[
    {
        "rel_file_path": "django/db/migrations/state.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/migrations/state.py",
        "start": 347,
        "end": 395,
        "class_name": "ProjectState",
        "method_name": "_find_reload_model",
        "code": "347     def _find_reload_model(self, app_label, model_name, delay=False):\n348         if delay:\n349             self.is_delayed = True\n350 \n351         related_models = set()\n352 \n353         try:\n354             old_model = self.apps.get_model(app_label, model_name)\n355         except LookupError:\n356             pass\n357         else:\n358             # Get all relations to and from the old model before reloading,\n359             # as _meta.apps may change\n360             if delay:\n361                 related_models = get_related_models_tuples(old_model)\n362             else:\n363                 related_models = get_related_models_recursive(old_model)\n364 \n365         # Get all outgoing references from the model to be rendered\n366         model_state = self.models[(app_label, model_name)]\n367         # Directly related models are the models pointed to by ForeignKeys,\n368         # OneToOneFields, and ManyToManyFields.\n369         direct_related_models = set()\n370         for field in model_state.fields.values():\n371             if field.is_relation:\n372                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:\n373                     continue\n374                 rel_app_label, rel_model_name = _get_app_label_and_model_name(\n375                     field.related_model, app_label\n376                 )\n377                 direct_related_models.add((rel_app_label, rel_model_name.lower()))\n378 \n379         # For all direct related models recursively get all related models.\n380         related_models.update(direct_related_models)\n381         for rel_app_label, rel_model_name in direct_related_models:\n382             try:\n383                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)\n384             except LookupError:\n385                 pass\n386             else:\n387                 if delay:\n388                     related_models.update(get_related_models_tuples(rel_model))\n389                 else:\n390                     related_models.update(get_related_models_recursive(rel_model))\n391 \n392         # Include the model itself\n393         related_models.add((app_label, model_name))\n394 \n395         return related_models\n",
        "intended_behavior": "The method should include improved logic to recognize and correctly handle changes to `ManyToManyField` relationships when they are altered to point to 'self'. This enhancement includes identifying this specific kind of relationship change during the migration state analysis and ensuring that any internal model references are updated accordingly to prevent operational errors related to missing columns in the database."
    },
    {
        "rel_file_path": "django/db/migrations/state.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/migrations/state.py",
        "start": 93,
        "end": 578,
        "class_name": "ProjectState",
        "method_name": null,
        "code": "93 class ProjectState:\n94     \"\"\"\n95     Represent the entire project's overall state. This is the item that is\n96     passed around - do it here rather than at the app level so that cross-app\n97     FKs/etc. resolve properly.\n98     \"\"\"\n99 \n100     def __init__(self, models=None, real_apps=None):\n101         self.models = models or {}\n102         # Apps to include from main registry, usually unmigrated ones\n103         if real_apps is None:\n104             real_apps = set()\n105         else:\n106             assert isinstance(real_apps, set)\n107         self.real_apps = real_apps\n108         self.is_delayed = False\n109         # {remote_model_key: {model_key: {field_name: field}}}\n110         self._relations = None\n111 \n112     @property\n113     def relations(self):\n114         if self._relations is None:\n115             self.resolve_fields_and_relations()\n116         return self._relations\n117 \n118     def add_model(self, model_state):\n119         model_key = model_state.app_label, model_state.name_lower\n120         self.models[model_key] = model_state\n121         if self._relations is not None:\n122             self.resolve_model_relations(model_key)\n123         if \"apps\" in self.__dict__:  # hasattr would cache the property\n124             self.reload_model(*model_key)\n125 \n126     def remove_model(self, app_label, model_name):\n127         model_key = app_label, model_name\n128         del self.models[model_key]\n129         if self._relations is not None:\n130             self._relations.pop(model_key, None)\n131             # Call list() since _relations can change size during iteration.\n132             for related_model_key, model_relations in list(self._relations.items()):\n133                 model_relations.pop(model_key, None)\n134                 if not model_relations:\n135                     del self._relations[related_model_key]\n136         if \"apps\" in self.__dict__:  # hasattr would cache the property\n137             self.apps.unregister_model(*model_key)\n138             # Need to do this explicitly since unregister_model() doesn't clear\n139             # the cache automatically (#24513)\n140             self.apps.clear_cache()\n141 \n142     def rename_model(self, app_label, old_name, new_name):\n143         # Add a new model.\n144         old_name_lower = old_name.lower()\n145         new_name_lower = new_name.lower()\n146         renamed_model = self.models[app_label, old_name_lower].clone()\n147         renamed_model.name = new_name\n148         self.models[app_label, new_name_lower] = renamed_model\n149         # Repoint all fields pointing to the old model to the new one.\n150         old_model_tuple = (app_label, old_name_lower)\n151         new_remote_model = f\"{app_label}.{new_name}\"\n152         to_reload = set()\n153         for model_state, name, field, reference in get_references(\n154             self, old_model_tuple\n155         ):\n156             changed_field = None\n157             if reference.to:\n158                 changed_field = field.clone()\n159                 changed_field.remote_field.model = new_remote_model\n160             if reference.through:\n161                 if changed_field is None:\n162                     changed_field = field.clone()\n163                 changed_field.remote_field.through = new_remote_model\n164             if changed_field:\n165                 model_state.fields[name] = changed_field\n166                 to_reload.add((model_state.app_label, model_state.name_lower))\n167         if self._relations is not None:\n168             old_name_key = app_label, old_name_lower\n169             new_name_key = app_label, new_name_lower\n170             if old_name_key in self._relations:\n171                 self._relations[new_name_key] = self._relations.pop(old_name_key)\n172             for model_relations in self._relations.values():\n173                 if old_name_key in model_relations:\n174                     model_relations[new_name_key] = model_relations.pop(old_name_key)\n175         # Reload models related to old model before removing the old model.\n176         self.reload_models(to_reload, delay=True)\n177         # Remove the old model.\n178         self.remove_model(app_label, old_name_lower)\n179         self.reload_model(app_label, new_name_lower, delay=True)\n180 \n181     def alter_model_options(self, app_label, model_name, options, option_keys=None):\n182         model_state = self.models[app_label, model_name]\n183         model_state.options = {**model_state.options, **options}\n184         if option_keys:\n185             for key in option_keys:\n186                 if key not in options:\n187                     model_state.options.pop(key, False)\n188         self.reload_model(app_label, model_name, delay=True)\n189 \n190     def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n191         model_state = self.models[app_label, model_name]\n192         if objs := model_state.options.get(option_name):\n193             model_state.options[option_name] = [\n194                 obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n195             ]\n196         self.reload_model(app_label, model_name, delay=True)\n197 \n198     def alter_model_managers(self, app_label, model_name, managers):\n199         model_state = self.models[app_label, model_name]\n200         model_state.managers = list(managers)\n201         self.reload_model(app_label, model_name, delay=True)\n202 \n203     def _append_option(self, app_label, model_name, option_name, obj):\n204         model_state = self.models[app_label, model_name]\n205         model_state.options[option_name] = [*model_state.options[option_name], obj]\n206         self.reload_model(app_label, model_name, delay=True)\n207 \n208     def _remove_option(self, app_label, model_name, option_name, obj_name):\n209         model_state = self.models[app_label, model_name]\n210         objs = model_state.options[option_name]\n211         model_state.options[option_name] = [obj for obj in objs if obj.name != obj_name]\n212         self.reload_model(app_label, model_name, delay=True)\n213 \n214     def add_index(self, app_label, model_name, index):\n215         self._append_option(app_label, model_name, \"indexes\", index)\n216 \n217     def remove_index(self, app_label, model_name, index_name):\n218         self._remove_option(app_label, model_name, \"indexes\", index_name)\n219 \n220     def rename_index(self, app_label, model_name, old_index_name, new_index_name):\n221         model_state = self.models[app_label, model_name]\n222         objs = model_state.options[\"indexes\"]\n223 \n224         new_indexes = []\n225         for obj in objs:\n226             if obj.name == old_index_name:\n227                 obj = obj.clone()\n228                 obj.name = new_index_name\n229             new_indexes.append(obj)\n230 \n231         model_state.options[\"indexes\"] = new_indexes\n232         self.reload_model(app_label, model_name, delay=True)\n233 \n234     def add_constraint(self, app_label, model_name, constraint):\n235         self._append_option(app_label, model_name, \"constraints\", constraint)\n236 \n237     def remove_constraint(self, app_label, model_name, constraint_name):\n238         self._remove_option(app_label, model_name, \"constraints\", constraint_name)\n239 \n240     def add_field(self, app_label, model_name, name, field, preserve_default):\n241         # If preserve default is off, don't use the default for future state.\n242         if not preserve_default:\n243             field = field.clone()\n244             field.default = NOT_PROVIDED\n245         else:\n246             field = field\n247         model_key = app_label, model_name\n248         self.models[model_key].fields[name] = field\n249         if self._relations is not None:\n250             self.resolve_model_field_relations(model_key, name, field)\n251         # Delay rendering of relationships if it's not a relational field.\n252         delay = not field.is_relation\n253         self.reload_model(*model_key, delay=delay)\n254 \n255     def remove_field(self, app_label, model_name, name):\n256         model_key = app_label, model_name\n257         model_state = self.models[model_key]\n258         old_field = model_state.fields.pop(name)\n259         if self._relations is not None:\n260             self.resolve_model_field_relations(model_key, name, old_field)\n261         # Delay rendering of relationships if it's not a relational field.\n262         delay = not old_field.is_relation\n263         self.reload_model(*model_key, delay=delay)\n264 \n265     def alter_field(self, app_label, model_name, name, field, preserve_default):\n266         if not preserve_default:\n267             field = field.clone()\n268             field.default = NOT_PROVIDED\n269         else:\n270             field = field\n271         model_key = app_label, model_name\n272         fields = self.models[model_key].fields\n273         if self._relations is not None:\n274             old_field = fields.pop(name)\n275             if old_field.is_relation:\n276                 self.resolve_model_field_relations(model_key, name, old_field)\n277             fields[name] = field\n278             if field.is_relation:\n279                 self.resolve_model_field_relations(model_key, name, field)\n280         else:\n281             fields[name] = field\n282         # TODO: investigate if old relational fields must be reloaded or if\n283         # it's sufficient if the new field is (#27737).\n284         # Delay rendering of relationships if it's not a relational field and\n285         # not referenced by a foreign key.\n286         delay = not field.is_relation and not field_is_referenced(\n287             self, model_key, (name, field)\n288         )\n289         self.reload_model(*model_key, delay=delay)\n290 \n291     def rename_field(self, app_label, model_name, old_name, new_name):\n292         model_key = app_label, model_name\n293         model_state = self.models[model_key]\n294         # Rename the field.\n295         fields = model_state.fields\n296         try:\n297             found = fields.pop(old_name)\n298         except KeyError:\n299             raise FieldDoesNotExist(\n300                 f\"{app_label}.{model_name} has no field named '{old_name}'\"\n301             )\n302         fields[new_name] = found\n303         for field in fields.values():\n304             # Fix from_fields to refer to the new field.\n305             from_fields = getattr(field, \"from_fields\", None)\n306             if from_fields:\n307                 field.from_fields = tuple(\n308                     [\n309                         new_name if from_field_name == old_name else from_field_name\n310                         for from_field_name in from_fields\n311                     ]\n312                 )\n313         # Fix index/unique_together to refer to the new field.\n314         options = model_state.options\n315         for option in (\"index_together\", \"unique_together\"):\n316             if option in options:\n317                 options[option] = [\n318                     [new_name if n == old_name else n for n in together]\n319                     for together in options[option]\n320                 ]\n321         # Fix to_fields to refer to the new field.\n322         delay = True\n323         references = get_references(self, model_key, (old_name, found))\n324         for *_, field, reference in references:\n325             delay = False\n326             if reference.to:\n327                 remote_field, to_fields = reference.to\n328                 if getattr(remote_field, \"field_name\", None) == old_name:\n329                     remote_field.field_name = new_name\n330                 if to_fields:\n331                     field.to_fields = tuple(\n332                         [\n333                             new_name if to_field_name == old_name else to_field_name\n334                             for to_field_name in to_fields\n335                         ]\n336                     )\n337         if self._relations is not None:\n338             old_name_lower = old_name.lower()\n339             new_name_lower = new_name.lower()\n340             for to_model in self._relations.values():\n341                 if old_name_lower in to_model[model_key]:\n342                     field = to_model[model_key].pop(old_name_lower)\n343                     field.name = new_name_lower\n344                     to_model[model_key][new_name_lower] = field\n345         self.reload_model(*model_key, delay=delay)\n346 \n347     def _find_reload_model(self, app_label, model_name, delay=False):\n348         if delay:\n349             self.is_delayed = True\n350 \n351         related_models = set()\n352 \n353         try:\n354             old_model = self.apps.get_model(app_label, model_name)\n355         except LookupError:\n356             pass\n357         else:\n358             # Get all relations to and from the old model before reloading,\n359             # as _meta.apps may change\n360             if delay:\n361                 related_models = get_related_models_tuples(old_model)\n362             else:\n363                 related_models = get_related_models_recursive(old_model)\n364 \n365         # Get all outgoing references from the model to be rendered\n366         model_state = self.models[(app_label, model_name)]\n367         # Directly related models are the models pointed to by ForeignKeys,\n368         # OneToOneFields, and ManyToManyFields.\n369         direct_related_models = set()\n370         for field in model_state.fields.values():\n371             if field.is_relation:\n372                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:\n373                     continue\n374                 rel_app_label, rel_model_name = _get_app_label_and_model_name(\n375                     field.related_model, app_label\n376                 )\n377                 direct_related_models.add((rel_app_label, rel_model_name.lower()))\n378 \n379         # For all direct related models recursively get all related models.\n380         related_models.update(direct_related_models)\n381         for rel_app_label, rel_model_name in direct_related_models:\n382             try:\n383                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)\n384             except LookupError:\n385                 pass\n386             else:\n387                 if delay:\n388                     related_models.update(get_related_models_tuples(rel_model))\n389                 else:\n390                     related_models.update(get_related_models_recursive(rel_model))\n391 \n392         # Include the model itself\n393         related_models.add((app_label, model_name))\n394 \n395         return related_models\n396 \n397     def reload_model(self, app_label, model_name, delay=False):\n398         if \"apps\" in self.__dict__:  # hasattr would cache the property\n399             related_models = self._find_reload_model(app_label, model_name, delay)\n400             self._reload(related_models)\n401 \n402     def reload_models(self, models, delay=True):\n403         if \"apps\" in self.__dict__:  # hasattr would cache the property\n404             related_models = set()\n405             for app_label, model_name in models:\n406                 related_models.update(\n407                     self._find_reload_model(app_label, model_name, delay)\n408                 )\n409             self._reload(related_models)\n410 \n411     def _reload(self, related_models):\n412         # Unregister all related models\n413         with self.apps.bulk_update():\n414             for rel_app_label, rel_model_name in related_models:\n415                 self.apps.unregister_model(rel_app_label, rel_model_name)\n416 \n417         states_to_be_rendered = []\n418         # Gather all models states of those models that will be rerendered.\n419         # This includes:\n420         # 1. All related models of unmigrated apps\n421         for model_state in self.apps.real_models:\n422             if (model_state.app_label, model_state.name_lower) in related_models:\n423                 states_to_be_rendered.append(model_state)\n424 \n425         # 2. All related models of migrated apps\n426         for rel_app_label, rel_model_name in related_models:\n427             try:\n428                 model_state = self.models[rel_app_label, rel_model_name]\n429             except KeyError:\n430                 pass\n431             else:\n432                 states_to_be_rendered.append(model_state)\n433 \n434         # Render all models\n435         self.apps.render_multiple(states_to_be_rendered)\n436 \n437     def update_model_field_relation(\n438         self,\n439         model,\n440         model_key,\n441         field_name,\n442         field,\n443         concretes,\n444     ):\n445         remote_model_key = resolve_relation(model, *model_key)\n446         if remote_model_key[0] not in self.real_apps and remote_model_key in concretes:\n447             remote_model_key = concretes[remote_model_key]\n448         relations_to_remote_model = self._relations[remote_model_key]\n449         if field_name in self.models[model_key].fields:\n450             # The assert holds because it's a new relation, or an altered\n451             # relation, in which case references have been removed by\n452             # alter_field().\n453             assert field_name not in relations_to_remote_model[model_key]\n454             relations_to_remote_model[model_key][field_name] = field\n455         else:\n456             del relations_to_remote_model[model_key][field_name]\n457             if not relations_to_remote_model[model_key]:\n458                 del relations_to_remote_model[model_key]\n459 \n460     def resolve_model_field_relations(\n461         self,\n462         model_key,\n463         field_name,\n464         field,\n465         concretes=None,\n466     ):\n467         remote_field = field.remote_field\n468         if not remote_field:\n469             return\n470         if concretes is None:\n471             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()\n472 \n473         self.update_model_field_relation(\n474             remote_field.model,\n475             model_key,\n476             field_name,\n477             field,\n478             concretes,\n479         )\n480 \n481         through = getattr(remote_field, \"through\", None)\n482         if not through:\n483             return\n484         self.update_model_field_relation(\n485             through, model_key, field_name, field, concretes\n486         )\n487 \n488     def resolve_model_relations(self, model_key, concretes=None):\n489         if concretes is None:\n490             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()\n491 \n492         model_state = self.models[model_key]\n493         for field_name, field in model_state.fields.items():\n494             self.resolve_model_field_relations(model_key, field_name, field, concretes)\n495 \n496     def resolve_fields_and_relations(self):\n497         # Resolve fields.\n498         for model_state in self.models.values():\n499             for field_name, field in model_state.fields.items():\n500                 field.name = field_name\n501         # Resolve relations.\n502         # {remote_model_key: {model_key: {field_name: field}}}\n503         self._relations = defaultdict(partial(defaultdict, dict))\n504         concretes, proxies = self._get_concrete_models_mapping_and_proxy_models()\n505 \n506         for model_key in concretes:\n507             self.resolve_model_relations(model_key, concretes)\n508 \n509         for model_key in proxies:\n510             self._relations[model_key] = self._relations[concretes[model_key]]\n511 \n512     def get_concrete_model_key(self, model):\n513         (\n514             concrete_models_mapping,\n515             _,\n516         ) = self._get_concrete_models_mapping_and_proxy_models()\n517         model_key = make_model_tuple(model)\n518         return concrete_models_mapping[model_key]\n519 \n520     def _get_concrete_models_mapping_and_proxy_models(self):\n521         concrete_models_mapping = {}\n522         proxy_models = {}\n523         # Split models to proxy and concrete models.\n524         for model_key, model_state in self.models.items():\n525             if model_state.options.get(\"proxy\"):\n526                 proxy_models[model_key] = model_state\n527                 # Find a concrete model for the proxy.\n528                 concrete_models_mapping[\n529                     model_key\n530                 ] = self._find_concrete_model_from_proxy(\n531                     proxy_models,\n532                     model_state,\n533                 )\n534             else:\n535                 concrete_models_mapping[model_key] = model_key\n536         return concrete_models_mapping, proxy_models\n537 \n538     def _find_concrete_model_from_proxy(self, proxy_models, model_state):\n539         for base in model_state.bases:\n540             if not (isinstance(base, str) or issubclass(base, models.Model)):\n541                 continue\n542             base_key = make_model_tuple(base)\n543             base_state = proxy_models.get(base_key)\n544             if not base_state:\n545                 # Concrete model found, stop looking at bases.\n546                 return base_key\n547             return self._find_concrete_model_from_proxy(proxy_models, base_state)\n548 \n549     def clone(self):\n550         \"\"\"Return an exact copy of this ProjectState.\"\"\"\n551         new_state = ProjectState(\n552             models={k: v.clone() for k, v in self.models.items()},\n553             real_apps=self.real_apps,\n554         )\n555         if \"apps\" in self.__dict__:\n556             new_state.apps = self.apps.clone()\n557         new_state.is_delayed = self.is_delayed\n558         return new_state\n559 \n560     def clear_delayed_apps_cache(self):\n561         if self.is_delayed and \"apps\" in self.__dict__:\n562             del self.__dict__[\"apps\"]\n563 \n564     @cached_property\n565     def apps(self):\n566         return StateApps(self.real_apps, self.models)\n567 \n568     @classmethod\n569     def from_apps(cls, apps):\n570         \"\"\"Take an Apps and return a ProjectState matching it.\"\"\"\n571         app_models = {}\n572         for model in apps.get_models(include_swapped=True):\n573             model_state = ModelState.from_model(model)\n574             app_models[(model_state.app_label, model_state.name_lower)] = model_state\n575         return cls(app_models)\n576 \n577     def __eq__(self, other):\n578         return self.models == other.models and self.real_apps == other.real_apps\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/db/models/fields/related.py",
        "start": 1,
        "end": 1993,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 from functools import partial\n4 \n5 from django import forms\n6 from django.apps import apps\n7 from django.conf import SettingsReference, settings\n8 from django.core import checks, exceptions\n9 from django.db import connection, router\n10 from django.db.backends import utils\n11 from django.db.models import Q\n12 from django.db.models.constants import LOOKUP_SEP\n13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14 from django.db.models.query_utils import PathInfo\n15 from django.db.models.utils import make_model_tuple\n16 from django.utils.functional import cached_property\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 from . import Field\n20 from .mixins import FieldCacheMixin\n21 from .related_descriptors import (\n22     ForeignKeyDeferredAttribute,\n23     ForwardManyToOneDescriptor,\n24     ForwardOneToOneDescriptor,\n25     ManyToManyDescriptor,\n26     ReverseManyToOneDescriptor,\n27     ReverseOneToOneDescriptor,\n28 )\n29 from .related_lookups import (\n30     RelatedExact,\n31     RelatedGreaterThan,\n32     RelatedGreaterThanOrEqual,\n33     RelatedIn,\n34     RelatedIsNull,\n35     RelatedLessThan,\n36     RelatedLessThanOrEqual,\n37 )\n38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel\n39 \n40 RECURSIVE_RELATIONSHIP_CONSTANT = \"self\"\n41 \n42 \n43 def resolve_relation(scope_model, relation):\n44     \"\"\"\n45     Transform relation into a model or fully-qualified model string of the form\n46     \"app_label.ModelName\", relative to scope_model.\n47 \n48     The relation argument can be:\n49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n50         the model argument will be returned.\n51       * A bare model name without an app_label, in which case scope_model's\n52         app_label will be prepended.\n53       * An \"app_label.ModelName\" string.\n54       * A model class, which will be returned unchanged.\n55     \"\"\"\n56     # Check for recursive relations\n57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n58         relation = scope_model\n59 \n60     # Look for an \"app.Model\" relation\n61     if isinstance(relation, str):\n62         if \".\" not in relation:\n63             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n64 \n65     return relation\n66 \n67 \n68 def lazy_related_operation(function, model, *related_models, **kwargs):\n69     \"\"\"\n70     Schedule `function` to be called once `model` and all `related_models`\n71     have been imported and registered with the app registry. `function` will\n72     be called with the newly-loaded model classes as its positional arguments,\n73     plus any optional keyword arguments.\n74 \n75     The `model` argument must be a model class. Each subsequent positional\n76     argument is another model, or a reference to another model - see\n77     `resolve_relation()` for the various forms these may take. Any relative\n78     references will be resolved relative to `model`.\n79 \n80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n81     registry model used is the one found in `model._meta.apps`.\n82     \"\"\"\n83     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n84     model_keys = (make_model_tuple(m) for m in models)\n85     apps = model._meta.apps\n86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n87 \n88 \n89 class RelatedField(FieldCacheMixin, Field):\n90     \"\"\"Base class that all relational fields inherit from.\"\"\"\n91 \n92     # Field flags\n93     one_to_many = False\n94     one_to_one = False\n95     many_to_many = False\n96     many_to_one = False\n97 \n98     def __init__(\n99         self,\n100         related_name=None,\n101         related_query_name=None,\n102         limit_choices_to=None,\n103         **kwargs,\n104     ):\n105         self._related_name = related_name\n106         self._related_query_name = related_query_name\n107         self._limit_choices_to = limit_choices_to\n108         super().__init__(**kwargs)\n109 \n110     @cached_property\n111     def related_model(self):\n112         # Can't cache this property until all the models are loaded.\n113         apps.check_models_ready()\n114         return self.remote_field.model\n115 \n116     def check(self, **kwargs):\n117         return [\n118             *super().check(**kwargs),\n119             *self._check_related_name_is_valid(),\n120             *self._check_related_query_name_is_valid(),\n121             *self._check_relation_model_exists(),\n122             *self._check_referencing_to_swapped_model(),\n123             *self._check_clashes(),\n124         ]\n125 \n126     def _check_related_name_is_valid(self):\n127         import keyword\n128 \n129         related_name = self.remote_field.related_name\n130         if related_name is None:\n131             return []\n132         is_valid_id = (\n133             not keyword.iskeyword(related_name) and related_name.isidentifier()\n134         )\n135         if not (is_valid_id or related_name.endswith(\"+\")):\n136             return [\n137                 checks.Error(\n138                     \"The name '%s' is invalid related_name for field %s.%s\"\n139                     % (\n140                         self.remote_field.related_name,\n141                         self.model._meta.object_name,\n142                         self.name,\n143                     ),\n144                     hint=(\n145                         \"Related name must be a valid Python identifier or end with a \"\n146                         \"'+'\"\n147                     ),\n148                     obj=self,\n149                     id=\"fields.E306\",\n150                 )\n151             ]\n152         return []\n153 \n154     def _check_related_query_name_is_valid(self):\n155         if self.remote_field.is_hidden():\n156             return []\n157         rel_query_name = self.related_query_name()\n158         errors = []\n159         if rel_query_name.endswith(\"_\"):\n160             errors.append(\n161                 checks.Error(\n162                     \"Reverse query name '%s' must not end with an underscore.\"\n163                     % rel_query_name,\n164                     hint=(\n165                         \"Add or change a related_name or related_query_name \"\n166                         \"argument for this field.\"\n167                     ),\n168                     obj=self,\n169                     id=\"fields.E308\",\n170                 )\n171             )\n172         if LOOKUP_SEP in rel_query_name:\n173             errors.append(\n174                 checks.Error(\n175                     \"Reverse query name '%s' must not contain '%s'.\"\n176                     % (rel_query_name, LOOKUP_SEP),\n177                     hint=(\n178                         \"Add or change a related_name or related_query_name \"\n179                         \"argument for this field.\"\n180                     ),\n181                     obj=self,\n182                     id=\"fields.E309\",\n183                 )\n184             )\n185         return errors\n186 \n187     def _check_relation_model_exists(self):\n188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n189         rel_is_string = isinstance(self.remote_field.model, str)\n190         model_name = (\n191             self.remote_field.model\n192             if rel_is_string\n193             else self.remote_field.model._meta.object_name\n194         )\n195         if rel_is_missing and (\n196             rel_is_string or not self.remote_field.model._meta.swapped\n197         ):\n198             return [\n199                 checks.Error(\n200                     \"Field defines a relation with model '%s', which is either \"\n201                     \"not installed, or is abstract.\" % model_name,\n202                     obj=self,\n203                     id=\"fields.E300\",\n204                 )\n205             ]\n206         return []\n207 \n208     def _check_referencing_to_swapped_model(self):\n209         if (\n210             self.remote_field.model not in self.opts.apps.get_models()\n211             and not isinstance(self.remote_field.model, str)\n212             and self.remote_field.model._meta.swapped\n213         ):\n214             return [\n215                 checks.Error(\n216                     \"Field defines a relation with the model '%s', which has \"\n217                     \"been swapped out.\" % self.remote_field.model._meta.label,\n218                     hint=\"Update the relation to point at 'settings.%s'.\"\n219                     % self.remote_field.model._meta.swappable,\n220                     obj=self,\n221                     id=\"fields.E301\",\n222                 )\n223             ]\n224         return []\n225 \n226     def _check_clashes(self):\n227         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n228         from django.db.models.base import ModelBase\n229 \n230         errors = []\n231         opts = self.model._meta\n232 \n233         # f.remote_field.model may be a string instead of a model. Skip if\n234         # model name is not resolved.\n235         if not isinstance(self.remote_field.model, ModelBase):\n236             return []\n237 \n238         # Consider that we are checking field `Model.foreign` and the models\n239         # are:\n240         #\n241         #     class Target(models.Model):\n242         #         model = models.IntegerField()\n243         #         model_set = models.IntegerField()\n244         #\n245         #     class Model(models.Model):\n246         #         foreign = models.ForeignKey(Target)\n247         #         m2m = models.ManyToManyField(Target)\n248 \n249         # rel_opts.object_name == \"Target\"\n250         rel_opts = self.remote_field.model._meta\n251         # If the field doesn't install a backward relation on the target model\n252         # (so `is_hidden` returns True), then there are no clashes to check\n253         # and we can skip these fields.\n254         rel_is_hidden = self.remote_field.is_hidden()\n255         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n256         rel_query_name = self.related_query_name()  # i. e. \"model\"\n257         # i.e. \"app_label.Model.field\".\n258         field_name = \"%s.%s\" % (opts.label, self.name)\n259 \n260         # Check clashes between accessor or reverse query name of `field`\n261         # and any other field name -- i.e. accessor for Model.foreign is\n262         # model_set and it clashes with Target.model_set.\n263         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n264         for clash_field in potential_clashes:\n265             # i.e. \"app_label.Target.model_set\".\n266             clash_name = \"%s.%s\" % (rel_opts.label, clash_field.name)\n267             if not rel_is_hidden and clash_field.name == rel_name:\n268                 errors.append(\n269                     checks.Error(\n270                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n271                         f\"for '{field_name}' clashes with field name \"\n272                         f\"'{clash_name}'.\",\n273                         hint=(\n274                             \"Rename field '%s', or add/change a related_name \"\n275                             \"argument to the definition for field '%s'.\"\n276                         )\n277                         % (clash_name, field_name),\n278                         obj=self,\n279                         id=\"fields.E302\",\n280                     )\n281                 )\n282 \n283             if clash_field.name == rel_query_name:\n284                 errors.append(\n285                     checks.Error(\n286                         \"Reverse query name for '%s' clashes with field name '%s'.\"\n287                         % (field_name, clash_name),\n288                         hint=(\n289                             \"Rename field '%s', or add/change a related_name \"\n290                             \"argument to the definition for field '%s'.\"\n291                         )\n292                         % (clash_name, field_name),\n293                         obj=self,\n294                         id=\"fields.E303\",\n295                     )\n296                 )\n297 \n298         # Check clashes between accessors/reverse query names of `field` and\n299         # any other field accessor -- i. e. Model.foreign accessor clashes with\n300         # Model.m2m accessor.\n301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n302         for clash_field in potential_clashes:\n303             # i.e. \"app_label.Model.m2m\".\n304             clash_name = \"%s.%s\" % (\n305                 clash_field.related_model._meta.label,\n306                 clash_field.field.name,\n307             )\n308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n309                 errors.append(\n310                     checks.Error(\n311                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n312                         f\"for '{field_name}' clashes with reverse accessor for \"\n313                         f\"'{clash_name}'.\",\n314                         hint=(\n315                             \"Add or change a related_name argument \"\n316                             \"to the definition for '%s' or '%s'.\"\n317                         )\n318                         % (field_name, clash_name),\n319                         obj=self,\n320                         id=\"fields.E304\",\n321                     )\n322                 )\n323 \n324             if clash_field.get_accessor_name() == rel_query_name:\n325                 errors.append(\n326                     checks.Error(\n327                         \"Reverse query name for '%s' clashes with reverse query name \"\n328                         \"for '%s'.\" % (field_name, clash_name),\n329                         hint=(\n330                             \"Add or change a related_name argument \"\n331                             \"to the definition for '%s' or '%s'.\"\n332                         )\n333                         % (field_name, clash_name),\n334                         obj=self,\n335                         id=\"fields.E305\",\n336                     )\n337                 )\n338 \n339         return errors\n340 \n341     def db_type(self, connection):\n342         # By default related field will not have a column as it relates to\n343         # columns from another table.\n344         return None\n345 \n346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n347 \n348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n349 \n350         self.opts = cls._meta\n351 \n352         if not cls._meta.abstract:\n353             if self.remote_field.related_name:\n354                 related_name = self.remote_field.related_name\n355             else:\n356                 related_name = self.opts.default_related_name\n357             if related_name:\n358                 related_name %= {\n359                     \"class\": cls.__name__.lower(),\n360                     \"model_name\": cls._meta.model_name.lower(),\n361                     \"app_label\": cls._meta.app_label.lower(),\n362                 }\n363                 self.remote_field.related_name = related_name\n364 \n365             if self.remote_field.related_query_name:\n366                 related_query_name = self.remote_field.related_query_name % {\n367                     \"class\": cls.__name__.lower(),\n368                     \"app_label\": cls._meta.app_label.lower(),\n369                 }\n370                 self.remote_field.related_query_name = related_query_name\n371 \n372             def resolve_related_class(model, related, field):\n373                 field.remote_field.model = related\n374                 field.do_related_class(related, model)\n375 \n376             lazy_related_operation(\n377                 resolve_related_class, cls, self.remote_field.model, field=self\n378             )\n379 \n380     def deconstruct(self):\n381         name, path, args, kwargs = super().deconstruct()\n382         if self._limit_choices_to:\n383             kwargs[\"limit_choices_to\"] = self._limit_choices_to\n384         if self._related_name is not None:\n385             kwargs[\"related_name\"] = self._related_name\n386         if self._related_query_name is not None:\n387             kwargs[\"related_query_name\"] = self._related_query_name\n388         return name, path, args, kwargs\n389 \n390     def get_forward_related_filter(self, obj):\n391         \"\"\"\n392         Return the keyword arguments that when supplied to\n393         self.model.object.filter(), would select all instances related through\n394         this field to the remote obj. This is used to build the querysets\n395         returned by related descriptors. obj is an instance of\n396         self.related_field.model.\n397         \"\"\"\n398         return {\n399             \"%s__%s\" % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n400             for _, rh_field in self.related_fields\n401         }\n402 \n403     def get_reverse_related_filter(self, obj):\n404         \"\"\"\n405         Complement to get_forward_related_filter(). Return the keyword\n406         arguments that when passed to self.related_field.model.object.filter()\n407         select all instances of self.related_field.model related through\n408         this field to obj. obj is an instance of self.model.\n409         \"\"\"\n410         base_q = Q.create(\n411             [\n412                 (rh_field.attname, getattr(obj, lh_field.attname))\n413                 for lh_field, rh_field in self.related_fields\n414             ]\n415         )\n416         descriptor_filter = self.get_extra_descriptor_filter(obj)\n417         if isinstance(descriptor_filter, dict):\n418             return base_q & Q(**descriptor_filter)\n419         elif descriptor_filter:\n420             return base_q & descriptor_filter\n421         return base_q\n422 \n423     @property\n424     def swappable_setting(self):\n425         \"\"\"\n426         Get the setting that this is powered from for swapping, or None\n427         if it's not swapped in / marked with swappable=False.\n428         \"\"\"\n429         if self.swappable:\n430             # Work out string form of \"to\"\n431             if isinstance(self.remote_field.model, str):\n432                 to_string = self.remote_field.model\n433             else:\n434                 to_string = self.remote_field.model._meta.label\n435             return apps.get_swappable_settings_name(to_string)\n436         return None\n437 \n438     def set_attributes_from_rel(self):\n439         self.name = self.name or (\n440             self.remote_field.model._meta.model_name\n441             + \"_\"\n442             + self.remote_field.model._meta.pk.name\n443         )\n444         if self.verbose_name is None:\n445             self.verbose_name = self.remote_field.model._meta.verbose_name\n446         self.remote_field.set_field_name()\n447 \n448     def do_related_class(self, other, cls):\n449         self.set_attributes_from_rel()\n450         self.contribute_to_related_class(other, self.remote_field)\n451 \n452     def get_limit_choices_to(self):\n453         \"\"\"\n454         Return ``limit_choices_to`` for this model field.\n455 \n456         If it is a callable, it will be invoked and the result will be\n457         returned.\n458         \"\"\"\n459         if callable(self.remote_field.limit_choices_to):\n460             return self.remote_field.limit_choices_to()\n461         return self.remote_field.limit_choices_to\n462 \n463     def formfield(self, **kwargs):\n464         \"\"\"\n465         Pass ``limit_choices_to`` to the field being constructed.\n466 \n467         Only passes it if there is a type that supports related fields.\n468         This is a similar strategy used to pass the ``queryset`` to the field\n469         being constructed.\n470         \"\"\"\n471         defaults = {}\n472         if hasattr(self.remote_field, \"get_related_field\"):\n473             # If this is a callable, do not invoke it here. Just pass\n474             # it in the defaults for when the form class will later be\n475             # instantiated.\n476             limit_choices_to = self.remote_field.limit_choices_to\n477             defaults.update(\n478                 {\n479                     \"limit_choices_to\": limit_choices_to,\n480                 }\n481             )\n482         defaults.update(kwargs)\n483         return super().formfield(**defaults)\n484 \n485     def related_query_name(self):\n486         \"\"\"\n487         Define the name that can be used to identify this related object in a\n488         table-spanning query.\n489         \"\"\"\n490         return (\n491             self.remote_field.related_query_name\n492             or self.remote_field.related_name\n493             or self.opts.model_name\n494         )\n495 \n496     @property\n497     def target_field(self):\n498         \"\"\"\n499         When filtering against this relation, return the field on the remote\n500         model against which the filtering should happen.\n501         \"\"\"\n502         target_fields = self.path_infos[-1].target_fields\n503         if len(target_fields) > 1:\n504             raise exceptions.FieldError(\n505                 \"The relation has multiple target fields, but only single target field \"\n506                 \"was asked for\"\n507             )\n508         return target_fields[0]\n509 \n510     def get_cache_name(self):\n511         return self.name\n512 \n513 \n514 class ForeignObject(RelatedField):\n515     \"\"\"\n516     Abstraction of the ForeignKey relation to support multi-column relations.\n517     \"\"\"\n518 \n519     # Field flags\n520     many_to_many = False\n521     many_to_one = True\n522     one_to_many = False\n523     one_to_one = False\n524 \n525     requires_unique_target = True\n526     related_accessor_class = ReverseManyToOneDescriptor\n527     forward_related_accessor_class = ForwardManyToOneDescriptor\n528     rel_class = ForeignObjectRel\n529 \n530     def __init__(\n531         self,\n532         to,\n533         on_delete,\n534         from_fields,\n535         to_fields,\n536         rel=None,\n537         related_name=None,\n538         related_query_name=None,\n539         limit_choices_to=None,\n540         parent_link=False,\n541         swappable=True,\n542         **kwargs,\n543     ):\n544 \n545         if rel is None:\n546             rel = self.rel_class(\n547                 self,\n548                 to,\n549                 related_name=related_name,\n550                 related_query_name=related_query_name,\n551                 limit_choices_to=limit_choices_to,\n552                 parent_link=parent_link,\n553                 on_delete=on_delete,\n554             )\n555 \n556         super().__init__(\n557             rel=rel,\n558             related_name=related_name,\n559             related_query_name=related_query_name,\n560             limit_choices_to=limit_choices_to,\n561             **kwargs,\n562         )\n563 \n564         self.from_fields = from_fields\n565         self.to_fields = to_fields\n566         self.swappable = swappable\n567 \n568     def __copy__(self):\n569         obj = super().__copy__()\n570         # Remove any cached PathInfo values.\n571         obj.__dict__.pop(\"path_infos\", None)\n572         obj.__dict__.pop(\"reverse_path_infos\", None)\n573         return obj\n574 \n575     def check(self, **kwargs):\n576         return [\n577             *super().check(**kwargs),\n578             *self._check_to_fields_exist(),\n579             *self._check_unique_target(),\n580         ]\n581 \n582     def _check_to_fields_exist(self):\n583         # Skip nonexistent models.\n584         if isinstance(self.remote_field.model, str):\n585             return []\n586 \n587         errors = []\n588         for to_field in self.to_fields:\n589             if to_field:\n590                 try:\n591                     self.remote_field.model._meta.get_field(to_field)\n592                 except exceptions.FieldDoesNotExist:\n593                     errors.append(\n594                         checks.Error(\n595                             \"The to_field '%s' doesn't exist on the related \"\n596                             \"model '%s'.\"\n597                             % (to_field, self.remote_field.model._meta.label),\n598                             obj=self,\n599                             id=\"fields.E312\",\n600                         )\n601                     )\n602         return errors\n603 \n604     def _check_unique_target(self):\n605         rel_is_string = isinstance(self.remote_field.model, str)\n606         if rel_is_string or not self.requires_unique_target:\n607             return []\n608 \n609         try:\n610             self.foreign_related_fields\n611         except exceptions.FieldDoesNotExist:\n612             return []\n613 \n614         if not self.foreign_related_fields:\n615             return []\n616 \n617         unique_foreign_fields = {\n618             frozenset([f.name])\n619             for f in self.remote_field.model._meta.get_fields()\n620             if getattr(f, \"unique\", False)\n621         }\n622         unique_foreign_fields.update(\n623             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}\n624         )\n625         unique_foreign_fields.update(\n626             {\n627                 frozenset(uc.fields)\n628                 for uc in self.remote_field.model._meta.total_unique_constraints\n629             }\n630         )\n631         foreign_fields = {f.name for f in self.foreign_related_fields}\n632         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n633 \n634         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n635             field_combination = \", \".join(\n636                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n637             )\n638             model_name = self.remote_field.model.__name__\n639             return [\n640                 checks.Error(\n641                     \"No subset of the fields %s on model '%s' is unique.\"\n642                     % (field_combination, model_name),\n643                     hint=(\n644                         \"Mark a single field as unique=True or add a set of \"\n645                         \"fields to a unique constraint (via unique_together \"\n646                         \"or a UniqueConstraint (without condition) in the \"\n647                         \"model Meta.constraints).\"\n648                     ),\n649                     obj=self,\n650                     id=\"fields.E310\",\n651                 )\n652             ]\n653         elif not has_unique_constraint:\n654             field_name = self.foreign_related_fields[0].name\n655             model_name = self.remote_field.model.__name__\n656             return [\n657                 checks.Error(\n658                     \"'%s.%s' must be unique because it is referenced by \"\n659                     \"a foreign key.\" % (model_name, field_name),\n660                     hint=(\n661                         \"Add unique=True to this field or add a \"\n662                         \"UniqueConstraint (without condition) in the model \"\n663                         \"Meta.constraints.\"\n664                     ),\n665                     obj=self,\n666                     id=\"fields.E311\",\n667                 )\n668             ]\n669         else:\n670             return []\n671 \n672     def deconstruct(self):\n673         name, path, args, kwargs = super().deconstruct()\n674         kwargs[\"on_delete\"] = self.remote_field.on_delete\n675         kwargs[\"from_fields\"] = self.from_fields\n676         kwargs[\"to_fields\"] = self.to_fields\n677 \n678         if self.remote_field.parent_link:\n679             kwargs[\"parent_link\"] = self.remote_field.parent_link\n680         if isinstance(self.remote_field.model, str):\n681             if \".\" in self.remote_field.model:\n682                 app_label, model_name = self.remote_field.model.split(\".\")\n683                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n684             else:\n685                 kwargs[\"to\"] = self.remote_field.model.lower()\n686         else:\n687             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n688         # If swappable is True, then see if we're actually pointing to the target\n689         # of a swap.\n690         swappable_setting = self.swappable_setting\n691         if swappable_setting is not None:\n692             # If it's already a settings reference, error\n693             if hasattr(kwargs[\"to\"], \"setting_name\"):\n694                 if kwargs[\"to\"].setting_name != swappable_setting:\n695                     raise ValueError(\n696                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n697                         \"that is swapped in place of more than one model (%s and %s)\"\n698                         % (kwargs[\"to\"].setting_name, swappable_setting)\n699                     )\n700             # Set it\n701             kwargs[\"to\"] = SettingsReference(\n702                 kwargs[\"to\"],\n703                 swappable_setting,\n704             )\n705         return name, path, args, kwargs\n706 \n707     def resolve_related_fields(self):\n708         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n709             raise ValueError(\n710                 \"Foreign Object from and to fields must be the same non-zero length\"\n711             )\n712         if isinstance(self.remote_field.model, str):\n713             raise ValueError(\n714                 \"Related model %r cannot be resolved\" % self.remote_field.model\n715             )\n716         related_fields = []\n717         for index in range(len(self.from_fields)):\n718             from_field_name = self.from_fields[index]\n719             to_field_name = self.to_fields[index]\n720             from_field = (\n721                 self\n722                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n723                 else self.opts.get_field(from_field_name)\n724             )\n725             to_field = (\n726                 self.remote_field.model._meta.pk\n727                 if to_field_name is None\n728                 else self.remote_field.model._meta.get_field(to_field_name)\n729             )\n730             related_fields.append((from_field, to_field))\n731         return related_fields\n732 \n733     @cached_property\n734     def related_fields(self):\n735         return self.resolve_related_fields()\n736 \n737     @cached_property\n738     def reverse_related_fields(self):\n739         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n740 \n741     @cached_property\n742     def local_related_fields(self):\n743         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n744 \n745     @cached_property\n746     def foreign_related_fields(self):\n747         return tuple(\n748             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field\n749         )\n750 \n751     def get_local_related_value(self, instance):\n752         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n753 \n754     def get_foreign_related_value(self, instance):\n755         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n756 \n757     @staticmethod\n758     def get_instance_value_for_fields(instance, fields):\n759         ret = []\n760         opts = instance._meta\n761         for field in fields:\n762             # Gotcha: in some cases (like fixture loading) a model can have\n763             # different values in parent_ptr_id and parent's id. So, use\n764             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n765             if field.primary_key:\n766                 possible_parent_link = opts.get_ancestor_link(field.model)\n767                 if (\n768                     not possible_parent_link\n769                     or possible_parent_link.primary_key\n770                     or possible_parent_link.model._meta.abstract\n771                 ):\n772                     ret.append(instance.pk)\n773                     continue\n774             ret.append(getattr(instance, field.attname))\n775         return tuple(ret)\n776 \n777     def get_attname_column(self):\n778         attname, column = super().get_attname_column()\n779         return attname, None\n780 \n781     def get_joining_columns(self, reverse_join=False):\n782         source = self.reverse_related_fields if reverse_join else self.related_fields\n783         return tuple(\n784             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source\n785         )\n786 \n787     def get_reverse_joining_columns(self):\n788         return self.get_joining_columns(reverse_join=True)\n789 \n790     def get_extra_descriptor_filter(self, instance):\n791         \"\"\"\n792         Return an extra filter condition for related object fetching when\n793         user does 'instance.fieldname', that is the extra filter is used in\n794         the descriptor of the field.\n795 \n796         The filter should be either a dict usable in .filter(**kwargs) call or\n797         a Q-object. The condition will be ANDed together with the relation's\n798         joining columns.\n799 \n800         A parallel method is get_extra_restriction() which is used in\n801         JOIN and subquery conditions.\n802         \"\"\"\n803         return {}\n804 \n805     def get_extra_restriction(self, alias, related_alias):\n806         \"\"\"\n807         Return a pair condition used for joining and subquery pushdown. The\n808         condition is something that responds to as_sql(compiler, connection)\n809         method.\n810 \n811         Note that currently referring both the 'alias' and 'related_alias'\n812         will not work in some conditions, like subquery pushdown.\n813 \n814         A parallel method is get_extra_descriptor_filter() which is used in\n815         instance.fieldname related object fetching.\n816         \"\"\"\n817         return None\n818 \n819     def get_path_info(self, filtered_relation=None):\n820         \"\"\"Get path from this field to the related model.\"\"\"\n821         opts = self.remote_field.model._meta\n822         from_opts = self.model._meta\n823         return [\n824             PathInfo(\n825                 from_opts=from_opts,\n826                 to_opts=opts,\n827                 target_fields=self.foreign_related_fields,\n828                 join_field=self,\n829                 m2m=False,\n830                 direct=True,\n831                 filtered_relation=filtered_relation,\n832             )\n833         ]\n834 \n835     @cached_property\n836     def path_infos(self):\n837         return self.get_path_info()\n838 \n839     def get_reverse_path_info(self, filtered_relation=None):\n840         \"\"\"Get path from the related model to this field's model.\"\"\"\n841         opts = self.model._meta\n842         from_opts = self.remote_field.model._meta\n843         return [\n844             PathInfo(\n845                 from_opts=from_opts,\n846                 to_opts=opts,\n847                 target_fields=(opts.pk,),\n848                 join_field=self.remote_field,\n849                 m2m=not self.unique,\n850                 direct=False,\n851                 filtered_relation=filtered_relation,\n852             )\n853         ]\n854 \n855     @cached_property\n856     def reverse_path_infos(self):\n857         return self.get_reverse_path_info()\n858 \n859     @classmethod\n860     @functools.lru_cache(maxsize=None)\n861     def get_class_lookups(cls):\n862         bases = inspect.getmro(cls)\n863         bases = bases[: bases.index(ForeignObject) + 1]\n864         class_lookups = [parent.__dict__.get(\"class_lookups\", {}) for parent in bases]\n865         return cls.merge_dicts(class_lookups)\n866 \n867     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n868         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n869         setattr(cls, self.name, self.forward_related_accessor_class(self))\n870 \n871     def contribute_to_related_class(self, cls, related):\n872         # Internal FK's - i.e., those with a related name ending with '+' -\n873         # and swapped models don't get a related descriptor.\n874         if (\n875             not self.remote_field.is_hidden()\n876             and not related.related_model._meta.swapped\n877         ):\n878             setattr(\n879                 cls._meta.concrete_model,\n880                 related.get_accessor_name(),\n881                 self.related_accessor_class(related),\n882             )\n883             # While 'limit_choices_to' might be a callable, simply pass\n884             # it along for later - this is too early because it's still\n885             # model load time.\n886             if self.remote_field.limit_choices_to:\n887                 cls._meta.related_fkey_lookups.append(\n888                     self.remote_field.limit_choices_to\n889                 )\n890 \n891 \n892 ForeignObject.register_lookup(RelatedIn)\n893 ForeignObject.register_lookup(RelatedExact)\n894 ForeignObject.register_lookup(RelatedLessThan)\n895 ForeignObject.register_lookup(RelatedGreaterThan)\n896 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n897 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n898 ForeignObject.register_lookup(RelatedIsNull)\n899 \n900 \n901 class ForeignKey(ForeignObject):\n902     \"\"\"\n903     Provide a many-to-one relation by adding a column to the local model\n904     to hold the remote value.\n905 \n906     By default ForeignKey will target the pk of the remote model but this\n907     behavior can be changed by using the ``to_field`` argument.\n908     \"\"\"\n909 \n910     descriptor_class = ForeignKeyDeferredAttribute\n911     # Field flags\n912     many_to_many = False\n913     many_to_one = True\n914     one_to_many = False\n915     one_to_one = False\n916 \n917     rel_class = ManyToOneRel\n918 \n919     empty_strings_allowed = False\n920     default_error_messages = {\n921         \"invalid\": _(\"%(model)s instance with %(field)s %(value)r does not exist.\")\n922     }\n923     description = _(\"Foreign Key (type determined by related field)\")\n924 \n925     def __init__(\n926         self,\n927         to,\n928         on_delete,\n929         related_name=None,\n930         related_query_name=None,\n931         limit_choices_to=None,\n932         parent_link=False,\n933         to_field=None,\n934         db_constraint=True,\n935         **kwargs,\n936     ):\n937         try:\n938             to._meta.model_name\n939         except AttributeError:\n940             if not isinstance(to, str):\n941                 raise TypeError(\n942                     \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n943                     \"either a model, a model name, or the string %r\"\n944                     % (\n945                         self.__class__.__name__,\n946                         to,\n947                         RECURSIVE_RELATIONSHIP_CONSTANT,\n948                     )\n949                 )\n950         else:\n951             # For backwards compatibility purposes, we need to *try* and set\n952             # the to_field during FK construction. It won't be guaranteed to\n953             # be correct until contribute_to_class is called. Refs #12190.\n954             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n955         if not callable(on_delete):\n956             raise TypeError(\"on_delete must be callable.\")\n957 \n958         kwargs[\"rel\"] = self.rel_class(\n959             self,\n960             to,\n961             to_field,\n962             related_name=related_name,\n963             related_query_name=related_query_name,\n964             limit_choices_to=limit_choices_to,\n965             parent_link=parent_link,\n966             on_delete=on_delete,\n967         )\n968         kwargs.setdefault(\"db_index\", True)\n969 \n970         super().__init__(\n971             to,\n972             on_delete,\n973             related_name=related_name,\n974             related_query_name=related_query_name,\n975             limit_choices_to=limit_choices_to,\n976             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n977             to_fields=[to_field],\n978             **kwargs,\n979         )\n980         self.db_constraint = db_constraint\n981 \n982     def __class_getitem__(cls, *args, **kwargs):\n983         return cls\n984 \n985     def check(self, **kwargs):\n986         return [\n987             *super().check(**kwargs),\n988             *self._check_on_delete(),\n989             *self._check_unique(),\n990         ]\n991 \n992     def _check_on_delete(self):\n993         on_delete = getattr(self.remote_field, \"on_delete\", None)\n994         if on_delete == SET_NULL and not self.null:\n995             return [\n996                 checks.Error(\n997                     \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n998                     hint=(\n999                         \"Set null=True argument on the field, or change the on_delete \"\n1000                         \"rule.\"\n1001                     ),\n1002                     obj=self,\n1003                     id=\"fields.E320\",\n1004                 )\n1005             ]\n1006         elif on_delete == SET_DEFAULT and not self.has_default():\n1007             return [\n1008                 checks.Error(\n1009                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n1010                     hint=\"Set a default value, or change the on_delete rule.\",\n1011                     obj=self,\n1012                     id=\"fields.E321\",\n1013                 )\n1014             ]\n1015         else:\n1016             return []\n1017 \n1018     def _check_unique(self, **kwargs):\n1019         return (\n1020             [\n1021                 checks.Warning(\n1022                     \"Setting unique=True on a ForeignKey has the same effect as using \"\n1023                     \"a OneToOneField.\",\n1024                     hint=(\n1025                         \"ForeignKey(unique=True) is usually better served by a \"\n1026                         \"OneToOneField.\"\n1027                     ),\n1028                     obj=self,\n1029                     id=\"fields.W342\",\n1030                 )\n1031             ]\n1032             if self.unique\n1033             else []\n1034         )\n1035 \n1036     def deconstruct(self):\n1037         name, path, args, kwargs = super().deconstruct()\n1038         del kwargs[\"to_fields\"]\n1039         del kwargs[\"from_fields\"]\n1040         # Handle the simpler arguments\n1041         if self.db_index:\n1042             del kwargs[\"db_index\"]\n1043         else:\n1044             kwargs[\"db_index\"] = False\n1045         if self.db_constraint is not True:\n1046             kwargs[\"db_constraint\"] = self.db_constraint\n1047         # Rel needs more work.\n1048         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n1049         if self.remote_field.field_name and (\n1050             not to_meta\n1051             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)\n1052         ):\n1053             kwargs[\"to_field\"] = self.remote_field.field_name\n1054         return name, path, args, kwargs\n1055 \n1056     def to_python(self, value):\n1057         return self.target_field.to_python(value)\n1058 \n1059     @property\n1060     def target_field(self):\n1061         return self.foreign_related_fields[0]\n1062 \n1063     def get_reverse_path_info(self, filtered_relation=None):\n1064         \"\"\"Get path from the related model to this field's model.\"\"\"\n1065         opts = self.model._meta\n1066         from_opts = self.remote_field.model._meta\n1067         return [\n1068             PathInfo(\n1069                 from_opts=from_opts,\n1070                 to_opts=opts,\n1071                 target_fields=(opts.pk,),\n1072                 join_field=self.remote_field,\n1073                 m2m=not self.unique,\n1074                 direct=False,\n1075                 filtered_relation=filtered_relation,\n1076             )\n1077         ]\n1078 \n1079     def validate(self, value, model_instance):\n1080         if self.remote_field.parent_link:\n1081             return\n1082         super().validate(value, model_instance)\n1083         if value is None:\n1084             return\n1085 \n1086         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n1087         qs = self.remote_field.model._base_manager.using(using).filter(\n1088             **{self.remote_field.field_name: value}\n1089         )\n1090         qs = qs.complex_filter(self.get_limit_choices_to())\n1091         if not qs.exists():\n1092             raise exceptions.ValidationError(\n1093                 self.error_messages[\"invalid\"],\n1094                 code=\"invalid\",\n1095                 params={\n1096                     \"model\": self.remote_field.model._meta.verbose_name,\n1097                     \"pk\": value,\n1098                     \"field\": self.remote_field.field_name,\n1099                     \"value\": value,\n1100                 },  # 'pk' is included for backwards compatibility\n1101             )\n1102 \n1103     def resolve_related_fields(self):\n1104         related_fields = super().resolve_related_fields()\n1105         for from_field, to_field in related_fields:\n1106             if (\n1107                 to_field\n1108                 and to_field.model != self.remote_field.model._meta.concrete_model\n1109             ):\n1110                 raise exceptions.FieldError(\n1111                     \"'%s.%s' refers to field '%s' which is not local to model \"\n1112                     \"'%s'.\"\n1113                     % (\n1114                         self.model._meta.label,\n1115                         self.name,\n1116                         to_field.name,\n1117                         self.remote_field.model._meta.concrete_model._meta.label,\n1118                     )\n1119                 )\n1120         return related_fields\n1121 \n1122     def get_attname(self):\n1123         return \"%s_id\" % self.name\n1124 \n1125     def get_attname_column(self):\n1126         attname = self.get_attname()\n1127         column = self.db_column or attname\n1128         return attname, column\n1129 \n1130     def get_default(self):\n1131         \"\"\"Return the to_field if the default value is an object.\"\"\"\n1132         field_default = super().get_default()\n1133         if isinstance(field_default, self.remote_field.model):\n1134             return getattr(field_default, self.target_field.attname)\n1135         return field_default\n1136 \n1137     def get_db_prep_save(self, value, connection):\n1138         if value is None or (\n1139             value == \"\"\n1140             and (\n1141                 not self.target_field.empty_strings_allowed\n1142                 or connection.features.interprets_empty_strings_as_nulls\n1143             )\n1144         ):\n1145             return None\n1146         else:\n1147             return self.target_field.get_db_prep_save(value, connection=connection)\n1148 \n1149     def get_db_prep_value(self, value, connection, prepared=False):\n1150         return self.target_field.get_db_prep_value(value, connection, prepared)\n1151 \n1152     def get_prep_value(self, value):\n1153         return self.target_field.get_prep_value(value)\n1154 \n1155     def contribute_to_related_class(self, cls, related):\n1156         super().contribute_to_related_class(cls, related)\n1157         if self.remote_field.field_name is None:\n1158             self.remote_field.field_name = cls._meta.pk.name\n1159 \n1160     def formfield(self, *, using=None, **kwargs):\n1161         if isinstance(self.remote_field.model, str):\n1162             raise ValueError(\n1163                 \"Cannot create form field for %r yet, because \"\n1164                 \"its related model %r has not been loaded yet\"\n1165                 % (self.name, self.remote_field.model)\n1166             )\n1167         return super().formfield(\n1168             **{\n1169                 \"form_class\": forms.ModelChoiceField,\n1170                 \"queryset\": self.remote_field.model._default_manager.using(using),\n1171                 \"to_field_name\": self.remote_field.field_name,\n1172                 **kwargs,\n1173                 \"blank\": self.blank,\n1174             }\n1175         )\n1176 \n1177     def db_check(self, connection):\n1178         return None\n1179 \n1180     def db_type(self, connection):\n1181         return self.target_field.rel_db_type(connection=connection)\n1182 \n1183     def db_parameters(self, connection):\n1184         target_db_parameters = self.target_field.db_parameters(connection)\n1185         return {\n1186             \"type\": self.db_type(connection),\n1187             \"check\": self.db_check(connection),\n1188             \"collation\": target_db_parameters.get(\"collation\"),\n1189         }\n1190 \n1191     def convert_empty_strings(self, value, expression, connection):\n1192         if (not value) and isinstance(value, str):\n1193             return None\n1194         return value\n1195 \n1196     def get_db_converters(self, connection):\n1197         converters = super().get_db_converters(connection)\n1198         if connection.features.interprets_empty_strings_as_nulls:\n1199             converters += [self.convert_empty_strings]\n1200         return converters\n1201 \n1202     def get_col(self, alias, output_field=None):\n1203         if output_field is None:\n1204             output_field = self.target_field\n1205             while isinstance(output_field, ForeignKey):\n1206                 output_field = output_field.target_field\n1207                 if output_field is self:\n1208                     raise ValueError(\"Cannot resolve output_field.\")\n1209         return super().get_col(alias, output_field)\n1210 \n1211 \n1212 class OneToOneField(ForeignKey):\n1213     \"\"\"\n1214     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1215     that it always carries a \"unique\" constraint with it and the reverse\n1216     relation always returns the object pointed to (since there will only ever\n1217     be one), rather than returning a list.\n1218     \"\"\"\n1219 \n1220     # Field flags\n1221     many_to_many = False\n1222     many_to_one = False\n1223     one_to_many = False\n1224     one_to_one = True\n1225 \n1226     related_accessor_class = ReverseOneToOneDescriptor\n1227     forward_related_accessor_class = ForwardOneToOneDescriptor\n1228     rel_class = OneToOneRel\n1229 \n1230     description = _(\"One-to-one relationship\")\n1231 \n1232     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1233         kwargs[\"unique\"] = True\n1234         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1235 \n1236     def deconstruct(self):\n1237         name, path, args, kwargs = super().deconstruct()\n1238         if \"unique\" in kwargs:\n1239             del kwargs[\"unique\"]\n1240         return name, path, args, kwargs\n1241 \n1242     def formfield(self, **kwargs):\n1243         if self.remote_field.parent_link:\n1244             return None\n1245         return super().formfield(**kwargs)\n1246 \n1247     def save_form_data(self, instance, data):\n1248         if isinstance(data, self.remote_field.model):\n1249             setattr(instance, self.name, data)\n1250         else:\n1251             setattr(instance, self.attname, data)\n1252             # Remote field object must be cleared otherwise Model.save()\n1253             # will reassign attname using the related object pk.\n1254             if data is None:\n1255                 setattr(instance, self.name, data)\n1256 \n1257     def _check_unique(self, **kwargs):\n1258         # Override ForeignKey since check isn't applicable here.\n1259         return []\n1260 \n1261 \n1262 def create_many_to_many_intermediary_model(field, klass):\n1263     from django.db import models\n1264 \n1265     def set_managed(model, related, through):\n1266         through._meta.managed = model._meta.managed or related._meta.managed\n1267 \n1268     to_model = resolve_relation(klass, field.remote_field.model)\n1269     name = \"%s_%s\" % (klass._meta.object_name, field.name)\n1270     lazy_related_operation(set_managed, klass, to_model, name)\n1271 \n1272     to = make_model_tuple(to_model)[1]\n1273     from_ = klass._meta.model_name\n1274     if to == from_:\n1275         to = \"to_%s\" % to\n1276         from_ = \"from_%s\" % from_\n1277 \n1278     meta = type(\n1279         \"Meta\",\n1280         (),\n1281         {\n1282             \"db_table\": field._get_m2m_db_table(klass._meta),\n1283             \"auto_created\": klass,\n1284             \"app_label\": klass._meta.app_label,\n1285             \"db_tablespace\": klass._meta.db_tablespace,\n1286             \"unique_together\": (from_, to),\n1287             \"verbose_name\": _(\"%(from)s-%(to)s relationship\")\n1288             % {\"from\": from_, \"to\": to},\n1289             \"verbose_name_plural\": _(\"%(from)s-%(to)s relationships\")\n1290             % {\"from\": from_, \"to\": to},\n1291             \"apps\": field.model._meta.apps,\n1292         },\n1293     )\n1294     # Construct and return the new class.\n1295     return type(\n1296         name,\n1297         (models.Model,),\n1298         {\n1299             \"Meta\": meta,\n1300             \"__module__\": klass.__module__,\n1301             from_: models.ForeignKey(\n1302                 klass,\n1303                 related_name=\"%s+\" % name,\n1304                 db_tablespace=field.db_tablespace,\n1305                 db_constraint=field.remote_field.db_constraint,\n1306                 on_delete=CASCADE,\n1307             ),\n1308             to: models.ForeignKey(\n1309                 to_model,\n1310                 related_name=\"%s+\" % name,\n1311                 db_tablespace=field.db_tablespace,\n1312                 db_constraint=field.remote_field.db_constraint,\n1313                 on_delete=CASCADE,\n1314             ),\n1315         },\n1316     )\n1317 \n1318 \n1319 class ManyToManyField(RelatedField):\n1320     \"\"\"\n1321     Provide a many-to-many relation by using an intermediary model that\n1322     holds two ForeignKey fields pointed at the two sides of the relation.\n1323 \n1324     Unless a ``through`` model was provided, ManyToManyField will use the\n1325     create_many_to_many_intermediary_model factory to automatically generate\n1326     the intermediary model.\n1327     \"\"\"\n1328 \n1329     # Field flags\n1330     many_to_many = True\n1331     many_to_one = False\n1332     one_to_many = False\n1333     one_to_one = False\n1334 \n1335     rel_class = ManyToManyRel\n1336 \n1337     description = _(\"Many-to-many relationship\")\n1338 \n1339     def __init__(\n1340         self,\n1341         to,\n1342         related_name=None,\n1343         related_query_name=None,\n1344         limit_choices_to=None,\n1345         symmetrical=None,\n1346         through=None,\n1347         through_fields=None,\n1348         db_constraint=True,\n1349         db_table=None,\n1350         swappable=True,\n1351         **kwargs,\n1352     ):\n1353         try:\n1354             to._meta\n1355         except AttributeError:\n1356             if not isinstance(to, str):\n1357                 raise TypeError(\n1358                     \"%s(%r) is invalid. First parameter to ManyToManyField \"\n1359                     \"must be either a model, a model name, or the string %r\"\n1360                     % (\n1361                         self.__class__.__name__,\n1362                         to,\n1363                         RECURSIVE_RELATIONSHIP_CONSTANT,\n1364                     )\n1365                 )\n1366 \n1367         if symmetrical is None:\n1368             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT\n1369 \n1370         if through is not None and db_table is not None:\n1371             raise ValueError(\n1372                 \"Cannot specify a db_table if an intermediary model is used.\"\n1373             )\n1374 \n1375         kwargs[\"rel\"] = self.rel_class(\n1376             self,\n1377             to,\n1378             related_name=related_name,\n1379             related_query_name=related_query_name,\n1380             limit_choices_to=limit_choices_to,\n1381             symmetrical=symmetrical,\n1382             through=through,\n1383             through_fields=through_fields,\n1384             db_constraint=db_constraint,\n1385         )\n1386         self.has_null_arg = \"null\" in kwargs\n1387 \n1388         super().__init__(\n1389             related_name=related_name,\n1390             related_query_name=related_query_name,\n1391             limit_choices_to=limit_choices_to,\n1392             **kwargs,\n1393         )\n1394 \n1395         self.db_table = db_table\n1396         self.swappable = swappable\n1397 \n1398     def check(self, **kwargs):\n1399         return [\n1400             *super().check(**kwargs),\n1401             *self._check_unique(**kwargs),\n1402             *self._check_relationship_model(**kwargs),\n1403             *self._check_ignored_options(**kwargs),\n1404             *self._check_table_uniqueness(**kwargs),\n1405         ]\n1406 \n1407     def _check_unique(self, **kwargs):\n1408         if self.unique:\n1409             return [\n1410                 checks.Error(\n1411                     \"ManyToManyFields cannot be unique.\",\n1412                     obj=self,\n1413                     id=\"fields.E330\",\n1414                 )\n1415             ]\n1416         return []\n1417 \n1418     def _check_ignored_options(self, **kwargs):\n1419         warnings = []\n1420 \n1421         if self.has_null_arg:\n1422             warnings.append(\n1423                 checks.Warning(\n1424                     \"null has no effect on ManyToManyField.\",\n1425                     obj=self,\n1426                     id=\"fields.W340\",\n1427                 )\n1428             )\n1429 \n1430         if self._validators:\n1431             warnings.append(\n1432                 checks.Warning(\n1433                     \"ManyToManyField does not support validators.\",\n1434                     obj=self,\n1435                     id=\"fields.W341\",\n1436                 )\n1437             )\n1438         if self.remote_field.symmetrical and self._related_name:\n1439             warnings.append(\n1440                 checks.Warning(\n1441                     \"related_name has no effect on ManyToManyField \"\n1442                     'with a symmetrical relationship, e.g. to \"self\".',\n1443                     obj=self,\n1444                     id=\"fields.W345\",\n1445                 )\n1446             )\n1447 \n1448         return warnings\n1449 \n1450     def _check_relationship_model(self, from_model=None, **kwargs):\n1451         if hasattr(self.remote_field.through, \"_meta\"):\n1452             qualified_model_name = \"%s.%s\" % (\n1453                 self.remote_field.through._meta.app_label,\n1454                 self.remote_field.through.__name__,\n1455             )\n1456         else:\n1457             qualified_model_name = self.remote_field.through\n1458 \n1459         errors = []\n1460 \n1461         if self.remote_field.through not in self.opts.apps.get_models(\n1462             include_auto_created=True\n1463         ):\n1464             # The relationship model is not installed.\n1465             errors.append(\n1466                 checks.Error(\n1467                     \"Field specifies a many-to-many relation through model \"\n1468                     \"'%s', which has not been installed.\" % qualified_model_name,\n1469                     obj=self,\n1470                     id=\"fields.E331\",\n1471                 )\n1472             )\n1473 \n1474         else:\n1475             assert from_model is not None, (\n1476                 \"ManyToManyField with intermediate \"\n1477                 \"tables cannot be checked if you don't pass the model \"\n1478                 \"where the field is attached to.\"\n1479             )\n1480             # Set some useful local variables\n1481             to_model = resolve_relation(from_model, self.remote_field.model)\n1482             from_model_name = from_model._meta.object_name\n1483             if isinstance(to_model, str):\n1484                 to_model_name = to_model\n1485             else:\n1486                 to_model_name = to_model._meta.object_name\n1487             relationship_model_name = self.remote_field.through._meta.object_name\n1488             self_referential = from_model == to_model\n1489             # Count foreign keys in intermediate model\n1490             if self_referential:\n1491                 seen_self = sum(\n1492                     from_model == getattr(field.remote_field, \"model\", None)\n1493                     for field in self.remote_field.through._meta.fields\n1494                 )\n1495 \n1496                 if seen_self > 2 and not self.remote_field.through_fields:\n1497                     errors.append(\n1498                         checks.Error(\n1499                             \"The model is used as an intermediate model by \"\n1500                             \"'%s', but it has more than two foreign keys \"\n1501                             \"to '%s', which is ambiguous. You must specify \"\n1502                             \"which two foreign keys Django should use via the \"\n1503                             \"through_fields keyword argument.\"\n1504                             % (self, from_model_name),\n1505                             hint=(\n1506                                 \"Use through_fields to specify which two foreign keys \"\n1507                                 \"Django should use.\"\n1508                             ),\n1509                             obj=self.remote_field.through,\n1510                             id=\"fields.E333\",\n1511                         )\n1512                     )\n1513 \n1514             else:\n1515                 # Count foreign keys in relationship model\n1516                 seen_from = sum(\n1517                     from_model == getattr(field.remote_field, \"model\", None)\n1518                     for field in self.remote_field.through._meta.fields\n1519                 )\n1520                 seen_to = sum(\n1521                     to_model == getattr(field.remote_field, \"model\", None)\n1522                     for field in self.remote_field.through._meta.fields\n1523                 )\n1524 \n1525                 if seen_from > 1 and not self.remote_field.through_fields:\n1526                     errors.append(\n1527                         checks.Error(\n1528                             (\n1529                                 \"The model is used as an intermediate model by \"\n1530                                 \"'%s', but it has more than one foreign key \"\n1531                                 \"from '%s', which is ambiguous. You must specify \"\n1532                                 \"which foreign key Django should use via the \"\n1533                                 \"through_fields keyword argument.\"\n1534                             )\n1535                             % (self, from_model_name),\n1536                             hint=(\n1537                                 \"If you want to create a recursive relationship, \"\n1538                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1539                             )\n1540                             % (\n1541                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1542                                 relationship_model_name,\n1543                             ),\n1544                             obj=self,\n1545                             id=\"fields.E334\",\n1546                         )\n1547                     )\n1548 \n1549                 if seen_to > 1 and not self.remote_field.through_fields:\n1550                     errors.append(\n1551                         checks.Error(\n1552                             \"The model is used as an intermediate model by \"\n1553                             \"'%s', but it has more than one foreign key \"\n1554                             \"to '%s', which is ambiguous. You must specify \"\n1555                             \"which foreign key Django should use via the \"\n1556                             \"through_fields keyword argument.\" % (self, to_model_name),\n1557                             hint=(\n1558                                 \"If you want to create a recursive relationship, \"\n1559                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1560                             )\n1561                             % (\n1562                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1563                                 relationship_model_name,\n1564                             ),\n1565                             obj=self,\n1566                             id=\"fields.E335\",\n1567                         )\n1568                     )\n1569 \n1570                 if seen_from == 0 or seen_to == 0:\n1571                     errors.append(\n1572                         checks.Error(\n1573                             \"The model is used as an intermediate model by \"\n1574                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\"\n1575                             % (self, from_model_name, to_model_name),\n1576                             obj=self.remote_field.through,\n1577                             id=\"fields.E336\",\n1578                         )\n1579                     )\n1580 \n1581         # Validate `through_fields`.\n1582         if self.remote_field.through_fields is not None:\n1583             # Validate that we're given an iterable of at least two items\n1584             # and that none of them is \"falsy\".\n1585             if not (\n1586                 len(self.remote_field.through_fields) >= 2\n1587                 and self.remote_field.through_fields[0]\n1588                 and self.remote_field.through_fields[1]\n1589             ):\n1590                 errors.append(\n1591                     checks.Error(\n1592                         \"Field specifies 'through_fields' but does not provide \"\n1593                         \"the names of the two link fields that should be used \"\n1594                         \"for the relation through model '%s'.\" % qualified_model_name,\n1595                         hint=(\n1596                             \"Make sure you specify 'through_fields' as \"\n1597                             \"through_fields=('field1', 'field2')\"\n1598                         ),\n1599                         obj=self,\n1600                         id=\"fields.E337\",\n1601                     )\n1602                 )\n1603 \n1604             # Validate the given through fields -- they should be actual\n1605             # fields on the through model, and also be foreign keys to the\n1606             # expected models.\n1607             else:\n1608                 assert from_model is not None, (\n1609                     \"ManyToManyField with intermediate \"\n1610                     \"tables cannot be checked if you don't pass the model \"\n1611                     \"where the field is attached to.\"\n1612                 )\n1613 \n1614                 source, through, target = (\n1615                     from_model,\n1616                     self.remote_field.through,\n1617                     self.remote_field.model,\n1618                 )\n1619                 source_field_name, target_field_name = self.remote_field.through_fields[\n1620                     :2\n1621                 ]\n1622 \n1623                 for field_name, related_model in (\n1624                     (source_field_name, source),\n1625                     (target_field_name, target),\n1626                 ):\n1627 \n1628                     possible_field_names = []\n1629                     for f in through._meta.fields:\n1630                         if (\n1631                             hasattr(f, \"remote_field\")\n1632                             and getattr(f.remote_field, \"model\", None) == related_model\n1633                         ):\n1634                             possible_field_names.append(f.name)\n1635                     if possible_field_names:\n1636                         hint = (\n1637                             \"Did you mean one of the following foreign keys to '%s': \"\n1638                             \"%s?\"\n1639                             % (\n1640                                 related_model._meta.object_name,\n1641                                 \", \".join(possible_field_names),\n1642                             )\n1643                         )\n1644                     else:\n1645                         hint = None\n1646 \n1647                     try:\n1648                         field = through._meta.get_field(field_name)\n1649                     except exceptions.FieldDoesNotExist:\n1650                         errors.append(\n1651                             checks.Error(\n1652                                 \"The intermediary model '%s' has no field '%s'.\"\n1653                                 % (qualified_model_name, field_name),\n1654                                 hint=hint,\n1655                                 obj=self,\n1656                                 id=\"fields.E338\",\n1657                             )\n1658                         )\n1659                     else:\n1660                         if not (\n1661                             hasattr(field, \"remote_field\")\n1662                             and getattr(field.remote_field, \"model\", None)\n1663                             == related_model\n1664                         ):\n1665                             errors.append(\n1666                                 checks.Error(\n1667                                     \"'%s.%s' is not a foreign key to '%s'.\"\n1668                                     % (\n1669                                         through._meta.object_name,\n1670                                         field_name,\n1671                                         related_model._meta.object_name,\n1672                                     ),\n1673                                     hint=hint,\n1674                                     obj=self,\n1675                                     id=\"fields.E339\",\n1676                                 )\n1677                             )\n1678 \n1679         return errors\n1680 \n1681     def _check_table_uniqueness(self, **kwargs):\n1682         if (\n1683             isinstance(self.remote_field.through, str)\n1684             or not self.remote_field.through._meta.managed\n1685         ):\n1686             return []\n1687         registered_tables = {\n1688             model._meta.db_table: model\n1689             for model in self.opts.apps.get_models(include_auto_created=True)\n1690             if model != self.remote_field.through and model._meta.managed\n1691         }\n1692         m2m_db_table = self.m2m_db_table()\n1693         model = registered_tables.get(m2m_db_table)\n1694         # The second condition allows multiple m2m relations on a model if\n1695         # some point to a through model that proxies another through model.\n1696         if (\n1697             model\n1698             and model._meta.concrete_model\n1699             != self.remote_field.through._meta.concrete_model\n1700         ):\n1701             if model._meta.auto_created:\n1702 \n1703                 def _get_field_name(model):\n1704                     for field in model._meta.auto_created._meta.many_to_many:\n1705                         if field.remote_field.through is model:\n1706                             return field.name\n1707 \n1708                 opts = model._meta.auto_created._meta\n1709                 clashing_obj = \"%s.%s\" % (opts.label, _get_field_name(model))\n1710             else:\n1711                 clashing_obj = model._meta.label\n1712             if settings.DATABASE_ROUTERS:\n1713                 error_class, error_id = checks.Warning, \"fields.W344\"\n1714                 error_hint = (\n1715                     \"You have configured settings.DATABASE_ROUTERS. Verify \"\n1716                     \"that the table of %r is correctly routed to a separate \"\n1717                     \"database.\" % clashing_obj\n1718                 )\n1719             else:\n1720                 error_class, error_id = checks.Error, \"fields.E340\"\n1721                 error_hint = None\n1722             return [\n1723                 error_class(\n1724                     \"The field's intermediary table '%s' clashes with the \"\n1725                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1726                     obj=self,\n1727                     hint=error_hint,\n1728                     id=error_id,\n1729                 )\n1730             ]\n1731         return []\n1732 \n1733     def deconstruct(self):\n1734         name, path, args, kwargs = super().deconstruct()\n1735         # Handle the simpler arguments.\n1736         if self.db_table is not None:\n1737             kwargs[\"db_table\"] = self.db_table\n1738         if self.remote_field.db_constraint is not True:\n1739             kwargs[\"db_constraint\"] = self.remote_field.db_constraint\n1740         # Lowercase model names as they should be treated as case-insensitive.\n1741         if isinstance(self.remote_field.model, str):\n1742             if \".\" in self.remote_field.model:\n1743                 app_label, model_name = self.remote_field.model.split(\".\")\n1744                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n1745             else:\n1746                 kwargs[\"to\"] = self.remote_field.model.lower()\n1747         else:\n1748             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n1749         if getattr(self.remote_field, \"through\", None) is not None:\n1750             if isinstance(self.remote_field.through, str):\n1751                 kwargs[\"through\"] = self.remote_field.through\n1752             elif not self.remote_field.through._meta.auto_created:\n1753                 kwargs[\"through\"] = self.remote_field.through._meta.label\n1754         # If swappable is True, then see if we're actually pointing to the target\n1755         # of a swap.\n1756         swappable_setting = self.swappable_setting\n1757         if swappable_setting is not None:\n1758             # If it's already a settings reference, error.\n1759             if hasattr(kwargs[\"to\"], \"setting_name\"):\n1760                 if kwargs[\"to\"].setting_name != swappable_setting:\n1761                     raise ValueError(\n1762                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1763                         \"model that is swapped in place of more than one model \"\n1764                         \"(%s and %s)\" % (kwargs[\"to\"].setting_name, swappable_setting)\n1765                     )\n1766 \n1767             kwargs[\"to\"] = SettingsReference(\n1768                 kwargs[\"to\"],\n1769                 swappable_setting,\n1770             )\n1771         return name, path, args, kwargs\n1772 \n1773     def _get_path_info(self, direct=False, filtered_relation=None):\n1774         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1775         int_model = self.remote_field.through\n1776         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1777         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1778         if direct:\n1779             join1infos = linkfield1.reverse_path_infos\n1780             if filtered_relation:\n1781                 join2infos = linkfield2.get_path_info(filtered_relation)\n1782             else:\n1783                 join2infos = linkfield2.path_infos\n1784         else:\n1785             join1infos = linkfield2.reverse_path_infos\n1786             if filtered_relation:\n1787                 join2infos = linkfield1.get_path_info(filtered_relation)\n1788             else:\n1789                 join2infos = linkfield1.path_infos\n1790         # Get join infos between the last model of join 1 and the first model\n1791         # of join 2. Assume the only reason these may differ is due to model\n1792         # inheritance.\n1793         join1_final = join1infos[-1].to_opts\n1794         join2_initial = join2infos[0].from_opts\n1795         if join1_final is join2_initial:\n1796             intermediate_infos = []\n1797         elif issubclass(join1_final.model, join2_initial.model):\n1798             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1799         else:\n1800             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1801 \n1802         return [*join1infos, *intermediate_infos, *join2infos]\n1803 \n1804     def get_path_info(self, filtered_relation=None):\n1805         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1806 \n1807     @cached_property\n1808     def path_infos(self):\n1809         return self.get_path_info()\n1810 \n1811     def get_reverse_path_info(self, filtered_relation=None):\n1812         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1813 \n1814     @cached_property\n1815     def reverse_path_infos(self):\n1816         return self.get_reverse_path_info()\n1817 \n1818     def _get_m2m_db_table(self, opts):\n1819         \"\"\"\n1820         Function that can be curried to provide the m2m table name for this\n1821         relation.\n1822         \"\"\"\n1823         if self.remote_field.through is not None:\n1824             return self.remote_field.through._meta.db_table\n1825         elif self.db_table:\n1826             return self.db_table\n1827         else:\n1828             m2m_table_name = \"%s_%s\" % (utils.strip_quotes(opts.db_table), self.name)\n1829             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1830 \n1831     def _get_m2m_attr(self, related, attr):\n1832         \"\"\"\n1833         Function that can be curried to provide the source accessor or DB\n1834         column name for the m2m table.\n1835         \"\"\"\n1836         cache_attr = \"_m2m_%s_cache\" % attr\n1837         if hasattr(self, cache_attr):\n1838             return getattr(self, cache_attr)\n1839         if self.remote_field.through_fields is not None:\n1840             link_field_name = self.remote_field.through_fields[0]\n1841         else:\n1842             link_field_name = None\n1843         for f in self.remote_field.through._meta.fields:\n1844             if (\n1845                 f.is_relation\n1846                 and f.remote_field.model == related.related_model\n1847                 and (link_field_name is None or link_field_name == f.name)\n1848             ):\n1849                 setattr(self, cache_attr, getattr(f, attr))\n1850                 return getattr(self, cache_attr)\n1851 \n1852     def _get_m2m_reverse_attr(self, related, attr):\n1853         \"\"\"\n1854         Function that can be curried to provide the related accessor or DB\n1855         column name for the m2m table.\n1856         \"\"\"\n1857         cache_attr = \"_m2m_reverse_%s_cache\" % attr\n1858         if hasattr(self, cache_attr):\n1859             return getattr(self, cache_attr)\n1860         found = False\n1861         if self.remote_field.through_fields is not None:\n1862             link_field_name = self.remote_field.through_fields[1]\n1863         else:\n1864             link_field_name = None\n1865         for f in self.remote_field.through._meta.fields:\n1866             if f.is_relation and f.remote_field.model == related.model:\n1867                 if link_field_name is None and related.related_model == related.model:\n1868                     # If this is an m2m-intermediate to self,\n1869                     # the first foreign key you find will be\n1870                     # the source column. Keep searching for\n1871                     # the second foreign key.\n1872                     if found:\n1873                         setattr(self, cache_attr, getattr(f, attr))\n1874                         break\n1875                     else:\n1876                         found = True\n1877                 elif link_field_name is None or link_field_name == f.name:\n1878                     setattr(self, cache_attr, getattr(f, attr))\n1879                     break\n1880         return getattr(self, cache_attr)\n1881 \n1882     def contribute_to_class(self, cls, name, **kwargs):\n1883         # To support multiple relations to self, it's useful to have a non-None\n1884         # related name on symmetrical relations for internal reasons. The\n1885         # concept doesn't make a lot of sense externally (\"you want me to\n1886         # specify *what* on my non-reversible relation?!\"), so we set it up\n1887         # automatically. The funky name reduces the chance of an accidental\n1888         # clash.\n1889         if self.remote_field.symmetrical and (\n1890             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT\n1891             or self.remote_field.model == cls._meta.object_name\n1892         ):\n1893             self.remote_field.related_name = \"%s_rel_+\" % name\n1894         elif self.remote_field.is_hidden():\n1895             # If the backwards relation is disabled, replace the original\n1896             # related_name with one generated from the m2m field name. Django\n1897             # still uses backwards relations internally and we need to avoid\n1898             # clashes between multiple m2m fields with related_name == '+'.\n1899             self.remote_field.related_name = \"_%s_%s_%s_+\" % (\n1900                 cls._meta.app_label,\n1901                 cls.__name__.lower(),\n1902                 name,\n1903             )\n1904 \n1905         super().contribute_to_class(cls, name, **kwargs)\n1906 \n1907         # The intermediate m2m model is not auto created if:\n1908         #  1) There is a manually specified intermediate, or\n1909         #  2) The class owning the m2m field is abstract.\n1910         #  3) The class owning the m2m field has been swapped out.\n1911         if not cls._meta.abstract:\n1912             if self.remote_field.through:\n1913 \n1914                 def resolve_through_model(_, model, field):\n1915                     field.remote_field.through = model\n1916 \n1917                 lazy_related_operation(\n1918                     resolve_through_model, cls, self.remote_field.through, field=self\n1919                 )\n1920             elif not cls._meta.swapped:\n1921                 self.remote_field.through = create_many_to_many_intermediary_model(\n1922                     self, cls\n1923                 )\n1924 \n1925         # Add the descriptor for the m2m relation.\n1926         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1927 \n1928         # Set up the accessor for the m2m table name for the relation.\n1929         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1930 \n1931     def contribute_to_related_class(self, cls, related):\n1932         # Internal M2Ms (i.e., those with a related name ending with '+')\n1933         # and swapped models don't get a related descriptor.\n1934         if (\n1935             not self.remote_field.is_hidden()\n1936             and not related.related_model._meta.swapped\n1937         ):\n1938             setattr(\n1939                 cls,\n1940                 related.get_accessor_name(),\n1941                 ManyToManyDescriptor(self.remote_field, reverse=True),\n1942             )\n1943 \n1944         # Set up the accessors for the column names on the m2m table.\n1945         self.m2m_column_name = partial(self._get_m2m_attr, related, \"column\")\n1946         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, \"column\")\n1947 \n1948         self.m2m_field_name = partial(self._get_m2m_attr, related, \"name\")\n1949         self.m2m_reverse_field_name = partial(\n1950             self._get_m2m_reverse_attr, related, \"name\"\n1951         )\n1952 \n1953         get_m2m_rel = partial(self._get_m2m_attr, related, \"remote_field\")\n1954         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1955         get_m2m_reverse_rel = partial(\n1956             self._get_m2m_reverse_attr, related, \"remote_field\"\n1957         )\n1958         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1959 \n1960     def set_attributes_from_rel(self):\n1961         pass\n1962 \n1963     def value_from_object(self, obj):\n1964         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1965 \n1966     def save_form_data(self, instance, data):\n1967         getattr(instance, self.attname).set(data)\n1968 \n1969     def formfield(self, *, using=None, **kwargs):\n1970         defaults = {\n1971             \"form_class\": forms.ModelMultipleChoiceField,\n1972             \"queryset\": self.remote_field.model._default_manager.using(using),\n1973             **kwargs,\n1974         }\n1975         # If initial is passed in, it's a list of related objects, but the\n1976         # MultipleChoiceField takes a list of IDs.\n1977         if defaults.get(\"initial\") is not None:\n1978             initial = defaults[\"initial\"]\n1979             if callable(initial):\n1980                 initial = initial()\n1981             defaults[\"initial\"] = [i.pk for i in initial]\n1982         return super().formfield(**defaults)\n1983 \n1984     def db_check(self, connection):\n1985         return None\n1986 \n1987     def db_type(self, connection):\n1988         # A ManyToManyField is not represented by a single column,\n1989         # so return None.\n1990         return None\n1991 \n1992     def db_parameters(self, connection):\n1993         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "These methods must be audited and potentially updated to ensure they gracefully handle the conversion to self-referential `ManyToManyField` definitions. Specifically, `deconstruct` should accurately reflect changes for migrations, ensuring the generated migration operations correctly handle self-referential relationships. Validation methods like `_check_relationship_model` should include logic to recognize and validate self-referential `ManyToManyField` configurations without erroneously flagging them during model checks."
    }
]