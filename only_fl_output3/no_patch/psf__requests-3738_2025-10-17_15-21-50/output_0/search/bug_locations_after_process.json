[
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/models.py",
        "start": 334,
        "end": 418,
        "class_name": null,
        "method_name": "prepare_url",
        "code": "334     def prepare_url(self, url, params):\n335         \"\"\"Prepares the given HTTP URL.\"\"\"\n336         #: Accept objects that have string representations.\n337         #: We're unable to blindly call unicode/str functions\n338         #: as this will include the bytestring indicator (b'')\n339         #: on python 3.x.\n340         #: https://github.com/kennethreitz/requests/pull/2238\n341         if isinstance(url, bytes):\n342             url = url.decode('utf8')\n343         else:\n344             url = unicode(url) if is_py2 else str(url)\n345 \n346         # Remove leading whitespaces from url\n347         url = url.lstrip()\n348 \n349         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n350         # `data`, `http+unix` etc to work around exceptions from `url_parse`,\n351         # which handles RFC 3986 only.\n352         if ':' in url and not url.lower().startswith(('http://', 'https://')):\n353             self.url = url\n354             return\n355 \n356         # Support for unicode domain names and paths.\n357         try:\n358             scheme, auth, host, port, path, query, fragment = parse_url(url)\n359         except LocationParseError as e:\n360             raise InvalidURL(*e.args)\n361 \n362         if not scheme:\n363             error = (\"Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?\")\n364             error = error.format(to_native_string(url, 'utf8'))\n365 \n366             raise MissingSchema(error)\n367 \n368         if not host:\n369             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n370 \n371         # In general, we want to try IDNA encoding every hostname, as that\n372         # allows users to automatically get the correct behaviour. However,\n373         # we\u2019re quite strict about IDNA encoding, so certain valid hostnames\n374         # may fail to encode. On failure, we verify the hostname meets a\n375         # minimum standard of only containing ASCII characters, and not starting\n376         # with a wildcard (*), before allowing the unencoded hostname through.\n377         try:\n378             host = idna.encode(host, uts46=True).decode('utf-8')\n379         except (UnicodeError, idna.IDNAError):\n380             if not unicode_is_ascii(host) or host.startswith(u'*'):\n381                 raise InvalidURL('URL has an invalid label.')\n382 \n383         # Carefully reconstruct the network location\n384         netloc = auth or ''\n385         if netloc:\n386             netloc += '@'\n387         netloc += host\n388         if port:\n389             netloc += ':' + str(port)\n390 \n391         # Bare domains aren't valid URLs.\n392         if not path:\n393             path = '/'\n394 \n395         if is_py2:\n396             if isinstance(scheme, str):\n397                 scheme = scheme.encode('utf-8')\n398             if isinstance(netloc, str):\n399                 netloc = netloc.encode('utf-8')\n400             if isinstance(path, str):\n401                 path = path.encode('utf-8')\n402             if isinstance(query, str):\n403                 query = query.encode('utf-8')\n404             if isinstance(fragment, str):\n405                 fragment = fragment.encode('utf-8')\n406 \n407         if isinstance(params, (str, bytes)):\n408             params = to_native_string(params)\n409 \n410         enc_params = self._encode_params(params)\n411         if enc_params:\n412             if query:\n413                 query = '%s&%s' % (query, enc_params)\n414             else:\n415                 query = enc_params\n416 \n417         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n418         self.url = url\n",
        "intended_behavior": "To resolve the issue, prepare_url should be adjusted or extended to ensure parameters are correctly handled and appended to URLs with custom or unrecognized schemes. This entails modifying the scheme validation or processing segment within this method to either recognize custom schemes or to follow a default, HTTP-like parameter handling process for schemes not explicitly recognized. This behavior should maintain the existing functionality for known schemes (e.g., http, https) while providing a mechanism for custom schemes to be included in parameter handling logic."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/models.py",
        "start": 334,
        "end": 418,
        "class_name": "PreparedRequest",
        "method_name": "prepare_url",
        "code": "334     def prepare_url(self, url, params):\n335         \"\"\"Prepares the given HTTP URL.\"\"\"\n336         #: Accept objects that have string representations.\n337         #: We're unable to blindly call unicode/str functions\n338         #: as this will include the bytestring indicator (b'')\n339         #: on python 3.x.\n340         #: https://github.com/kennethreitz/requests/pull/2238\n341         if isinstance(url, bytes):\n342             url = url.decode('utf8')\n343         else:\n344             url = unicode(url) if is_py2 else str(url)\n345 \n346         # Remove leading whitespaces from url\n347         url = url.lstrip()\n348 \n349         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n350         # `data`, `http+unix` etc to work around exceptions from `url_parse`,\n351         # which handles RFC 3986 only.\n352         if ':' in url and not url.lower().startswith(('http://', 'https://')):\n353             self.url = url\n354             return\n355 \n356         # Support for unicode domain names and paths.\n357         try:\n358             scheme, auth, host, port, path, query, fragment = parse_url(url)\n359         except LocationParseError as e:\n360             raise InvalidURL(*e.args)\n361 \n362         if not scheme:\n363             error = (\"Invalid URL {0!r}: No schema supplied. Perhaps you meant http://{0}?\")\n364             error = error.format(to_native_string(url, 'utf8'))\n365 \n366             raise MissingSchema(error)\n367 \n368         if not host:\n369             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n370 \n371         # In general, we want to try IDNA encoding every hostname, as that\n372         # allows users to automatically get the correct behaviour. However,\n373         # we\u2019re quite strict about IDNA encoding, so certain valid hostnames\n374         # may fail to encode. On failure, we verify the hostname meets a\n375         # minimum standard of only containing ASCII characters, and not starting\n376         # with a wildcard (*), before allowing the unencoded hostname through.\n377         try:\n378             host = idna.encode(host, uts46=True).decode('utf-8')\n379         except (UnicodeError, idna.IDNAError):\n380             if not unicode_is_ascii(host) or host.startswith(u'*'):\n381                 raise InvalidURL('URL has an invalid label.')\n382 \n383         # Carefully reconstruct the network location\n384         netloc = auth or ''\n385         if netloc:\n386             netloc += '@'\n387         netloc += host\n388         if port:\n389             netloc += ':' + str(port)\n390 \n391         # Bare domains aren't valid URLs.\n392         if not path:\n393             path = '/'\n394 \n395         if is_py2:\n396             if isinstance(scheme, str):\n397                 scheme = scheme.encode('utf-8')\n398             if isinstance(netloc, str):\n399                 netloc = netloc.encode('utf-8')\n400             if isinstance(path, str):\n401                 path = path.encode('utf-8')\n402             if isinstance(query, str):\n403                 query = query.encode('utf-8')\n404             if isinstance(fragment, str):\n405                 fragment = fragment.encode('utf-8')\n406 \n407         if isinstance(params, (str, bytes)):\n408             params = to_native_string(params)\n409 \n410         enc_params = self._encode_params(params)\n411         if enc_params:\n412             if query:\n413                 query = '%s&%s' % (query, enc_params)\n414             else:\n415                 query = enc_params\n416 \n417         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n418         self.url = url\n",
        "intended_behavior": "To resolve the issue, prepare_url should be adjusted or extended to ensure parameters are correctly handled and appended to URLs with custom or unrecognized schemes. This entails modifying the scheme validation or processing segment within this method to either recognize custom schemes or to follow a default, HTTP-like parameter handling process for schemes not explicitly recognized. This behavior should maintain the existing functionality for known schemes (e.g., http, https) while providing a mechanism for custom schemes to be included in parameter handling logic."
    },
    {
        "rel_file_path": "requests/sessions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/sessions.py",
        "start": 673,
        "end": 685,
        "class_name": null,
        "method_name": "get_adapter",
        "code": "673     def get_adapter(self, url):\n674         \"\"\"\n675         Returns the appropriate connection adapter for the given URL.\n676 \n677         :rtype: requests.adapters.BaseAdapter\n678         \"\"\"\n679         for (prefix, adapter) in self.adapters.items():\n680 \n681             if url.lower().startswith(prefix):\n682                 return adapter\n683 \n684         # Nothing matches :-/\n685         raise InvalidSchema(\"No connection adapters were found for '%s'\" % url)\n",
        "intended_behavior": "The get_adapter method needs to be enhanced to provide a fallback option or a registration system for custom URL schemes, allowing such URLs to be processed similarly to HTTP/HTTPS schemes. This could involve introducing a dynamically updatable registry of scheme-handling adapters or a default processing path for schemes that don't match any of the existing adapters but are intended to be treated as HTTP-like. This approach would preserve the method\u2019s current capability while extending its utility to cover custom schemes, thus ensuring that requests involving such schemes are not incorrectly processed or denied due to a lack of adapter match."
    },
    {
        "rel_file_path": "requests/sessions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.12/requests/sessions.py",
        "start": 673,
        "end": 685,
        "class_name": "Session",
        "method_name": "get_adapter",
        "code": "673     def get_adapter(self, url):\n674         \"\"\"\n675         Returns the appropriate connection adapter for the given URL.\n676 \n677         :rtype: requests.adapters.BaseAdapter\n678         \"\"\"\n679         for (prefix, adapter) in self.adapters.items():\n680 \n681             if url.lower().startswith(prefix):\n682                 return adapter\n683 \n684         # Nothing matches :-/\n685         raise InvalidSchema(\"No connection adapters were found for '%s'\" % url)\n",
        "intended_behavior": "The get_adapter method needs to be enhanced to provide a fallback option or a registration system for custom URL schemes, allowing such URLs to be processed similarly to HTTP/HTTPS schemes. This could involve introducing a dynamically updatable registry of scheme-handling adapters or a default processing path for schemes that don't match any of the existing adapters but are intended to be treated as HTTP-like. This approach would preserve the method\u2019s current capability while extending its utility to cover custom schemes, thus ensuring that requests involving such schemes are not incorrectly processed or denied due to a lack of adapter match."
    }
]