[
    {
        "rel_file_path": "src/_pytest/deprecated.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__7.2/src/_pytest/deprecated.py",
        "start": 1,
        "end": 131,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Deprecation messages and bits of code used elsewhere in the codebase that\n2 is planned to be removed in the next pytest release.\n3 \n4 Keeping it in a central location makes it easy to track what is deprecated and should\n5 be removed when the time comes.\n6 \n7 All constants defined in this module should be either instances of\n8 :class:`PytestWarning`, or :class:`UnformattedWarning`\n9 in case of warnings which need to format their messages.\n10 \"\"\"\n11 from warnings import warn\n12 \n13 from _pytest.warning_types import PytestDeprecationWarning\n14 from _pytest.warning_types import PytestRemovedIn8Warning\n15 from _pytest.warning_types import UnformattedWarning\n16 \n17 # set of plugins which have been integrated into the core; we use this list to ignore\n18 # them during registration to avoid conflicts\n19 DEPRECATED_EXTERNAL_PLUGINS = {\n20     \"pytest_catchlog\",\n21     \"pytest_capturelog\",\n22     \"pytest_faulthandler\",\n23 }\n24 \n25 \n26 # This can be* removed pytest 8, but it's harmless and common, so no rush to remove.\n27 # * If you're in the future: \"could have been\".\n28 YIELD_FIXTURE = PytestDeprecationWarning(\n29     \"@pytest.yield_fixture is deprecated.\\n\"\n30     \"Use @pytest.fixture instead; they are the same.\"\n31 )\n32 \n33 WARNING_CMDLINE_PREPARSE_HOOK = PytestRemovedIn8Warning(\n34     \"The pytest_cmdline_preparse hook is deprecated and will be removed in a future release. \\n\"\n35     \"Please use pytest_load_initial_conftests hook instead.\"\n36 )\n37 \n38 FSCOLLECTOR_GETHOOKPROXY_ISINITPATH = PytestRemovedIn8Warning(\n39     \"The gethookproxy() and isinitpath() methods of FSCollector and Package are deprecated; \"\n40     \"use self.session.gethookproxy() and self.session.isinitpath() instead. \"\n41 )\n42 \n43 STRICT_OPTION = PytestRemovedIn8Warning(\n44     \"The --strict option is deprecated, use --strict-markers instead.\"\n45 )\n46 \n47 # This deprecation is never really meant to be removed.\n48 PRIVATE = PytestDeprecationWarning(\"A private pytest class or function was used.\")\n49 \n50 ARGUMENT_PERCENT_DEFAULT = PytestRemovedIn8Warning(\n51     'pytest now uses argparse. \"%default\" should be changed to \"%(default)s\"',\n52 )\n53 \n54 ARGUMENT_TYPE_STR_CHOICE = UnformattedWarning(\n55     PytestRemovedIn8Warning,\n56     \"`type` argument to addoption() is the string {typ!r}.\"\n57     \" For choices this is optional and can be omitted, \"\n58     \" but when supplied should be a type (for example `str` or `int`).\"\n59     \" (options: {names})\",\n60 )\n61 \n62 ARGUMENT_TYPE_STR = UnformattedWarning(\n63     PytestRemovedIn8Warning,\n64     \"`type` argument to addoption() is the string {typ!r}, \"\n65     \" but when supplied should be a type (for example `str` or `int`).\"\n66     \" (options: {names})\",\n67 )\n68 \n69 \n70 HOOK_LEGACY_PATH_ARG = UnformattedWarning(\n71     PytestRemovedIn8Warning,\n72     \"The ({pylib_path_arg}: py.path.local) argument is deprecated, please use ({pathlib_path_arg}: pathlib.Path)\\n\"\n73     \"see https://docs.pytest.org/en/latest/deprecations.html\"\n74     \"#py-path-local-arguments-for-hooks-replaced-with-pathlib-path\",\n75 )\n76 \n77 NODE_CTOR_FSPATH_ARG = UnformattedWarning(\n78     PytestRemovedIn8Warning,\n79     \"The (fspath: py.path.local) argument to {node_type_name} is deprecated. \"\n80     \"Please use the (path: pathlib.Path) argument instead.\\n\"\n81     \"See https://docs.pytest.org/en/latest/deprecations.html\"\n82     \"#fspath-argument-for-node-constructors-replaced-with-pathlib-path\",\n83 )\n84 \n85 WARNS_NONE_ARG = PytestRemovedIn8Warning(\n86     \"Passing None has been deprecated.\\n\"\n87     \"See https://docs.pytest.org/en/latest/how-to/capture-warnings.html\"\n88     \"#additional-use-cases-of-warnings-in-tests\"\n89     \" for alternatives in common use cases.\"\n90 )\n91 \n92 KEYWORD_MSG_ARG = UnformattedWarning(\n93     PytestRemovedIn8Warning,\n94     \"pytest.{func}(msg=...) is now deprecated, use pytest.{func}(reason=...) instead\",\n95 )\n96 \n97 INSTANCE_COLLECTOR = PytestRemovedIn8Warning(\n98     \"The pytest.Instance collector type is deprecated and is no longer used. \"\n99     \"See https://docs.pytest.org/en/latest/deprecations.html#the-pytest-instance-collector\",\n100 )\n101 HOOK_LEGACY_MARKING = UnformattedWarning(\n102     PytestDeprecationWarning,\n103     \"The hook{type} {fullname} uses old-style configuration options (marks or attributes).\\n\"\n104     \"Please use the pytest.hook{type}({hook_opts}) decorator instead\\n\"\n105     \" to configure the hooks.\\n\"\n106     \" See https://docs.pytest.org/en/latest/deprecations.html\"\n107     \"#configuring-hook-specs-impls-using-markers\",\n108 )\n109 \n110 # You want to make some `__init__` or function \"private\".\n111 #\n112 #   def my_private_function(some, args):\n113 #       ...\n114 #\n115 # Do this:\n116 #\n117 #   def my_private_function(some, args, *, _ispytest: bool = False):\n118 #       check_ispytest(_ispytest)\n119 #       ...\n120 #\n121 # Change all internal/allowed calls to\n122 #\n123 #   my_private_function(some, args, _ispytest=True)\n124 #\n125 # All other calls will get the default _ispytest=False and trigger\n126 # the warning (possibly error in the future).\n127 \n128 \n129 def check_ispytest(ispytest: bool) -> None:\n130     if not ispytest:\n131         warn(PRIVATE, stacklevel=3)\n",
        "intended_behavior": "This file should be enhanced to include a mechanism or structure that allows passing additional context details (like plugin name or file path) into the deprecation warning messages related to old-style hookimpl usages. If PytestDeprecationWarning does not currently support this, it should be modified to accept such parameters and incorporate them into the warning message."
    },
    {
        "rel_file_path": "src/_pytest/config/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__7.2/src/_pytest/config/__init__.py",
        "start": 1,
        "end": 1743,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Command line options, ini-file and conftest.py processing.\"\"\"\n2 import argparse\n3 import collections.abc\n4 import copy\n5 import enum\n6 import glob\n7 import inspect\n8 import os\n9 import re\n10 import shlex\n11 import sys\n12 import types\n13 import warnings\n14 from functools import lru_cache\n15 from pathlib import Path\n16 from textwrap import dedent\n17 from types import FunctionType\n18 from types import TracebackType\n19 from typing import Any\n20 from typing import Callable\n21 from typing import cast\n22 from typing import Dict\n23 from typing import Generator\n24 from typing import IO\n25 from typing import Iterable\n26 from typing import Iterator\n27 from typing import List\n28 from typing import Optional\n29 from typing import Sequence\n30 from typing import Set\n31 from typing import TextIO\n32 from typing import Tuple\n33 from typing import Type\n34 from typing import TYPE_CHECKING\n35 from typing import Union\n36 \n37 import attr\n38 from pluggy import HookimplMarker\n39 from pluggy import HookspecMarker\n40 from pluggy import PluginManager\n41 \n42 import _pytest._code\n43 import _pytest.deprecated\n44 import _pytest.hookspec\n45 from .exceptions import PrintHelp as PrintHelp\n46 from .exceptions import UsageError as UsageError\n47 from .findpaths import determine_setup\n48 from _pytest._code import ExceptionInfo\n49 from _pytest._code import filter_traceback\n50 from _pytest._io import TerminalWriter\n51 from _pytest.compat import final\n52 from _pytest.compat import importlib_metadata\n53 from _pytest.outcomes import fail\n54 from _pytest.outcomes import Skipped\n55 from _pytest.pathlib import absolutepath\n56 from _pytest.pathlib import bestrelpath\n57 from _pytest.pathlib import import_path\n58 from _pytest.pathlib import ImportMode\n59 from _pytest.pathlib import resolve_package_path\n60 from _pytest.stash import Stash\n61 from _pytest.warning_types import PytestConfigWarning\n62 from _pytest.warning_types import warn_explicit_for\n63 \n64 if TYPE_CHECKING:\n65 \n66     from _pytest._code.code import _TracebackStyle\n67     from _pytest.terminal import TerminalReporter\n68     from .argparsing import Argument\n69 \n70 \n71 _PluggyPlugin = object\n72 \"\"\"A type to represent plugin objects.\n73 \n74 Plugins can be any namespace, so we can't narrow it down much, but we use an\n75 alias to make the intent clear.\n76 \n77 Ideally this type would be provided by pluggy itself.\n78 \"\"\"\n79 \n80 \n81 hookimpl = HookimplMarker(\"pytest\")\n82 hookspec = HookspecMarker(\"pytest\")\n83 \n84 \n85 @final\n86 class ExitCode(enum.IntEnum):\n87     \"\"\"Encodes the valid exit codes by pytest.\n88 \n89     Currently users and plugins may supply other exit codes as well.\n90 \n91     .. versionadded:: 5.0\n92     \"\"\"\n93 \n94     #: Tests passed.\n95     OK = 0\n96     #: Tests failed.\n97     TESTS_FAILED = 1\n98     #: pytest was interrupted.\n99     INTERRUPTED = 2\n100     #: An internal error got in the way.\n101     INTERNAL_ERROR = 3\n102     #: pytest was misused.\n103     USAGE_ERROR = 4\n104     #: pytest couldn't find tests.\n105     NO_TESTS_COLLECTED = 5\n106 \n107 \n108 class ConftestImportFailure(Exception):\n109     def __init__(\n110         self,\n111         path: Path,\n112         excinfo: Tuple[Type[Exception], Exception, TracebackType],\n113     ) -> None:\n114         super().__init__(path, excinfo)\n115         self.path = path\n116         self.excinfo = excinfo\n117 \n118     def __str__(self) -> str:\n119         return \"{}: {} (from {})\".format(\n120             self.excinfo[0].__name__, self.excinfo[1], self.path\n121         )\n122 \n123 \n124 def filter_traceback_for_conftest_import_failure(\n125     entry: _pytest._code.TracebackEntry,\n126 ) -> bool:\n127     \"\"\"Filter tracebacks entries which point to pytest internals or importlib.\n128 \n129     Make a special case for importlib because we use it to import test modules and conftest files\n130     in _pytest.pathlib.import_path.\n131     \"\"\"\n132     return filter_traceback(entry) and \"importlib\" not in str(entry.path).split(os.sep)\n133 \n134 \n135 def main(\n136     args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n137     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n138 ) -> Union[int, ExitCode]:\n139     \"\"\"Perform an in-process test run.\n140 \n141     :param args: List of command line arguments.\n142     :param plugins: List of plugin objects to be auto-registered during initialization.\n143 \n144     :returns: An exit code.\n145     \"\"\"\n146     try:\n147         try:\n148             config = _prepareconfig(args, plugins)\n149         except ConftestImportFailure as e:\n150             exc_info = ExceptionInfo.from_exc_info(e.excinfo)\n151             tw = TerminalWriter(sys.stderr)\n152             tw.line(f\"ImportError while loading conftest '{e.path}'.\", red=True)\n153             exc_info.traceback = exc_info.traceback.filter(\n154                 filter_traceback_for_conftest_import_failure\n155             )\n156             exc_repr = (\n157                 exc_info.getrepr(style=\"short\", chain=False)\n158                 if exc_info.traceback\n159                 else exc_info.exconly()\n160             )\n161             formatted_tb = str(exc_repr)\n162             for line in formatted_tb.splitlines():\n163                 tw.line(line.rstrip(), red=True)\n164             return ExitCode.USAGE_ERROR\n165         else:\n166             try:\n167                 ret: Union[ExitCode, int] = config.hook.pytest_cmdline_main(\n168                     config=config\n169                 )\n170                 try:\n171                     return ExitCode(ret)\n172                 except ValueError:\n173                     return ret\n174             finally:\n175                 config._ensure_unconfigure()\n176     except UsageError as e:\n177         tw = TerminalWriter(sys.stderr)\n178         for msg in e.args:\n179             tw.line(f\"ERROR: {msg}\\n\", red=True)\n180         return ExitCode.USAGE_ERROR\n181 \n182 \n183 def console_main() -> int:\n184     \"\"\"The CLI entry point of pytest.\n185 \n186     This function is not meant for programmable use; use `main()` instead.\n187     \"\"\"\n188     # https://docs.python.org/3/library/signal.html#note-on-sigpipe\n189     try:\n190         code = main()\n191         sys.stdout.flush()\n192         return code\n193     except BrokenPipeError:\n194         # Python flushes standard streams on exit; redirect remaining output\n195         # to devnull to avoid another BrokenPipeError at shutdown\n196         devnull = os.open(os.devnull, os.O_WRONLY)\n197         os.dup2(devnull, sys.stdout.fileno())\n198         return 1  # Python exits with error code 1 on EPIPE\n199 \n200 \n201 class cmdline:  # compatibility namespace\n202     main = staticmethod(main)\n203 \n204 \n205 def filename_arg(path: str, optname: str) -> str:\n206     \"\"\"Argparse type validator for filename arguments.\n207 \n208     :path: Path of filename.\n209     :optname: Name of the option.\n210     \"\"\"\n211     if os.path.isdir(path):\n212         raise UsageError(f\"{optname} must be a filename, given: {path}\")\n213     return path\n214 \n215 \n216 def directory_arg(path: str, optname: str) -> str:\n217     \"\"\"Argparse type validator for directory arguments.\n218 \n219     :path: Path of directory.\n220     :optname: Name of the option.\n221     \"\"\"\n222     if not os.path.isdir(path):\n223         raise UsageError(f\"{optname} must be a directory, given: {path}\")\n224     return path\n225 \n226 \n227 # Plugins that cannot be disabled via \"-p no:X\" currently.\n228 essential_plugins = (\n229     \"mark\",\n230     \"main\",\n231     \"runner\",\n232     \"fixtures\",\n233     \"helpconfig\",  # Provides -p.\n234 )\n235 \n236 default_plugins = essential_plugins + (\n237     \"python\",\n238     \"terminal\",\n239     \"debugging\",\n240     \"unittest\",\n241     \"capture\",\n242     \"skipping\",\n243     \"legacypath\",\n244     \"tmpdir\",\n245     \"monkeypatch\",\n246     \"recwarn\",\n247     \"pastebin\",\n248     \"nose\",\n249     \"assertion\",\n250     \"junitxml\",\n251     \"doctest\",\n252     \"cacheprovider\",\n253     \"freeze_support\",\n254     \"setuponly\",\n255     \"setupplan\",\n256     \"stepwise\",\n257     \"warnings\",\n258     \"logging\",\n259     \"reports\",\n260     \"python_path\",\n261     *([\"unraisableexception\", \"threadexception\"] if sys.version_info >= (3, 8) else []),\n262     \"faulthandler\",\n263 )\n264 \n265 builtin_plugins = set(default_plugins)\n266 builtin_plugins.add(\"pytester\")\n267 builtin_plugins.add(\"pytester_assertions\")\n268 \n269 \n270 def get_config(\n271     args: Optional[List[str]] = None,\n272     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n273 ) -> \"Config\":\n274     # subsequent calls to main will create a fresh instance\n275     pluginmanager = PytestPluginManager()\n276     config = Config(\n277         pluginmanager,\n278         invocation_params=Config.InvocationParams(\n279             args=args or (),\n280             plugins=plugins,\n281             dir=Path.cwd(),\n282         ),\n283     )\n284 \n285     if args is not None:\n286         # Handle any \"-p no:plugin\" args.\n287         pluginmanager.consider_preparse(args, exclude_only=True)\n288 \n289     for spec in default_plugins:\n290         pluginmanager.import_plugin(spec)\n291 \n292     return config\n293 \n294 \n295 def get_plugin_manager() -> \"PytestPluginManager\":\n296     \"\"\"Obtain a new instance of the\n297     :py:class:`pytest.PytestPluginManager`, with default plugins\n298     already loaded.\n299 \n300     This function can be used by integration with other tools, like hooking\n301     into pytest to run tests into an IDE.\n302     \"\"\"\n303     return get_config().pluginmanager\n304 \n305 \n306 def _prepareconfig(\n307     args: Optional[Union[List[str], \"os.PathLike[str]\"]] = None,\n308     plugins: Optional[Sequence[Union[str, _PluggyPlugin]]] = None,\n309 ) -> \"Config\":\n310     if args is None:\n311         args = sys.argv[1:]\n312     elif isinstance(args, os.PathLike):\n313         args = [os.fspath(args)]\n314     elif not isinstance(args, list):\n315         msg = (  # type:ignore[unreachable]\n316             \"`args` parameter expected to be a list of strings, got: {!r} (type: {})\"\n317         )\n318         raise TypeError(msg.format(args, type(args)))\n319 \n320     config = get_config(args, plugins)\n321     pluginmanager = config.pluginmanager\n322     try:\n323         if plugins:\n324             for plugin in plugins:\n325                 if isinstance(plugin, str):\n326                     pluginmanager.consider_pluginarg(plugin)\n327                 else:\n328                     pluginmanager.register(plugin)\n329         config = pluginmanager.hook.pytest_cmdline_parse(\n330             pluginmanager=pluginmanager, args=args\n331         )\n332         return config\n333     except BaseException:\n334         config._ensure_unconfigure()\n335         raise\n336 \n337 \n338 def _get_directory(path: Path) -> Path:\n339     \"\"\"Get the directory of a path - itself if already a directory.\"\"\"\n340     if path.is_file():\n341         return path.parent\n342     else:\n343         return path\n344 \n345 \n346 def _get_legacy_hook_marks(\n347     method: Any,\n348     hook_type: str,\n349     opt_names: Tuple[str, ...],\n350 ) -> Dict[str, bool]:\n351     if TYPE_CHECKING:\n352         # abuse typeguard from importlib to avoid massive method type union thats lacking a alias\n353         assert inspect.isroutine(method)\n354     known_marks: set[str] = {m.name for m in getattr(method, \"pytestmark\", [])}\n355     must_warn: list[str] = []\n356     opts: dict[str, bool] = {}\n357     for opt_name in opt_names:\n358         opt_attr = getattr(method, opt_name, AttributeError)\n359         if opt_attr is not AttributeError:\n360             must_warn.append(f\"{opt_name}={opt_attr}\")\n361             opts[opt_name] = True\n362         elif opt_name in known_marks:\n363             must_warn.append(f\"{opt_name}=True\")\n364             opts[opt_name] = True\n365         else:\n366             opts[opt_name] = False\n367     if must_warn:\n368         hook_opts = \", \".join(must_warn)\n369         message = _pytest.deprecated.HOOK_LEGACY_MARKING.format(\n370             type=hook_type,\n371             fullname=method.__qualname__,\n372             hook_opts=hook_opts,\n373         )\n374         warn_explicit_for(cast(FunctionType, method), message)\n375     return opts\n376 \n377 \n378 @final\n379 class PytestPluginManager(PluginManager):\n380     \"\"\"A :py:class:`pluggy.PluginManager <pluggy.PluginManager>` with\n381     additional pytest-specific functionality:\n382 \n383     * Loading plugins from the command line, ``PYTEST_PLUGINS`` env variable and\n384       ``pytest_plugins`` global variables found in plugins being loaded.\n385     * ``conftest.py`` loading during start-up.\n386     \"\"\"\n387 \n388     def __init__(self) -> None:\n389         import _pytest.assertion\n390 \n391         super().__init__(\"pytest\")\n392 \n393         # -- State related to local conftest plugins.\n394         # All loaded conftest modules.\n395         self._conftest_plugins: Set[types.ModuleType] = set()\n396         # All conftest modules applicable for a directory.\n397         # This includes the directory's own conftest modules as well\n398         # as those of its parent directories.\n399         self._dirpath2confmods: Dict[Path, List[types.ModuleType]] = {}\n400         # Cutoff directory above which conftests are no longer discovered.\n401         self._confcutdir: Optional[Path] = None\n402         # If set, conftest loading is skipped.\n403         self._noconftest = False\n404 \n405         # _getconftestmodules()'s call to _get_directory() causes a stat\n406         # storm when it's called potentially thousands of times in a test\n407         # session (#9478), often with the same path, so cache it.\n408         self._get_directory = lru_cache(256)(_get_directory)\n409 \n410         self._duplicatepaths: Set[Path] = set()\n411 \n412         # plugins that were explicitly skipped with pytest.skip\n413         # list of (module name, skip reason)\n414         # previously we would issue a warning when a plugin was skipped, but\n415         # since we refactored warnings as first citizens of Config, they are\n416         # just stored here to be used later.\n417         self.skipped_plugins: List[Tuple[str, str]] = []\n418 \n419         self.add_hookspecs(_pytest.hookspec)\n420         self.register(self)\n421         if os.environ.get(\"PYTEST_DEBUG\"):\n422             err: IO[str] = sys.stderr\n423             encoding: str = getattr(err, \"encoding\", \"utf8\")\n424             try:\n425                 err = open(\n426                     os.dup(err.fileno()),\n427                     mode=err.mode,\n428                     buffering=1,\n429                     encoding=encoding,\n430                 )\n431             except Exception:\n432                 pass\n433             self.trace.root.setwriter(err.write)\n434             self.enable_tracing()\n435 \n436         # Config._consider_importhook will set a real object if required.\n437         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()\n438         # Used to know when we are importing conftests after the pytest_configure stage.\n439         self._configured = False\n440 \n441     def parse_hookimpl_opts(self, plugin: _PluggyPlugin, name: str):\n442         # pytest hooks are always prefixed with \"pytest_\",\n443         # so we avoid accessing possibly non-readable attributes\n444         # (see issue #1073).\n445         if not name.startswith(\"pytest_\"):\n446             return\n447         # Ignore names which can not be hooks.\n448         if name == \"pytest_plugins\":\n449             return\n450 \n451         opts = super().parse_hookimpl_opts(plugin, name)\n452         if opts is not None:\n453             return opts\n454 \n455         method = getattr(plugin, name)\n456         # Consider only actual functions for hooks (#3775).\n457         if not inspect.isroutine(method):\n458             return\n459         # Collect unmarked hooks as long as they have the `pytest_' prefix.\n460         return _get_legacy_hook_marks(\n461             method, \"impl\", (\"tryfirst\", \"trylast\", \"optionalhook\", \"hookwrapper\")\n462         )\n463 \n464     def parse_hookspec_opts(self, module_or_class, name: str):\n465         opts = super().parse_hookspec_opts(module_or_class, name)\n466         if opts is None:\n467             method = getattr(module_or_class, name)\n468             if name.startswith(\"pytest_\"):\n469                 opts = _get_legacy_hook_marks(\n470                     method,\n471                     \"spec\",\n472                     (\"firstresult\", \"historic\"),\n473                 )\n474         return opts\n475 \n476     def register(\n477         self, plugin: _PluggyPlugin, name: Optional[str] = None\n478     ) -> Optional[str]:\n479         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:\n480             warnings.warn(\n481                 PytestConfigWarning(\n482                     \"{} plugin has been merged into the core, \"\n483                     \"please remove it from your requirements.\".format(\n484                         name.replace(\"_\", \"-\")\n485                     )\n486                 )\n487             )\n488             return None\n489         ret: Optional[str] = super().register(plugin, name)\n490         if ret:\n491             self.hook.pytest_plugin_registered.call_historic(\n492                 kwargs=dict(plugin=plugin, manager=self)\n493             )\n494 \n495             if isinstance(plugin, types.ModuleType):\n496                 self.consider_module(plugin)\n497         return ret\n498 \n499     def getplugin(self, name: str):\n500         # Support deprecated naming because plugins (xdist e.g.) use it.\n501         plugin: Optional[_PluggyPlugin] = self.get_plugin(name)\n502         return plugin\n503 \n504     def hasplugin(self, name: str) -> bool:\n505         \"\"\"Return whether a plugin with the given name is registered.\"\"\"\n506         return bool(self.get_plugin(name))\n507 \n508     def pytest_configure(self, config: \"Config\") -> None:\n509         \"\"\":meta private:\"\"\"\n510         # XXX now that the pluginmanager exposes hookimpl(tryfirst...)\n511         # we should remove tryfirst/trylast as markers.\n512         config.addinivalue_line(\n513             \"markers\",\n514             \"tryfirst: mark a hook implementation function such that the \"\n515             \"plugin machinery will try to call it first/as early as possible.\",\n516         )\n517         config.addinivalue_line(\n518             \"markers\",\n519             \"trylast: mark a hook implementation function such that the \"\n520             \"plugin machinery will try to call it last/as late as possible.\",\n521         )\n522         self._configured = True\n523 \n524     #\n525     # Internal API for local conftest plugin handling.\n526     #\n527     def _set_initial_conftests(\n528         self, namespace: argparse.Namespace, rootpath: Path\n529     ) -> None:\n530         \"\"\"Load initial conftest files given a preparsed \"namespace\".\n531 \n532         As conftest files may add their own command line options which have\n533         arguments ('--my-opt somepath') we might get some false positives.\n534         All builtin and 3rd party plugins will have been loaded, however, so\n535         common options will not confuse our logic here.\n536         \"\"\"\n537         current = Path.cwd()\n538         self._confcutdir = (\n539             absolutepath(current / namespace.confcutdir)\n540             if namespace.confcutdir\n541             else None\n542         )\n543         self._noconftest = namespace.noconftest\n544         self._using_pyargs = namespace.pyargs\n545         testpaths = namespace.file_or_dir\n546         foundanchor = False\n547         for testpath in testpaths:\n548             path = str(testpath)\n549             # remove node-id syntax\n550             i = path.find(\"::\")\n551             if i != -1:\n552                 path = path[:i]\n553             anchor = absolutepath(current / path)\n554             if anchor.exists():  # we found some file object\n555                 self._try_load_conftest(anchor, namespace.importmode, rootpath)\n556                 foundanchor = True\n557         if not foundanchor:\n558             self._try_load_conftest(current, namespace.importmode, rootpath)\n559 \n560     def _is_in_confcutdir(self, path: Path) -> bool:\n561         \"\"\"Whether a path is within the confcutdir.\n562 \n563         When false, should not load conftest.\n564         \"\"\"\n565         if self._confcutdir is None:\n566             return True\n567         return path not in self._confcutdir.parents\n568 \n569     def _try_load_conftest(\n570         self, anchor: Path, importmode: Union[str, ImportMode], rootpath: Path\n571     ) -> None:\n572         self._getconftestmodules(anchor, importmode, rootpath)\n573         # let's also consider test* subdirs\n574         if anchor.is_dir():\n575             for x in anchor.glob(\"test*\"):\n576                 if x.is_dir():\n577                     self._getconftestmodules(x, importmode, rootpath)\n578 \n579     def _getconftestmodules(\n580         self, path: Path, importmode: Union[str, ImportMode], rootpath: Path\n581     ) -> Sequence[types.ModuleType]:\n582         if self._noconftest:\n583             return []\n584 \n585         directory = self._get_directory(path)\n586 \n587         # Optimization: avoid repeated searches in the same directory.\n588         # Assumes always called with same importmode and rootpath.\n589         existing_clist = self._dirpath2confmods.get(directory)\n590         if existing_clist is not None:\n591             return existing_clist\n592 \n593         # XXX these days we may rather want to use config.rootpath\n594         # and allow users to opt into looking into the rootdir parent\n595         # directories instead of requiring to specify confcutdir.\n596         clist = []\n597         for parent in reversed((directory, *directory.parents)):\n598             if self._is_in_confcutdir(parent):\n599                 conftestpath = parent / \"conftest.py\"\n600                 if conftestpath.is_file():\n601                     mod = self._importconftest(conftestpath, importmode, rootpath)\n602                     clist.append(mod)\n603         self._dirpath2confmods[directory] = clist\n604         return clist\n605 \n606     def _rget_with_confmod(\n607         self,\n608         name: str,\n609         path: Path,\n610         importmode: Union[str, ImportMode],\n611         rootpath: Path,\n612     ) -> Tuple[types.ModuleType, Any]:\n613         modules = self._getconftestmodules(path, importmode, rootpath=rootpath)\n614         for mod in reversed(modules):\n615             try:\n616                 return mod, getattr(mod, name)\n617             except AttributeError:\n618                 continue\n619         raise KeyError(name)\n620 \n621     def _importconftest(\n622         self, conftestpath: Path, importmode: Union[str, ImportMode], rootpath: Path\n623     ) -> types.ModuleType:\n624         existing = self.get_plugin(str(conftestpath))\n625         if existing is not None:\n626             return cast(types.ModuleType, existing)\n627 \n628         pkgpath = resolve_package_path(conftestpath)\n629         if pkgpath is None:\n630             _ensure_removed_sysmodule(conftestpath.stem)\n631 \n632         try:\n633             mod = import_path(conftestpath, mode=importmode, root=rootpath)\n634         except Exception as e:\n635             assert e.__traceback__ is not None\n636             exc_info = (type(e), e, e.__traceback__)\n637             raise ConftestImportFailure(conftestpath, exc_info) from e\n638 \n639         self._check_non_top_pytest_plugins(mod, conftestpath)\n640 \n641         self._conftest_plugins.add(mod)\n642         dirpath = conftestpath.parent\n643         if dirpath in self._dirpath2confmods:\n644             for path, mods in self._dirpath2confmods.items():\n645                 if dirpath in path.parents or path == dirpath:\n646                     assert mod not in mods\n647                     mods.append(mod)\n648         self.trace(f\"loading conftestmodule {mod!r}\")\n649         self.consider_conftest(mod)\n650         return mod\n651 \n652     def _check_non_top_pytest_plugins(\n653         self,\n654         mod: types.ModuleType,\n655         conftestpath: Path,\n656     ) -> None:\n657         if (\n658             hasattr(mod, \"pytest_plugins\")\n659             and self._configured\n660             and not self._using_pyargs\n661         ):\n662             msg = (\n663                 \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported:\\n\"\n664                 \"It affects the entire test suite instead of just below the conftest as expected.\\n\"\n665                 \"  {}\\n\"\n666                 \"Please move it to a top level conftest file at the rootdir:\\n\"\n667                 \"  {}\\n\"\n668                 \"For more information, visit:\\n\"\n669                 \"  https://docs.pytest.org/en/stable/deprecations.html#pytest-plugins-in-non-top-level-conftest-files\"\n670             )\n671             fail(msg.format(conftestpath, self._confcutdir), pytrace=False)\n672 \n673     #\n674     # API for bootstrapping plugin loading\n675     #\n676     #\n677 \n678     def consider_preparse(\n679         self, args: Sequence[str], *, exclude_only: bool = False\n680     ) -> None:\n681         \"\"\":meta private:\"\"\"\n682         i = 0\n683         n = len(args)\n684         while i < n:\n685             opt = args[i]\n686             i += 1\n687             if isinstance(opt, str):\n688                 if opt == \"-p\":\n689                     try:\n690                         parg = args[i]\n691                     except IndexError:\n692                         return\n693                     i += 1\n694                 elif opt.startswith(\"-p\"):\n695                     parg = opt[2:]\n696                 else:\n697                     continue\n698                 if exclude_only and not parg.startswith(\"no:\"):\n699                     continue\n700                 self.consider_pluginarg(parg)\n701 \n702     def consider_pluginarg(self, arg: str) -> None:\n703         \"\"\":meta private:\"\"\"\n704         if arg.startswith(\"no:\"):\n705             name = arg[3:]\n706             if name in essential_plugins:\n707                 raise UsageError(\"plugin %s cannot be disabled\" % name)\n708 \n709             # PR #4304: remove stepwise if cacheprovider is blocked.\n710             if name == \"cacheprovider\":\n711                 self.set_blocked(\"stepwise\")\n712                 self.set_blocked(\"pytest_stepwise\")\n713 \n714             self.set_blocked(name)\n715             if not name.startswith(\"pytest_\"):\n716                 self.set_blocked(\"pytest_\" + name)\n717         else:\n718             name = arg\n719             # Unblock the plugin.  None indicates that it has been blocked.\n720             # There is no interface with pluggy for this.\n721             if self._name2plugin.get(name, -1) is None:\n722                 del self._name2plugin[name]\n723             if not name.startswith(\"pytest_\"):\n724                 if self._name2plugin.get(\"pytest_\" + name, -1) is None:\n725                     del self._name2plugin[\"pytest_\" + name]\n726             self.import_plugin(arg, consider_entry_points=True)\n727 \n728     def consider_conftest(self, conftestmodule: types.ModuleType) -> None:\n729         \"\"\":meta private:\"\"\"\n730         self.register(conftestmodule, name=conftestmodule.__file__)\n731 \n732     def consider_env(self) -> None:\n733         \"\"\":meta private:\"\"\"\n734         self._import_plugin_specs(os.environ.get(\"PYTEST_PLUGINS\"))\n735 \n736     def consider_module(self, mod: types.ModuleType) -> None:\n737         \"\"\":meta private:\"\"\"\n738         self._import_plugin_specs(getattr(mod, \"pytest_plugins\", []))\n739 \n740     def _import_plugin_specs(\n741         self, spec: Union[None, types.ModuleType, str, Sequence[str]]\n742     ) -> None:\n743         plugins = _get_plugin_specs_as_list(spec)\n744         for import_spec in plugins:\n745             self.import_plugin(import_spec)\n746 \n747     def import_plugin(self, modname: str, consider_entry_points: bool = False) -> None:\n748         \"\"\"Import a plugin with ``modname``.\n749 \n750         If ``consider_entry_points`` is True, entry point names are also\n751         considered to find a plugin.\n752         \"\"\"\n753         # Most often modname refers to builtin modules, e.g. \"pytester\",\n754         # \"terminal\" or \"capture\".  Those plugins are registered under their\n755         # basename for historic purposes but must be imported with the\n756         # _pytest prefix.\n757         assert isinstance(modname, str), (\n758             \"module name as text required, got %r\" % modname\n759         )\n760         if self.is_blocked(modname) or self.get_plugin(modname) is not None:\n761             return\n762 \n763         importspec = \"_pytest.\" + modname if modname in builtin_plugins else modname\n764         self.rewrite_hook.mark_rewrite(importspec)\n765 \n766         if consider_entry_points:\n767             loaded = self.load_setuptools_entrypoints(\"pytest11\", name=modname)\n768             if loaded:\n769                 return\n770 \n771         try:\n772             __import__(importspec)\n773         except ImportError as e:\n774             raise ImportError(\n775                 f'Error importing plugin \"{modname}\": {e.args[0]}'\n776             ).with_traceback(e.__traceback__) from e\n777 \n778         except Skipped as e:\n779             self.skipped_plugins.append((modname, e.msg or \"\"))\n780         else:\n781             mod = sys.modules[importspec]\n782             self.register(mod, modname)\n783 \n784 \n785 def _get_plugin_specs_as_list(\n786     specs: Union[None, types.ModuleType, str, Sequence[str]]\n787 ) -> List[str]:\n788     \"\"\"Parse a plugins specification into a list of plugin names.\"\"\"\n789     # None means empty.\n790     if specs is None:\n791         return []\n792     # Workaround for #3899 - a submodule which happens to be called \"pytest_plugins\".\n793     if isinstance(specs, types.ModuleType):\n794         return []\n795     # Comma-separated list.\n796     if isinstance(specs, str):\n797         return specs.split(\",\") if specs else []\n798     # Direct specification.\n799     if isinstance(specs, collections.abc.Sequence):\n800         return list(specs)\n801     raise UsageError(\n802         \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %r\"\n803         % specs\n804     )\n805 \n806 \n807 def _ensure_removed_sysmodule(modname: str) -> None:\n808     try:\n809         del sys.modules[modname]\n810     except KeyError:\n811         pass\n812 \n813 \n814 class Notset:\n815     def __repr__(self):\n816         return \"<NOTSET>\"\n817 \n818 \n819 notset = Notset()\n820 \n821 \n822 def _iter_rewritable_modules(package_files: Iterable[str]) -> Iterator[str]:\n823     \"\"\"Given an iterable of file names in a source distribution, return the \"names\" that should\n824     be marked for assertion rewrite.\n825 \n826     For example the package \"pytest_mock/__init__.py\" should be added as \"pytest_mock\" in\n827     the assertion rewrite mechanism.\n828 \n829     This function has to deal with dist-info based distributions and egg based distributions\n830     (which are still very much in use for \"editable\" installs).\n831 \n832     Here are the file names as seen in a dist-info based distribution:\n833 \n834         pytest_mock/__init__.py\n835         pytest_mock/_version.py\n836         pytest_mock/plugin.py\n837         pytest_mock.egg-info/PKG-INFO\n838 \n839     Here are the file names as seen in an egg based distribution:\n840 \n841         src/pytest_mock/__init__.py\n842         src/pytest_mock/_version.py\n843         src/pytest_mock/plugin.py\n844         src/pytest_mock.egg-info/PKG-INFO\n845         LICENSE\n846         setup.py\n847 \n848     We have to take in account those two distribution flavors in order to determine which\n849     names should be considered for assertion rewriting.\n850 \n851     More information:\n852         https://github.com/pytest-dev/pytest-mock/issues/167\n853     \"\"\"\n854     package_files = list(package_files)\n855     seen_some = False\n856     for fn in package_files:\n857         is_simple_module = \"/\" not in fn and fn.endswith(\".py\")\n858         is_package = fn.count(\"/\") == 1 and fn.endswith(\"__init__.py\")\n859         if is_simple_module:\n860             module_name, _ = os.path.splitext(fn)\n861             # we ignore \"setup.py\" at the root of the distribution\n862             # as well as editable installation finder modules made by setuptools\n863             if module_name != \"setup\" and not module_name.startswith(\"__editable__\"):\n864                 seen_some = True\n865                 yield module_name\n866         elif is_package:\n867             package_name = os.path.dirname(fn)\n868             seen_some = True\n869             yield package_name\n870 \n871     if not seen_some:\n872         # At this point we did not find any packages or modules suitable for assertion\n873         # rewriting, so we try again by stripping the first path component (to account for\n874         # \"src\" based source trees for example).\n875         # This approach lets us have the common case continue to be fast, as egg-distributions\n876         # are rarer.\n877         new_package_files = []\n878         for fn in package_files:\n879             parts = fn.split(\"/\")\n880             new_fn = \"/\".join(parts[1:])\n881             if new_fn:\n882                 new_package_files.append(new_fn)\n883         if new_package_files:\n884             yield from _iter_rewritable_modules(new_package_files)\n885 \n886 \n887 def _args_converter(args: Iterable[str]) -> Tuple[str, ...]:\n888     return tuple(args)\n889 \n890 \n891 @final\n892 class Config:\n893     \"\"\"Access to configuration values, pluginmanager and plugin hooks.\n894 \n895     :param PytestPluginManager pluginmanager:\n896         A pytest PluginManager.\n897 \n898     :param InvocationParams invocation_params:\n899         Object containing parameters regarding the :func:`pytest.main`\n900         invocation.\n901     \"\"\"\n902 \n903     @final\n904     @attr.s(frozen=True, auto_attribs=True)\n905     class InvocationParams:\n906         \"\"\"Holds parameters passed during :func:`pytest.main`.\n907 \n908         The object attributes are read-only.\n909 \n910         .. versionadded:: 5.1\n911 \n912         .. note::\n913 \n914             Note that the environment variable ``PYTEST_ADDOPTS`` and the ``addopts``\n915             ini option are handled by pytest, not being included in the ``args`` attribute.\n916 \n917             Plugins accessing ``InvocationParams`` must be aware of that.\n918         \"\"\"\n919 \n920         args: Tuple[str, ...] = attr.ib(converter=_args_converter)\n921         \"\"\"The command-line arguments as passed to :func:`pytest.main`.\"\"\"\n922         plugins: Optional[Sequence[Union[str, _PluggyPlugin]]]\n923         \"\"\"Extra plugins, might be `None`.\"\"\"\n924         dir: Path\n925         \"\"\"The directory from which :func:`pytest.main` was invoked.\"\"\"\n926 \n927     class ArgsSource(enum.Enum):\n928         \"\"\"Indicates the source of the test arguments.\n929 \n930         .. versionadded:: 7.2\n931         \"\"\"\n932 \n933         #: Command line arguments.\n934         ARGS = enum.auto()\n935         #: Invocation directory.\n936         INCOVATION_DIR = enum.auto()\n937         #: 'testpaths' configuration value.\n938         TESTPATHS = enum.auto()\n939 \n940     def __init__(\n941         self,\n942         pluginmanager: PytestPluginManager,\n943         *,\n944         invocation_params: Optional[InvocationParams] = None,\n945     ) -> None:\n946         from .argparsing import Parser, FILE_OR_DIR\n947 \n948         if invocation_params is None:\n949             invocation_params = self.InvocationParams(\n950                 args=(), plugins=None, dir=Path.cwd()\n951             )\n952 \n953         self.option = argparse.Namespace()\n954         \"\"\"Access to command line option as attributes.\n955 \n956         :type: argparse.Namespace\n957         \"\"\"\n958 \n959         self.invocation_params = invocation_params\n960         \"\"\"The parameters with which pytest was invoked.\n961 \n962         :type: InvocationParams\n963         \"\"\"\n964 \n965         _a = FILE_OR_DIR\n966         self._parser = Parser(\n967             usage=f\"%(prog)s [options] [{_a}] [{_a}] [...]\",\n968             processopt=self._processopt,\n969             _ispytest=True,\n970         )\n971         self.pluginmanager = pluginmanager\n972         \"\"\"The plugin manager handles plugin registration and hook invocation.\n973 \n974         :type: PytestPluginManager\n975         \"\"\"\n976 \n977         self.stash = Stash()\n978         \"\"\"A place where plugins can store information on the config for their\n979         own use.\n980 \n981         :type: Stash\n982         \"\"\"\n983         # Deprecated alias. Was never public. Can be removed in a few releases.\n984         self._store = self.stash\n985 \n986         from .compat import PathAwareHookProxy\n987 \n988         self.trace = self.pluginmanager.trace.root.get(\"config\")\n989         self.hook = PathAwareHookProxy(self.pluginmanager.hook)\n990         self._inicache: Dict[str, Any] = {}\n991         self._override_ini: Sequence[str] = ()\n992         self._opt2dest: Dict[str, str] = {}\n993         self._cleanup: List[Callable[[], None]] = []\n994         self.pluginmanager.register(self, \"pytestconfig\")\n995         self._configured = False\n996         self.hook.pytest_addoption.call_historic(\n997             kwargs=dict(parser=self._parser, pluginmanager=self.pluginmanager)\n998         )\n999 \n1000         if TYPE_CHECKING:\n1001             from _pytest.cacheprovider import Cache\n1002 \n1003             self.cache: Optional[Cache] = None\n1004 \n1005     @property\n1006     def rootpath(self) -> Path:\n1007         \"\"\"The path to the :ref:`rootdir <rootdir>`.\n1008 \n1009         :type: pathlib.Path\n1010 \n1011         .. versionadded:: 6.1\n1012         \"\"\"\n1013         return self._rootpath\n1014 \n1015     @property\n1016     def inipath(self) -> Optional[Path]:\n1017         \"\"\"The path to the :ref:`configfile <configfiles>`.\n1018 \n1019         :type: Optional[pathlib.Path]\n1020 \n1021         .. versionadded:: 6.1\n1022         \"\"\"\n1023         return self._inipath\n1024 \n1025     def add_cleanup(self, func: Callable[[], None]) -> None:\n1026         \"\"\"Add a function to be called when the config object gets out of\n1027         use (usually coinciding with pytest_unconfigure).\"\"\"\n1028         self._cleanup.append(func)\n1029 \n1030     def _do_configure(self) -> None:\n1031         assert not self._configured\n1032         self._configured = True\n1033         with warnings.catch_warnings():\n1034             warnings.simplefilter(\"default\")\n1035             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\n1036 \n1037     def _ensure_unconfigure(self) -> None:\n1038         if self._configured:\n1039             self._configured = False\n1040             self.hook.pytest_unconfigure(config=self)\n1041             self.hook.pytest_configure._call_history = []\n1042         while self._cleanup:\n1043             fin = self._cleanup.pop()\n1044             fin()\n1045 \n1046     def get_terminal_writer(self) -> TerminalWriter:\n1047         terminalreporter: TerminalReporter = self.pluginmanager.get_plugin(\n1048             \"terminalreporter\"\n1049         )\n1050         return terminalreporter._tw\n1051 \n1052     def pytest_cmdline_parse(\n1053         self, pluginmanager: PytestPluginManager, args: List[str]\n1054     ) -> \"Config\":\n1055         try:\n1056             self.parse(args)\n1057         except UsageError:\n1058 \n1059             # Handle --version and --help here in a minimal fashion.\n1060             # This gets done via helpconfig normally, but its\n1061             # pytest_cmdline_main is not called in case of errors.\n1062             if getattr(self.option, \"version\", False) or \"--version\" in args:\n1063                 from _pytest.helpconfig import showversion\n1064 \n1065                 showversion(self)\n1066             elif (\n1067                 getattr(self.option, \"help\", False) or \"--help\" in args or \"-h\" in args\n1068             ):\n1069                 self._parser._getparser().print_help()\n1070                 sys.stdout.write(\n1071                     \"\\nNOTE: displaying only minimal help due to UsageError.\\n\\n\"\n1072                 )\n1073 \n1074             raise\n1075 \n1076         return self\n1077 \n1078     def notify_exception(\n1079         self,\n1080         excinfo: ExceptionInfo[BaseException],\n1081         option: Optional[argparse.Namespace] = None,\n1082     ) -> None:\n1083         if option and getattr(option, \"fulltrace\", False):\n1084             style: _TracebackStyle = \"long\"\n1085         else:\n1086             style = \"native\"\n1087         excrepr = excinfo.getrepr(\n1088             funcargs=True, showlocals=getattr(option, \"showlocals\", False), style=style\n1089         )\n1090         res = self.hook.pytest_internalerror(excrepr=excrepr, excinfo=excinfo)\n1091         if not any(res):\n1092             for line in str(excrepr).split(\"\\n\"):\n1093                 sys.stderr.write(\"INTERNALERROR> %s\\n\" % line)\n1094                 sys.stderr.flush()\n1095 \n1096     def cwd_relative_nodeid(self, nodeid: str) -> str:\n1097         # nodeid's are relative to the rootpath, compute relative to cwd.\n1098         if self.invocation_params.dir != self.rootpath:\n1099             fullpath = self.rootpath / nodeid\n1100             nodeid = bestrelpath(self.invocation_params.dir, fullpath)\n1101         return nodeid\n1102 \n1103     @classmethod\n1104     def fromdictargs(cls, option_dict, args) -> \"Config\":\n1105         \"\"\"Constructor usable for subprocesses.\"\"\"\n1106         config = get_config(args)\n1107         config.option.__dict__.update(option_dict)\n1108         config.parse(args, addopts=False)\n1109         for x in config.option.plugins:\n1110             config.pluginmanager.consider_pluginarg(x)\n1111         return config\n1112 \n1113     def _processopt(self, opt: \"Argument\") -> None:\n1114         for name in opt._short_opts + opt._long_opts:\n1115             self._opt2dest[name] = opt.dest\n1116 \n1117         if hasattr(opt, \"default\"):\n1118             if not hasattr(self.option, opt.dest):\n1119                 setattr(self.option, opt.dest, opt.default)\n1120 \n1121     @hookimpl(trylast=True)\n1122     def pytest_load_initial_conftests(self, early_config: \"Config\") -> None:\n1123         self.pluginmanager._set_initial_conftests(\n1124             early_config.known_args_namespace, rootpath=early_config.rootpath\n1125         )\n1126 \n1127     def _initini(self, args: Sequence[str]) -> None:\n1128         ns, unknown_args = self._parser.parse_known_and_unknown_args(\n1129             args, namespace=copy.copy(self.option)\n1130         )\n1131         rootpath, inipath, inicfg = determine_setup(\n1132             ns.inifilename,\n1133             ns.file_or_dir + unknown_args,\n1134             rootdir_cmd_arg=ns.rootdir or None,\n1135             config=self,\n1136         )\n1137         self._rootpath = rootpath\n1138         self._inipath = inipath\n1139         self.inicfg = inicfg\n1140         self._parser.extra_info[\"rootdir\"] = str(self.rootpath)\n1141         self._parser.extra_info[\"inifile\"] = str(self.inipath)\n1142         self._parser.addini(\"addopts\", \"Extra command line options\", \"args\")\n1143         self._parser.addini(\"minversion\", \"Minimally required pytest version\")\n1144         self._parser.addini(\n1145             \"required_plugins\",\n1146             \"Plugins that must be present for pytest to run\",\n1147             type=\"args\",\n1148             default=[],\n1149         )\n1150         self._override_ini = ns.override_ini or ()\n1151 \n1152     def _consider_importhook(self, args: Sequence[str]) -> None:\n1153         \"\"\"Install the PEP 302 import hook if using assertion rewriting.\n1154 \n1155         Needs to parse the --assert=<mode> option from the commandline\n1156         and find all the installed plugins to mark them for rewriting\n1157         by the importhook.\n1158         \"\"\"\n1159         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)\n1160         mode = getattr(ns, \"assertmode\", \"plain\")\n1161         if mode == \"rewrite\":\n1162             import _pytest.assertion\n1163 \n1164             try:\n1165                 hook = _pytest.assertion.install_importhook(self)\n1166             except SystemError:\n1167                 mode = \"plain\"\n1168             else:\n1169                 self._mark_plugins_for_rewrite(hook)\n1170         self._warn_about_missing_assertion(mode)\n1171 \n1172     def _mark_plugins_for_rewrite(self, hook) -> None:\n1173         \"\"\"Given an importhook, mark for rewrite any top-level\n1174         modules or packages in the distribution package for\n1175         all pytest plugins.\"\"\"\n1176         self.pluginmanager.rewrite_hook = hook\n1177 \n1178         if os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n1179             # We don't autoload from setuptools entry points, no need to continue.\n1180             return\n1181 \n1182         package_files = (\n1183             str(file)\n1184             for dist in importlib_metadata.distributions()\n1185             if any(ep.group == \"pytest11\" for ep in dist.entry_points)\n1186             for file in dist.files or []\n1187         )\n1188 \n1189         for name in _iter_rewritable_modules(package_files):\n1190             hook.mark_rewrite(name)\n1191 \n1192     def _validate_args(self, args: List[str], via: str) -> List[str]:\n1193         \"\"\"Validate known args.\"\"\"\n1194         self._parser._config_source_hint = via  # type: ignore\n1195         try:\n1196             self._parser.parse_known_and_unknown_args(\n1197                 args, namespace=copy.copy(self.option)\n1198             )\n1199         finally:\n1200             del self._parser._config_source_hint  # type: ignore\n1201 \n1202         return args\n1203 \n1204     def _preparse(self, args: List[str], addopts: bool = True) -> None:\n1205         if addopts:\n1206             env_addopts = os.environ.get(\"PYTEST_ADDOPTS\", \"\")\n1207             if len(env_addopts):\n1208                 args[:] = (\n1209                     self._validate_args(shlex.split(env_addopts), \"via PYTEST_ADDOPTS\")\n1210                     + args\n1211                 )\n1212         self._initini(args)\n1213         if addopts:\n1214             args[:] = (\n1215                 self._validate_args(self.getini(\"addopts\"), \"via addopts config\") + args\n1216             )\n1217 \n1218         self.known_args_namespace = self._parser.parse_known_args(\n1219             args, namespace=copy.copy(self.option)\n1220         )\n1221         self._checkversion()\n1222         self._consider_importhook(args)\n1223         self.pluginmanager.consider_preparse(args, exclude_only=False)\n1224         if not os.environ.get(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\"):\n1225             # Don't autoload from setuptools entry point. Only explicitly specified\n1226             # plugins are going to be loaded.\n1227             self.pluginmanager.load_setuptools_entrypoints(\"pytest11\")\n1228         self.pluginmanager.consider_env()\n1229 \n1230         self.known_args_namespace = self._parser.parse_known_args(\n1231             args, namespace=copy.copy(self.known_args_namespace)\n1232         )\n1233 \n1234         self._validate_plugins()\n1235         self._warn_about_skipped_plugins()\n1236 \n1237         if self.known_args_namespace.strict:\n1238             self.issue_config_time_warning(\n1239                 _pytest.deprecated.STRICT_OPTION, stacklevel=2\n1240             )\n1241 \n1242         if self.known_args_namespace.confcutdir is None and self.inipath is not None:\n1243             confcutdir = str(self.inipath.parent)\n1244             self.known_args_namespace.confcutdir = confcutdir\n1245         try:\n1246             self.hook.pytest_load_initial_conftests(\n1247                 early_config=self, args=args, parser=self._parser\n1248             )\n1249         except ConftestImportFailure as e:\n1250             if self.known_args_namespace.help or self.known_args_namespace.version:\n1251                 # we don't want to prevent --help/--version to work\n1252                 # so just let is pass and print a warning at the end\n1253                 self.issue_config_time_warning(\n1254                     PytestConfigWarning(f\"could not load initial conftests: {e.path}\"),\n1255                     stacklevel=2,\n1256                 )\n1257             else:\n1258                 raise\n1259 \n1260     @hookimpl(hookwrapper=True)\n1261     def pytest_collection(self) -> Generator[None, None, None]:\n1262         # Validate invalid ini keys after collection is done so we take in account\n1263         # options added by late-loading conftest files.\n1264         yield\n1265         self._validate_config_options()\n1266 \n1267     def _checkversion(self) -> None:\n1268         import pytest\n1269 \n1270         minver = self.inicfg.get(\"minversion\", None)\n1271         if minver:\n1272             # Imported lazily to improve start-up time.\n1273             from packaging.version import Version\n1274 \n1275             if not isinstance(minver, str):\n1276                 raise pytest.UsageError(\n1277                     \"%s: 'minversion' must be a single value\" % self.inipath\n1278                 )\n1279 \n1280             if Version(minver) > Version(pytest.__version__):\n1281                 raise pytest.UsageError(\n1282                     \"%s: 'minversion' requires pytest-%s, actual pytest-%s'\"\n1283                     % (\n1284                         self.inipath,\n1285                         minver,\n1286                         pytest.__version__,\n1287                     )\n1288                 )\n1289 \n1290     def _validate_config_options(self) -> None:\n1291         for key in sorted(self._get_unknown_ini_keys()):\n1292             self._warn_or_fail_if_strict(f\"Unknown config option: {key}\\n\")\n1293 \n1294     def _validate_plugins(self) -> None:\n1295         required_plugins = sorted(self.getini(\"required_plugins\"))\n1296         if not required_plugins:\n1297             return\n1298 \n1299         # Imported lazily to improve start-up time.\n1300         from packaging.version import Version\n1301         from packaging.requirements import InvalidRequirement, Requirement\n1302 \n1303         plugin_info = self.pluginmanager.list_plugin_distinfo()\n1304         plugin_dist_info = {dist.project_name: dist.version for _, dist in plugin_info}\n1305 \n1306         missing_plugins = []\n1307         for required_plugin in required_plugins:\n1308             try:\n1309                 req = Requirement(required_plugin)\n1310             except InvalidRequirement:\n1311                 missing_plugins.append(required_plugin)\n1312                 continue\n1313 \n1314             if req.name not in plugin_dist_info:\n1315                 missing_plugins.append(required_plugin)\n1316             elif not req.specifier.contains(\n1317                 Version(plugin_dist_info[req.name]), prereleases=True\n1318             ):\n1319                 missing_plugins.append(required_plugin)\n1320 \n1321         if missing_plugins:\n1322             raise UsageError(\n1323                 \"Missing required plugins: {}\".format(\", \".join(missing_plugins)),\n1324             )\n1325 \n1326     def _warn_or_fail_if_strict(self, message: str) -> None:\n1327         if self.known_args_namespace.strict_config:\n1328             raise UsageError(message)\n1329 \n1330         self.issue_config_time_warning(PytestConfigWarning(message), stacklevel=3)\n1331 \n1332     def _get_unknown_ini_keys(self) -> List[str]:\n1333         parser_inicfg = self._parser._inidict\n1334         return [name for name in self.inicfg if name not in parser_inicfg]\n1335 \n1336     def parse(self, args: List[str], addopts: bool = True) -> None:\n1337         # Parse given cmdline arguments into this config object.\n1338         assert not hasattr(\n1339             self, \"args\"\n1340         ), \"can only parse cmdline args at most once per Config object\"\n1341         self.hook.pytest_addhooks.call_historic(\n1342             kwargs=dict(pluginmanager=self.pluginmanager)\n1343         )\n1344         self._preparse(args, addopts=addopts)\n1345         # XXX deprecated hook:\n1346         self.hook.pytest_cmdline_preparse(config=self, args=args)\n1347         self._parser.after_preparse = True  # type: ignore\n1348         try:\n1349             source = Config.ArgsSource.ARGS\n1350             args = self._parser.parse_setoption(\n1351                 args, self.option, namespace=self.option\n1352             )\n1353             if not args:\n1354                 if self.invocation_params.dir == self.rootpath:\n1355                     source = Config.ArgsSource.TESTPATHS\n1356                     testpaths: List[str] = self.getini(\"testpaths\")\n1357                     if self.known_args_namespace.pyargs:\n1358                         args = testpaths\n1359                     else:\n1360                         args = []\n1361                         for path in testpaths:\n1362                             args.extend(sorted(glob.iglob(path, recursive=True)))\n1363                 if not args:\n1364                     source = Config.ArgsSource.INCOVATION_DIR\n1365                     args = [str(self.invocation_params.dir)]\n1366             self.args = args\n1367             self.args_source = source\n1368         except PrintHelp:\n1369             pass\n1370 \n1371     def issue_config_time_warning(self, warning: Warning, stacklevel: int) -> None:\n1372         \"\"\"Issue and handle a warning during the \"configure\" stage.\n1373 \n1374         During ``pytest_configure`` we can't capture warnings using the ``catch_warnings_for_item``\n1375         function because it is not possible to have hookwrappers around ``pytest_configure``.\n1376 \n1377         This function is mainly intended for plugins that need to issue warnings during\n1378         ``pytest_configure`` (or similar stages).\n1379 \n1380         :param warning: The warning instance.\n1381         :param stacklevel: stacklevel forwarded to warnings.warn.\n1382         \"\"\"\n1383         if self.pluginmanager.is_blocked(\"warnings\"):\n1384             return\n1385 \n1386         cmdline_filters = self.known_args_namespace.pythonwarnings or []\n1387         config_filters = self.getini(\"filterwarnings\")\n1388 \n1389         with warnings.catch_warnings(record=True) as records:\n1390             warnings.simplefilter(\"always\", type(warning))\n1391             apply_warning_filters(config_filters, cmdline_filters)\n1392             warnings.warn(warning, stacklevel=stacklevel)\n1393 \n1394         if records:\n1395             frame = sys._getframe(stacklevel - 1)\n1396             location = frame.f_code.co_filename, frame.f_lineno, frame.f_code.co_name\n1397             self.hook.pytest_warning_recorded.call_historic(\n1398                 kwargs=dict(\n1399                     warning_message=records[0],\n1400                     when=\"config\",\n1401                     nodeid=\"\",\n1402                     location=location,\n1403                 )\n1404             )\n1405 \n1406     def addinivalue_line(self, name: str, line: str) -> None:\n1407         \"\"\"Add a line to an ini-file option. The option must have been\n1408         declared but might not yet be set in which case the line becomes\n1409         the first line in its value.\"\"\"\n1410         x = self.getini(name)\n1411         assert isinstance(x, list)\n1412         x.append(line)  # modifies the cached list inline\n1413 \n1414     def getini(self, name: str):\n1415         \"\"\"Return configuration value from an :ref:`ini file <configfiles>`.\n1416 \n1417         If the specified name hasn't been registered through a prior\n1418         :func:`parser.addini <pytest.Parser.addini>` call (usually from a\n1419         plugin), a ValueError is raised.\n1420         \"\"\"\n1421         try:\n1422             return self._inicache[name]\n1423         except KeyError:\n1424             self._inicache[name] = val = self._getini(name)\n1425             return val\n1426 \n1427     # Meant for easy monkeypatching by legacypath plugin.\n1428     # Can be inlined back (with no cover removed) once legacypath is gone.\n1429     def _getini_unknown_type(self, name: str, type: str, value: Union[str, List[str]]):\n1430         msg = f\"unknown configuration type: {type}\"\n1431         raise ValueError(msg, value)  # pragma: no cover\n1432 \n1433     def _getini(self, name: str):\n1434         try:\n1435             description, type, default = self._parser._inidict[name]\n1436         except KeyError as e:\n1437             raise ValueError(f\"unknown configuration value: {name!r}\") from e\n1438         override_value = self._get_override_ini_value(name)\n1439         if override_value is None:\n1440             try:\n1441                 value = self.inicfg[name]\n1442             except KeyError:\n1443                 if default is not None:\n1444                     return default\n1445                 if type is None:\n1446                     return \"\"\n1447                 return []\n1448         else:\n1449             value = override_value\n1450         # Coerce the values based on types.\n1451         #\n1452         # Note: some coercions are only required if we are reading from .ini files, because\n1453         # the file format doesn't contain type information, but when reading from toml we will\n1454         # get either str or list of str values (see _parse_ini_config_from_pyproject_toml).\n1455         # For example:\n1456         #\n1457         #   ini:\n1458         #     a_line_list = \"tests acceptance\"\n1459         #   in this case, we need to split the string to obtain a list of strings.\n1460         #\n1461         #   toml:\n1462         #     a_line_list = [\"tests\", \"acceptance\"]\n1463         #   in this case, we already have a list ready to use.\n1464         #\n1465         if type == \"paths\":\n1466             # TODO: This assert is probably not valid in all cases.\n1467             assert self.inipath is not None\n1468             dp = self.inipath.parent\n1469             input_values = shlex.split(value) if isinstance(value, str) else value\n1470             return [dp / x for x in input_values]\n1471         elif type == \"args\":\n1472             return shlex.split(value) if isinstance(value, str) else value\n1473         elif type == \"linelist\":\n1474             if isinstance(value, str):\n1475                 return [t for t in map(lambda x: x.strip(), value.split(\"\\n\")) if t]\n1476             else:\n1477                 return value\n1478         elif type == \"bool\":\n1479             return _strtobool(str(value).strip())\n1480         elif type == \"string\":\n1481             return value\n1482         elif type is None:\n1483             return value\n1484         else:\n1485             return self._getini_unknown_type(name, type, value)\n1486 \n1487     def _getconftest_pathlist(\n1488         self, name: str, path: Path, rootpath: Path\n1489     ) -> Optional[List[Path]]:\n1490         try:\n1491             mod, relroots = self.pluginmanager._rget_with_confmod(\n1492                 name, path, self.getoption(\"importmode\"), rootpath\n1493             )\n1494         except KeyError:\n1495             return None\n1496         assert mod.__file__ is not None\n1497         modpath = Path(mod.__file__).parent\n1498         values: List[Path] = []\n1499         for relroot in relroots:\n1500             if isinstance(relroot, os.PathLike):\n1501                 relroot = Path(relroot)\n1502             else:\n1503                 relroot = relroot.replace(\"/\", os.sep)\n1504                 relroot = absolutepath(modpath / relroot)\n1505             values.append(relroot)\n1506         return values\n1507 \n1508     def _get_override_ini_value(self, name: str) -> Optional[str]:\n1509         value = None\n1510         # override_ini is a list of \"ini=value\" options.\n1511         # Always use the last item if multiple values are set for same ini-name,\n1512         # e.g. -o foo=bar1 -o foo=bar2 will set foo to bar2.\n1513         for ini_config in self._override_ini:\n1514             try:\n1515                 key, user_ini_value = ini_config.split(\"=\", 1)\n1516             except ValueError as e:\n1517                 raise UsageError(\n1518                     \"-o/--override-ini expects option=value style (got: {!r}).\".format(\n1519                         ini_config\n1520                     )\n1521                 ) from e\n1522             else:\n1523                 if key == name:\n1524                     value = user_ini_value\n1525         return value\n1526 \n1527     def getoption(self, name: str, default=notset, skip: bool = False):\n1528         \"\"\"Return command line option value.\n1529 \n1530         :param name: Name of the option.  You may also specify\n1531             the literal ``--OPT`` option instead of the \"dest\" option name.\n1532         :param default: Default value if no option of that name exists.\n1533         :param skip: If True, raise pytest.skip if option does not exists\n1534             or has a None value.\n1535         \"\"\"\n1536         name = self._opt2dest.get(name, name)\n1537         try:\n1538             val = getattr(self.option, name)\n1539             if val is None and skip:\n1540                 raise AttributeError(name)\n1541             return val\n1542         except AttributeError as e:\n1543             if default is not notset:\n1544                 return default\n1545             if skip:\n1546                 import pytest\n1547 \n1548                 pytest.skip(f\"no {name!r} option found\")\n1549             raise ValueError(f\"no option named {name!r}\") from e\n1550 \n1551     def getvalue(self, name: str, path=None):\n1552         \"\"\"Deprecated, use getoption() instead.\"\"\"\n1553         return self.getoption(name)\n1554 \n1555     def getvalueorskip(self, name: str, path=None):\n1556         \"\"\"Deprecated, use getoption(skip=True) instead.\"\"\"\n1557         return self.getoption(name, skip=True)\n1558 \n1559     def _warn_about_missing_assertion(self, mode: str) -> None:\n1560         if not _assertion_supported():\n1561             if mode == \"plain\":\n1562                 warning_text = (\n1563                     \"ASSERTIONS ARE NOT EXECUTED\"\n1564                     \" and FAILING TESTS WILL PASS.  Are you\"\n1565                     \" using python -O?\"\n1566                 )\n1567             else:\n1568                 warning_text = (\n1569                     \"assertions not in test modules or\"\n1570                     \" plugins will be ignored\"\n1571                     \" because assert statements are not executed \"\n1572                     \"by the underlying Python interpreter \"\n1573                     \"(are you using python -O?)\\n\"\n1574                 )\n1575             self.issue_config_time_warning(\n1576                 PytestConfigWarning(warning_text),\n1577                 stacklevel=3,\n1578             )\n1579 \n1580     def _warn_about_skipped_plugins(self) -> None:\n1581         for module_name, msg in self.pluginmanager.skipped_plugins:\n1582             self.issue_config_time_warning(\n1583                 PytestConfigWarning(f\"skipped plugin {module_name!r}: {msg}\"),\n1584                 stacklevel=2,\n1585             )\n1586 \n1587 \n1588 def _assertion_supported() -> bool:\n1589     try:\n1590         assert False\n1591     except AssertionError:\n1592         return True\n1593     else:\n1594         return False  # type: ignore[unreachable]\n1595 \n1596 \n1597 def create_terminal_writer(\n1598     config: Config, file: Optional[TextIO] = None\n1599 ) -> TerminalWriter:\n1600     \"\"\"Create a TerminalWriter instance configured according to the options\n1601     in the config object.\n1602 \n1603     Every code which requires a TerminalWriter object and has access to a\n1604     config object should use this function.\n1605     \"\"\"\n1606     tw = TerminalWriter(file=file)\n1607 \n1608     if config.option.color == \"yes\":\n1609         tw.hasmarkup = True\n1610     elif config.option.color == \"no\":\n1611         tw.hasmarkup = False\n1612 \n1613     if config.option.code_highlight == \"yes\":\n1614         tw.code_highlight = True\n1615     elif config.option.code_highlight == \"no\":\n1616         tw.code_highlight = False\n1617 \n1618     return tw\n1619 \n1620 \n1621 def _strtobool(val: str) -> bool:\n1622     \"\"\"Convert a string representation of truth to True or False.\n1623 \n1624     True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n1625     are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n1626     'val' is anything else.\n1627 \n1628     .. note:: Copied from distutils.util.\n1629     \"\"\"\n1630     val = val.lower()\n1631     if val in (\"y\", \"yes\", \"t\", \"true\", \"on\", \"1\"):\n1632         return True\n1633     elif val in (\"n\", \"no\", \"f\", \"false\", \"off\", \"0\"):\n1634         return False\n1635     else:\n1636         raise ValueError(f\"invalid truth value {val!r}\")\n1637 \n1638 \n1639 @lru_cache(maxsize=50)\n1640 def parse_warning_filter(\n1641     arg: str, *, escape: bool\n1642 ) -> Tuple[\"warnings._ActionKind\", str, Type[Warning], str, int]:\n1643     \"\"\"Parse a warnings filter string.\n1644 \n1645     This is copied from warnings._setoption with the following changes:\n1646 \n1647     * Does not apply the filter.\n1648     * Escaping is optional.\n1649     * Raises UsageError so we get nice error messages on failure.\n1650     \"\"\"\n1651     __tracebackhide__ = True\n1652     error_template = dedent(\n1653         f\"\"\"\\\n1654         while parsing the following warning configuration:\n1655 \n1656           {arg}\n1657 \n1658         This error occurred:\n1659 \n1660         {{error}}\n1661         \"\"\"\n1662     )\n1663 \n1664     parts = arg.split(\":\")\n1665     if len(parts) > 5:\n1666         doc_url = (\n1667             \"https://docs.python.org/3/library/warnings.html#describing-warning-filters\"\n1668         )\n1669         error = dedent(\n1670             f\"\"\"\\\n1671             Too many fields ({len(parts)}), expected at most 5 separated by colons:\n1672 \n1673               action:message:category:module:line\n1674 \n1675             For more information please consult: {doc_url}\n1676             \"\"\"\n1677         )\n1678         raise UsageError(error_template.format(error=error))\n1679 \n1680     while len(parts) < 5:\n1681         parts.append(\"\")\n1682     action_, message, category_, module, lineno_ = (s.strip() for s in parts)\n1683     try:\n1684         action: \"warnings._ActionKind\" = warnings._getaction(action_)  # type: ignore[attr-defined]\n1685     except warnings._OptionError as e:\n1686         raise UsageError(error_template.format(error=str(e)))\n1687     try:\n1688         category: Type[Warning] = _resolve_warning_category(category_)\n1689     except Exception:\n1690         exc_info = ExceptionInfo.from_current()\n1691         exception_text = exc_info.getrepr(style=\"native\")\n1692         raise UsageError(error_template.format(error=exception_text))\n1693     if message and escape:\n1694         message = re.escape(message)\n1695     if module and escape:\n1696         module = re.escape(module) + r\"\\Z\"\n1697     if lineno_:\n1698         try:\n1699             lineno = int(lineno_)\n1700             if lineno < 0:\n1701                 raise ValueError(\"number is negative\")\n1702         except ValueError as e:\n1703             raise UsageError(\n1704                 error_template.format(error=f\"invalid lineno {lineno_!r}: {e}\")\n1705             )\n1706     else:\n1707         lineno = 0\n1708     return action, message, category, module, lineno\n1709 \n1710 \n1711 def _resolve_warning_category(category: str) -> Type[Warning]:\n1712     \"\"\"\n1713     Copied from warnings._getcategory, but changed so it lets exceptions (specially ImportErrors)\n1714     propagate so we can get access to their tracebacks (#9218).\n1715     \"\"\"\n1716     __tracebackhide__ = True\n1717     if not category:\n1718         return Warning\n1719 \n1720     if \".\" not in category:\n1721         import builtins as m\n1722 \n1723         klass = category\n1724     else:\n1725         module, _, klass = category.rpartition(\".\")\n1726         m = __import__(module, None, None, [klass])\n1727     cat = getattr(m, klass)\n1728     if not issubclass(cat, Warning):\n1729         raise UsageError(f\"{cat} is not a Warning subclass\")\n1730     return cast(Type[Warning], cat)\n1731 \n1732 \n1733 def apply_warning_filters(\n1734     config_filters: Iterable[str], cmdline_filters: Iterable[str]\n1735 ) -> None:\n1736     \"\"\"Applies pytest-configured filters to the warnings module\"\"\"\n1737     # Filters should have this precedence: cmdline options, config.\n1738     # Filters should be applied in the inverse order of precedence.\n1739     for arg in config_filters:\n1740         warnings.filterwarnings(*parse_warning_filter(arg, escape=False))\n1741 \n1742     for arg in cmdline_filters:\n1743         warnings.filterwarnings(*parse_warning_filter(arg, escape=True))\n",
        "intended_behavior": "Modify the logic to include detailed source information when deprecation warnings are issued for old-style hookimpl. This could involve capturing the plugin name or file path during the hook registration phase and feeding this information into the PytestDeprecationWarning message. The objective is to make the warning not just a notification of deprecated practice but also a navigational aid pointing directly to the problematic code."
    }
]