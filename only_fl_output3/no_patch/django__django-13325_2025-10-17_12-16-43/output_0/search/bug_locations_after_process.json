[
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 147,
        "end": 148,
        "class_name": "BaseMemcachedCache",
        "method_name": "delete_many",
        "code": "147     def delete_many(self, keys, version=None):\n148         self._cache.delete_multi(self.make_key(key, version=version) for key in keys)\n",
        "intended_behavior": "Before performing the `delete_multi` operation on cache keys, the method should iterate through each key and validate it using `self.validate_key(key)` to ensure the key's integrity and conformity to the backend's expectations. This validation will prevent potential security risks associated with malicious key values."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 13,
        "end": 155,
        "class_name": "BaseMemcachedCache",
        "method_name": null,
        "code": "13 class BaseMemcachedCache(BaseCache):\n14     def __init__(self, server, params, library, value_not_found_exception):\n15         super().__init__(params)\n16         if isinstance(server, str):\n17             self._servers = re.split('[;,]', server)\n18         else:\n19             self._servers = server\n20 \n21         # Exception type raised by the underlying client library for a\n22         # nonexistent key.\n23         self.LibraryValueNotFoundException = value_not_found_exception\n24 \n25         self._lib = library\n26         self._options = params.get('OPTIONS') or {}\n27 \n28     @property\n29     def _cache(self):\n30         \"\"\"\n31         Implement transparent thread-safe access to a memcached client.\n32         \"\"\"\n33         if getattr(self, '_client', None) is None:\n34             self._client = self._lib.Client(self._servers, **self._options)\n35 \n36         return self._client\n37 \n38     def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT):\n39         \"\"\"\n40         Memcached deals with long (> 30 days) timeouts in a special\n41         way. Call this function to obtain a safe value for your timeout.\n42         \"\"\"\n43         if timeout == DEFAULT_TIMEOUT:\n44             timeout = self.default_timeout\n45 \n46         if timeout is None:\n47             # Using 0 in memcache sets a non-expiring timeout.\n48             return 0\n49         elif int(timeout) == 0:\n50             # Other cache backends treat 0 as set-and-expire. To achieve this\n51             # in memcache backends, a negative timeout must be passed.\n52             timeout = -1\n53 \n54         if timeout > 2592000:  # 60*60*24*30, 30 days\n55             # See https://github.com/memcached/memcached/wiki/Programming#expiration\n56             # \"Expiration times can be set from 0, meaning \"never expire\", to\n57             # 30 days. Any time higher than 30 days is interpreted as a Unix\n58             # timestamp date. If you want to expire an object on January 1st of\n59             # next year, this is how you do that.\"\n60             #\n61             # This means that we have to switch to absolute timestamps.\n62             timeout += int(time.time())\n63         return int(timeout)\n64 \n65     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n66         key = self.make_key(key, version=version)\n67         self.validate_key(key)\n68         return self._cache.add(key, value, self.get_backend_timeout(timeout))\n69 \n70     def get(self, key, default=None, version=None):\n71         key = self.make_key(key, version=version)\n72         self.validate_key(key)\n73         return self._cache.get(key, default)\n74 \n75     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n76         key = self.make_key(key, version=version)\n77         self.validate_key(key)\n78         if not self._cache.set(key, value, self.get_backend_timeout(timeout)):\n79             # make sure the key doesn't keep its old value in case of failure to set (memcached's 1MB limit)\n80             self._cache.delete(key)\n81 \n82     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n83         key = self.make_key(key, version=version)\n84         return bool(self._cache.touch(key, self.get_backend_timeout(timeout)))\n85 \n86     def delete(self, key, version=None):\n87         key = self.make_key(key, version=version)\n88         self.validate_key(key)\n89         return bool(self._cache.delete(key))\n90 \n91     def get_many(self, keys, version=None):\n92         key_map = {self.make_key(key, version=version): key for key in keys}\n93         for key in key_map:\n94             self.validate_key(key)\n95         ret = self._cache.get_multi(key_map.keys())\n96         return {key_map[k]: v for k, v in ret.items()}\n97 \n98     def close(self, **kwargs):\n99         # Many clients don't clean up connections properly.\n100         self._cache.disconnect_all()\n101 \n102     def incr(self, key, delta=1, version=None):\n103         key = self.make_key(key, version=version)\n104         self.validate_key(key)\n105         # memcached doesn't support a negative delta\n106         if delta < 0:\n107             return self._cache.decr(key, -delta)\n108         try:\n109             val = self._cache.incr(key, delta)\n110 \n111         # Normalize an exception raised by the underlying client library to\n112         # ValueError in the event of a nonexistent key when calling incr().\n113         except self.LibraryValueNotFoundException:\n114             val = None\n115         if val is None:\n116             raise ValueError(\"Key '%s' not found\" % key)\n117         return val\n118 \n119     def decr(self, key, delta=1, version=None):\n120         key = self.make_key(key, version=version)\n121         self.validate_key(key)\n122         # memcached doesn't support a negative delta\n123         if delta < 0:\n124             return self._cache.incr(key, -delta)\n125         try:\n126             val = self._cache.decr(key, delta)\n127 \n128         # Normalize an exception raised by the underlying client library to\n129         # ValueError in the event of a nonexistent key when calling decr().\n130         except self.LibraryValueNotFoundException:\n131             val = None\n132         if val is None:\n133             raise ValueError(\"Key '%s' not found\" % key)\n134         return val\n135 \n136     def set_many(self, data, timeout=DEFAULT_TIMEOUT, version=None):\n137         safe_data = {}\n138         original_keys = {}\n139         for key, value in data.items():\n140             safe_key = self.make_key(key, version=version)\n141             self.validate_key(safe_key)\n142             safe_data[safe_key] = value\n143             original_keys[safe_key] = key\n144         failed_keys = self._cache.set_multi(safe_data, self.get_backend_timeout(timeout))\n145         return [original_keys[k] for k in failed_keys]\n146 \n147     def delete_many(self, keys, version=None):\n148         self._cache.delete_multi(self.make_key(key, version=version) for key in keys)\n149 \n150     def clear(self):\n151         self._cache.flush_all()\n152 \n153     def validate_key(self, key):\n154         for warning in memcache_key_warnings(key):\n155             raise InvalidCacheKey(warning)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 174,
        "end": 182,
        "class_name": "MemcachedCache",
        "method_name": "get",
        "code": "174     def get(self, key, default=None, version=None):\n175         key = self.make_key(key, version=version)\n176         val = self._cache.get(key)\n177         # python-memcached doesn't support default values in get().\n178         # https://github.com/linsomniac/python-memcached/issues/159\n179         # Remove this method if that issue is fixed.\n180         if val is None:\n181             return default\n182         return val\n",
        "intended_behavior": "The `get` method should call `self.validate_key(key)` prior to making the key with `self.make_key(key, version=version)` and attempting to retrieve the item from the cache. This ensures that only validated keys are used to access cache data, adhering to security and integrity standards."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 158,
        "end": 189,
        "class_name": "MemcachedCache",
        "method_name": null,
        "code": "158 class MemcachedCache(BaseMemcachedCache):\n159     \"An implementation of a cache binding using python-memcached\"\n160     def __init__(self, server, params):\n161         # python-memcached \u2265 1.45 returns None for a nonexistent key in\n162         # incr/decr(), python-memcached < 1.45 raises ValueError.\n163         import memcache\n164         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)\n165 \n166     @property\n167     def _cache(self):\n168         if getattr(self, '_client', None) is None:\n169             client_kwargs = {'pickleProtocol': pickle.HIGHEST_PROTOCOL}\n170             client_kwargs.update(self._options)\n171             self._client = self._lib.Client(self._servers, **client_kwargs)\n172         return self._client\n173 \n174     def get(self, key, default=None, version=None):\n175         key = self.make_key(key, version=version)\n176         val = self._cache.get(key)\n177         # python-memcached doesn't support default values in get().\n178         # https://github.com/linsomniac/python-memcached/issues/159\n179         # Remove this method if that issue is fixed.\n180         if val is None:\n181             return default\n182         return val\n183 \n184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 184,
        "end": 189,
        "class_name": "MemcachedCache",
        "method_name": "delete",
        "code": "184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n",
        "intended_behavior": "Similar to the `get` method, `delete` must validate the cache key by invoking `self.validate_key(key)` before constructing the key for deletion. This key validation step ensures that only appropriate and valid keys are being removed from the cache, preventing any unintended deletions based on improper keys."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 158,
        "end": 189,
        "class_name": "MemcachedCache",
        "method_name": null,
        "code": "158 class MemcachedCache(BaseMemcachedCache):\n159     \"An implementation of a cache binding using python-memcached\"\n160     def __init__(self, server, params):\n161         # python-memcached \u2265 1.45 returns None for a nonexistent key in\n162         # incr/decr(), python-memcached < 1.45 raises ValueError.\n163         import memcache\n164         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)\n165 \n166     @property\n167     def _cache(self):\n168         if getattr(self, '_client', None) is None:\n169             client_kwargs = {'pickleProtocol': pickle.HIGHEST_PROTOCOL}\n170             client_kwargs.update(self._options)\n171             self._client = self._lib.Client(self._servers, **client_kwargs)\n172         return self._client\n173 \n174     def get(self, key, default=None, version=None):\n175         key = self.make_key(key, version=version)\n176         val = self._cache.get(key)\n177         # python-memcached doesn't support default values in get().\n178         # https://github.com/linsomniac/python-memcached/issues/159\n179         # Remove this method if that issue is fixed.\n180         if val is None:\n181             return default\n182         return val\n183 \n184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 202,
        "end": 206,
        "class_name": "PyLibMCCache",
        "method_name": "touch",
        "code": "202     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n203         key = self.make_key(key, version=version)\n204         if timeout == 0:\n205             return self._cache.delete(key)\n206         return self._cache.touch(key, self.get_backend_timeout(timeout))\n",
        "intended_behavior": "In the `touch` method, before the key is used either to update the cache item's expiration or delete it (if timeout is 0), it should be validated through `self.validate_key(key)`. This ensures the operation is performed on a verified key, upholding the cache's integrity and security according to the backend's rules."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 192,
        "end": 211,
        "class_name": "PyLibMCCache",
        "method_name": null,
        "code": "192 class PyLibMCCache(BaseMemcachedCache):\n193     \"An implementation of a cache binding using pylibmc\"\n194     def __init__(self, server, params):\n195         import pylibmc\n196         super().__init__(server, params, library=pylibmc, value_not_found_exception=pylibmc.NotFound)\n197 \n198     @cached_property\n199     def _cache(self):\n200         return self._lib.Client(self._servers, **self._options)\n201 \n202     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n203         key = self.make_key(key, version=version)\n204         if timeout == 0:\n205             return self._cache.delete(key)\n206         return self._cache.touch(key, self.get_backend_timeout(timeout))\n207 \n208     def close(self, **kwargs):\n209         # libmemcached manages its own connections. Don't call disconnect_all()\n210         # as it resets the failover state and creates unnecessary reconnects.\n211         pass\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]