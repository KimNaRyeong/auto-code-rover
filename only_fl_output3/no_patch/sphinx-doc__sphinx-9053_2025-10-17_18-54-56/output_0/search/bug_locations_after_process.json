[
    {
        "rel_file_path": "sphinx/util/docutils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/util/docutils.py",
        "start": 1,
        "end": 516,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.docutils\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Utility functions for docutils.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import os\n12 import re\n13 from contextlib import contextmanager\n14 from copy import copy\n15 from distutils.version import LooseVersion\n16 from os import path\n17 from types import ModuleType\n18 from typing import (IO, TYPE_CHECKING, Any, Callable, Dict, Generator, List, Optional, Set,\n19                     Tuple, Type, cast)\n20 \n21 import docutils\n22 from docutils import nodes\n23 from docutils.io import FileOutput\n24 from docutils.nodes import Element, Node, system_message\n25 from docutils.parsers.rst import Directive, directives, roles\n26 from docutils.parsers.rst.states import Inliner\n27 from docutils.statemachine import State, StateMachine, StringList\n28 from docutils.utils import Reporter, unescape\n29 \n30 from sphinx.errors import SphinxError\n31 from sphinx.locale import _\n32 from sphinx.util import logging\n33 from sphinx.util.typing import RoleFunction\n34 \n35 logger = logging.getLogger(__name__)\n36 report_re = re.compile('^(.+?:(?:\\\\d+)?): \\\\((DEBUG|INFO|WARNING|ERROR|SEVERE)/(\\\\d+)?\\\\) ')\n37 \n38 if TYPE_CHECKING:\n39     from sphinx.builders import Builder\n40     from sphinx.config import Config\n41     from sphinx.environment import BuildEnvironment\n42 \n43 \n44 __version_info__ = tuple(LooseVersion(docutils.__version__).version)\n45 additional_nodes: Set[Type[Element]] = set()\n46 \n47 \n48 @contextmanager\n49 def docutils_namespace() -> Generator[None, None, None]:\n50     \"\"\"Create namespace for reST parsers.\"\"\"\n51     try:\n52         _directives = copy(directives._directives)  # type: ignore\n53         _roles = copy(roles._roles)  # type: ignore\n54 \n55         yield\n56     finally:\n57         directives._directives = _directives  # type: ignore\n58         roles._roles = _roles  # type: ignore\n59 \n60         for node in list(additional_nodes):\n61             unregister_node(node)\n62             additional_nodes.discard(node)\n63 \n64 \n65 def is_directive_registered(name: str) -> bool:\n66     \"\"\"Check the *name* directive is already registered.\"\"\"\n67     return name in directives._directives  # type: ignore\n68 \n69 \n70 def register_directive(name: str, directive: Type[Directive]) -> None:\n71     \"\"\"Register a directive to docutils.\n72 \n73     This modifies global state of docutils.  So it is better to use this\n74     inside ``docutils_namespace()`` to prevent side-effects.\n75     \"\"\"\n76     directives.register_directive(name, directive)\n77 \n78 \n79 def is_role_registered(name: str) -> bool:\n80     \"\"\"Check the *name* role is already registered.\"\"\"\n81     return name in roles._roles  # type: ignore\n82 \n83 \n84 def register_role(name: str, role: RoleFunction) -> None:\n85     \"\"\"Register a role to docutils.\n86 \n87     This modifies global state of docutils.  So it is better to use this\n88     inside ``docutils_namespace()`` to prevent side-effects.\n89     \"\"\"\n90     roles.register_local_role(name, role)\n91 \n92 \n93 def unregister_role(name: str) -> None:\n94     \"\"\"Unregister a role from docutils.\"\"\"\n95     roles._roles.pop(name, None)  # type: ignore\n96 \n97 \n98 def is_node_registered(node: Type[Element]) -> bool:\n99     \"\"\"Check the *node* is already registered.\"\"\"\n100     return hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__)\n101 \n102 \n103 def register_node(node: Type[Element]) -> None:\n104     \"\"\"Register a node to docutils.\n105 \n106     This modifies global state of some visitors.  So it is better to use this\n107     inside ``docutils_namespace()`` to prevent side-effects.\n108     \"\"\"\n109     if not hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):\n110         nodes._add_node_class_names([node.__name__])  # type: ignore\n111         additional_nodes.add(node)\n112 \n113 \n114 def unregister_node(node: Type[Element]) -> None:\n115     \"\"\"Unregister a node from docutils.\n116 \n117     This is inverse of ``nodes._add_nodes_class_names()``.\n118     \"\"\"\n119     if hasattr(nodes.GenericNodeVisitor, 'visit_' + node.__name__):\n120         delattr(nodes.GenericNodeVisitor, \"visit_\" + node.__name__)\n121         delattr(nodes.GenericNodeVisitor, \"depart_\" + node.__name__)\n122         delattr(nodes.SparseNodeVisitor, 'visit_' + node.__name__)\n123         delattr(nodes.SparseNodeVisitor, 'depart_' + node.__name__)\n124 \n125 \n126 @contextmanager\n127 def patched_get_language() -> Generator[None, None, None]:\n128     \"\"\"Patch docutils.languages.get_language() temporarily.\n129 \n130     This ignores the second argument ``reporter`` to suppress warnings.\n131     refs: https://github.com/sphinx-doc/sphinx/issues/3788\n132     \"\"\"\n133     from docutils.languages import get_language\n134 \n135     def patched_get_language(language_code: str, reporter: Reporter = None) -> Any:\n136         return get_language(language_code)\n137 \n138     try:\n139         docutils.languages.get_language = patched_get_language\n140         yield\n141     finally:\n142         # restore original implementations\n143         docutils.languages.get_language = get_language\n144 \n145 \n146 @contextmanager\n147 def using_user_docutils_conf(confdir: Optional[str]) -> Generator[None, None, None]:\n148     \"\"\"Let docutils know the location of ``docutils.conf`` for Sphinx.\"\"\"\n149     try:\n150         docutilsconfig = os.environ.get('DOCUTILSCONFIG', None)\n151         if confdir:\n152             os.environ['DOCUTILSCONFIG'] = path.join(path.abspath(confdir), 'docutils.conf')\n153 \n154         yield\n155     finally:\n156         if docutilsconfig is None:\n157             os.environ.pop('DOCUTILSCONFIG', None)\n158         else:\n159             os.environ['DOCUTILSCONFIG'] = docutilsconfig\n160 \n161 \n162 @contextmanager\n163 def patch_docutils(confdir: Optional[str] = None) -> Generator[None, None, None]:\n164     \"\"\"Patch to docutils temporarily.\"\"\"\n165     with patched_get_language(), using_user_docutils_conf(confdir):\n166         yield\n167 \n168 \n169 class ElementLookupError(Exception):\n170     pass\n171 \n172 \n173 class sphinx_domains:\n174     \"\"\"Monkey-patch directive and role dispatch, so that domain-specific\n175     markup takes precedence.\n176     \"\"\"\n177     def __init__(self, env: \"BuildEnvironment\") -> None:\n178         self.env = env\n179         self.directive_func: Callable = None\n180         self.roles_func: Callable = None\n181 \n182     def __enter__(self) -> None:\n183         self.enable()\n184 \n185     def __exit__(self, exc_type: Type[Exception], exc_value: Exception, traceback: Any) -> None:  # NOQA\n186         self.disable()\n187 \n188     def enable(self) -> None:\n189         self.directive_func = directives.directive\n190         self.role_func = roles.role\n191 \n192         directives.directive = self.lookup_directive\n193         roles.role = self.lookup_role\n194 \n195     def disable(self) -> None:\n196         directives.directive = self.directive_func\n197         roles.role = self.role_func\n198 \n199     def lookup_domain_element(self, type: str, name: str) -> Any:\n200         \"\"\"Lookup a markup element (directive or role), given its name which can\n201         be a full name (with domain).\n202         \"\"\"\n203         name = name.lower()\n204         # explicit domain given?\n205         if ':' in name:\n206             domain_name, name = name.split(':', 1)\n207             if domain_name in self.env.domains:\n208                 domain = self.env.get_domain(domain_name)\n209                 element = getattr(domain, type)(name)\n210                 if element is not None:\n211                     return element, []\n212             else:\n213                 logger.warning(_('unknown directive or role name: %s:%s'), domain_name, name)\n214         # else look in the default domain\n215         else:\n216             def_domain = self.env.temp_data.get('default_domain')\n217             if def_domain is not None:\n218                 element = getattr(def_domain, type)(name)\n219                 if element is not None:\n220                     return element, []\n221 \n222         # always look in the std domain\n223         element = getattr(self.env.get_domain('std'), type)(name)\n224         if element is not None:\n225             return element, []\n226 \n227         raise ElementLookupError\n228 \n229     def lookup_directive(self, directive_name: str, language_module: ModuleType, document: nodes.document) -> Tuple[Optional[Type[Directive]], List[system_message]]:  # NOQA\n230         try:\n231             return self.lookup_domain_element('directive', directive_name)\n232         except ElementLookupError:\n233             return self.directive_func(directive_name, language_module, document)\n234 \n235     def lookup_role(self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter) -> Tuple[RoleFunction, List[system_message]]:  # NOQA\n236         try:\n237             return self.lookup_domain_element('role', role_name)\n238         except ElementLookupError:\n239             return self.role_func(role_name, language_module, lineno, reporter)\n240 \n241 \n242 class WarningStream:\n243     def write(self, text: str) -> None:\n244         matched = report_re.search(text)\n245         if not matched:\n246             logger.warning(text.rstrip(\"\\r\\n\"))\n247         else:\n248             location, type, level = matched.groups()\n249             message = report_re.sub('', text).rstrip()\n250             logger.log(type, message, location=location)\n251 \n252 \n253 class LoggingReporter(Reporter):\n254     @classmethod\n255     def from_reporter(cls, reporter: Reporter) -> \"LoggingReporter\":\n256         \"\"\"Create an instance of LoggingReporter from other reporter object.\"\"\"\n257         return cls(reporter.source, reporter.report_level, reporter.halt_level,\n258                    reporter.debug_flag, reporter.error_handler)\n259 \n260     def __init__(self, source: str, report_level: int = Reporter.WARNING_LEVEL,\n261                  halt_level: int = Reporter.SEVERE_LEVEL, debug: bool = False,\n262                  error_handler: str = 'backslashreplace') -> None:\n263         stream = cast(IO, WarningStream())\n264         super().__init__(source, report_level, halt_level,\n265                          stream, debug, error_handler=error_handler)\n266 \n267 \n268 class NullReporter(Reporter):\n269     \"\"\"A dummy reporter; write nothing.\"\"\"\n270 \n271     def __init__(self) -> None:\n272         super().__init__('', 999, 4)\n273 \n274 \n275 def is_html5_writer_available() -> bool:\n276     return __version_info__ > (0, 13, 0)\n277 \n278 \n279 @contextmanager\n280 def switch_source_input(state: State, content: StringList) -> Generator[None, None, None]:\n281     \"\"\"Switch current source input of state temporarily.\"\"\"\n282     try:\n283         # remember the original ``get_source_and_line()`` method\n284         get_source_and_line = state.memo.reporter.get_source_and_line  # type: ignore\n285 \n286         # replace it by new one\n287         state_machine = StateMachine([], None)\n288         state_machine.input_lines = content\n289         state.memo.reporter.get_source_and_line = state_machine.get_source_and_line  # type: ignore  # NOQA\n290 \n291         yield\n292     finally:\n293         # restore the method\n294         state.memo.reporter.get_source_and_line = get_source_and_line  # type: ignore\n295 \n296 \n297 class SphinxFileOutput(FileOutput):\n298     \"\"\"Better FileOutput class for Sphinx.\"\"\"\n299 \n300     def __init__(self, **kwargs: Any) -> None:\n301         self.overwrite_if_changed = kwargs.pop('overwrite_if_changed', False)\n302         super().__init__(**kwargs)\n303 \n304     def write(self, data: str) -> str:\n305         if (self.destination_path and self.autoclose and 'b' not in self.mode and\n306                 self.overwrite_if_changed and os.path.exists(self.destination_path)):\n307             with open(self.destination_path, encoding=self.encoding) as f:\n308                 # skip writing: content not changed\n309                 if f.read() == data:\n310                     return data\n311 \n312         return super().write(data)\n313 \n314 \n315 class SphinxDirective(Directive):\n316     \"\"\"A base class for Sphinx directives.\n317 \n318     This class provides helper methods for Sphinx directives.\n319 \n320     .. note:: The subclasses of this class might not work with docutils.\n321               This class is strongly coupled with Sphinx.\n322     \"\"\"\n323 \n324     @property\n325     def env(self) -> \"BuildEnvironment\":\n326         \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n327         return self.state.document.settings.env\n328 \n329     @property\n330     def config(self) -> \"Config\":\n331         \"\"\"Reference to the :class:`.Config` object.\"\"\"\n332         return self.env.config\n333 \n334     def get_source_info(self) -> Tuple[str, int]:\n335         \"\"\"Get source and line number.\"\"\"\n336         return self.state_machine.get_source_and_line(self.lineno)\n337 \n338     def set_source_info(self, node: Node) -> None:\n339         \"\"\"Set source and line number to the node.\"\"\"\n340         node.source, node.line = self.get_source_info()\n341 \n342 \n343 class SphinxRole:\n344     \"\"\"A base class for Sphinx roles.\n345 \n346     This class provides helper methods for Sphinx roles.\n347 \n348     .. note:: The subclasses of this class might not work with docutils.\n349               This class is strongly coupled with Sphinx.\n350     \"\"\"\n351     name: str           #: The role name actually used in the document.\n352     rawtext: str        #: A string containing the entire interpreted text input.\n353     text: str           #: The interpreted text content.\n354     lineno: int         #: The line number where the interpreted text begins.\n355     inliner: Inliner    #: The ``docutils.parsers.rst.states.Inliner`` object.\n356     options: Dict       #: A dictionary of directive options for customization\n357                         #: (from the \"role\" directive).\n358     content: List[str]  #: A list of strings, the directive content for customization\n359                         #: (from the \"role\" directive).\n360 \n361     def __call__(self, name: str, rawtext: str, text: str, lineno: int,\n362                  inliner: Inliner, options: Dict = {}, content: List[str] = []\n363                  ) -> Tuple[List[Node], List[system_message]]:\n364         self.rawtext = rawtext\n365         self.text = unescape(text)\n366         self.lineno = lineno\n367         self.inliner = inliner\n368         self.options = options\n369         self.content = content\n370 \n371         # guess role type\n372         if name:\n373             self.name = name.lower()\n374         else:\n375             self.name = self.env.temp_data.get('default_role')\n376             if not self.name:\n377                 self.name = self.env.config.default_role\n378             if not self.name:\n379                 raise SphinxError('cannot determine default role!')\n380 \n381         return self.run()\n382 \n383     def run(self) -> Tuple[List[Node], List[system_message]]:\n384         raise NotImplementedError\n385 \n386     @property\n387     def env(self) -> \"BuildEnvironment\":\n388         \"\"\"Reference to the :class:`.BuildEnvironment` object.\"\"\"\n389         return self.inliner.document.settings.env\n390 \n391     @property\n392     def config(self) -> \"Config\":\n393         \"\"\"Reference to the :class:`.Config` object.\"\"\"\n394         return self.env.config\n395 \n396     def get_source_info(self, lineno: int = None) -> Tuple[str, int]:\n397         if lineno is None:\n398             lineno = self.lineno\n399         return self.inliner.reporter.get_source_and_line(lineno)  # type: ignore\n400 \n401     def set_source_info(self, node: Node, lineno: int = None) -> None:\n402         node.source, node.line = self.get_source_info(lineno)\n403 \n404 \n405 class ReferenceRole(SphinxRole):\n406     \"\"\"A base class for reference roles.\n407 \n408     The reference roles can accpet ``link title <target>`` style as a text for\n409     the role.  The parsed result; link title and target will be stored to\n410     ``self.title`` and ``self.target``.\n411     \"\"\"\n412     has_explicit_title: bool    #: A boolean indicates the role has explicit title or not.\n413     disabled: bool              #: A boolean indicates the reference is disabled.\n414     title: str                  #: The link title for the interpreted text.\n415     target: str                 #: The link target for the interpreted text.\n416 \n417     # \\x00 means the \"<\" was backslash-escaped\n418     explicit_title_re = re.compile(r'^(.+?)\\s*(?<!\\x00)<(.*?)>$', re.DOTALL)\n419 \n420     def __call__(self, name: str, rawtext: str, text: str, lineno: int,\n421                  inliner: Inliner, options: Dict = {}, content: List[str] = []\n422                  ) -> Tuple[List[Node], List[system_message]]:\n423         # if the first character is a bang, don't cross-reference at all\n424         self.disabled = text.startswith('!')\n425 \n426         matched = self.explicit_title_re.match(text)\n427         if matched:\n428             self.has_explicit_title = True\n429             self.title = unescape(matched.group(1))\n430             self.target = unescape(matched.group(2))\n431         else:\n432             self.has_explicit_title = False\n433             self.title = unescape(text)\n434             self.target = unescape(text)\n435 \n436         return super().__call__(name, rawtext, text, lineno, inliner, options, content)\n437 \n438 \n439 class SphinxTranslator(nodes.NodeVisitor):\n440     \"\"\"A base class for Sphinx translators.\n441 \n442     This class adds a support for visitor/departure method for super node class\n443     if visitor/departure method for node class is not found.\n444 \n445     It also provides helper methods for Sphinx translators.\n446 \n447     .. note:: The subclasses of this class might not work with docutils.\n448               This class is strongly coupled with Sphinx.\n449     \"\"\"\n450 \n451     def __init__(self, document: nodes.document, builder: \"Builder\") -> None:\n452         super().__init__(document)\n453         self.builder = builder\n454         self.config = builder.config\n455         self.settings = document.settings\n456 \n457     def dispatch_visit(self, node: Node) -> None:\n458         \"\"\"\n459         Dispatch node to appropriate visitor method.\n460         The priority of visitor method is:\n461 \n462         1. ``self.visit_{node_class}()``\n463         2. ``self.visit_{super_node_class}()``\n464         3. ``self.unknown_visit()``\n465         \"\"\"\n466         for node_class in node.__class__.__mro__:\n467             method = getattr(self, 'visit_%s' % (node_class.__name__), None)\n468             if method:\n469                 method(node)\n470                 break\n471         else:\n472             super().dispatch_visit(node)\n473 \n474     def dispatch_departure(self, node: Node) -> None:\n475         \"\"\"\n476         Dispatch node to appropriate departure method.\n477         The priority of departure method is:\n478 \n479         1. ``self.depart_{node_class}()``\n480         2. ``self.depart_{super_node_class}()``\n481         3. ``self.unknown_departure()``\n482         \"\"\"\n483         for node_class in node.__class__.__mro__:\n484             method = getattr(self, 'depart_%s' % (node_class.__name__), None)\n485             if method:\n486                 method(node)\n487                 break\n488         else:\n489             super().dispatch_departure(node)\n490 \n491 \n492 # cache a vanilla instance of nodes.document\n493 # Used in new_document() function\n494 __document_cache__: nodes.document = None\n495 \n496 \n497 def new_document(source_path: str, settings: Any = None) -> nodes.document:\n498     \"\"\"Return a new empty document object.  This is an alternative of docutils'.\n499 \n500     This is a simple wrapper for ``docutils.utils.new_document()``.  It\n501     caches the result of docutils' and use it on second call for instantiation.\n502     This makes an instantiation of document nodes much faster.\n503     \"\"\"\n504     global __document_cache__\n505     if __document_cache__ is None:\n506         __document_cache__ = docutils.utils.new_document(source_path)\n507 \n508     if settings is None:\n509         # Make a copy of ``settings`` from cache to accelerate instansiation\n510         settings = copy(__document_cache__.settings)\n511 \n512     # Create a new instance of nodes.document using cached reporter\n513     from sphinx import addnodes\n514     document = addnodes.document(settings, __document_cache__.reporter, source=source_path)\n515     document.note_source(source_path, -1)\n516     return document\n",
        "intended_behavior": "This file appears central to the project's interaction with docutils and may require adjustments or the addition of compatibility checks to ensure that features or APIs that have changed in docutils 0.17b1 are correctly handled. It should ensure that any deprecated features are substituted with their newer counterparts while maintaining backward compatibility with earlier versions of docutils where possible."
    },
    {
        "rel_file_path": "sphinx/application.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/application.py",
        "start": 1,
        "end": 1295,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.application\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Sphinx application class and extensibility interface.\n6 \n7     Gracefully adapted from the TextPress system by Armin.\n8 \n9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import os\n14 import pickle\n15 import platform\n16 import sys\n17 from collections import deque\n18 from io import StringIO\n19 from os import path\n20 from typing import IO, TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Type, Union\n21 \n22 from docutils import nodes\n23 from docutils.nodes import Element, TextElement\n24 from docutils.parsers import Parser\n25 from docutils.parsers.rst import Directive, roles\n26 from docutils.transforms import Transform\n27 from pygments.lexer import Lexer\n28 \n29 import sphinx\n30 from sphinx import locale, package_dir\n31 from sphinx.config import Config\n32 from sphinx.domains import Domain, Index\n33 from sphinx.environment import BuildEnvironment\n34 from sphinx.environment.collectors import EnvironmentCollector\n35 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError\n36 from sphinx.events import EventManager\n37 from sphinx.extension import Extension\n38 from sphinx.highlighting import lexer_classes\n39 from sphinx.locale import __\n40 from sphinx.project import Project\n41 from sphinx.registry import SphinxComponentRegistry\n42 from sphinx.roles import XRefRole\n43 from sphinx.theming import Theme\n44 from sphinx.util import docutils, logging, progress_message\n45 from sphinx.util.build_phase import BuildPhase\n46 from sphinx.util.console import bold  # type: ignore\n47 from sphinx.util.i18n import CatalogRepository\n48 from sphinx.util.logging import prefixed_warnings\n49 from sphinx.util.osutil import abspath, ensuredir, relpath\n50 from sphinx.util.tags import Tags\n51 from sphinx.util.typing import RoleFunction, TitleGetter\n52 \n53 if TYPE_CHECKING:\n54     from docutils.nodes import Node  # NOQA\n55 \n56     from sphinx.builders import Builder\n57 \n58 \n59 builtin_extensions = (\n60     'sphinx.addnodes',\n61     'sphinx.builders.changes',\n62     'sphinx.builders.epub3',\n63     'sphinx.builders.dirhtml',\n64     'sphinx.builders.dummy',\n65     'sphinx.builders.gettext',\n66     'sphinx.builders.html',\n67     'sphinx.builders.latex',\n68     'sphinx.builders.linkcheck',\n69     'sphinx.builders.manpage',\n70     'sphinx.builders.singlehtml',\n71     'sphinx.builders.texinfo',\n72     'sphinx.builders.text',\n73     'sphinx.builders.xml',\n74     'sphinx.config',\n75     'sphinx.domains.c',\n76     'sphinx.domains.changeset',\n77     'sphinx.domains.citation',\n78     'sphinx.domains.cpp',\n79     'sphinx.domains.index',\n80     'sphinx.domains.javascript',\n81     'sphinx.domains.math',\n82     'sphinx.domains.python',\n83     'sphinx.domains.rst',\n84     'sphinx.domains.std',\n85     'sphinx.directives',\n86     'sphinx.directives.code',\n87     'sphinx.directives.other',\n88     'sphinx.directives.patches',\n89     'sphinx.extension',\n90     'sphinx.parsers',\n91     'sphinx.registry',\n92     'sphinx.roles',\n93     'sphinx.transforms',\n94     'sphinx.transforms.compact_bullet_list',\n95     'sphinx.transforms.i18n',\n96     'sphinx.transforms.references',\n97     'sphinx.transforms.post_transforms',\n98     'sphinx.transforms.post_transforms.code',\n99     'sphinx.transforms.post_transforms.images',\n100     'sphinx.util.compat',\n101     'sphinx.versioning',\n102     # collectors should be loaded by specific order\n103     'sphinx.environment.collectors.dependencies',\n104     'sphinx.environment.collectors.asset',\n105     'sphinx.environment.collectors.metadata',\n106     'sphinx.environment.collectors.title',\n107     'sphinx.environment.collectors.toctree',\n108     # 1st party extensions\n109     'sphinxcontrib.applehelp',\n110     'sphinxcontrib.devhelp',\n111     'sphinxcontrib.htmlhelp',\n112     'sphinxcontrib.serializinghtml',\n113     'sphinxcontrib.qthelp',\n114     # Strictly, alabaster theme is not a builtin extension,\n115     # but it is loaded automatically to use it as default theme.\n116     'alabaster',\n117 )\n118 \n119 ENV_PICKLE_FILENAME = 'environment.pickle'\n120 \n121 logger = logging.getLogger(__name__)\n122 \n123 \n124 class Sphinx:\n125     \"\"\"The main application class and extensibility interface.\n126 \n127     :ivar srcdir: Directory containing source.\n128     :ivar confdir: Directory containing ``conf.py``.\n129     :ivar doctreedir: Directory for storing pickled doctrees.\n130     :ivar outdir: Directory for storing build documents.\n131     \"\"\"\n132 \n133     warningiserror: bool\n134     _warncount: int\n135 \n136     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,\n137                  buildername: str, confoverrides: Dict = None,\n138                  status: IO = sys.stdout, warning: IO = sys.stderr,\n139                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,\n140                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:\n141         self.phase = BuildPhase.INITIALIZATION\n142         self.verbosity = verbosity\n143         self.extensions: Dict[str, Extension] = {}\n144         self.builder: Builder = None\n145         self.env: BuildEnvironment = None\n146         self.project: Project = None\n147         self.registry = SphinxComponentRegistry()\n148         self.html_themes: Dict[str, str] = {}\n149 \n150         # validate provided directories\n151         self.srcdir = abspath(srcdir)\n152         self.outdir = abspath(outdir)\n153         self.doctreedir = abspath(doctreedir)\n154         self.confdir = confdir\n155         if self.confdir:  # confdir is optional\n156             self.confdir = abspath(self.confdir)\n157             if not path.isfile(path.join(self.confdir, 'conf.py')):\n158                 raise ApplicationError(__(\"config directory doesn't contain a \"\n159                                           \"conf.py file (%s)\") % confdir)\n160 \n161         if not path.isdir(self.srcdir):\n162             raise ApplicationError(__('Cannot find source directory (%s)') %\n163                                    self.srcdir)\n164 \n165         if path.exists(self.outdir) and not path.isdir(self.outdir):\n166             raise ApplicationError(__('Output directory (%s) is not a directory') %\n167                                    self.outdir)\n168 \n169         if self.srcdir == self.outdir:\n170             raise ApplicationError(__('Source directory and destination '\n171                                       'directory cannot be identical'))\n172 \n173         self.parallel = parallel\n174 \n175         if status is None:\n176             self._status: IO = StringIO()\n177             self.quiet = True\n178         else:\n179             self._status = status\n180             self.quiet = False\n181 \n182         if warning is None:\n183             self._warning: IO = StringIO()\n184         else:\n185             self._warning = warning\n186         self._warncount = 0\n187         self.keep_going = warningiserror and keep_going\n188         if self.keep_going:\n189             self.warningiserror = False\n190         else:\n191             self.warningiserror = warningiserror\n192         logging.setup(self, self._status, self._warning)\n193 \n194         self.events = EventManager(self)\n195 \n196         # keep last few messages for traceback\n197         # This will be filled by sphinx.util.logging.LastMessagesWriter\n198         self.messagelog: deque = deque(maxlen=10)\n199 \n200         # say hello to the world\n201         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))\n202 \n203         # notice for parallel build on macOS and py38+\n204         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:\n205             logger.info(bold(__(\"For security reason, parallel mode is disabled on macOS and \"\n206                                 \"python3.8 and above. For more details, please read \"\n207                                 \"https://github.com/sphinx-doc/sphinx/issues/6803\")))\n208 \n209         # status code for command-line application\n210         self.statuscode = 0\n211 \n212         # read config\n213         self.tags = Tags(tags)\n214         if self.confdir is None:\n215             self.config = Config({}, confoverrides or {})\n216         else:\n217             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)\n218 \n219         # initialize some limited config variables before initialize i18n and loading\n220         # extensions\n221         self.config.pre_init_values()\n222 \n223         # set up translation infrastructure\n224         self._init_i18n()\n225 \n226         # check the Sphinx version if requested\n227         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:\n228             raise VersionRequirementError(\n229                 __('This project needs at least Sphinx v%s and therefore cannot '\n230                    'be built with this version.') % self.config.needs_sphinx)\n231 \n232         # set confdir to srcdir if -C given (!= no confdir); a few pieces\n233         # of code expect a confdir to be set\n234         if self.confdir is None:\n235             self.confdir = self.srcdir\n236 \n237         # load all built-in extension modules\n238         for extension in builtin_extensions:\n239             self.setup_extension(extension)\n240 \n241         # load all user-given extension modules\n242         for extension in self.config.extensions:\n243             self.setup_extension(extension)\n244 \n245         # preload builder module (before init config values)\n246         self.preload_builder(buildername)\n247 \n248         if not path.isdir(outdir):\n249             with progress_message(__('making output directory')):\n250                 ensuredir(outdir)\n251 \n252         # the config file itself can be an extension\n253         if self.config.setup:\n254             prefix = __('while setting up extension %s:') % \"conf.py\"\n255             with prefixed_warnings(prefix):\n256                 if callable(self.config.setup):\n257                     self.config.setup(self)\n258                 else:\n259                     raise ConfigError(\n260                         __(\"'setup' as currently defined in conf.py isn't a Python callable. \"\n261                            \"Please modify its definition to make it a callable function. \"\n262                            \"This is needed for conf.py to behave as a Sphinx extension.\")\n263                     )\n264 \n265         # now that we know all config values, collect them from conf.py\n266         self.config.init_values()\n267         self.events.emit('config-inited', self.config)\n268 \n269         # create the project\n270         self.project = Project(self.srcdir, self.config.source_suffix)\n271         # create the builder\n272         self.builder = self.create_builder(buildername)\n273         # set up the build environment\n274         self._init_env(freshenv)\n275         # set up the builder\n276         self._init_builder()\n277 \n278     def _init_i18n(self) -> None:\n279         \"\"\"Load translated strings from the configured localedirs if enabled in\n280         the configuration.\n281         \"\"\"\n282         if self.config.language is None:\n283             self.translator, has_translation = locale.init([], None)\n284         else:\n285             logger.info(bold(__('loading translations [%s]... ') % self.config.language),\n286                         nonl=True)\n287 \n288             # compile mo files if sphinx.po file in user locale directories are updated\n289             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,\n290                                      self.config.language, self.config.source_encoding)\n291             for catalog in repo.catalogs:\n292                 if catalog.domain == 'sphinx' and catalog.is_outdated():\n293                     catalog.write_mo(self.config.language)\n294 \n295             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)\n296             locale_dirs += [None]\n297             locale_dirs += [path.join(package_dir, 'locale')]\n298 \n299             self.translator, has_translation = locale.init(locale_dirs, self.config.language)\n300             if has_translation or self.config.language == 'en':\n301                 # \"en\" never needs to be translated\n302                 logger.info(__('done'))\n303             else:\n304                 logger.info(__('not available for built-in messages'))\n305 \n306     def _init_env(self, freshenv: bool) -> None:\n307         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n308         if freshenv or not os.path.exists(filename):\n309             self.env = BuildEnvironment()\n310             self.env.setup(self)\n311             self.env.find_files(self.config, self.builder)\n312         else:\n313             try:\n314                 with progress_message(__('loading pickled environment')):\n315                     with open(filename, 'rb') as f:\n316                         self.env = pickle.load(f)\n317                         self.env.setup(self)\n318             except Exception as err:\n319                 logger.info(__('failed: %s'), err)\n320                 self._init_env(freshenv=True)\n321 \n322     def preload_builder(self, name: str) -> None:\n323         self.registry.preload_builder(self, name)\n324 \n325     def create_builder(self, name: str) -> \"Builder\":\n326         if name is None:\n327             logger.info(__('No builder selected, using default: html'))\n328             name = 'html'\n329 \n330         return self.registry.create_builder(self, name)\n331 \n332     def _init_builder(self) -> None:\n333         self.builder.set_environment(self.env)\n334         self.builder.init()\n335         self.events.emit('builder-inited')\n336 \n337     # ---- main \"build\" method -------------------------------------------------\n338 \n339     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:\n340         self.phase = BuildPhase.READING\n341         try:\n342             if force_all:\n343                 self.builder.compile_all_catalogs()\n344                 self.builder.build_all()\n345             elif filenames:\n346                 self.builder.compile_specific_catalogs(filenames)\n347                 self.builder.build_specific(filenames)\n348             else:\n349                 self.builder.compile_update_catalogs()\n350                 self.builder.build_update()\n351 \n352             if self._warncount and self.keep_going:\n353                 self.statuscode = 1\n354 \n355             status = (__('succeeded') if self.statuscode == 0\n356                       else __('finished with problems'))\n357             if self._warncount:\n358                 if self.warningiserror:\n359                     if self._warncount == 1:\n360                         msg = __('build %s, %s warning (with warnings treated as errors).')\n361                     else:\n362                         msg = __('build %s, %s warnings (with warnings treated as errors).')\n363                 else:\n364                     if self._warncount == 1:\n365                         msg = __('build %s, %s warning.')\n366                     else:\n367                         msg = __('build %s, %s warnings.')\n368 \n369                 logger.info(bold(msg % (status, self._warncount)))\n370             else:\n371                 logger.info(bold(__('build %s.') % status))\n372 \n373             if self.statuscode == 0 and self.builder.epilog:\n374                 logger.info('')\n375                 logger.info(self.builder.epilog % {\n376                     'outdir': relpath(self.outdir),\n377                     'project': self.config.project\n378                 })\n379         except Exception as err:\n380             # delete the saved env to force a fresh build next time\n381             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n382             if path.isfile(envfile):\n383                 os.unlink(envfile)\n384             self.events.emit('build-finished', err)\n385             raise\n386         else:\n387             self.events.emit('build-finished', None)\n388         self.builder.cleanup()\n389 \n390     # ---- general extensibility interface -------------------------------------\n391 \n392     def setup_extension(self, extname: str) -> None:\n393         \"\"\"Import and setup a Sphinx extension module.\n394 \n395         Load the extension given by the module *name*.  Use this if your\n396         extension needs the features provided by another extension.  No-op if\n397         called twice.\n398         \"\"\"\n399         logger.debug('[app] setting up extension: %r', extname)\n400         self.registry.load_extension(self, extname)\n401 \n402     def require_sphinx(self, version: str) -> None:\n403         \"\"\"Check the Sphinx version if requested.\n404 \n405         Compare *version* with the version of the running Sphinx, and abort the\n406         build when it is too old.\n407 \n408         :param version: The required version in the form of ``major.minor``.\n409 \n410         .. versionadded:: 1.0\n411         \"\"\"\n412         if version > sphinx.__display_version__[:3]:\n413             raise VersionRequirementError(version)\n414 \n415     # event interface\n416     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:\n417         \"\"\"Register *callback* to be called when *event* is emitted.\n418 \n419         For details on available core events and the arguments of callback\n420         functions, please see :ref:`events`.\n421 \n422         :param event: The name of target event\n423         :param callback: Callback function for the event\n424         :param priority: The priority of the callback.  The callbacks will be invoked\n425                          in the order of *priority* in asending.\n426         :return: A listener ID.  It can be used for :meth:`disconnect`.\n427 \n428         .. versionchanged:: 3.0\n429 \n430            Support *priority*\n431         \"\"\"\n432         listener_id = self.events.connect(event, callback, priority)\n433         logger.debug('[app] connecting event %r (%d): %r [id=%s]',\n434                      event, priority, callback, listener_id)\n435         return listener_id\n436 \n437     def disconnect(self, listener_id: int) -> None:\n438         \"\"\"Unregister callback by *listener_id*.\n439 \n440         :param listener_id: A listener_id that :meth:`connect` returns\n441         \"\"\"\n442         logger.debug('[app] disconnecting event: [id=%s]', listener_id)\n443         self.events.disconnect(listener_id)\n444 \n445     def emit(self, event: str, *args: Any,\n446              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:\n447         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n448 \n449         Return the return values of all callbacks as a list.  Do not emit core\n450         Sphinx events in extensions!\n451 \n452         :param event: The name of event that will be emitted\n453         :param args: The arguments for the event\n454         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks\n455 \n456         .. versionchanged:: 3.1\n457 \n458            Added *allowed_exceptions* to specify path-through exceptions\n459         \"\"\"\n460         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)\n461 \n462     def emit_firstresult(self, event: str, *args: Any,\n463                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:\n464         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n465 \n466         Return the result of the first callback that doesn't return ``None``.\n467 \n468         :param event: The name of event that will be emitted\n469         :param args: The arguments for the event\n470         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks\n471 \n472         .. versionadded:: 0.5\n473         .. versionchanged:: 3.1\n474 \n475            Added *allowed_exceptions* to specify path-through exceptions\n476         \"\"\"\n477         return self.events.emit_firstresult(event, *args,\n478                                             allowed_exceptions=allowed_exceptions)\n479 \n480     # registering addon parts\n481 \n482     def add_builder(self, builder: Type[\"Builder\"], override: bool = False) -> None:\n483         \"\"\"Register a new builder.\n484 \n485         :param builder: A builder class\n486         :param override: If true, install the builder forcedly even if another builder\n487                          is already installed as the same name\n488 \n489         .. versionchanged:: 1.8\n490            Add *override* keyword.\n491         \"\"\"\n492         self.registry.add_builder(builder, override=override)\n493 \n494     # TODO(stephenfin): Describe 'types' parameter\n495     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],\n496                          types: Any = ()) -> None:\n497         \"\"\"Register a configuration value.\n498 \n499         This is necessary for Sphinx to recognize new values and set default\n500         values accordingly.\n501 \n502 \n503         :param name: The name of configuration value.  It is recommended to be prefixed\n504                      with the extension name (ex. ``html_logo``, ``epub_title``)\n505         :param default: The default value of the configuration.\n506         :param rebuild: The condition of rebuild.  It must be one of those values:\n507 \n508                         * ``'env'`` if a change in the setting only takes effect when a\n509                           document is parsed -- this means that the whole environment must be\n510                           rebuilt.\n511                         * ``'html'`` if a change in the setting needs a full rebuild of HTML\n512                           documents.\n513                         * ``''`` if a change in the setting will not need any special rebuild.\n514         :param types: The type of configuration value.  A list of types can be specified.  For\n515                       example, ``[str]`` is used to describe a configuration that takes string\n516                       value.\n517 \n518         .. versionchanged:: 0.4\n519            If the *default* value is a callable, it will be called with the\n520            config object as its argument in order to get the default value.\n521            This can be used to implement config values whose default depends on\n522            other values.\n523 \n524         .. versionchanged:: 0.6\n525            Changed *rebuild* from a simple boolean (equivalent to ``''`` or\n526            ``'env'``) to a string.  However, booleans are still accepted and\n527            converted internally.\n528         \"\"\"\n529         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))\n530         if rebuild in (False, True):\n531             rebuild = 'env' if rebuild else ''\n532         self.config.add(name, default, rebuild, types)\n533 \n534     def add_event(self, name: str) -> None:\n535         \"\"\"Register an event called *name*.\n536 \n537         This is needed to be able to emit it.\n538 \n539         :param name: The name of the event\n540         \"\"\"\n541         logger.debug('[app] adding event: %r', name)\n542         self.events.add(name)\n543 \n544     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],\n545                        override: bool = False) -> None:\n546         \"\"\"Register or override a Docutils translator class.\n547 \n548         This is used to register a custom output translator or to replace a\n549         builtin translator.  This allows extensions to use custom translator\n550         and define custom nodes for the translator (see :meth:`add_node`).\n551 \n552         :param name: The name of builder for the translator\n553         :param translator_class: A translator class\n554         :param override: If true, install the translator forcedly even if another translator\n555                          is already installed as the same name\n556 \n557         .. versionadded:: 1.3\n558         .. versionchanged:: 1.8\n559            Add *override* keyword.\n560         \"\"\"\n561         self.registry.add_translator(name, translator_class, override=override)\n562 \n563     def add_node(self, node: Type[Element], override: bool = False,\n564                  **kwargs: Tuple[Callable, Callable]) -> None:\n565         \"\"\"Register a Docutils node class.\n566 \n567         This is necessary for Docutils internals.  It may also be used in the\n568         future to validate nodes in the parsed documents.\n569 \n570         :param node: A node class\n571         :param kwargs: Visitor functions for each builder (see below)\n572         :param override: If true, install the node forcedly even if another node is already\n573                          installed as the same name\n574 \n575         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage\n576         writers can be given as keyword arguments: the keyword should be one or\n577         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``\n578         or any other supported translators, the value a 2-tuple of ``(visit,\n579         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``\n580         function raises :exc:`docutils.nodes.SkipNode`.  Example:\n581 \n582         .. code-block:: python\n583 \n584            class math(docutils.nodes.Element): pass\n585 \n586            def visit_math_html(self, node):\n587                self.body.append(self.starttag(node, 'math'))\n588            def depart_math_html(self, node):\n589                self.body.append('</math>')\n590 \n591            app.add_node(math, html=(visit_math_html, depart_math_html))\n592 \n593         Obviously, translators for which you don't specify visitor methods will\n594         choke on the node when encountered in a document to translate.\n595 \n596         .. versionchanged:: 0.5\n597            Added the support for keyword arguments giving visit functions.\n598         \"\"\"\n599         logger.debug('[app] adding node: %r', (node, kwargs))\n600         if not override and docutils.is_node_registered(node):\n601             logger.warning(__('node class %r is already registered, '\n602                               'its visitors will be overridden'),\n603                            node.__name__, type='app', subtype='add_node')\n604         docutils.register_node(node)\n605         self.registry.add_translation_handlers(node, **kwargs)\n606 \n607     def add_enumerable_node(self, node: Type[Element], figtype: str,\n608                             title_getter: TitleGetter = None, override: bool = False,\n609                             **kwargs: Tuple[Callable, Callable]) -> None:\n610         \"\"\"Register a Docutils node class as a numfig target.\n611 \n612         Sphinx numbers the node automatically. And then the users can refer it\n613         using :rst:role:`numref`.\n614 \n615         :param node: A node class\n616         :param figtype: The type of enumerable nodes.  Each figtypes have individual numbering\n617                         sequences.  As a system figtypes, ``figure``, ``table`` and\n618                         ``code-block`` are defined.  It is able to add custom nodes to these\n619                         default figtypes.  It is also able to define new custom figtype if new\n620                         figtype is given.\n621         :param title_getter: A getter function to obtain the title of node.  It takes an\n622                              instance of the enumerable node, and it must return its title as\n623                              string.  The title is used to the default title of references for\n624                              :rst:role:`ref`.  By default, Sphinx searches\n625                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the\n626                              node as a title.\n627         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)\n628         :param override: If true, install the node forcedly even if another node is already\n629                          installed as the same name\n630 \n631         .. versionadded:: 1.4\n632         \"\"\"\n633         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)\n634         self.add_node(node, override=override, **kwargs)\n635 \n636     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:\n637         \"\"\"Register a Docutils directive.\n638 \n639         :param name: The name of directive\n640         :param cls: A directive class\n641         :param override: If true, install the directive forcedly even if another directive\n642                          is already installed as the same name\n643 \n644         For example, a custom directive named ``my-directive`` would be added\n645         like this:\n646 \n647         .. code-block:: python\n648 \n649            from docutils.parsers.rst import Directive, directives\n650 \n651            class MyDirective(Directive):\n652                has_content = True\n653                required_arguments = 1\n654                optional_arguments = 0\n655                final_argument_whitespace = True\n656                option_spec = {\n657                    'class': directives.class_option,\n658                    'name': directives.unchanged,\n659                }\n660 \n661                def run(self):\n662                    ...\n663 \n664            def setup(app):\n665                add_directive('my-directive', MyDirective)\n666 \n667         For more details, see `the Docutils docs\n668         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`__ .\n669 \n670         .. versionchanged:: 0.6\n671            Docutils 0.5-style directive classes are now supported.\n672         .. deprecated:: 1.8\n673            Docutils 0.4-style (function based) directives support is deprecated.\n674         .. versionchanged:: 1.8\n675            Add *override* keyword.\n676         \"\"\"\n677         logger.debug('[app] adding directive: %r', (name, cls))\n678         if not override and docutils.is_directive_registered(name):\n679             logger.warning(__('directive %r is already registered, it will be overridden'),\n680                            name, type='app', subtype='add_directive')\n681 \n682         docutils.register_directive(name, cls)\n683 \n684     def add_role(self, name: str, role: Any, override: bool = False) -> None:\n685         \"\"\"Register a Docutils role.\n686 \n687         :param name: The name of role\n688         :param role: A role function\n689         :param override: If true, install the role forcedly even if another role is already\n690                          installed as the same name\n691 \n692         For more details about role functions, see `the Docutils docs\n693         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`__ .\n694 \n695         .. versionchanged:: 1.8\n696            Add *override* keyword.\n697         \"\"\"\n698         logger.debug('[app] adding role: %r', (name, role))\n699         if not override and docutils.is_role_registered(name):\n700             logger.warning(__('role %r is already registered, it will be overridden'),\n701                            name, type='app', subtype='add_role')\n702         docutils.register_role(name, role)\n703 \n704     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:\n705         \"\"\"Register a generic Docutils role.\n706 \n707         Register a Docutils role that does nothing but wrap its contents in the\n708         node given by *nodeclass*.\n709 \n710         If *override* is True, the given *nodeclass* is forcedly installed even if\n711         a role named as *name* is already installed.\n712 \n713         .. versionadded:: 0.6\n714         .. versionchanged:: 1.8\n715            Add *override* keyword.\n716         \"\"\"\n717         # Don't use ``roles.register_generic_role`` because it uses\n718         # ``register_canonical_role``.\n719         logger.debug('[app] adding generic role: %r', (name, nodeclass))\n720         if not override and docutils.is_role_registered(name):\n721             logger.warning(__('role %r is already registered, it will be overridden'),\n722                            name, type='app', subtype='add_generic_role')\n723         role = roles.GenericRole(name, nodeclass)\n724         docutils.register_role(name, role)\n725 \n726     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:\n727         \"\"\"Register a domain.\n728 \n729         :param domain: A domain class\n730         :param override: If true, install the domain forcedly even if another domain\n731                          is already installed as the same name\n732 \n733         .. versionadded:: 1.0\n734         .. versionchanged:: 1.8\n735            Add *override* keyword.\n736         \"\"\"\n737         self.registry.add_domain(domain, override=override)\n738 \n739     def add_directive_to_domain(self, domain: str, name: str,\n740                                 cls: Type[Directive], override: bool = False) -> None:\n741         \"\"\"Register a Docutils directive in a domain.\n742 \n743         Like :meth:`add_directive`, but the directive is added to the domain\n744         named *domain*.\n745 \n746         :param domain: The name of target domain\n747         :param name: A name of directive\n748         :param cls: A directive class\n749         :param override: If true, install the directive forcedly even if another directive\n750                          is already installed as the same name\n751 \n752         .. versionadded:: 1.0\n753         .. versionchanged:: 1.8\n754            Add *override* keyword.\n755         \"\"\"\n756         self.registry.add_directive_to_domain(domain, name, cls, override=override)\n757 \n758     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],\n759                            override: bool = False) -> None:\n760         \"\"\"Register a Docutils role in a domain.\n761 \n762         Like :meth:`add_role`, but the role is added to the domain named\n763         *domain*.\n764 \n765         :param domain: The name of target domain\n766         :param name: A name of role\n767         :param role: A role function\n768         :param override: If true, install the role forcedly even if another role is already\n769                          installed as the same name\n770 \n771         .. versionadded:: 1.0\n772         .. versionchanged:: 1.8\n773            Add *override* keyword.\n774         \"\"\"\n775         self.registry.add_role_to_domain(domain, name, role, override=override)\n776 \n777     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False\n778                             ) -> None:\n779         \"\"\"Register a custom index for a domain.\n780 \n781         Add a custom *index* class to the domain named *domain*.\n782 \n783         :param domain: The name of target domain\n784         :param index: A index class\n785         :param override: If true, install the index forcedly even if another index is\n786                          already installed as the same name\n787 \n788         .. versionadded:: 1.0\n789         .. versionchanged:: 1.8\n790            Add *override* keyword.\n791         \"\"\"\n792         self.registry.add_index_to_domain(domain, index)\n793 \n794     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',\n795                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,\n796                         objname: str = '', doc_field_types: List = [], override: bool = False\n797                         ) -> None:\n798         \"\"\"Register a new object type.\n799 \n800         This method is a very convenient way to add a new :term:`object` type\n801         that can be cross-referenced.  It will do this:\n802 \n803         - Create a new directive (called *directivename*) for documenting an\n804           object.  It will automatically add index entries if *indextemplate*\n805           is nonempty; if given, it must contain exactly one instance of\n806           ``%s``.  See the example below for how the template will be\n807           interpreted.\n808         - Create a new role (called *rolename*) to cross-reference to these\n809           object descriptions.\n810         - If you provide *parse_node*, it must be a function that takes a\n811           string and a docutils node, and it must populate the node with\n812           children parsed from the string.  It must then return the name of the\n813           item to be used in cross-referencing and index entries.  See the\n814           :file:`conf.py` file in the source for this documentation for an\n815           example.\n816         - The *objname* (if not given, will default to *directivename*) names\n817           the type of object.  It is used when listing objects, e.g. in search\n818           results.\n819 \n820         For example, if you have this call in a custom Sphinx extension::\n821 \n822            app.add_object_type('directive', 'dir', 'pair: %s; directive')\n823 \n824         you can use this markup in your documents::\n825 \n826            .. rst:directive:: function\n827 \n828               Document a function.\n829 \n830            <...>\n831 \n832            See also the :rst:dir:`function` directive.\n833 \n834         For the directive, an index entry will be generated as if you had prepended ::\n835 \n836            .. index:: pair: function; directive\n837 \n838         The reference node will be of class ``literal`` (so it will be rendered\n839         in a proportional font, as appropriate for code) unless you give the\n840         *ref_nodeclass* argument, which must be a docutils node class.  Most\n841         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --\n842         you can also use ``docutils.nodes.generated`` if you want no further\n843         text decoration.  If the text should be treated as literal (e.g. no\n844         smart quote replacement), but not have typewriter styling, use\n845         ``sphinx.addnodes.literal_emphasis`` or\n846         ``sphinx.addnodes.literal_strong``.\n847 \n848         For the role content, you have the same syntactical possibilities as\n849         for standard Sphinx roles (see :ref:`xref-syntax`).\n850 \n851         If *override* is True, the given object_type is forcedly installed even if\n852         an object_type having the same name is already installed.\n853 \n854         .. versionchanged:: 1.8\n855            Add *override* keyword.\n856         \"\"\"\n857         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,\n858                                       ref_nodeclass, objname, doc_field_types,\n859                                       override=override)\n860 \n861     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',\n862                           ref_nodeclass: Type[TextElement] = None, objname: str = '',\n863                           override: bool = False) -> None:\n864         \"\"\"Register a new crossref object type.\n865 \n866         This method is very similar to :meth:`add_object_type` except that the\n867         directive it generates must be empty, and will produce no output.\n868 \n869         That means that you can add semantic targets to your sources, and refer\n870         to them using custom roles instead of generic ones (like\n871         :rst:role:`ref`).  Example call::\n872 \n873            app.add_crossref_type('topic', 'topic', 'single: %s',\n874                                  docutils.nodes.emphasis)\n875 \n876         Example usage::\n877 \n878            .. topic:: application API\n879 \n880            The application API\n881            -------------------\n882 \n883            Some random text here.\n884 \n885            See also :topic:`this section <application API>`.\n886 \n887         (Of course, the element following the ``topic`` directive needn't be a\n888         section.)\n889 \n890         If *override* is True, the given crossref_type is forcedly installed even if\n891         a crossref_type having the same name is already installed.\n892 \n893         .. versionchanged:: 1.8\n894            Add *override* keyword.\n895         \"\"\"\n896         self.registry.add_crossref_type(directivename, rolename,\n897                                         indextemplate, ref_nodeclass, objname,\n898                                         override=override)\n899 \n900     def add_transform(self, transform: Type[Transform]) -> None:\n901         \"\"\"Register a Docutils transform to be applied after parsing.\n902 \n903         Add the standard docutils :class:`Transform` subclass *transform* to\n904         the list of transforms that are applied after Sphinx parses a reST\n905         document.\n906 \n907         :param transform: A transform class\n908 \n909         .. list-table:: priority range categories for Sphinx transforms\n910            :widths: 20,80\n911 \n912            * - Priority\n913              - Main purpose in Sphinx\n914            * - 0-99\n915              - Fix invalid nodes by docutils. Translate a doctree.\n916            * - 100-299\n917              - Preparation\n918            * - 300-399\n919              - early\n920            * - 400-699\n921              - main\n922            * - 700-799\n923              - Post processing. Deadline to modify text and referencing.\n924            * - 800-899\n925              - Collect referencing and referenced nodes. Domain processing.\n926            * - 900-999\n927              - Finalize and clean up.\n928 \n929         refs: `Transform Priority Range Categories`__\n930 \n931         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories\n932         \"\"\"  # NOQA\n933         self.registry.add_transform(transform)\n934 \n935     def add_post_transform(self, transform: Type[Transform]) -> None:\n936         \"\"\"Register a Docutils transform to be applied before writing.\n937 \n938         Add the standard docutils :class:`Transform` subclass *transform* to\n939         the list of transforms that are applied before Sphinx writes a\n940         document.\n941 \n942         :param transform: A transform class\n943         \"\"\"\n944         self.registry.add_post_transform(transform)\n945 \n946     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:\n947         \"\"\"Register a JavaScript file to include in the HTML output.\n948 \n949         Add *filename* to the list of JavaScript files that the default HTML\n950         template will include in order of *priority* (ascending).  The filename\n951         must be relative to the HTML static path , or a full URI with scheme.\n952         If the priority of JavaScript file is the same as others, the JavaScript\n953         files will be included in order of the registration.  If the keyword\n954         argument ``body`` is given, its value will be added between the\n955         ``<script>`` tags. Extra keyword arguments are included as attributes of\n956         the ``<script>`` tag.\n957 \n958         Example::\n959 \n960             app.add_js_file('example.js')\n961             # => <script src=\"_static/example.js\"></script>\n962 \n963             app.add_js_file('example.js', async=\"async\")\n964             # => <script src=\"_static/example.js\" async=\"async\"></script>\n965 \n966             app.add_js_file(None, body=\"var myVariable = 'foo';\")\n967             # => <script>var myVariable = 'foo';</script>\n968 \n969         .. list-table:: priority range for JavaScript files\n970            :widths: 20,80\n971 \n972            * - Priority\n973              - Main purpose in Sphinx\n974            * - 200\n975              - default priority for built-in JavaScript files\n976            * - 500\n977              - default priority for extensions\n978            * - 800\n979              - default priority for :confval:`html_js_files`\n980 \n981         A JavaScript file can be added to the specific HTML page when on extension\n982         calls this method on :event:`html-page-context` event.\n983 \n984         .. versionadded:: 0.5\n985 \n986         .. versionchanged:: 1.8\n987            Renamed from ``app.add_javascript()``.\n988            And it allows keyword arguments as attributes of script tag.\n989 \n990         .. versionchanged:: 3.5\n991            Take priority argument.  Allow to add a JavaScript file to the specific page.\n992         \"\"\"\n993         self.registry.add_js_file(filename, priority=priority, **kwargs)\n994         if hasattr(self.builder, 'add_js_file'):\n995             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore\n996 \n997     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:\n998         \"\"\"Register a stylesheet to include in the HTML output.\n999 \n1000         Add *filename* to the list of CSS files that the default HTML template\n1001         will include in order of *priority* (ascending).  The filename must be\n1002         relative to the HTML static path, or a full URI with scheme.  If the\n1003         priority of CSS file is the same as others, the CSS files will be\n1004         included in order of the registration.  The keyword arguments are also\n1005         accepted for attributes of ``<link>`` tag.\n1006 \n1007         Example::\n1008 \n1009             app.add_css_file('custom.css')\n1010             # => <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n1011 \n1012             app.add_css_file('print.css', media='print')\n1013             # => <link rel=\"stylesheet\" href=\"_static/print.css\"\n1014             #          type=\"text/css\" media=\"print\" />\n1015 \n1016             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')\n1017             # => <link rel=\"alternate stylesheet\" href=\"_static/fancy.css\"\n1018             #          type=\"text/css\" title=\"fancy\" />\n1019 \n1020         .. list-table:: priority range for CSS files\n1021            :widths: 20,80\n1022 \n1023            * - Priority\n1024              - Main purpose in Sphinx\n1025            * - 200\n1026              - default priority for built-in CSS files\n1027            * - 500\n1028              - default priority for extensions\n1029            * - 800\n1030              - default priority for :confval:`html_css_files`\n1031 \n1032         A CSS file can be added to the specific HTML page when on extension calls\n1033         this method on :event:`html-page-context` event.\n1034 \n1035         .. versionadded:: 1.0\n1036 \n1037         .. versionchanged:: 1.6\n1038            Optional ``alternate`` and/or ``title`` attributes can be supplied\n1039            with the *alternate* (of boolean type) and *title* (a string)\n1040            arguments. The default is no title and *alternate* = ``False``. For\n1041            more information, refer to the `documentation\n1042            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.\n1043 \n1044         .. versionchanged:: 1.8\n1045            Renamed from ``app.add_stylesheet()``.\n1046            And it allows keyword arguments as attributes of link tag.\n1047 \n1048         .. versionchanged:: 3.5\n1049            Take priority argument.  Allow to add a CSS file to the specific page.\n1050         \"\"\"\n1051         logger.debug('[app] adding stylesheet: %r', filename)\n1052         self.registry.add_css_files(filename, priority=priority, **kwargs)\n1053         if hasattr(self.builder, 'add_css_file'):\n1054             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore\n1055 \n1056     def add_latex_package(self, packagename: str, options: str = None,\n1057                           after_hyperref: bool = False) -> None:\n1058         r\"\"\"Register a package to include in the LaTeX source code.\n1059 \n1060         Add *packagename* to the list of packages that LaTeX source code will\n1061         include.  If you provide *options*, it will be taken to `\\usepackage`\n1062         declaration.  If you set *after_hyperref* truthy, the package will be\n1063         loaded after ``hyperref`` package.\n1064 \n1065         .. code-block:: python\n1066 \n1067            app.add_latex_package('mypackage')\n1068            # => \\usepackage{mypackage}\n1069            app.add_latex_package('mypackage', 'foo,bar')\n1070            # => \\usepackage[foo,bar]{mypackage}\n1071 \n1072         .. versionadded:: 1.3\n1073         .. versionadded:: 3.1\n1074 \n1075            *after_hyperref* option.\n1076         \"\"\"\n1077         self.registry.add_latex_package(packagename, options, after_hyperref)\n1078 \n1079     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:\n1080         \"\"\"Register a new lexer for source code.\n1081 \n1082         Use *lexer* to highlight code blocks with the given language *alias*.\n1083 \n1084         .. versionadded:: 0.6\n1085         .. versionchanged:: 2.1\n1086            Take a lexer class as an argument.  An instance of lexers are\n1087            still supported until Sphinx-3.x.\n1088         \"\"\"\n1089         logger.debug('[app] adding lexer: %r', (alias, lexer))\n1090         lexer_classes[alias] = lexer\n1091 \n1092     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:\n1093         \"\"\"Register a new documenter class for the autodoc extension.\n1094 \n1095         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`\n1096         extension.  It must be a subclass of\n1097         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document\n1098         new types of objects.  See the source of the autodoc module for\n1099         examples on how to subclass :class:`Documenter`.\n1100 \n1101         If *override* is True, the given *cls* is forcedly installed even if\n1102         a documenter having the same name is already installed.\n1103 \n1104         See :ref:`autodoc_ext_tutorial`.\n1105 \n1106         .. versionadded:: 0.6\n1107         .. versionchanged:: 2.2\n1108            Add *override* keyword.\n1109         \"\"\"\n1110         logger.debug('[app] adding autodocumenter: %r', cls)\n1111         from sphinx.ext.autodoc.directive import AutodocDirective\n1112         self.registry.add_documenter(cls.objtype, cls)\n1113         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)\n1114 \n1115     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]\n1116                                ) -> None:\n1117         \"\"\"Register a new ``getattr``-like function for the autodoc extension.\n1118 \n1119         Add *getter*, which must be a function with an interface compatible to\n1120         the :func:`getattr` builtin, as the autodoc attribute getter for\n1121         objects that are instances of *typ*.  All cases where autodoc needs to\n1122         get an attribute of a type are then handled by this function instead of\n1123         :func:`getattr`.\n1124 \n1125         .. versionadded:: 0.6\n1126         \"\"\"\n1127         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))\n1128         self.registry.add_autodoc_attrgetter(typ, getter)\n1129 \n1130     def add_search_language(self, cls: Any) -> None:\n1131         \"\"\"Register a new language for the HTML search index.\n1132 \n1133         Add *cls*, which must be a subclass of\n1134         :class:`sphinx.search.SearchLanguage`, as a support language for\n1135         building the HTML full-text search index.  The class must have a *lang*\n1136         attribute that indicates the language it should be used for.  See\n1137         :confval:`html_search_language`.\n1138 \n1139         .. versionadded:: 1.1\n1140         \"\"\"\n1141         logger.debug('[app] adding search language: %r', cls)\n1142         from sphinx.search import SearchLanguage, languages\n1143         assert issubclass(cls, SearchLanguage)\n1144         languages[cls.lang] = cls\n1145 \n1146     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:\n1147         \"\"\"Register a suffix of source files.\n1148 \n1149         Same as :confval:`source_suffix`.  The users can override this\n1150         using the setting.\n1151 \n1152         If *override* is True, the given *suffix* is forcedly installed even if\n1153         a same suffix is already installed.\n1154 \n1155         .. versionadded:: 1.8\n1156         \"\"\"\n1157         self.registry.add_source_suffix(suffix, filetype, override=override)\n1158 \n1159     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:\n1160         \"\"\"Register a parser class.\n1161 \n1162         If *override* is True, the given *parser* is forcedly installed even if\n1163         a parser for the same suffix is already installed.\n1164 \n1165         .. versionadded:: 1.4\n1166         .. versionchanged:: 1.8\n1167            *suffix* argument is deprecated.  It only accepts *parser* argument.\n1168            Use :meth:`add_source_suffix` API to register suffix instead.\n1169         .. versionchanged:: 1.8\n1170            Add *override* keyword.\n1171         \"\"\"\n1172         self.registry.add_source_parser(parser, override=override)\n1173 \n1174     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:\n1175         \"\"\"Register an environment collector class.\n1176 \n1177         Refer to :ref:`collector-api`.\n1178 \n1179         .. versionadded:: 1.6\n1180         \"\"\"\n1181         logger.debug('[app] adding environment collector: %r', collector)\n1182         collector().enable(self)\n1183 \n1184     def add_html_theme(self, name: str, theme_path: str) -> None:\n1185         \"\"\"Register a HTML Theme.\n1186 \n1187         The *name* is a name of theme, and *path* is a full path to the theme\n1188         (refs: :ref:`distribute-your-theme`).\n1189 \n1190         .. versionadded:: 1.6\n1191         \"\"\"\n1192         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)\n1193         self.html_themes[name] = theme_path\n1194 \n1195     def add_html_math_renderer(self, name: str,\n1196                                inline_renderers: Tuple[Callable, Callable] = None,\n1197                                block_renderers: Tuple[Callable, Callable] = None) -> None:\n1198         \"\"\"Register a math renderer for HTML.\n1199 \n1200         The *name* is a name of math renderer.  Both *inline_renderers* and\n1201         *block_renderers* are used as visitor functions for the HTML writer:\n1202         the former for inline math node (``nodes.math``), the latter for\n1203         block math node (``nodes.math_block``).  Regarding visitor functions,\n1204         see :meth:`add_node` for details.\n1205 \n1206         .. versionadded:: 1.8\n1207 \n1208         \"\"\"\n1209         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)\n1210 \n1211     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:\n1212         \"\"\"Register a message catalog.\n1213 \n1214         :param catalog: A name of catalog\n1215         :param locale_dir: The base path of message catalog\n1216 \n1217         For more details, see :func:`sphinx.locale.get_translation()`.\n1218 \n1219         .. versionadded:: 1.8\n1220         \"\"\"\n1221         locale.init([locale_dir], self.config.language, catalog)\n1222         locale.init_console(locale_dir, catalog)\n1223 \n1224     # ---- other methods -------------------------------------------------\n1225     def is_parallel_allowed(self, typ: str) -> bool:\n1226         \"\"\"Check parallel processing is allowed or not.\n1227 \n1228         :param typ: A type of processing; ``'read'`` or ``'write'``.\n1229         \"\"\"\n1230         if typ == 'read':\n1231             attrname = 'parallel_read_safe'\n1232             message_not_declared = __(\"the %s extension does not declare if it \"\n1233                                       \"is safe for parallel reading, assuming \"\n1234                                       \"it isn't - please ask the extension author \"\n1235                                       \"to check and make it explicit\")\n1236             message_not_safe = __(\"the %s extension is not safe for parallel reading\")\n1237         elif typ == 'write':\n1238             attrname = 'parallel_write_safe'\n1239             message_not_declared = __(\"the %s extension does not declare if it \"\n1240                                       \"is safe for parallel writing, assuming \"\n1241                                       \"it isn't - please ask the extension author \"\n1242                                       \"to check and make it explicit\")\n1243             message_not_safe = __(\"the %s extension is not safe for parallel writing\")\n1244         else:\n1245             raise ValueError('parallel type %s is not supported' % typ)\n1246 \n1247         for ext in self.extensions.values():\n1248             allowed = getattr(ext, attrname, None)\n1249             if allowed is None:\n1250                 logger.warning(message_not_declared, ext.name)\n1251                 logger.warning(__('doing serial %s'), typ)\n1252                 return False\n1253             elif not allowed:\n1254                 logger.warning(message_not_safe, ext.name)\n1255                 logger.warning(__('doing serial %s'), typ)\n1256                 return False\n1257 \n1258         return True\n1259 \n1260 \n1261 class TemplateBridge:\n1262     \"\"\"\n1263     This class defines the interface for a \"template bridge\", that is, a class\n1264     that renders templates given a template name and a context.\n1265     \"\"\"\n1266 \n1267     def init(self, builder: \"Builder\", theme: Theme = None, dirs: List[str] = None) -> None:\n1268         \"\"\"Called by the builder to initialize the template system.\n1269 \n1270         *builder* is the builder object; you'll probably want to look at the\n1271         value of ``builder.config.templates_path``.\n1272 \n1273         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter\n1274         case, *dirs* can be list of fixed directories to look for templates.\n1275         \"\"\"\n1276         raise NotImplementedError('must be implemented in subclasses')\n1277 \n1278     def newest_template_mtime(self) -> float:\n1279         \"\"\"Called by the builder to determine if output files are outdated\n1280         because of template changes.  Return the mtime of the newest template\n1281         file that was changed.  The default implementation returns ``0``.\n1282         \"\"\"\n1283         return 0\n1284 \n1285     def render(self, template: str, context: Dict) -> None:\n1286         \"\"\"Called by the builder to render a template given as a filename with\n1287         a specified context (a Python dictionary).\n1288         \"\"\"\n1289         raise NotImplementedError('must be implemented in subclasses')\n1290 \n1291     def render_string(self, template: str, context: Dict) -> str:\n1292         \"\"\"Called by the builder to render a template given as a string with a\n1293         specified context (a Python dictionary).\n1294         \"\"\"\n1295         raise NotImplementedError('must be implemented in subclasses')\n",
        "intended_behavior": "Changes here may be necessary to ensure that the application's initialization and setup processes correctly account for the new version of docutils. This could involve adjusting the way docutils components are loaded or initialized to accommodate any changes in docutils 0.17b1."
    },
    {
        "rel_file_path": "doc/conf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/doc/conf.py",
        "start": 1,
        "end": 161,
        "class_name": null,
        "method_name": null,
        "code": "1 # Sphinx documentation build configuration file\n2 \n3 import re\n4 \n5 import sphinx\n6 \n7 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',\n8               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',\n9               'sphinx.ext.intersphinx',\n10               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']\n11 \n12 root_doc = 'contents'\n13 templates_path = ['_templates']\n14 exclude_patterns = ['_build']\n15 \n16 project = 'Sphinx'\n17 copyright = '2007-2021, Georg Brandl and the Sphinx team'\n18 version = sphinx.__display_version__\n19 release = version\n20 show_authors = True\n21 \n22 html_theme = 'sphinx13'\n23 html_theme_path = ['_themes']\n24 modindex_common_prefix = ['sphinx.']\n25 html_static_path = ['_static']\n26 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}\n27 html_title = 'Sphinx documentation'\n28 html_additional_pages = {'index': 'index.html'}\n29 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'\n30 html_baseurl = 'https://www.sphinx-doc.org/en/master/'\n31 html_favicon = '_static/favicon.svg'\n32 \n33 htmlhelp_basename = 'Sphinxdoc'\n34 \n35 epub_theme = 'epub'\n36 epub_basename = 'sphinx'\n37 epub_author = 'Georg Brandl'\n38 epub_publisher = 'http://sphinx-doc.org/'\n39 epub_uid = 'web-site'\n40 epub_scheme = 'url'\n41 epub_identifier = epub_publisher\n42 epub_pre_files = [('index.xhtml', 'Welcome')]\n43 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),\n44                    ('develop.xhtml', 'Sphinx development')]\n45 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',\n46                       '_static/jquery.js', '_static/searchtools.js',\n47                       '_static/underscore.js', '_static/basic.css',\n48                       '_static/language_data.js',\n49                       'search.html', '_static/websupport.js']\n50 epub_fix_images = False\n51 epub_max_image_width = 0\n52 epub_show_urls = 'inline'\n53 epub_use_index = False\n54 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)\n55 epub_description = 'Sphinx documentation generator system manual'\n56 \n57 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',\n58                     'Georg Brandl', 'manual', 1)]\n59 latex_logo = '_static/sphinx.png'\n60 latex_elements = {\n61     'fontenc': r'\\usepackage[LGR,X2,T1]{fontenc}',\n62     'passoptionstopackages': r'''\n63 \\PassOptionsToPackage{svgnames}{xcolor}\n64 ''',\n65     'preamble': r'''\n66 \\DeclareUnicodeCharacter{229E}{\\ensuremath{\\boxplus}}\n67 \\setcounter{tocdepth}{3}%    depth of what main TOC shows (3=subsubsection)\n68 \\setcounter{secnumdepth}{1}% depth of section numbering\n69 ''',\n70     # fix missing index entry due to RTD doing only once pdflatex after makeindex\n71     'printindex': r'''\n72 \\IfFileExists{\\jobname.ind}\n73              {\\footnotesize\\raggedright\\printindex}\n74              {\\begin{sphinxtheindex}\\end{sphinxtheindex}}\n75 ''',\n76 }\n77 latex_show_urls = 'footnote'\n78 latex_use_xindy = True\n79 \n80 autodoc_member_order = 'groupwise'\n81 autosummary_generate = False\n82 todo_include_todos = True\n83 extlinks = {'duref': ('http://docutils.sourceforge.net/docs/ref/rst/'\n84                       'restructuredtext.html#%s', ''),\n85             'durole': ('http://docutils.sourceforge.net/docs/ref/rst/'\n86                        'roles.html#%s', ''),\n87             'dudir': ('http://docutils.sourceforge.net/docs/ref/rst/'\n88                       'directives.html#%s', '')}\n89 \n90 man_pages = [\n91     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',\n92      'Georg Brandl', 1),\n93     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',\n94      '', 1),\n95     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '\n96      'template generator', '', 1),\n97     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',\n98      '', 1),\n99     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',\n100      '', 1),\n101 ]\n102 \n103 texinfo_documents = [\n104     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',\n105      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',\n106      1),\n107 ]\n108 \n109 intersphinx_mapping = {\n110     'python': ('https://docs.python.org/3/', None),\n111     'requests': ('https://requests.readthedocs.io/en/master', None),\n112 }\n113 \n114 # Sphinx document translation with sphinx gettext feature uses these settings:\n115 locale_dirs = ['locale/']\n116 gettext_compact = False\n117 \n118 \n119 # -- Extension interface -------------------------------------------------------\n120 \n121 from sphinx import addnodes  # noqa\n122 \n123 event_sig_re = re.compile(r'([a-zA-Z-]+)\\s*\\((.*)\\)')\n124 \n125 \n126 def parse_event(env, sig, signode):\n127     m = event_sig_re.match(sig)\n128     if not m:\n129         signode += addnodes.desc_name(sig, sig)\n130         return sig\n131     name, args = m.groups()\n132     signode += addnodes.desc_name(name, name)\n133     plist = addnodes.desc_parameterlist()\n134     for arg in args.split(','):\n135         arg = arg.strip()\n136         plist += addnodes.desc_parameter(arg, arg)\n137     signode += plist\n138     return name\n139 \n140 \n141 def setup(app):\n142     from sphinx.ext.autodoc import cut_lines\n143     from sphinx.util.docfields import GroupedField\n144     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n145     app.add_object_type('confval', 'confval',\n146                         objname='configuration value',\n147                         indextemplate='pair: %s; configuration value')\n148     app.add_object_type('setuptools-confval', 'setuptools-confval',\n149                         objname='setuptools configuration value',\n150                         indextemplate='pair: %s; setuptools configuration value')\n151     fdesc = GroupedField('parameter', label='Parameters',\n152                          names=['param'], can_collapse=True)\n153     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,\n154                         doc_field_types=[fdesc])\n155 \n156     # workaround for RTD\n157     from sphinx.util import logging\n158     logger = logging.getLogger(__name__)\n159     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)\n160     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)\n161     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)\n",
        "intended_behavior": "Given its role in configuration, especially in projects that use Sphinx for documentation, this file might need modifications to ensure that settings related to docutils are correctly configured for version 0.17b1. This could include adjusting default settings or options that are passed to docutils components."
    },
    {
        "rel_file_path": "sphinx/setup_command.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.0/sphinx/setup_command.py",
        "start": 1,
        "end": 189,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.setup_command\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Setuptools/distutils commands to assist the building of sphinx\n6     documentation.\n7 \n8     :author: Sebastian Wiesner\n9     :contact: basti.wiesner@gmx.net\n10     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n11     :license: BSD, see LICENSE for details.\n12 \"\"\"\n13 \n14 import os\n15 import sys\n16 from distutils.cmd import Command\n17 from distutils.errors import DistutilsExecError\n18 from io import StringIO\n19 from typing import Any, Dict\n20 \n21 from sphinx.application import Sphinx\n22 from sphinx.cmd.build import handle_exception\n23 from sphinx.util.console import color_terminal, nocolor\n24 from sphinx.util.docutils import docutils_namespace, patch_docutils\n25 from sphinx.util.osutil import abspath\n26 \n27 \n28 class BuildDoc(Command):\n29     \"\"\"\n30     Distutils command to build Sphinx documentation.\n31 \n32     The Sphinx build can then be triggered from distutils, and some Sphinx\n33     options can be set in ``setup.py`` or ``setup.cfg`` instead of Sphinx own\n34     configuration file.\n35 \n36     For instance, from `setup.py`::\n37 \n38        # this is only necessary when not using setuptools/distribute\n39        from sphinx.setup_command import BuildDoc\n40        cmdclass = {'build_sphinx': BuildDoc}\n41 \n42        name = 'My project'\n43        version = '1.2'\n44        release = '1.2.0'\n45        setup(\n46            name=name,\n47            author='Bernard Montgomery',\n48            version=release,\n49            cmdclass=cmdclass,\n50            # these are optional and override conf.py settings\n51            command_options={\n52                'build_sphinx': {\n53                    'project': ('setup.py', name),\n54                    'version': ('setup.py', version),\n55                    'release': ('setup.py', release)}},\n56        )\n57 \n58     Or add this section in ``setup.cfg``::\n59 \n60        [build_sphinx]\n61        project = 'My project'\n62        version = 1.2\n63        release = 1.2.0\n64     \"\"\"\n65 \n66     description = 'Build Sphinx documentation'\n67     user_options = [\n68         ('fresh-env', 'E', 'discard saved environment'),\n69         ('all-files', 'a', 'build all files'),\n70         ('source-dir=', 's', 'Source directory'),\n71         ('build-dir=', None, 'Build directory'),\n72         ('config-dir=', 'c', 'Location of the configuration directory'),\n73         ('builder=', 'b', 'The builder (or builders) to use. Can be a comma- '\n74          'or space-separated list. Defaults to \"html\"'),\n75         ('warning-is-error', 'W', 'Turn warning into errors'),\n76         ('project=', None, 'The documented project\\'s name'),\n77         ('version=', None, 'The short X.Y version'),\n78         ('release=', None, 'The full version, including alpha/beta/rc tags'),\n79         ('today=', None, 'How to format the current date, used as the '\n80          'replacement for |today|'),\n81         ('link-index', 'i', 'Link index.html to the master doc'),\n82         ('copyright', None, 'The copyright string'),\n83         ('pdb', None, 'Start pdb on exception'),\n84         ('verbosity', 'v', 'increase verbosity (can be repeated)'),\n85         ('nitpicky', 'n', 'nit-picky mode, warn about all missing references'),\n86         ('keep-going', None, 'With -W, keep going when getting warnings'),\n87     ]\n88     boolean_options = ['fresh-env', 'all-files', 'warning-is-error',\n89                        'link-index', 'nitpicky']\n90 \n91     def initialize_options(self) -> None:\n92         self.fresh_env = self.all_files = False\n93         self.pdb = False\n94         self.source_dir: str = None\n95         self.build_dir: str = None\n96         self.builder = 'html'\n97         self.warning_is_error = False\n98         self.project = ''\n99         self.version = ''\n100         self.release = ''\n101         self.today = ''\n102         self.config_dir: str = None\n103         self.link_index = False\n104         self.copyright = ''\n105         # Link verbosity to distutils' (which uses 1 by default).\n106         self.verbosity = self.distribution.verbose - 1  # type: ignore\n107         self.traceback = False\n108         self.nitpicky = False\n109         self.keep_going = False\n110 \n111     def _guess_source_dir(self) -> str:\n112         for guess in ('doc', 'docs'):\n113             if not os.path.isdir(guess):\n114                 continue\n115             for root, dirnames, filenames in os.walk(guess):\n116                 if 'conf.py' in filenames:\n117                     return root\n118         return os.curdir\n119 \n120     def finalize_options(self) -> None:\n121         self.ensure_string_list('builder')\n122 \n123         if self.source_dir is None:\n124             self.source_dir = self._guess_source_dir()\n125             self.announce('Using source directory %s' % self.source_dir)\n126 \n127         self.ensure_dirname('source_dir')\n128 \n129         if self.config_dir is None:\n130             self.config_dir = self.source_dir\n131 \n132         if self.build_dir is None:\n133             build = self.get_finalized_command('build')\n134             self.build_dir = os.path.join(abspath(build.build_base), 'sphinx')  # type: ignore\n135 \n136         self.doctree_dir = os.path.join(self.build_dir, 'doctrees')\n137 \n138         self.builder_target_dirs = [\n139             (builder, os.path.join(self.build_dir, builder))\n140             for builder in self.builder]\n141 \n142     def run(self) -> None:\n143         if not color_terminal():\n144             nocolor()\n145         if not self.verbose:  # type: ignore\n146             status_stream = StringIO()\n147         else:\n148             status_stream = sys.stdout  # type: ignore\n149         confoverrides: Dict[str, Any] = {}\n150         if self.project:\n151             confoverrides['project'] = self.project\n152         if self.version:\n153             confoverrides['version'] = self.version\n154         if self.release:\n155             confoverrides['release'] = self.release\n156         if self.today:\n157             confoverrides['today'] = self.today\n158         if self.copyright:\n159             confoverrides['copyright'] = self.copyright\n160         if self.nitpicky:\n161             confoverrides['nitpicky'] = self.nitpicky\n162 \n163         for builder, builder_target_dir in self.builder_target_dirs:\n164             app = None\n165 \n166             try:\n167                 confdir = self.config_dir or self.source_dir\n168                 with patch_docutils(confdir), docutils_namespace():\n169                     app = Sphinx(self.source_dir, self.config_dir,\n170                                  builder_target_dir, self.doctree_dir,\n171                                  builder, confoverrides, status_stream,\n172                                  freshenv=self.fresh_env,\n173                                  warningiserror=self.warning_is_error,\n174                                  verbosity=self.verbosity, keep_going=self.keep_going)\n175                     app.build(force_all=self.all_files)\n176                     if app.statuscode:\n177                         raise DistutilsExecError(\n178                             'caused by %s builder.' % app.builder.name)\n179             except Exception as exc:\n180                 handle_exception(app, self, exc, sys.stderr)\n181                 if not self.pdb:\n182                     raise SystemExit(1) from exc\n183 \n184             if not self.link_index:\n185                 continue\n186 \n187             src = app.config.root_doc + app.builder.out_suffix  # type: ignore\n188             dst = app.builder.get_outfilename('index')  # type: ignore\n189             os.symlink(src, dst)\n",
        "intended_behavior": "If this file manages how docutils is specified as a dependency during setup, it might need to ensure that the project specifies an appropriate dependency range that includes docutils 0.17b1. Additionally, it should include safeguards or checks that alert the user to potential compatibility issues if an unsupported version of docutils is detected."
    }
]