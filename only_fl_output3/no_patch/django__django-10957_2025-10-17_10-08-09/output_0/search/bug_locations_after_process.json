[
    {
        "rel_file_path": "django/utils/translation/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/utils/translation/__init__.py",
        "start": 1,
        "end": 282,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Internationalization support.\n3 \"\"\"\n4 import re\n5 from contextlib import ContextDecorator\n6 \n7 from django.utils.autoreload import autoreload_started, file_changed\n8 from django.utils.functional import lazy\n9 \n10 __all__ = [\n11     'activate', 'deactivate', 'override', 'deactivate_all',\n12     'get_language', 'get_language_from_request',\n13     'get_language_info', 'get_language_bidi',\n14     'check_for_language', 'to_language', 'to_locale', 'templatize',\n15     'gettext', 'gettext_lazy', 'gettext_noop',\n16     'ugettext', 'ugettext_lazy', 'ugettext_noop',\n17     'ngettext', 'ngettext_lazy',\n18     'ungettext', 'ungettext_lazy',\n19     'pgettext', 'pgettext_lazy',\n20     'npgettext', 'npgettext_lazy',\n21     'LANGUAGE_SESSION_KEY',\n22 ]\n23 \n24 LANGUAGE_SESSION_KEY = '_language'\n25 \n26 \n27 class TranslatorCommentWarning(SyntaxWarning):\n28     pass\n29 \n30 \n31 # Here be dragons, so a short explanation of the logic won't hurt:\n32 # We are trying to solve two problems: (1) access settings, in particular\n33 # settings.USE_I18N, as late as possible, so that modules can be imported\n34 # without having to first configure Django, and (2) if some other code creates\n35 # a reference to one of these functions, don't break that reference when we\n36 # replace the functions with their real counterparts (once we do access the\n37 # settings).\n38 \n39 class Trans:\n40     \"\"\"\n41     The purpose of this class is to store the actual translation function upon\n42     receiving the first call to that function. After this is done, changes to\n43     USE_I18N will have no effect to which function is served upon request. If\n44     your tests rely on changing USE_I18N, you can delete all the functions\n45     from _trans.__dict__.\n46 \n47     Note that storing the function with setattr will have a noticeable\n48     performance effect, as access to the function goes the normal path,\n49     instead of using __getattr__.\n50     \"\"\"\n51 \n52     def __getattr__(self, real_name):\n53         from django.conf import settings\n54         if settings.USE_I18N:\n55             from django.utils.translation import trans_real as trans\n56             from django.utils.translation.reloader import watch_for_translation_changes, translation_file_changed\n57             autoreload_started.connect(watch_for_translation_changes, dispatch_uid='translation_file_changed')\n58             file_changed.connect(translation_file_changed, dispatch_uid='translation_file_changed')\n59         else:\n60             from django.utils.translation import trans_null as trans\n61         setattr(self, real_name, getattr(trans, real_name))\n62         return getattr(trans, real_name)\n63 \n64 \n65 _trans = Trans()\n66 \n67 # The Trans class is no more needed, so remove it from the namespace.\n68 del Trans\n69 \n70 \n71 def gettext_noop(message):\n72     return _trans.gettext_noop(message)\n73 \n74 \n75 ugettext_noop = gettext_noop\n76 \n77 \n78 def gettext(message):\n79     return _trans.gettext(message)\n80 \n81 \n82 # An alias since Django 2.0\n83 ugettext = gettext\n84 \n85 \n86 def ngettext(singular, plural, number):\n87     return _trans.ngettext(singular, plural, number)\n88 \n89 \n90 # An alias since Django 2.0\n91 ungettext = ngettext\n92 \n93 \n94 def pgettext(context, message):\n95     return _trans.pgettext(context, message)\n96 \n97 \n98 def npgettext(context, singular, plural, number):\n99     return _trans.npgettext(context, singular, plural, number)\n100 \n101 \n102 gettext_lazy = ugettext_lazy = lazy(gettext, str)\n103 pgettext_lazy = lazy(pgettext, str)\n104 \n105 \n106 def lazy_number(func, resultclass, number=None, **kwargs):\n107     if isinstance(number, int):\n108         kwargs['number'] = number\n109         proxy = lazy(func, resultclass)(**kwargs)\n110     else:\n111         original_kwargs = kwargs.copy()\n112 \n113         class NumberAwareString(resultclass):\n114             def __bool__(self):\n115                 return bool(kwargs['singular'])\n116 \n117             def _get_number_value(self, values):\n118                 try:\n119                     return values[number]\n120                 except KeyError:\n121                     raise KeyError(\n122                         \"Your dictionary lacks key '%s\\'. Please provide \"\n123                         \"it, because it is required to determine whether \"\n124                         \"string is singular or plural.\" % number\n125                     )\n126 \n127             def _translate(self, number_value):\n128                 kwargs['number'] = number_value\n129                 return func(**kwargs)\n130 \n131             def format(self, *args, **kwargs):\n132                 number_value = self._get_number_value(kwargs) if kwargs and number else args[0]\n133                 return self._translate(number_value).format(*args, **kwargs)\n134 \n135             def __mod__(self, rhs):\n136                 if isinstance(rhs, dict) and number:\n137                     number_value = self._get_number_value(rhs)\n138                 else:\n139                     number_value = rhs\n140                 translated = self._translate(number_value)\n141                 try:\n142                     translated = translated % rhs\n143                 except TypeError:\n144                     # String doesn't contain a placeholder for the number.\n145                     pass\n146                 return translated\n147 \n148         proxy = lazy(lambda **kwargs: NumberAwareString(), NumberAwareString)(**kwargs)\n149         proxy.__reduce__ = lambda: (_lazy_number_unpickle, (func, resultclass, number, original_kwargs))\n150     return proxy\n151 \n152 \n153 def _lazy_number_unpickle(func, resultclass, number, kwargs):\n154     return lazy_number(func, resultclass, number=number, **kwargs)\n155 \n156 \n157 def ngettext_lazy(singular, plural, number=None):\n158     return lazy_number(ngettext, str, singular=singular, plural=plural, number=number)\n159 \n160 \n161 # An alias since Django 2.0\n162 ungettext_lazy = ngettext_lazy\n163 \n164 \n165 def npgettext_lazy(context, singular, plural, number=None):\n166     return lazy_number(npgettext, str, context=context, singular=singular, plural=plural, number=number)\n167 \n168 \n169 def activate(language):\n170     return _trans.activate(language)\n171 \n172 \n173 def deactivate():\n174     return _trans.deactivate()\n175 \n176 \n177 class override(ContextDecorator):\n178     def __init__(self, language, deactivate=False):\n179         self.language = language\n180         self.deactivate = deactivate\n181 \n182     def __enter__(self):\n183         self.old_language = get_language()\n184         if self.language is not None:\n185             activate(self.language)\n186         else:\n187             deactivate_all()\n188 \n189     def __exit__(self, exc_type, exc_value, traceback):\n190         if self.old_language is None:\n191             deactivate_all()\n192         elif self.deactivate:\n193             deactivate()\n194         else:\n195             activate(self.old_language)\n196 \n197 \n198 def get_language():\n199     return _trans.get_language()\n200 \n201 \n202 def get_language_bidi():\n203     return _trans.get_language_bidi()\n204 \n205 \n206 def check_for_language(lang_code):\n207     return _trans.check_for_language(lang_code)\n208 \n209 \n210 def to_language(locale):\n211     \"\"\"Turn a locale name (en_US) into a language name (en-us).\"\"\"\n212     p = locale.find('_')\n213     if p >= 0:\n214         return locale[:p].lower() + '-' + locale[p + 1:].lower()\n215     else:\n216         return locale.lower()\n217 \n218 \n219 def to_locale(language):\n220     \"\"\"Turn a language name (en-us) into a locale name (en_US).\"\"\"\n221     language, _, country = language.lower().partition('-')\n222     if not country:\n223         return language\n224     # A language with > 2 characters after the dash only has its first\n225     # character after the dash capitalized; e.g. sr-latn becomes sr_Latn.\n226     # A language with 2 characters after the dash has both characters\n227     # capitalized; e.g. en-us becomes en_US.\n228     country, _, tail = country.partition('-')\n229     country = country.title() if len(country) > 2 else country.upper()\n230     if tail:\n231         country += '-' + tail\n232     return language + '_' + country\n233 \n234 \n235 def get_language_from_request(request, check_path=False):\n236     return _trans.get_language_from_request(request, check_path)\n237 \n238 \n239 def get_language_from_path(path):\n240     return _trans.get_language_from_path(path)\n241 \n242 \n243 def get_supported_language_variant(lang_code, *, strict=False):\n244     return _trans.get_supported_language_variant(lang_code, strict)\n245 \n246 \n247 def templatize(src, **kwargs):\n248     from .template import templatize\n249     return templatize(src, **kwargs)\n250 \n251 \n252 def deactivate_all():\n253     return _trans.deactivate_all()\n254 \n255 \n256 def get_language_info(lang_code):\n257     from django.conf.locale import LANG_INFO\n258     try:\n259         lang_info = LANG_INFO[lang_code]\n260         if 'fallback' in lang_info and 'name' not in lang_info:\n261             info = get_language_info(lang_info['fallback'][0])\n262         else:\n263             info = lang_info\n264     except KeyError:\n265         if '-' not in lang_code:\n266             raise KeyError(\"Unknown language code %s.\" % lang_code)\n267         generic_lang_code = lang_code.split('-')[0]\n268         try:\n269             info = LANG_INFO[generic_lang_code]\n270         except KeyError:\n271             raise KeyError(\"Unknown language code %s and %s.\" % (lang_code, generic_lang_code))\n272 \n273     if info:\n274         info['name_translated'] = gettext_lazy(info['name'])\n275     return info\n276 \n277 \n278 trim_whitespace_re = re.compile(r'\\s*\\n\\s*')\n279 \n280 \n281 def trim_whitespace(s):\n282     return trim_whitespace_re.sub(' ', s.strip())\n",
        "intended_behavior": "Replace all instances of `ugettext` within this file with `gettext`. This change is to align with Python 3's standard for translation, ensuring that Django's codebase remains modern and maintainable. The replacement should preserve the functionality of the translation module, seamlessly transitioning to the updated function without altering its external behavior or the API it offers to Django applications."
    },
    {
        "rel_file_path": "django/core/management/commands/makemessages.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/management/commands/makemessages.py",
        "start": 1,
        "end": 662,
        "class_name": null,
        "method_name": null,
        "code": "1 import glob\n2 import os\n3 import re\n4 import sys\n5 from functools import total_ordering\n6 from itertools import dropwhile\n7 \n8 import django\n9 from django.conf import settings\n10 from django.core.exceptions import ImproperlyConfigured\n11 from django.core.files.temp import NamedTemporaryFile\n12 from django.core.management.base import BaseCommand, CommandError\n13 from django.core.management.utils import (\n14     find_command, handle_extensions, is_ignored_path, popen_wrapper,\n15 )\n16 from django.utils.encoding import DEFAULT_LOCALE_ENCODING\n17 from django.utils.functional import cached_property\n18 from django.utils.jslex import prepare_js_for_gettext\n19 from django.utils.text import get_text_list\n20 from django.utils.translation import templatize\n21 \n22 plural_forms_re = re.compile(r'^(?P<value>\"Plural-Forms.+?\\\\n\")\\s*$', re.MULTILINE | re.DOTALL)\n23 STATUS_OK = 0\n24 NO_LOCALE_DIR = object()\n25 \n26 \n27 def check_programs(*programs):\n28     for program in programs:\n29         if find_command(program) is None:\n30             raise CommandError(\n31                 \"Can't find %s. Make sure you have GNU gettext tools 0.15 or \"\n32                 \"newer installed.\" % program\n33             )\n34 \n35 \n36 @total_ordering\n37 class TranslatableFile:\n38     def __init__(self, dirpath, file_name, locale_dir):\n39         self.file = file_name\n40         self.dirpath = dirpath\n41         self.locale_dir = locale_dir\n42 \n43     def __repr__(self):\n44         return \"<%s: %s>\" % (\n45             self.__class__.__name__,\n46             os.sep.join([self.dirpath, self.file]),\n47         )\n48 \n49     def __eq__(self, other):\n50         return self.path == other.path\n51 \n52     def __lt__(self, other):\n53         return self.path < other.path\n54 \n55     @property\n56     def path(self):\n57         return os.path.join(self.dirpath, self.file)\n58 \n59 \n60 class BuildFile:\n61     \"\"\"\n62     Represent the state of a translatable file during the build process.\n63     \"\"\"\n64     def __init__(self, command, domain, translatable):\n65         self.command = command\n66         self.domain = domain\n67         self.translatable = translatable\n68 \n69     @cached_property\n70     def is_templatized(self):\n71         if self.domain == 'djangojs':\n72             return self.command.gettext_version < (0, 18, 3)\n73         elif self.domain == 'django':\n74             file_ext = os.path.splitext(self.translatable.file)[1]\n75             return file_ext != '.py'\n76         return False\n77 \n78     @cached_property\n79     def path(self):\n80         return self.translatable.path\n81 \n82     @cached_property\n83     def work_path(self):\n84         \"\"\"\n85         Path to a file which is being fed into GNU gettext pipeline. This may\n86         be either a translatable or its preprocessed version.\n87         \"\"\"\n88         if not self.is_templatized:\n89             return self.path\n90         extension = {\n91             'djangojs': 'c',\n92             'django': 'py',\n93         }.get(self.domain)\n94         filename = '%s.%s' % (self.translatable.file, extension)\n95         return os.path.join(self.translatable.dirpath, filename)\n96 \n97     def preprocess(self):\n98         \"\"\"\n99         Preprocess (if necessary) a translatable file before passing it to\n100         xgettext GNU gettext utility.\n101         \"\"\"\n102         if not self.is_templatized:\n103             return\n104 \n105         encoding = settings.FILE_CHARSET if self.command.settings_available else 'utf-8'\n106         with open(self.path, encoding=encoding) as fp:\n107             src_data = fp.read()\n108 \n109         if self.domain == 'djangojs':\n110             content = prepare_js_for_gettext(src_data)\n111         elif self.domain == 'django':\n112             content = templatize(src_data, origin=self.path[2:])\n113 \n114         with open(self.work_path, 'w', encoding='utf-8') as fp:\n115             fp.write(content)\n116 \n117     def postprocess_messages(self, msgs):\n118         \"\"\"\n119         Postprocess messages generated by xgettext GNU gettext utility.\n120 \n121         Transform paths as if these messages were generated from original\n122         translatable files rather than from preprocessed versions.\n123         \"\"\"\n124         if not self.is_templatized:\n125             return msgs\n126 \n127         # Remove '.py' suffix\n128         if os.name == 'nt':\n129             # Preserve '.\\' prefix on Windows to respect gettext behavior\n130             old_path = self.work_path\n131             new_path = self.path\n132         else:\n133             old_path = self.work_path[2:]\n134             new_path = self.path[2:]\n135 \n136         return re.sub(\n137             r'^(#: .*)(' + re.escape(old_path) + r')',\n138             lambda match: match.group().replace(old_path, new_path),\n139             msgs,\n140             flags=re.MULTILINE\n141         )\n142 \n143     def cleanup(self):\n144         \"\"\"\n145         Remove a preprocessed copy of a translatable file (if any).\n146         \"\"\"\n147         if self.is_templatized:\n148             # This check is needed for the case of a symlinked file and its\n149             # source being processed inside a single group (locale dir);\n150             # removing either of those two removes both.\n151             if os.path.exists(self.work_path):\n152                 os.unlink(self.work_path)\n153 \n154 \n155 def normalize_eols(raw_contents):\n156     \"\"\"\n157     Take a block of raw text that will be passed through str.splitlines() to\n158     get universal newlines treatment.\n159 \n160     Return the resulting block of text with normalized `\\n` EOL sequences ready\n161     to be written to disk using current platform's native EOLs.\n162     \"\"\"\n163     lines_list = raw_contents.splitlines()\n164     # Ensure last line has its EOL\n165     if lines_list and lines_list[-1]:\n166         lines_list.append('')\n167     return '\\n'.join(lines_list)\n168 \n169 \n170 def write_pot_file(potfile, msgs):\n171     \"\"\"\n172     Write the `potfile` with the `msgs` contents, making sure its format is\n173     valid.\n174     \"\"\"\n175     pot_lines = msgs.splitlines()\n176     if os.path.exists(potfile):\n177         # Strip the header\n178         lines = dropwhile(len, pot_lines)\n179     else:\n180         lines = []\n181         found, header_read = False, False\n182         for line in pot_lines:\n183             if not found and not header_read:\n184                 if 'charset=CHARSET' in line:\n185                     found = True\n186                     line = line.replace('charset=CHARSET', 'charset=UTF-8')\n187             if not line and not found:\n188                 header_read = True\n189             lines.append(line)\n190     msgs = '\\n'.join(lines)\n191     # Force newlines of POT files to '\\n' to work around\n192     # https://savannah.gnu.org/bugs/index.php?52395\n193     with open(potfile, 'a', encoding='utf-8', newline='\\n') as fp:\n194         fp.write(msgs)\n195 \n196 \n197 class Command(BaseCommand):\n198     help = (\n199         \"Runs over the entire source tree of the current directory and \"\n200         \"pulls out all strings marked for translation. It creates (or updates) a message \"\n201         \"file in the conf/locale (in the django tree) or locale (for projects and \"\n202         \"applications) directory.\\n\\nYou must run this command with one of either the \"\n203         \"--locale, --exclude, or --all options.\"\n204     )\n205 \n206     translatable_file_class = TranslatableFile\n207     build_file_class = BuildFile\n208 \n209     requires_system_checks = False\n210 \n211     msgmerge_options = ['-q', '--previous']\n212     msguniq_options = ['--to-code=utf-8']\n213     msgattrib_options = ['--no-obsolete']\n214     xgettext_options = ['--from-code=UTF-8', '--add-comments=Translators']\n215 \n216     def add_arguments(self, parser):\n217         parser.add_argument(\n218             '--locale', '-l', default=[], action='append',\n219             help='Creates or updates the message files for the given locale(s) (e.g. pt_BR). '\n220                  'Can be used multiple times.',\n221         )\n222         parser.add_argument(\n223             '--exclude', '-x', default=[], action='append',\n224             help='Locales to exclude. Default is none. Can be used multiple times.',\n225         )\n226         parser.add_argument(\n227             '--domain', '-d', default='django',\n228             help='The domain of the message files (default: \"django\").',\n229         )\n230         parser.add_argument(\n231             '--all', '-a', action='store_true',\n232             help='Updates the message files for all existing locales.',\n233         )\n234         parser.add_argument(\n235             '--extension', '-e', dest='extensions', action='append',\n236             help='The file extension(s) to examine (default: \"html,txt,py\", or \"js\" '\n237                  'if the domain is \"djangojs\"). Separate multiple extensions with '\n238                  'commas, or use -e multiple times.',\n239         )\n240         parser.add_argument(\n241             '--symlinks', '-s', action='store_true',\n242             help='Follows symlinks to directories when examining source code '\n243                  'and templates for translation strings.',\n244         )\n245         parser.add_argument(\n246             '--ignore', '-i', action='append', dest='ignore_patterns',\n247             default=[], metavar='PATTERN',\n248             help='Ignore files or directories matching this glob-style pattern. '\n249                  'Use multiple times to ignore more.',\n250         )\n251         parser.add_argument(\n252             '--no-default-ignore', action='store_false', dest='use_default_ignore_patterns',\n253             help=\"Don't ignore the common glob-style patterns 'CVS', '.*', '*~' and '*.pyc'.\",\n254         )\n255         parser.add_argument(\n256             '--no-wrap', action='store_true',\n257             help=\"Don't break long message lines into several lines.\",\n258         )\n259         parser.add_argument(\n260             '--no-location', action='store_true',\n261             help=\"Don't write '#: filename:line' lines.\",\n262         )\n263         parser.add_argument(\n264             '--add-location',\n265             choices=('full', 'file', 'never'), const='full', nargs='?',\n266             help=(\n267                 \"Controls '#: filename:line' lines. If the option is 'full' \"\n268                 \"(the default if not given), the lines  include both file name \"\n269                 \"and line number. If it's 'file', the line number is omitted. If \"\n270                 \"it's 'never', the lines are suppressed (same as --no-location). \"\n271                 \"--add-location requires gettext 0.19 or newer.\"\n272             ),\n273         )\n274         parser.add_argument(\n275             '--no-obsolete', action='store_true',\n276             help=\"Remove obsolete message strings.\",\n277         )\n278         parser.add_argument(\n279             '--keep-pot', action='store_true',\n280             help=\"Keep .pot file after making messages. Useful when debugging.\",\n281         )\n282 \n283     def handle(self, *args, **options):\n284         locale = options['locale']\n285         exclude = options['exclude']\n286         self.domain = options['domain']\n287         self.verbosity = options['verbosity']\n288         process_all = options['all']\n289         extensions = options['extensions']\n290         self.symlinks = options['symlinks']\n291 \n292         ignore_patterns = options['ignore_patterns']\n293         if options['use_default_ignore_patterns']:\n294             ignore_patterns += ['CVS', '.*', '*~', '*.pyc']\n295         self.ignore_patterns = list(set(ignore_patterns))\n296 \n297         # Avoid messing with mutable class variables\n298         if options['no_wrap']:\n299             self.msgmerge_options = self.msgmerge_options[:] + ['--no-wrap']\n300             self.msguniq_options = self.msguniq_options[:] + ['--no-wrap']\n301             self.msgattrib_options = self.msgattrib_options[:] + ['--no-wrap']\n302             self.xgettext_options = self.xgettext_options[:] + ['--no-wrap']\n303         if options['no_location']:\n304             self.msgmerge_options = self.msgmerge_options[:] + ['--no-location']\n305             self.msguniq_options = self.msguniq_options[:] + ['--no-location']\n306             self.msgattrib_options = self.msgattrib_options[:] + ['--no-location']\n307             self.xgettext_options = self.xgettext_options[:] + ['--no-location']\n308         if options['add_location']:\n309             if self.gettext_version < (0, 19):\n310                 raise CommandError(\n311                     \"The --add-location option requires gettext 0.19 or later. \"\n312                     \"You have %s.\" % '.'.join(str(x) for x in self.gettext_version)\n313                 )\n314             arg_add_location = \"--add-location=%s\" % options['add_location']\n315             self.msgmerge_options = self.msgmerge_options[:] + [arg_add_location]\n316             self.msguniq_options = self.msguniq_options[:] + [arg_add_location]\n317             self.msgattrib_options = self.msgattrib_options[:] + [arg_add_location]\n318             self.xgettext_options = self.xgettext_options[:] + [arg_add_location]\n319 \n320         self.no_obsolete = options['no_obsolete']\n321         self.keep_pot = options['keep_pot']\n322 \n323         if self.domain not in ('django', 'djangojs'):\n324             raise CommandError(\"currently makemessages only supports domains \"\n325                                \"'django' and 'djangojs'\")\n326         if self.domain == 'djangojs':\n327             exts = extensions or ['js']\n328         else:\n329             exts = extensions or ['html', 'txt', 'py']\n330         self.extensions = handle_extensions(exts)\n331 \n332         if (locale is None and not exclude and not process_all) or self.domain is None:\n333             raise CommandError(\n334                 \"Type '%s help %s' for usage information.\"\n335                 % (os.path.basename(sys.argv[0]), sys.argv[1])\n336             )\n337 \n338         if self.verbosity > 1:\n339             self.stdout.write(\n340                 'examining files with the extensions: %s\\n'\n341                 % get_text_list(list(self.extensions), 'and')\n342             )\n343 \n344         self.invoked_for_django = False\n345         self.locale_paths = []\n346         self.default_locale_path = None\n347         if os.path.isdir(os.path.join('conf', 'locale')):\n348             self.locale_paths = [os.path.abspath(os.path.join('conf', 'locale'))]\n349             self.default_locale_path = self.locale_paths[0]\n350             self.invoked_for_django = True\n351         else:\n352             if self.settings_available:\n353                 self.locale_paths.extend(settings.LOCALE_PATHS)\n354             # Allow to run makemessages inside an app dir\n355             if os.path.isdir('locale'):\n356                 self.locale_paths.append(os.path.abspath('locale'))\n357             if self.locale_paths:\n358                 self.default_locale_path = self.locale_paths[0]\n359                 os.makedirs(self.default_locale_path, exist_ok=True)\n360 \n361         # Build locale list\n362         looks_like_locale = re.compile(r'[a-z]{2}')\n363         locale_dirs = filter(os.path.isdir, glob.glob('%s/*' % self.default_locale_path))\n364         all_locales = [\n365             lang_code for lang_code in map(os.path.basename, locale_dirs)\n366             if looks_like_locale.match(lang_code)\n367         ]\n368 \n369         # Account for excluded locales\n370         if process_all:\n371             locales = all_locales\n372         else:\n373             locales = locale or all_locales\n374             locales = set(locales).difference(exclude)\n375 \n376         if locales:\n377             check_programs('msguniq', 'msgmerge', 'msgattrib')\n378 \n379         check_programs('xgettext')\n380 \n381         try:\n382             potfiles = self.build_potfiles()\n383 \n384             # Build po files for each selected locale\n385             for locale in locales:\n386                 if self.verbosity > 0:\n387                     self.stdout.write(\"processing locale %s\\n\" % locale)\n388                 for potfile in potfiles:\n389                     self.write_po_file(potfile, locale)\n390         finally:\n391             if not self.keep_pot:\n392                 self.remove_potfiles()\n393 \n394     @cached_property\n395     def gettext_version(self):\n396         # Gettext tools will output system-encoded bytestrings instead of UTF-8,\n397         # when looking up the version. It's especially a problem on Windows.\n398         out, err, status = popen_wrapper(\n399             ['xgettext', '--version'],\n400             stdout_encoding=DEFAULT_LOCALE_ENCODING,\n401         )\n402         m = re.search(r'(\\d+)\\.(\\d+)\\.?(\\d+)?', out)\n403         if m:\n404             return tuple(int(d) for d in m.groups() if d is not None)\n405         else:\n406             raise CommandError(\"Unable to get gettext version. Is it installed?\")\n407 \n408     @cached_property\n409     def settings_available(self):\n410         try:\n411             settings.LOCALE_PATHS\n412         except ImproperlyConfigured:\n413             if self.verbosity > 1:\n414                 self.stderr.write(\"Running without configured settings.\")\n415             return False\n416         return True\n417 \n418     def build_potfiles(self):\n419         \"\"\"\n420         Build pot files and apply msguniq to them.\n421         \"\"\"\n422         file_list = self.find_files(\".\")\n423         self.remove_potfiles()\n424         self.process_files(file_list)\n425         potfiles = []\n426         for path in self.locale_paths:\n427             potfile = os.path.join(path, '%s.pot' % self.domain)\n428             if not os.path.exists(potfile):\n429                 continue\n430             args = ['msguniq'] + self.msguniq_options + [potfile]\n431             msgs, errors, status = popen_wrapper(args)\n432             if errors:\n433                 if status != STATUS_OK:\n434                     raise CommandError(\n435                         \"errors happened while running msguniq\\n%s\" % errors)\n436                 elif self.verbosity > 0:\n437                     self.stdout.write(errors)\n438             msgs = normalize_eols(msgs)\n439             with open(potfile, 'w', encoding='utf-8') as fp:\n440                 fp.write(msgs)\n441             potfiles.append(potfile)\n442         return potfiles\n443 \n444     def remove_potfiles(self):\n445         for path in self.locale_paths:\n446             pot_path = os.path.join(path, '%s.pot' % self.domain)\n447             if os.path.exists(pot_path):\n448                 os.unlink(pot_path)\n449 \n450     def find_files(self, root):\n451         \"\"\"\n452         Get all files in the given root. Also check that there is a matching\n453         locale dir for each file.\n454         \"\"\"\n455         all_files = []\n456         ignored_roots = []\n457         if self.settings_available:\n458             ignored_roots = [os.path.normpath(p) for p in (settings.MEDIA_ROOT, settings.STATIC_ROOT) if p]\n459         for dirpath, dirnames, filenames in os.walk(root, topdown=True, followlinks=self.symlinks):\n460             for dirname in dirnames[:]:\n461                 if (is_ignored_path(os.path.normpath(os.path.join(dirpath, dirname)), self.ignore_patterns) or\n462                         os.path.join(os.path.abspath(dirpath), dirname) in ignored_roots):\n463                     dirnames.remove(dirname)\n464                     if self.verbosity > 1:\n465                         self.stdout.write('ignoring directory %s\\n' % dirname)\n466                 elif dirname == 'locale':\n467                     dirnames.remove(dirname)\n468                     self.locale_paths.insert(0, os.path.join(os.path.abspath(dirpath), dirname))\n469             for filename in filenames:\n470                 file_path = os.path.normpath(os.path.join(dirpath, filename))\n471                 file_ext = os.path.splitext(filename)[1]\n472                 if file_ext not in self.extensions or is_ignored_path(file_path, self.ignore_patterns):\n473                     if self.verbosity > 1:\n474                         self.stdout.write('ignoring file %s in %s\\n' % (filename, dirpath))\n475                 else:\n476                     locale_dir = None\n477                     for path in self.locale_paths:\n478                         if os.path.abspath(dirpath).startswith(os.path.dirname(path)):\n479                             locale_dir = path\n480                             break\n481                     locale_dir = locale_dir or self.default_locale_path or NO_LOCALE_DIR\n482                     all_files.append(self.translatable_file_class(dirpath, filename, locale_dir))\n483         return sorted(all_files)\n484 \n485     def process_files(self, file_list):\n486         \"\"\"\n487         Group translatable files by locale directory and run pot file build\n488         process for each group.\n489         \"\"\"\n490         file_groups = {}\n491         for translatable in file_list:\n492             file_group = file_groups.setdefault(translatable.locale_dir, [])\n493             file_group.append(translatable)\n494         for locale_dir, files in file_groups.items():\n495             self.process_locale_dir(locale_dir, files)\n496 \n497     def process_locale_dir(self, locale_dir, files):\n498         \"\"\"\n499         Extract translatable literals from the specified files, creating or\n500         updating the POT file for a given locale directory.\n501 \n502         Use the xgettext GNU gettext utility.\n503         \"\"\"\n504         build_files = []\n505         for translatable in files:\n506             if self.verbosity > 1:\n507                 self.stdout.write('processing file %s in %s\\n' % (\n508                     translatable.file, translatable.dirpath\n509                 ))\n510             if self.domain not in ('djangojs', 'django'):\n511                 continue\n512             build_file = self.build_file_class(self, self.domain, translatable)\n513             try:\n514                 build_file.preprocess()\n515             except UnicodeDecodeError as e:\n516                 self.stdout.write(\n517                     'UnicodeDecodeError: skipped file %s in %s (reason: %s)' % (\n518                         translatable.file, translatable.dirpath, e,\n519                     )\n520                 )\n521                 continue\n522             build_files.append(build_file)\n523 \n524         if self.domain == 'djangojs':\n525             is_templatized = build_file.is_templatized\n526             args = [\n527                 'xgettext',\n528                 '-d', self.domain,\n529                 '--language=%s' % ('C' if is_templatized else 'JavaScript',),\n530                 '--keyword=gettext_noop',\n531                 '--keyword=gettext_lazy',\n532                 '--keyword=ngettext_lazy:1,2',\n533                 '--keyword=pgettext:1c,2',\n534                 '--keyword=npgettext:1c,2,3',\n535                 '--output=-',\n536             ]\n537         elif self.domain == 'django':\n538             args = [\n539                 'xgettext',\n540                 '-d', self.domain,\n541                 '--language=Python',\n542                 '--keyword=gettext_noop',\n543                 '--keyword=gettext_lazy',\n544                 '--keyword=ngettext_lazy:1,2',\n545                 '--keyword=ugettext_noop',\n546                 '--keyword=ugettext_lazy',\n547                 '--keyword=ungettext_lazy:1,2',\n548                 '--keyword=pgettext:1c,2',\n549                 '--keyword=npgettext:1c,2,3',\n550                 '--keyword=pgettext_lazy:1c,2',\n551                 '--keyword=npgettext_lazy:1c,2,3',\n552                 '--output=-',\n553             ]\n554         else:\n555             return\n556 \n557         input_files = [bf.work_path for bf in build_files]\n558         with NamedTemporaryFile(mode='w+') as input_files_list:\n559             input_files_list.write(('\\n'.join(input_files)))\n560             input_files_list.flush()\n561             args.extend(['--files-from', input_files_list.name])\n562             args.extend(self.xgettext_options)\n563             msgs, errors, status = popen_wrapper(args)\n564 \n565         if errors:\n566             if status != STATUS_OK:\n567                 for build_file in build_files:\n568                     build_file.cleanup()\n569                 raise CommandError(\n570                     'errors happened while running xgettext on %s\\n%s' %\n571                     ('\\n'.join(input_files), errors)\n572                 )\n573             elif self.verbosity > 0:\n574                 # Print warnings\n575                 self.stdout.write(errors)\n576 \n577         if msgs:\n578             if locale_dir is NO_LOCALE_DIR:\n579                 file_path = os.path.normpath(build_files[0].path)\n580                 raise CommandError(\n581                     'Unable to find a locale path to store translations for '\n582                     'file %s' % file_path\n583                 )\n584             for build_file in build_files:\n585                 msgs = build_file.postprocess_messages(msgs)\n586             potfile = os.path.join(locale_dir, '%s.pot' % self.domain)\n587             write_pot_file(potfile, msgs)\n588 \n589         for build_file in build_files:\n590             build_file.cleanup()\n591 \n592     def write_po_file(self, potfile, locale):\n593         \"\"\"\n594         Create or update the PO file for self.domain and `locale`.\n595         Use contents of the existing `potfile`.\n596 \n597         Use msgmerge and msgattrib GNU gettext utilities.\n598         \"\"\"\n599         basedir = os.path.join(os.path.dirname(potfile), locale, 'LC_MESSAGES')\n600         os.makedirs(basedir, exist_ok=True)\n601         pofile = os.path.join(basedir, '%s.po' % self.domain)\n602 \n603         if os.path.exists(pofile):\n604             args = ['msgmerge'] + self.msgmerge_options + [pofile, potfile]\n605             msgs, errors, status = popen_wrapper(args)\n606             if errors:\n607                 if status != STATUS_OK:\n608                     raise CommandError(\n609                         \"errors happened while running msgmerge\\n%s\" % errors)\n610                 elif self.verbosity > 0:\n611                     self.stdout.write(errors)\n612         else:\n613             with open(potfile, encoding='utf-8') as fp:\n614                 msgs = fp.read()\n615             if not self.invoked_for_django:\n616                 msgs = self.copy_plural_forms(msgs, locale)\n617         msgs = normalize_eols(msgs)\n618         msgs = msgs.replace(\n619             \"#. #-#-#-#-#  %s.pot (PACKAGE VERSION)  #-#-#-#-#\\n\" % self.domain, \"\")\n620         with open(pofile, 'w', encoding='utf-8') as fp:\n621             fp.write(msgs)\n622 \n623         if self.no_obsolete:\n624             args = ['msgattrib'] + self.msgattrib_options + ['-o', pofile, pofile]\n625             msgs, errors, status = popen_wrapper(args)\n626             if errors:\n627                 if status != STATUS_OK:\n628                     raise CommandError(\n629                         \"errors happened while running msgattrib\\n%s\" % errors)\n630                 elif self.verbosity > 0:\n631                     self.stdout.write(errors)\n632 \n633     def copy_plural_forms(self, msgs, locale):\n634         \"\"\"\n635         Copy plural forms header contents from a Django catalog of locale to\n636         the msgs string, inserting it at the right place. msgs should be the\n637         contents of a newly created .po file.\n638         \"\"\"\n639         django_dir = os.path.normpath(os.path.join(os.path.dirname(django.__file__)))\n640         if self.domain == 'djangojs':\n641             domains = ('djangojs', 'django')\n642         else:\n643             domains = ('django',)\n644         for domain in domains:\n645             django_po = os.path.join(django_dir, 'conf', 'locale', locale, 'LC_MESSAGES', '%s.po' % domain)\n646             if os.path.exists(django_po):\n647                 with open(django_po, encoding='utf-8') as fp:\n648                     m = plural_forms_re.search(fp.read())\n649                 if m:\n650                     plural_form_line = m.group('value')\n651                     if self.verbosity > 1:\n652                         self.stdout.write(\"copying plural forms: %s\\n\" % plural_form_line)\n653                     lines = []\n654                     found = False\n655                     for line in msgs.splitlines():\n656                         if not found and (not line or plural_forms_re.search(line)):\n657                             line = plural_form_line\n658                             found = True\n659                         lines.append(line)\n660                     msgs = '\\n'.join(lines)\n661                     break\n662         return msgs\n",
        "intended_behavior": "Audit and replace any usage of `ugettext` with `gettext` in this script, focusing on maintaining the integrity of the message file generation process. The adaptation aims to ensure that the command's functionality reflects the updated translation practices without impacting the user experience or the outcome of the command's execution, thus ensuring that message file generation remains efficient and accurate under the new standard."
    }
]