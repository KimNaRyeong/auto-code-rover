2025-10-17 11:43:21.682 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 11:43:25.448 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=401, output_tokens=12, cost=0.004370
2025-10-17 11:43:25.449 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 11:43:25.453 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:43:34.111 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=701, output_tokens=351, cost=0.017540
2025-10-17 11:43:34.119 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:43:36.692 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=705, output_tokens=96, cost=0.009930
2025-10-17 11:43:36.693 | DEBUG    | Extracted a valid json.
2025-10-17 11:43:36.693 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Index\")",
        "search_class(\"UniqueConstraint\")",
        "search_class(\"BaseDatabaseSchemaEditor\")",
        "search_method_in_class(\"add_index\", \"BaseDatabaseSchemaEditor\")",
        "search_method_in_class(\"add_constraint\", \"BaseDatabaseSchemaEditor\")",
        "search_code(\"fields=\")",
        "search_code(\"condition=\")"
    ],
    "bug_locations": []
}
2025-10-17 11:43:36.887 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 11:43:36.888 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 11:43:51.909 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4219, output_tokens=694, cost=0.063010
2025-10-17 11:43:51.923 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:44:01.925 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5129, output_tokens=396, cost=0.063170
2025-10-17 11:44:01.935 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:44:11.202 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=750, output_tokens=348, cost=0.017940
2025-10-17 11:44:11.203 | DEBUG    | Extracted a valid json.
2025-10-17 11:44:11.203 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/models/indexes.py",
            "class": "Index",
            "method": "",
            "intended_behavior": "Modify or extend the `__init__`, `create_sql`, and possibly `deconstruct` methods to support an `include` kwarg. This kwarg should list the fields to be included in the index but not used as keys. The `create_sql` method must be adapted to append an `INCLUDE` clause with the fields specified by `include` when generating the SQL for databases that support this feature."
        },
        {
            "file": "django/db/models/constraints.py",
            "class": "UniqueConstraint",
            "method": "",
            "intended_behavior": "Similar to the `Index` class, modify or extend the `__init__`, `create_sql`, and possibly `deconstruct` methods to accept an `include` kwarg, allowing non-key columns to be included in the unique constraint for databases that support this feature. The `create_sql` needs to generate SQL that includes these fields in an `INCLUDE` statement."
        },
        {
            "file": "django/db/backends/base/schema.py",
            "class": "BaseDatabaseSchemaEditor",
            "method": "",
            "intended_behavior": "Since backend-specific implementations might be needed to support the `INCLUDE` clause across different databases, review and possibly extend methods like `add_index` and `add_constraint` to handle the `include` kwarg. This involves ensuring that SQL generation respects the `include` kwarg if provided and the database backend supports it."
        }
    ]
}
2025-10-17 11:44:11.218 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/indexes.py</file>
<class>Index</class>
<method>None</method>
<code>
8 class Index:
9     suffix = 'idx'
10     # The max length of the name of the index (restricted to 30 for
11     # cross-database compatibility with Oracle)
12     max_name_length = 30
13 
14     def __init__(self, *, fields=(), name=None, db_tablespace=None, opclasses=(), condition=None):
15         if opclasses and not name:
16             raise ValueError('An index must be named to use opclasses.')
17         if not isinstance(condition, (type(None), Q)):
18             raise ValueError('Index.condition must be a Q instance.')
19         if condition and not name:
20             raise ValueError('An index must be named to use condition.')
21         if not isinstance(fields, (list, tuple)):
22             raise ValueError('Index.fields must be a list or tuple.')
23         if not isinstance(opclasses, (list, tuple)):
24             raise ValueError('Index.opclasses must be a list or tuple.')
25         if opclasses and len(fields) != len(opclasses):
26             raise ValueError('Index.fields and Index.opclasses must have the same number of elements.')
27         if not fields:
28             raise ValueError('At least one field is required to define an index.')
29         self.fields = list(fields)
30         # A list of 2-tuple with the field name and ordering ('' or 'DESC').
31         self.fields_orders = [
32             (field_name[1:], 'DESC') if field_name.startswith('-') else (field_name, '')
33             for field_name in self.fields
34         ]
35         self.name = name or ''
36         self.db_tablespace = db_tablespace
37         self.opclasses = opclasses
38         self.condition = condition
39 
40     def _get_condition_sql(self, model, schema_editor):
41         if self.condition is None:
42             return None
43         query = Query(model=model, alias_cols=False)
44         where = query.build_where(self.condition)
45         compiler = query.get_compiler(connection=schema_editor.connection)
46         sql, params = where.as_sql(compiler, schema_editor.connection)
47         return sql % tuple(schema_editor.quote_value(p) for p in params)
48 
49     def create_sql(self, model, schema_editor, using='', **kwargs):
50         fields = [model._meta.get_field(field_name) for field_name, _ in self.fields_orders]
51         col_suffixes = [order[1] for order in self.fields_orders]
52         condition = self._get_condition_sql(model, schema_editor)
53         return schema_editor._create_index_sql(
54             model, fields, name=self.name, using=using, db_tablespace=self.db_tablespace,
55             col_suffixes=col_suffixes, opclasses=self.opclasses, condition=condition,
56             **kwargs,
57         )
58 
59     def remove_sql(self, model, schema_editor, **kwargs):
60         return schema_editor._delete_index_sql(model, self.name, **kwargs)
61 
62     def deconstruct(self):
63         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)
64         path = path.replace('django.db.models.indexes', 'django.db.models')
65         kwargs = {'fields': self.fields, 'name': self.name}
66         if self.db_tablespace is not None:
67             kwargs['db_tablespace'] = self.db_tablespace
68         if self.opclasses:
69             kwargs['opclasses'] = self.opclasses
70         if self.condition:
71             kwargs['condition'] = self.condition
72         return (path, (), kwargs)
73 
74     def clone(self):
75         """Create a copy of this Index."""
76         _, _, kwargs = self.deconstruct()
77         return self.__class__(**kwargs)
78 
79     def set_name_with_model(self, model):
80         """
81         Generate a unique name for the index.
82 
83         The name is divided into 3 parts - table name (12 chars), field name
84         (8 chars) and unique hash + suffix (10 chars). Each part is made to
85         fit its size by truncating the excess length.
86         """
87         _, table_name = split_identifier(model._meta.db_table)
88         column_names = [model._meta.get_field(field_name).column for field_name, order in self.fields_orders]
89         column_names_with_order = [
90             (('-%s' if order else '%s') % column_name)
91             for column_name, (field_name, order) in zip(column_names, self.fields_orders)
92         ]
93         # The length of the parts of the name is based on the default max
94         # length of 30 characters.
95         hash_data = [table_name] + column_names_with_order + [self.suffix]
96         self.name = '%s_%s_%s' % (
97             table_name[:11],
98             column_names[0][:7],
99             '%s_%s' % (names_digest(*hash_data, length=6), self.suffix),
100         )
101         assert len(self.name) <= self.max_name_length, (
102             'Index too long for multiple database support. Is self.suffix '
103             'longer than 3 characters?'
104         )
105         if self.name[0] == '_' or self.name[0].isdigit():
106             self.name = 'D%s' % self.name[1:]
107 
108     def __repr__(self):
109         return "<%s: fields='%s'%s>" % (
110             self.__class__.__name__, ', '.join(self.fields),
111             '' if self.condition is None else ', condition=%s' % self.condition,
112         )
113 
114     def __eq__(self, other):
115         if self.__class__ == other.__class__:
116             return self.deconstruct() == other.deconstruct()
117         return NotImplemented

</code><intended_behavior>Modify or extend the `__init__`, `create_sql`, and possibly `deconstruct` methods to support an `include` kwarg. This kwarg should list the fields to be included in the index but not used as keys. The `create_sql` method must be adapted to append an `INCLUDE` clause with the fields specified by `include` when generating the SQL for databases that support this feature.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>UniqueConstraint</class>
<method>None</method>
<code>
79 class UniqueConstraint(BaseConstraint):
80     def __init__(self, *, fields, name, condition=None, deferrable=None):
81         if not fields:
82             raise ValueError('At least one field is required to define a unique constraint.')
83         if not isinstance(condition, (type(None), Q)):
84             raise ValueError('UniqueConstraint.condition must be a Q instance.')
85         if condition and deferrable:
86             raise ValueError(
87                 'UniqueConstraint with conditions cannot be deferred.'
88             )
89         if not isinstance(deferrable, (type(None), Deferrable)):
90             raise ValueError(
91                 'UniqueConstraint.deferrable must be a Deferrable instance.'
92             )
93         self.fields = tuple(fields)
94         self.condition = condition
95         self.deferrable = deferrable
96         super().__init__(name)
97 
98     def _get_condition_sql(self, model, schema_editor):
99         if self.condition is None:
100             return None
101         query = Query(model=model, alias_cols=False)
102         where = query.build_where(self.condition)
103         compiler = query.get_compiler(connection=schema_editor.connection)
104         sql, params = where.as_sql(compiler, schema_editor.connection)
105         return sql % tuple(schema_editor.quote_value(p) for p in params)
106 
107     def constraint_sql(self, model, schema_editor):
108         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
109         condition = self._get_condition_sql(model, schema_editor)
110         return schema_editor._unique_sql(
111             model, fields, self.name, condition=condition,
112             deferrable=self.deferrable,
113         )
114 
115     def create_sql(self, model, schema_editor):
116         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
117         condition = self._get_condition_sql(model, schema_editor)
118         return schema_editor._create_unique_sql(
119             model, fields, self.name, condition=condition,
120             deferrable=self.deferrable,
121         )
122 
123     def remove_sql(self, model, schema_editor):
124         condition = self._get_condition_sql(model, schema_editor)
125         return schema_editor._delete_unique_sql(
126             model, self.name, condition=condition, deferrable=self.deferrable,
127         )
128 
129     def __repr__(self):
130         return '<%s: fields=%r name=%r%s%s>' % (
131             self.__class__.__name__, self.fields, self.name,
132             '' if self.condition is None else ' condition=%s' % self.condition,
133             '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,
134         )
135 
136     def __eq__(self, other):
137         if isinstance(other, UniqueConstraint):
138             return (
139                 self.name == other.name and
140                 self.fields == other.fields and
141                 self.condition == other.condition and
142                 self.deferrable == other.deferrable
143             )
144         return super().__eq__(other)
145 
146     def deconstruct(self):
147         path, args, kwargs = super().deconstruct()
148         kwargs['fields'] = self.fields
149         if self.condition:
150             kwargs['condition'] = self.condition
151         if self.deferrable:
152             kwargs['deferrable'] = self.deferrable
153         return path, args, kwargs

</code><intended_behavior>Similar to the `Index` class, modify or extend the `__init__`, `create_sql`, and possibly `deconstruct` methods to accept an `include` kwarg, allowing non-key columns to be included in the unique constraint for databases that support this feature. The `create_sql` needs to generate SQL that includes these fields in an `INCLUDE` statement.</intended_behavior>, <file>django/db/backends/base/schema.py</file>
<class>BaseDatabaseSchemaEditor</class>
<method>None</method>
<code>
44 class BaseDatabaseSchemaEditor:
45     """
46     This class and its subclasses are responsible for emitting schema-changing
47     statements to the databases - model creation/removal/alteration, field
48     renaming, index fiddling, and so on.
49     """
50 
51     # Overrideable SQL templates
52     sql_create_table = "CREATE TABLE %(table)s (%(definition)s)"
53     sql_rename_table = "ALTER TABLE %(old_table)s RENAME TO %(new_table)s"
54     sql_retablespace_table = "ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s"
55     sql_delete_table = "DROP TABLE %(table)s CASCADE"
56 
57     sql_create_column = "ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s"
58     sql_alter_column = "ALTER TABLE %(table)s %(changes)s"
59     sql_alter_column_type = "ALTER COLUMN %(column)s TYPE %(type)s"
60     sql_alter_column_null = "ALTER COLUMN %(column)s DROP NOT NULL"
61     sql_alter_column_not_null = "ALTER COLUMN %(column)s SET NOT NULL"
62     sql_alter_column_default = "ALTER COLUMN %(column)s SET DEFAULT %(default)s"
63     sql_alter_column_no_default = "ALTER COLUMN %(column)s DROP DEFAULT"
64     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE"
65     sql_rename_column = "ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s"
66     sql_update_with_default = "UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL"
67 
68     sql_unique_constraint = "UNIQUE (%(columns)s)%(deferrable)s"
69     sql_check_constraint = "CHECK (%(check)s)"
70     sql_delete_constraint = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"
71     sql_constraint = "CONSTRAINT %(name)s %(constraint)s"
72 
73     sql_create_check = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)"
74     sql_delete_check = sql_delete_constraint
75 
76     sql_create_unique = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s UNIQUE (%(columns)s)%(deferrable)s"
77     sql_delete_unique = sql_delete_constraint
78 
79     sql_create_fk = (
80         "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) "
81         "REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s"
82     )
83     sql_create_inline_fk = None
84     sql_create_column_inline_fk = None
85     sql_delete_fk = sql_delete_constraint
86 
87     sql_create_index = "CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s%(condition)s"
88     sql_create_unique_index = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s"
89     sql_delete_index = "DROP INDEX %(name)s"
90 
91     sql_create_pk = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)"
92     sql_delete_pk = sql_delete_constraint
93 
94     sql_delete_procedure = 'DROP PROCEDURE %(procedure)s'
95 
96     def __init__(self, connection, collect_sql=False, atomic=True):
97         self.connection = connection
98         self.collect_sql = collect_sql
99         if self.collect_sql:
100             self.collected_sql = []
101         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
102 
103     # State-managing methods
104 
105     def __enter__(self):
106         self.deferred_sql = []
107         if self.atomic_migration:
108             self.atomic = atomic(self.connection.alias)
109             self.atomic.__enter__()
110         return self
111 
112     def __exit__(self, exc_type, exc_value, traceback):
113         if exc_type is None:
114             for sql in self.deferred_sql:
115                 self.execute(sql)
116         if self.atomic_migration:
117             self.atomic.__exit__(exc_type, exc_value, traceback)
118 
119     # Core utility functions
120 
121     def execute(self, sql, params=()):
122         """Execute the given SQL statement, with optional parameters."""
123         # Don't perform the transactional DDL check if SQL is being collected
124         # as it's not going to be executed anyway.
125         if not self.collect_sql and self.connection.in_atomic_block and not self.connection.features.can_rollback_ddl:
126             raise TransactionManagementError(
127                 "Executing DDL statements while in a transaction on databases "
128                 "that can't perform a rollback is prohibited."
129             )
130         # Account for non-string statement objects.
131         sql = str(sql)
132         # Log the command we're running, then run it
133         logger.debug("%s; (params %r)", sql, params, extra={'params': params, 'sql': sql})
134         if self.collect_sql:
135             ending = "" if sql.endswith(";") else ";"
136             if params is not None:
137                 self.collected_sql.append((sql % tuple(map(self.quote_value, params))) + ending)
138             else:
139                 self.collected_sql.append(sql + ending)
140         else:
141             with self.connection.cursor() as cursor:
142                 cursor.execute(sql, params)
143 
144     def quote_name(self, name):
145         return self.connection.ops.quote_name(name)
146 
147     def table_sql(self, model):
148         """Take a model and return its table definition."""
149         # Add any unique_togethers (always deferred, as some fields might be
150         # created afterwards, like geometry fields with some backends).
151         for fields in model._meta.unique_together:
152             columns = [model._meta.get_field(field).column for field in fields]
153             self.deferred_sql.append(self._create_unique_sql(model, columns))
154         # Create column SQL, add FK deferreds if needed.
155         column_sqls = []
156         params = []
157         for field in model._meta.local_fields:
158             # SQL.
159             definition, extra_params = self.column_sql(model, field)
160             if definition is None:
161                 continue
162             # Check constraints can go on the column SQL here.
163             db_params = field.db_parameters(connection=self.connection)
164             if db_params['check']:
165                 definition += ' ' + self.sql_check_constraint % db_params
166             # Autoincrement SQL (for backends with inline variant).
167             col_type_suffix = field.db_type_suffix(connection=self.connection)
168             if col_type_suffix:
169                 definition += ' %s' % col_type_suffix
170             params.extend(extra_params)
171             # FK.
172             if field.remote_field and field.db_constraint:
173                 to_table = field.remote_field.model._meta.db_table
174                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
175                 if self.sql_create_inline_fk:
176                     definition += ' ' + self.sql_create_inline_fk % {
177                         'to_table': self.quote_name(to_table),
178                         'to_column': self.quote_name(to_column),
179                     }
180                 elif self.connection.features.supports_foreign_keys:
181                     self.deferred_sql.append(self._create_fk_sql(model, field, '_fk_%(to_table)s_%(to_column)s'))
182             # Add the SQL to our big list.
183             column_sqls.append('%s %s' % (
184                 self.quote_name(field.column),
185                 definition,
186             ))
187             # Autoincrement SQL (for backends with post table definition
188             # variant).
189             if field.get_internal_type() in ('AutoField', 'BigAutoField', 'SmallAutoField'):
190                 autoinc_sql = self.connection.ops.autoinc_sql(model._meta.db_table, field.column)
191                 if autoinc_sql:
192                     self.deferred_sql.extend(autoinc_sql)
193         constraints = [constraint.constraint_sql(model, self) for constraint in model._meta.constraints]
194         sql = self.sql_create_table % {
195             'table': self.quote_name(model._meta.db_table),
196             'definition': ', '.join(constraint for constraint in (*column_sqls, *constraints) if constraint),
197         }
198         if model._meta.db_tablespace:
199             tablespace_sql = self.connection.ops.tablespace_sql(model._meta.db_tablespace)
200             if tablespace_sql:
201                 sql += ' ' + tablespace_sql
202         return sql, params
203 
204     # Field <-> database mapping functions
205 
206     def column_sql(self, model, field, include_default=False):
207         """
208         Take a field and return its column definition.
209         The field must already have had set_attributes_from_name() called.
210         """
211         # Get the column's type and use that as the basis of the SQL
212         db_params = field.db_parameters(connection=self.connection)
213         sql = db_params['type']
214         params = []
215         # Check for fields that aren't actually columns (e.g. M2M)
216         if sql is None:
217             return None, None
218         # Work out nullability
219         null = field.null
220         # If we were told to include a default value, do so
221         include_default = include_default and not self.skip_default(field)
222         if include_default:
223             default_value = self.effective_default(field)
224             column_default = ' DEFAULT ' + self._column_default_sql(field)
225             if default_value is not None:
226                 if self.connection.features.requires_literal_defaults:
227                     # Some databases can't take defaults as a parameter (oracle)
228                     # If this is the case, the individual schema backend should
229                     # implement prepare_default
230                     sql += column_default % self.prepare_default(default_value)
231                 else:
232                     sql += column_default
233                     params += [default_value]
234         # Oracle treats the empty string ('') as null, so coerce the null
235         # option whenever '' is a possible value.
236         if (field.empty_strings_allowed and not field.primary_key and
237                 self.connection.features.interprets_empty_strings_as_nulls):
238             null = True
239         if null and not self.connection.features.implied_column_null:
240             sql += " NULL"
241         elif not null:
242             sql += " NOT NULL"
243         # Primary key/unique outputs
244         if field.primary_key:
245             sql += " PRIMARY KEY"
246         elif field.unique:
247             sql += " UNIQUE"
248         # Optionally add the tablespace if it's an implicitly indexed column
249         tablespace = field.db_tablespace or model._meta.db_tablespace
250         if tablespace and self.connection.features.supports_tablespaces and field.unique:
251             sql += " %s" % self.connection.ops.tablespace_sql(tablespace, inline=True)
252         # Return the sql
253         return sql, params
254 
255     def skip_default(self, field):
256         """
257         Some backends don't accept default values for certain columns types
258         (i.e. MySQL longtext and longblob).
259         """
260         return False
261 
262     def prepare_default(self, value):
263         """
264         Only used for backends which have requires_literal_defaults feature
265         """
266         raise NotImplementedError(
267             'subclasses of BaseDatabaseSchemaEditor for backends which have '
268             'requires_literal_defaults must provide a prepare_default() method'
269         )
270 
271     def _column_default_sql(self, field):
272         """
273         Return the SQL to use in a DEFAULT clause. The resulting string should
274         contain a '%s' placeholder for a default value.
275         """
276         return '%s'
277 
278     @staticmethod
279     def _effective_default(field):
280         # This method allows testing its logic without a connection.
281         if field.has_default():
282             default = field.get_default()
283         elif not field.null and field.blank and field.empty_strings_allowed:
284             if field.get_internal_type() == "BinaryField":
285                 default = b''
286             else:
287                 default = ''
288         elif getattr(field, 'auto_now', False) or getattr(field, 'auto_now_add', False):
289             default = datetime.now()
290             internal_type = field.get_internal_type()
291             if internal_type == 'DateField':
292                 default = default.date()
293             elif internal_type == 'TimeField':
294                 default = default.time()
295             elif internal_type == 'DateTimeField':
296                 default = timezone.now()
297         else:
298             default = None
299         return default
300 
301     def effective_default(self, field):
302         """Return a field's effective database default value."""
303         return field.get_db_prep_save(self._effective_default(field), self.connection)
304 
305     def quote_value(self, value):
306         """
307         Return a quoted version of the value so it's safe to use in an SQL
308         string. This is not safe against injection from user code; it is
309         intended only for use in making SQL scripts or preparing default values
310         for particularly tricky backends (defaults are not user-defined, though,
311         so this is safe).
312         """
313         raise NotImplementedError()
314 
315     # Actions
316 
317     def create_model(self, model):
318         """
319         Create a table and any accompanying indexes or unique constraints for
320         the given `model`.
321         """
322         sql, params = self.table_sql(model)
323         # Prevent using [] as params, in the case a literal '%' is used in the definition
324         self.execute(sql, params or None)
325 
326         # Add any field index and index_together's (deferred as SQLite _remake_table needs it)
327         self.deferred_sql.extend(self._model_indexes_sql(model))
328 
329         # Make M2M tables
330         for field in model._meta.local_many_to_many:
331             if field.remote_field.through._meta.auto_created:
332                 self.create_model(field.remote_field.through)
333 
334     def delete_model(self, model):
335         """Delete a model from the database."""
336         # Handle auto-created intermediary models
337         for field in model._meta.local_many_to_many:
338             if field.remote_field.through._meta.auto_created:
339                 self.delete_model(field.remote_field.through)
340 
341         # Delete the table
342         self.execute(self.sql_delete_table % {
343             "table": self.quote_name(model._meta.db_table),
344         })
345         # Remove all deferred statements referencing the deleted table.
346         for sql in list(self.deferred_sql):
347             if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
348                 self.deferred_sql.remove(sql)
349 
350     def add_index(self, model, index):
351         """Add an index on a model."""
352         self.execute(index.create_sql(model, self), params=None)
353 
354     def remove_index(self, model, index):
355         """Remove an index from a model."""
356         self.execute(index.remove_sql(model, self))
357 
358     def add_constraint(self, model, constraint):
359         """Add a constraint to a model."""
360         sql = constraint.create_sql(model, self)
361         if sql:
362             self.execute(sql)
363 
364     def remove_constraint(self, model, constraint):
365         """Remove a constraint from a model."""
366         sql = constraint.remove_sql(model, self)
367         if sql:
368             self.execute(sql)
369 
370     def alter_unique_together(self, model, old_unique_together, new_unique_together):
371         """
372         Deal with a model changing its unique_together. The input
373         unique_togethers must be doubly-nested, not the single-nested
374         ["foo", "bar"] format.
375         """
376         olds = {tuple(fields) for fields in old_unique_together}
377         news = {tuple(fields) for fields in new_unique_together}
378         # Deleted uniques
379         for fields in olds.difference(news):
380             self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)
381         # Created uniques
382         for fields in news.difference(olds):
383             columns = [model._meta.get_field(field).column for field in fields]
384             self.execute(self._create_unique_sql(model, columns))
385 
386     def alter_index_together(self, model, old_index_together, new_index_together):
387         """
388         Deal with a model changing its index_together. The input
389         index_togethers must be doubly-nested, not the single-nested
390         ["foo", "bar"] format.
391         """
392         olds = {tuple(fields) for fields in old_index_together}
393         news = {tuple(fields) for fields in new_index_together}
394         # Deleted indexes
395         for fields in olds.difference(news):
396             self._delete_composed_index(
397                 model,
398                 fields,
399                 {'index': True, 'unique': False},
400                 self.sql_delete_index,
401             )
402         # Created indexes
403         for field_names in news.difference(olds):
404             fields = [model._meta.get_field(field) for field in field_names]
405             self.execute(self._create_index_sql(model, fields, suffix="_idx"))
406 
407     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):
408         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
409         meta_index_names = {constraint.name for constraint in model._meta.indexes}
410         columns = [model._meta.get_field(field).column for field in fields]
411         constraint_names = self._constraint_names(
412             model, columns, exclude=meta_constraint_names | meta_index_names,
413             **constraint_kwargs
414         )
415         if len(constraint_names) != 1:
416             raise ValueError("Found wrong number (%s) of constraints for %s(%s)" % (
417                 len(constraint_names),
418                 model._meta.db_table,
419                 ", ".join(columns),
420             ))
421         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))
422 
423     def alter_db_table(self, model, old_db_table, new_db_table):
424         """Rename the table a model points to."""
425         if (old_db_table == new_db_table or
426             (self.connection.features.ignores_table_name_case and
427                 old_db_table.lower() == new_db_table.lower())):
428             return
429         self.execute(self.sql_rename_table % {
430             "old_table": self.quote_name(old_db_table),
431             "new_table": self.quote_name(new_db_table),
432         })
433         # Rename all references to the old table name.
434         for sql in self.deferred_sql:
435             if isinstance(sql, Statement):
436                 sql.rename_table_references(old_db_table, new_db_table)
437 
438     def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):
439         """Move a model's table between tablespaces."""
440         self.execute(self.sql_retablespace_table % {
441             "table": self.quote_name(model._meta.db_table),
442             "old_tablespace": self.quote_name(old_db_tablespace),
443             "new_tablespace": self.quote_name(new_db_tablespace),
444         })
445 
446     def add_field(self, model, field):
447         """
448         Create a field on a model. Usually involves adding a column, but may
449         involve adding a table instead (for M2M fields).
450         """
451         # Special-case implicit M2M tables
452         if field.many_to_many and field.remote_field.through._meta.auto_created:
453             return self.create_model(field.remote_field.through)
454         # Get the column's definition
455         definition, params = self.column_sql(model, field, include_default=True)
456         # It might not actually have a column behind it
457         if definition is None:
458             return
459         # Check constraints can go on the column SQL here
460         db_params = field.db_parameters(connection=self.connection)
461         if db_params['check']:
462             definition += " " + self.sql_check_constraint % db_params
463         if field.remote_field and self.connection.features.supports_foreign_keys and field.db_constraint:
464             constraint_suffix = '_fk_%(to_table)s_%(to_column)s'
465             # Add FK constraint inline, if supported.
466             if self.sql_create_column_inline_fk:
467                 to_table = field.remote_field.model._meta.db_table
468                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
469                 definition += " " + self.sql_create_column_inline_fk % {
470                     'name': self._fk_constraint_name(model, field, constraint_suffix),
471                     'column': self.quote_name(field.column),
472                     'to_table': self.quote_name(to_table),
473                     'to_column': self.quote_name(to_column),
474                     'deferrable': self.connection.ops.deferrable_sql()
475                 }
476             # Otherwise, add FK constraints later.
477             else:
478                 self.deferred_sql.append(self._create_fk_sql(model, field, constraint_suffix))
479         # Build the SQL and run it
480         sql = self.sql_create_column % {
481             "table": self.quote_name(model._meta.db_table),
482             "column": self.quote_name(field.column),
483             "definition": definition,
484         }
485         self.execute(sql, params)
486         # Drop the default if we need to
487         # (Django usually does not use in-database defaults)
488         if not self.skip_default(field) and self.effective_default(field) is not None:
489             changes_sql, params = self._alter_column_default_sql(model, None, field, drop=True)
490             sql = self.sql_alter_column % {
491                 "table": self.quote_name(model._meta.db_table),
492                 "changes": changes_sql,
493             }
494             self.execute(sql, params)
495         # Add an index, if required
496         self.deferred_sql.extend(self._field_indexes_sql(model, field))
497         # Reset connection if required
498         if self.connection.features.connection_persists_old_columns:
499             self.connection.close()
500 
501     def remove_field(self, model, field):
502         """
503         Remove a field from a model. Usually involves deleting a column,
504         but for M2Ms may involve deleting a table.
505         """
506         # Special-case implicit M2M tables
507         if field.many_to_many and field.remote_field.through._meta.auto_created:
508             return self.delete_model(field.remote_field.through)
509         # It might not actually have a column behind it
510         if field.db_parameters(connection=self.connection)['type'] is None:
511             return
512         # Drop any FK constraints, MySQL requires explicit deletion
513         if field.remote_field:
514             fk_names = self._constraint_names(model, [field.column], foreign_key=True)
515             for fk_name in fk_names:
516                 self.execute(self._delete_fk_sql(model, fk_name))
517         # Delete the column
518         sql = self.sql_delete_column % {
519             "table": self.quote_name(model._meta.db_table),
520             "column": self.quote_name(field.column),
521         }
522         self.execute(sql)
523         # Reset connection if required
524         if self.connection.features.connection_persists_old_columns:
525             self.connection.close()
526         # Remove all deferred statements referencing the deleted column.
527         for sql in list(self.deferred_sql):
528             if isinstance(sql, Statement) and sql.references_column(model._meta.db_table, field.column):
529                 self.deferred_sql.remove(sql)
530 
531     def alter_field(self, model, old_field, new_field, strict=False):
532         """
533         Allow a field's type, uniqueness, nullability, default, column,
534         constraints, etc. to be modified.
535         `old_field` is required to compute the necessary changes.
536         If `strict` is True, raise errors if the old column does not match
537         `old_field` precisely.
538         """
539         # Ensure this field is even column-based
540         old_db_params = old_field.db_parameters(connection=self.connection)
541         old_type = old_db_params['type']
542         new_db_params = new_field.db_parameters(connection=self.connection)
543         new_type = new_db_params['type']
544         if ((old_type is None and old_field.remote_field is None) or
545                 (new_type is None and new_field.remote_field is None)):
546             raise ValueError(
547                 "Cannot alter field %s into %s - they do not properly define "
548                 "db_type (are you using a badly-written custom field?)" %
549                 (old_field, new_field),
550             )
551         elif old_type is None and new_type is None and (
552                 old_field.remote_field.through and new_field.remote_field.through and
553                 old_field.remote_field.through._meta.auto_created and
554                 new_field.remote_field.through._meta.auto_created):
555             return self._alter_many_to_many(model, old_field, new_field, strict)
556         elif old_type is None and new_type is None and (
557                 old_field.remote_field.through and new_field.remote_field.through and
558                 not old_field.remote_field.through._meta.auto_created and
559                 not new_field.remote_field.through._meta.auto_created):
560             # Both sides have through models; this is a no-op.
561             return
562         elif old_type is None or new_type is None:
563             raise ValueError(
564                 "Cannot alter field %s into %s - they are not compatible types "
565                 "(you cannot alter to or from M2M fields, or add or remove "
566                 "through= on M2M fields)" % (old_field, new_field)
567             )
568 
569         self._alter_field(model, old_field, new_field, old_type, new_type,
570                           old_db_params, new_db_params, strict)
571 
572     def _alter_field(self, model, old_field, new_field, old_type, new_type,
573                      old_db_params, new_db_params, strict=False):
574         """Perform a "physical" (non-ManyToMany) field update."""
575         # Drop any FK constraints, we'll remake them later
576         fks_dropped = set()
577         if (
578             self.connection.features.supports_foreign_keys and
579             old_field.remote_field and
580             old_field.db_constraint
581         ):
582             fk_names = self._constraint_names(model, [old_field.column], foreign_key=True)
583             if strict and len(fk_names) != 1:
584                 raise ValueError("Found wrong number (%s) of foreign key constraints for %s.%s" % (
585                     len(fk_names),
586                     model._meta.db_table,
587                     old_field.column,
588                 ))
589             for fk_name in fk_names:
590                 fks_dropped.add((old_field.column,))
591                 self.execute(self._delete_fk_sql(model, fk_name))
592         # Has unique been removed?
593         if old_field.unique and (not new_field.unique or self._field_became_primary_key(old_field, new_field)):
594             # Find the unique constraint for this field
595             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
596             constraint_names = self._constraint_names(
597                 model, [old_field.column], unique=True, primary_key=False,
598                 exclude=meta_constraint_names,
599             )
600             if strict and len(constraint_names) != 1:
601                 raise ValueError("Found wrong number (%s) of unique constraints for %s.%s" % (
602                     len(constraint_names),
603                     model._meta.db_table,
604                     old_field.column,
605                 ))
606             for constraint_name in constraint_names:
607                 self.execute(self._delete_unique_sql(model, constraint_name))
608         # Drop incoming FK constraints if the field is a primary key or unique,
609         # which might be a to_field target, and things are going to change.
610         drop_foreign_keys = (
611             self.connection.features.supports_foreign_keys and (
612                 (old_field.primary_key and new_field.primary_key) or
613                 (old_field.unique and new_field.unique)
614             ) and old_type != new_type
615         )
616         if drop_foreign_keys:
617             # '_meta.related_field' also contains M2M reverse fields, these
618             # will be filtered out
619             for _old_rel, new_rel in _related_non_m2m_objects(old_field, new_field):
620                 rel_fk_names = self._constraint_names(
621                     new_rel.related_model, [new_rel.field.column], foreign_key=True
622                 )
623                 for fk_name in rel_fk_names:
624                     self.execute(self._delete_fk_sql(new_rel.related_model, fk_name))
625         # Removed an index? (no strict check, as multiple indexes are possible)
626         # Remove indexes if db_index switched to False or a unique constraint
627         # will now be used in lieu of an index. The following lines from the
628         # truth table show all True cases; the rest are False:
629         #
630         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
631         # ------------------------------------------------------------------------------
632         # True               | False            | False              | False
633         # True               | False            | False              | True
634         # True               | False            | True               | True
635         if old_field.db_index and not old_field.unique and (not new_field.db_index or new_field.unique):
636             # Find the index for this field
637             meta_index_names = {index.name for index in model._meta.indexes}
638             # Retrieve only BTREE indexes since this is what's created with
639             # db_index=True.
640             index_names = self._constraint_names(
641                 model, [old_field.column], index=True, type_=Index.suffix,
642                 exclude=meta_index_names,
643             )
644             for index_name in index_names:
645                 # The only way to check if an index was created with
646                 # db_index=True or with Index(['field'], name='foo')
647                 # is to look at its name (refs #28053).
648                 self.execute(self._delete_index_sql(model, index_name))
649         # Change check constraints?
650         if old_db_params['check'] != new_db_params['check'] and old_db_params['check']:
651             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
652             constraint_names = self._constraint_names(
653                 model, [old_field.column], check=True,
654                 exclude=meta_constraint_names,
655             )
656             if strict and len(constraint_names) != 1:
657                 raise ValueError("Found wrong number (%s) of check constraints for %s.%s" % (
658                     len(constraint_names),
659                     model._meta.db_table,
660                     old_field.column,
661                 ))
662             for constraint_name in constraint_names:
663                 self.execute(self._delete_check_sql(model, constraint_name))
664         # Have they renamed the column?
665         if old_field.column != new_field.column:
666             self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
667             # Rename all references to the renamed column.
668             for sql in self.deferred_sql:
669                 if isinstance(sql, Statement):
670                     sql.rename_column_references(model._meta.db_table, old_field.column, new_field.column)
671         # Next, start accumulating actions to do
672         actions = []
673         null_actions = []
674         post_actions = []
675         # Type change?
676         if old_type != new_type:
677             fragment, other_actions = self._alter_column_type_sql(model, old_field, new_field, new_type)
678             actions.append(fragment)
679             post_actions.extend(other_actions)
680         # When changing a column NULL constraint to NOT NULL with a given
681         # default value, we need to perform 4 steps:
682         #  1. Add a default for new incoming writes
683         #  2. Update existing NULL rows with new default
684         #  3. Replace NULL constraint with NOT NULL
685         #  4. Drop the default again.
686         # Default change?
687         needs_database_default = False
688         if old_field.null and not new_field.null:
689             old_default = self.effective_default(old_field)
690             new_default = self.effective_default(new_field)
691             if (
692                 not self.skip_default(new_field) and
693                 old_default != new_default and
694                 new_default is not None
695             ):
696                 needs_database_default = True
697                 actions.append(self._alter_column_default_sql(model, old_field, new_field))
698         # Nullability change?
699         if old_field.null != new_field.null:
700             fragment = self._alter_column_null_sql(model, old_field, new_field)
701             if fragment:
702                 null_actions.append(fragment)
703         # Only if we have a default and there is a change from NULL to NOT NULL
704         four_way_default_alteration = (
705             new_field.has_default() and
706             (old_field.null and not new_field.null)
707         )
708         if actions or null_actions:
709             if not four_way_default_alteration:
710                 # If we don't have to do a 4-way default alteration we can
711                 # directly run a (NOT) NULL alteration
712                 actions = actions + null_actions
713             # Combine actions together if we can (e.g. postgres)
714             if self.connection.features.supports_combined_alters and actions:
715                 sql, params = tuple(zip(*actions))
716                 actions = [(", ".join(sql), sum(params, []))]
717             # Apply those actions
718             for sql, params in actions:
719                 self.execute(
720                     self.sql_alter_column % {
721                         "table": self.quote_name(model._meta.db_table),
722                         "changes": sql,
723                     },
724                     params,
725                 )
726             if four_way_default_alteration:
727                 # Update existing rows with default value
728                 self.execute(
729                     self.sql_update_with_default % {
730                         "table": self.quote_name(model._meta.db_table),
731                         "column": self.quote_name(new_field.column),
732                         "default": "%s",
733                     },
734                     [new_default],
735                 )
736                 # Since we didn't run a NOT NULL change before we need to do it
737                 # now
738                 for sql, params in null_actions:
739                     self.execute(
740                         self.sql_alter_column % {
741                             "table": self.quote_name(model._meta.db_table),
742                             "changes": sql,
743                         },
744                         params,
745                     )
746         if post_actions:
747             for sql, params in post_actions:
748                 self.execute(sql, params)
749         # If primary_key changed to False, delete the primary key constraint.
750         if old_field.primary_key and not new_field.primary_key:
751             self._delete_primary_key(model, strict)
752         # Added a unique?
753         if self._unique_should_be_added(old_field, new_field):
754             self.execute(self._create_unique_sql(model, [new_field.column]))
755         # Added an index? Add an index if db_index switched to True or a unique
756         # constraint will no longer be used in lieu of an index. The following
757         # lines from the truth table show all True cases; the rest are False:
758         #
759         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
760         # ------------------------------------------------------------------------------
761         # False              | False            | True               | False
762         # False              | True             | True               | False
763         # True               | True             | True               | False
764         if (not old_field.db_index or old_field.unique) and new_field.db_index and not new_field.unique:
765             self.execute(self._create_index_sql(model, [new_field]))
766         # Type alteration on primary key? Then we need to alter the column
767         # referring to us.
768         rels_to_update = []
769         if drop_foreign_keys:
770             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
771         # Changed to become primary key?
772         if self._field_became_primary_key(old_field, new_field):
773             # Make the new one
774             self.execute(self._create_primary_key_sql(model, new_field))
775             # Update all referencing columns
776             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
777         # Handle our type alters on the other end of rels from the PK stuff above
778         for old_rel, new_rel in rels_to_update:
779             rel_db_params = new_rel.field.db_parameters(connection=self.connection)
780             rel_type = rel_db_params['type']
781             fragment, other_actions = self._alter_column_type_sql(
782                 new_rel.related_model, old_rel.field, new_rel.field, rel_type
783             )
784             self.execute(
785                 self.sql_alter_column % {
786                     "table": self.quote_name(new_rel.related_model._meta.db_table),
787                     "changes": fragment[0],
788                 },
789                 fragment[1],
790             )
791             for sql, params in other_actions:
792                 self.execute(sql, params)
793         # Does it have a foreign key?
794         if (self.connection.features.supports_foreign_keys and new_field.remote_field and
795                 (fks_dropped or not old_field.remote_field or not old_field.db_constraint) and
796                 new_field.db_constraint):
797             self.execute(self._create_fk_sql(model, new_field, "_fk_%(to_table)s_%(to_column)s"))
798         # Rebuild FKs that pointed to us if we previously had to drop them
799         if drop_foreign_keys:
800             for rel in new_field.model._meta.related_objects:
801                 if _is_relevant_relation(rel, new_field) and rel.field.db_constraint:
802                     self.execute(self._create_fk_sql(rel.related_model, rel.field, "_fk"))
803         # Does it have check constraints we need to add?
804         if old_db_params['check'] != new_db_params['check'] and new_db_params['check']:
805             constraint_name = self._create_index_name(model._meta.db_table, [new_field.column], suffix='_check')
806             self.execute(self._create_check_sql(model, constraint_name, new_db_params['check']))
807         # Drop the default if we need to
808         # (Django usually does not use in-database defaults)
809         if needs_database_default:
810             changes_sql, params = self._alter_column_default_sql(model, old_field, new_field, drop=True)
811             sql = self.sql_alter_column % {
812                 "table": self.quote_name(model._meta.db_table),
813                 "changes": changes_sql,
814             }
815             self.execute(sql, params)
816         # Reset connection if required
817         if self.connection.features.connection_persists_old_columns:
818             self.connection.close()
819 
820     def _alter_column_null_sql(self, model, old_field, new_field):
821         """
822         Hook to specialize column null alteration.
823 
824         Return a (sql, params) fragment to set a column to null or non-null
825         as required by new_field, or None if no changes are required.
826         """
827         if (self.connection.features.interprets_empty_strings_as_nulls and
828                 new_field.get_internal_type() in ("CharField", "TextField")):
829             # The field is nullable in the database anyway, leave it alone.
830             return
831         else:
832             new_db_params = new_field.db_parameters(connection=self.connection)
833             sql = self.sql_alter_column_null if new_field.null else self.sql_alter_column_not_null
834             return (
835                 sql % {
836                     'column': self.quote_name(new_field.column),
837                     'type': new_db_params['type'],
838                 },
839                 [],
840             )
841 
842     def _alter_column_default_sql(self, model, old_field, new_field, drop=False):
843         """
844         Hook to specialize column default alteration.
845 
846         Return a (sql, params) fragment to add or drop (depending on the drop
847         argument) a default to new_field's column.
848         """
849         new_default = self.effective_default(new_field)
850         default = self._column_default_sql(new_field)
851         params = [new_default]
852 
853         if drop:
854             params = []
855         elif self.connection.features.requires_literal_defaults:
856             # Some databases (Oracle) can't take defaults as a parameter
857             # If this is the case, the SchemaEditor for that database should
858             # implement prepare_default().
859             default = self.prepare_default(new_default)
860             params = []
861 
862         new_db_params = new_field.db_parameters(connection=self.connection)
863         sql = self.sql_alter_column_no_default if drop else self.sql_alter_column_default
864         return (
865             sql % {
866                 'column': self.quote_name(new_field.column),
867                 'type': new_db_params['type'],
868                 'default': default,
869             },
870             params,
871         )
872 
873     def _alter_column_type_sql(self, model, old_field, new_field, new_type):
874         """
875         Hook to specialize column type alteration for different backends,
876         for cases when a creation type is different to an alteration type
877         (e.g. SERIAL in PostgreSQL, PostGIS fields).
878 
879         Return a two-tuple of: an SQL fragment of (sql, params) to insert into
880         an ALTER TABLE statement and a list of extra (sql, params) tuples to
881         run once the field is altered.
882         """
883         return (
884             (
885                 self.sql_alter_column_type % {
886                     "column": self.quote_name(new_field.column),
887                     "type": new_type,
888                 },
889                 [],
890             ),
891             [],
892         )
893 
894     def _alter_many_to_many(self, model, old_field, new_field, strict):
895         """Alter M2Ms to repoint their to= endpoints."""
896         # Rename the through table
897         if old_field.remote_field.through._meta.db_table != new_field.remote_field.through._meta.db_table:
898             self.alter_db_table(old_field.remote_field.through, old_field.remote_field.through._meta.db_table,
899                                 new_field.remote_field.through._meta.db_table)
900         # Repoint the FK to the other side
901         self.alter_field(
902             new_field.remote_field.through,
903             # We need the field that points to the target model, so we can tell alter_field to change it -
904             # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
905             old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
906             new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
907         )
908         self.alter_field(
909             new_field.remote_field.through,
910             # for self-referential models we need to alter field from the other end too
911             old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),
912             new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),
913         )
914 
915     def _create_index_name(self, table_name, column_names, suffix=""):
916         """
917         Generate a unique name for an index/unique constraint.
918 
919         The name is divided into 3 parts: the table name, the column names,
920         and a unique digest and suffix.
921         """
922         _, table_name = split_identifier(table_name)
923         hash_suffix_part = '%s%s' % (names_digest(table_name, *column_names, length=8), suffix)
924         max_length = self.connection.ops.max_name_length() or 200
925         # If everything fits into max_length, use that name.
926         index_name = '%s_%s_%s' % (table_name, '_'.join(column_names), hash_suffix_part)
927         if len(index_name) <= max_length:
928             return index_name
929         # Shorten a long suffix.
930         if len(hash_suffix_part) > max_length / 3:
931             hash_suffix_part = hash_suffix_part[:max_length // 3]
932         other_length = (max_length - len(hash_suffix_part)) // 2 - 1
933         index_name = '%s_%s_%s' % (
934             table_name[:other_length],
935             '_'.join(column_names)[:other_length],
936             hash_suffix_part,
937         )
938         # Prepend D if needed to prevent the name from starting with an
939         # underscore or a number (not permitted on Oracle).
940         if index_name[0] == "_" or index_name[0].isdigit():
941             index_name = "D%s" % index_name[:-1]
942         return index_name
943 
944     def _get_index_tablespace_sql(self, model, fields, db_tablespace=None):
945         if db_tablespace is None:
946             if len(fields) == 1 and fields[0].db_tablespace:
947                 db_tablespace = fields[0].db_tablespace
948             elif model._meta.db_tablespace:
949                 db_tablespace = model._meta.db_tablespace
950         if db_tablespace is not None:
951             return ' ' + self.connection.ops.tablespace_sql(db_tablespace)
952         return ''
953 
954     def _index_condition_sql(self, condition):
955         if condition:
956             return ' WHERE ' + condition
957         return ''
958 
959     def _create_index_sql(self, model, fields, *, name=None, suffix='', using='',
960                           db_tablespace=None, col_suffixes=(), sql=None, opclasses=(),
961                           condition=None):
962         """
963         Return the SQL statement to create the index for one or several fields.
964         `sql` can be specified if the syntax differs from the standard (GIS
965         indexes, ...).
966         """
967         tablespace_sql = self._get_index_tablespace_sql(model, fields, db_tablespace=db_tablespace)
968         columns = [field.column for field in fields]
969         sql_create_index = sql or self.sql_create_index
970         table = model._meta.db_table
971 
972         def create_index_name(*args, **kwargs):
973             nonlocal name
974             if name is None:
975                 name = self._create_index_name(*args, **kwargs)
976             return self.quote_name(name)
977 
978         return Statement(
979             sql_create_index,
980             table=Table(table, self.quote_name),
981             name=IndexName(table, columns, suffix, create_index_name),
982             using=using,
983             columns=self._index_columns(table, columns, col_suffixes, opclasses),
984             extra=tablespace_sql,
985             condition=self._index_condition_sql(condition),
986         )
987 
988     def _delete_index_sql(self, model, name, sql=None):
989         return Statement(
990             sql or self.sql_delete_index,
991             table=Table(model._meta.db_table, self.quote_name),
992             name=self.quote_name(name),
993         )
994 
995     def _index_columns(self, table, columns, col_suffixes, opclasses):
996         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
997 
998     def _model_indexes_sql(self, model):
999         """
1000         Return a list of all index SQL statements (field indexes,
1001         index_together, Meta.indexes) for the specified model.
1002         """
1003         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
1004             return []
1005         output = []
1006         for field in model._meta.local_fields:
1007             output.extend(self._field_indexes_sql(model, field))
1008 
1009         for field_names in model._meta.index_together:
1010             fields = [model._meta.get_field(field) for field in field_names]
1011             output.append(self._create_index_sql(model, fields, suffix="_idx"))
1012 
1013         for index in model._meta.indexes:
1014             output.append(index.create_sql(model, self))
1015         return output
1016 
1017     def _field_indexes_sql(self, model, field):
1018         """
1019         Return a list of all index SQL statements for the specified field.
1020         """
1021         output = []
1022         if self._field_should_be_indexed(model, field):
1023             output.append(self._create_index_sql(model, [field]))
1024         return output
1025 
1026     def _field_should_be_indexed(self, model, field):
1027         return field.db_index and not field.unique
1028 
1029     def _field_became_primary_key(self, old_field, new_field):
1030         return not old_field.primary_key and new_field.primary_key
1031 
1032     def _unique_should_be_added(self, old_field, new_field):
1033         return (not old_field.unique and new_field.unique) or (
1034             old_field.primary_key and not new_field.primary_key and new_field.unique
1035         )
1036 
1037     def _rename_field_sql(self, table, old_field, new_field, new_type):
1038         return self.sql_rename_column % {
1039             "table": self.quote_name(table),
1040             "old_column": self.quote_name(old_field.column),
1041             "new_column": self.quote_name(new_field.column),
1042             "type": new_type,
1043         }
1044 
1045     def _create_fk_sql(self, model, field, suffix):
1046         table = Table(model._meta.db_table, self.quote_name)
1047         name = self._fk_constraint_name(model, field, suffix)
1048         column = Columns(model._meta.db_table, [field.column], self.quote_name)
1049         to_table = Table(field.target_field.model._meta.db_table, self.quote_name)
1050         to_column = Columns(field.target_field.model._meta.db_table, [field.target_field.column], self.quote_name)
1051         deferrable = self.connection.ops.deferrable_sql()
1052         return Statement(
1053             self.sql_create_fk,
1054             table=table,
1055             name=name,
1056             column=column,
1057             to_table=to_table,
1058             to_column=to_column,
1059             deferrable=deferrable,
1060         )
1061 
1062     def _fk_constraint_name(self, model, field, suffix):
1063         def create_fk_name(*args, **kwargs):
1064             return self.quote_name(self._create_index_name(*args, **kwargs))
1065 
1066         return ForeignKeyName(
1067             model._meta.db_table,
1068             [field.column],
1069             split_identifier(field.target_field.model._meta.db_table)[1],
1070             [field.target_field.column],
1071             suffix,
1072             create_fk_name,
1073         )
1074 
1075     def _delete_fk_sql(self, model, name):
1076         return self._delete_constraint_sql(self.sql_delete_fk, model, name)
1077 
1078     def _deferrable_constraint_sql(self, deferrable):
1079         if deferrable is None:
1080             return ''
1081         if deferrable == Deferrable.DEFERRED:
1082             return ' DEFERRABLE INITIALLY DEFERRED'
1083         if deferrable == Deferrable.IMMEDIATE:
1084             return ' DEFERRABLE INITIALLY IMMEDIATE'
1085 
1086     def _unique_sql(self, model, fields, name, condition=None, deferrable=None):
1087         if (
1088             deferrable and
1089             not self.connection.features.supports_deferrable_unique_constraints
1090         ):
1091             return None
1092         if condition:
1093             # Databases support conditional unique constraints via a unique
1094             # index.
1095             sql = self._create_unique_sql(model, fields, name=name, condition=condition)
1096             if sql:
1097                 self.deferred_sql.append(sql)
1098             return None
1099         constraint = self.sql_unique_constraint % {
1100             'columns': ', '.join(map(self.quote_name, fields)),
1101             'deferrable': self._deferrable_constraint_sql(deferrable),
1102         }
1103         return self.sql_constraint % {
1104             'name': self.quote_name(name),
1105             'constraint': constraint,
1106         }
1107 
1108     def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None):
1109         if (
1110             deferrable and
1111             not self.connection.features.supports_deferrable_unique_constraints
1112         ):
1113             return None
1114 
1115         def create_unique_name(*args, **kwargs):
1116             return self.quote_name(self._create_index_name(*args, **kwargs))
1117 
1118         table = Table(model._meta.db_table, self.quote_name)
1119         if name is None:
1120             name = IndexName(model._meta.db_table, columns, '_uniq', create_unique_name)
1121         else:
1122             name = self.quote_name(name)
1123         columns = Columns(table, columns, self.quote_name)
1124         if condition:
1125             if not self.connection.features.supports_partial_indexes:
1126                 return None
1127             sql = self.sql_create_unique_index
1128         else:
1129             sql = self.sql_create_unique
1130         return Statement(
1131             sql,
1132             table=table,
1133             name=name,
1134             columns=columns,
1135             condition=self._index_condition_sql(condition),
1136             deferrable=self._deferrable_constraint_sql(deferrable),
1137         )
1138 
1139     def _delete_unique_sql(self, model, name, condition=None, deferrable=None):
1140         if (
1141             deferrable and
1142             not self.connection.features.supports_deferrable_unique_constraints
1143         ):
1144             return None
1145         if condition:
1146             return (
1147                 self._delete_constraint_sql(self.sql_delete_index, model, name)
1148                 if self.connection.features.supports_partial_indexes else None
1149             )
1150         return self._delete_constraint_sql(self.sql_delete_unique, model, name)
1151 
1152     def _check_sql(self, name, check):
1153         return self.sql_constraint % {
1154             'name': self.quote_name(name),
1155             'constraint': self.sql_check_constraint % {'check': check},
1156         }
1157 
1158     def _create_check_sql(self, model, name, check):
1159         return Statement(
1160             self.sql_create_check,
1161             table=Table(model._meta.db_table, self.quote_name),
1162             name=self.quote_name(name),
1163             check=check,
1164         )
1165 
1166     def _delete_check_sql(self, model, name):
1167         return self._delete_constraint_sql(self.sql_delete_check, model, name)
1168 
1169     def _delete_constraint_sql(self, template, model, name):
1170         return Statement(
1171             template,
1172             table=Table(model._meta.db_table, self.quote_name),
1173             name=self.quote_name(name),
1174         )
1175 
1176     def _constraint_names(self, model, column_names=None, unique=None,
1177                           primary_key=None, index=None, foreign_key=None,
1178                           check=None, type_=None, exclude=None):
1179         """Return all constraint names matching the columns and conditions."""
1180         if column_names is not None:
1181             column_names = [
1182                 self.connection.introspection.identifier_converter(name)
1183                 for name in column_names
1184             ]
1185         with self.connection.cursor() as cursor:
1186             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)
1187         result = []
1188         for name, infodict in constraints.items():
1189             if column_names is None or column_names == infodict['columns']:
1190                 if unique is not None and infodict['unique'] != unique:
1191                     continue
1192                 if primary_key is not None and infodict['primary_key'] != primary_key:
1193                     continue
1194                 if index is not None and infodict['index'] != index:
1195                     continue
1196                 if check is not None and infodict['check'] != check:
1197                     continue
1198                 if foreign_key is not None and not infodict['foreign_key']:
1199                     continue
1200                 if type_ is not None and infodict['type'] != type_:
1201                     continue
1202                 if not exclude or name not in exclude:
1203                     result.append(name)
1204         return result
1205 
1206     def _delete_primary_key(self, model, strict=False):
1207         constraint_names = self._constraint_names(model, primary_key=True)
1208         if strict and len(constraint_names) != 1:
1209             raise ValueError('Found wrong number (%s) of PK constraints for %s' % (
1210                 len(constraint_names),
1211                 model._meta.db_table,
1212             ))
1213         for constraint_name in constraint_names:
1214             self.execute(self._delete_primary_key_sql(model, constraint_name))
1215 
1216     def _create_primary_key_sql(self, model, field):
1217         return Statement(
1218             self.sql_create_pk,
1219             table=Table(model._meta.db_table, self.quote_name),
1220             name=self.quote_name(
1221                 self._create_index_name(model._meta.db_table, [field.column], suffix="_pk")
1222             ),
1223             columns=Columns(model._meta.db_table, [field.column], self.quote_name),
1224         )
1225 
1226     def _delete_primary_key_sql(self, model, name):
1227         return self._delete_constraint_sql(self.sql_delete_pk, model, name)
1228 
1229     def remove_procedure(self, procedure_name, param_types=()):
1230         sql = self.sql_delete_procedure % {
1231             'procedure': self.quote_name(procedure_name),
1232             'param_types': ','.join(param_types),
1233         }
1234         self.execute(sql)

</code><intended_behavior>Since backend-specific implementations might be needed to support the `INCLUDE` clause across different databases, review and possibly extend methods like `add_index` and `add_constraint` to handle the `include` kwarg. This involves ensuring that SQL generation respects the `include` kwarg if provided and the database backend supports it.</intended_behavior>]
2025-10-17 11:44:11.218 | INFO     | Search completed. Bug locations: [<file>django/db/models/indexes.py</file>
<class>Index</class>
<method>None</method>
<code>
8 class Index:
9     suffix = 'idx'
10     # The max length of the name of the index (restricted to 30 for
11     # cross-database compatibility with Oracle)
12     max_name_length = 30
13 
14     def __init__(self, *, fields=(), name=None, db_tablespace=None, opclasses=(), condition=None):
15         if opclasses and not name:
16             raise ValueError('An index must be named to use opclasses.')
17         if not isinstance(condition, (type(None), Q)):
18             raise ValueError('Index.condition must be a Q instance.')
19         if condition and not name:
20             raise ValueError('An index must be named to use condition.')
21         if not isinstance(fields, (list, tuple)):
22             raise ValueError('Index.fields must be a list or tuple.')
23         if not isinstance(opclasses, (list, tuple)):
24             raise ValueError('Index.opclasses must be a list or tuple.')
25         if opclasses and len(fields) != len(opclasses):
26             raise ValueError('Index.fields and Index.opclasses must have the same number of elements.')
27         if not fields:
28             raise ValueError('At least one field is required to define an index.')
29         self.fields = list(fields)
30         # A list of 2-tuple with the field name and ordering ('' or 'DESC').
31         self.fields_orders = [
32             (field_name[1:], 'DESC') if field_name.startswith('-') else (field_name, '')
33             for field_name in self.fields
34         ]
35         self.name = name or ''
36         self.db_tablespace = db_tablespace
37         self.opclasses = opclasses
38         self.condition = condition
39 
40     def _get_condition_sql(self, model, schema_editor):
41         if self.condition is None:
42             return None
43         query = Query(model=model, alias_cols=False)
44         where = query.build_where(self.condition)
45         compiler = query.get_compiler(connection=schema_editor.connection)
46         sql, params = where.as_sql(compiler, schema_editor.connection)
47         return sql % tuple(schema_editor.quote_value(p) for p in params)
48 
49     def create_sql(self, model, schema_editor, using='', **kwargs):
50         fields = [model._meta.get_field(field_name) for field_name, _ in self.fields_orders]
51         col_suffixes = [order[1] for order in self.fields_orders]
52         condition = self._get_condition_sql(model, schema_editor)
53         return schema_editor._create_index_sql(
54             model, fields, name=self.name, using=using, db_tablespace=self.db_tablespace,
55             col_suffixes=col_suffixes, opclasses=self.opclasses, condition=condition,
56             **kwargs,
57         )
58 
59     def remove_sql(self, model, schema_editor, **kwargs):
60         return schema_editor._delete_index_sql(model, self.name, **kwargs)
61 
62     def deconstruct(self):
63         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)
64         path = path.replace('django.db.models.indexes', 'django.db.models')
65         kwargs = {'fields': self.fields, 'name': self.name}
66         if self.db_tablespace is not None:
67             kwargs['db_tablespace'] = self.db_tablespace
68         if self.opclasses:
69             kwargs['opclasses'] = self.opclasses
70         if self.condition:
71             kwargs['condition'] = self.condition
72         return (path, (), kwargs)
73 
74     def clone(self):
75         """Create a copy of this Index."""
76         _, _, kwargs = self.deconstruct()
77         return self.__class__(**kwargs)
78 
79     def set_name_with_model(self, model):
80         """
81         Generate a unique name for the index.
82 
83         The name is divided into 3 parts - table name (12 chars), field name
84         (8 chars) and unique hash + suffix (10 chars). Each part is made to
85         fit its size by truncating the excess length.
86         """
87         _, table_name = split_identifier(model._meta.db_table)
88         column_names = [model._meta.get_field(field_name).column for field_name, order in self.fields_orders]
89         column_names_with_order = [
90             (('-%s' if order else '%s') % column_name)
91             for column_name, (field_name, order) in zip(column_names, self.fields_orders)
92         ]
93         # The length of the parts of the name is based on the default max
94         # length of 30 characters.
95         hash_data = [table_name] + column_names_with_order + [self.suffix]
96         self.name = '%s_%s_%s' % (
97             table_name[:11],
98             column_names[0][:7],
99             '%s_%s' % (names_digest(*hash_data, length=6), self.suffix),
100         )
101         assert len(self.name) <= self.max_name_length, (
102             'Index too long for multiple database support. Is self.suffix '
103             'longer than 3 characters?'
104         )
105         if self.name[0] == '_' or self.name[0].isdigit():
106             self.name = 'D%s' % self.name[1:]
107 
108     def __repr__(self):
109         return "<%s: fields='%s'%s>" % (
110             self.__class__.__name__, ', '.join(self.fields),
111             '' if self.condition is None else ', condition=%s' % self.condition,
112         )
113 
114     def __eq__(self, other):
115         if self.__class__ == other.__class__:
116             return self.deconstruct() == other.deconstruct()
117         return NotImplemented

</code><intended_behavior>Modify or extend the `__init__`, `create_sql`, and possibly `deconstruct` methods to support an `include` kwarg. This kwarg should list the fields to be included in the index but not used as keys. The `create_sql` method must be adapted to append an `INCLUDE` clause with the fields specified by `include` when generating the SQL for databases that support this feature.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>UniqueConstraint</class>
<method>None</method>
<code>
79 class UniqueConstraint(BaseConstraint):
80     def __init__(self, *, fields, name, condition=None, deferrable=None):
81         if not fields:
82             raise ValueError('At least one field is required to define a unique constraint.')
83         if not isinstance(condition, (type(None), Q)):
84             raise ValueError('UniqueConstraint.condition must be a Q instance.')
85         if condition and deferrable:
86             raise ValueError(
87                 'UniqueConstraint with conditions cannot be deferred.'
88             )
89         if not isinstance(deferrable, (type(None), Deferrable)):
90             raise ValueError(
91                 'UniqueConstraint.deferrable must be a Deferrable instance.'
92             )
93         self.fields = tuple(fields)
94         self.condition = condition
95         self.deferrable = deferrable
96         super().__init__(name)
97 
98     def _get_condition_sql(self, model, schema_editor):
99         if self.condition is None:
100             return None
101         query = Query(model=model, alias_cols=False)
102         where = query.build_where(self.condition)
103         compiler = query.get_compiler(connection=schema_editor.connection)
104         sql, params = where.as_sql(compiler, schema_editor.connection)
105         return sql % tuple(schema_editor.quote_value(p) for p in params)
106 
107     def constraint_sql(self, model, schema_editor):
108         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
109         condition = self._get_condition_sql(model, schema_editor)
110         return schema_editor._unique_sql(
111             model, fields, self.name, condition=condition,
112             deferrable=self.deferrable,
113         )
114 
115     def create_sql(self, model, schema_editor):
116         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
117         condition = self._get_condition_sql(model, schema_editor)
118         return schema_editor._create_unique_sql(
119             model, fields, self.name, condition=condition,
120             deferrable=self.deferrable,
121         )
122 
123     def remove_sql(self, model, schema_editor):
124         condition = self._get_condition_sql(model, schema_editor)
125         return schema_editor._delete_unique_sql(
126             model, self.name, condition=condition, deferrable=self.deferrable,
127         )
128 
129     def __repr__(self):
130         return '<%s: fields=%r name=%r%s%s>' % (
131             self.__class__.__name__, self.fields, self.name,
132             '' if self.condition is None else ' condition=%s' % self.condition,
133             '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,
134         )
135 
136     def __eq__(self, other):
137         if isinstance(other, UniqueConstraint):
138             return (
139                 self.name == other.name and
140                 self.fields == other.fields and
141                 self.condition == other.condition and
142                 self.deferrable == other.deferrable
143             )
144         return super().__eq__(other)
145 
146     def deconstruct(self):
147         path, args, kwargs = super().deconstruct()
148         kwargs['fields'] = self.fields
149         if self.condition:
150             kwargs['condition'] = self.condition
151         if self.deferrable:
152             kwargs['deferrable'] = self.deferrable
153         return path, args, kwargs

</code><intended_behavior>Similar to the `Index` class, modify or extend the `__init__`, `create_sql`, and possibly `deconstruct` methods to accept an `include` kwarg, allowing non-key columns to be included in the unique constraint for databases that support this feature. The `create_sql` needs to generate SQL that includes these fields in an `INCLUDE` statement.</intended_behavior>, <file>django/db/backends/base/schema.py</file>
<class>BaseDatabaseSchemaEditor</class>
<method>None</method>
<code>
44 class BaseDatabaseSchemaEditor:
45     """
46     This class and its subclasses are responsible for emitting schema-changing
47     statements to the databases - model creation/removal/alteration, field
48     renaming, index fiddling, and so on.
49     """
50 
51     # Overrideable SQL templates
52     sql_create_table = "CREATE TABLE %(table)s (%(definition)s)"
53     sql_rename_table = "ALTER TABLE %(old_table)s RENAME TO %(new_table)s"
54     sql_retablespace_table = "ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s"
55     sql_delete_table = "DROP TABLE %(table)s CASCADE"
56 
57     sql_create_column = "ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s"
58     sql_alter_column = "ALTER TABLE %(table)s %(changes)s"
59     sql_alter_column_type = "ALTER COLUMN %(column)s TYPE %(type)s"
60     sql_alter_column_null = "ALTER COLUMN %(column)s DROP NOT NULL"
61     sql_alter_column_not_null = "ALTER COLUMN %(column)s SET NOT NULL"
62     sql_alter_column_default = "ALTER COLUMN %(column)s SET DEFAULT %(default)s"
63     sql_alter_column_no_default = "ALTER COLUMN %(column)s DROP DEFAULT"
64     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE"
65     sql_rename_column = "ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s"
66     sql_update_with_default = "UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL"
67 
68     sql_unique_constraint = "UNIQUE (%(columns)s)%(deferrable)s"
69     sql_check_constraint = "CHECK (%(check)s)"
70     sql_delete_constraint = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"
71     sql_constraint = "CONSTRAINT %(name)s %(constraint)s"
72 
73     sql_create_check = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)"
74     sql_delete_check = sql_delete_constraint
75 
76     sql_create_unique = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s UNIQUE (%(columns)s)%(deferrable)s"
77     sql_delete_unique = sql_delete_constraint
78 
79     sql_create_fk = (
80         "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) "
81         "REFERENCES %(to_table)s (%(to_column)s)%(deferrable)s"
82     )
83     sql_create_inline_fk = None
84     sql_create_column_inline_fk = None
85     sql_delete_fk = sql_delete_constraint
86 
87     sql_create_index = "CREATE INDEX %(name)s ON %(table)s (%(columns)s)%(extra)s%(condition)s"
88     sql_create_unique_index = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)%(condition)s"
89     sql_delete_index = "DROP INDEX %(name)s"
90 
91     sql_create_pk = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)"
92     sql_delete_pk = sql_delete_constraint
93 
94     sql_delete_procedure = 'DROP PROCEDURE %(procedure)s'
95 
96     def __init__(self, connection, collect_sql=False, atomic=True):
97         self.connection = connection
98         self.collect_sql = collect_sql
99         if self.collect_sql:
100             self.collected_sql = []
101         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
102 
103     # State-managing methods
104 
105     def __enter__(self):
106         self.deferred_sql = []
107         if self.atomic_migration:
108             self.atomic = atomic(self.connection.alias)
109             self.atomic.__enter__()
110         return self
111 
112     def __exit__(self, exc_type, exc_value, traceback):
113         if exc_type is None:
114             for sql in self.deferred_sql:
115                 self.execute(sql)
116         if self.atomic_migration:
117             self.atomic.__exit__(exc_type, exc_value, traceback)
118 
119     # Core utility functions
120 
121     def execute(self, sql, params=()):
122         """Execute the given SQL statement, with optional parameters."""
123         # Don't perform the transactional DDL check if SQL is being collected
124         # as it's not going to be executed anyway.
125         if not self.collect_sql and self.connection.in_atomic_block and not self.connection.features.can_rollback_ddl:
126             raise TransactionManagementError(
127                 "Executing DDL statements while in a transaction on databases "
128                 "that can't perform a rollback is prohibited."
129             )
130         # Account for non-string statement objects.
131         sql = str(sql)
132         # Log the command we're running, then run it
133         logger.debug("%s; (params %r)", sql, params, extra={'params': params, 'sql': sql})
134         if self.collect_sql:
135             ending = "" if sql.endswith(";") else ";"
136             if params is not None:
137                 self.collected_sql.append((sql % tuple(map(self.quote_value, params))) + ending)
138             else:
139                 self.collected_sql.append(sql + ending)
140         else:
141             with self.connection.cursor() as cursor:
142                 cursor.execute(sql, params)
143 
144     def quote_name(self, name):
145         return self.connection.ops.quote_name(name)
146 
147     def table_sql(self, model):
148         """Take a model and return its table definition."""
149         # Add any unique_togethers (always deferred, as some fields might be
150         # created afterwards, like geometry fields with some backends).
151         for fields in model._meta.unique_together:
152             columns = [model._meta.get_field(field).column for field in fields]
153             self.deferred_sql.append(self._create_unique_sql(model, columns))
154         # Create column SQL, add FK deferreds if needed.
155         column_sqls = []
156         params = []
157         for field in model._meta.local_fields:
158             # SQL.
159             definition, extra_params = self.column_sql(model, field)
160             if definition is None:
161                 continue
162             # Check constraints can go on the column SQL here.
163             db_params = field.db_parameters(connection=self.connection)
164             if db_params['check']:
165                 definition += ' ' + self.sql_check_constraint % db_params
166             # Autoincrement SQL (for backends with inline variant).
167             col_type_suffix = field.db_type_suffix(connection=self.connection)
168             if col_type_suffix:
169                 definition += ' %s' % col_type_suffix
170             params.extend(extra_params)
171             # FK.
172             if field.remote_field and field.db_constraint:
173                 to_table = field.remote_field.model._meta.db_table
174                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
175                 if self.sql_create_inline_fk:
176                     definition += ' ' + self.sql_create_inline_fk % {
177                         'to_table': self.quote_name(to_table),
178                         'to_column': self.quote_name(to_column),
179                     }
180                 elif self.connection.features.supports_foreign_keys:
181                     self.deferred_sql.append(self._create_fk_sql(model, field, '_fk_%(to_table)s_%(to_column)s'))
182             # Add the SQL to our big list.
183             column_sqls.append('%s %s' % (
184                 self.quote_name(field.column),
185                 definition,
186             ))
187             # Autoincrement SQL (for backends with post table definition
188             # variant).
189             if field.get_internal_type() in ('AutoField', 'BigAutoField', 'SmallAutoField'):
190                 autoinc_sql = self.connection.ops.autoinc_sql(model._meta.db_table, field.column)
191                 if autoinc_sql:
192                     self.deferred_sql.extend(autoinc_sql)
193         constraints = [constraint.constraint_sql(model, self) for constraint in model._meta.constraints]
194         sql = self.sql_create_table % {
195             'table': self.quote_name(model._meta.db_table),
196             'definition': ', '.join(constraint for constraint in (*column_sqls, *constraints) if constraint),
197         }
198         if model._meta.db_tablespace:
199             tablespace_sql = self.connection.ops.tablespace_sql(model._meta.db_tablespace)
200             if tablespace_sql:
201                 sql += ' ' + tablespace_sql
202         return sql, params
203 
204     # Field <-> database mapping functions
205 
206     def column_sql(self, model, field, include_default=False):
207         """
208         Take a field and return its column definition.
209         The field must already have had set_attributes_from_name() called.
210         """
211         # Get the column's type and use that as the basis of the SQL
212         db_params = field.db_parameters(connection=self.connection)
213         sql = db_params['type']
214         params = []
215         # Check for fields that aren't actually columns (e.g. M2M)
216         if sql is None:
217             return None, None
218         # Work out nullability
219         null = field.null
220         # If we were told to include a default value, do so
221         include_default = include_default and not self.skip_default(field)
222         if include_default:
223             default_value = self.effective_default(field)
224             column_default = ' DEFAULT ' + self._column_default_sql(field)
225             if default_value is not None:
226                 if self.connection.features.requires_literal_defaults:
227                     # Some databases can't take defaults as a parameter (oracle)
228                     # If this is the case, the individual schema backend should
229                     # implement prepare_default
230                     sql += column_default % self.prepare_default(default_value)
231                 else:
232                     sql += column_default
233                     params += [default_value]
234         # Oracle treats the empty string ('') as null, so coerce the null
235         # option whenever '' is a possible value.
236         if (field.empty_strings_allowed and not field.primary_key and
237                 self.connection.features.interprets_empty_strings_as_nulls):
238             null = True
239         if null and not self.connection.features.implied_column_null:
240             sql += " NULL"
241         elif not null:
242             sql += " NOT NULL"
243         # Primary key/unique outputs
244         if field.primary_key:
245             sql += " PRIMARY KEY"
246         elif field.unique:
247             sql += " UNIQUE"
248         # Optionally add the tablespace if it's an implicitly indexed column
249         tablespace = field.db_tablespace or model._meta.db_tablespace
250         if tablespace and self.connection.features.supports_tablespaces and field.unique:
251             sql += " %s" % self.connection.ops.tablespace_sql(tablespace, inline=True)
252         # Return the sql
253         return sql, params
254 
255     def skip_default(self, field):
256         """
257         Some backends don't accept default values for certain columns types
258         (i.e. MySQL longtext and longblob).
259         """
260         return False
261 
262     def prepare_default(self, value):
263         """
264         Only used for backends which have requires_literal_defaults feature
265         """
266         raise NotImplementedError(
267             'subclasses of BaseDatabaseSchemaEditor for backends which have '
268             'requires_literal_defaults must provide a prepare_default() method'
269         )
270 
271     def _column_default_sql(self, field):
272         """
273         Return the SQL to use in a DEFAULT clause. The resulting string should
274         contain a '%s' placeholder for a default value.
275         """
276         return '%s'
277 
278     @staticmethod
279     def _effective_default(field):
280         # This method allows testing its logic without a connection.
281         if field.has_default():
282             default = field.get_default()
283         elif not field.null and field.blank and field.empty_strings_allowed:
284             if field.get_internal_type() == "BinaryField":
285                 default = b''
286             else:
287                 default = ''
288         elif getattr(field, 'auto_now', False) or getattr(field, 'auto_now_add', False):
289             default = datetime.now()
290             internal_type = field.get_internal_type()
291             if internal_type == 'DateField':
292                 default = default.date()
293             elif internal_type == 'TimeField':
294                 default = default.time()
295             elif internal_type == 'DateTimeField':
296                 default = timezone.now()
297         else:
298             default = None
299         return default
300 
301     def effective_default(self, field):
302         """Return a field's effective database default value."""
303         return field.get_db_prep_save(self._effective_default(field), self.connection)
304 
305     def quote_value(self, value):
306         """
307         Return a quoted version of the value so it's safe to use in an SQL
308         string. This is not safe against injection from user code; it is
309         intended only for use in making SQL scripts or preparing default values
310         for particularly tricky backends (defaults are not user-defined, though,
311         so this is safe).
312         """
313         raise NotImplementedError()
314 
315     # Actions
316 
317     def create_model(self, model):
318         """
319         Create a table and any accompanying indexes or unique constraints for
320         the given `model`.
321         """
322         sql, params = self.table_sql(model)
323         # Prevent using [] as params, in the case a literal '%' is used in the definition
324         self.execute(sql, params or None)
325 
326         # Add any field index and index_together's (deferred as SQLite _remake_table needs it)
327         self.deferred_sql.extend(self._model_indexes_sql(model))
328 
329         # Make M2M tables
330         for field in model._meta.local_many_to_many:
331             if field.remote_field.through._meta.auto_created:
332                 self.create_model(field.remote_field.through)
333 
334     def delete_model(self, model):
335         """Delete a model from the database."""
336         # Handle auto-created intermediary models
337         for field in model._meta.local_many_to_many:
338             if field.remote_field.through._meta.auto_created:
339                 self.delete_model(field.remote_field.through)
340 
341         # Delete the table
342         self.execute(self.sql_delete_table % {
343             "table": self.quote_name(model._meta.db_table),
344         })
345         # Remove all deferred statements referencing the deleted table.
346         for sql in list(self.deferred_sql):
347             if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
348                 self.deferred_sql.remove(sql)
349 
350     def add_index(self, model, index):
351         """Add an index on a model."""
352         self.execute(index.create_sql(model, self), params=None)
353 
354     def remove_index(self, model, index):
355         """Remove an index from a model."""
356         self.execute(index.remove_sql(model, self))
357 
358     def add_constraint(self, model, constraint):
359         """Add a constraint to a model."""
360         sql = constraint.create_sql(model, self)
361         if sql:
362             self.execute(sql)
363 
364     def remove_constraint(self, model, constraint):
365         """Remove a constraint from a model."""
366         sql = constraint.remove_sql(model, self)
367         if sql:
368             self.execute(sql)
369 
370     def alter_unique_together(self, model, old_unique_together, new_unique_together):
371         """
372         Deal with a model changing its unique_together. The input
373         unique_togethers must be doubly-nested, not the single-nested
374         ["foo", "bar"] format.
375         """
376         olds = {tuple(fields) for fields in old_unique_together}
377         news = {tuple(fields) for fields in new_unique_together}
378         # Deleted uniques
379         for fields in olds.difference(news):
380             self._delete_composed_index(model, fields, {'unique': True}, self.sql_delete_unique)
381         # Created uniques
382         for fields in news.difference(olds):
383             columns = [model._meta.get_field(field).column for field in fields]
384             self.execute(self._create_unique_sql(model, columns))
385 
386     def alter_index_together(self, model, old_index_together, new_index_together):
387         """
388         Deal with a model changing its index_together. The input
389         index_togethers must be doubly-nested, not the single-nested
390         ["foo", "bar"] format.
391         """
392         olds = {tuple(fields) for fields in old_index_together}
393         news = {tuple(fields) for fields in new_index_together}
394         # Deleted indexes
395         for fields in olds.difference(news):
396             self._delete_composed_index(
397                 model,
398                 fields,
399                 {'index': True, 'unique': False},
400                 self.sql_delete_index,
401             )
402         # Created indexes
403         for field_names in news.difference(olds):
404             fields = [model._meta.get_field(field) for field in field_names]
405             self.execute(self._create_index_sql(model, fields, suffix="_idx"))
406 
407     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):
408         meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
409         meta_index_names = {constraint.name for constraint in model._meta.indexes}
410         columns = [model._meta.get_field(field).column for field in fields]
411         constraint_names = self._constraint_names(
412             model, columns, exclude=meta_constraint_names | meta_index_names,
413             **constraint_kwargs
414         )
415         if len(constraint_names) != 1:
416             raise ValueError("Found wrong number (%s) of constraints for %s(%s)" % (
417                 len(constraint_names),
418                 model._meta.db_table,
419                 ", ".join(columns),
420             ))
421         self.execute(self._delete_constraint_sql(sql, model, constraint_names[0]))
422 
423     def alter_db_table(self, model, old_db_table, new_db_table):
424         """Rename the table a model points to."""
425         if (old_db_table == new_db_table or
426             (self.connection.features.ignores_table_name_case and
427                 old_db_table.lower() == new_db_table.lower())):
428             return
429         self.execute(self.sql_rename_table % {
430             "old_table": self.quote_name(old_db_table),
431             "new_table": self.quote_name(new_db_table),
432         })
433         # Rename all references to the old table name.
434         for sql in self.deferred_sql:
435             if isinstance(sql, Statement):
436                 sql.rename_table_references(old_db_table, new_db_table)
437 
438     def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):
439         """Move a model's table between tablespaces."""
440         self.execute(self.sql_retablespace_table % {
441             "table": self.quote_name(model._meta.db_table),
442             "old_tablespace": self.quote_name(old_db_tablespace),
443             "new_tablespace": self.quote_name(new_db_tablespace),
444         })
445 
446     def add_field(self, model, field):
447         """
448         Create a field on a model. Usually involves adding a column, but may
449         involve adding a table instead (for M2M fields).
450         """
451         # Special-case implicit M2M tables
452         if field.many_to_many and field.remote_field.through._meta.auto_created:
453             return self.create_model(field.remote_field.through)
454         # Get the column's definition
455         definition, params = self.column_sql(model, field, include_default=True)
456         # It might not actually have a column behind it
457         if definition is None:
458             return
459         # Check constraints can go on the column SQL here
460         db_params = field.db_parameters(connection=self.connection)
461         if db_params['check']:
462             definition += " " + self.sql_check_constraint % db_params
463         if field.remote_field and self.connection.features.supports_foreign_keys and field.db_constraint:
464             constraint_suffix = '_fk_%(to_table)s_%(to_column)s'
465             # Add FK constraint inline, if supported.
466             if self.sql_create_column_inline_fk:
467                 to_table = field.remote_field.model._meta.db_table
468                 to_column = field.remote_field.model._meta.get_field(field.remote_field.field_name).column
469                 definition += " " + self.sql_create_column_inline_fk % {
470                     'name': self._fk_constraint_name(model, field, constraint_suffix),
471                     'column': self.quote_name(field.column),
472                     'to_table': self.quote_name(to_table),
473                     'to_column': self.quote_name(to_column),
474                     'deferrable': self.connection.ops.deferrable_sql()
475                 }
476             # Otherwise, add FK constraints later.
477             else:
478                 self.deferred_sql.append(self._create_fk_sql(model, field, constraint_suffix))
479         # Build the SQL and run it
480         sql = self.sql_create_column % {
481             "table": self.quote_name(model._meta.db_table),
482             "column": self.quote_name(field.column),
483             "definition": definition,
484         }
485         self.execute(sql, params)
486         # Drop the default if we need to
487         # (Django usually does not use in-database defaults)
488         if not self.skip_default(field) and self.effective_default(field) is not None:
489             changes_sql, params = self._alter_column_default_sql(model, None, field, drop=True)
490             sql = self.sql_alter_column % {
491                 "table": self.quote_name(model._meta.db_table),
492                 "changes": changes_sql,
493             }
494             self.execute(sql, params)
495         # Add an index, if required
496         self.deferred_sql.extend(self._field_indexes_sql(model, field))
497         # Reset connection if required
498         if self.connection.features.connection_persists_old_columns:
499             self.connection.close()
500 
501     def remove_field(self, model, field):
502         """
503         Remove a field from a model. Usually involves deleting a column,
504         but for M2Ms may involve deleting a table.
505         """
506         # Special-case implicit M2M tables
507         if field.many_to_many and field.remote_field.through._meta.auto_created:
508             return self.delete_model(field.remote_field.through)
509         # It might not actually have a column behind it
510         if field.db_parameters(connection=self.connection)['type'] is None:
511             return
512         # Drop any FK constraints, MySQL requires explicit deletion
513         if field.remote_field:
514             fk_names = self._constraint_names(model, [field.column], foreign_key=True)
515             for fk_name in fk_names:
516                 self.execute(self._delete_fk_sql(model, fk_name))
517         # Delete the column
518         sql = self.sql_delete_column % {
519             "table": self.quote_name(model._meta.db_table),
520             "column": self.quote_name(field.column),
521         }
522         self.execute(sql)
523         # Reset connection if required
524         if self.connection.features.connection_persists_old_columns:
525             self.connection.close()
526         # Remove all deferred statements referencing the deleted column.
527         for sql in list(self.deferred_sql):
528             if isinstance(sql, Statement) and sql.references_column(model._meta.db_table, field.column):
529                 self.deferred_sql.remove(sql)
530 
531     def alter_field(self, model, old_field, new_field, strict=False):
532         """
533         Allow a field's type, uniqueness, nullability, default, column,
534         constraints, etc. to be modified.
535         `old_field` is required to compute the necessary changes.
536         If `strict` is True, raise errors if the old column does not match
537         `old_field` precisely.
538         """
539         # Ensure this field is even column-based
540         old_db_params = old_field.db_parameters(connection=self.connection)
541         old_type = old_db_params['type']
542         new_db_params = new_field.db_parameters(connection=self.connection)
543         new_type = new_db_params['type']
544         if ((old_type is None and old_field.remote_field is None) or
545                 (new_type is None and new_field.remote_field is None)):
546             raise ValueError(
547                 "Cannot alter field %s into %s - they do not properly define "
548                 "db_type (are you using a badly-written custom field?)" %
549                 (old_field, new_field),
550             )
551         elif old_type is None and new_type is None and (
552                 old_field.remote_field.through and new_field.remote_field.through and
553                 old_field.remote_field.through._meta.auto_created and
554                 new_field.remote_field.through._meta.auto_created):
555             return self._alter_many_to_many(model, old_field, new_field, strict)
556         elif old_type is None and new_type is None and (
557                 old_field.remote_field.through and new_field.remote_field.through and
558                 not old_field.remote_field.through._meta.auto_created and
559                 not new_field.remote_field.through._meta.auto_created):
560             # Both sides have through models; this is a no-op.
561             return
562         elif old_type is None or new_type is None:
563             raise ValueError(
564                 "Cannot alter field %s into %s - they are not compatible types "
565                 "(you cannot alter to or from M2M fields, or add or remove "
566                 "through= on M2M fields)" % (old_field, new_field)
567             )
568 
569         self._alter_field(model, old_field, new_field, old_type, new_type,
570                           old_db_params, new_db_params, strict)
571 
572     def _alter_field(self, model, old_field, new_field, old_type, new_type,
573                      old_db_params, new_db_params, strict=False):
574         """Perform a "physical" (non-ManyToMany) field update."""
575         # Drop any FK constraints, we'll remake them later
576         fks_dropped = set()
577         if (
578             self.connection.features.supports_foreign_keys and
579             old_field.remote_field and
580             old_field.db_constraint
581         ):
582             fk_names = self._constraint_names(model, [old_field.column], foreign_key=True)
583             if strict and len(fk_names) != 1:
584                 raise ValueError("Found wrong number (%s) of foreign key constraints for %s.%s" % (
585                     len(fk_names),
586                     model._meta.db_table,
587                     old_field.column,
588                 ))
589             for fk_name in fk_names:
590                 fks_dropped.add((old_field.column,))
591                 self.execute(self._delete_fk_sql(model, fk_name))
592         # Has unique been removed?
593         if old_field.unique and (not new_field.unique or self._field_became_primary_key(old_field, new_field)):
594             # Find the unique constraint for this field
595             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
596             constraint_names = self._constraint_names(
597                 model, [old_field.column], unique=True, primary_key=False,
598                 exclude=meta_constraint_names,
599             )
600             if strict and len(constraint_names) != 1:
601                 raise ValueError("Found wrong number (%s) of unique constraints for %s.%s" % (
602                     len(constraint_names),
603                     model._meta.db_table,
604                     old_field.column,
605                 ))
606             for constraint_name in constraint_names:
607                 self.execute(self._delete_unique_sql(model, constraint_name))
608         # Drop incoming FK constraints if the field is a primary key or unique,
609         # which might be a to_field target, and things are going to change.
610         drop_foreign_keys = (
611             self.connection.features.supports_foreign_keys and (
612                 (old_field.primary_key and new_field.primary_key) or
613                 (old_field.unique and new_field.unique)
614             ) and old_type != new_type
615         )
616         if drop_foreign_keys:
617             # '_meta.related_field' also contains M2M reverse fields, these
618             # will be filtered out
619             for _old_rel, new_rel in _related_non_m2m_objects(old_field, new_field):
620                 rel_fk_names = self._constraint_names(
621                     new_rel.related_model, [new_rel.field.column], foreign_key=True
622                 )
623                 for fk_name in rel_fk_names:
624                     self.execute(self._delete_fk_sql(new_rel.related_model, fk_name))
625         # Removed an index? (no strict check, as multiple indexes are possible)
626         # Remove indexes if db_index switched to False or a unique constraint
627         # will now be used in lieu of an index. The following lines from the
628         # truth table show all True cases; the rest are False:
629         #
630         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
631         # ------------------------------------------------------------------------------
632         # True               | False            | False              | False
633         # True               | False            | False              | True
634         # True               | False            | True               | True
635         if old_field.db_index and not old_field.unique and (not new_field.db_index or new_field.unique):
636             # Find the index for this field
637             meta_index_names = {index.name for index in model._meta.indexes}
638             # Retrieve only BTREE indexes since this is what's created with
639             # db_index=True.
640             index_names = self._constraint_names(
641                 model, [old_field.column], index=True, type_=Index.suffix,
642                 exclude=meta_index_names,
643             )
644             for index_name in index_names:
645                 # The only way to check if an index was created with
646                 # db_index=True or with Index(['field'], name='foo')
647                 # is to look at its name (refs #28053).
648                 self.execute(self._delete_index_sql(model, index_name))
649         # Change check constraints?
650         if old_db_params['check'] != new_db_params['check'] and old_db_params['check']:
651             meta_constraint_names = {constraint.name for constraint in model._meta.constraints}
652             constraint_names = self._constraint_names(
653                 model, [old_field.column], check=True,
654                 exclude=meta_constraint_names,
655             )
656             if strict and len(constraint_names) != 1:
657                 raise ValueError("Found wrong number (%s) of check constraints for %s.%s" % (
658                     len(constraint_names),
659                     model._meta.db_table,
660                     old_field.column,
661                 ))
662             for constraint_name in constraint_names:
663                 self.execute(self._delete_check_sql(model, constraint_name))
664         # Have they renamed the column?
665         if old_field.column != new_field.column:
666             self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
667             # Rename all references to the renamed column.
668             for sql in self.deferred_sql:
669                 if isinstance(sql, Statement):
670                     sql.rename_column_references(model._meta.db_table, old_field.column, new_field.column)
671         # Next, start accumulating actions to do
672         actions = []
673         null_actions = []
674         post_actions = []
675         # Type change?
676         if old_type != new_type:
677             fragment, other_actions = self._alter_column_type_sql(model, old_field, new_field, new_type)
678             actions.append(fragment)
679             post_actions.extend(other_actions)
680         # When changing a column NULL constraint to NOT NULL with a given
681         # default value, we need to perform 4 steps:
682         #  1. Add a default for new incoming writes
683         #  2. Update existing NULL rows with new default
684         #  3. Replace NULL constraint with NOT NULL
685         #  4. Drop the default again.
686         # Default change?
687         needs_database_default = False
688         if old_field.null and not new_field.null:
689             old_default = self.effective_default(old_field)
690             new_default = self.effective_default(new_field)
691             if (
692                 not self.skip_default(new_field) and
693                 old_default != new_default and
694                 new_default is not None
695             ):
696                 needs_database_default = True
697                 actions.append(self._alter_column_default_sql(model, old_field, new_field))
698         # Nullability change?
699         if old_field.null != new_field.null:
700             fragment = self._alter_column_null_sql(model, old_field, new_field)
701             if fragment:
702                 null_actions.append(fragment)
703         # Only if we have a default and there is a change from NULL to NOT NULL
704         four_way_default_alteration = (
705             new_field.has_default() and
706             (old_field.null and not new_field.null)
707         )
708         if actions or null_actions:
709             if not four_way_default_alteration:
710                 # If we don't have to do a 4-way default alteration we can
711                 # directly run a (NOT) NULL alteration
712                 actions = actions + null_actions
713             # Combine actions together if we can (e.g. postgres)
714             if self.connection.features.supports_combined_alters and actions:
715                 sql, params = tuple(zip(*actions))
716                 actions = [(", ".join(sql), sum(params, []))]
717             # Apply those actions
718             for sql, params in actions:
719                 self.execute(
720                     self.sql_alter_column % {
721                         "table": self.quote_name(model._meta.db_table),
722                         "changes": sql,
723                     },
724                     params,
725                 )
726             if four_way_default_alteration:
727                 # Update existing rows with default value
728                 self.execute(
729                     self.sql_update_with_default % {
730                         "table": self.quote_name(model._meta.db_table),
731                         "column": self.quote_name(new_field.column),
732                         "default": "%s",
733                     },
734                     [new_default],
735                 )
736                 # Since we didn't run a NOT NULL change before we need to do it
737                 # now
738                 for sql, params in null_actions:
739                     self.execute(
740                         self.sql_alter_column % {
741                             "table": self.quote_name(model._meta.db_table),
742                             "changes": sql,
743                         },
744                         params,
745                     )
746         if post_actions:
747             for sql, params in post_actions:
748                 self.execute(sql, params)
749         # If primary_key changed to False, delete the primary key constraint.
750         if old_field.primary_key and not new_field.primary_key:
751             self._delete_primary_key(model, strict)
752         # Added a unique?
753         if self._unique_should_be_added(old_field, new_field):
754             self.execute(self._create_unique_sql(model, [new_field.column]))
755         # Added an index? Add an index if db_index switched to True or a unique
756         # constraint will no longer be used in lieu of an index. The following
757         # lines from the truth table show all True cases; the rest are False:
758         #
759         # old_field.db_index | old_field.unique | new_field.db_index | new_field.unique
760         # ------------------------------------------------------------------------------
761         # False              | False            | True               | False
762         # False              | True             | True               | False
763         # True               | True             | True               | False
764         if (not old_field.db_index or old_field.unique) and new_field.db_index and not new_field.unique:
765             self.execute(self._create_index_sql(model, [new_field]))
766         # Type alteration on primary key? Then we need to alter the column
767         # referring to us.
768         rels_to_update = []
769         if drop_foreign_keys:
770             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
771         # Changed to become primary key?
772         if self._field_became_primary_key(old_field, new_field):
773             # Make the new one
774             self.execute(self._create_primary_key_sql(model, new_field))
775             # Update all referencing columns
776             rels_to_update.extend(_related_non_m2m_objects(old_field, new_field))
777         # Handle our type alters on the other end of rels from the PK stuff above
778         for old_rel, new_rel in rels_to_update:
779             rel_db_params = new_rel.field.db_parameters(connection=self.connection)
780             rel_type = rel_db_params['type']
781             fragment, other_actions = self._alter_column_type_sql(
782                 new_rel.related_model, old_rel.field, new_rel.field, rel_type
783             )
784             self.execute(
785                 self.sql_alter_column % {
786                     "table": self.quote_name(new_rel.related_model._meta.db_table),
787                     "changes": fragment[0],
788                 },
789                 fragment[1],
790             )
791             for sql, params in other_actions:
792                 self.execute(sql, params)
793         # Does it have a foreign key?
794         if (self.connection.features.supports_foreign_keys and new_field.remote_field and
795                 (fks_dropped or not old_field.remote_field or not old_field.db_constraint) and
796                 new_field.db_constraint):
797             self.execute(self._create_fk_sql(model, new_field, "_fk_%(to_table)s_%(to_column)s"))
798         # Rebuild FKs that pointed to us if we previously had to drop them
799         if drop_foreign_keys:
800             for rel in new_field.model._meta.related_objects:
801                 if _is_relevant_relation(rel, new_field) and rel.field.db_constraint:
802                     self.execute(self._create_fk_sql(rel.related_model, rel.field, "_fk"))
803         # Does it have check constraints we need to add?
804         if old_db_params['check'] != new_db_params['check'] and new_db_params['check']:
805             constraint_name = self._create_index_name(model._meta.db_table, [new_field.column], suffix='_check')
806             self.execute(self._create_check_sql(model, constraint_name, new_db_params['check']))
807         # Drop the default if we need to
808         # (Django usually does not use in-database defaults)
809         if needs_database_default:
810             changes_sql, params = self._alter_column_default_sql(model, old_field, new_field, drop=True)
811             sql = self.sql_alter_column % {
812                 "table": self.quote_name(model._meta.db_table),
813                 "changes": changes_sql,
814             }
815             self.execute(sql, params)
816         # Reset connection if required
817         if self.connection.features.connection_persists_old_columns:
818             self.connection.close()
819 
820     def _alter_column_null_sql(self, model, old_field, new_field):
821         """
822         Hook to specialize column null alteration.
823 
824         Return a (sql, params) fragment to set a column to null or non-null
825         as required by new_field, or None if no changes are required.
826         """
827         if (self.connection.features.interprets_empty_strings_as_nulls and
828                 new_field.get_internal_type() in ("CharField", "TextField")):
829             # The field is nullable in the database anyway, leave it alone.
830             return
831         else:
832             new_db_params = new_field.db_parameters(connection=self.connection)
833             sql = self.sql_alter_column_null if new_field.null else self.sql_alter_column_not_null
834             return (
835                 sql % {
836                     'column': self.quote_name(new_field.column),
837                     'type': new_db_params['type'],
838                 },
839                 [],
840             )
841 
842     def _alter_column_default_sql(self, model, old_field, new_field, drop=False):
843         """
844         Hook to specialize column default alteration.
845 
846         Return a (sql, params) fragment to add or drop (depending on the drop
847         argument) a default to new_field's column.
848         """
849         new_default = self.effective_default(new_field)
850         default = self._column_default_sql(new_field)
851         params = [new_default]
852 
853         if drop:
854             params = []
855         elif self.connection.features.requires_literal_defaults:
856             # Some databases (Oracle) can't take defaults as a parameter
857             # If this is the case, the SchemaEditor for that database should
858             # implement prepare_default().
859             default = self.prepare_default(new_default)
860             params = []
861 
862         new_db_params = new_field.db_parameters(connection=self.connection)
863         sql = self.sql_alter_column_no_default if drop else self.sql_alter_column_default
864         return (
865             sql % {
866                 'column': self.quote_name(new_field.column),
867                 'type': new_db_params['type'],
868                 'default': default,
869             },
870             params,
871         )
872 
873     def _alter_column_type_sql(self, model, old_field, new_field, new_type):
874         """
875         Hook to specialize column type alteration for different backends,
876         for cases when a creation type is different to an alteration type
877         (e.g. SERIAL in PostgreSQL, PostGIS fields).
878 
879         Return a two-tuple of: an SQL fragment of (sql, params) to insert into
880         an ALTER TABLE statement and a list of extra (sql, params) tuples to
881         run once the field is altered.
882         """
883         return (
884             (
885                 self.sql_alter_column_type % {
886                     "column": self.quote_name(new_field.column),
887                     "type": new_type,
888                 },
889                 [],
890             ),
891             [],
892         )
893 
894     def _alter_many_to_many(self, model, old_field, new_field, strict):
895         """Alter M2Ms to repoint their to= endpoints."""
896         # Rename the through table
897         if old_field.remote_field.through._meta.db_table != new_field.remote_field.through._meta.db_table:
898             self.alter_db_table(old_field.remote_field.through, old_field.remote_field.through._meta.db_table,
899                                 new_field.remote_field.through._meta.db_table)
900         # Repoint the FK to the other side
901         self.alter_field(
902             new_field.remote_field.through,
903             # We need the field that points to the target model, so we can tell alter_field to change it -
904             # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
905             old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
906             new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
907         )
908         self.alter_field(
909             new_field.remote_field.through,
910             # for self-referential models we need to alter field from the other end too
911             old_field.remote_field.through._meta.get_field(old_field.m2m_field_name()),
912             new_field.remote_field.through._meta.get_field(new_field.m2m_field_name()),
913         )
914 
915     def _create_index_name(self, table_name, column_names, suffix=""):
916         """
917         Generate a unique name for an index/unique constraint.
918 
919         The name is divided into 3 parts: the table name, the column names,
920         and a unique digest and suffix.
921         """
922         _, table_name = split_identifier(table_name)
923         hash_suffix_part = '%s%s' % (names_digest(table_name, *column_names, length=8), suffix)
924         max_length = self.connection.ops.max_name_length() or 200
925         # If everything fits into max_length, use that name.
926         index_name = '%s_%s_%s' % (table_name, '_'.join(column_names), hash_suffix_part)
927         if len(index_name) <= max_length:
928             return index_name
929         # Shorten a long suffix.
930         if len(hash_suffix_part) > max_length / 3:
931             hash_suffix_part = hash_suffix_part[:max_length // 3]
932         other_length = (max_length - len(hash_suffix_part)) // 2 - 1
933         index_name = '%s_%s_%s' % (
934             table_name[:other_length],
935             '_'.join(column_names)[:other_length],
936             hash_suffix_part,
937         )
938         # Prepend D if needed to prevent the name from starting with an
939         # underscore or a number (not permitted on Oracle).
940         if index_name[0] == "_" or index_name[0].isdigit():
941             index_name = "D%s" % index_name[:-1]
942         return index_name
943 
944     def _get_index_tablespace_sql(self, model, fields, db_tablespace=None):
945         if db_tablespace is None:
946             if len(fields) == 1 and fields[0].db_tablespace:
947                 db_tablespace = fields[0].db_tablespace
948             elif model._meta.db_tablespace:
949                 db_tablespace = model._meta.db_tablespace
950         if db_tablespace is not None:
951             return ' ' + self.connection.ops.tablespace_sql(db_tablespace)
952         return ''
953 
954     def _index_condition_sql(self, condition):
955         if condition:
956             return ' WHERE ' + condition
957         return ''
958 
959     def _create_index_sql(self, model, fields, *, name=None, suffix='', using='',
960                           db_tablespace=None, col_suffixes=(), sql=None, opclasses=(),
961                           condition=None):
962         """
963         Return the SQL statement to create the index for one or several fields.
964         `sql` can be specified if the syntax differs from the standard (GIS
965         indexes, ...).
966         """
967         tablespace_sql = self._get_index_tablespace_sql(model, fields, db_tablespace=db_tablespace)
968         columns = [field.column for field in fields]
969         sql_create_index = sql or self.sql_create_index
970         table = model._meta.db_table
971 
972         def create_index_name(*args, **kwargs):
973             nonlocal name
974             if name is None:
975                 name = self._create_index_name(*args, **kwargs)
976             return self.quote_name(name)
977 
978         return Statement(
979             sql_create_index,
980             table=Table(table, self.quote_name),
981             name=IndexName(table, columns, suffix, create_index_name),
982             using=using,
983             columns=self._index_columns(table, columns, col_suffixes, opclasses),
984             extra=tablespace_sql,
985             condition=self._index_condition_sql(condition),
986         )
987 
988     def _delete_index_sql(self, model, name, sql=None):
989         return Statement(
990             sql or self.sql_delete_index,
991             table=Table(model._meta.db_table, self.quote_name),
992             name=self.quote_name(name),
993         )
994 
995     def _index_columns(self, table, columns, col_suffixes, opclasses):
996         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
997 
998     def _model_indexes_sql(self, model):
999         """
1000         Return a list of all index SQL statements (field indexes,
1001         index_together, Meta.indexes) for the specified model.
1002         """
1003         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
1004             return []
1005         output = []
1006         for field in model._meta.local_fields:
1007             output.extend(self._field_indexes_sql(model, field))
1008 
1009         for field_names in model._meta.index_together:
1010             fields = [model._meta.get_field(field) for field in field_names]
1011             output.append(self._create_index_sql(model, fields, suffix="_idx"))
1012 
1013         for index in model._meta.indexes:
1014             output.append(index.create_sql(model, self))
1015         return output
1016 
1017     def _field_indexes_sql(self, model, field):
1018         """
1019         Return a list of all index SQL statements for the specified field.
1020         """
1021         output = []
1022         if self._field_should_be_indexed(model, field):
1023             output.append(self._create_index_sql(model, [field]))
1024         return output
1025 
1026     def _field_should_be_indexed(self, model, field):
1027         return field.db_index and not field.unique
1028 
1029     def _field_became_primary_key(self, old_field, new_field):
1030         return not old_field.primary_key and new_field.primary_key
1031 
1032     def _unique_should_be_added(self, old_field, new_field):
1033         return (not old_field.unique and new_field.unique) or (
1034             old_field.primary_key and not new_field.primary_key and new_field.unique
1035         )
1036 
1037     def _rename_field_sql(self, table, old_field, new_field, new_type):
1038         return self.sql_rename_column % {
1039             "table": self.quote_name(table),
1040             "old_column": self.quote_name(old_field.column),
1041             "new_column": self.quote_name(new_field.column),
1042             "type": new_type,
1043         }
1044 
1045     def _create_fk_sql(self, model, field, suffix):
1046         table = Table(model._meta.db_table, self.quote_name)
1047         name = self._fk_constraint_name(model, field, suffix)
1048         column = Columns(model._meta.db_table, [field.column], self.quote_name)
1049         to_table = Table(field.target_field.model._meta.db_table, self.quote_name)
1050         to_column = Columns(field.target_field.model._meta.db_table, [field.target_field.column], self.quote_name)
1051         deferrable = self.connection.ops.deferrable_sql()
1052         return Statement(
1053             self.sql_create_fk,
1054             table=table,
1055             name=name,
1056             column=column,
1057             to_table=to_table,
1058             to_column=to_column,
1059             deferrable=deferrable,
1060         )
1061 
1062     def _fk_constraint_name(self, model, field, suffix):
1063         def create_fk_name(*args, **kwargs):
1064             return self.quote_name(self._create_index_name(*args, **kwargs))
1065 
1066         return ForeignKeyName(
1067             model._meta.db_table,
1068             [field.column],
1069             split_identifier(field.target_field.model._meta.db_table)[1],
1070             [field.target_field.column],
1071             suffix,
1072             create_fk_name,
1073         )
1074 
1075     def _delete_fk_sql(self, model, name):
1076         return self._delete_constraint_sql(self.sql_delete_fk, model, name)
1077 
1078     def _deferrable_constraint_sql(self, deferrable):
1079         if deferrable is None:
1080             return ''
1081         if deferrable == Deferrable.DEFERRED:
1082             return ' DEFERRABLE INITIALLY DEFERRED'
1083         if deferrable == Deferrable.IMMEDIATE:
1084             return ' DEFERRABLE INITIALLY IMMEDIATE'
1085 
1086     def _unique_sql(self, model, fields, name, condition=None, deferrable=None):
1087         if (
1088             deferrable and
1089             not self.connection.features.supports_deferrable_unique_constraints
1090         ):
1091             return None
1092         if condition:
1093             # Databases support conditional unique constraints via a unique
1094             # index.
1095             sql = self._create_unique_sql(model, fields, name=name, condition=condition)
1096             if sql:
1097                 self.deferred_sql.append(sql)
1098             return None
1099         constraint = self.sql_unique_constraint % {
1100             'columns': ', '.join(map(self.quote_name, fields)),
1101             'deferrable': self._deferrable_constraint_sql(deferrable),
1102         }
1103         return self.sql_constraint % {
1104             'name': self.quote_name(name),
1105             'constraint': constraint,
1106         }
1107 
1108     def _create_unique_sql(self, model, columns, name=None, condition=None, deferrable=None):
1109         if (
1110             deferrable and
1111             not self.connection.features.supports_deferrable_unique_constraints
1112         ):
1113             return None
1114 
1115         def create_unique_name(*args, **kwargs):
1116             return self.quote_name(self._create_index_name(*args, **kwargs))
1117 
1118         table = Table(model._meta.db_table, self.quote_name)
1119         if name is None:
1120             name = IndexName(model._meta.db_table, columns, '_uniq', create_unique_name)
1121         else:
1122             name = self.quote_name(name)
1123         columns = Columns(table, columns, self.quote_name)
1124         if condition:
1125             if not self.connection.features.supports_partial_indexes:
1126                 return None
1127             sql = self.sql_create_unique_index
1128         else:
1129             sql = self.sql_create_unique
1130         return Statement(
1131             sql,
1132             table=table,
1133             name=name,
1134             columns=columns,
1135             condition=self._index_condition_sql(condition),
1136             deferrable=self._deferrable_constraint_sql(deferrable),
1137         )
1138 
1139     def _delete_unique_sql(self, model, name, condition=None, deferrable=None):
1140         if (
1141             deferrable and
1142             not self.connection.features.supports_deferrable_unique_constraints
1143         ):
1144             return None
1145         if condition:
1146             return (
1147                 self._delete_constraint_sql(self.sql_delete_index, model, name)
1148                 if self.connection.features.supports_partial_indexes else None
1149             )
1150         return self._delete_constraint_sql(self.sql_delete_unique, model, name)
1151 
1152     def _check_sql(self, name, check):
1153         return self.sql_constraint % {
1154             'name': self.quote_name(name),
1155             'constraint': self.sql_check_constraint % {'check': check},
1156         }
1157 
1158     def _create_check_sql(self, model, name, check):
1159         return Statement(
1160             self.sql_create_check,
1161             table=Table(model._meta.db_table, self.quote_name),
1162             name=self.quote_name(name),
1163             check=check,
1164         )
1165 
1166     def _delete_check_sql(self, model, name):
1167         return self._delete_constraint_sql(self.sql_delete_check, model, name)
1168 
1169     def _delete_constraint_sql(self, template, model, name):
1170         return Statement(
1171             template,
1172             table=Table(model._meta.db_table, self.quote_name),
1173             name=self.quote_name(name),
1174         )
1175 
1176     def _constraint_names(self, model, column_names=None, unique=None,
1177                           primary_key=None, index=None, foreign_key=None,
1178                           check=None, type_=None, exclude=None):
1179         """Return all constraint names matching the columns and conditions."""
1180         if column_names is not None:
1181             column_names = [
1182                 self.connection.introspection.identifier_converter(name)
1183                 for name in column_names
1184             ]
1185         with self.connection.cursor() as cursor:
1186             constraints = self.connection.introspection.get_constraints(cursor, model._meta.db_table)
1187         result = []
1188         for name, infodict in constraints.items():
1189             if column_names is None or column_names == infodict['columns']:
1190                 if unique is not None and infodict['unique'] != unique:
1191                     continue
1192                 if primary_key is not None and infodict['primary_key'] != primary_key:
1193                     continue
1194                 if index is not None and infodict['index'] != index:
1195                     continue
1196                 if check is not None and infodict['check'] != check:
1197                     continue
1198                 if foreign_key is not None and not infodict['foreign_key']:
1199                     continue
1200                 if type_ is not None and infodict['type'] != type_:
1201                     continue
1202                 if not exclude or name not in exclude:
1203                     result.append(name)
1204         return result
1205 
1206     def _delete_primary_key(self, model, strict=False):
1207         constraint_names = self._constraint_names(model, primary_key=True)
1208         if strict and len(constraint_names) != 1:
1209             raise ValueError('Found wrong number (%s) of PK constraints for %s' % (
1210                 len(constraint_names),
1211                 model._meta.db_table,
1212             ))
1213         for constraint_name in constraint_names:
1214             self.execute(self._delete_primary_key_sql(model, constraint_name))
1215 
1216     def _create_primary_key_sql(self, model, field):
1217         return Statement(
1218             self.sql_create_pk,
1219             table=Table(model._meta.db_table, self.quote_name),
1220             name=self.quote_name(
1221                 self._create_index_name(model._meta.db_table, [field.column], suffix="_pk")
1222             ),
1223             columns=Columns(model._meta.db_table, [field.column], self.quote_name),
1224         )
1225 
1226     def _delete_primary_key_sql(self, model, name):
1227         return self._delete_constraint_sql(self.sql_delete_pk, model, name)
1228 
1229     def remove_procedure(self, procedure_name, param_types=()):
1230         sql = self.sql_delete_procedure % {
1231             'procedure': self.quote_name(procedure_name),
1232             'param_types': ','.join(param_types),
1233         }
1234         self.execute(sql)

</code><intended_behavior>Since backend-specific implementations might be needed to support the `INCLUDE` clause across different databases, review and possibly extend methods like `add_index` and `add_constraint` to handle the `include` kwarg. This involves ensuring that SQL generation respects the `include` kwarg if provided and the database backend supports it.</intended_behavior>]
2025-10-17 11:44:11.219 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 11:44:11.219 | INFO     | Search-only: skipping patch selection
2025-10-17 11:44:11.461 | INFO     | Task django__django-11991 completed successfully.
2025-10-17 11:44:11.462 | INFO     | No patch generated. You can try running ACR again.
