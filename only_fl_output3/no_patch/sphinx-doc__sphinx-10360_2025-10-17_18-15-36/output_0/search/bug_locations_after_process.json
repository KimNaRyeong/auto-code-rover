[
    {
        "rel_file_path": "sphinx/domains/c.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/domains/c.py",
        "start": 2143,
        "end": 3129,
        "class_name": "DefinitionParser",
        "method_name": null,
        "code": "2143 class DefinitionParser(BaseParser):\n2144     @property\n2145     def language(self) -> str:\n2146         return 'C'\n2147 \n2148     @property\n2149     def id_attributes(self):\n2150         return self.config.c_id_attributes\n2151 \n2152     @property\n2153     def paren_attributes(self):\n2154         return self.config.c_paren_attributes\n2155 \n2156     def _parse_string(self) -> str:\n2157         if self.current_char != '\"':\n2158             return None\n2159         startPos = self.pos\n2160         self.pos += 1\n2161         escape = False\n2162         while True:\n2163             if self.eof:\n2164                 self.fail(\"Unexpected end during inside string.\")\n2165             elif self.current_char == '\"' and not escape:\n2166                 self.pos += 1\n2167                 break\n2168             elif self.current_char == '\\\\':\n2169                 escape = True\n2170             else:\n2171                 escape = False\n2172             self.pos += 1\n2173         return self.definition[startPos:self.pos]\n2174 \n2175     def _parse_literal(self) -> ASTLiteral:\n2176         # -> integer-literal\n2177         #  | character-literal\n2178         #  | floating-literal\n2179         #  | string-literal\n2180         #  | boolean-literal -> \"false\" | \"true\"\n2181         self.skip_ws()\n2182         if self.skip_word('true'):\n2183             return ASTBooleanLiteral(True)\n2184         if self.skip_word('false'):\n2185             return ASTBooleanLiteral(False)\n2186         pos = self.pos\n2187         if self.match(float_literal_re):\n2188             self.match(float_literal_suffix_re)\n2189             return ASTNumberLiteral(self.definition[pos:self.pos])\n2190         for regex in [binary_literal_re, hex_literal_re,\n2191                       integer_literal_re, octal_literal_re]:\n2192             if self.match(regex):\n2193                 self.match(integers_literal_suffix_re)\n2194                 return ASTNumberLiteral(self.definition[pos:self.pos])\n2195 \n2196         string = self._parse_string()\n2197         if string is not None:\n2198             return ASTStringLiteral(string)\n2199 \n2200         # character-literal\n2201         if self.match(char_literal_re):\n2202             prefix = self.last_match.group(1)  # may be None when no prefix\n2203             data = self.last_match.group(2)\n2204             try:\n2205                 return ASTCharLiteral(prefix, data)\n2206             except UnicodeDecodeError as e:\n2207                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n2208             except UnsupportedMultiCharacterCharLiteral:\n2209                 self.fail(\"Can not handle character literal\"\n2210                           \" resulting in multiple decoded characters.\")\n2211         return None\n2212 \n2213     def _parse_paren_expression(self) -> ASTExpression:\n2214         # \"(\" expression \")\"\n2215         if self.current_char != '(':\n2216             return None\n2217         self.pos += 1\n2218         res = self._parse_expression()\n2219         self.skip_ws()\n2220         if not self.skip_string(')'):\n2221             self.fail(\"Expected ')' in end of parenthesized expression.\")\n2222         return ASTParenExpr(res)\n2223 \n2224     def _parse_primary_expression(self) -> ASTExpression:\n2225         # literal\n2226         # \"(\" expression \")\"\n2227         # id-expression -> we parse this with _parse_nested_name\n2228         self.skip_ws()\n2229         res: ASTExpression = self._parse_literal()\n2230         if res is not None:\n2231             return res\n2232         res = self._parse_paren_expression()\n2233         if res is not None:\n2234             return res\n2235         nn = self._parse_nested_name()\n2236         if nn is not None:\n2237             return ASTIdExpression(nn)\n2238         return None\n2239 \n2240     def _parse_initializer_list(self, name: str, open: str, close: str\n2241                                 ) -> Tuple[List[ASTExpression], bool]:\n2242         # Parse open and close with the actual initializer-list in between\n2243         # -> initializer-clause '...'[opt]\n2244         #  | initializer-list ',' initializer-clause '...'[opt]\n2245         # TODO: designators\n2246         self.skip_ws()\n2247         if not self.skip_string_and_ws(open):\n2248             return None, None\n2249         if self.skip_string(close):\n2250             return [], False\n2251 \n2252         exprs = []\n2253         trailingComma = False\n2254         while True:\n2255             self.skip_ws()\n2256             expr = self._parse_expression()\n2257             self.skip_ws()\n2258             exprs.append(expr)\n2259             self.skip_ws()\n2260             if self.skip_string(close):\n2261                 break\n2262             if not self.skip_string_and_ws(','):\n2263                 self.fail(\"Error in %s, expected ',' or '%s'.\" % (name, close))\n2264             if self.current_char == close and close == '}':\n2265                 self.pos += 1\n2266                 trailingComma = True\n2267                 break\n2268         return exprs, trailingComma\n2269 \n2270     def _parse_paren_expression_list(self) -> ASTParenExprList:\n2271         # -> '(' expression-list ')'\n2272         # though, we relax it to also allow empty parens\n2273         # as it's needed in some cases\n2274         #\n2275         # expression-list\n2276         # -> initializer-list\n2277         exprs, trailingComma = self._parse_initializer_list(\"parenthesized expression-list\",\n2278                                                             '(', ')')\n2279         if exprs is None:\n2280             return None\n2281         return ASTParenExprList(exprs)\n2282 \n2283     def _parse_braced_init_list(self) -> ASTBracedInitList:\n2284         # -> '{' initializer-list ','[opt] '}'\n2285         #  | '{' '}'\n2286         exprs, trailingComma = self._parse_initializer_list(\"braced-init-list\", '{', '}')\n2287         if exprs is None:\n2288             return None\n2289         return ASTBracedInitList(exprs, trailingComma)\n2290 \n2291     def _parse_postfix_expression(self) -> ASTPostfixExpr:\n2292         # -> primary\n2293         #  | postfix \"[\" expression \"]\"\n2294         #  | postfix \"[\" braced-init-list [opt] \"]\"\n2295         #  | postfix \"(\" expression-list [opt] \")\"\n2296         #  | postfix \".\" id-expression  // taken care of in primary by nested name\n2297         #  | postfix \"->\" id-expression\n2298         #  | postfix \"++\"\n2299         #  | postfix \"--\"\n2300 \n2301         prefix = self._parse_primary_expression()\n2302 \n2303         # and now parse postfixes\n2304         postFixes: List[ASTPostfixOp] = []\n2305         while True:\n2306             self.skip_ws()\n2307             if self.skip_string_and_ws('['):\n2308                 expr = self._parse_expression()\n2309                 self.skip_ws()\n2310                 if not self.skip_string(']'):\n2311                     self.fail(\"Expected ']' in end of postfix expression.\")\n2312                 postFixes.append(ASTPostfixArray(expr))\n2313                 continue\n2314             if self.skip_string('->'):\n2315                 if self.skip_string('*'):\n2316                     # don't steal the arrow\n2317                     self.pos -= 3\n2318                 else:\n2319                     name = self._parse_nested_name()\n2320                     postFixes.append(ASTPostfixMemberOfPointer(name))\n2321                     continue\n2322             if self.skip_string('++'):\n2323                 postFixes.append(ASTPostfixInc())\n2324                 continue\n2325             if self.skip_string('--'):\n2326                 postFixes.append(ASTPostfixDec())\n2327                 continue\n2328             lst = self._parse_paren_expression_list()\n2329             if lst is not None:\n2330                 postFixes.append(ASTPostfixCallExpr(lst))\n2331                 continue\n2332             break\n2333         return ASTPostfixExpr(prefix, postFixes)\n2334 \n2335     def _parse_unary_expression(self) -> ASTExpression:\n2336         # -> postfix\n2337         #  | \"++\" cast\n2338         #  | \"--\" cast\n2339         #  | unary-operator cast -> (* | & | + | - | ! | ~) cast\n2340         # The rest:\n2341         #  | \"sizeof\" unary\n2342         #  | \"sizeof\" \"(\" type-id \")\"\n2343         #  | \"alignof\" \"(\" type-id \")\"\n2344         self.skip_ws()\n2345         for op in _expression_unary_ops:\n2346             # TODO: hmm, should we be able to backtrack here?\n2347             if op[0] in 'cn':\n2348                 res = self.skip_word(op)\n2349             else:\n2350                 res = self.skip_string(op)\n2351             if res:\n2352                 expr = self._parse_cast_expression()\n2353                 return ASTUnaryOpExpr(op, expr)\n2354         if self.skip_word_and_ws('sizeof'):\n2355             if self.skip_string_and_ws('('):\n2356                 typ = self._parse_type(named=False)\n2357                 self.skip_ws()\n2358                 if not self.skip_string(')'):\n2359                     self.fail(\"Expecting ')' to end 'sizeof'.\")\n2360                 return ASTSizeofType(typ)\n2361             expr = self._parse_unary_expression()\n2362             return ASTSizeofExpr(expr)\n2363         if self.skip_word_and_ws('alignof'):\n2364             if not self.skip_string_and_ws('('):\n2365                 self.fail(\"Expecting '(' after 'alignof'.\")\n2366             typ = self._parse_type(named=False)\n2367             self.skip_ws()\n2368             if not self.skip_string(')'):\n2369                 self.fail(\"Expecting ')' to end 'alignof'.\")\n2370             return ASTAlignofExpr(typ)\n2371         return self._parse_postfix_expression()\n2372 \n2373     def _parse_cast_expression(self) -> ASTExpression:\n2374         # -> unary  | \"(\" type-id \")\" cast\n2375         pos = self.pos\n2376         self.skip_ws()\n2377         if self.skip_string('('):\n2378             try:\n2379                 typ = self._parse_type(False)\n2380                 if not self.skip_string(')'):\n2381                     self.fail(\"Expected ')' in cast expression.\")\n2382                 expr = self._parse_cast_expression()\n2383                 return ASTCastExpr(typ, expr)\n2384             except DefinitionError as exCast:\n2385                 self.pos = pos\n2386                 try:\n2387                     return self._parse_unary_expression()\n2388                 except DefinitionError as exUnary:\n2389                     errs = []\n2390                     errs.append((exCast, \"If type cast expression\"))\n2391                     errs.append((exUnary, \"If unary expression\"))\n2392                     raise self._make_multi_error(errs,\n2393                                                  \"Error in cast expression.\") from exUnary\n2394         else:\n2395             return self._parse_unary_expression()\n2396 \n2397     def _parse_logical_or_expression(self) -> ASTExpression:\n2398         # logical-or     = logical-and      ||\n2399         # logical-and    = inclusive-or     &&\n2400         # inclusive-or   = exclusive-or     |\n2401         # exclusive-or   = and              ^\n2402         # and            = equality         &\n2403         # equality       = relational       ==, !=\n2404         # relational     = shift            <, >, <=, >=\n2405         # shift          = additive         <<, >>\n2406         # additive       = multiplicative   +, -\n2407         # multiplicative = pm               *, /, %\n2408         # pm             = cast             .*, ->*\n2409         def _parse_bin_op_expr(self, opId):\n2410             if opId + 1 == len(_expression_bin_ops):\n2411                 def parser() -> ASTExpression:\n2412                     return self._parse_cast_expression()\n2413             else:\n2414                 def parser() -> ASTExpression:\n2415                     return _parse_bin_op_expr(self, opId + 1)\n2416             exprs = []\n2417             ops = []\n2418             exprs.append(parser())\n2419             while True:\n2420                 self.skip_ws()\n2421                 pos = self.pos\n2422                 oneMore = False\n2423                 for op in _expression_bin_ops[opId]:\n2424                     if op[0] in 'abcnox':\n2425                         if not self.skip_word(op):\n2426                             continue\n2427                     else:\n2428                         if not self.skip_string(op):\n2429                             continue\n2430                     if op == '&' and self.current_char == '&':\n2431                         # don't split the && 'token'\n2432                         self.pos -= 1\n2433                         # and btw. && has lower precedence, so we are done\n2434                         break\n2435                     try:\n2436                         expr = parser()\n2437                         exprs.append(expr)\n2438                         ops.append(op)\n2439                         oneMore = True\n2440                         break\n2441                     except DefinitionError:\n2442                         self.pos = pos\n2443                 if not oneMore:\n2444                     break\n2445             return ASTBinOpExpr(exprs, ops)\n2446         return _parse_bin_op_expr(self, 0)\n2447 \n2448     def _parse_conditional_expression_tail(self, orExprHead: Any) -> ASTExpression:\n2449         # -> \"?\" expression \":\" assignment-expression\n2450         return None\n2451 \n2452     def _parse_assignment_expression(self) -> ASTExpression:\n2453         # -> conditional-expression\n2454         #  | logical-or-expression assignment-operator initializer-clause\n2455         # -> conditional-expression ->\n2456         #     logical-or-expression\n2457         #   | logical-or-expression \"?\" expression \":\" assignment-expression\n2458         #   | logical-or-expression assignment-operator initializer-clause\n2459         exprs = []\n2460         ops = []\n2461         orExpr = self._parse_logical_or_expression()\n2462         exprs.append(orExpr)\n2463         # TODO: handle ternary with _parse_conditional_expression_tail\n2464         while True:\n2465             oneMore = False\n2466             self.skip_ws()\n2467             for op in _expression_assignment_ops:\n2468                 if op[0] in 'abcnox':\n2469                     if not self.skip_word(op):\n2470                         continue\n2471                 else:\n2472                     if not self.skip_string(op):\n2473                         continue\n2474                 expr = self._parse_logical_or_expression()\n2475                 exprs.append(expr)\n2476                 ops.append(op)\n2477                 oneMore = True\n2478             if not oneMore:\n2479                 break\n2480         return ASTAssignmentExpr(exprs, ops)\n2481 \n2482     def _parse_constant_expression(self) -> ASTExpression:\n2483         # -> conditional-expression\n2484         orExpr = self._parse_logical_or_expression()\n2485         # TODO: use _parse_conditional_expression_tail\n2486         return orExpr\n2487 \n2488     def _parse_expression(self) -> ASTExpression:\n2489         # -> assignment-expression\n2490         #  | expression \",\" assignment-expression\n2491         # TODO: actually parse the second production\n2492         return self._parse_assignment_expression()\n2493 \n2494     def _parse_expression_fallback(\n2495             self, end: List[str],\n2496             parser: Callable[[], ASTExpression],\n2497             allow: bool = True) -> ASTExpression:\n2498         # Stupidly \"parse\" an expression.\n2499         # 'end' should be a list of characters which ends the expression.\n2500 \n2501         # first try to use the provided parser\n2502         prevPos = self.pos\n2503         try:\n2504             return parser()\n2505         except DefinitionError as e:\n2506             # some places (e.g., template parameters) we really don't want to use fallback,\n2507             # and for testing we may want to globally disable it\n2508             if not allow or not self.allowFallbackExpressionParsing:\n2509                 raise\n2510             self.warn(\"Parsing of expression failed. Using fallback parser.\"\n2511                       \" Error was:\\n%s\" % e)\n2512             self.pos = prevPos\n2513         # and then the fallback scanning\n2514         assert end is not None\n2515         self.skip_ws()\n2516         startPos = self.pos\n2517         if self.match(_string_re):\n2518             value = self.matched_text\n2519         else:\n2520             # TODO: add handling of more bracket-like things, and quote handling\n2521             brackets = {'(': ')', '{': '}', '[': ']'}\n2522             symbols: List[str] = []\n2523             while not self.eof:\n2524                 if (len(symbols) == 0 and self.current_char in end):\n2525                     break\n2526                 if self.current_char in brackets.keys():\n2527                     symbols.append(brackets[self.current_char])\n2528                 elif len(symbols) > 0 and self.current_char == symbols[-1]:\n2529                     symbols.pop()\n2530                 self.pos += 1\n2531             if len(end) > 0 and self.eof:\n2532                 self.fail(\"Could not find end of expression starting at %d.\"\n2533                           % startPos)\n2534             value = self.definition[startPos:self.pos].strip()\n2535         return ASTFallbackExpr(value.strip())\n2536 \n2537     def _parse_nested_name(self) -> ASTNestedName:\n2538         names: List[Any] = []\n2539 \n2540         self.skip_ws()\n2541         rooted = False\n2542         if self.skip_string('.'):\n2543             rooted = True\n2544         while 1:\n2545             self.skip_ws()\n2546             if not self.match(identifier_re):\n2547                 self.fail(\"Expected identifier in nested name.\")\n2548             identifier = self.matched_text\n2549             # make sure there isn't a keyword\n2550             if identifier in _keywords:\n2551                 self.fail(\"Expected identifier in nested name, \"\n2552                           \"got keyword: %s\" % identifier)\n2553             if self.matched_text in self.config.c_extra_keywords:\n2554                 msg = \"Expected identifier, got user-defined keyword: %s.\" \\\n2555                       + \" Remove it from c_extra_keywords to allow it as identifier.\\n\" \\\n2556                       + \"Currently c_extra_keywords is %s.\"\n2557                 self.fail(msg % (self.matched_text,\n2558                                  str(self.config.c_extra_keywords)))\n2559             ident = ASTIdentifier(identifier)\n2560             names.append(ident)\n2561 \n2562             self.skip_ws()\n2563             if not self.skip_string('.'):\n2564                 break\n2565         return ASTNestedName(names, rooted)\n2566 \n2567     def _parse_simple_type_specifier(self) -> Optional[str]:\n2568         if self.match(_simple_type_specifiers_re):\n2569             return self.matched_text\n2570         for t in ('bool', 'complex', 'imaginary'):\n2571             if t in self.config.c_extra_keywords:\n2572                 if self.skip_word(t):\n2573                     return t\n2574         return None\n2575 \n2576     def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental:\n2577         names: List[str] = []\n2578 \n2579         self.skip_ws()\n2580         while True:\n2581             t = self._parse_simple_type_specifier()\n2582             if t is None:\n2583                 break\n2584             names.append(t)\n2585             self.skip_ws()\n2586         if len(names) == 0:\n2587             return None\n2588         return ASTTrailingTypeSpecFundamental(names)\n2589 \n2590     def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:\n2591         # fundamental types, https://en.cppreference.com/w/c/language/type\n2592         # and extensions\n2593         self.skip_ws()\n2594         res = self._parse_simple_type_specifiers()\n2595         if res is not None:\n2596             return res\n2597 \n2598         # prefixed\n2599         prefix = None\n2600         self.skip_ws()\n2601         for k in ('struct', 'enum', 'union'):\n2602             if self.skip_word_and_ws(k):\n2603                 prefix = k\n2604                 break\n2605 \n2606         nestedName = self._parse_nested_name()\n2607         return ASTTrailingTypeSpecName(prefix, nestedName)\n2608 \n2609     def _parse_parameters(self, paramMode: str) -> ASTParameters:\n2610         self.skip_ws()\n2611         if not self.skip_string('('):\n2612             if paramMode == 'function':\n2613                 self.fail('Expecting \"(\" in parameters.')\n2614             else:\n2615                 return None\n2616 \n2617         args = []\n2618         self.skip_ws()\n2619         if not self.skip_string(')'):\n2620             while 1:\n2621                 self.skip_ws()\n2622                 if self.skip_string('...'):\n2623                     args.append(ASTFunctionParameter(None, True))\n2624                     self.skip_ws()\n2625                     if not self.skip_string(')'):\n2626                         self.fail('Expected \")\" after \"...\" in parameters.')\n2627                     break\n2628                 # note: it seems that function arguments can always be named,\n2629                 # even in function pointers and similar.\n2630                 arg = self._parse_type_with_init(outer=None, named='single')\n2631                 # TODO: parse default parameters # TODO: didn't we just do that?\n2632                 args.append(ASTFunctionParameter(arg))\n2633 \n2634                 self.skip_ws()\n2635                 if self.skip_string(','):\n2636                     continue\n2637                 elif self.skip_string(')'):\n2638                     break\n2639                 else:\n2640                     self.fail(\n2641                         'Expecting \",\" or \")\" in parameters, '\n2642                         'got \"%s\".' % self.current_char)\n2643 \n2644         attrs = []\n2645         while True:\n2646             attr = self._parse_attribute()\n2647             if attr is None:\n2648                 break\n2649             attrs.append(attr)\n2650 \n2651         return ASTParameters(args, attrs)\n2652 \n2653     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:\n2654         \"\"\"Just parse the simple ones.\"\"\"\n2655         storage = None\n2656         threadLocal = None\n2657         inline = None\n2658         restrict = None\n2659         volatile = None\n2660         const = None\n2661         attrs = []\n2662         while 1:  # accept any permutation of a subset of some decl-specs\n2663             self.skip_ws()\n2664             if not storage:\n2665                 if outer == 'member':\n2666                     if self.skip_word('auto'):\n2667                         storage = 'auto'\n2668                         continue\n2669                     if self.skip_word('register'):\n2670                         storage = 'register'\n2671                         continue\n2672                 if outer in ('member', 'function'):\n2673                     if self.skip_word('static'):\n2674                         storage = 'static'\n2675                         continue\n2676                     if self.skip_word('extern'):\n2677                         storage = 'extern'\n2678                         continue\n2679             if outer == 'member' and not threadLocal:\n2680                 if self.skip_word('thread_local'):\n2681                     threadLocal = 'thread_local'\n2682                     continue\n2683                 if self.skip_word('_Thread_local'):\n2684                     threadLocal = '_Thread_local'\n2685                     continue\n2686             if outer == 'function' and not inline:\n2687                 inline = self.skip_word('inline')\n2688                 if inline:\n2689                     continue\n2690 \n2691             if not restrict and typed:\n2692                 restrict = self.skip_word('restrict')\n2693                 if restrict:\n2694                     continue\n2695             if not volatile and typed:\n2696                 volatile = self.skip_word('volatile')\n2697                 if volatile:\n2698                     continue\n2699             if not const and typed:\n2700                 const = self.skip_word('const')\n2701                 if const:\n2702                     continue\n2703             attr = self._parse_attribute()\n2704             if attr:\n2705                 attrs.append(attr)\n2706                 continue\n2707             break\n2708         return ASTDeclSpecsSimple(storage, threadLocal, inline,\n2709                                   restrict, volatile, const, attrs)\n2710 \n2711     def _parse_decl_specs(self, outer: str, typed: bool = True) -> ASTDeclSpecs:\n2712         if outer:\n2713             if outer not in ('type', 'member', 'function'):\n2714                 raise Exception('Internal error, unknown outer \"%s\".' % outer)\n2715         leftSpecs = self._parse_decl_specs_simple(outer, typed)\n2716         rightSpecs = None\n2717 \n2718         if typed:\n2719             trailing = self._parse_trailing_type_spec()\n2720             rightSpecs = self._parse_decl_specs_simple(outer, typed)\n2721         else:\n2722             trailing = None\n2723         return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)\n2724 \n2725     def _parse_declarator_name_suffix(\n2726             self, named: Union[bool, str], paramMode: str, typed: bool\n2727     ) -> ASTDeclarator:\n2728         assert named in (True, False, 'single')\n2729         # now we should parse the name, and then suffixes\n2730         if named == 'single':\n2731             if self.match(identifier_re):\n2732                 if self.matched_text in _keywords:\n2733                     self.fail(\"Expected identifier, \"\n2734                               \"got keyword: %s\" % self.matched_text)\n2735                 if self.matched_text in self.config.c_extra_keywords:\n2736                     msg = \"Expected identifier, got user-defined keyword: %s.\" \\\n2737                           + \" Remove it from c_extra_keywords to allow it as identifier.\\n\" \\\n2738                           + \"Currently c_extra_keywords is %s.\"\n2739                     self.fail(msg % (self.matched_text,\n2740                                      str(self.config.c_extra_keywords)))\n2741                 identifier = ASTIdentifier(self.matched_text)\n2742                 declId = ASTNestedName([identifier], rooted=False)\n2743             else:\n2744                 declId = None\n2745         elif named:\n2746             declId = self._parse_nested_name()\n2747         else:\n2748             declId = None\n2749         arrayOps = []\n2750         while 1:\n2751             self.skip_ws()\n2752             if typed and self.skip_string('['):\n2753                 self.skip_ws()\n2754                 static = False\n2755                 const = False\n2756                 volatile = False\n2757                 restrict = False\n2758                 while True:\n2759                     if not static:\n2760                         if self.skip_word_and_ws('static'):\n2761                             static = True\n2762                             continue\n2763                     if not const:\n2764                         if self.skip_word_and_ws('const'):\n2765                             const = True\n2766                             continue\n2767                     if not volatile:\n2768                         if self.skip_word_and_ws('volatile'):\n2769                             volatile = True\n2770                             continue\n2771                     if not restrict:\n2772                         if self.skip_word_and_ws('restrict'):\n2773                             restrict = True\n2774                             continue\n2775                     break\n2776                 vla = False if static else self.skip_string_and_ws('*')\n2777                 if vla:\n2778                     if not self.skip_string(']'):\n2779                         self.fail(\"Expected ']' in end of array operator.\")\n2780                     size = None\n2781                 else:\n2782                     if self.skip_string(']'):\n2783                         size = None\n2784                     else:\n2785 \n2786                         def parser():\n2787                             return self._parse_expression()\n2788                         size = self._parse_expression_fallback([']'], parser)\n2789                         self.skip_ws()\n2790                         if not self.skip_string(']'):\n2791                             self.fail(\"Expected ']' in end of array operator.\")\n2792                 arrayOps.append(ASTArray(static, const, volatile, restrict, vla, size))\n2793             else:\n2794                 break\n2795         param = self._parse_parameters(paramMode)\n2796         if param is None and len(arrayOps) == 0:\n2797             # perhaps a bit-field\n2798             if named and paramMode == 'type' and typed:\n2799                 self.skip_ws()\n2800                 if self.skip_string(':'):\n2801                     size = self._parse_constant_expression()\n2802                     return ASTDeclaratorNameBitField(declId=declId, size=size)\n2803         return ASTDeclaratorNameParam(declId=declId, arrayOps=arrayOps,\n2804                                       param=param)\n2805 \n2806     def _parse_declarator(self, named: Union[bool, str], paramMode: str,\n2807                           typed: bool = True) -> ASTDeclarator:\n2808         # 'typed' here means 'parse return type stuff'\n2809         if paramMode not in ('type', 'function'):\n2810             raise Exception(\n2811                 \"Internal error, unknown paramMode '%s'.\" % paramMode)\n2812         prevErrors = []\n2813         self.skip_ws()\n2814         if typed and self.skip_string('*'):\n2815             self.skip_ws()\n2816             restrict = False\n2817             volatile = False\n2818             const = False\n2819             attrs = []\n2820             while 1:\n2821                 if not restrict:\n2822                     restrict = self.skip_word_and_ws('restrict')\n2823                     if restrict:\n2824                         continue\n2825                 if not volatile:\n2826                     volatile = self.skip_word_and_ws('volatile')\n2827                     if volatile:\n2828                         continue\n2829                 if not const:\n2830                     const = self.skip_word_and_ws('const')\n2831                     if const:\n2832                         continue\n2833                 attr = self._parse_attribute()\n2834                 if attr is not None:\n2835                     attrs.append(attr)\n2836                     continue\n2837                 break\n2838             next = self._parse_declarator(named, paramMode, typed)\n2839             return ASTDeclaratorPtr(next=next,\n2840                                     restrict=restrict, volatile=volatile, const=const,\n2841                                     attrs=attrs)\n2842         if typed and self.current_char == '(':  # note: peeking, not skipping\n2843             # maybe this is the beginning of params, try that first,\n2844             # otherwise assume it's noptr->declarator > ( ptr-declarator )\n2845             pos = self.pos\n2846             try:\n2847                 # assume this is params\n2848                 res = self._parse_declarator_name_suffix(named, paramMode,\n2849                                                          typed)\n2850                 return res\n2851             except DefinitionError as exParamQual:\n2852                 msg = \"If declarator-id with parameters\"\n2853                 if paramMode == 'function':\n2854                     msg += \" (e.g., 'void f(int arg)')\"\n2855                 prevErrors.append((exParamQual, msg))\n2856                 self.pos = pos\n2857                 try:\n2858                     assert self.current_char == '('\n2859                     self.skip_string('(')\n2860                     # TODO: hmm, if there is a name, it must be in inner, right?\n2861                     # TODO: hmm, if there must be parameters, they must b\n2862                     # inside, right?\n2863                     inner = self._parse_declarator(named, paramMode, typed)\n2864                     if not self.skip_string(')'):\n2865                         self.fail(\"Expected ')' in \\\"( ptr-declarator )\\\"\")\n2866                     next = self._parse_declarator(named=False,\n2867                                                   paramMode=\"type\",\n2868                                                   typed=typed)\n2869                     return ASTDeclaratorParen(inner=inner, next=next)\n2870                 except DefinitionError as exNoPtrParen:\n2871                     self.pos = pos\n2872                     msg = \"If parenthesis in noptr-declarator\"\n2873                     if paramMode == 'function':\n2874                         msg += \" (e.g., 'void (*f(int arg))(double)')\"\n2875                     prevErrors.append((exNoPtrParen, msg))\n2876                     header = \"Error in declarator\"\n2877                     raise self._make_multi_error(prevErrors, header) from exNoPtrParen\n2878         pos = self.pos\n2879         try:\n2880             return self._parse_declarator_name_suffix(named, paramMode, typed)\n2881         except DefinitionError as e:\n2882             self.pos = pos\n2883             prevErrors.append((e, \"If declarator-id\"))\n2884             header = \"Error in declarator or parameters\"\n2885             raise self._make_multi_error(prevErrors, header) from e\n2886 \n2887     def _parse_initializer(self, outer: str = None, allowFallback: bool = True\n2888                            ) -> ASTInitializer:\n2889         self.skip_ws()\n2890         if outer == 'member' and False:  # TODO\n2891             bracedInit = self._parse_braced_init_list()\n2892             if bracedInit is not None:\n2893                 return ASTInitializer(bracedInit, hasAssign=False)\n2894 \n2895         if not self.skip_string('='):\n2896             return None\n2897 \n2898         bracedInit = self._parse_braced_init_list()\n2899         if bracedInit is not None:\n2900             return ASTInitializer(bracedInit)\n2901 \n2902         if outer == 'member':\n2903             fallbackEnd: List[str] = []\n2904         elif outer is None:  # function parameter\n2905             fallbackEnd = [',', ')']\n2906         else:\n2907             self.fail(\"Internal error, initializer for outer '%s' not \"\n2908                       \"implemented.\" % outer)\n2909 \n2910         def parser():\n2911             return self._parse_assignment_expression()\n2912 \n2913         value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)\n2914         return ASTInitializer(value)\n2915 \n2916     def _parse_type(self, named: Union[bool, str], outer: str = None) -> ASTType:\n2917         \"\"\"\n2918         named=False|'single'|True: 'single' is e.g., for function objects which\n2919         doesn't need to name the arguments, but otherwise is a single name\n2920         \"\"\"\n2921         if outer:  # always named\n2922             if outer not in ('type', 'member', 'function'):\n2923                 raise Exception('Internal error, unknown outer \"%s\".' % outer)\n2924             assert named\n2925 \n2926         if outer == 'type':\n2927             # We allow type objects to just be a name.\n2928             prevErrors = []\n2929             startPos = self.pos\n2930             # first try without the type\n2931             try:\n2932                 declSpecs = self._parse_decl_specs(outer=outer, typed=False)\n2933                 decl = self._parse_declarator(named=True, paramMode=outer,\n2934                                               typed=False)\n2935                 self.assert_end(allowSemicolon=True)\n2936             except DefinitionError as exUntyped:\n2937                 desc = \"If just a name\"\n2938                 prevErrors.append((exUntyped, desc))\n2939                 self.pos = startPos\n2940                 try:\n2941                     declSpecs = self._parse_decl_specs(outer=outer)\n2942                     decl = self._parse_declarator(named=True, paramMode=outer)\n2943                 except DefinitionError as exTyped:\n2944                     self.pos = startPos\n2945                     desc = \"If typedef-like declaration\"\n2946                     prevErrors.append((exTyped, desc))\n2947                     # Retain the else branch for easier debugging.\n2948                     # TODO: it would be nice to save the previous stacktrace\n2949                     #       and output it here.\n2950                     if True:\n2951                         header = \"Type must be either just a name or a \"\n2952                         header += \"typedef-like declaration.\"\n2953                         raise self._make_multi_error(prevErrors, header) from exTyped\n2954                     else:\n2955                         # For testing purposes.\n2956                         # do it again to get the proper traceback (how do you\n2957                         # reliably save a traceback when an exception is\n2958                         # constructed?)\n2959                         self.pos = startPos\n2960                         typed = True\n2961                         declSpecs = self._parse_decl_specs(outer=outer, typed=typed)\n2962                         decl = self._parse_declarator(named=True, paramMode=outer,\n2963                                                       typed=typed)\n2964         elif outer == 'function':\n2965             declSpecs = self._parse_decl_specs(outer=outer)\n2966             decl = self._parse_declarator(named=True, paramMode=outer)\n2967         else:\n2968             paramMode = 'type'\n2969             if outer == 'member':  # i.e., member\n2970                 named = True\n2971             declSpecs = self._parse_decl_specs(outer=outer)\n2972             decl = self._parse_declarator(named=named, paramMode=paramMode)\n2973         return ASTType(declSpecs, decl)\n2974 \n2975     def _parse_type_with_init(self, named: Union[bool, str], outer: str) -> ASTTypeWithInit:\n2976         if outer:\n2977             assert outer in ('type', 'member', 'function')\n2978         type = self._parse_type(outer=outer, named=named)\n2979         init = self._parse_initializer(outer=outer)\n2980         return ASTTypeWithInit(type, init)\n2981 \n2982     def _parse_macro(self) -> ASTMacro:\n2983         self.skip_ws()\n2984         ident = self._parse_nested_name()\n2985         if ident is None:\n2986             self.fail(\"Expected identifier in macro definition.\")\n2987         self.skip_ws()\n2988         if not self.skip_string_and_ws('('):\n2989             return ASTMacro(ident, None)\n2990         if self.skip_string(')'):\n2991             return ASTMacro(ident, [])\n2992         args = []\n2993         while 1:\n2994             self.skip_ws()\n2995             if self.skip_string('...'):\n2996                 args.append(ASTMacroParameter(None, True))\n2997                 self.skip_ws()\n2998                 if not self.skip_string(')'):\n2999                     self.fail('Expected \")\" after \"...\" in macro parameters.')\n3000                 break\n3001             if not self.match(identifier_re):\n3002                 self.fail(\"Expected identifier in macro parameters.\")\n3003             nn = ASTNestedName([ASTIdentifier(self.matched_text)], rooted=False)\n3004             # Allow named variadic args:\n3005             # https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html\n3006             self.skip_ws()\n3007             if self.skip_string_and_ws('...'):\n3008                 args.append(ASTMacroParameter(nn, False, True))\n3009                 self.skip_ws()\n3010                 if not self.skip_string(')'):\n3011                     self.fail('Expected \")\" after \"...\" in macro parameters.')\n3012                 break\n3013             args.append(ASTMacroParameter(nn))\n3014             if self.skip_string_and_ws(','):\n3015                 continue\n3016             elif self.skip_string_and_ws(')'):\n3017                 break\n3018             else:\n3019                 self.fail(\"Expected identifier, ')', or ',' in macro parameter list.\")\n3020         return ASTMacro(ident, args)\n3021 \n3022     def _parse_struct(self) -> ASTStruct:\n3023         name = self._parse_nested_name()\n3024         return ASTStruct(name)\n3025 \n3026     def _parse_union(self) -> ASTUnion:\n3027         name = self._parse_nested_name()\n3028         return ASTUnion(name)\n3029 \n3030     def _parse_enum(self) -> ASTEnum:\n3031         name = self._parse_nested_name()\n3032         return ASTEnum(name)\n3033 \n3034     def _parse_enumerator(self) -> ASTEnumerator:\n3035         name = self._parse_nested_name()\n3036         self.skip_ws()\n3037         init = None\n3038         if self.skip_string('='):\n3039             self.skip_ws()\n3040 \n3041             def parser() -> ASTExpression:\n3042                 return self._parse_constant_expression()\n3043 \n3044             initVal = self._parse_expression_fallback([], parser)\n3045             init = ASTInitializer(initVal)\n3046         return ASTEnumerator(name, init)\n3047 \n3048     def parse_pre_v3_type_definition(self) -> ASTDeclaration:\n3049         self.skip_ws()\n3050         declaration: DeclarationType = None\n3051         if self.skip_word('struct'):\n3052             typ = 'struct'\n3053             declaration = self._parse_struct()\n3054         elif self.skip_word('union'):\n3055             typ = 'union'\n3056             declaration = self._parse_union()\n3057         elif self.skip_word('enum'):\n3058             typ = 'enum'\n3059             declaration = self._parse_enum()\n3060         else:\n3061             self.fail(\"Could not parse pre-v3 type directive.\"\n3062                       \" Must start with 'struct', 'union', or 'enum'.\")\n3063         return ASTDeclaration(typ, typ, declaration, False)\n3064 \n3065     def parse_declaration(self, objectType: str, directiveType: str) -> ASTDeclaration:\n3066         if objectType not in ('function', 'member',\n3067                               'macro', 'struct', 'union', 'enum', 'enumerator', 'type'):\n3068             raise Exception('Internal error, unknown objectType \"%s\".' % objectType)\n3069         if directiveType not in ('function', 'member', 'var',\n3070                                  'macro', 'struct', 'union', 'enum', 'enumerator', 'type'):\n3071             raise Exception('Internal error, unknown directiveType \"%s\".' % directiveType)\n3072 \n3073         declaration: DeclarationType = None\n3074         if objectType == 'member':\n3075             declaration = self._parse_type_with_init(named=True, outer='member')\n3076         elif objectType == 'function':\n3077             declaration = self._parse_type(named=True, outer='function')\n3078         elif objectType == 'macro':\n3079             declaration = self._parse_macro()\n3080         elif objectType == 'struct':\n3081             declaration = self._parse_struct()\n3082         elif objectType == 'union':\n3083             declaration = self._parse_union()\n3084         elif objectType == 'enum':\n3085             declaration = self._parse_enum()\n3086         elif objectType == 'enumerator':\n3087             declaration = self._parse_enumerator()\n3088         elif objectType == 'type':\n3089             declaration = self._parse_type(named=True, outer='type')\n3090         else:\n3091             assert False\n3092         if objectType != 'macro':\n3093             self.skip_ws()\n3094             semicolon = self.skip_string(';')\n3095         else:\n3096             semicolon = False\n3097         return ASTDeclaration(objectType, directiveType, declaration, semicolon)\n3098 \n3099     def parse_namespace_object(self) -> ASTNestedName:\n3100         return self._parse_nested_name()\n3101 \n3102     def parse_xref_object(self) -> ASTNestedName:\n3103         name = self._parse_nested_name()\n3104         # if there are '()' left, just skip them\n3105         self.skip_ws()\n3106         self.skip_string('()')\n3107         self.assert_end()\n3108         return name\n3109 \n3110     def parse_expression(self) -> Union[ASTExpression, ASTType]:\n3111         pos = self.pos\n3112         res: Union[ASTExpression, ASTType] = None\n3113         try:\n3114             res = self._parse_expression()\n3115             self.skip_ws()\n3116             self.assert_end()\n3117         except DefinitionError as exExpr:\n3118             self.pos = pos\n3119             try:\n3120                 res = self._parse_type(False)\n3121                 self.skip_ws()\n3122                 self.assert_end()\n3123             except DefinitionError as exType:\n3124                 header = \"Error when parsing (type) expression.\"\n3125                 errs = []\n3126                 errs.append((exExpr, \"If expression\"))\n3127                 errs.append((exType, \"If type\"))\n3128                 raise self._make_multi_error(errs, header) from exType\n3129         return res\n",
        "intended_behavior": "Adjust the id_attributes property and perhaps the setup method as needed to ensure that when Sphinx encounters attributes in enum value declarations (like __attribute__((__deprecated__)) or macros intended for deprecation signals), these attributes are either ignored or processed in a way that does not interfere with the correct identification of the enum value names. This might involve modifying how c_id_attributes is used within this parsing context to ensure attributes in enums are handled according to the expected documentation output, without misinterpretation or causing duplicate declaration issues."
    },
    {
        "rel_file_path": "sphinx/domains/cpp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/domains/cpp.py",
        "start": 5087,
        "end": 7089,
        "class_name": "DefinitionParser",
        "method_name": null,
        "code": "5087 class DefinitionParser(BaseParser):\n5088     @property\n5089     def language(self) -> str:\n5090         return 'C++'\n5091 \n5092     @property\n5093     def id_attributes(self):\n5094         return self.config.cpp_id_attributes\n5095 \n5096     @property\n5097     def paren_attributes(self):\n5098         return self.config.cpp_paren_attributes\n5099 \n5100     def _parse_string(self) -> str:\n5101         if self.current_char != '\"':\n5102             return None\n5103         startPos = self.pos\n5104         self.pos += 1\n5105         escape = False\n5106         while True:\n5107             if self.eof:\n5108                 self.fail(\"Unexpected end during inside string.\")\n5109             elif self.current_char == '\"' and not escape:\n5110                 self.pos += 1\n5111                 break\n5112             elif self.current_char == '\\\\':\n5113                 escape = True\n5114             else:\n5115                 escape = False\n5116             self.pos += 1\n5117         return self.definition[startPos:self.pos]\n5118 \n5119     def _parse_literal(self) -> ASTLiteral:\n5120         # -> integer-literal\n5121         #  | character-literal\n5122         #  | floating-literal\n5123         #  | string-literal\n5124         #  | boolean-literal -> \"false\" | \"true\"\n5125         #  | pointer-literal -> \"nullptr\"\n5126         #  | user-defined-literal\n5127 \n5128         def _udl(literal: ASTLiteral) -> ASTLiteral:\n5129             if not self.match(udl_identifier_re):\n5130                 return literal\n5131             # hmm, should we care if it's a keyword?\n5132             # it looks like GCC does not disallow keywords\n5133             ident = ASTIdentifier(self.matched_text)\n5134             return ASTUserDefinedLiteral(literal, ident)\n5135 \n5136         self.skip_ws()\n5137         if self.skip_word('nullptr'):\n5138             return ASTPointerLiteral()\n5139         if self.skip_word('true'):\n5140             return ASTBooleanLiteral(True)\n5141         if self.skip_word('false'):\n5142             return ASTBooleanLiteral(False)\n5143         pos = self.pos\n5144         if self.match(float_literal_re):\n5145             hasSuffix = self.match(float_literal_suffix_re)\n5146             floatLit = ASTNumberLiteral(self.definition[pos:self.pos])\n5147             if hasSuffix:\n5148                 return floatLit\n5149             else:\n5150                 return _udl(floatLit)\n5151         for regex in [binary_literal_re, hex_literal_re,\n5152                       integer_literal_re, octal_literal_re]:\n5153             if self.match(regex):\n5154                 hasSuffix = self.match(integers_literal_suffix_re)\n5155                 intLit = ASTNumberLiteral(self.definition[pos:self.pos])\n5156                 if hasSuffix:\n5157                     return intLit\n5158                 else:\n5159                     return _udl(intLit)\n5160 \n5161         string = self._parse_string()\n5162         if string is not None:\n5163             return _udl(ASTStringLiteral(string))\n5164 \n5165         # character-literal\n5166         if self.match(char_literal_re):\n5167             prefix = self.last_match.group(1)  # may be None when no prefix\n5168             data = self.last_match.group(2)\n5169             try:\n5170                 charLit = ASTCharLiteral(prefix, data)\n5171             except UnicodeDecodeError as e:\n5172                 self.fail(\"Can not handle character literal. Internal error was: %s\" % e)\n5173             except UnsupportedMultiCharacterCharLiteral:\n5174                 self.fail(\"Can not handle character literal\"\n5175                           \" resulting in multiple decoded characters.\")\n5176             return _udl(charLit)\n5177         return None\n5178 \n5179     def _parse_fold_or_paren_expression(self) -> ASTExpression:\n5180         # \"(\" expression \")\"\n5181         # fold-expression\n5182         # -> ( cast-expression fold-operator ... )\n5183         #  | ( ... fold-operator cast-expression )\n5184         #  | ( cast-expression fold-operator ... fold-operator cast-expression\n5185         if self.current_char != '(':\n5186             return None\n5187         self.pos += 1\n5188         self.skip_ws()\n5189         if self.skip_string_and_ws(\"...\"):\n5190             # ( ... fold-operator cast-expression )\n5191             if not self.match(_fold_operator_re):\n5192                 self.fail(\"Expected fold operator after '...' in fold expression.\")\n5193             op = self.matched_text\n5194             rightExpr = self._parse_cast_expression()\n5195             if not self.skip_string(')'):\n5196                 self.fail(\"Expected ')' in end of fold expression.\")\n5197             return ASTFoldExpr(None, op, rightExpr)\n5198         # try first parsing a unary right fold, or a binary fold\n5199         pos = self.pos\n5200         try:\n5201             self.skip_ws()\n5202             leftExpr = self._parse_cast_expression()\n5203             self.skip_ws()\n5204             if not self.match(_fold_operator_re):\n5205                 self.fail(\"Expected fold operator after left expression in fold expression.\")\n5206             op = self.matched_text\n5207             self.skip_ws()\n5208             if not self.skip_string_and_ws('...'):\n5209                 self.fail(\"Expected '...' after fold operator in fold expression.\")\n5210         except DefinitionError as eFold:\n5211             self.pos = pos\n5212             # fall back to a paren expression\n5213             try:\n5214                 res = self._parse_expression()\n5215                 self.skip_ws()\n5216                 if not self.skip_string(')'):\n5217                     self.fail(\"Expected ')' in end of parenthesized expression.\")\n5218             except DefinitionError as eExpr:\n5219                 raise self._make_multi_error([\n5220                     (eFold, \"If fold expression\"),\n5221                     (eExpr, \"If parenthesized expression\")\n5222                 ], \"Error in fold expression or parenthesized expression.\") from eExpr\n5223             return ASTParenExpr(res)\n5224         # now it definitely is a fold expression\n5225         if self.skip_string(')'):\n5226             return ASTFoldExpr(leftExpr, op, None)\n5227         if not self.match(_fold_operator_re):\n5228             self.fail(\"Expected fold operator or ')' after '...' in fold expression.\")\n5229         if op != self.matched_text:\n5230             self.fail(\"Operators are different in binary fold: '%s' and '%s'.\"\n5231                       % (op, self.matched_text))\n5232         rightExpr = self._parse_cast_expression()\n5233         self.skip_ws()\n5234         if not self.skip_string(')'):\n5235             self.fail(\"Expected ')' to end binary fold expression.\")\n5236         return ASTFoldExpr(leftExpr, op, rightExpr)\n5237 \n5238     def _parse_primary_expression(self) -> ASTExpression:\n5239         # literal\n5240         # \"this\"\n5241         # lambda-expression\n5242         # \"(\" expression \")\"\n5243         # fold-expression\n5244         # id-expression -> we parse this with _parse_nested_name\n5245         self.skip_ws()\n5246         res: ASTExpression = self._parse_literal()\n5247         if res is not None:\n5248             return res\n5249         self.skip_ws()\n5250         if self.skip_word(\"this\"):\n5251             return ASTThisLiteral()\n5252         # TODO: try lambda expression\n5253         res = self._parse_fold_or_paren_expression()\n5254         if res is not None:\n5255             return res\n5256         nn = self._parse_nested_name()\n5257         if nn is not None:\n5258             return ASTIdExpression(nn)\n5259         return None\n5260 \n5261     def _parse_initializer_list(self, name: str, open: str, close: str\n5262                                 ) -> Tuple[List[Union[ASTExpression,\n5263                                                       ASTBracedInitList]],\n5264                                            bool]:\n5265         # Parse open and close with the actual initializer-list in between\n5266         # -> initializer-clause '...'[opt]\n5267         #  | initializer-list ',' initializer-clause '...'[opt]\n5268         self.skip_ws()\n5269         if not self.skip_string_and_ws(open):\n5270             return None, None\n5271         if self.skip_string(close):\n5272             return [], False\n5273 \n5274         exprs: List[Union[ASTExpression, ASTBracedInitList]] = []\n5275         trailingComma = False\n5276         while True:\n5277             self.skip_ws()\n5278             expr = self._parse_initializer_clause()\n5279             self.skip_ws()\n5280             if self.skip_string('...'):\n5281                 exprs.append(ASTPackExpansionExpr(expr))\n5282             else:\n5283                 exprs.append(expr)\n5284             self.skip_ws()\n5285             if self.skip_string(close):\n5286                 break\n5287             if not self.skip_string_and_ws(','):\n5288                 self.fail(\"Error in %s, expected ',' or '%s'.\" % (name, close))\n5289             if self.current_char == close and close == '}':\n5290                 self.pos += 1\n5291                 trailingComma = True\n5292                 break\n5293         return exprs, trailingComma\n5294 \n5295     def _parse_paren_expression_list(self) -> ASTParenExprList:\n5296         # -> '(' expression-list ')'\n5297         # though, we relax it to also allow empty parens\n5298         # as it's needed in some cases\n5299         #\n5300         # expression-list\n5301         # -> initializer-list\n5302         exprs, trailingComma = self._parse_initializer_list(\"parenthesized expression-list\",\n5303                                                             '(', ')')\n5304         if exprs is None:\n5305             return None\n5306         return ASTParenExprList(exprs)\n5307 \n5308     def _parse_initializer_clause(self) -> Union[ASTExpression, ASTBracedInitList]:\n5309         bracedInitList = self._parse_braced_init_list()\n5310         if bracedInitList is not None:\n5311             return bracedInitList\n5312         return self._parse_assignment_expression(inTemplate=False)\n5313 \n5314     def _parse_braced_init_list(self) -> ASTBracedInitList:\n5315         # -> '{' initializer-list ','[opt] '}'\n5316         #  | '{' '}'\n5317         exprs, trailingComma = self._parse_initializer_list(\"braced-init-list\", '{', '}')\n5318         if exprs is None:\n5319             return None\n5320         return ASTBracedInitList(exprs, trailingComma)\n5321 \n5322     def _parse_expression_list_or_braced_init_list(\n5323         self\n5324     ) -> Union[ASTParenExprList, ASTBracedInitList]:\n5325         paren = self._parse_paren_expression_list()\n5326         if paren is not None:\n5327             return paren\n5328         return self._parse_braced_init_list()\n5329 \n5330     def _parse_postfix_expression(self) -> ASTPostfixExpr:\n5331         # -> primary\n5332         #  | postfix \"[\" expression \"]\"\n5333         #  | postfix \"[\" braced-init-list [opt] \"]\"\n5334         #  | postfix \"(\" expression-list [opt] \")\"\n5335         #  | postfix \".\" \"template\" [opt] id-expression\n5336         #  | postfix \"->\" \"template\" [opt] id-expression\n5337         #  | postfix \".\" pseudo-destructor-name\n5338         #  | postfix \"->\" pseudo-destructor-name\n5339         #  | postfix \"++\"\n5340         #  | postfix \"--\"\n5341         #  | simple-type-specifier \"(\" expression-list [opt] \")\"\n5342         #  | simple-type-specifier braced-init-list\n5343         #  | typename-specifier \"(\" expression-list [opt] \")\"\n5344         #  | typename-specifier braced-init-list\n5345         #  | \"dynamic_cast\" \"<\" type-id \">\" \"(\" expression \")\"\n5346         #  | \"static_cast\" \"<\" type-id \">\" \"(\" expression \")\"\n5347         #  | \"reinterpret_cast\" \"<\" type-id \">\" \"(\" expression \")\"\n5348         #  | \"const_cast\" \"<\" type-id \">\" \"(\" expression \")\"\n5349         #  | \"typeid\" \"(\" expression \")\"\n5350         #  | \"typeid\" \"(\" type-id \")\"\n5351 \n5352         prefixType = None\n5353         prefix: Any = None\n5354         self.skip_ws()\n5355 \n5356         cast = None\n5357         for c in _id_explicit_cast:\n5358             if self.skip_word_and_ws(c):\n5359                 cast = c\n5360                 break\n5361         if cast is not None:\n5362             prefixType = \"cast\"\n5363             if not self.skip_string(\"<\"):\n5364                 self.fail(\"Expected '<' after '%s'.\" % cast)\n5365             typ = self._parse_type(False)\n5366             self.skip_ws()\n5367             if not self.skip_string_and_ws(\">\"):\n5368                 self.fail(\"Expected '>' after type in '%s'.\" % cast)\n5369             if not self.skip_string(\"(\"):\n5370                 self.fail(\"Expected '(' in '%s'.\" % cast)\n5371 \n5372             def parser() -> ASTExpression:\n5373                 return self._parse_expression()\n5374             expr = self._parse_expression_fallback([')'], parser)\n5375             self.skip_ws()\n5376             if not self.skip_string(\")\"):\n5377                 self.fail(\"Expected ')' to end '%s'.\" % cast)\n5378             prefix = ASTExplicitCast(cast, typ, expr)\n5379         elif self.skip_word_and_ws(\"typeid\"):\n5380             prefixType = \"typeid\"\n5381             if not self.skip_string_and_ws('('):\n5382                 self.fail(\"Expected '(' after 'typeid'.\")\n5383             pos = self.pos\n5384             try:\n5385                 typ = self._parse_type(False)\n5386                 prefix = ASTTypeId(typ, isType=True)\n5387                 if not self.skip_string(')'):\n5388                     self.fail(\"Expected ')' to end 'typeid' of type.\")\n5389             except DefinitionError as eType:\n5390                 self.pos = pos\n5391                 try:\n5392 \n5393                     def parser() -> ASTExpression:\n5394                         return self._parse_expression()\n5395                     expr = self._parse_expression_fallback([')'], parser)\n5396                     prefix = ASTTypeId(expr, isType=False)\n5397                     if not self.skip_string(')'):\n5398                         self.fail(\"Expected ')' to end 'typeid' of expression.\")\n5399                 except DefinitionError as eExpr:\n5400                     self.pos = pos\n5401                     header = \"Error in 'typeid(...)'.\"\n5402                     header += \" Expected type or expression.\"\n5403                     errors = []\n5404                     errors.append((eType, \"If type\"))\n5405                     errors.append((eExpr, \"If expression\"))\n5406                     raise self._make_multi_error(errors, header) from eExpr\n5407         else:  # a primary expression or a type\n5408             pos = self.pos\n5409             try:\n5410                 prefix = self._parse_primary_expression()\n5411                 prefixType = 'expr'\n5412             except DefinitionError as eOuter:\n5413                 self.pos = pos\n5414                 try:\n5415                     # we are potentially casting, so save parens for us\n5416                     # TODO: hmm, would we need to try both with operatorCast and with None?\n5417                     prefix = self._parse_type(False, 'operatorCast')\n5418                     prefixType = 'typeOperatorCast'\n5419                     #  | simple-type-specifier \"(\" expression-list [opt] \")\"\n5420                     #  | simple-type-specifier braced-init-list\n5421                     #  | typename-specifier \"(\" expression-list [opt] \")\"\n5422                     #  | typename-specifier braced-init-list\n5423                     self.skip_ws()\n5424                     if self.current_char != '(' and self.current_char != '{':\n5425                         self.fail(\"Expecting '(' or '{' after type in cast expression.\")\n5426                 except DefinitionError as eInner:\n5427                     self.pos = pos\n5428                     header = \"Error in postfix expression,\"\n5429                     header += \" expected primary expression or type.\"\n5430                     errors = []\n5431                     errors.append((eOuter, \"If primary expression\"))\n5432                     errors.append((eInner, \"If type\"))\n5433                     raise self._make_multi_error(errors, header) from eInner\n5434 \n5435         # and now parse postfixes\n5436         postFixes: List[ASTPostfixOp] = []\n5437         while True:\n5438             self.skip_ws()\n5439             if prefixType in ('expr', 'cast', 'typeid'):\n5440                 if self.skip_string_and_ws('['):\n5441                     expr = self._parse_expression()\n5442                     self.skip_ws()\n5443                     if not self.skip_string(']'):\n5444                         self.fail(\"Expected ']' in end of postfix expression.\")\n5445                     postFixes.append(ASTPostfixArray(expr))\n5446                     continue\n5447                 if self.skip_string('.'):\n5448                     if self.skip_string('*'):\n5449                         # don't steal the dot\n5450                         self.pos -= 2\n5451                     elif self.skip_string('..'):\n5452                         # don't steal the dot\n5453                         self.pos -= 3\n5454                     else:\n5455                         name = self._parse_nested_name()\n5456                         postFixes.append(ASTPostfixMember(name))\n5457                         continue\n5458                 if self.skip_string('->'):\n5459                     if self.skip_string('*'):\n5460                         # don't steal the arrow\n5461                         self.pos -= 3\n5462                     else:\n5463                         name = self._parse_nested_name()\n5464                         postFixes.append(ASTPostfixMemberOfPointer(name))\n5465                         continue\n5466                 if self.skip_string('++'):\n5467                     postFixes.append(ASTPostfixInc())\n5468                     continue\n5469                 if self.skip_string('--'):\n5470                     postFixes.append(ASTPostfixDec())\n5471                     continue\n5472             lst = self._parse_expression_list_or_braced_init_list()\n5473             if lst is not None:\n5474                 postFixes.append(ASTPostfixCallExpr(lst))\n5475                 continue\n5476             break\n5477         return ASTPostfixExpr(prefix, postFixes)\n5478 \n5479     def _parse_unary_expression(self) -> ASTExpression:\n5480         # -> postfix\n5481         #  | \"++\" cast\n5482         #  | \"--\" cast\n5483         #  | unary-operator cast -> (* | & | + | - | ! | ~) cast\n5484         # The rest:\n5485         #  | \"sizeof\" unary\n5486         #  | \"sizeof\" \"(\" type-id \")\"\n5487         #  | \"sizeof\" \"...\" \"(\" identifier \")\"\n5488         #  | \"alignof\" \"(\" type-id \")\"\n5489         #  | noexcept-expression -> noexcept \"(\" expression \")\"\n5490         #  | new-expression\n5491         #  | delete-expression\n5492         self.skip_ws()\n5493         for op in _expression_unary_ops:\n5494             # TODO: hmm, should we be able to backtrack here?\n5495             if op[0] in 'cn':\n5496                 res = self.skip_word(op)\n5497             else:\n5498                 res = self.skip_string(op)\n5499             if res:\n5500                 expr = self._parse_cast_expression()\n5501                 return ASTUnaryOpExpr(op, expr)\n5502         if self.skip_word_and_ws('sizeof'):\n5503             if self.skip_string_and_ws('...'):\n5504                 if not self.skip_string_and_ws('('):\n5505                     self.fail(\"Expecting '(' after 'sizeof...'.\")\n5506                 if not self.match(identifier_re):\n5507                     self.fail(\"Expecting identifier for 'sizeof...'.\")\n5508                 ident = ASTIdentifier(self.matched_text)\n5509                 self.skip_ws()\n5510                 if not self.skip_string(\")\"):\n5511                     self.fail(\"Expecting ')' to end 'sizeof...'.\")\n5512                 return ASTSizeofParamPack(ident)\n5513             if self.skip_string_and_ws('('):\n5514                 typ = self._parse_type(named=False)\n5515                 self.skip_ws()\n5516                 if not self.skip_string(')'):\n5517                     self.fail(\"Expecting ')' to end 'sizeof'.\")\n5518                 return ASTSizeofType(typ)\n5519             expr = self._parse_unary_expression()\n5520             return ASTSizeofExpr(expr)\n5521         if self.skip_word_and_ws('alignof'):\n5522             if not self.skip_string_and_ws('('):\n5523                 self.fail(\"Expecting '(' after 'alignof'.\")\n5524             typ = self._parse_type(named=False)\n5525             self.skip_ws()\n5526             if not self.skip_string(')'):\n5527                 self.fail(\"Expecting ')' to end 'alignof'.\")\n5528             return ASTAlignofExpr(typ)\n5529         if self.skip_word_and_ws('noexcept'):\n5530             if not self.skip_string_and_ws('('):\n5531                 self.fail(\"Expecting '(' after 'noexcept'.\")\n5532             expr = self._parse_expression()\n5533             self.skip_ws()\n5534             if not self.skip_string(')'):\n5535                 self.fail(\"Expecting ')' to end 'noexcept'.\")\n5536             return ASTNoexceptExpr(expr)\n5537         # new-expression\n5538         pos = self.pos\n5539         rooted = self.skip_string('::')\n5540         self.skip_ws()\n5541         if not self.skip_word_and_ws('new'):\n5542             self.pos = pos\n5543         else:\n5544             # new-placement[opt] new-type-id new-initializer[opt]\n5545             # new-placement[opt] ( type-id ) new-initializer[opt]\n5546             isNewTypeId = True\n5547             if self.skip_string_and_ws('('):\n5548                 # either this is a new-placement or it's the second production\n5549                 # without placement, and it's actually the ( type-id ) part\n5550                 self.fail(\"Sorry, neither new-placement nor parenthesised type-id \"\n5551                           \"in new-epression is supported yet.\")\n5552                 # set isNewTypeId = False if it's (type-id)\n5553             if isNewTypeId:\n5554                 declSpecs = self._parse_decl_specs(outer=None)\n5555                 decl = self._parse_declarator(named=False, paramMode=\"new\")\n5556             else:\n5557                 self.fail(\"Sorry, parenthesised type-id in new expression not yet supported.\")\n5558             lst = self._parse_expression_list_or_braced_init_list()\n5559             return ASTNewExpr(rooted, isNewTypeId, ASTType(declSpecs, decl), lst)\n5560         # delete-expression\n5561         pos = self.pos\n5562         rooted = self.skip_string('::')\n5563         self.skip_ws()\n5564         if not self.skip_word_and_ws('delete'):\n5565             self.pos = pos\n5566         else:\n5567             array = self.skip_string_and_ws('[')\n5568             if array and not self.skip_string_and_ws(']'):\n5569                 self.fail(\"Expected ']' in array delete-expression.\")\n5570             expr = self._parse_cast_expression()\n5571             return ASTDeleteExpr(rooted, array, expr)\n5572         return self._parse_postfix_expression()\n5573 \n5574     def _parse_cast_expression(self) -> ASTExpression:\n5575         # -> unary  | \"(\" type-id \")\" cast\n5576         pos = self.pos\n5577         self.skip_ws()\n5578         if self.skip_string('('):\n5579             try:\n5580                 typ = self._parse_type(False)\n5581                 if not self.skip_string(')'):\n5582                     self.fail(\"Expected ')' in cast expression.\")\n5583                 expr = self._parse_cast_expression()\n5584                 return ASTCastExpr(typ, expr)\n5585             except DefinitionError as exCast:\n5586                 self.pos = pos\n5587                 try:\n5588                     return self._parse_unary_expression()\n5589                 except DefinitionError as exUnary:\n5590                     errs = []\n5591                     errs.append((exCast, \"If type cast expression\"))\n5592                     errs.append((exUnary, \"If unary expression\"))\n5593                     raise self._make_multi_error(errs,\n5594                                                  \"Error in cast expression.\") from exUnary\n5595         else:\n5596             return self._parse_unary_expression()\n5597 \n5598     def _parse_logical_or_expression(self, inTemplate: bool) -> ASTExpression:\n5599         # logical-or     = logical-and      ||\n5600         # logical-and    = inclusive-or     &&\n5601         # inclusive-or   = exclusive-or     |\n5602         # exclusive-or   = and              ^\n5603         # and            = equality         &\n5604         # equality       = relational       ==, !=\n5605         # relational     = shift            <, >, <=, >=, <=>\n5606         # shift          = additive         <<, >>\n5607         # additive       = multiplicative   +, -\n5608         # multiplicative = pm               *, /, %\n5609         # pm             = cast             .*, ->*\n5610         def _parse_bin_op_expr(self: DefinitionParser,\n5611                                opId: int, inTemplate: bool) -> ASTExpression:\n5612             if opId + 1 == len(_expression_bin_ops):\n5613                 def parser(inTemplate: bool) -> ASTExpression:\n5614                     return self._parse_cast_expression()\n5615             else:\n5616                 def parser(inTemplate: bool) -> ASTExpression:\n5617                     return _parse_bin_op_expr(self, opId + 1, inTemplate=inTemplate)\n5618             exprs = []\n5619             ops = []\n5620             exprs.append(parser(inTemplate=inTemplate))\n5621             while True:\n5622                 self.skip_ws()\n5623                 if inTemplate and self.current_char == '>':\n5624                     break\n5625                 pos = self.pos\n5626                 oneMore = False\n5627                 for op in _expression_bin_ops[opId]:\n5628                     if op[0] in 'abcnox':\n5629                         if not self.skip_word(op):\n5630                             continue\n5631                     else:\n5632                         if not self.skip_string(op):\n5633                             continue\n5634                     if op == '&' and self.current_char == '&':\n5635                         # don't split the && 'token'\n5636                         self.pos -= 1\n5637                         # and btw. && has lower precedence, so we are done\n5638                         break\n5639                     try:\n5640                         expr = parser(inTemplate=inTemplate)\n5641                         exprs.append(expr)\n5642                         ops.append(op)\n5643                         oneMore = True\n5644                         break\n5645                     except DefinitionError:\n5646                         self.pos = pos\n5647                 if not oneMore:\n5648                     break\n5649             return ASTBinOpExpr(exprs, ops)\n5650         return _parse_bin_op_expr(self, 0, inTemplate=inTemplate)\n5651 \n5652     def _parse_conditional_expression_tail(self, orExprHead: ASTExpression,\n5653                                            inTemplate: bool) -> Optional[ASTConditionalExpr]:\n5654         # Consumes the orExprHead on success.\n5655 \n5656         # -> \"?\" expression \":\" assignment-expression\n5657         self.skip_ws()\n5658         if not self.skip_string(\"?\"):\n5659             return None\n5660         thenExpr = self._parse_expression()\n5661         self.skip_ws()\n5662         if not self.skip_string(\":\"):\n5663             self.fail('Expected \":\" after then-expression in conditional expression.')\n5664         elseExpr = self._parse_assignment_expression(inTemplate)\n5665         return ASTConditionalExpr(orExprHead, thenExpr, elseExpr)\n5666 \n5667     def _parse_assignment_expression(self, inTemplate: bool) -> ASTExpression:\n5668         # -> conditional-expression\n5669         #  | logical-or-expression assignment-operator initializer-clause\n5670         #  | yield-expression -> \"co_yield\" assignment-expression\n5671         #                      | \"co_yield\" braced-init-list\n5672         #  | throw-expression -> \"throw\" assignment-expression[opt]\n5673         # TODO: yield-expression\n5674         # TODO: throw-expression\n5675 \n5676         # Now we have (after expanding conditional-expression:\n5677         #     logical-or-expression\n5678         #   | logical-or-expression \"?\" expression \":\" assignment-expression\n5679         #   | logical-or-expression assignment-operator initializer-clause\n5680         leftExpr = self._parse_logical_or_expression(inTemplate=inTemplate)\n5681         # the ternary operator\n5682         condExpr = self._parse_conditional_expression_tail(leftExpr, inTemplate)\n5683         if condExpr is not None:\n5684             return condExpr\n5685         # and actual assignment\n5686         for op in _expression_assignment_ops:\n5687             if op[0] in 'anox':\n5688                 if not self.skip_word(op):\n5689                     continue\n5690             else:\n5691                 if not self.skip_string(op):\n5692                     continue\n5693             rightExpr = self._parse_initializer_clause()\n5694             return ASTAssignmentExpr(leftExpr, op, rightExpr)\n5695         # just a logical-or-expression\n5696         return leftExpr\n5697 \n5698     def _parse_constant_expression(self, inTemplate: bool) -> ASTExpression:\n5699         # -> conditional-expression ->\n5700         #    logical-or-expression\n5701         #  | logical-or-expression \"?\" expression \":\" assignment-expression\n5702         orExpr = self._parse_logical_or_expression(inTemplate=inTemplate)\n5703         condExpr = self._parse_conditional_expression_tail(orExpr, inTemplate)\n5704         if condExpr is not None:\n5705             return condExpr\n5706         return orExpr\n5707 \n5708     def _parse_expression(self) -> ASTExpression:\n5709         # -> assignment-expression\n5710         #  | expression \",\" assignment-expression\n5711         exprs = [self._parse_assignment_expression(inTemplate=False)]\n5712         while True:\n5713             self.skip_ws()\n5714             if not self.skip_string(','):\n5715                 break\n5716             exprs.append(self._parse_assignment_expression(inTemplate=False))\n5717         if len(exprs) == 1:\n5718             return exprs[0]\n5719         else:\n5720             return ASTCommaExpr(exprs)\n5721 \n5722     def _parse_expression_fallback(self, end: List[str],\n5723                                    parser: Callable[[], ASTExpression],\n5724                                    allow: bool = True) -> ASTExpression:\n5725         # Stupidly \"parse\" an expression.\n5726         # 'end' should be a list of characters which ends the expression.\n5727 \n5728         # first try to use the provided parser\n5729         prevPos = self.pos\n5730         try:\n5731             return parser()\n5732         except DefinitionError as e:\n5733             # some places (e.g., template parameters) we really don't want to use fallback,\n5734             # and for testing we may want to globally disable it\n5735             if not allow or not self.allowFallbackExpressionParsing:\n5736                 raise\n5737             self.warn(\"Parsing of expression failed. Using fallback parser.\"\n5738                       \" Error was:\\n%s\" % e)\n5739             self.pos = prevPos\n5740         # and then the fallback scanning\n5741         assert end is not None\n5742         self.skip_ws()\n5743         startPos = self.pos\n5744         if self.match(_string_re):\n5745             value = self.matched_text\n5746         else:\n5747             # TODO: add handling of more bracket-like things, and quote handling\n5748             brackets = {'(': ')', '{': '}', '[': ']', '<': '>'}\n5749             symbols: List[str] = []\n5750             while not self.eof:\n5751                 if (len(symbols) == 0 and self.current_char in end):\n5752                     break\n5753                 if self.current_char in brackets.keys():\n5754                     symbols.append(brackets[self.current_char])\n5755                 elif len(symbols) > 0 and self.current_char == symbols[-1]:\n5756                     symbols.pop()\n5757                 self.pos += 1\n5758             if len(end) > 0 and self.eof:\n5759                 self.fail(\"Could not find end of expression starting at %d.\"\n5760                           % startPos)\n5761             value = self.definition[startPos:self.pos].strip()\n5762         return ASTFallbackExpr(value.strip())\n5763 \n5764     # ==========================================================================\n5765 \n5766     def _parse_operator(self) -> ASTOperator:\n5767         self.skip_ws()\n5768         # adapted from the old code\n5769         # yay, a regular operator definition\n5770         if self.match(_operator_re):\n5771             return ASTOperatorBuildIn(self.matched_text)\n5772 \n5773         # new/delete operator?\n5774         for op in 'new', 'delete':\n5775             if not self.skip_word(op):\n5776                 continue\n5777             self.skip_ws()\n5778             if self.skip_string('['):\n5779                 self.skip_ws()\n5780                 if not self.skip_string(']'):\n5781                     self.fail('Expected \"]\" after  \"operator ' + op + '[\"')\n5782                 op += '[]'\n5783             return ASTOperatorBuildIn(op)\n5784 \n5785         # user-defined literal?\n5786         if self.skip_string('\"\"'):\n5787             self.skip_ws()\n5788             if not self.match(identifier_re):\n5789                 self.fail(\"Expected user-defined literal suffix.\")\n5790             identifier = ASTIdentifier(self.matched_text)\n5791             return ASTOperatorLiteral(identifier)\n5792 \n5793         # oh well, looks like a cast operator definition.\n5794         # In that case, eat another type.\n5795         type = self._parse_type(named=False, outer=\"operatorCast\")\n5796         return ASTOperatorType(type)\n5797 \n5798     def _parse_template_argument_list(self) -> ASTTemplateArgs:\n5799         # template-argument-list: (but we include the < and > here\n5800         #    template-argument ...[opt]\n5801         #    template-argument-list, template-argument ...[opt]\n5802         # template-argument:\n5803         #    constant-expression\n5804         #    type-id\n5805         #    id-expression\n5806         self.skip_ws()\n5807         if not self.skip_string_and_ws('<'):\n5808             return None\n5809         if self.skip_string('>'):\n5810             return ASTTemplateArgs([], False)\n5811         prevErrors = []\n5812         templateArgs: List[Union[ASTType, ASTTemplateArgConstant]] = []\n5813         packExpansion = False\n5814         while 1:\n5815             pos = self.pos\n5816             parsedComma = False\n5817             parsedEnd = False\n5818             try:\n5819                 type = self._parse_type(named=False)\n5820                 self.skip_ws()\n5821                 if self.skip_string_and_ws('...'):\n5822                     packExpansion = True\n5823                     parsedEnd = True\n5824                     if not self.skip_string('>'):\n5825                         self.fail('Expected \">\" after \"...\" in template argument list.')\n5826                 elif self.skip_string('>'):\n5827                     parsedEnd = True\n5828                 elif self.skip_string(','):\n5829                     parsedComma = True\n5830                 else:\n5831                     self.fail('Expected \"...>\", \">\" or \",\" in template argument list.')\n5832                 templateArgs.append(type)\n5833             except DefinitionError as e:\n5834                 prevErrors.append((e, \"If type argument\"))\n5835                 self.pos = pos\n5836                 try:\n5837                     value = self._parse_constant_expression(inTemplate=True)\n5838                     self.skip_ws()\n5839                     if self.skip_string_and_ws('...'):\n5840                         packExpansion = True\n5841                         parsedEnd = True\n5842                         if not self.skip_string('>'):\n5843                             self.fail('Expected \">\" after \"...\" in template argument list.')\n5844                     elif self.skip_string('>'):\n5845                         parsedEnd = True\n5846                     elif self.skip_string(','):\n5847                         parsedComma = True\n5848                     else:\n5849                         self.fail('Expected \"...>\", \">\" or \",\" in template argument list.')\n5850                     templateArgs.append(ASTTemplateArgConstant(value))\n5851                 except DefinitionError as e:\n5852                     self.pos = pos\n5853                     prevErrors.append((e, \"If non-type argument\"))\n5854                     header = \"Error in parsing template argument list.\"\n5855                     raise self._make_multi_error(prevErrors, header) from e\n5856             if parsedEnd:\n5857                 assert not parsedComma\n5858                 break\n5859             else:\n5860                 assert not packExpansion\n5861         return ASTTemplateArgs(templateArgs, packExpansion)\n5862 \n5863     def _parse_nested_name(self, memberPointer: bool = False) -> ASTNestedName:\n5864         names: List[ASTNestedNameElement] = []\n5865         templates: List[bool] = []\n5866 \n5867         self.skip_ws()\n5868         rooted = False\n5869         if self.skip_string('::'):\n5870             rooted = True\n5871         while 1:\n5872             self.skip_ws()\n5873             if len(names) > 0:\n5874                 template = self.skip_word_and_ws('template')\n5875             else:\n5876                 template = False\n5877             templates.append(template)\n5878             identOrOp: Union[ASTIdentifier, ASTOperator] = None\n5879             if self.skip_word_and_ws('operator'):\n5880                 identOrOp = self._parse_operator()\n5881             else:\n5882                 if not self.match(identifier_re):\n5883                     if memberPointer and len(names) > 0:\n5884                         templates.pop()\n5885                         break\n5886                     self.fail(\"Expected identifier in nested name.\")\n5887                 identifier = self.matched_text\n5888                 # make sure there isn't a keyword\n5889                 if identifier in _keywords:\n5890                     self.fail(\"Expected identifier in nested name, \"\n5891                               \"got keyword: %s\" % identifier)\n5892                 identOrOp = ASTIdentifier(identifier)\n5893             # try greedily to get template arguments,\n5894             # but otherwise a < might be because we are in an expression\n5895             pos = self.pos\n5896             try:\n5897                 templateArgs = self._parse_template_argument_list()\n5898             except DefinitionError as ex:\n5899                 self.pos = pos\n5900                 templateArgs = None\n5901                 self.otherErrors.append(ex)\n5902             names.append(ASTNestedNameElement(identOrOp, templateArgs))\n5903 \n5904             self.skip_ws()\n5905             if not self.skip_string('::'):\n5906                 if memberPointer:\n5907                     self.fail(\"Expected '::' in pointer to member (function).\")\n5908                 break\n5909         return ASTNestedName(names, templates, rooted)\n5910 \n5911     # ==========================================================================\n5912 \n5913     def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental:\n5914         modifier: Optional[str] = None\n5915         signedness: Optional[str] = None\n5916         width: List[str] = []\n5917         typ: Optional[str] = None\n5918         names: List[str] = []  # the parsed sequence\n5919 \n5920         self.skip_ws()\n5921         while self.match(_simple_type_specifiers_re):\n5922             t = self.matched_text\n5923             names.append(t)\n5924             if t in ('auto', 'void', 'bool',\n5925                      'char', 'wchar_t', 'char8_t', 'char16_t', 'char32_t',\n5926                      'int', '__int64', '__int128',\n5927                      'float', 'double',\n5928                      '__float80', '_Float64x', '__float128', '_Float128'):\n5929                 if typ is not None:\n5930                     self.fail(\"Can not have both {} and {}.\".format(t, typ))\n5931                 typ = t\n5932             elif t in ('signed', 'unsigned'):\n5933                 if signedness is not None:\n5934                     self.fail(\"Can not have both {} and {}.\".format(t, signedness))\n5935                 signedness = t\n5936             elif t == 'short':\n5937                 if len(width) != 0:\n5938                     self.fail(\"Can not have both {} and {}.\".format(t, width[0]))\n5939                 width.append(t)\n5940             elif t == 'long':\n5941                 if len(width) != 0 and width[0] != 'long':\n5942                     self.fail(\"Can not have both {} and {}.\".format(t, width[0]))\n5943                 width.append(t)\n5944             elif t in ('_Imaginary', '_Complex'):\n5945                 if modifier is not None:\n5946                     self.fail(\"Can not have both {} and {}.\".format(t, modifier))\n5947                 modifier = t\n5948             self.skip_ws()\n5949         if len(names) == 0:\n5950             return None\n5951 \n5952         if typ in ('auto', 'void', 'bool',\n5953                    'wchar_t', 'char8_t', 'char16_t', 'char32_t',\n5954                    '__float80', '_Float64x', '__float128', '_Float128'):\n5955             if modifier is not None:\n5956                 self.fail(\"Can not have both {} and {}.\".format(typ, modifier))\n5957             if signedness is not None:\n5958                 self.fail(\"Can not have both {} and {}.\".format(typ, signedness))\n5959             if len(width) != 0:\n5960                 self.fail(\"Can not have both {} and {}.\".format(typ, ' '.join(width)))\n5961         elif typ == 'char':\n5962             if modifier is not None:\n5963                 self.fail(\"Can not have both {} and {}.\".format(typ, modifier))\n5964             if len(width) != 0:\n5965                 self.fail(\"Can not have both {} and {}.\".format(typ, ' '.join(width)))\n5966         elif typ == 'int':\n5967             if modifier is not None:\n5968                 self.fail(\"Can not have both {} and {}.\".format(typ, modifier))\n5969         elif typ in ('__int64', '__int128'):\n5970             if modifier is not None:\n5971                 self.fail(\"Can not have both {} and {}.\".format(typ, modifier))\n5972             if len(width) != 0:\n5973                 self.fail(\"Can not have both {} and {}.\".format(typ, ' '.join(width)))\n5974         elif typ == 'float':\n5975             if signedness is not None:\n5976                 self.fail(\"Can not have both {} and {}.\".format(typ, signedness))\n5977             if len(width) != 0:\n5978                 self.fail(\"Can not have both {} and {}.\".format(typ, ' '.join(width)))\n5979         elif typ == 'double':\n5980             if signedness is not None:\n5981                 self.fail(\"Can not have both {} and {}.\".format(typ, signedness))\n5982             if len(width) > 1:\n5983                 self.fail(\"Can not have both {} and {}.\".format(typ, ' '.join(width)))\n5984             if len(width) == 1 and width[0] != 'long':\n5985                 self.fail(\"Can not have both {} and {}.\".format(typ, ' '.join(width)))\n5986         elif typ is None:\n5987             if modifier is not None:\n5988                 self.fail(\"Can not have {} without a floating point type.\".format(modifier))\n5989         else:\n5990             assert False, \"Unhandled type {}\".format(typ)\n5991 \n5992         canonNames: List[str] = []\n5993         if modifier is not None:\n5994             canonNames.append(modifier)\n5995         if signedness is not None:\n5996             canonNames.append(signedness)\n5997         canonNames.extend(width)\n5998         if typ is not None:\n5999             canonNames.append(typ)\n6000         return ASTTrailingTypeSpecFundamental(names, canonNames)\n6001 \n6002     def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:\n6003         # fundamental types, https://en.cppreference.com/w/cpp/language/type\n6004         # and extensions\n6005         self.skip_ws()\n6006         res = self._parse_simple_type_specifiers()\n6007         if res is not None:\n6008             return res\n6009 \n6010         # decltype\n6011         self.skip_ws()\n6012         if self.skip_word_and_ws('decltype'):\n6013             if not self.skip_string_and_ws('('):\n6014                 self.fail(\"Expected '(' after 'decltype'.\")\n6015             if self.skip_word_and_ws('auto'):\n6016                 if not self.skip_string(')'):\n6017                     self.fail(\"Expected ')' after 'decltype(auto'.\")\n6018                 return ASTTrailingTypeSpecDecltypeAuto()\n6019             expr = self._parse_expression()\n6020             self.skip_ws()\n6021             if not self.skip_string(')'):\n6022                 self.fail(\"Expected ')' after 'decltype(<expr>'.\")\n6023             return ASTTrailingTypeSpecDecltype(expr)\n6024 \n6025         # prefixed\n6026         prefix = None\n6027         self.skip_ws()\n6028         for k in ('class', 'struct', 'enum', 'union', 'typename'):\n6029             if self.skip_word_and_ws(k):\n6030                 prefix = k\n6031                 break\n6032         nestedName = self._parse_nested_name()\n6033         self.skip_ws()\n6034         placeholderType = None\n6035         if self.skip_word('auto'):\n6036             placeholderType = 'auto'\n6037         elif self.skip_word_and_ws('decltype'):\n6038             if not self.skip_string_and_ws('('):\n6039                 self.fail(\"Expected '(' after 'decltype' in placeholder type specifier.\")\n6040             if not self.skip_word_and_ws('auto'):\n6041                 self.fail(\"Expected 'auto' after 'decltype(' in placeholder type specifier.\")\n6042             if not self.skip_string_and_ws(')'):\n6043                 self.fail(\"Expected ')' after 'decltype(auto' in placeholder type specifier.\")\n6044             placeholderType = 'decltype(auto)'\n6045         return ASTTrailingTypeSpecName(prefix, nestedName, placeholderType)\n6046 \n6047     def _parse_parameters_and_qualifiers(self, paramMode: str) -> ASTParametersQualifiers:\n6048         if paramMode == 'new':\n6049             return None\n6050         self.skip_ws()\n6051         if not self.skip_string('('):\n6052             if paramMode == 'function':\n6053                 self.fail('Expecting \"(\" in parameters-and-qualifiers.')\n6054             else:\n6055                 return None\n6056         args = []\n6057         self.skip_ws()\n6058         if not self.skip_string(')'):\n6059             while 1:\n6060                 self.skip_ws()\n6061                 if self.skip_string('...'):\n6062                     args.append(ASTFunctionParameter(None, True))\n6063                     self.skip_ws()\n6064                     if not self.skip_string(')'):\n6065                         self.fail('Expected \")\" after \"...\" in '\n6066                                   'parameters-and-qualifiers.')\n6067                     break\n6068                 # note: it seems that function arguments can always be named,\n6069                 # even in function pointers and similar.\n6070                 arg = self._parse_type_with_init(outer=None, named='single')\n6071                 # TODO: parse default parameters # TODO: didn't we just do that?\n6072                 args.append(ASTFunctionParameter(arg))\n6073 \n6074                 self.skip_ws()\n6075                 if self.skip_string(','):\n6076                     continue\n6077                 elif self.skip_string(')'):\n6078                     break\n6079                 else:\n6080                     self.fail(\n6081                         'Expecting \",\" or \")\" in parameters-and-qualifiers, '\n6082                         'got \"%s\".' % self.current_char)\n6083 \n6084         self.skip_ws()\n6085         const = self.skip_word_and_ws('const')\n6086         volatile = self.skip_word_and_ws('volatile')\n6087         if not const:  # the can be permuted\n6088             const = self.skip_word_and_ws('const')\n6089 \n6090         refQual = None\n6091         if self.skip_string('&&'):\n6092             refQual = '&&'\n6093         if not refQual and self.skip_string('&'):\n6094             refQual = '&'\n6095 \n6096         exceptionSpec = None\n6097         self.skip_ws()\n6098         if self.skip_string('noexcept'):\n6099             if self.skip_string_and_ws('('):\n6100                 expr = self._parse_constant_expression(False)\n6101                 self.skip_ws()\n6102                 if not self.skip_string(')'):\n6103                     self.fail(\"Expecting ')' to end 'noexcept'.\")\n6104                 exceptionSpec = ASTNoexceptSpec(expr)\n6105             else:\n6106                 exceptionSpec = ASTNoexceptSpec(None)\n6107 \n6108         self.skip_ws()\n6109         if self.skip_string('->'):\n6110             trailingReturn = self._parse_type(named=False)\n6111         else:\n6112             trailingReturn = None\n6113 \n6114         self.skip_ws()\n6115         override = self.skip_word_and_ws('override')\n6116         final = self.skip_word_and_ws('final')\n6117         if not override:\n6118             override = self.skip_word_and_ws(\n6119                 'override')  # they can be permuted\n6120 \n6121         attrs = []\n6122         while True:\n6123             attr = self._parse_attribute()\n6124             if attr is None:\n6125                 break\n6126             attrs.append(attr)\n6127 \n6128         self.skip_ws()\n6129         initializer = None\n6130         # if this is a function pointer we should not swallow an initializer\n6131         if paramMode == 'function' and self.skip_string('='):\n6132             self.skip_ws()\n6133             valid = ('0', 'delete', 'default')\n6134             for w in valid:\n6135                 if self.skip_word_and_ws(w):\n6136                     initializer = w\n6137                     break\n6138             if not initializer:\n6139                 self.fail(\n6140                     'Expected \"%s\" in initializer-specifier.'\n6141                     % '\" or \"'.join(valid))\n6142 \n6143         return ASTParametersQualifiers(\n6144             args, volatile, const, refQual, exceptionSpec, trailingReturn,\n6145             override, final, attrs, initializer)\n6146 \n6147     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:\n6148         \"\"\"Just parse the simple ones.\"\"\"\n6149         storage = None\n6150         threadLocal = None\n6151         inline = None\n6152         virtual = None\n6153         explicitSpec = None\n6154         consteval = None\n6155         constexpr = None\n6156         constinit = None\n6157         volatile = None\n6158         const = None\n6159         friend = None\n6160         attrs = []\n6161         while 1:  # accept any permutation of a subset of some decl-specs\n6162             self.skip_ws()\n6163             if not const and typed:\n6164                 const = self.skip_word('const')\n6165                 if const:\n6166                     continue\n6167             if not volatile and typed:\n6168                 volatile = self.skip_word('volatile')\n6169                 if volatile:\n6170                     continue\n6171             if not storage:\n6172                 if outer in ('member', 'function'):\n6173                     if self.skip_word('static'):\n6174                         storage = 'static'\n6175                         continue\n6176                     if self.skip_word('extern'):\n6177                         storage = 'extern'\n6178                         continue\n6179                 if outer == 'member':\n6180                     if self.skip_word('mutable'):\n6181                         storage = 'mutable'\n6182                         continue\n6183                 if self.skip_word('register'):\n6184                     storage = 'register'\n6185                     continue\n6186             if not inline and outer in ('function', 'member'):\n6187                 inline = self.skip_word('inline')\n6188                 if inline:\n6189                     continue\n6190             if not constexpr and outer in ('member', 'function'):\n6191                 constexpr = self.skip_word(\"constexpr\")\n6192                 if constexpr:\n6193                     continue\n6194 \n6195             if outer == 'member':\n6196                 if not constinit:\n6197                     constinit = self.skip_word('constinit')\n6198                     if constinit:\n6199                         continue\n6200                 if not threadLocal:\n6201                     threadLocal = self.skip_word('thread_local')\n6202                     if threadLocal:\n6203                         continue\n6204             if outer == 'function':\n6205                 if not consteval:\n6206                     consteval = self.skip_word('consteval')\n6207                     if consteval:\n6208                         continue\n6209                 if not friend:\n6210                     friend = self.skip_word('friend')\n6211                     if friend:\n6212                         continue\n6213                 if not virtual:\n6214                     virtual = self.skip_word('virtual')\n6215                     if virtual:\n6216                         continue\n6217                 if not explicitSpec:\n6218                     explicit = self.skip_word_and_ws('explicit')\n6219                     if explicit:\n6220                         expr: ASTExpression = None\n6221                         if self.skip_string('('):\n6222                             expr = self._parse_constant_expression(inTemplate=False)\n6223                             if not expr:\n6224                                 self.fail(\"Expected constant expression after '('\" +\n6225                                           \" in explicit specifier.\")\n6226                             self.skip_ws()\n6227                             if not self.skip_string(')'):\n6228                                 self.fail(\"Expected ')' to end explicit specifier.\")\n6229                         explicitSpec = ASTExplicitSpec(expr)\n6230                         continue\n6231             attr = self._parse_attribute()\n6232             if attr:\n6233                 attrs.append(attr)\n6234                 continue\n6235             break\n6236         return ASTDeclSpecsSimple(storage, threadLocal, inline, virtual,\n6237                                   explicitSpec, consteval, constexpr, constinit,\n6238                                   volatile, const, friend, attrs)\n6239 \n6240     def _parse_decl_specs(self, outer: str, typed: bool = True) -> ASTDeclSpecs:\n6241         if outer:\n6242             if outer not in ('type', 'member', 'function', 'templateParam'):\n6243                 raise Exception('Internal error, unknown outer \"%s\".' % outer)\n6244         \"\"\"\n6245         storage-class-specifier function-specifier \"constexpr\"\n6246         \"volatile\" \"const\" trailing-type-specifier\n6247 \n6248         storage-class-specifier ->\n6249               \"static\" (only for member_object and function_object)\n6250             | \"register\"\n6251 \n6252         function-specifier -> \"inline\" | \"virtual\" | \"explicit\" (only for\n6253         function_object)\n6254 \n6255         \"constexpr\" (only for member_object and function_object)\n6256         \"\"\"\n6257         leftSpecs = self._parse_decl_specs_simple(outer, typed)\n6258         rightSpecs = None\n6259 \n6260         if typed:\n6261             trailing = self._parse_trailing_type_spec()\n6262             rightSpecs = self._parse_decl_specs_simple(outer, typed)\n6263         else:\n6264             trailing = None\n6265         return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)\n6266 \n6267     def _parse_declarator_name_suffix(\n6268         self, named: Union[bool, str], paramMode: str, typed: bool\n6269     ) -> Union[ASTDeclaratorNameParamQual, ASTDeclaratorNameBitField]:\n6270         # now we should parse the name, and then suffixes\n6271         if named == 'maybe':\n6272             pos = self.pos\n6273             try:\n6274                 declId = self._parse_nested_name()\n6275             except DefinitionError:\n6276                 self.pos = pos\n6277                 declId = None\n6278         elif named == 'single':\n6279             if self.match(identifier_re):\n6280                 identifier = ASTIdentifier(self.matched_text)\n6281                 nne = ASTNestedNameElement(identifier, None)\n6282                 declId = ASTNestedName([nne], [False], rooted=False)\n6283                 # if it's a member pointer, we may have '::', which should be an error\n6284                 self.skip_ws()\n6285                 if self.current_char == ':':\n6286                     self.fail(\"Unexpected ':' after identifier.\")\n6287             else:\n6288                 declId = None\n6289         elif named:\n6290             declId = self._parse_nested_name()\n6291         else:\n6292             declId = None\n6293         arrayOps = []\n6294         while 1:\n6295             self.skip_ws()\n6296             if typed and self.skip_string('['):\n6297                 self.skip_ws()\n6298                 if self.skip_string(']'):\n6299                     arrayOps.append(ASTArray(None))\n6300                     continue\n6301 \n6302                 def parser() -> ASTExpression:\n6303                     return self._parse_expression()\n6304                 value = self._parse_expression_fallback([']'], parser)\n6305                 if not self.skip_string(']'):\n6306                     self.fail(\"Expected ']' in end of array operator.\")\n6307                 arrayOps.append(ASTArray(value))\n6308                 continue\n6309             else:\n6310                 break\n6311         paramQual = self._parse_parameters_and_qualifiers(paramMode)\n6312         if paramQual is None and len(arrayOps) == 0:\n6313             # perhaps a bit-field\n6314             if named and paramMode == 'type' and typed:\n6315                 self.skip_ws()\n6316                 if self.skip_string(':'):\n6317                     size = self._parse_constant_expression(inTemplate=False)\n6318                     return ASTDeclaratorNameBitField(declId=declId, size=size)\n6319         return ASTDeclaratorNameParamQual(declId=declId, arrayOps=arrayOps,\n6320                                           paramQual=paramQual)\n6321 \n6322     def _parse_declarator(self, named: Union[bool, str], paramMode: str,\n6323                           typed: bool = True\n6324                           ) -> ASTDeclarator:\n6325         # 'typed' here means 'parse return type stuff'\n6326         if paramMode not in ('type', 'function', 'operatorCast', 'new'):\n6327             raise Exception(\n6328                 \"Internal error, unknown paramMode '%s'.\" % paramMode)\n6329         prevErrors = []\n6330         self.skip_ws()\n6331         if typed and self.skip_string('*'):\n6332             self.skip_ws()\n6333             volatile = False\n6334             const = False\n6335             attrs = []\n6336             while 1:\n6337                 if not volatile:\n6338                     volatile = self.skip_word_and_ws('volatile')\n6339                     if volatile:\n6340                         continue\n6341                 if not const:\n6342                     const = self.skip_word_and_ws('const')\n6343                     if const:\n6344                         continue\n6345                 attr = self._parse_attribute()\n6346                 if attr is not None:\n6347                     attrs.append(attr)\n6348                     continue\n6349                 break\n6350             next = self._parse_declarator(named, paramMode, typed)\n6351             return ASTDeclaratorPtr(next=next, volatile=volatile, const=const, attrs=attrs)\n6352         # TODO: shouldn't we parse an R-value ref here first?\n6353         if typed and self.skip_string(\"&\"):\n6354             attrs = []\n6355             while 1:\n6356                 attr = self._parse_attribute()\n6357                 if attr is None:\n6358                     break\n6359                 attrs.append(attr)\n6360             next = self._parse_declarator(named, paramMode, typed)\n6361             return ASTDeclaratorRef(next=next, attrs=attrs)\n6362         if typed and self.skip_string(\"...\"):\n6363             next = self._parse_declarator(named, paramMode, False)\n6364             return ASTDeclaratorParamPack(next=next)\n6365         if typed and self.current_char == '(':  # note: peeking, not skipping\n6366             if paramMode == \"operatorCast\":\n6367                 # TODO: we should be able to parse cast operators which return\n6368                 # function pointers. For now, just hax it and ignore.\n6369                 return ASTDeclaratorNameParamQual(declId=None, arrayOps=[],\n6370                                                   paramQual=None)\n6371             # maybe this is the beginning of params and quals,try that first,\n6372             # otherwise assume it's noptr->declarator > ( ptr-declarator )\n6373             pos = self.pos\n6374             try:\n6375                 # assume this is params and quals\n6376                 res = self._parse_declarator_name_suffix(named, paramMode,\n6377                                                          typed)\n6378                 return res\n6379             except DefinitionError as exParamQual:\n6380                 prevErrors.append((exParamQual,\n6381                                    \"If declarator-id with parameters-and-qualifiers\"))\n6382                 self.pos = pos\n6383                 try:\n6384                     assert self.current_char == '('\n6385                     self.skip_string('(')\n6386                     # TODO: hmm, if there is a name, it must be in inner, right?\n6387                     # TODO: hmm, if there must be parameters, they must be\n6388                     #       inside, right?\n6389                     inner = self._parse_declarator(named, paramMode, typed)\n6390                     if not self.skip_string(')'):\n6391                         self.fail(\"Expected ')' in \\\"( ptr-declarator )\\\"\")\n6392                     next = self._parse_declarator(named=False,\n6393                                                   paramMode=\"type\",\n6394                                                   typed=typed)\n6395                     return ASTDeclaratorParen(inner=inner, next=next)\n6396                 except DefinitionError as exNoPtrParen:\n6397                     self.pos = pos\n6398                     prevErrors.append((exNoPtrParen, \"If parenthesis in noptr-declarator\"))\n6399                     header = \"Error in declarator\"\n6400                     raise self._make_multi_error(prevErrors, header) from exNoPtrParen\n6401         if typed:  # pointer to member\n6402             pos = self.pos\n6403             try:\n6404                 name = self._parse_nested_name(memberPointer=True)\n6405                 self.skip_ws()\n6406                 if not self.skip_string('*'):\n6407                     self.fail(\"Expected '*' in pointer to member declarator.\")\n6408                 self.skip_ws()\n6409             except DefinitionError as e:\n6410                 self.pos = pos\n6411                 prevErrors.append((e, \"If pointer to member declarator\"))\n6412             else:\n6413                 volatile = False\n6414                 const = False\n6415                 while 1:\n6416                     if not volatile:\n6417                         volatile = self.skip_word_and_ws('volatile')\n6418                         if volatile:\n6419                             continue\n6420                     if not const:\n6421                         const = self.skip_word_and_ws('const')\n6422                         if const:\n6423                             continue\n6424                     break\n6425                 next = self._parse_declarator(named, paramMode, typed)\n6426                 return ASTDeclaratorMemPtr(name, const, volatile, next=next)\n6427         pos = self.pos\n6428         try:\n6429             res = self._parse_declarator_name_suffix(named, paramMode, typed)\n6430             # this is a heuristic for error messages, for when there is a < after a\n6431             # nested name, but it was not a successful template argument list\n6432             if self.current_char == '<':\n6433                 self.otherErrors.append(self._make_multi_error(prevErrors, \"\"))\n6434             return res\n6435         except DefinitionError as e:\n6436             self.pos = pos\n6437             prevErrors.append((e, \"If declarator-id\"))\n6438             header = \"Error in declarator or parameters-and-qualifiers\"\n6439             raise self._make_multi_error(prevErrors, header) from e\n6440 \n6441     def _parse_initializer(self, outer: str = None, allowFallback: bool = True\n6442                            ) -> ASTInitializer:\n6443         # initializer                           # global vars\n6444         # -> brace-or-equal-initializer\n6445         #  | '(' expression-list ')'\n6446         #\n6447         # brace-or-equal-initializer            # member vars\n6448         # -> '=' initializer-clause\n6449         #  | braced-init-list\n6450         #\n6451         # initializer-clause  # function params, non-type template params (with '=' in front)\n6452         # -> assignment-expression\n6453         #  | braced-init-list\n6454         #\n6455         # we don't distinguish between global and member vars, so disallow paren:\n6456         #\n6457         # -> braced-init-list             # var only\n6458         #  | '=' assignment-expression\n6459         #  | '=' braced-init-list\n6460         self.skip_ws()\n6461         if outer == 'member':\n6462             bracedInit = self._parse_braced_init_list()\n6463             if bracedInit is not None:\n6464                 return ASTInitializer(bracedInit, hasAssign=False)\n6465 \n6466         if not self.skip_string('='):\n6467             return None\n6468 \n6469         bracedInit = self._parse_braced_init_list()\n6470         if bracedInit is not None:\n6471             return ASTInitializer(bracedInit)\n6472 \n6473         if outer == 'member':\n6474             fallbackEnd: List[str] = []\n6475         elif outer == 'templateParam':\n6476             fallbackEnd = [',', '>']\n6477         elif outer is None:  # function parameter\n6478             fallbackEnd = [',', ')']\n6479         else:\n6480             self.fail(\"Internal error, initializer for outer '%s' not \"\n6481                       \"implemented.\" % outer)\n6482 \n6483         inTemplate = outer == 'templateParam'\n6484 \n6485         def parser() -> ASTExpression:\n6486             return self._parse_assignment_expression(inTemplate=inTemplate)\n6487         value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)\n6488         return ASTInitializer(value)\n6489 \n6490     def _parse_type(self, named: Union[bool, str], outer: str = None) -> ASTType:\n6491         \"\"\"\n6492         named=False|'maybe'|True: 'maybe' is e.g., for function objects which\n6493         doesn't need to name the arguments\n6494 \n6495         outer == operatorCast: annoying case, we should not take the params\n6496         \"\"\"\n6497         if outer:  # always named\n6498             if outer not in ('type', 'member', 'function',\n6499                              'operatorCast', 'templateParam'):\n6500                 raise Exception('Internal error, unknown outer \"%s\".' % outer)\n6501             if outer != 'operatorCast':\n6502                 assert named\n6503         if outer in ('type', 'function'):\n6504             # We allow type objects to just be a name.\n6505             # Some functions don't have normal return types: constructors,\n6506             # destructors, cast operators\n6507             prevErrors = []\n6508             startPos = self.pos\n6509             # first try without the type\n6510             try:\n6511                 declSpecs = self._parse_decl_specs(outer=outer, typed=False)\n6512                 decl = self._parse_declarator(named=True, paramMode=outer,\n6513                                               typed=False)\n6514                 self.assert_end(allowSemicolon=True)\n6515             except DefinitionError as exUntyped:\n6516                 if outer == 'type':\n6517                     desc = \"If just a name\"\n6518                 elif outer == 'function':\n6519                     desc = \"If the function has no return type\"\n6520                 else:\n6521                     assert False\n6522                 prevErrors.append((exUntyped, desc))\n6523                 self.pos = startPos\n6524                 try:\n6525                     declSpecs = self._parse_decl_specs(outer=outer)\n6526                     decl = self._parse_declarator(named=True, paramMode=outer)\n6527                 except DefinitionError as exTyped:\n6528                     self.pos = startPos\n6529                     if outer == 'type':\n6530                         desc = \"If typedef-like declaration\"\n6531                     elif outer == 'function':\n6532                         desc = \"If the function has a return type\"\n6533                     else:\n6534                         assert False\n6535                     prevErrors.append((exTyped, desc))\n6536                     # Retain the else branch for easier debugging.\n6537                     # TODO: it would be nice to save the previous stacktrace\n6538                     #       and output it here.\n6539                     if True:\n6540                         if outer == 'type':\n6541                             header = \"Type must be either just a name or a \"\n6542                             header += \"typedef-like declaration.\"\n6543                         elif outer == 'function':\n6544                             header = \"Error when parsing function declaration.\"\n6545                         else:\n6546                             assert False\n6547                         raise self._make_multi_error(prevErrors, header) from exTyped\n6548                     else:\n6549                         # For testing purposes.\n6550                         # do it again to get the proper traceback (how do you\n6551                         # reliably save a traceback when an exception is\n6552                         # constructed?)\n6553                         self.pos = startPos\n6554                         typed = True\n6555                         declSpecs = self._parse_decl_specs(outer=outer, typed=typed)\n6556                         decl = self._parse_declarator(named=True, paramMode=outer,\n6557                                                       typed=typed)\n6558         else:\n6559             paramMode = 'type'\n6560             if outer == 'member':\n6561                 named = True\n6562             elif outer == 'operatorCast':\n6563                 paramMode = 'operatorCast'\n6564                 outer = None\n6565             elif outer == 'templateParam':\n6566                 named = 'single'\n6567             declSpecs = self._parse_decl_specs(outer=outer)\n6568             decl = self._parse_declarator(named=named, paramMode=paramMode)\n6569         return ASTType(declSpecs, decl)\n6570 \n6571     def _parse_type_with_init(\n6572             self, named: Union[bool, str],\n6573             outer: str) -> Union[ASTTypeWithInit, ASTTemplateParamConstrainedTypeWithInit]:\n6574         if outer:\n6575             assert outer in ('type', 'member', 'function', 'templateParam')\n6576         type = self._parse_type(outer=outer, named=named)\n6577         if outer != 'templateParam':\n6578             init = self._parse_initializer(outer=outer)\n6579             return ASTTypeWithInit(type, init)\n6580         # it could also be a constrained type parameter, e.g., C T = int&\n6581         pos = self.pos\n6582         eExpr = None\n6583         try:\n6584             init = self._parse_initializer(outer=outer, allowFallback=False)\n6585             # note: init may be None if there is no =\n6586             if init is None:\n6587                 return ASTTypeWithInit(type, None)\n6588             # we parsed an expression, so we must have a , or a >,\n6589             # otherwise the expression didn't get everything\n6590             self.skip_ws()\n6591             if self.current_char != ',' and self.current_char != '>':\n6592                 # pretend it didn't happen\n6593                 self.pos = pos\n6594                 init = None\n6595             else:\n6596                 # we assume that it was indeed an expression\n6597                 return ASTTypeWithInit(type, init)\n6598         except DefinitionError as e:\n6599             self.pos = pos\n6600             eExpr = e\n6601         if not self.skip_string(\"=\"):\n6602             return ASTTypeWithInit(type, None)\n6603         try:\n6604             typeInit = self._parse_type(named=False, outer=None)\n6605             return ASTTemplateParamConstrainedTypeWithInit(type, typeInit)\n6606         except DefinitionError as eType:\n6607             if eExpr is None:\n6608                 raise eType\n6609             errs = []\n6610             errs.append((eExpr, \"If default template argument is an expression\"))\n6611             errs.append((eType, \"If default template argument is a type\"))\n6612             msg = \"Error in non-type template parameter\"\n6613             msg += \" or constrained template parameter.\"\n6614             raise self._make_multi_error(errs, msg) from eType\n6615 \n6616     def _parse_type_using(self) -> ASTTypeUsing:\n6617         name = self._parse_nested_name()\n6618         self.skip_ws()\n6619         if not self.skip_string('='):\n6620             return ASTTypeUsing(name, None)\n6621         type = self._parse_type(False, None)\n6622         return ASTTypeUsing(name, type)\n6623 \n6624     def _parse_concept(self) -> ASTConcept:\n6625         nestedName = self._parse_nested_name()\n6626         self.skip_ws()\n6627         initializer = self._parse_initializer('member')\n6628         return ASTConcept(nestedName, initializer)\n6629 \n6630     def _parse_class(self) -> ASTClass:\n6631         attrs = []\n6632         while 1:\n6633             attr = self._parse_attribute()\n6634             if attr is None:\n6635                 break\n6636             attrs.append(attr)\n6637         name = self._parse_nested_name()\n6638         self.skip_ws()\n6639         final = self.skip_word_and_ws('final')\n6640         bases = []\n6641         self.skip_ws()\n6642         if self.skip_string(':'):\n6643             while 1:\n6644                 self.skip_ws()\n6645                 visibility = None\n6646                 virtual = False\n6647                 pack = False\n6648                 if self.skip_word_and_ws('virtual'):\n6649                     virtual = True\n6650                 if self.match(_visibility_re):\n6651                     visibility = self.matched_text\n6652                     self.skip_ws()\n6653                 if not virtual and self.skip_word_and_ws('virtual'):\n6654                     virtual = True\n6655                 baseName = self._parse_nested_name()\n6656                 self.skip_ws()\n6657                 pack = self.skip_string('...')\n6658                 bases.append(ASTBaseClass(baseName, visibility, virtual, pack))\n6659                 self.skip_ws()\n6660                 if self.skip_string(','):\n6661                     continue\n6662                 else:\n6663                     break\n6664         return ASTClass(name, final, bases, attrs)\n6665 \n6666     def _parse_union(self) -> ASTUnion:\n6667         attrs = []\n6668         while 1:\n6669             attr = self._parse_attribute()\n6670             if attr is None:\n6671                 break\n6672             attrs.append(attr)\n6673         name = self._parse_nested_name()\n6674         return ASTUnion(name, attrs)\n6675 \n6676     def _parse_enum(self) -> ASTEnum:\n6677         scoped = None  # is set by CPPEnumObject\n6678         attrs = []\n6679         while 1:\n6680             attr = self._parse_attribute()\n6681             if attr is None:\n6682                 break\n6683             attrs.append(attr)\n6684         self.skip_ws()\n6685         name = self._parse_nested_name()\n6686         self.skip_ws()\n6687         underlyingType = None\n6688         if self.skip_string(':'):\n6689             underlyingType = self._parse_type(named=False)\n6690         return ASTEnum(name, scoped, underlyingType, attrs)\n6691 \n6692     def _parse_enumerator(self) -> ASTEnumerator:\n6693         name = self._parse_nested_name()\n6694         self.skip_ws()\n6695         init = None\n6696         if self.skip_string('='):\n6697             self.skip_ws()\n6698 \n6699             def parser() -> ASTExpression:\n6700                 return self._parse_constant_expression(inTemplate=False)\n6701             initVal = self._parse_expression_fallback([], parser)\n6702             init = ASTInitializer(initVal)\n6703         return ASTEnumerator(name, init)\n6704 \n6705     # ==========================================================================\n6706 \n6707     def _parse_template_parameter(self) -> ASTTemplateParam:\n6708         self.skip_ws()\n6709         if self.skip_word('template'):\n6710             # declare a tenplate template parameter\n6711             nestedParams = self._parse_template_parameter_list()\n6712         else:\n6713             nestedParams = None\n6714 \n6715         pos = self.pos\n6716         try:\n6717             # Unconstrained type parameter or template type parameter\n6718             key = None\n6719             self.skip_ws()\n6720             if self.skip_word_and_ws('typename'):\n6721                 key = 'typename'\n6722             elif self.skip_word_and_ws('class'):\n6723                 key = 'class'\n6724             elif nestedParams:\n6725                 self.fail(\"Expected 'typename' or 'class' after \"\n6726                           \"template template parameter list.\")\n6727             else:\n6728                 self.fail(\"Expected 'typename' or 'class' in the \"\n6729                           \"beginning of template type parameter.\")\n6730             self.skip_ws()\n6731             parameterPack = self.skip_string('...')\n6732             self.skip_ws()\n6733             if self.match(identifier_re):\n6734                 identifier = ASTIdentifier(self.matched_text)\n6735             else:\n6736                 identifier = None\n6737             self.skip_ws()\n6738             if not parameterPack and self.skip_string('='):\n6739                 default = self._parse_type(named=False, outer=None)\n6740             else:\n6741                 default = None\n6742                 if self.current_char not in ',>':\n6743                     self.fail('Expected \",\" or \">\" after (template) type parameter.')\n6744             data = ASTTemplateKeyParamPackIdDefault(key, identifier,\n6745                                                     parameterPack, default)\n6746             if nestedParams:\n6747                 return ASTTemplateParamTemplateType(nestedParams, data)\n6748             else:\n6749                 return ASTTemplateParamType(data)\n6750         except DefinitionError as eType:\n6751             if nestedParams:\n6752                 raise\n6753             try:\n6754                 # non-type parameter or constrained type parameter\n6755                 self.pos = pos\n6756                 param = self._parse_type_with_init('maybe', 'templateParam')\n6757                 return ASTTemplateParamNonType(param)\n6758             except DefinitionError as eNonType:\n6759                 self.pos = pos\n6760                 header = \"Error when parsing template parameter.\"\n6761                 errs = []\n6762                 errs.append(\n6763                     (eType, \"If unconstrained type parameter or template type parameter\"))\n6764                 errs.append(\n6765                     (eNonType, \"If constrained type parameter or non-type parameter\"))\n6766                 raise self._make_multi_error(errs, header)\n6767 \n6768     def _parse_template_parameter_list(self) -> ASTTemplateParams:\n6769         # only: '<' parameter-list '>'\n6770         # we assume that 'template' has just been parsed\n6771         templateParams: List[ASTTemplateParam] = []\n6772         self.skip_ws()\n6773         if not self.skip_string(\"<\"):\n6774             self.fail(\"Expected '<' after 'template'\")\n6775         while 1:\n6776             pos = self.pos\n6777             err = None\n6778             try:\n6779                 param = self._parse_template_parameter()\n6780                 templateParams.append(param)\n6781             except DefinitionError as eParam:\n6782                 self.pos = pos\n6783                 err = eParam\n6784             self.skip_ws()\n6785             if self.skip_string('>'):\n6786                 return ASTTemplateParams(templateParams)\n6787             elif self.skip_string(','):\n6788                 continue\n6789             else:\n6790                 header = \"Error in template parameter list.\"\n6791                 errs = []\n6792                 if err:\n6793                     errs.append((err, \"If parameter\"))\n6794                 try:\n6795                     self.fail('Expected \",\" or \">\".')\n6796                 except DefinitionError as e:\n6797                     errs.append((e, \"If no parameter\"))\n6798                 print(errs)\n6799                 raise self._make_multi_error(errs, header)\n6800 \n6801     def _parse_template_introduction(self) -> ASTTemplateIntroduction:\n6802         pos = self.pos\n6803         try:\n6804             concept = self._parse_nested_name()\n6805         except Exception:\n6806             self.pos = pos\n6807             return None\n6808         self.skip_ws()\n6809         if not self.skip_string('{'):\n6810             self.pos = pos\n6811             return None\n6812 \n6813         # for sure it must be a template introduction now\n6814         params = []\n6815         while 1:\n6816             self.skip_ws()\n6817             parameterPack = self.skip_string('...')\n6818             self.skip_ws()\n6819             if not self.match(identifier_re):\n6820                 self.fail(\"Expected identifier in template introduction list.\")\n6821             txt_identifier = self.matched_text\n6822             # make sure there isn't a keyword\n6823             if txt_identifier in _keywords:\n6824                 self.fail(\"Expected identifier in template introduction list, \"\n6825                           \"got keyword: %s\" % txt_identifier)\n6826             identifier = ASTIdentifier(txt_identifier)\n6827             params.append(ASTTemplateIntroductionParameter(identifier, parameterPack))\n6828 \n6829             self.skip_ws()\n6830             if self.skip_string('}'):\n6831                 break\n6832             elif self.skip_string(','):\n6833                 continue\n6834             else:\n6835                 self.fail(\"Error in template introduction list. \"\n6836                           'Expected \",\", or \"}\".')\n6837         return ASTTemplateIntroduction(concept, params)\n6838 \n6839     def _parse_requires_clause(self) -> Optional[ASTRequiresClause]:\n6840         # requires-clause -> 'requires' constraint-logical-or-expression\n6841         # constraint-logical-or-expression\n6842         #   -> constraint-logical-and-expression\n6843         #    | constraint-logical-or-expression '||' constraint-logical-and-expression\n6844         # constraint-logical-and-expression\n6845         #   -> primary-expression\n6846         #    | constraint-logical-and-expression '&&' primary-expression\n6847         self.skip_ws()\n6848         if not self.skip_word('requires'):\n6849             return None\n6850 \n6851         def parse_and_expr(self: DefinitionParser) -> ASTExpression:\n6852             andExprs = []\n6853             ops = []\n6854             andExprs.append(self._parse_primary_expression())\n6855             while True:\n6856                 self.skip_ws()\n6857                 oneMore = False\n6858                 if self.skip_string('&&'):\n6859                     oneMore = True\n6860                     ops.append('&&')\n6861                 elif self.skip_word('and'):\n6862                     oneMore = True\n6863                     ops.append('and')\n6864                 if not oneMore:\n6865                     break\n6866                 andExprs.append(self._parse_primary_expression())\n6867             if len(andExprs) == 1:\n6868                 return andExprs[0]\n6869             else:\n6870                 return ASTBinOpExpr(andExprs, ops)\n6871 \n6872         orExprs = []\n6873         ops = []\n6874         orExprs.append(parse_and_expr(self))\n6875         while True:\n6876             self.skip_ws()\n6877             oneMore = False\n6878             if self.skip_string('||'):\n6879                 oneMore = True\n6880                 ops.append('||')\n6881             elif self.skip_word('or'):\n6882                 oneMore = True\n6883                 ops.append('or')\n6884             if not oneMore:\n6885                 break\n6886             orExprs.append(parse_and_expr(self))\n6887         if len(orExprs) == 1:\n6888             return ASTRequiresClause(orExprs[0])\n6889         else:\n6890             return ASTRequiresClause(ASTBinOpExpr(orExprs, ops))\n6891 \n6892     def _parse_template_declaration_prefix(self, objectType: str\n6893                                            ) -> Optional[ASTTemplateDeclarationPrefix]:\n6894         templates: List[Union[ASTTemplateParams, ASTTemplateIntroduction]] = []\n6895         while 1:\n6896             self.skip_ws()\n6897             # the saved position is only used to provide a better error message\n6898             params: Union[ASTTemplateParams, ASTTemplateIntroduction] = None\n6899             pos = self.pos\n6900             if self.skip_word(\"template\"):\n6901                 try:\n6902                     params = self._parse_template_parameter_list()\n6903                 except DefinitionError as e:\n6904                     if objectType == 'member' and len(templates) == 0:\n6905                         return ASTTemplateDeclarationPrefix(None)\n6906                     else:\n6907                         raise e\n6908             else:\n6909                 params = self._parse_template_introduction()\n6910                 if not params:\n6911                     break\n6912             if objectType == 'concept' and len(templates) > 0:\n6913                 self.pos = pos\n6914                 self.fail(\"More than 1 template parameter list for concept.\")\n6915             templates.append(params)\n6916         if len(templates) == 0 and objectType == 'concept':\n6917             self.fail('Missing template parameter list for concept.')\n6918         if len(templates) == 0:\n6919             return None\n6920         else:\n6921             return ASTTemplateDeclarationPrefix(templates)\n6922 \n6923     def _check_template_consistency(self, nestedName: ASTNestedName,\n6924                                     templatePrefix: ASTTemplateDeclarationPrefix,\n6925                                     fullSpecShorthand: bool, isMember: bool = False\n6926                                     ) -> ASTTemplateDeclarationPrefix:\n6927         numArgs = nestedName.num_templates()\n6928         isMemberInstantiation = False\n6929         if not templatePrefix:\n6930             numParams = 0\n6931         else:\n6932             if isMember and templatePrefix.templates is None:\n6933                 numParams = 0\n6934                 isMemberInstantiation = True\n6935             else:\n6936                 numParams = len(templatePrefix.templates)\n6937         if numArgs + 1 < numParams:\n6938             self.fail(\"Too few template argument lists comapred to parameter\"\n6939                       \" lists. Argument lists: %d, Parameter lists: %d.\"\n6940                       % (numArgs, numParams))\n6941         if numArgs > numParams:\n6942             numExtra = numArgs - numParams\n6943             if not fullSpecShorthand and not isMemberInstantiation:\n6944                 msg = \"Too many template argument lists compared to parameter\" \\\n6945                     \" lists. Argument lists: %d, Parameter lists: %d,\" \\\n6946                     \" Extra empty parameters lists prepended: %d.\" \\\n6947                     % (numArgs, numParams, numExtra)\n6948                 msg += \" Declaration:\\n\\t\"\n6949                 if templatePrefix:\n6950                     msg += \"%s\\n\\t\" % templatePrefix\n6951                 msg += str(nestedName)\n6952                 self.warn(msg)\n6953 \n6954             newTemplates: List[Union[ASTTemplateParams, ASTTemplateIntroduction]] = []\n6955             for _i in range(numExtra):\n6956                 newTemplates.append(ASTTemplateParams([]))\n6957             if templatePrefix and not isMemberInstantiation:\n6958                 newTemplates.extend(templatePrefix.templates)\n6959             templatePrefix = ASTTemplateDeclarationPrefix(newTemplates)\n6960         return templatePrefix\n6961 \n6962     def parse_declaration(self, objectType: str, directiveType: str) -> ASTDeclaration:\n6963         if objectType not in ('class', 'union', 'function', 'member', 'type',\n6964                               'concept', 'enum', 'enumerator'):\n6965             raise Exception('Internal error, unknown objectType \"%s\".' % objectType)\n6966         if directiveType not in ('class', 'struct', 'union', 'function', 'member', 'var',\n6967                                  'type', 'concept',\n6968                                  'enum', 'enum-struct', 'enum-class', 'enumerator'):\n6969             raise Exception('Internal error, unknown directiveType \"%s\".' % directiveType)\n6970         visibility = None\n6971         templatePrefix = None\n6972         requiresClause = None\n6973         trailingRequiresClause = None\n6974         declaration: Any = None\n6975 \n6976         self.skip_ws()\n6977         if self.match(_visibility_re):\n6978             visibility = self.matched_text\n6979 \n6980         if objectType in ('type', 'concept', 'member', 'function', 'class'):\n6981             templatePrefix = self._parse_template_declaration_prefix(objectType)\n6982             if objectType == 'function' and templatePrefix is not None:\n6983                 requiresClause = self._parse_requires_clause()\n6984 \n6985         if objectType == 'type':\n6986             prevErrors = []\n6987             pos = self.pos\n6988             try:\n6989                 if not templatePrefix:\n6990                     declaration = self._parse_type(named=True, outer='type')\n6991             except DefinitionError as e:\n6992                 prevErrors.append((e, \"If typedef-like declaration\"))\n6993                 self.pos = pos\n6994             pos = self.pos\n6995             try:\n6996                 if not declaration:\n6997                     declaration = self._parse_type_using()\n6998             except DefinitionError as e:\n6999                 self.pos = pos\n7000                 prevErrors.append((e, \"If type alias or template alias\"))\n7001                 header = \"Error in type declaration.\"\n7002                 raise self._make_multi_error(prevErrors, header) from e\n7003         elif objectType == 'concept':\n7004             declaration = self._parse_concept()\n7005         elif objectType == 'member':\n7006             declaration = self._parse_type_with_init(named=True, outer='member')\n7007         elif objectType == 'function':\n7008             declaration = self._parse_type(named=True, outer='function')\n7009             if templatePrefix is not None:\n7010                 trailingRequiresClause = self._parse_requires_clause()\n7011         elif objectType == 'class':\n7012             declaration = self._parse_class()\n7013         elif objectType == 'union':\n7014             declaration = self._parse_union()\n7015         elif objectType == 'enum':\n7016             declaration = self._parse_enum()\n7017         elif objectType == 'enumerator':\n7018             declaration = self._parse_enumerator()\n7019         else:\n7020             assert False\n7021         templatePrefix = self._check_template_consistency(declaration.name,\n7022                                                           templatePrefix,\n7023                                                           fullSpecShorthand=False,\n7024                                                           isMember=objectType == 'member')\n7025         self.skip_ws()\n7026         semicolon = self.skip_string(';')\n7027         return ASTDeclaration(objectType, directiveType, visibility,\n7028                               templatePrefix, requiresClause, declaration,\n7029                               trailingRequiresClause, semicolon)\n7030 \n7031     def parse_namespace_object(self) -> ASTNamespace:\n7032         templatePrefix = self._parse_template_declaration_prefix(objectType=\"namespace\")\n7033         name = self._parse_nested_name()\n7034         templatePrefix = self._check_template_consistency(name, templatePrefix,\n7035                                                           fullSpecShorthand=False)\n7036         res = ASTNamespace(name, templatePrefix)\n7037         res.objectType = 'namespace'  # type: ignore\n7038         return res\n7039 \n7040     def parse_xref_object(self) -> Tuple[Union[ASTNamespace, ASTDeclaration], bool]:\n7041         pos = self.pos\n7042         try:\n7043             templatePrefix = self._parse_template_declaration_prefix(objectType=\"xref\")\n7044             name = self._parse_nested_name()\n7045             # if there are '()' left, just skip them\n7046             self.skip_ws()\n7047             self.skip_string('()')\n7048             self.assert_end()\n7049             templatePrefix = self._check_template_consistency(name, templatePrefix,\n7050                                                               fullSpecShorthand=True)\n7051             res1 = ASTNamespace(name, templatePrefix)\n7052             res1.objectType = 'xref'  # type: ignore\n7053             return res1, True\n7054         except DefinitionError as e1:\n7055             try:\n7056                 self.pos = pos\n7057                 res2 = self.parse_declaration('function', 'function')\n7058                 # if there are '()' left, just skip them\n7059                 self.skip_ws()\n7060                 self.skip_string('()')\n7061                 self.assert_end()\n7062                 return res2, False\n7063             except DefinitionError as e2:\n7064                 errs = []\n7065                 errs.append((e1, \"If shorthand ref\"))\n7066                 errs.append((e2, \"If full function ref\"))\n7067                 msg = \"Error in cross-reference.\"\n7068                 raise self._make_multi_error(errs, msg) from e2\n7069 \n7070     def parse_expression(self) -> Union[ASTExpression, ASTType]:\n7071         pos = self.pos\n7072         try:\n7073             expr = self._parse_expression()\n7074             self.skip_ws()\n7075             self.assert_end()\n7076             return expr\n7077         except DefinitionError as exExpr:\n7078             self.pos = pos\n7079             try:\n7080                 typ = self._parse_type(False)\n7081                 self.skip_ws()\n7082                 self.assert_end()\n7083                 return typ\n7084             except DefinitionError as exType:\n7085                 header = \"Error when parsing (type) expression.\"\n7086                 errs = []\n7087                 errs.append((exExpr, \"If expression\"))\n7088                 errs.append((exType, \"If type\"))\n7089                 raise self._make_multi_error(errs, header) from exType\n",
        "intended_behavior": "Similar to the C domain, the DefinitionParser class and the setup function in the C++ domain (cpp.py) should be adjusted to correctly handle cpp_id_attributes during enum parsing. This involves ensuring attributes tagged on enum values do not cause parsing issues or misnomers in the generated documentation. The correct approach would filter or properly recognize these attributes so that they do not lead to errors or misnamed enum values in the documentation output."
    }
]