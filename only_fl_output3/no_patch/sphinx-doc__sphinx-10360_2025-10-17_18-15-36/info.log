2025-10-17 18:15:36.565 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 18:15:39.172 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=478, output_tokens=12, cost=0.005140
2025-10-17 18:15:57.775 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=658, output_tokens=712, cost=0.027940
2025-10-17 18:15:58.784 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:16:06.218 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=779, output_tokens=291, cost=0.016520
2025-10-17 18:16:06.225 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:16:08.338 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=645, output_tokens=62, cost=0.008310
2025-10-17 18:16:08.339 | DEBUG    | Extracted a valid json.
2025-10-17 18:16:08.339 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"typedef enum { JXL_TYPE_FLOAT = 0, JXL_TYPE_BOOLEAN JXL_DEPRECATED,\")",
        "search_code(\"c_id_attributes\")",
        "search_code(\"cpp_id_attributes\")"
    ],
    "bug_locations": []
}
2025-10-17 18:16:08.392 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 18:16:08.393 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 18:16:23.052 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1702, output_tokens=636, cost=0.036100
2025-10-17 18:16:23.066 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:16:33.149 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2554, output_tokens=413, cost=0.037930
2025-10-17 18:16:33.159 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:16:39.906 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=767, output_tokens=292, cost=0.016430
2025-10-17 18:16:39.907 | DEBUG    | Extracted a valid json.
2025-10-17 18:16:39.907 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sphinx/domains/c.py", 
            "class": "DefinitionParser", 
            "method": "id_attributes, setup", 
            "intended_behavior": "Adjust the id_attributes property and perhaps the setup method as needed to ensure that when Sphinx encounters attributes in enum value declarations (like __attribute__((__deprecated__)) or macros intended for deprecation signals), these attributes are either ignored or processed in a way that does not interfere with the correct identification of the enum value names. This might involve modifying how c_id_attributes is used within this parsing context to ensure attributes in enums are handled according to the expected documentation output, without misinterpretation or causing duplicate declaration issues."
        }, 
        {
            "file": "sphinx/domains/cpp.py", 
            "class": "DefinitionParser", 
            "method": "id_attributes, setup", 
            "intended_behavior": "Similar to the C domain, the DefinitionParser class and the setup function in the C++ domain (cpp.py) should be adjusted to correctly handle cpp_id_attributes during enum parsing. This involves ensuring attributes tagged on enum values do not cause parsing issues or misnomers in the generated documentation. The correct approach would filter or properly recognize these attributes so that they do not lead to errors or misnamed enum values in the documentation output."
        }
    ]
}
2025-10-17 18:16:39.922 | DEBUG    | Bug location extracted successfully: [<file>sphinx/domains/c.py</file>
<class>DefinitionParser</class>
<method>None</method>
<code>
2143 class DefinitionParser(BaseParser):
2144     @property
2145     def language(self) -> str:
2146         return 'C'
2147 
2148     @property
2149     def id_attributes(self):
2150         return self.config.c_id_attributes
2151 
2152     @property
2153     def paren_attributes(self):
2154         return self.config.c_paren_attributes
2155 
2156     def _parse_string(self) -> str:
2157         if self.current_char != '"':
2158             return None
2159         startPos = self.pos
2160         self.pos += 1
2161         escape = False
2162         while True:
2163             if self.eof:
2164                 self.fail("Unexpected end during inside string.")
2165             elif self.current_char == '"' and not escape:
2166                 self.pos += 1
2167                 break
2168             elif self.current_char == '\\':
2169                 escape = True
2170             else:
2171                 escape = False
2172             self.pos += 1
2173         return self.definition[startPos:self.pos]
2174 
2175     def _parse_literal(self) -> ASTLiteral:
2176         # -> integer-literal
2177         #  | character-literal
2178         #  | floating-literal
2179         #  | string-literal
2180         #  | boolean-literal -> "false" | "true"
2181         self.skip_ws()
2182         if self.skip_word('true'):
2183             return ASTBooleanLiteral(True)
2184         if self.skip_word('false'):
2185             return ASTBooleanLiteral(False)
2186         pos = self.pos
2187         if self.match(float_literal_re):
2188             self.match(float_literal_suffix_re)
2189             return ASTNumberLiteral(self.definition[pos:self.pos])
2190         for regex in [binary_literal_re, hex_literal_re,
2191                       integer_literal_re, octal_literal_re]:
2192             if self.match(regex):
2193                 self.match(integers_literal_suffix_re)
2194                 return ASTNumberLiteral(self.definition[pos:self.pos])
2195 
2196         string = self._parse_string()
2197         if string is not None:
2198             return ASTStringLiteral(string)
2199 
2200         # character-literal
2201         if self.match(char_literal_re):
2202             prefix = self.last_match.group(1)  # may be None when no prefix
2203             data = self.last_match.group(2)
2204             try:
2205                 return ASTCharLiteral(prefix, data)
2206             except UnicodeDecodeError as e:
2207                 self.fail("Can not handle character literal. Internal error was: %s" % e)
2208             except UnsupportedMultiCharacterCharLiteral:
2209                 self.fail("Can not handle character literal"
2210                           " resulting in multiple decoded characters.")
2211         return None
2212 
2213     def _parse_paren_expression(self) -> ASTExpression:
2214         # "(" expression ")"
2215         if self.current_char != '(':
2216             return None
2217         self.pos += 1
2218         res = self._parse_expression()
2219         self.skip_ws()
2220         if not self.skip_string(')'):
2221             self.fail("Expected ')' in end of parenthesized expression.")
2222         return ASTParenExpr(res)
2223 
2224     def _parse_primary_expression(self) -> ASTExpression:
2225         # literal
2226         # "(" expression ")"
2227         # id-expression -> we parse this with _parse_nested_name
2228         self.skip_ws()
2229         res: ASTExpression = self._parse_literal()
2230         if res is not None:
2231             return res
2232         res = self._parse_paren_expression()
2233         if res is not None:
2234             return res
2235         nn = self._parse_nested_name()
2236         if nn is not None:
2237             return ASTIdExpression(nn)
2238         return None
2239 
2240     def _parse_initializer_list(self, name: str, open: str, close: str
2241                                 ) -> Tuple[List[ASTExpression], bool]:
2242         # Parse open and close with the actual initializer-list in between
2243         # -> initializer-clause '...'[opt]
2244         #  | initializer-list ',' initializer-clause '...'[opt]
2245         # TODO: designators
2246         self.skip_ws()
2247         if not self.skip_string_and_ws(open):
2248             return None, None
2249         if self.skip_string(close):
2250             return [], False
2251 
2252         exprs = []
2253         trailingComma = False
2254         while True:
2255             self.skip_ws()
2256             expr = self._parse_expression()
2257             self.skip_ws()
2258             exprs.append(expr)
2259             self.skip_ws()
2260             if self.skip_string(close):
2261                 break
2262             if not self.skip_string_and_ws(','):
2263                 self.fail("Error in %s, expected ',' or '%s'." % (name, close))
2264             if self.current_char == close and close == '}':
2265                 self.pos += 1
2266                 trailingComma = True
2267                 break
2268         return exprs, trailingComma
2269 
2270     def _parse_paren_expression_list(self) -> ASTParenExprList:
2271         # -> '(' expression-list ')'
2272         # though, we relax it to also allow empty parens
2273         # as it's needed in some cases
2274         #
2275         # expression-list
2276         # -> initializer-list
2277         exprs, trailingComma = self._parse_initializer_list("parenthesized expression-list",
2278                                                             '(', ')')
2279         if exprs is None:
2280             return None
2281         return ASTParenExprList(exprs)
2282 
2283     def _parse_braced_init_list(self) -> ASTBracedInitList:
2284         # -> '{' initializer-list ','[opt] '}'
2285         #  | '{' '}'
2286         exprs, trailingComma = self._parse_initializer_list("braced-init-list", '{', '}')
2287         if exprs is None:
2288             return None
2289         return ASTBracedInitList(exprs, trailingComma)
2290 
2291     def _parse_postfix_expression(self) -> ASTPostfixExpr:
2292         # -> primary
2293         #  | postfix "[" expression "]"
2294         #  | postfix "[" braced-init-list [opt] "]"
2295         #  | postfix "(" expression-list [opt] ")"
2296         #  | postfix "." id-expression  // taken care of in primary by nested name
2297         #  | postfix "->" id-expression
2298         #  | postfix "++"
2299         #  | postfix "--"
2300 
2301         prefix = self._parse_primary_expression()
2302 
2303         # and now parse postfixes
2304         postFixes: List[ASTPostfixOp] = []
2305         while True:
2306             self.skip_ws()
2307             if self.skip_string_and_ws('['):
2308                 expr = self._parse_expression()
2309                 self.skip_ws()
2310                 if not self.skip_string(']'):
2311                     self.fail("Expected ']' in end of postfix expression.")
2312                 postFixes.append(ASTPostfixArray(expr))
2313                 continue
2314             if self.skip_string('->'):
2315                 if self.skip_string('*'):
2316                     # don't steal the arrow
2317                     self.pos -= 3
2318                 else:
2319                     name = self._parse_nested_name()
2320                     postFixes.append(ASTPostfixMemberOfPointer(name))
2321                     continue
2322             if self.skip_string('++'):
2323                 postFixes.append(ASTPostfixInc())
2324                 continue
2325             if self.skip_string('--'):
2326                 postFixes.append(ASTPostfixDec())
2327                 continue
2328             lst = self._parse_paren_expression_list()
2329             if lst is not None:
2330                 postFixes.append(ASTPostfixCallExpr(lst))
2331                 continue
2332             break
2333         return ASTPostfixExpr(prefix, postFixes)
2334 
2335     def _parse_unary_expression(self) -> ASTExpression:
2336         # -> postfix
2337         #  | "++" cast
2338         #  | "--" cast
2339         #  | unary-operator cast -> (* | & | + | - | ! | ~) cast
2340         # The rest:
2341         #  | "sizeof" unary
2342         #  | "sizeof" "(" type-id ")"
2343         #  | "alignof" "(" type-id ")"
2344         self.skip_ws()
2345         for op in _expression_unary_ops:
2346             # TODO: hmm, should we be able to backtrack here?
2347             if op[0] in 'cn':
2348                 res = self.skip_word(op)
2349             else:
2350                 res = self.skip_string(op)
2351             if res:
2352                 expr = self._parse_cast_expression()
2353                 return ASTUnaryOpExpr(op, expr)
2354         if self.skip_word_and_ws('sizeof'):
2355             if self.skip_string_and_ws('('):
2356                 typ = self._parse_type(named=False)
2357                 self.skip_ws()
2358                 if not self.skip_string(')'):
2359                     self.fail("Expecting ')' to end 'sizeof'.")
2360                 return ASTSizeofType(typ)
2361             expr = self._parse_unary_expression()
2362             return ASTSizeofExpr(expr)
2363         if self.skip_word_and_ws('alignof'):
2364             if not self.skip_string_and_ws('('):
2365                 self.fail("Expecting '(' after 'alignof'.")
2366             typ = self._parse_type(named=False)
2367             self.skip_ws()
2368             if not self.skip_string(')'):
2369                 self.fail("Expecting ')' to end 'alignof'.")
2370             return ASTAlignofExpr(typ)
2371         return self._parse_postfix_expression()
2372 
2373     def _parse_cast_expression(self) -> ASTExpression:
2374         # -> unary  | "(" type-id ")" cast
2375         pos = self.pos
2376         self.skip_ws()
2377         if self.skip_string('('):
2378             try:
2379                 typ = self._parse_type(False)
2380                 if not self.skip_string(')'):
2381                     self.fail("Expected ')' in cast expression.")
2382                 expr = self._parse_cast_expression()
2383                 return ASTCastExpr(typ, expr)
2384             except DefinitionError as exCast:
2385                 self.pos = pos
2386                 try:
2387                     return self._parse_unary_expression()
2388                 except DefinitionError as exUnary:
2389                     errs = []
2390                     errs.append((exCast, "If type cast expression"))
2391                     errs.append((exUnary, "If unary expression"))
2392                     raise self._make_multi_error(errs,
2393                                                  "Error in cast expression.") from exUnary
2394         else:
2395             return self._parse_unary_expression()
2396 
2397     def _parse_logical_or_expression(self) -> ASTExpression:
2398         # logical-or     = logical-and      ||
2399         # logical-and    = inclusive-or     &&
2400         # inclusive-or   = exclusive-or     |
2401         # exclusive-or   = and              ^
2402         # and            = equality         &
2403         # equality       = relational       ==, !=
2404         # relational     = shift            <, >, <=, >=
2405         # shift          = additive         <<, >>
2406         # additive       = multiplicative   +, -
2407         # multiplicative = pm               *, /, %
2408         # pm             = cast             .*, ->*
2409         def _parse_bin_op_expr(self, opId):
2410             if opId + 1 == len(_expression_bin_ops):
2411                 def parser() -> ASTExpression:
2412                     return self._parse_cast_expression()
2413             else:
2414                 def parser() -> ASTExpression:
2415                     return _parse_bin_op_expr(self, opId + 1)
2416             exprs = []
2417             ops = []
2418             exprs.append(parser())
2419             while True:
2420                 self.skip_ws()
2421                 pos = self.pos
2422                 oneMore = False
2423                 for op in _expression_bin_ops[opId]:
2424                     if op[0] in 'abcnox':
2425                         if not self.skip_word(op):
2426                             continue
2427                     else:
2428                         if not self.skip_string(op):
2429                             continue
2430                     if op == '&' and self.current_char == '&':
2431                         # don't split the && 'token'
2432                         self.pos -= 1
2433                         # and btw. && has lower precedence, so we are done
2434                         break
2435                     try:
2436                         expr = parser()
2437                         exprs.append(expr)
2438                         ops.append(op)
2439                         oneMore = True
2440                         break
2441                     except DefinitionError:
2442                         self.pos = pos
2443                 if not oneMore:
2444                     break
2445             return ASTBinOpExpr(exprs, ops)
2446         return _parse_bin_op_expr(self, 0)
2447 
2448     def _parse_conditional_expression_tail(self, orExprHead: Any) -> ASTExpression:
2449         # -> "?" expression ":" assignment-expression
2450         return None
2451 
2452     def _parse_assignment_expression(self) -> ASTExpression:
2453         # -> conditional-expression
2454         #  | logical-or-expression assignment-operator initializer-clause
2455         # -> conditional-expression ->
2456         #     logical-or-expression
2457         #   | logical-or-expression "?" expression ":" assignment-expression
2458         #   | logical-or-expression assignment-operator initializer-clause
2459         exprs = []
2460         ops = []
2461         orExpr = self._parse_logical_or_expression()
2462         exprs.append(orExpr)
2463         # TODO: handle ternary with _parse_conditional_expression_tail
2464         while True:
2465             oneMore = False
2466             self.skip_ws()
2467             for op in _expression_assignment_ops:
2468                 if op[0] in 'abcnox':
2469                     if not self.skip_word(op):
2470                         continue
2471                 else:
2472                     if not self.skip_string(op):
2473                         continue
2474                 expr = self._parse_logical_or_expression()
2475                 exprs.append(expr)
2476                 ops.append(op)
2477                 oneMore = True
2478             if not oneMore:
2479                 break
2480         return ASTAssignmentExpr(exprs, ops)
2481 
2482     def _parse_constant_expression(self) -> ASTExpression:
2483         # -> conditional-expression
2484         orExpr = self._parse_logical_or_expression()
2485         # TODO: use _parse_conditional_expression_tail
2486         return orExpr
2487 
2488     def _parse_expression(self) -> ASTExpression:
2489         # -> assignment-expression
2490         #  | expression "," assignment-expression
2491         # TODO: actually parse the second production
2492         return self._parse_assignment_expression()
2493 
2494     def _parse_expression_fallback(
2495             self, end: List[str],
2496             parser: Callable[[], ASTExpression],
2497             allow: bool = True) -> ASTExpression:
2498         # Stupidly "parse" an expression.
2499         # 'end' should be a list of characters which ends the expression.
2500 
2501         # first try to use the provided parser
2502         prevPos = self.pos
2503         try:
2504             return parser()
2505         except DefinitionError as e:
2506             # some places (e.g., template parameters) we really don't want to use fallback,
2507             # and for testing we may want to globally disable it
2508             if not allow or not self.allowFallbackExpressionParsing:
2509                 raise
2510             self.warn("Parsing of expression failed. Using fallback parser."
2511                       " Error was:\n%s" % e)
2512             self.pos = prevPos
2513         # and then the fallback scanning
2514         assert end is not None
2515         self.skip_ws()
2516         startPos = self.pos
2517         if self.match(_string_re):
2518             value = self.matched_text
2519         else:
2520             # TODO: add handling of more bracket-like things, and quote handling
2521             brackets = {'(': ')', '{': '}', '[': ']'}
2522             symbols: List[str] = []
2523             while not self.eof:
2524                 if (len(symbols) == 0 and self.current_char in end):
2525                     break
2526                 if self.current_char in brackets.keys():
2527                     symbols.append(brackets[self.current_char])
2528                 elif len(symbols) > 0 and self.current_char == symbols[-1]:
2529                     symbols.pop()
2530                 self.pos += 1
2531             if len(end) > 0 and self.eof:
2532                 self.fail("Could not find end of expression starting at %d."
2533                           % startPos)
2534             value = self.definition[startPos:self.pos].strip()
2535         return ASTFallbackExpr(value.strip())
2536 
2537     def _parse_nested_name(self) -> ASTNestedName:
2538         names: List[Any] = []
2539 
2540         self.skip_ws()
2541         rooted = False
2542         if self.skip_string('.'):
2543             rooted = True
2544         while 1:
2545             self.skip_ws()
2546             if not self.match(identifier_re):
2547                 self.fail("Expected identifier in nested name.")
2548             identifier = self.matched_text
2549             # make sure there isn't a keyword
2550             if identifier in _keywords:
2551                 self.fail("Expected identifier in nested name, "
2552                           "got keyword: %s" % identifier)
2553             if self.matched_text in self.config.c_extra_keywords:
2554                 msg = "Expected identifier, got user-defined keyword: %s." \
2555                       + " Remove it from c_extra_keywords to allow it as identifier.\n" \
2556                       + "Currently c_extra_keywords is %s."
2557                 self.fail(msg % (self.matched_text,
2558                                  str(self.config.c_extra_keywords)))
2559             ident = ASTIdentifier(identifier)
2560             names.append(ident)
2561 
2562             self.skip_ws()
2563             if not self.skip_string('.'):
2564                 break
2565         return ASTNestedName(names, rooted)
2566 
2567     def _parse_simple_type_specifier(self) -> Optional[str]:
2568         if self.match(_simple_type_specifiers_re):
2569             return self.matched_text
2570         for t in ('bool', 'complex', 'imaginary'):
2571             if t in self.config.c_extra_keywords:
2572                 if self.skip_word(t):
2573                     return t
2574         return None
2575 
2576     def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental:
2577         names: List[str] = []
2578 
2579         self.skip_ws()
2580         while True:
2581             t = self._parse_simple_type_specifier()
2582             if t is None:
2583                 break
2584             names.append(t)
2585             self.skip_ws()
2586         if len(names) == 0:
2587             return None
2588         return ASTTrailingTypeSpecFundamental(names)
2589 
2590     def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:
2591         # fundamental types, https://en.cppreference.com/w/c/language/type
2592         # and extensions
2593         self.skip_ws()
2594         res = self._parse_simple_type_specifiers()
2595         if res is not None:
2596             return res
2597 
2598         # prefixed
2599         prefix = None
2600         self.skip_ws()
2601         for k in ('struct', 'enum', 'union'):
2602             if self.skip_word_and_ws(k):
2603                 prefix = k
2604                 break
2605 
2606         nestedName = self._parse_nested_name()
2607         return ASTTrailingTypeSpecName(prefix, nestedName)
2608 
2609     def _parse_parameters(self, paramMode: str) -> ASTParameters:
2610         self.skip_ws()
2611         if not self.skip_string('('):
2612             if paramMode == 'function':
2613                 self.fail('Expecting "(" in parameters.')
2614             else:
2615                 return None
2616 
2617         args = []
2618         self.skip_ws()
2619         if not self.skip_string(')'):
2620             while 1:
2621                 self.skip_ws()
2622                 if self.skip_string('...'):
2623                     args.append(ASTFunctionParameter(None, True))
2624                     self.skip_ws()
2625                     if not self.skip_string(')'):
2626                         self.fail('Expected ")" after "..." in parameters.')
2627                     break
2628                 # note: it seems that function arguments can always be named,
2629                 # even in function pointers and similar.
2630                 arg = self._parse_type_with_init(outer=None, named='single')
2631                 # TODO: parse default parameters # TODO: didn't we just do that?
2632                 args.append(ASTFunctionParameter(arg))
2633 
2634                 self.skip_ws()
2635                 if self.skip_string(','):
2636                     continue
2637                 elif self.skip_string(')'):
2638                     break
2639                 else:
2640                     self.fail(
2641                         'Expecting "," or ")" in parameters, '
2642                         'got "%s".' % self.current_char)
2643 
2644         attrs = []
2645         while True:
2646             attr = self._parse_attribute()
2647             if attr is None:
2648                 break
2649             attrs.append(attr)
2650 
2651         return ASTParameters(args, attrs)
2652 
2653     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:
2654         """Just parse the simple ones."""
2655         storage = None
2656         threadLocal = None
2657         inline = None
2658         restrict = None
2659         volatile = None
2660         const = None
2661         attrs = []
2662         while 1:  # accept any permutation of a subset of some decl-specs
2663             self.skip_ws()
2664             if not storage:
2665                 if outer == 'member':
2666                     if self.skip_word('auto'):
2667                         storage = 'auto'
2668                         continue
2669                     if self.skip_word('register'):
2670                         storage = 'register'
2671                         continue
2672                 if outer in ('member', 'function'):
2673                     if self.skip_word('static'):
2674                         storage = 'static'
2675                         continue
2676                     if self.skip_word('extern'):
2677                         storage = 'extern'
2678                         continue
2679             if outer == 'member' and not threadLocal:
2680                 if self.skip_word('thread_local'):
2681                     threadLocal = 'thread_local'
2682                     continue
2683                 if self.skip_word('_Thread_local'):
2684                     threadLocal = '_Thread_local'
2685                     continue
2686             if outer == 'function' and not inline:
2687                 inline = self.skip_word('inline')
2688                 if inline:
2689                     continue
2690 
2691             if not restrict and typed:
2692                 restrict = self.skip_word('restrict')
2693                 if restrict:
2694                     continue
2695             if not volatile and typed:
2696                 volatile = self.skip_word('volatile')
2697                 if volatile:
2698                     continue
2699             if not const and typed:
2700                 const = self.skip_word('const')
2701                 if const:
2702                     continue
2703             attr = self._parse_attribute()
2704             if attr:
2705                 attrs.append(attr)
2706                 continue
2707             break
2708         return ASTDeclSpecsSimple(storage, threadLocal, inline,
2709                                   restrict, volatile, const, attrs)
2710 
2711     def _parse_decl_specs(self, outer: str, typed: bool = True) -> ASTDeclSpecs:
2712         if outer:
2713             if outer not in ('type', 'member', 'function'):
2714                 raise Exception('Internal error, unknown outer "%s".' % outer)
2715         leftSpecs = self._parse_decl_specs_simple(outer, typed)
2716         rightSpecs = None
2717 
2718         if typed:
2719             trailing = self._parse_trailing_type_spec()
2720             rightSpecs = self._parse_decl_specs_simple(outer, typed)
2721         else:
2722             trailing = None
2723         return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)
2724 
2725     def _parse_declarator_name_suffix(
2726             self, named: Union[bool, str], paramMode: str, typed: bool
2727     ) -> ASTDeclarator:
2728         assert named in (True, False, 'single')
2729         # now we should parse the name, and then suffixes
2730         if named == 'single':
2731             if self.match(identifier_re):
2732                 if self.matched_text in _keywords:
2733                     self.fail("Expected identifier, "
2734                               "got keyword: %s" % self.matched_text)
2735                 if self.matched_text in self.config.c_extra_keywords:
2736                     msg = "Expected identifier, got user-defined keyword: %s." \
2737                           + " Remove it from c_extra_keywords to allow it as identifier.\n" \
2738                           + "Currently c_extra_keywords is %s."
2739                     self.fail(msg % (self.matched_text,
2740                                      str(self.config.c_extra_keywords)))
2741                 identifier = ASTIdentifier(self.matched_text)
2742                 declId = ASTNestedName([identifier], rooted=False)
2743             else:
2744                 declId = None
2745         elif named:
2746             declId = self._parse_nested_name()
2747         else:
2748             declId = None
2749         arrayOps = []
2750         while 1:
2751             self.skip_ws()
2752             if typed and self.skip_string('['):
2753                 self.skip_ws()
2754                 static = False
2755                 const = False
2756                 volatile = False
2757                 restrict = False
2758                 while True:
2759                     if not static:
2760                         if self.skip_word_and_ws('static'):
2761                             static = True
2762                             continue
2763                     if not const:
2764                         if self.skip_word_and_ws('const'):
2765                             const = True
2766                             continue
2767                     if not volatile:
2768                         if self.skip_word_and_ws('volatile'):
2769                             volatile = True
2770                             continue
2771                     if not restrict:
2772                         if self.skip_word_and_ws('restrict'):
2773                             restrict = True
2774                             continue
2775                     break
2776                 vla = False if static else self.skip_string_and_ws('*')
2777                 if vla:
2778                     if not self.skip_string(']'):
2779                         self.fail("Expected ']' in end of array operator.")
2780                     size = None
2781                 else:
2782                     if self.skip_string(']'):
2783                         size = None
2784                     else:
2785 
2786                         def parser():
2787                             return self._parse_expression()
2788                         size = self._parse_expression_fallback([']'], parser)
2789                         self.skip_ws()
2790                         if not self.skip_string(']'):
2791                             self.fail("Expected ']' in end of array operator.")
2792                 arrayOps.append(ASTArray(static, const, volatile, restrict, vla, size))
2793             else:
2794                 break
2795         param = self._parse_parameters(paramMode)
2796         if param is None and len(arrayOps) == 0:
2797             # perhaps a bit-field
2798             if named and paramMode == 'type' and typed:
2799                 self.skip_ws()
2800                 if self.skip_string(':'):
2801                     size = self._parse_constant_expression()
2802                     return ASTDeclaratorNameBitField(declId=declId, size=size)
2803         return ASTDeclaratorNameParam(declId=declId, arrayOps=arrayOps,
2804                                       param=param)
2805 
2806     def _parse_declarator(self, named: Union[bool, str], paramMode: str,
2807                           typed: bool = True) -> ASTDeclarator:
2808         # 'typed' here means 'parse return type stuff'
2809         if paramMode not in ('type', 'function'):
2810             raise Exception(
2811                 "Internal error, unknown paramMode '%s'." % paramMode)
2812         prevErrors = []
2813         self.skip_ws()
2814         if typed and self.skip_string('*'):
2815             self.skip_ws()
2816             restrict = False
2817             volatile = False
2818             const = False
2819             attrs = []
2820             while 1:
2821                 if not restrict:
2822                     restrict = self.skip_word_and_ws('restrict')
2823                     if restrict:
2824                         continue
2825                 if not volatile:
2826                     volatile = self.skip_word_and_ws('volatile')
2827                     if volatile:
2828                         continue
2829                 if not const:
2830                     const = self.skip_word_and_ws('const')
2831                     if const:
2832                         continue
2833                 attr = self._parse_attribute()
2834                 if attr is not None:
2835                     attrs.append(attr)
2836                     continue
2837                 break
2838             next = self._parse_declarator(named, paramMode, typed)
2839             return ASTDeclaratorPtr(next=next,
2840                                     restrict=restrict, volatile=volatile, const=const,
2841                                     attrs=attrs)
2842         if typed and self.current_char == '(':  # note: peeking, not skipping
2843             # maybe this is the beginning of params, try that first,
2844             # otherwise assume it's noptr->declarator > ( ptr-declarator )
2845             pos = self.pos
2846             try:
2847                 # assume this is params
2848                 res = self._parse_declarator_name_suffix(named, paramMode,
2849                                                          typed)
2850                 return res
2851             except DefinitionError as exParamQual:
2852                 msg = "If declarator-id with parameters"
2853                 if paramMode == 'function':
2854                     msg += " (e.g., 'void f(int arg)')"
2855                 prevErrors.append((exParamQual, msg))
2856                 self.pos = pos
2857                 try:
2858                     assert self.current_char == '('
2859                     self.skip_string('(')
2860                     # TODO: hmm, if there is a name, it must be in inner, right?
2861                     # TODO: hmm, if there must be parameters, they must b
2862                     # inside, right?
2863                     inner = self._parse_declarator(named, paramMode, typed)
2864                     if not self.skip_string(')'):
2865                         self.fail("Expected ')' in \"( ptr-declarator )\"")
2866                     next = self._parse_declarator(named=False,
2867                                                   paramMode="type",
2868                                                   typed=typed)
2869                     return ASTDeclaratorParen(inner=inner, next=next)
2870                 except DefinitionError as exNoPtrParen:
2871                     self.pos = pos
2872                     msg = "If parenthesis in noptr-declarator"
2873                     if paramMode == 'function':
2874                         msg += " (e.g., 'void (*f(int arg))(double)')"
2875                     prevErrors.append((exNoPtrParen, msg))
2876                     header = "Error in declarator"
2877                     raise self._make_multi_error(prevErrors, header) from exNoPtrParen
2878         pos = self.pos
2879         try:
2880             return self._parse_declarator_name_suffix(named, paramMode, typed)
2881         except DefinitionError as e:
2882             self.pos = pos
2883             prevErrors.append((e, "If declarator-id"))
2884             header = "Error in declarator or parameters"
2885             raise self._make_multi_error(prevErrors, header) from e
2886 
2887     def _parse_initializer(self, outer: str = None, allowFallback: bool = True
2888                            ) -> ASTInitializer:
2889         self.skip_ws()
2890         if outer == 'member' and False:  # TODO
2891             bracedInit = self._parse_braced_init_list()
2892             if bracedInit is not None:
2893                 return ASTInitializer(bracedInit, hasAssign=False)
2894 
2895         if not self.skip_string('='):
2896             return None
2897 
2898         bracedInit = self._parse_braced_init_list()
2899         if bracedInit is not None:
2900             return ASTInitializer(bracedInit)
2901 
2902         if outer == 'member':
2903             fallbackEnd: List[str] = []
2904         elif outer is None:  # function parameter
2905             fallbackEnd = [',', ')']
2906         else:
2907             self.fail("Internal error, initializer for outer '%s' not "
2908                       "implemented." % outer)
2909 
2910         def parser():
2911             return self._parse_assignment_expression()
2912 
2913         value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)
2914         return ASTInitializer(value)
2915 
2916     def _parse_type(self, named: Union[bool, str], outer: str = None) -> ASTType:
2917         """
2918         named=False|'single'|True: 'single' is e.g., for function objects which
2919         doesn't need to name the arguments, but otherwise is a single name
2920         """
2921         if outer:  # always named
2922             if outer not in ('type', 'member', 'function'):
2923                 raise Exception('Internal error, unknown outer "%s".' % outer)
2924             assert named
2925 
2926         if outer == 'type':
2927             # We allow type objects to just be a name.
2928             prevErrors = []
2929             startPos = self.pos
2930             # first try without the type
2931             try:
2932                 declSpecs = self._parse_decl_specs(outer=outer, typed=False)
2933                 decl = self._parse_declarator(named=True, paramMode=outer,
2934                                               typed=False)
2935                 self.assert_end(allowSemicolon=True)
2936             except DefinitionError as exUntyped:
2937                 desc = "If just a name"
2938                 prevErrors.append((exUntyped, desc))
2939                 self.pos = startPos
2940                 try:
2941                     declSpecs = self._parse_decl_specs(outer=outer)
2942                     decl = self._parse_declarator(named=True, paramMode=outer)
2943                 except DefinitionError as exTyped:
2944                     self.pos = startPos
2945                     desc = "If typedef-like declaration"
2946                     prevErrors.append((exTyped, desc))
2947                     # Retain the else branch for easier debugging.
2948                     # TODO: it would be nice to save the previous stacktrace
2949                     #       and output it here.
2950                     if True:
2951                         header = "Type must be either just a name or a "
2952                         header += "typedef-like declaration."
2953                         raise self._make_multi_error(prevErrors, header) from exTyped
2954                     else:
2955                         # For testing purposes.
2956                         # do it again to get the proper traceback (how do you
2957                         # reliably save a traceback when an exception is
2958                         # constructed?)
2959                         self.pos = startPos
2960                         typed = True
2961                         declSpecs = self._parse_decl_specs(outer=outer, typed=typed)
2962                         decl = self._parse_declarator(named=True, paramMode=outer,
2963                                                       typed=typed)
2964         elif outer == 'function':
2965             declSpecs = self._parse_decl_specs(outer=outer)
2966             decl = self._parse_declarator(named=True, paramMode=outer)
2967         else:
2968             paramMode = 'type'
2969             if outer == 'member':  # i.e., member
2970                 named = True
2971             declSpecs = self._parse_decl_specs(outer=outer)
2972             decl = self._parse_declarator(named=named, paramMode=paramMode)
2973         return ASTType(declSpecs, decl)
2974 
2975     def _parse_type_with_init(self, named: Union[bool, str], outer: str) -> ASTTypeWithInit:
2976         if outer:
2977             assert outer in ('type', 'member', 'function')
2978         type = self._parse_type(outer=outer, named=named)
2979         init = self._parse_initializer(outer=outer)
2980         return ASTTypeWithInit(type, init)
2981 
2982     def _parse_macro(self) -> ASTMacro:
2983         self.skip_ws()
2984         ident = self._parse_nested_name()
2985         if ident is None:
2986             self.fail("Expected identifier in macro definition.")
2987         self.skip_ws()
2988         if not self.skip_string_and_ws('('):
2989             return ASTMacro(ident, None)
2990         if self.skip_string(')'):
2991             return ASTMacro(ident, [])
2992         args = []
2993         while 1:
2994             self.skip_ws()
2995             if self.skip_string('...'):
2996                 args.append(ASTMacroParameter(None, True))
2997                 self.skip_ws()
2998                 if not self.skip_string(')'):
2999                     self.fail('Expected ")" after "..." in macro parameters.')
3000                 break
3001             if not self.match(identifier_re):
3002                 self.fail("Expected identifier in macro parameters.")
3003             nn = ASTNestedName([ASTIdentifier(self.matched_text)], rooted=False)
3004             # Allow named variadic args:
3005             # https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html
3006             self.skip_ws()
3007             if self.skip_string_and_ws('...'):
3008                 args.append(ASTMacroParameter(nn, False, True))
3009                 self.skip_ws()
3010                 if not self.skip_string(')'):
3011                     self.fail('Expected ")" after "..." in macro parameters.')
3012                 break
3013             args.append(ASTMacroParameter(nn))
3014             if self.skip_string_and_ws(','):
3015                 continue
3016             elif self.skip_string_and_ws(')'):
3017                 break
3018             else:
3019                 self.fail("Expected identifier, ')', or ',' in macro parameter list.")
3020         return ASTMacro(ident, args)
3021 
3022     def _parse_struct(self) -> ASTStruct:
3023         name = self._parse_nested_name()
3024         return ASTStruct(name)
3025 
3026     def _parse_union(self) -> ASTUnion:
3027         name = self._parse_nested_name()
3028         return ASTUnion(name)
3029 
3030     def _parse_enum(self) -> ASTEnum:
3031         name = self._parse_nested_name()
3032         return ASTEnum(name)
3033 
3034     def _parse_enumerator(self) -> ASTEnumerator:
3035         name = self._parse_nested_name()
3036         self.skip_ws()
3037         init = None
3038         if self.skip_string('='):
3039             self.skip_ws()
3040 
3041             def parser() -> ASTExpression:
3042                 return self._parse_constant_expression()
3043 
3044             initVal = self._parse_expression_fallback([], parser)
3045             init = ASTInitializer(initVal)
3046         return ASTEnumerator(name, init)
3047 
3048     def parse_pre_v3_type_definition(self) -> ASTDeclaration:
3049         self.skip_ws()
3050         declaration: DeclarationType = None
3051         if self.skip_word('struct'):
3052             typ = 'struct'
3053             declaration = self._parse_struct()
3054         elif self.skip_word('union'):
3055             typ = 'union'
3056             declaration = self._parse_union()
3057         elif self.skip_word('enum'):
3058             typ = 'enum'
3059             declaration = self._parse_enum()
3060         else:
3061             self.fail("Could not parse pre-v3 type directive."
3062                       " Must start with 'struct', 'union', or 'enum'.")
3063         return ASTDeclaration(typ, typ, declaration, False)
3064 
3065     def parse_declaration(self, objectType: str, directiveType: str) -> ASTDeclaration:
3066         if objectType not in ('function', 'member',
3067                               'macro', 'struct', 'union', 'enum', 'enumerator', 'type'):
3068             raise Exception('Internal error, unknown objectType "%s".' % objectType)
3069         if directiveType not in ('function', 'member', 'var',
3070                                  'macro', 'struct', 'union', 'enum', 'enumerator', 'type'):
3071             raise Exception('Internal error, unknown directiveType "%s".' % directiveType)
3072 
3073         declaration: DeclarationType = None
3074         if objectType == 'member':
3075             declaration = self._parse_type_with_init(named=True, outer='member')
3076         elif objectType == 'function':
3077             declaration = self._parse_type(named=True, outer='function')
3078         elif objectType == 'macro':
3079             declaration = self._parse_macro()
3080         elif objectType == 'struct':
3081             declaration = self._parse_struct()
3082         elif objectType == 'union':
3083             declaration = self._parse_union()
3084         elif objectType == 'enum':
3085             declaration = self._parse_enum()
3086         elif objectType == 'enumerator':
3087             declaration = self._parse_enumerator()
3088         elif objectType == 'type':
3089             declaration = self._parse_type(named=True, outer='type')
3090         else:
3091             assert False
3092         if objectType != 'macro':
3093             self.skip_ws()
3094             semicolon = self.skip_string(';')
3095         else:
3096             semicolon = False
3097         return ASTDeclaration(objectType, directiveType, declaration, semicolon)
3098 
3099     def parse_namespace_object(self) -> ASTNestedName:
3100         return self._parse_nested_name()
3101 
3102     def parse_xref_object(self) -> ASTNestedName:
3103         name = self._parse_nested_name()
3104         # if there are '()' left, just skip them
3105         self.skip_ws()
3106         self.skip_string('()')
3107         self.assert_end()
3108         return name
3109 
3110     def parse_expression(self) -> Union[ASTExpression, ASTType]:
3111         pos = self.pos
3112         res: Union[ASTExpression, ASTType] = None
3113         try:
3114             res = self._parse_expression()
3115             self.skip_ws()
3116             self.assert_end()
3117         except DefinitionError as exExpr:
3118             self.pos = pos
3119             try:
3120                 res = self._parse_type(False)
3121                 self.skip_ws()
3122                 self.assert_end()
3123             except DefinitionError as exType:
3124                 header = "Error when parsing (type) expression."
3125                 errs = []
3126                 errs.append((exExpr, "If expression"))
3127                 errs.append((exType, "If type"))
3128                 raise self._make_multi_error(errs, header) from exType
3129         return res

</code><intended_behavior>Adjust the id_attributes property and perhaps the setup method as needed to ensure that when Sphinx encounters attributes in enum value declarations (like __attribute__((__deprecated__)) or macros intended for deprecation signals), these attributes are either ignored or processed in a way that does not interfere with the correct identification of the enum value names. This might involve modifying how c_id_attributes is used within this parsing context to ensure attributes in enums are handled according to the expected documentation output, without misinterpretation or causing duplicate declaration issues.</intended_behavior>, <file>sphinx/domains/cpp.py</file>
<class>DefinitionParser</class>
<method>None</method>
<code>
5087 class DefinitionParser(BaseParser):
5088     @property
5089     def language(self) -> str:
5090         return 'C++'
5091 
5092     @property
5093     def id_attributes(self):
5094         return self.config.cpp_id_attributes
5095 
5096     @property
5097     def paren_attributes(self):
5098         return self.config.cpp_paren_attributes
5099 
5100     def _parse_string(self) -> str:
5101         if self.current_char != '"':
5102             return None
5103         startPos = self.pos
5104         self.pos += 1
5105         escape = False
5106         while True:
5107             if self.eof:
5108                 self.fail("Unexpected end during inside string.")
5109             elif self.current_char == '"' and not escape:
5110                 self.pos += 1
5111                 break
5112             elif self.current_char == '\\':
5113                 escape = True
5114             else:
5115                 escape = False
5116             self.pos += 1
5117         return self.definition[startPos:self.pos]
5118 
5119     def _parse_literal(self) -> ASTLiteral:
5120         # -> integer-literal
5121         #  | character-literal
5122         #  | floating-literal
5123         #  | string-literal
5124         #  | boolean-literal -> "false" | "true"
5125         #  | pointer-literal -> "nullptr"
5126         #  | user-defined-literal
5127 
5128         def _udl(literal: ASTLiteral) -> ASTLiteral:
5129             if not self.match(udl_identifier_re):
5130                 return literal
5131             # hmm, should we care if it's a keyword?
5132             # it looks like GCC does not disallow keywords
5133             ident = ASTIdentifier(self.matched_text)
5134             return ASTUserDefinedLiteral(literal, ident)
5135 
5136         self.skip_ws()
5137         if self.skip_word('nullptr'):
5138             return ASTPointerLiteral()
5139         if self.skip_word('true'):
5140             return ASTBooleanLiteral(True)
5141         if self.skip_word('false'):
5142             return ASTBooleanLiteral(False)
5143         pos = self.pos
5144         if self.match(float_literal_re):
5145             hasSuffix = self.match(float_literal_suffix_re)
5146             floatLit = ASTNumberLiteral(self.definition[pos:self.pos])
5147             if hasSuffix:
5148                 return floatLit
5149             else:
5150                 return _udl(floatLit)
5151         for regex in [binary_literal_re, hex_literal_re,
5152                       integer_literal_re, octal_literal_re]:
5153             if self.match(regex):
5154                 hasSuffix = self.match(integers_literal_suffix_re)
5155                 intLit = ASTNumberLiteral(self.definition[pos:self.pos])
5156                 if hasSuffix:
5157                     return intLit
5158                 else:
5159                     return _udl(intLit)
5160 
5161         string = self._parse_string()
5162         if string is not None:
5163             return _udl(ASTStringLiteral(string))
5164 
5165         # character-literal
5166         if self.match(char_literal_re):
5167             prefix = self.last_match.group(1)  # may be None when no prefix
5168             data = self.last_match.group(2)
5169             try:
5170                 charLit = ASTCharLiteral(prefix, data)
5171             except UnicodeDecodeError as e:
5172                 self.fail("Can not handle character literal. Internal error was: %s" % e)
5173             except UnsupportedMultiCharacterCharLiteral:
5174                 self.fail("Can not handle character literal"
5175                           " resulting in multiple decoded characters.")
5176             return _udl(charLit)
5177         return None
5178 
5179     def _parse_fold_or_paren_expression(self) -> ASTExpression:
5180         # "(" expression ")"
5181         # fold-expression
5182         # -> ( cast-expression fold-operator ... )
5183         #  | ( ... fold-operator cast-expression )
5184         #  | ( cast-expression fold-operator ... fold-operator cast-expression
5185         if self.current_char != '(':
5186             return None
5187         self.pos += 1
5188         self.skip_ws()
5189         if self.skip_string_and_ws("..."):
5190             # ( ... fold-operator cast-expression )
5191             if not self.match(_fold_operator_re):
5192                 self.fail("Expected fold operator after '...' in fold expression.")
5193             op = self.matched_text
5194             rightExpr = self._parse_cast_expression()
5195             if not self.skip_string(')'):
5196                 self.fail("Expected ')' in end of fold expression.")
5197             return ASTFoldExpr(None, op, rightExpr)
5198         # try first parsing a unary right fold, or a binary fold
5199         pos = self.pos
5200         try:
5201             self.skip_ws()
5202             leftExpr = self._parse_cast_expression()
5203             self.skip_ws()
5204             if not self.match(_fold_operator_re):
5205                 self.fail("Expected fold operator after left expression in fold expression.")
5206             op = self.matched_text
5207             self.skip_ws()
5208             if not self.skip_string_and_ws('...'):
5209                 self.fail("Expected '...' after fold operator in fold expression.")
5210         except DefinitionError as eFold:
5211             self.pos = pos
5212             # fall back to a paren expression
5213             try:
5214                 res = self._parse_expression()
5215                 self.skip_ws()
5216                 if not self.skip_string(')'):
5217                     self.fail("Expected ')' in end of parenthesized expression.")
5218             except DefinitionError as eExpr:
5219                 raise self._make_multi_error([
5220                     (eFold, "If fold expression"),
5221                     (eExpr, "If parenthesized expression")
5222                 ], "Error in fold expression or parenthesized expression.") from eExpr
5223             return ASTParenExpr(res)
5224         # now it definitely is a fold expression
5225         if self.skip_string(')'):
5226             return ASTFoldExpr(leftExpr, op, None)
5227         if not self.match(_fold_operator_re):
5228             self.fail("Expected fold operator or ')' after '...' in fold expression.")
5229         if op != self.matched_text:
5230             self.fail("Operators are different in binary fold: '%s' and '%s'."
5231                       % (op, self.matched_text))
5232         rightExpr = self._parse_cast_expression()
5233         self.skip_ws()
5234         if not self.skip_string(')'):
5235             self.fail("Expected ')' to end binary fold expression.")
5236         return ASTFoldExpr(leftExpr, op, rightExpr)
5237 
5238     def _parse_primary_expression(self) -> ASTExpression:
5239         # literal
5240         # "this"
5241         # lambda-expression
5242         # "(" expression ")"
5243         # fold-expression
5244         # id-expression -> we parse this with _parse_nested_name
5245         self.skip_ws()
5246         res: ASTExpression = self._parse_literal()
5247         if res is not None:
5248             return res
5249         self.skip_ws()
5250         if self.skip_word("this"):
5251             return ASTThisLiteral()
5252         # TODO: try lambda expression
5253         res = self._parse_fold_or_paren_expression()
5254         if res is not None:
5255             return res
5256         nn = self._parse_nested_name()
5257         if nn is not None:
5258             return ASTIdExpression(nn)
5259         return None
5260 
5261     def _parse_initializer_list(self, name: str, open: str, close: str
5262                                 ) -> Tuple[List[Union[ASTExpression,
5263                                                       ASTBracedInitList]],
5264                                            bool]:
5265         # Parse open and close with the actual initializer-list in between
5266         # -> initializer-clause '...'[opt]
5267         #  | initializer-list ',' initializer-clause '...'[opt]
5268         self.skip_ws()
5269         if not self.skip_string_and_ws(open):
5270             return None, None
5271         if self.skip_string(close):
5272             return [], False
5273 
5274         exprs: List[Union[ASTExpression, ASTBracedInitList]] = []
5275         trailingComma = False
5276         while True:
5277             self.skip_ws()
5278             expr = self._parse_initializer_clause()
5279             self.skip_ws()
5280             if self.skip_string('...'):
5281                 exprs.append(ASTPackExpansionExpr(expr))
5282             else:
5283                 exprs.append(expr)
5284             self.skip_ws()
5285             if self.skip_string(close):
5286                 break
5287             if not self.skip_string_and_ws(','):
5288                 self.fail("Error in %s, expected ',' or '%s'." % (name, close))
5289             if self.current_char == close and close == '}':
5290                 self.pos += 1
5291                 trailingComma = True
5292                 break
5293         return exprs, trailingComma
5294 
5295     def _parse_paren_expression_list(self) -> ASTParenExprList:
5296         # -> '(' expression-list ')'
5297         # though, we relax it to also allow empty parens
5298         # as it's needed in some cases
5299         #
5300         # expression-list
5301         # -> initializer-list
5302         exprs, trailingComma = self._parse_initializer_list("parenthesized expression-list",
5303                                                             '(', ')')
5304         if exprs is None:
5305             return None
5306         return ASTParenExprList(exprs)
5307 
5308     def _parse_initializer_clause(self) -> Union[ASTExpression, ASTBracedInitList]:
5309         bracedInitList = self._parse_braced_init_list()
5310         if bracedInitList is not None:
5311             return bracedInitList
5312         return self._parse_assignment_expression(inTemplate=False)
5313 
5314     def _parse_braced_init_list(self) -> ASTBracedInitList:
5315         # -> '{' initializer-list ','[opt] '}'
5316         #  | '{' '}'
5317         exprs, trailingComma = self._parse_initializer_list("braced-init-list", '{', '}')
5318         if exprs is None:
5319             return None
5320         return ASTBracedInitList(exprs, trailingComma)
5321 
5322     def _parse_expression_list_or_braced_init_list(
5323         self
5324     ) -> Union[ASTParenExprList, ASTBracedInitList]:
5325         paren = self._parse_paren_expression_list()
5326         if paren is not None:
5327             return paren
5328         return self._parse_braced_init_list()
5329 
5330     def _parse_postfix_expression(self) -> ASTPostfixExpr:
5331         # -> primary
5332         #  | postfix "[" expression "]"
5333         #  | postfix "[" braced-init-list [opt] "]"
5334         #  | postfix "(" expression-list [opt] ")"
5335         #  | postfix "." "template" [opt] id-expression
5336         #  | postfix "->" "template" [opt] id-expression
5337         #  | postfix "." pseudo-destructor-name
5338         #  | postfix "->" pseudo-destructor-name
5339         #  | postfix "++"
5340         #  | postfix "--"
5341         #  | simple-type-specifier "(" expression-list [opt] ")"
5342         #  | simple-type-specifier braced-init-list
5343         #  | typename-specifier "(" expression-list [opt] ")"
5344         #  | typename-specifier braced-init-list
5345         #  | "dynamic_cast" "<" type-id ">" "(" expression ")"
5346         #  | "static_cast" "<" type-id ">" "(" expression ")"
5347         #  | "reinterpret_cast" "<" type-id ">" "(" expression ")"
5348         #  | "const_cast" "<" type-id ">" "(" expression ")"
5349         #  | "typeid" "(" expression ")"
5350         #  | "typeid" "(" type-id ")"
5351 
5352         prefixType = None
5353         prefix: Any = None
5354         self.skip_ws()
5355 
5356         cast = None
5357         for c in _id_explicit_cast:
5358             if self.skip_word_and_ws(c):
5359                 cast = c
5360                 break
5361         if cast is not None:
5362             prefixType = "cast"
5363             if not self.skip_string("<"):
5364                 self.fail("Expected '<' after '%s'." % cast)
5365             typ = self._parse_type(False)
5366             self.skip_ws()
5367             if not self.skip_string_and_ws(">"):
5368                 self.fail("Expected '>' after type in '%s'." % cast)
5369             if not self.skip_string("("):
5370                 self.fail("Expected '(' in '%s'." % cast)
5371 
5372             def parser() -> ASTExpression:
5373                 return self._parse_expression()
5374             expr = self._parse_expression_fallback([')'], parser)
5375             self.skip_ws()
5376             if not self.skip_string(")"):
5377                 self.fail("Expected ')' to end '%s'." % cast)
5378             prefix = ASTExplicitCast(cast, typ, expr)
5379         elif self.skip_word_and_ws("typeid"):
5380             prefixType = "typeid"
5381             if not self.skip_string_and_ws('('):
5382                 self.fail("Expected '(' after 'typeid'.")
5383             pos = self.pos
5384             try:
5385                 typ = self._parse_type(False)
5386                 prefix = ASTTypeId(typ, isType=True)
5387                 if not self.skip_string(')'):
5388                     self.fail("Expected ')' to end 'typeid' of type.")
5389             except DefinitionError as eType:
5390                 self.pos = pos
5391                 try:
5392 
5393                     def parser() -> ASTExpression:
5394                         return self._parse_expression()
5395                     expr = self._parse_expression_fallback([')'], parser)
5396                     prefix = ASTTypeId(expr, isType=False)
5397                     if not self.skip_string(')'):
5398                         self.fail("Expected ')' to end 'typeid' of expression.")
5399                 except DefinitionError as eExpr:
5400                     self.pos = pos
5401                     header = "Error in 'typeid(...)'."
5402                     header += " Expected type or expression."
5403                     errors = []
5404                     errors.append((eType, "If type"))
5405                     errors.append((eExpr, "If expression"))
5406                     raise self._make_multi_error(errors, header) from eExpr
5407         else:  # a primary expression or a type
5408             pos = self.pos
5409             try:
5410                 prefix = self._parse_primary_expression()
5411                 prefixType = 'expr'
5412             except DefinitionError as eOuter:
5413                 self.pos = pos
5414                 try:
5415                     # we are potentially casting, so save parens for us
5416                     # TODO: hmm, would we need to try both with operatorCast and with None?
5417                     prefix = self._parse_type(False, 'operatorCast')
5418                     prefixType = 'typeOperatorCast'
5419                     #  | simple-type-specifier "(" expression-list [opt] ")"
5420                     #  | simple-type-specifier braced-init-list
5421                     #  | typename-specifier "(" expression-list [opt] ")"
5422                     #  | typename-specifier braced-init-list
5423                     self.skip_ws()
5424                     if self.current_char != '(' and self.current_char != '{':
5425                         self.fail("Expecting '(' or '{' after type in cast expression.")
5426                 except DefinitionError as eInner:
5427                     self.pos = pos
5428                     header = "Error in postfix expression,"
5429                     header += " expected primary expression or type."
5430                     errors = []
5431                     errors.append((eOuter, "If primary expression"))
5432                     errors.append((eInner, "If type"))
5433                     raise self._make_multi_error(errors, header) from eInner
5434 
5435         # and now parse postfixes
5436         postFixes: List[ASTPostfixOp] = []
5437         while True:
5438             self.skip_ws()
5439             if prefixType in ('expr', 'cast', 'typeid'):
5440                 if self.skip_string_and_ws('['):
5441                     expr = self._parse_expression()
5442                     self.skip_ws()
5443                     if not self.skip_string(']'):
5444                         self.fail("Expected ']' in end of postfix expression.")
5445                     postFixes.append(ASTPostfixArray(expr))
5446                     continue
5447                 if self.skip_string('.'):
5448                     if self.skip_string('*'):
5449                         # don't steal the dot
5450                         self.pos -= 2
5451                     elif self.skip_string('..'):
5452                         # don't steal the dot
5453                         self.pos -= 3
5454                     else:
5455                         name = self._parse_nested_name()
5456                         postFixes.append(ASTPostfixMember(name))
5457                         continue
5458                 if self.skip_string('->'):
5459                     if self.skip_string('*'):
5460                         # don't steal the arrow
5461                         self.pos -= 3
5462                     else:
5463                         name = self._parse_nested_name()
5464                         postFixes.append(ASTPostfixMemberOfPointer(name))
5465                         continue
5466                 if self.skip_string('++'):
5467                     postFixes.append(ASTPostfixInc())
5468                     continue
5469                 if self.skip_string('--'):
5470                     postFixes.append(ASTPostfixDec())
5471                     continue
5472             lst = self._parse_expression_list_or_braced_init_list()
5473             if lst is not None:
5474                 postFixes.append(ASTPostfixCallExpr(lst))
5475                 continue
5476             break
5477         return ASTPostfixExpr(prefix, postFixes)
5478 
5479     def _parse_unary_expression(self) -> ASTExpression:
5480         # -> postfix
5481         #  | "++" cast
5482         #  | "--" cast
5483         #  | unary-operator cast -> (* | & | + | - | ! | ~) cast
5484         # The rest:
5485         #  | "sizeof" unary
5486         #  | "sizeof" "(" type-id ")"
5487         #  | "sizeof" "..." "(" identifier ")"
5488         #  | "alignof" "(" type-id ")"
5489         #  | noexcept-expression -> noexcept "(" expression ")"
5490         #  | new-expression
5491         #  | delete-expression
5492         self.skip_ws()
5493         for op in _expression_unary_ops:
5494             # TODO: hmm, should we be able to backtrack here?
5495             if op[0] in 'cn':
5496                 res = self.skip_word(op)
5497             else:
5498                 res = self.skip_string(op)
5499             if res:
5500                 expr = self._parse_cast_expression()
5501                 return ASTUnaryOpExpr(op, expr)
5502         if self.skip_word_and_ws('sizeof'):
5503             if self.skip_string_and_ws('...'):
5504                 if not self.skip_string_and_ws('('):
5505                     self.fail("Expecting '(' after 'sizeof...'.")
5506                 if not self.match(identifier_re):
5507                     self.fail("Expecting identifier for 'sizeof...'.")
5508                 ident = ASTIdentifier(self.matched_text)
5509                 self.skip_ws()
5510                 if not self.skip_string(")"):
5511                     self.fail("Expecting ')' to end 'sizeof...'.")
5512                 return ASTSizeofParamPack(ident)
5513             if self.skip_string_and_ws('('):
5514                 typ = self._parse_type(named=False)
5515                 self.skip_ws()
5516                 if not self.skip_string(')'):
5517                     self.fail("Expecting ')' to end 'sizeof'.")
5518                 return ASTSizeofType(typ)
5519             expr = self._parse_unary_expression()
5520             return ASTSizeofExpr(expr)
5521         if self.skip_word_and_ws('alignof'):
5522             if not self.skip_string_and_ws('('):
5523                 self.fail("Expecting '(' after 'alignof'.")
5524             typ = self._parse_type(named=False)
5525             self.skip_ws()
5526             if not self.skip_string(')'):
5527                 self.fail("Expecting ')' to end 'alignof'.")
5528             return ASTAlignofExpr(typ)
5529         if self.skip_word_and_ws('noexcept'):
5530             if not self.skip_string_and_ws('('):
5531                 self.fail("Expecting '(' after 'noexcept'.")
5532             expr = self._parse_expression()
5533             self.skip_ws()
5534             if not self.skip_string(')'):
5535                 self.fail("Expecting ')' to end 'noexcept'.")
5536             return ASTNoexceptExpr(expr)
5537         # new-expression
5538         pos = self.pos
5539         rooted = self.skip_string('::')
5540         self.skip_ws()
5541         if not self.skip_word_and_ws('new'):
5542             self.pos = pos
5543         else:
5544             # new-placement[opt] new-type-id new-initializer[opt]
5545             # new-placement[opt] ( type-id ) new-initializer[opt]
5546             isNewTypeId = True
5547             if self.skip_string_and_ws('('):
5548                 # either this is a new-placement or it's the second production
5549                 # without placement, and it's actually the ( type-id ) part
5550                 self.fail("Sorry, neither new-placement nor parenthesised type-id "
5551                           "in new-epression is supported yet.")
5552                 # set isNewTypeId = False if it's (type-id)
5553             if isNewTypeId:
5554                 declSpecs = self._parse_decl_specs(outer=None)
5555                 decl = self._parse_declarator(named=False, paramMode="new")
5556             else:
5557                 self.fail("Sorry, parenthesised type-id in new expression not yet supported.")
5558             lst = self._parse_expression_list_or_braced_init_list()
5559             return ASTNewExpr(rooted, isNewTypeId, ASTType(declSpecs, decl), lst)
5560         # delete-expression
5561         pos = self.pos
5562         rooted = self.skip_string('::')
5563         self.skip_ws()
5564         if not self.skip_word_and_ws('delete'):
5565             self.pos = pos
5566         else:
5567             array = self.skip_string_and_ws('[')
5568             if array and not self.skip_string_and_ws(']'):
5569                 self.fail("Expected ']' in array delete-expression.")
5570             expr = self._parse_cast_expression()
5571             return ASTDeleteExpr(rooted, array, expr)
5572         return self._parse_postfix_expression()
5573 
5574     def _parse_cast_expression(self) -> ASTExpression:
5575         # -> unary  | "(" type-id ")" cast
5576         pos = self.pos
5577         self.skip_ws()
5578         if self.skip_string('('):
5579             try:
5580                 typ = self._parse_type(False)
5581                 if not self.skip_string(')'):
5582                     self.fail("Expected ')' in cast expression.")
5583                 expr = self._parse_cast_expression()
5584                 return ASTCastExpr(typ, expr)
5585             except DefinitionError as exCast:
5586                 self.pos = pos
5587                 try:
5588                     return self._parse_unary_expression()
5589                 except DefinitionError as exUnary:
5590                     errs = []
5591                     errs.append((exCast, "If type cast expression"))
5592                     errs.append((exUnary, "If unary expression"))
5593                     raise self._make_multi_error(errs,
5594                                                  "Error in cast expression.") from exUnary
5595         else:
5596             return self._parse_unary_expression()
5597 
5598     def _parse_logical_or_expression(self, inTemplate: bool) -> ASTExpression:
5599         # logical-or     = logical-and      ||
5600         # logical-and    = inclusive-or     &&
5601         # inclusive-or   = exclusive-or     |
5602         # exclusive-or   = and              ^
5603         # and            = equality         &
5604         # equality       = relational       ==, !=
5605         # relational     = shift            <, >, <=, >=, <=>
5606         # shift          = additive         <<, >>
5607         # additive       = multiplicative   +, -
5608         # multiplicative = pm               *, /, %
5609         # pm             = cast             .*, ->*
5610         def _parse_bin_op_expr(self: DefinitionParser,
5611                                opId: int, inTemplate: bool) -> ASTExpression:
5612             if opId + 1 == len(_expression_bin_ops):
5613                 def parser(inTemplate: bool) -> ASTExpression:
5614                     return self._parse_cast_expression()
5615             else:
5616                 def parser(inTemplate: bool) -> ASTExpression:
5617                     return _parse_bin_op_expr(self, opId + 1, inTemplate=inTemplate)
5618             exprs = []
5619             ops = []
5620             exprs.append(parser(inTemplate=inTemplate))
5621             while True:
5622                 self.skip_ws()
5623                 if inTemplate and self.current_char == '>':
5624                     break
5625                 pos = self.pos
5626                 oneMore = False
5627                 for op in _expression_bin_ops[opId]:
5628                     if op[0] in 'abcnox':
5629                         if not self.skip_word(op):
5630                             continue
5631                     else:
5632                         if not self.skip_string(op):
5633                             continue
5634                     if op == '&' and self.current_char == '&':
5635                         # don't split the && 'token'
5636                         self.pos -= 1
5637                         # and btw. && has lower precedence, so we are done
5638                         break
5639                     try:
5640                         expr = parser(inTemplate=inTemplate)
5641                         exprs.append(expr)
5642                         ops.append(op)
5643                         oneMore = True
5644                         break
5645                     except DefinitionError:
5646                         self.pos = pos
5647                 if not oneMore:
5648                     break
5649             return ASTBinOpExpr(exprs, ops)
5650         return _parse_bin_op_expr(self, 0, inTemplate=inTemplate)
5651 
5652     def _parse_conditional_expression_tail(self, orExprHead: ASTExpression,
5653                                            inTemplate: bool) -> Optional[ASTConditionalExpr]:
5654         # Consumes the orExprHead on success.
5655 
5656         # -> "?" expression ":" assignment-expression
5657         self.skip_ws()
5658         if not self.skip_string("?"):
5659             return None
5660         thenExpr = self._parse_expression()
5661         self.skip_ws()
5662         if not self.skip_string(":"):
5663             self.fail('Expected ":" after then-expression in conditional expression.')
5664         elseExpr = self._parse_assignment_expression(inTemplate)
5665         return ASTConditionalExpr(orExprHead, thenExpr, elseExpr)
5666 
5667     def _parse_assignment_expression(self, inTemplate: bool) -> ASTExpression:
5668         # -> conditional-expression
5669         #  | logical-or-expression assignment-operator initializer-clause
5670         #  | yield-expression -> "co_yield" assignment-expression
5671         #                      | "co_yield" braced-init-list
5672         #  | throw-expression -> "throw" assignment-expression[opt]
5673         # TODO: yield-expression
5674         # TODO: throw-expression
5675 
5676         # Now we have (after expanding conditional-expression:
5677         #     logical-or-expression
5678         #   | logical-or-expression "?" expression ":" assignment-expression
5679         #   | logical-or-expression assignment-operator initializer-clause
5680         leftExpr = self._parse_logical_or_expression(inTemplate=inTemplate)
5681         # the ternary operator
5682         condExpr = self._parse_conditional_expression_tail(leftExpr, inTemplate)
5683         if condExpr is not None:
5684             return condExpr
5685         # and actual assignment
5686         for op in _expression_assignment_ops:
5687             if op[0] in 'anox':
5688                 if not self.skip_word(op):
5689                     continue
5690             else:
5691                 if not self.skip_string(op):
5692                     continue
5693             rightExpr = self._parse_initializer_clause()
5694             return ASTAssignmentExpr(leftExpr, op, rightExpr)
5695         # just a logical-or-expression
5696         return leftExpr
5697 
5698     def _parse_constant_expression(self, inTemplate: bool) -> ASTExpression:
5699         # -> conditional-expression ->
5700         #    logical-or-expression
5701         #  | logical-or-expression "?" expression ":" assignment-expression
5702         orExpr = self._parse_logical_or_expression(inTemplate=inTemplate)
5703         condExpr = self._parse_conditional_expression_tail(orExpr, inTemplate)
5704         if condExpr is not None:
5705             return condExpr
5706         return orExpr
5707 
5708     def _parse_expression(self) -> ASTExpression:
5709         # -> assignment-expression
5710         #  | expression "," assignment-expression
5711         exprs = [self._parse_assignment_expression(inTemplate=False)]
5712         while True:
5713             self.skip_ws()
5714             if not self.skip_string(','):
5715                 break
5716             exprs.append(self._parse_assignment_expression(inTemplate=False))
5717         if len(exprs) == 1:
5718             return exprs[0]
5719         else:
5720             return ASTCommaExpr(exprs)
5721 
5722     def _parse_expression_fallback(self, end: List[str],
5723                                    parser: Callable[[], ASTExpression],
5724                                    allow: bool = True) -> ASTExpression:
5725         # Stupidly "parse" an expression.
5726         # 'end' should be a list of characters which ends the expression.
5727 
5728         # first try to use the provided parser
5729         prevPos = self.pos
5730         try:
5731             return parser()
5732         except DefinitionError as e:
5733             # some places (e.g., template parameters) we really don't want to use fallback,
5734             # and for testing we may want to globally disable it
5735             if not allow or not self.allowFallbackExpressionParsing:
5736                 raise
5737             self.warn("Parsing of expression failed. Using fallback parser."
5738                       " Error was:\n%s" % e)
5739             self.pos = prevPos
5740         # and then the fallback scanning
5741         assert end is not None
5742         self.skip_ws()
5743         startPos = self.pos
5744         if self.match(_string_re):
5745             value = self.matched_text
5746         else:
5747             # TODO: add handling of more bracket-like things, and quote handling
5748             brackets = {'(': ')', '{': '}', '[': ']', '<': '>'}
5749             symbols: List[str] = []
5750             while not self.eof:
5751                 if (len(symbols) == 0 and self.current_char in end):
5752                     break
5753                 if self.current_char in brackets.keys():
5754                     symbols.append(brackets[self.current_char])
5755                 elif len(symbols) > 0 and self.current_char == symbols[-1]:
5756                     symbols.pop()
5757                 self.pos += 1
5758             if len(end) > 0 and self.eof:
5759                 self.fail("Could not find end of expression starting at %d."
5760                           % startPos)
5761             value = self.definition[startPos:self.pos].strip()
5762         return ASTFallbackExpr(value.strip())
5763 
5764     # ==========================================================================
5765 
5766     def _parse_operator(self) -> ASTOperator:
5767         self.skip_ws()
5768         # adapted from the old code
5769         # yay, a regular operator definition
5770         if self.match(_operator_re):
5771             return ASTOperatorBuildIn(self.matched_text)
5772 
5773         # new/delete operator?
5774         for op in 'new', 'delete':
5775             if not self.skip_word(op):
5776                 continue
5777             self.skip_ws()
5778             if self.skip_string('['):
5779                 self.skip_ws()
5780                 if not self.skip_string(']'):
5781                     self.fail('Expected "]" after  "operator ' + op + '["')
5782                 op += '[]'
5783             return ASTOperatorBuildIn(op)
5784 
5785         # user-defined literal?
5786         if self.skip_string('""'):
5787             self.skip_ws()
5788             if not self.match(identifier_re):
5789                 self.fail("Expected user-defined literal suffix.")
5790             identifier = ASTIdentifier(self.matched_text)
5791             return ASTOperatorLiteral(identifier)
5792 
5793         # oh well, looks like a cast operator definition.
5794         # In that case, eat another type.
5795         type = self._parse_type(named=False, outer="operatorCast")
5796         return ASTOperatorType(type)
5797 
5798     def _parse_template_argument_list(self) -> ASTTemplateArgs:
5799         # template-argument-list: (but we include the < and > here
5800         #    template-argument ...[opt]
5801         #    template-argument-list, template-argument ...[opt]
5802         # template-argument:
5803         #    constant-expression
5804         #    type-id
5805         #    id-expression
5806         self.skip_ws()
5807         if not self.skip_string_and_ws('<'):
5808             return None
5809         if self.skip_string('>'):
5810             return ASTTemplateArgs([], False)
5811         prevErrors = []
5812         templateArgs: List[Union[ASTType, ASTTemplateArgConstant]] = []
5813         packExpansion = False
5814         while 1:
5815             pos = self.pos
5816             parsedComma = False
5817             parsedEnd = False
5818             try:
5819                 type = self._parse_type(named=False)
5820                 self.skip_ws()
5821                 if self.skip_string_and_ws('...'):
5822                     packExpansion = True
5823                     parsedEnd = True
5824                     if not self.skip_string('>'):
5825                         self.fail('Expected ">" after "..." in template argument list.')
5826                 elif self.skip_string('>'):
5827                     parsedEnd = True
5828                 elif self.skip_string(','):
5829                     parsedComma = True
5830                 else:
5831                     self.fail('Expected "...>", ">" or "," in template argument list.')
5832                 templateArgs.append(type)
5833             except DefinitionError as e:
5834                 prevErrors.append((e, "If type argument"))
5835                 self.pos = pos
5836                 try:
5837                     value = self._parse_constant_expression(inTemplate=True)
5838                     self.skip_ws()
5839                     if self.skip_string_and_ws('...'):
5840                         packExpansion = True
5841                         parsedEnd = True
5842                         if not self.skip_string('>'):
5843                             self.fail('Expected ">" after "..." in template argument list.')
5844                     elif self.skip_string('>'):
5845                         parsedEnd = True
5846                     elif self.skip_string(','):
5847                         parsedComma = True
5848                     else:
5849                         self.fail('Expected "...>", ">" or "," in template argument list.')
5850                     templateArgs.append(ASTTemplateArgConstant(value))
5851                 except DefinitionError as e:
5852                     self.pos = pos
5853                     prevErrors.append((e, "If non-type argument"))
5854                     header = "Error in parsing template argument list."
5855                     raise self._make_multi_error(prevErrors, header) from e
5856             if parsedEnd:
5857                 assert not parsedComma
5858                 break
5859             else:
5860                 assert not packExpansion
5861         return ASTTemplateArgs(templateArgs, packExpansion)
5862 
5863     def _parse_nested_name(self, memberPointer: bool = False) -> ASTNestedName:
5864         names: List[ASTNestedNameElement] = []
5865         templates: List[bool] = []
5866 
5867         self.skip_ws()
5868         rooted = False
5869         if self.skip_string('::'):
5870             rooted = True
5871         while 1:
5872             self.skip_ws()
5873             if len(names) > 0:
5874                 template = self.skip_word_and_ws('template')
5875             else:
5876                 template = False
5877             templates.append(template)
5878             identOrOp: Union[ASTIdentifier, ASTOperator] = None
5879             if self.skip_word_and_ws('operator'):
5880                 identOrOp = self._parse_operator()
5881             else:
5882                 if not self.match(identifier_re):
5883                     if memberPointer and len(names) > 0:
5884                         templates.pop()
5885                         break
5886                     self.fail("Expected identifier in nested name.")
5887                 identifier = self.matched_text
5888                 # make sure there isn't a keyword
5889                 if identifier in _keywords:
5890                     self.fail("Expected identifier in nested name, "
5891                               "got keyword: %s" % identifier)
5892                 identOrOp = ASTIdentifier(identifier)
5893             # try greedily to get template arguments,
5894             # but otherwise a < might be because we are in an expression
5895             pos = self.pos
5896             try:
5897                 templateArgs = self._parse_template_argument_list()
5898             except DefinitionError as ex:
5899                 self.pos = pos
5900                 templateArgs = None
5901                 self.otherErrors.append(ex)
5902             names.append(ASTNestedNameElement(identOrOp, templateArgs))
5903 
5904             self.skip_ws()
5905             if not self.skip_string('::'):
5906                 if memberPointer:
5907                     self.fail("Expected '::' in pointer to member (function).")
5908                 break
5909         return ASTNestedName(names, templates, rooted)
5910 
5911     # ==========================================================================
5912 
5913     def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental:
5914         modifier: Optional[str] = None
5915         signedness: Optional[str] = None
5916         width: List[str] = []
5917         typ: Optional[str] = None
5918         names: List[str] = []  # the parsed sequence
5919 
5920         self.skip_ws()
5921         while self.match(_simple_type_specifiers_re):
5922             t = self.matched_text
5923             names.append(t)
5924             if t in ('auto', 'void', 'bool',
5925                      'char', 'wchar_t', 'char8_t', 'char16_t', 'char32_t',
5926                      'int', '__int64', '__int128',
5927                      'float', 'double',
5928                      '__float80', '_Float64x', '__float128', '_Float128'):
5929                 if typ is not None:
5930                     self.fail("Can not have both {} and {}.".format(t, typ))
5931                 typ = t
5932             elif t in ('signed', 'unsigned'):
5933                 if signedness is not None:
5934                     self.fail("Can not have both {} and {}.".format(t, signedness))
5935                 signedness = t
5936             elif t == 'short':
5937                 if len(width) != 0:
5938                     self.fail("Can not have both {} and {}.".format(t, width[0]))
5939                 width.append(t)
5940             elif t == 'long':
5941                 if len(width) != 0 and width[0] != 'long':
5942                     self.fail("Can not have both {} and {}.".format(t, width[0]))
5943                 width.append(t)
5944             elif t in ('_Imaginary', '_Complex'):
5945                 if modifier is not None:
5946                     self.fail("Can not have both {} and {}.".format(t, modifier))
5947                 modifier = t
5948             self.skip_ws()
5949         if len(names) == 0:
5950             return None
5951 
5952         if typ in ('auto', 'void', 'bool',
5953                    'wchar_t', 'char8_t', 'char16_t', 'char32_t',
5954                    '__float80', '_Float64x', '__float128', '_Float128'):
5955             if modifier is not None:
5956                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5957             if signedness is not None:
5958                 self.fail("Can not have both {} and {}.".format(typ, signedness))
5959             if len(width) != 0:
5960                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5961         elif typ == 'char':
5962             if modifier is not None:
5963                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5964             if len(width) != 0:
5965                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5966         elif typ == 'int':
5967             if modifier is not None:
5968                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5969         elif typ in ('__int64', '__int128'):
5970             if modifier is not None:
5971                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5972             if len(width) != 0:
5973                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5974         elif typ == 'float':
5975             if signedness is not None:
5976                 self.fail("Can not have both {} and {}.".format(typ, signedness))
5977             if len(width) != 0:
5978                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5979         elif typ == 'double':
5980             if signedness is not None:
5981                 self.fail("Can not have both {} and {}.".format(typ, signedness))
5982             if len(width) > 1:
5983                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5984             if len(width) == 1 and width[0] != 'long':
5985                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5986         elif typ is None:
5987             if modifier is not None:
5988                 self.fail("Can not have {} without a floating point type.".format(modifier))
5989         else:
5990             assert False, "Unhandled type {}".format(typ)
5991 
5992         canonNames: List[str] = []
5993         if modifier is not None:
5994             canonNames.append(modifier)
5995         if signedness is not None:
5996             canonNames.append(signedness)
5997         canonNames.extend(width)
5998         if typ is not None:
5999             canonNames.append(typ)
6000         return ASTTrailingTypeSpecFundamental(names, canonNames)
6001 
6002     def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:
6003         # fundamental types, https://en.cppreference.com/w/cpp/language/type
6004         # and extensions
6005         self.skip_ws()
6006         res = self._parse_simple_type_specifiers()
6007         if res is not None:
6008             return res
6009 
6010         # decltype
6011         self.skip_ws()
6012         if self.skip_word_and_ws('decltype'):
6013             if not self.skip_string_and_ws('('):
6014                 self.fail("Expected '(' after 'decltype'.")
6015             if self.skip_word_and_ws('auto'):
6016                 if not self.skip_string(')'):
6017                     self.fail("Expected ')' after 'decltype(auto'.")
6018                 return ASTTrailingTypeSpecDecltypeAuto()
6019             expr = self._parse_expression()
6020             self.skip_ws()
6021             if not self.skip_string(')'):
6022                 self.fail("Expected ')' after 'decltype(<expr>'.")
6023             return ASTTrailingTypeSpecDecltype(expr)
6024 
6025         # prefixed
6026         prefix = None
6027         self.skip_ws()
6028         for k in ('class', 'struct', 'enum', 'union', 'typename'):
6029             if self.skip_word_and_ws(k):
6030                 prefix = k
6031                 break
6032         nestedName = self._parse_nested_name()
6033         self.skip_ws()
6034         placeholderType = None
6035         if self.skip_word('auto'):
6036             placeholderType = 'auto'
6037         elif self.skip_word_and_ws('decltype'):
6038             if not self.skip_string_and_ws('('):
6039                 self.fail("Expected '(' after 'decltype' in placeholder type specifier.")
6040             if not self.skip_word_and_ws('auto'):
6041                 self.fail("Expected 'auto' after 'decltype(' in placeholder type specifier.")
6042             if not self.skip_string_and_ws(')'):
6043                 self.fail("Expected ')' after 'decltype(auto' in placeholder type specifier.")
6044             placeholderType = 'decltype(auto)'
6045         return ASTTrailingTypeSpecName(prefix, nestedName, placeholderType)
6046 
6047     def _parse_parameters_and_qualifiers(self, paramMode: str) -> ASTParametersQualifiers:
6048         if paramMode == 'new':
6049             return None
6050         self.skip_ws()
6051         if not self.skip_string('('):
6052             if paramMode == 'function':
6053                 self.fail('Expecting "(" in parameters-and-qualifiers.')
6054             else:
6055                 return None
6056         args = []
6057         self.skip_ws()
6058         if not self.skip_string(')'):
6059             while 1:
6060                 self.skip_ws()
6061                 if self.skip_string('...'):
6062                     args.append(ASTFunctionParameter(None, True))
6063                     self.skip_ws()
6064                     if not self.skip_string(')'):
6065                         self.fail('Expected ")" after "..." in '
6066                                   'parameters-and-qualifiers.')
6067                     break
6068                 # note: it seems that function arguments can always be named,
6069                 # even in function pointers and similar.
6070                 arg = self._parse_type_with_init(outer=None, named='single')
6071                 # TODO: parse default parameters # TODO: didn't we just do that?
6072                 args.append(ASTFunctionParameter(arg))
6073 
6074                 self.skip_ws()
6075                 if self.skip_string(','):
6076                     continue
6077                 elif self.skip_string(')'):
6078                     break
6079                 else:
6080                     self.fail(
6081                         'Expecting "," or ")" in parameters-and-qualifiers, '
6082                         'got "%s".' % self.current_char)
6083 
6084         self.skip_ws()
6085         const = self.skip_word_and_ws('const')
6086         volatile = self.skip_word_and_ws('volatile')
6087         if not const:  # the can be permuted
6088             const = self.skip_word_and_ws('const')
6089 
6090         refQual = None
6091         if self.skip_string('&&'):
6092             refQual = '&&'
6093         if not refQual and self.skip_string('&'):
6094             refQual = '&'
6095 
6096         exceptionSpec = None
6097         self.skip_ws()
6098         if self.skip_string('noexcept'):
6099             if self.skip_string_and_ws('('):
6100                 expr = self._parse_constant_expression(False)
6101                 self.skip_ws()
6102                 if not self.skip_string(')'):
6103                     self.fail("Expecting ')' to end 'noexcept'.")
6104                 exceptionSpec = ASTNoexceptSpec(expr)
6105             else:
6106                 exceptionSpec = ASTNoexceptSpec(None)
6107 
6108         self.skip_ws()
6109         if self.skip_string('->'):
6110             trailingReturn = self._parse_type(named=False)
6111         else:
6112             trailingReturn = None
6113 
6114         self.skip_ws()
6115         override = self.skip_word_and_ws('override')
6116         final = self.skip_word_and_ws('final')
6117         if not override:
6118             override = self.skip_word_and_ws(
6119                 'override')  # they can be permuted
6120 
6121         attrs = []
6122         while True:
6123             attr = self._parse_attribute()
6124             if attr is None:
6125                 break
6126             attrs.append(attr)
6127 
6128         self.skip_ws()
6129         initializer = None
6130         # if this is a function pointer we should not swallow an initializer
6131         if paramMode == 'function' and self.skip_string('='):
6132             self.skip_ws()
6133             valid = ('0', 'delete', 'default')
6134             for w in valid:
6135                 if self.skip_word_and_ws(w):
6136                     initializer = w
6137                     break
6138             if not initializer:
6139                 self.fail(
6140                     'Expected "%s" in initializer-specifier.'
6141                     % '" or "'.join(valid))
6142 
6143         return ASTParametersQualifiers(
6144             args, volatile, const, refQual, exceptionSpec, trailingReturn,
6145             override, final, attrs, initializer)
6146 
6147     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:
6148         """Just parse the simple ones."""
6149         storage = None
6150         threadLocal = None
6151         inline = None
6152         virtual = None
6153         explicitSpec = None
6154         consteval = None
6155         constexpr = None
6156         constinit = None
6157         volatile = None
6158         const = None
6159         friend = None
6160         attrs = []
6161         while 1:  # accept any permutation of a subset of some decl-specs
6162             self.skip_ws()
6163             if not const and typed:
6164                 const = self.skip_word('const')
6165                 if const:
6166                     continue
6167             if not volatile and typed:
6168                 volatile = self.skip_word('volatile')
6169                 if volatile:
6170                     continue
6171             if not storage:
6172                 if outer in ('member', 'function'):
6173                     if self.skip_word('static'):
6174                         storage = 'static'
6175                         continue
6176                     if self.skip_word('extern'):
6177                         storage = 'extern'
6178                         continue
6179                 if outer == 'member':
6180                     if self.skip_word('mutable'):
6181                         storage = 'mutable'
6182                         continue
6183                 if self.skip_word('register'):
6184                     storage = 'register'
6185                     continue
6186             if not inline and outer in ('function', 'member'):
6187                 inline = self.skip_word('inline')
6188                 if inline:
6189                     continue
6190             if not constexpr and outer in ('member', 'function'):
6191                 constexpr = self.skip_word("constexpr")
6192                 if constexpr:
6193                     continue
6194 
6195             if outer == 'member':
6196                 if not constinit:
6197                     constinit = self.skip_word('constinit')
6198                     if constinit:
6199                         continue
6200                 if not threadLocal:
6201                     threadLocal = self.skip_word('thread_local')
6202                     if threadLocal:
6203                         continue
6204             if outer == 'function':
6205                 if not consteval:
6206                     consteval = self.skip_word('consteval')
6207                     if consteval:
6208                         continue
6209                 if not friend:
6210                     friend = self.skip_word('friend')
6211                     if friend:
6212                         continue
6213                 if not virtual:
6214                     virtual = self.skip_word('virtual')
6215                     if virtual:
6216                         continue
6217                 if not explicitSpec:
6218                     explicit = self.skip_word_and_ws('explicit')
6219                     if explicit:
6220                         expr: ASTExpression = None
6221                         if self.skip_string('('):
6222                             expr = self._parse_constant_expression(inTemplate=False)
6223                             if not expr:
6224                                 self.fail("Expected constant expression after '('" +
6225                                           " in explicit specifier.")
6226                             self.skip_ws()
6227                             if not self.skip_string(')'):
6228                                 self.fail("Expected ')' to end explicit specifier.")
6229                         explicitSpec = ASTExplicitSpec(expr)
6230                         continue
6231             attr = self._parse_attribute()
6232             if attr:
6233                 attrs.append(attr)
6234                 continue
6235             break
6236         return ASTDeclSpecsSimple(storage, threadLocal, inline, virtual,
6237                                   explicitSpec, consteval, constexpr, constinit,
6238                                   volatile, const, friend, attrs)
6239 
6240     def _parse_decl_specs(self, outer: str, typed: bool = True) -> ASTDeclSpecs:
6241         if outer:
6242             if outer not in ('type', 'member', 'function', 'templateParam'):
6243                 raise Exception('Internal error, unknown outer "%s".' % outer)
6244         """
6245         storage-class-specifier function-specifier "constexpr"
6246         "volatile" "const" trailing-type-specifier
6247 
6248         storage-class-specifier ->
6249               "static" (only for member_object and function_object)
6250             | "register"
6251 
6252         function-specifier -> "inline" | "virtual" | "explicit" (only for
6253         function_object)
6254 
6255         "constexpr" (only for member_object and function_object)
6256         """
6257         leftSpecs = self._parse_decl_specs_simple(outer, typed)
6258         rightSpecs = None
6259 
6260         if typed:
6261             trailing = self._parse_trailing_type_spec()
6262             rightSpecs = self._parse_decl_specs_simple(outer, typed)
6263         else:
6264             trailing = None
6265         return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)
6266 
6267     def _parse_declarator_name_suffix(
6268         self, named: Union[bool, str], paramMode: str, typed: bool
6269     ) -> Union[ASTDeclaratorNameParamQual, ASTDeclaratorNameBitField]:
6270         # now we should parse the name, and then suffixes
6271         if named == 'maybe':
6272             pos = self.pos
6273             try:
6274                 declId = self._parse_nested_name()
6275             except DefinitionError:
6276                 self.pos = pos
6277                 declId = None
6278         elif named == 'single':
6279             if self.match(identifier_re):
6280                 identifier = ASTIdentifier(self.matched_text)
6281                 nne = ASTNestedNameElement(identifier, None)
6282                 declId = ASTNestedName([nne], [False], rooted=False)
6283                 # if it's a member pointer, we may have '::', which should be an error
6284                 self.skip_ws()
6285                 if self.current_char == ':':
6286                     self.fail("Unexpected ':' after identifier.")
6287             else:
6288                 declId = None
6289         elif named:
6290             declId = self._parse_nested_name()
6291         else:
6292             declId = None
6293         arrayOps = []
6294         while 1:
6295             self.skip_ws()
6296             if typed and self.skip_string('['):
6297                 self.skip_ws()
6298                 if self.skip_string(']'):
6299                     arrayOps.append(ASTArray(None))
6300                     continue
6301 
6302                 def parser() -> ASTExpression:
6303                     return self._parse_expression()
6304                 value = self._parse_expression_fallback([']'], parser)
6305                 if not self.skip_string(']'):
6306                     self.fail("Expected ']' in end of array operator.")
6307                 arrayOps.append(ASTArray(value))
6308                 continue
6309             else:
6310                 break
6311         paramQual = self._parse_parameters_and_qualifiers(paramMode)
6312         if paramQual is None and len(arrayOps) == 0:
6313             # perhaps a bit-field
6314             if named and paramMode == 'type' and typed:
6315                 self.skip_ws()
6316                 if self.skip_string(':'):
6317                     size = self._parse_constant_expression(inTemplate=False)
6318                     return ASTDeclaratorNameBitField(declId=declId, size=size)
6319         return ASTDeclaratorNameParamQual(declId=declId, arrayOps=arrayOps,
6320                                           paramQual=paramQual)
6321 
6322     def _parse_declarator(self, named: Union[bool, str], paramMode: str,
6323                           typed: bool = True
6324                           ) -> ASTDeclarator:
6325         # 'typed' here means 'parse return type stuff'
6326         if paramMode not in ('type', 'function', 'operatorCast', 'new'):
6327             raise Exception(
6328                 "Internal error, unknown paramMode '%s'." % paramMode)
6329         prevErrors = []
6330         self.skip_ws()
6331         if typed and self.skip_string('*'):
6332             self.skip_ws()
6333             volatile = False
6334             const = False
6335             attrs = []
6336             while 1:
6337                 if not volatile:
6338                     volatile = self.skip_word_and_ws('volatile')
6339                     if volatile:
6340                         continue
6341                 if not const:
6342                     const = self.skip_word_and_ws('const')
6343                     if const:
6344                         continue
6345                 attr = self._parse_attribute()
6346                 if attr is not None:
6347                     attrs.append(attr)
6348                     continue
6349                 break
6350             next = self._parse_declarator(named, paramMode, typed)
6351             return ASTDeclaratorPtr(next=next, volatile=volatile, const=const, attrs=attrs)
6352         # TODO: shouldn't we parse an R-value ref here first?
6353         if typed and self.skip_string("&"):
6354             attrs = []
6355             while 1:
6356                 attr = self._parse_attribute()
6357                 if attr is None:
6358                     break
6359                 attrs.append(attr)
6360             next = self._parse_declarator(named, paramMode, typed)
6361             return ASTDeclaratorRef(next=next, attrs=attrs)
6362         if typed and self.skip_string("..."):
6363             next = self._parse_declarator(named, paramMode, False)
6364             return ASTDeclaratorParamPack(next=next)
6365         if typed and self.current_char == '(':  # note: peeking, not skipping
6366             if paramMode == "operatorCast":
6367                 # TODO: we should be able to parse cast operators which return
6368                 # function pointers. For now, just hax it and ignore.
6369                 return ASTDeclaratorNameParamQual(declId=None, arrayOps=[],
6370                                                   paramQual=None)
6371             # maybe this is the beginning of params and quals,try that first,
6372             # otherwise assume it's noptr->declarator > ( ptr-declarator )
6373             pos = self.pos
6374             try:
6375                 # assume this is params and quals
6376                 res = self._parse_declarator_name_suffix(named, paramMode,
6377                                                          typed)
6378                 return res
6379             except DefinitionError as exParamQual:
6380                 prevErrors.append((exParamQual,
6381                                    "If declarator-id with parameters-and-qualifiers"))
6382                 self.pos = pos
6383                 try:
6384                     assert self.current_char == '('
6385                     self.skip_string('(')
6386                     # TODO: hmm, if there is a name, it must be in inner, right?
6387                     # TODO: hmm, if there must be parameters, they must be
6388                     #       inside, right?
6389                     inner = self._parse_declarator(named, paramMode, typed)
6390                     if not self.skip_string(')'):
6391                         self.fail("Expected ')' in \"( ptr-declarator )\"")
6392                     next = self._parse_declarator(named=False,
6393                                                   paramMode="type",
6394                                                   typed=typed)
6395                     return ASTDeclaratorParen(inner=inner, next=next)
6396                 except DefinitionError as exNoPtrParen:
6397                     self.pos = pos
6398                     prevErrors.append((exNoPtrParen, "If parenthesis in noptr-declarator"))
6399                     header = "Error in declarator"
6400                     raise self._make_multi_error(prevErrors, header) from exNoPtrParen
6401         if typed:  # pointer to member
6402             pos = self.pos
6403             try:
6404                 name = self._parse_nested_name(memberPointer=True)
6405                 self.skip_ws()
6406                 if not self.skip_string('*'):
6407                     self.fail("Expected '*' in pointer to member declarator.")
6408                 self.skip_ws()
6409             except DefinitionError as e:
6410                 self.pos = pos
6411                 prevErrors.append((e, "If pointer to member declarator"))
6412             else:
6413                 volatile = False
6414                 const = False
6415                 while 1:
6416                     if not volatile:
6417                         volatile = self.skip_word_and_ws('volatile')
6418                         if volatile:
6419                             continue
6420                     if not const:
6421                         const = self.skip_word_and_ws('const')
6422                         if const:
6423                             continue
6424                     break
6425                 next = self._parse_declarator(named, paramMode, typed)
6426                 return ASTDeclaratorMemPtr(name, const, volatile, next=next)
6427         pos = self.pos
6428         try:
6429             res = self._parse_declarator_name_suffix(named, paramMode, typed)
6430             # this is a heuristic for error messages, for when there is a < after a
6431             # nested name, but it was not a successful template argument list
6432             if self.current_char == '<':
6433                 self.otherErrors.append(self._make_multi_error(prevErrors, ""))
6434             return res
6435         except DefinitionError as e:
6436             self.pos = pos
6437             prevErrors.append((e, "If declarator-id"))
6438             header = "Error in declarator or parameters-and-qualifiers"
6439             raise self._make_multi_error(prevErrors, header) from e
6440 
6441     def _parse_initializer(self, outer: str = None, allowFallback: bool = True
6442                            ) -> ASTInitializer:
6443         # initializer                           # global vars
6444         # -> brace-or-equal-initializer
6445         #  | '(' expression-list ')'
6446         #
6447         # brace-or-equal-initializer            # member vars
6448         # -> '=' initializer-clause
6449         #  | braced-init-list
6450         #
6451         # initializer-clause  # function params, non-type template params (with '=' in front)
6452         # -> assignment-expression
6453         #  | braced-init-list
6454         #
6455         # we don't distinguish between global and member vars, so disallow paren:
6456         #
6457         # -> braced-init-list             # var only
6458         #  | '=' assignment-expression
6459         #  | '=' braced-init-list
6460         self.skip_ws()
6461         if outer == 'member':
6462             bracedInit = self._parse_braced_init_list()
6463             if bracedInit is not None:
6464                 return ASTInitializer(bracedInit, hasAssign=False)
6465 
6466         if not self.skip_string('='):
6467             return None
6468 
6469         bracedInit = self._parse_braced_init_list()
6470         if bracedInit is not None:
6471             return ASTInitializer(bracedInit)
6472 
6473         if outer == 'member':
6474             fallbackEnd: List[str] = []
6475         elif outer == 'templateParam':
6476             fallbackEnd = [',', '>']
6477         elif outer is None:  # function parameter
6478             fallbackEnd = [',', ')']
6479         else:
6480             self.fail("Internal error, initializer for outer '%s' not "
6481                       "implemented." % outer)
6482 
6483         inTemplate = outer == 'templateParam'
6484 
6485         def parser() -> ASTExpression:
6486             return self._parse_assignment_expression(inTemplate=inTemplate)
6487         value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)
6488         return ASTInitializer(value)
6489 
6490     def _parse_type(self, named: Union[bool, str], outer: str = None) -> ASTType:
6491         """
6492         named=False|'maybe'|True: 'maybe' is e.g., for function objects which
6493         doesn't need to name the arguments
6494 
6495         outer == operatorCast: annoying case, we should not take the params
6496         """
6497         if outer:  # always named
6498             if outer not in ('type', 'member', 'function',
6499                              'operatorCast', 'templateParam'):
6500                 raise Exception('Internal error, unknown outer "%s".' % outer)
6501             if outer != 'operatorCast':
6502                 assert named
6503         if outer in ('type', 'function'):
6504             # We allow type objects to just be a name.
6505             # Some functions don't have normal return types: constructors,
6506             # destructors, cast operators
6507             prevErrors = []
6508             startPos = self.pos
6509             # first try without the type
6510             try:
6511                 declSpecs = self._parse_decl_specs(outer=outer, typed=False)
6512                 decl = self._parse_declarator(named=True, paramMode=outer,
6513                                               typed=False)
6514                 self.assert_end(allowSemicolon=True)
6515             except DefinitionError as exUntyped:
6516                 if outer == 'type':
6517                     desc = "If just a name"
6518                 elif outer == 'function':
6519                     desc = "If the function has no return type"
6520                 else:
6521                     assert False
6522                 prevErrors.append((exUntyped, desc))
6523                 self.pos = startPos
6524                 try:
6525                     declSpecs = self._parse_decl_specs(outer=outer)
6526                     decl = self._parse_declarator(named=True, paramMode=outer)
6527                 except DefinitionError as exTyped:
6528                     self.pos = startPos
6529                     if outer == 'type':
6530                         desc = "If typedef-like declaration"
6531                     elif outer == 'function':
6532                         desc = "If the function has a return type"
6533                     else:
6534                         assert False
6535                     prevErrors.append((exTyped, desc))
6536                     # Retain the else branch for easier debugging.
6537                     # TODO: it would be nice to save the previous stacktrace
6538                     #       and output it here.
6539                     if True:
6540                         if outer == 'type':
6541                             header = "Type must be either just a name or a "
6542                             header += "typedef-like declaration."
6543                         elif outer == 'function':
6544                             header = "Error when parsing function declaration."
6545                         else:
6546                             assert False
6547                         raise self._make_multi_error(prevErrors, header) from exTyped
6548                     else:
6549                         # For testing purposes.
6550                         # do it again to get the proper traceback (how do you
6551                         # reliably save a traceback when an exception is
6552                         # constructed?)
6553                         self.pos = startPos
6554                         typed = True
6555                         declSpecs = self._parse_decl_specs(outer=outer, typed=typed)
6556                         decl = self._parse_declarator(named=True, paramMode=outer,
6557                                                       typed=typed)
6558         else:
6559             paramMode = 'type'
6560             if outer == 'member':
6561                 named = True
6562             elif outer == 'operatorCast':
6563                 paramMode = 'operatorCast'
6564                 outer = None
6565             elif outer == 'templateParam':
6566                 named = 'single'
6567             declSpecs = self._parse_decl_specs(outer=outer)
6568             decl = self._parse_declarator(named=named, paramMode=paramMode)
6569         return ASTType(declSpecs, decl)
6570 
6571     def _parse_type_with_init(
6572             self, named: Union[bool, str],
6573             outer: str) -> Union[ASTTypeWithInit, ASTTemplateParamConstrainedTypeWithInit]:
6574         if outer:
6575             assert outer in ('type', 'member', 'function', 'templateParam')
6576         type = self._parse_type(outer=outer, named=named)
6577         if outer != 'templateParam':
6578             init = self._parse_initializer(outer=outer)
6579             return ASTTypeWithInit(type, init)
6580         # it could also be a constrained type parameter, e.g., C T = int&
6581         pos = self.pos
6582         eExpr = None
6583         try:
6584             init = self._parse_initializer(outer=outer, allowFallback=False)
6585             # note: init may be None if there is no =
6586             if init is None:
6587                 return ASTTypeWithInit(type, None)
6588             # we parsed an expression, so we must have a , or a >,
6589             # otherwise the expression didn't get everything
6590             self.skip_ws()
6591             if self.current_char != ',' and self.current_char != '>':
6592                 # pretend it didn't happen
6593                 self.pos = pos
6594                 init = None
6595             else:
6596                 # we assume that it was indeed an expression
6597                 return ASTTypeWithInit(type, init)
6598         except DefinitionError as e:
6599             self.pos = pos
6600             eExpr = e
6601         if not self.skip_string("="):
6602             return ASTTypeWithInit(type, None)
6603         try:
6604             typeInit = self._parse_type(named=False, outer=None)
6605             return ASTTemplateParamConstrainedTypeWithInit(type, typeInit)
6606         except DefinitionError as eType:
6607             if eExpr is None:
6608                 raise eType
6609             errs = []
6610             errs.append((eExpr, "If default template argument is an expression"))
6611             errs.append((eType, "If default template argument is a type"))
6612             msg = "Error in non-type template parameter"
6613             msg += " or constrained template parameter."
6614             raise self._make_multi_error(errs, msg) from eType
6615 
6616     def _parse_type_using(self) -> ASTTypeUsing:
6617         name = self._parse_nested_name()
6618         self.skip_ws()
6619         if not self.skip_string('='):
6620             return ASTTypeUsing(name, None)
6621         type = self._parse_type(False, None)
6622         return ASTTypeUsing(name, type)
6623 
6624     def _parse_concept(self) -> ASTConcept:
6625         nestedName = self._parse_nested_name()
6626         self.skip_ws()
6627         initializer = self._parse_initializer('member')
6628         return ASTConcept(nestedName, initializer)
6629 
6630     def _parse_class(self) -> ASTClass:
6631         attrs = []
6632         while 1:
6633             attr = self._parse_attribute()
6634             if attr is None:
6635                 break
6636             attrs.append(attr)
6637         name = self._parse_nested_name()
6638         self.skip_ws()
6639         final = self.skip_word_and_ws('final')
6640         bases = []
6641         self.skip_ws()
6642         if self.skip_string(':'):
6643             while 1:
6644                 self.skip_ws()
6645                 visibility = None
6646                 virtual = False
6647                 pack = False
6648                 if self.skip_word_and_ws('virtual'):
6649                     virtual = True
6650                 if self.match(_visibility_re):
6651                     visibility = self.matched_text
6652                     self.skip_ws()
6653                 if not virtual and self.skip_word_and_ws('virtual'):
6654                     virtual = True
6655                 baseName = self._parse_nested_name()
6656                 self.skip_ws()
6657                 pack = self.skip_string('...')
6658                 bases.append(ASTBaseClass(baseName, visibility, virtual, pack))
6659                 self.skip_ws()
6660                 if self.skip_string(','):
6661                     continue
6662                 else:
6663                     break
6664         return ASTClass(name, final, bases, attrs)
6665 
6666     def _parse_union(self) -> ASTUnion:
6667         attrs = []
6668         while 1:
6669             attr = self._parse_attribute()
6670             if attr is None:
6671                 break
6672             attrs.append(attr)
6673         name = self._parse_nested_name()
6674         return ASTUnion(name, attrs)
6675 
6676     def _parse_enum(self) -> ASTEnum:
6677         scoped = None  # is set by CPPEnumObject
6678         attrs = []
6679         while 1:
6680             attr = self._parse_attribute()
6681             if attr is None:
6682                 break
6683             attrs.append(attr)
6684         self.skip_ws()
6685         name = self._parse_nested_name()
6686         self.skip_ws()
6687         underlyingType = None
6688         if self.skip_string(':'):
6689             underlyingType = self._parse_type(named=False)
6690         return ASTEnum(name, scoped, underlyingType, attrs)
6691 
6692     def _parse_enumerator(self) -> ASTEnumerator:
6693         name = self._parse_nested_name()
6694         self.skip_ws()
6695         init = None
6696         if self.skip_string('='):
6697             self.skip_ws()
6698 
6699             def parser() -> ASTExpression:
6700                 return self._parse_constant_expression(inTemplate=False)
6701             initVal = self._parse_expression_fallback([], parser)
6702             init = ASTInitializer(initVal)
6703         return ASTEnumerator(name, init)
6704 
6705     # ==========================================================================
6706 
6707     def _parse_template_parameter(self) -> ASTTemplateParam:
6708         self.skip_ws()
6709         if self.skip_word('template'):
6710             # declare a tenplate template parameter
6711             nestedParams = self._parse_template_parameter_list()
6712         else:
6713             nestedParams = None
6714 
6715         pos = self.pos
6716         try:
6717             # Unconstrained type parameter or template type parameter
6718             key = None
6719             self.skip_ws()
6720             if self.skip_word_and_ws('typename'):
6721                 key = 'typename'
6722             elif self.skip_word_and_ws('class'):
6723                 key = 'class'
6724             elif nestedParams:
6725                 self.fail("Expected 'typename' or 'class' after "
6726                           "template template parameter list.")
6727             else:
6728                 self.fail("Expected 'typename' or 'class' in the "
6729                           "beginning of template type parameter.")
6730             self.skip_ws()
6731             parameterPack = self.skip_string('...')
6732             self.skip_ws()
6733             if self.match(identifier_re):
6734                 identifier = ASTIdentifier(self.matched_text)
6735             else:
6736                 identifier = None
6737             self.skip_ws()
6738             if not parameterPack and self.skip_string('='):
6739                 default = self._parse_type(named=False, outer=None)
6740             else:
6741                 default = None
6742                 if self.current_char not in ',>':
6743                     self.fail('Expected "," or ">" after (template) type parameter.')
6744             data = ASTTemplateKeyParamPackIdDefault(key, identifier,
6745                                                     parameterPack, default)
6746             if nestedParams:
6747                 return ASTTemplateParamTemplateType(nestedParams, data)
6748             else:
6749                 return ASTTemplateParamType(data)
6750         except DefinitionError as eType:
6751             if nestedParams:
6752                 raise
6753             try:
6754                 # non-type parameter or constrained type parameter
6755                 self.pos = pos
6756                 param = self._parse_type_with_init('maybe', 'templateParam')
6757                 return ASTTemplateParamNonType(param)
6758             except DefinitionError as eNonType:
6759                 self.pos = pos
6760                 header = "Error when parsing template parameter."
6761                 errs = []
6762                 errs.append(
6763                     (eType, "If unconstrained type parameter or template type parameter"))
6764                 errs.append(
6765                     (eNonType, "If constrained type parameter or non-type parameter"))
6766                 raise self._make_multi_error(errs, header)
6767 
6768     def _parse_template_parameter_list(self) -> ASTTemplateParams:
6769         # only: '<' parameter-list '>'
6770         # we assume that 'template' has just been parsed
6771         templateParams: List[ASTTemplateParam] = []
6772         self.skip_ws()
6773         if not self.skip_string("<"):
6774             self.fail("Expected '<' after 'template'")
6775         while 1:
6776             pos = self.pos
6777             err = None
6778             try:
6779                 param = self._parse_template_parameter()
6780                 templateParams.append(param)
6781             except DefinitionError as eParam:
6782                 self.pos = pos
6783                 err = eParam
6784             self.skip_ws()
6785             if self.skip_string('>'):
6786                 return ASTTemplateParams(templateParams)
6787             elif self.skip_string(','):
6788                 continue
6789             else:
6790                 header = "Error in template parameter list."
6791                 errs = []
6792                 if err:
6793                     errs.append((err, "If parameter"))
6794                 try:
6795                     self.fail('Expected "," or ">".')
6796                 except DefinitionError as e:
6797                     errs.append((e, "If no parameter"))
6798                 print(errs)
6799                 raise self._make_multi_error(errs, header)
6800 
6801     def _parse_template_introduction(self) -> ASTTemplateIntroduction:
6802         pos = self.pos
6803         try:
6804             concept = self._parse_nested_name()
6805         except Exception:
6806             self.pos = pos
6807             return None
6808         self.skip_ws()
6809         if not self.skip_string('{'):
6810             self.pos = pos
6811             return None
6812 
6813         # for sure it must be a template introduction now
6814         params = []
6815         while 1:
6816             self.skip_ws()
6817             parameterPack = self.skip_string('...')
6818             self.skip_ws()
6819             if not self.match(identifier_re):
6820                 self.fail("Expected identifier in template introduction list.")
6821             txt_identifier = self.matched_text
6822             # make sure there isn't a keyword
6823             if txt_identifier in _keywords:
6824                 self.fail("Expected identifier in template introduction list, "
6825                           "got keyword: %s" % txt_identifier)
6826             identifier = ASTIdentifier(txt_identifier)
6827             params.append(ASTTemplateIntroductionParameter(identifier, parameterPack))
6828 
6829             self.skip_ws()
6830             if self.skip_string('}'):
6831                 break
6832             elif self.skip_string(','):
6833                 continue
6834             else:
6835                 self.fail("Error in template introduction list. "
6836                           'Expected ",", or "}".')
6837         return ASTTemplateIntroduction(concept, params)
6838 
6839     def _parse_requires_clause(self) -> Optional[ASTRequiresClause]:
6840         # requires-clause -> 'requires' constraint-logical-or-expression
6841         # constraint-logical-or-expression
6842         #   -> constraint-logical-and-expression
6843         #    | constraint-logical-or-expression '||' constraint-logical-and-expression
6844         # constraint-logical-and-expression
6845         #   -> primary-expression
6846         #    | constraint-logical-and-expression '&&' primary-expression
6847         self.skip_ws()
6848         if not self.skip_word('requires'):
6849             return None
6850 
6851         def parse_and_expr(self: DefinitionParser) -> ASTExpression:
6852             andExprs = []
6853             ops = []
6854             andExprs.append(self._parse_primary_expression())
6855             while True:
6856                 self.skip_ws()
6857                 oneMore = False
6858                 if self.skip_string('&&'):
6859                     oneMore = True
6860                     ops.append('&&')
6861                 elif self.skip_word('and'):
6862                     oneMore = True
6863                     ops.append('and')
6864                 if not oneMore:
6865                     break
6866                 andExprs.append(self._parse_primary_expression())
6867             if len(andExprs) == 1:
6868                 return andExprs[0]
6869             else:
6870                 return ASTBinOpExpr(andExprs, ops)
6871 
6872         orExprs = []
6873         ops = []
6874         orExprs.append(parse_and_expr(self))
6875         while True:
6876             self.skip_ws()
6877             oneMore = False
6878             if self.skip_string('||'):
6879                 oneMore = True
6880                 ops.append('||')
6881             elif self.skip_word('or'):
6882                 oneMore = True
6883                 ops.append('or')
6884             if not oneMore:
6885                 break
6886             orExprs.append(parse_and_expr(self))
6887         if len(orExprs) == 1:
6888             return ASTRequiresClause(orExprs[0])
6889         else:
6890             return ASTRequiresClause(ASTBinOpExpr(orExprs, ops))
6891 
6892     def _parse_template_declaration_prefix(self, objectType: str
6893                                            ) -> Optional[ASTTemplateDeclarationPrefix]:
6894         templates: List[Union[ASTTemplateParams, ASTTemplateIntroduction]] = []
6895         while 1:
6896             self.skip_ws()
6897             # the saved position is only used to provide a better error message
6898             params: Union[ASTTemplateParams, ASTTemplateIntroduction] = None
6899             pos = self.pos
6900             if self.skip_word("template"):
6901                 try:
6902                     params = self._parse_template_parameter_list()
6903                 except DefinitionError as e:
6904                     if objectType == 'member' and len(templates) == 0:
6905                         return ASTTemplateDeclarationPrefix(None)
6906                     else:
6907                         raise e
6908             else:
6909                 params = self._parse_template_introduction()
6910                 if not params:
6911                     break
6912             if objectType == 'concept' and len(templates) > 0:
6913                 self.pos = pos
6914                 self.fail("More than 1 template parameter list for concept.")
6915             templates.append(params)
6916         if len(templates) == 0 and objectType == 'concept':
6917             self.fail('Missing template parameter list for concept.')
6918         if len(templates) == 0:
6919             return None
6920         else:
6921             return ASTTemplateDeclarationPrefix(templates)
6922 
6923     def _check_template_consistency(self, nestedName: ASTNestedName,
6924                                     templatePrefix: ASTTemplateDeclarationPrefix,
6925                                     fullSpecShorthand: bool, isMember: bool = False
6926                                     ) -> ASTTemplateDeclarationPrefix:
6927         numArgs = nestedName.num_templates()
6928         isMemberInstantiation = False
6929         if not templatePrefix:
6930             numParams = 0
6931         else:
6932             if isMember and templatePrefix.templates is None:
6933                 numParams = 0
6934                 isMemberInstantiation = True
6935             else:
6936                 numParams = len(templatePrefix.templates)
6937         if numArgs + 1 < numParams:
6938             self.fail("Too few template argument lists comapred to parameter"
6939                       " lists. Argument lists: %d, Parameter lists: %d."
6940                       % (numArgs, numParams))
6941         if numArgs > numParams:
6942             numExtra = numArgs - numParams
6943             if not fullSpecShorthand and not isMemberInstantiation:
6944                 msg = "Too many template argument lists compared to parameter" \
6945                     " lists. Argument lists: %d, Parameter lists: %d," \
6946                     " Extra empty parameters lists prepended: %d." \
6947                     % (numArgs, numParams, numExtra)
6948                 msg += " Declaration:\n\t"
6949                 if templatePrefix:
6950                     msg += "%s\n\t" % templatePrefix
6951                 msg += str(nestedName)
6952                 self.warn(msg)
6953 
6954             newTemplates: List[Union[ASTTemplateParams, ASTTemplateIntroduction]] = []
6955             for _i in range(numExtra):
6956                 newTemplates.append(ASTTemplateParams([]))
6957             if templatePrefix and not isMemberInstantiation:
6958                 newTemplates.extend(templatePrefix.templates)
6959             templatePrefix = ASTTemplateDeclarationPrefix(newTemplates)
6960         return templatePrefix
6961 
6962     def parse_declaration(self, objectType: str, directiveType: str) -> ASTDeclaration:
6963         if objectType not in ('class', 'union', 'function', 'member', 'type',
6964                               'concept', 'enum', 'enumerator'):
6965             raise Exception('Internal error, unknown objectType "%s".' % objectType)
6966         if directiveType not in ('class', 'struct', 'union', 'function', 'member', 'var',
6967                                  'type', 'concept',
6968                                  'enum', 'enum-struct', 'enum-class', 'enumerator'):
6969             raise Exception('Internal error, unknown directiveType "%s".' % directiveType)
6970         visibility = None
6971         templatePrefix = None
6972         requiresClause = None
6973         trailingRequiresClause = None
6974         declaration: Any = None
6975 
6976         self.skip_ws()
6977         if self.match(_visibility_re):
6978             visibility = self.matched_text
6979 
6980         if objectType in ('type', 'concept', 'member', 'function', 'class'):
6981             templatePrefix = self._parse_template_declaration_prefix(objectType)
6982             if objectType == 'function' and templatePrefix is not None:
6983                 requiresClause = self._parse_requires_clause()
6984 
6985         if objectType == 'type':
6986             prevErrors = []
6987             pos = self.pos
6988             try:
6989                 if not templatePrefix:
6990                     declaration = self._parse_type(named=True, outer='type')
6991             except DefinitionError as e:
6992                 prevErrors.append((e, "If typedef-like declaration"))
6993                 self.pos = pos
6994             pos = self.pos
6995             try:
6996                 if not declaration:
6997                     declaration = self._parse_type_using()
6998             except DefinitionError as e:
6999                 self.pos = pos
7000                 prevErrors.append((e, "If type alias or template alias"))
7001                 header = "Error in type declaration."
7002                 raise self._make_multi_error(prevErrors, header) from e
7003         elif objectType == 'concept':
7004             declaration = self._parse_concept()
7005         elif objectType == 'member':
7006             declaration = self._parse_type_with_init(named=True, outer='member')
7007         elif objectType == 'function':
7008             declaration = self._parse_type(named=True, outer='function')
7009             if templatePrefix is not None:
7010                 trailingRequiresClause = self._parse_requires_clause()
7011         elif objectType == 'class':
7012             declaration = self._parse_class()
7013         elif objectType == 'union':
7014             declaration = self._parse_union()
7015         elif objectType == 'enum':
7016             declaration = self._parse_enum()
7017         elif objectType == 'enumerator':
7018             declaration = self._parse_enumerator()
7019         else:
7020             assert False
7021         templatePrefix = self._check_template_consistency(declaration.name,
7022                                                           templatePrefix,
7023                                                           fullSpecShorthand=False,
7024                                                           isMember=objectType == 'member')
7025         self.skip_ws()
7026         semicolon = self.skip_string(';')
7027         return ASTDeclaration(objectType, directiveType, visibility,
7028                               templatePrefix, requiresClause, declaration,
7029                               trailingRequiresClause, semicolon)
7030 
7031     def parse_namespace_object(self) -> ASTNamespace:
7032         templatePrefix = self._parse_template_declaration_prefix(objectType="namespace")
7033         name = self._parse_nested_name()
7034         templatePrefix = self._check_template_consistency(name, templatePrefix,
7035                                                           fullSpecShorthand=False)
7036         res = ASTNamespace(name, templatePrefix)
7037         res.objectType = 'namespace'  # type: ignore
7038         return res
7039 
7040     def parse_xref_object(self) -> Tuple[Union[ASTNamespace, ASTDeclaration], bool]:
7041         pos = self.pos
7042         try:
7043             templatePrefix = self._parse_template_declaration_prefix(objectType="xref")
7044             name = self._parse_nested_name()
7045             # if there are '()' left, just skip them
7046             self.skip_ws()
7047             self.skip_string('()')
7048             self.assert_end()
7049             templatePrefix = self._check_template_consistency(name, templatePrefix,
7050                                                               fullSpecShorthand=True)
7051             res1 = ASTNamespace(name, templatePrefix)
7052             res1.objectType = 'xref'  # type: ignore
7053             return res1, True
7054         except DefinitionError as e1:
7055             try:
7056                 self.pos = pos
7057                 res2 = self.parse_declaration('function', 'function')
7058                 # if there are '()' left, just skip them
7059                 self.skip_ws()
7060                 self.skip_string('()')
7061                 self.assert_end()
7062                 return res2, False
7063             except DefinitionError as e2:
7064                 errs = []
7065                 errs.append((e1, "If shorthand ref"))
7066                 errs.append((e2, "If full function ref"))
7067                 msg = "Error in cross-reference."
7068                 raise self._make_multi_error(errs, msg) from e2
7069 
7070     def parse_expression(self) -> Union[ASTExpression, ASTType]:
7071         pos = self.pos
7072         try:
7073             expr = self._parse_expression()
7074             self.skip_ws()
7075             self.assert_end()
7076             return expr
7077         except DefinitionError as exExpr:
7078             self.pos = pos
7079             try:
7080                 typ = self._parse_type(False)
7081                 self.skip_ws()
7082                 self.assert_end()
7083                 return typ
7084             except DefinitionError as exType:
7085                 header = "Error when parsing (type) expression."
7086                 errs = []
7087                 errs.append((exExpr, "If expression"))
7088                 errs.append((exType, "If type"))
7089                 raise self._make_multi_error(errs, header) from exType

</code><intended_behavior>Similar to the C domain, the DefinitionParser class and the setup function in the C++ domain (cpp.py) should be adjusted to correctly handle cpp_id_attributes during enum parsing. This involves ensuring attributes tagged on enum values do not cause parsing issues or misnomers in the generated documentation. The correct approach would filter or properly recognize these attributes so that they do not lead to errors or misnamed enum values in the documentation output.</intended_behavior>]
2025-10-17 18:16:39.922 | INFO     | Search completed. Bug locations: [<file>sphinx/domains/c.py</file>
<class>DefinitionParser</class>
<method>None</method>
<code>
2143 class DefinitionParser(BaseParser):
2144     @property
2145     def language(self) -> str:
2146         return 'C'
2147 
2148     @property
2149     def id_attributes(self):
2150         return self.config.c_id_attributes
2151 
2152     @property
2153     def paren_attributes(self):
2154         return self.config.c_paren_attributes
2155 
2156     def _parse_string(self) -> str:
2157         if self.current_char != '"':
2158             return None
2159         startPos = self.pos
2160         self.pos += 1
2161         escape = False
2162         while True:
2163             if self.eof:
2164                 self.fail("Unexpected end during inside string.")
2165             elif self.current_char == '"' and not escape:
2166                 self.pos += 1
2167                 break
2168             elif self.current_char == '\\':
2169                 escape = True
2170             else:
2171                 escape = False
2172             self.pos += 1
2173         return self.definition[startPos:self.pos]
2174 
2175     def _parse_literal(self) -> ASTLiteral:
2176         # -> integer-literal
2177         #  | character-literal
2178         #  | floating-literal
2179         #  | string-literal
2180         #  | boolean-literal -> "false" | "true"
2181         self.skip_ws()
2182         if self.skip_word('true'):
2183             return ASTBooleanLiteral(True)
2184         if self.skip_word('false'):
2185             return ASTBooleanLiteral(False)
2186         pos = self.pos
2187         if self.match(float_literal_re):
2188             self.match(float_literal_suffix_re)
2189             return ASTNumberLiteral(self.definition[pos:self.pos])
2190         for regex in [binary_literal_re, hex_literal_re,
2191                       integer_literal_re, octal_literal_re]:
2192             if self.match(regex):
2193                 self.match(integers_literal_suffix_re)
2194                 return ASTNumberLiteral(self.definition[pos:self.pos])
2195 
2196         string = self._parse_string()
2197         if string is not None:
2198             return ASTStringLiteral(string)
2199 
2200         # character-literal
2201         if self.match(char_literal_re):
2202             prefix = self.last_match.group(1)  # may be None when no prefix
2203             data = self.last_match.group(2)
2204             try:
2205                 return ASTCharLiteral(prefix, data)
2206             except UnicodeDecodeError as e:
2207                 self.fail("Can not handle character literal. Internal error was: %s" % e)
2208             except UnsupportedMultiCharacterCharLiteral:
2209                 self.fail("Can not handle character literal"
2210                           " resulting in multiple decoded characters.")
2211         return None
2212 
2213     def _parse_paren_expression(self) -> ASTExpression:
2214         # "(" expression ")"
2215         if self.current_char != '(':
2216             return None
2217         self.pos += 1
2218         res = self._parse_expression()
2219         self.skip_ws()
2220         if not self.skip_string(')'):
2221             self.fail("Expected ')' in end of parenthesized expression.")
2222         return ASTParenExpr(res)
2223 
2224     def _parse_primary_expression(self) -> ASTExpression:
2225         # literal
2226         # "(" expression ")"
2227         # id-expression -> we parse this with _parse_nested_name
2228         self.skip_ws()
2229         res: ASTExpression = self._parse_literal()
2230         if res is not None:
2231             return res
2232         res = self._parse_paren_expression()
2233         if res is not None:
2234             return res
2235         nn = self._parse_nested_name()
2236         if nn is not None:
2237             return ASTIdExpression(nn)
2238         return None
2239 
2240     def _parse_initializer_list(self, name: str, open: str, close: str
2241                                 ) -> Tuple[List[ASTExpression], bool]:
2242         # Parse open and close with the actual initializer-list in between
2243         # -> initializer-clause '...'[opt]
2244         #  | initializer-list ',' initializer-clause '...'[opt]
2245         # TODO: designators
2246         self.skip_ws()
2247         if not self.skip_string_and_ws(open):
2248             return None, None
2249         if self.skip_string(close):
2250             return [], False
2251 
2252         exprs = []
2253         trailingComma = False
2254         while True:
2255             self.skip_ws()
2256             expr = self._parse_expression()
2257             self.skip_ws()
2258             exprs.append(expr)
2259             self.skip_ws()
2260             if self.skip_string(close):
2261                 break
2262             if not self.skip_string_and_ws(','):
2263                 self.fail("Error in %s, expected ',' or '%s'." % (name, close))
2264             if self.current_char == close and close == '}':
2265                 self.pos += 1
2266                 trailingComma = True
2267                 break
2268         return exprs, trailingComma
2269 
2270     def _parse_paren_expression_list(self) -> ASTParenExprList:
2271         # -> '(' expression-list ')'
2272         # though, we relax it to also allow empty parens
2273         # as it's needed in some cases
2274         #
2275         # expression-list
2276         # -> initializer-list
2277         exprs, trailingComma = self._parse_initializer_list("parenthesized expression-list",
2278                                                             '(', ')')
2279         if exprs is None:
2280             return None
2281         return ASTParenExprList(exprs)
2282 
2283     def _parse_braced_init_list(self) -> ASTBracedInitList:
2284         # -> '{' initializer-list ','[opt] '}'
2285         #  | '{' '}'
2286         exprs, trailingComma = self._parse_initializer_list("braced-init-list", '{', '}')
2287         if exprs is None:
2288             return None
2289         return ASTBracedInitList(exprs, trailingComma)
2290 
2291     def _parse_postfix_expression(self) -> ASTPostfixExpr:
2292         # -> primary
2293         #  | postfix "[" expression "]"
2294         #  | postfix "[" braced-init-list [opt] "]"
2295         #  | postfix "(" expression-list [opt] ")"
2296         #  | postfix "." id-expression  // taken care of in primary by nested name
2297         #  | postfix "->" id-expression
2298         #  | postfix "++"
2299         #  | postfix "--"
2300 
2301         prefix = self._parse_primary_expression()
2302 
2303         # and now parse postfixes
2304         postFixes: List[ASTPostfixOp] = []
2305         while True:
2306             self.skip_ws()
2307             if self.skip_string_and_ws('['):
2308                 expr = self._parse_expression()
2309                 self.skip_ws()
2310                 if not self.skip_string(']'):
2311                     self.fail("Expected ']' in end of postfix expression.")
2312                 postFixes.append(ASTPostfixArray(expr))
2313                 continue
2314             if self.skip_string('->'):
2315                 if self.skip_string('*'):
2316                     # don't steal the arrow
2317                     self.pos -= 3
2318                 else:
2319                     name = self._parse_nested_name()
2320                     postFixes.append(ASTPostfixMemberOfPointer(name))
2321                     continue
2322             if self.skip_string('++'):
2323                 postFixes.append(ASTPostfixInc())
2324                 continue
2325             if self.skip_string('--'):
2326                 postFixes.append(ASTPostfixDec())
2327                 continue
2328             lst = self._parse_paren_expression_list()
2329             if lst is not None:
2330                 postFixes.append(ASTPostfixCallExpr(lst))
2331                 continue
2332             break
2333         return ASTPostfixExpr(prefix, postFixes)
2334 
2335     def _parse_unary_expression(self) -> ASTExpression:
2336         # -> postfix
2337         #  | "++" cast
2338         #  | "--" cast
2339         #  | unary-operator cast -> (* | & | + | - | ! | ~) cast
2340         # The rest:
2341         #  | "sizeof" unary
2342         #  | "sizeof" "(" type-id ")"
2343         #  | "alignof" "(" type-id ")"
2344         self.skip_ws()
2345         for op in _expression_unary_ops:
2346             # TODO: hmm, should we be able to backtrack here?
2347             if op[0] in 'cn':
2348                 res = self.skip_word(op)
2349             else:
2350                 res = self.skip_string(op)
2351             if res:
2352                 expr = self._parse_cast_expression()
2353                 return ASTUnaryOpExpr(op, expr)
2354         if self.skip_word_and_ws('sizeof'):
2355             if self.skip_string_and_ws('('):
2356                 typ = self._parse_type(named=False)
2357                 self.skip_ws()
2358                 if not self.skip_string(')'):
2359                     self.fail("Expecting ')' to end 'sizeof'.")
2360                 return ASTSizeofType(typ)
2361             expr = self._parse_unary_expression()
2362             return ASTSizeofExpr(expr)
2363         if self.skip_word_and_ws('alignof'):
2364             if not self.skip_string_and_ws('('):
2365                 self.fail("Expecting '(' after 'alignof'.")
2366             typ = self._parse_type(named=False)
2367             self.skip_ws()
2368             if not self.skip_string(')'):
2369                 self.fail("Expecting ')' to end 'alignof'.")
2370             return ASTAlignofExpr(typ)
2371         return self._parse_postfix_expression()
2372 
2373     def _parse_cast_expression(self) -> ASTExpression:
2374         # -> unary  | "(" type-id ")" cast
2375         pos = self.pos
2376         self.skip_ws()
2377         if self.skip_string('('):
2378             try:
2379                 typ = self._parse_type(False)
2380                 if not self.skip_string(')'):
2381                     self.fail("Expected ')' in cast expression.")
2382                 expr = self._parse_cast_expression()
2383                 return ASTCastExpr(typ, expr)
2384             except DefinitionError as exCast:
2385                 self.pos = pos
2386                 try:
2387                     return self._parse_unary_expression()
2388                 except DefinitionError as exUnary:
2389                     errs = []
2390                     errs.append((exCast, "If type cast expression"))
2391                     errs.append((exUnary, "If unary expression"))
2392                     raise self._make_multi_error(errs,
2393                                                  "Error in cast expression.") from exUnary
2394         else:
2395             return self._parse_unary_expression()
2396 
2397     def _parse_logical_or_expression(self) -> ASTExpression:
2398         # logical-or     = logical-and      ||
2399         # logical-and    = inclusive-or     &&
2400         # inclusive-or   = exclusive-or     |
2401         # exclusive-or   = and              ^
2402         # and            = equality         &
2403         # equality       = relational       ==, !=
2404         # relational     = shift            <, >, <=, >=
2405         # shift          = additive         <<, >>
2406         # additive       = multiplicative   +, -
2407         # multiplicative = pm               *, /, %
2408         # pm             = cast             .*, ->*
2409         def _parse_bin_op_expr(self, opId):
2410             if opId + 1 == len(_expression_bin_ops):
2411                 def parser() -> ASTExpression:
2412                     return self._parse_cast_expression()
2413             else:
2414                 def parser() -> ASTExpression:
2415                     return _parse_bin_op_expr(self, opId + 1)
2416             exprs = []
2417             ops = []
2418             exprs.append(parser())
2419             while True:
2420                 self.skip_ws()
2421                 pos = self.pos
2422                 oneMore = False
2423                 for op in _expression_bin_ops[opId]:
2424                     if op[0] in 'abcnox':
2425                         if not self.skip_word(op):
2426                             continue
2427                     else:
2428                         if not self.skip_string(op):
2429                             continue
2430                     if op == '&' and self.current_char == '&':
2431                         # don't split the && 'token'
2432                         self.pos -= 1
2433                         # and btw. && has lower precedence, so we are done
2434                         break
2435                     try:
2436                         expr = parser()
2437                         exprs.append(expr)
2438                         ops.append(op)
2439                         oneMore = True
2440                         break
2441                     except DefinitionError:
2442                         self.pos = pos
2443                 if not oneMore:
2444                     break
2445             return ASTBinOpExpr(exprs, ops)
2446         return _parse_bin_op_expr(self, 0)
2447 
2448     def _parse_conditional_expression_tail(self, orExprHead: Any) -> ASTExpression:
2449         # -> "?" expression ":" assignment-expression
2450         return None
2451 
2452     def _parse_assignment_expression(self) -> ASTExpression:
2453         # -> conditional-expression
2454         #  | logical-or-expression assignment-operator initializer-clause
2455         # -> conditional-expression ->
2456         #     logical-or-expression
2457         #   | logical-or-expression "?" expression ":" assignment-expression
2458         #   | logical-or-expression assignment-operator initializer-clause
2459         exprs = []
2460         ops = []
2461         orExpr = self._parse_logical_or_expression()
2462         exprs.append(orExpr)
2463         # TODO: handle ternary with _parse_conditional_expression_tail
2464         while True:
2465             oneMore = False
2466             self.skip_ws()
2467             for op in _expression_assignment_ops:
2468                 if op[0] in 'abcnox':
2469                     if not self.skip_word(op):
2470                         continue
2471                 else:
2472                     if not self.skip_string(op):
2473                         continue
2474                 expr = self._parse_logical_or_expression()
2475                 exprs.append(expr)
2476                 ops.append(op)
2477                 oneMore = True
2478             if not oneMore:
2479                 break
2480         return ASTAssignmentExpr(exprs, ops)
2481 
2482     def _parse_constant_expression(self) -> ASTExpression:
2483         # -> conditional-expression
2484         orExpr = self._parse_logical_or_expression()
2485         # TODO: use _parse_conditional_expression_tail
2486         return orExpr
2487 
2488     def _parse_expression(self) -> ASTExpression:
2489         # -> assignment-expression
2490         #  | expression "," assignment-expression
2491         # TODO: actually parse the second production
2492         return self._parse_assignment_expression()
2493 
2494     def _parse_expression_fallback(
2495             self, end: List[str],
2496             parser: Callable[[], ASTExpression],
2497             allow: bool = True) -> ASTExpression:
2498         # Stupidly "parse" an expression.
2499         # 'end' should be a list of characters which ends the expression.
2500 
2501         # first try to use the provided parser
2502         prevPos = self.pos
2503         try:
2504             return parser()
2505         except DefinitionError as e:
2506             # some places (e.g., template parameters) we really don't want to use fallback,
2507             # and for testing we may want to globally disable it
2508             if not allow or not self.allowFallbackExpressionParsing:
2509                 raise
2510             self.warn("Parsing of expression failed. Using fallback parser."
2511                       " Error was:\n%s" % e)
2512             self.pos = prevPos
2513         # and then the fallback scanning
2514         assert end is not None
2515         self.skip_ws()
2516         startPos = self.pos
2517         if self.match(_string_re):
2518             value = self.matched_text
2519         else:
2520             # TODO: add handling of more bracket-like things, and quote handling
2521             brackets = {'(': ')', '{': '}', '[': ']'}
2522             symbols: List[str] = []
2523             while not self.eof:
2524                 if (len(symbols) == 0 and self.current_char in end):
2525                     break
2526                 if self.current_char in brackets.keys():
2527                     symbols.append(brackets[self.current_char])
2528                 elif len(symbols) > 0 and self.current_char == symbols[-1]:
2529                     symbols.pop()
2530                 self.pos += 1
2531             if len(end) > 0 and self.eof:
2532                 self.fail("Could not find end of expression starting at %d."
2533                           % startPos)
2534             value = self.definition[startPos:self.pos].strip()
2535         return ASTFallbackExpr(value.strip())
2536 
2537     def _parse_nested_name(self) -> ASTNestedName:
2538         names: List[Any] = []
2539 
2540         self.skip_ws()
2541         rooted = False
2542         if self.skip_string('.'):
2543             rooted = True
2544         while 1:
2545             self.skip_ws()
2546             if not self.match(identifier_re):
2547                 self.fail("Expected identifier in nested name.")
2548             identifier = self.matched_text
2549             # make sure there isn't a keyword
2550             if identifier in _keywords:
2551                 self.fail("Expected identifier in nested name, "
2552                           "got keyword: %s" % identifier)
2553             if self.matched_text in self.config.c_extra_keywords:
2554                 msg = "Expected identifier, got user-defined keyword: %s." \
2555                       + " Remove it from c_extra_keywords to allow it as identifier.\n" \
2556                       + "Currently c_extra_keywords is %s."
2557                 self.fail(msg % (self.matched_text,
2558                                  str(self.config.c_extra_keywords)))
2559             ident = ASTIdentifier(identifier)
2560             names.append(ident)
2561 
2562             self.skip_ws()
2563             if not self.skip_string('.'):
2564                 break
2565         return ASTNestedName(names, rooted)
2566 
2567     def _parse_simple_type_specifier(self) -> Optional[str]:
2568         if self.match(_simple_type_specifiers_re):
2569             return self.matched_text
2570         for t in ('bool', 'complex', 'imaginary'):
2571             if t in self.config.c_extra_keywords:
2572                 if self.skip_word(t):
2573                     return t
2574         return None
2575 
2576     def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental:
2577         names: List[str] = []
2578 
2579         self.skip_ws()
2580         while True:
2581             t = self._parse_simple_type_specifier()
2582             if t is None:
2583                 break
2584             names.append(t)
2585             self.skip_ws()
2586         if len(names) == 0:
2587             return None
2588         return ASTTrailingTypeSpecFundamental(names)
2589 
2590     def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:
2591         # fundamental types, https://en.cppreference.com/w/c/language/type
2592         # and extensions
2593         self.skip_ws()
2594         res = self._parse_simple_type_specifiers()
2595         if res is not None:
2596             return res
2597 
2598         # prefixed
2599         prefix = None
2600         self.skip_ws()
2601         for k in ('struct', 'enum', 'union'):
2602             if self.skip_word_and_ws(k):
2603                 prefix = k
2604                 break
2605 
2606         nestedName = self._parse_nested_name()
2607         return ASTTrailingTypeSpecName(prefix, nestedName)
2608 
2609     def _parse_parameters(self, paramMode: str) -> ASTParameters:
2610         self.skip_ws()
2611         if not self.skip_string('('):
2612             if paramMode == 'function':
2613                 self.fail('Expecting "(" in parameters.')
2614             else:
2615                 return None
2616 
2617         args = []
2618         self.skip_ws()
2619         if not self.skip_string(')'):
2620             while 1:
2621                 self.skip_ws()
2622                 if self.skip_string('...'):
2623                     args.append(ASTFunctionParameter(None, True))
2624                     self.skip_ws()
2625                     if not self.skip_string(')'):
2626                         self.fail('Expected ")" after "..." in parameters.')
2627                     break
2628                 # note: it seems that function arguments can always be named,
2629                 # even in function pointers and similar.
2630                 arg = self._parse_type_with_init(outer=None, named='single')
2631                 # TODO: parse default parameters # TODO: didn't we just do that?
2632                 args.append(ASTFunctionParameter(arg))
2633 
2634                 self.skip_ws()
2635                 if self.skip_string(','):
2636                     continue
2637                 elif self.skip_string(')'):
2638                     break
2639                 else:
2640                     self.fail(
2641                         'Expecting "," or ")" in parameters, '
2642                         'got "%s".' % self.current_char)
2643 
2644         attrs = []
2645         while True:
2646             attr = self._parse_attribute()
2647             if attr is None:
2648                 break
2649             attrs.append(attr)
2650 
2651         return ASTParameters(args, attrs)
2652 
2653     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:
2654         """Just parse the simple ones."""
2655         storage = None
2656         threadLocal = None
2657         inline = None
2658         restrict = None
2659         volatile = None
2660         const = None
2661         attrs = []
2662         while 1:  # accept any permutation of a subset of some decl-specs
2663             self.skip_ws()
2664             if not storage:
2665                 if outer == 'member':
2666                     if self.skip_word('auto'):
2667                         storage = 'auto'
2668                         continue
2669                     if self.skip_word('register'):
2670                         storage = 'register'
2671                         continue
2672                 if outer in ('member', 'function'):
2673                     if self.skip_word('static'):
2674                         storage = 'static'
2675                         continue
2676                     if self.skip_word('extern'):
2677                         storage = 'extern'
2678                         continue
2679             if outer == 'member' and not threadLocal:
2680                 if self.skip_word('thread_local'):
2681                     threadLocal = 'thread_local'
2682                     continue
2683                 if self.skip_word('_Thread_local'):
2684                     threadLocal = '_Thread_local'
2685                     continue
2686             if outer == 'function' and not inline:
2687                 inline = self.skip_word('inline')
2688                 if inline:
2689                     continue
2690 
2691             if not restrict and typed:
2692                 restrict = self.skip_word('restrict')
2693                 if restrict:
2694                     continue
2695             if not volatile and typed:
2696                 volatile = self.skip_word('volatile')
2697                 if volatile:
2698                     continue
2699             if not const and typed:
2700                 const = self.skip_word('const')
2701                 if const:
2702                     continue
2703             attr = self._parse_attribute()
2704             if attr:
2705                 attrs.append(attr)
2706                 continue
2707             break
2708         return ASTDeclSpecsSimple(storage, threadLocal, inline,
2709                                   restrict, volatile, const, attrs)
2710 
2711     def _parse_decl_specs(self, outer: str, typed: bool = True) -> ASTDeclSpecs:
2712         if outer:
2713             if outer not in ('type', 'member', 'function'):
2714                 raise Exception('Internal error, unknown outer "%s".' % outer)
2715         leftSpecs = self._parse_decl_specs_simple(outer, typed)
2716         rightSpecs = None
2717 
2718         if typed:
2719             trailing = self._parse_trailing_type_spec()
2720             rightSpecs = self._parse_decl_specs_simple(outer, typed)
2721         else:
2722             trailing = None
2723         return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)
2724 
2725     def _parse_declarator_name_suffix(
2726             self, named: Union[bool, str], paramMode: str, typed: bool
2727     ) -> ASTDeclarator:
2728         assert named in (True, False, 'single')
2729         # now we should parse the name, and then suffixes
2730         if named == 'single':
2731             if self.match(identifier_re):
2732                 if self.matched_text in _keywords:
2733                     self.fail("Expected identifier, "
2734                               "got keyword: %s" % self.matched_text)
2735                 if self.matched_text in self.config.c_extra_keywords:
2736                     msg = "Expected identifier, got user-defined keyword: %s." \
2737                           + " Remove it from c_extra_keywords to allow it as identifier.\n" \
2738                           + "Currently c_extra_keywords is %s."
2739                     self.fail(msg % (self.matched_text,
2740                                      str(self.config.c_extra_keywords)))
2741                 identifier = ASTIdentifier(self.matched_text)
2742                 declId = ASTNestedName([identifier], rooted=False)
2743             else:
2744                 declId = None
2745         elif named:
2746             declId = self._parse_nested_name()
2747         else:
2748             declId = None
2749         arrayOps = []
2750         while 1:
2751             self.skip_ws()
2752             if typed and self.skip_string('['):
2753                 self.skip_ws()
2754                 static = False
2755                 const = False
2756                 volatile = False
2757                 restrict = False
2758                 while True:
2759                     if not static:
2760                         if self.skip_word_and_ws('static'):
2761                             static = True
2762                             continue
2763                     if not const:
2764                         if self.skip_word_and_ws('const'):
2765                             const = True
2766                             continue
2767                     if not volatile:
2768                         if self.skip_word_and_ws('volatile'):
2769                             volatile = True
2770                             continue
2771                     if not restrict:
2772                         if self.skip_word_and_ws('restrict'):
2773                             restrict = True
2774                             continue
2775                     break
2776                 vla = False if static else self.skip_string_and_ws('*')
2777                 if vla:
2778                     if not self.skip_string(']'):
2779                         self.fail("Expected ']' in end of array operator.")
2780                     size = None
2781                 else:
2782                     if self.skip_string(']'):
2783                         size = None
2784                     else:
2785 
2786                         def parser():
2787                             return self._parse_expression()
2788                         size = self._parse_expression_fallback([']'], parser)
2789                         self.skip_ws()
2790                         if not self.skip_string(']'):
2791                             self.fail("Expected ']' in end of array operator.")
2792                 arrayOps.append(ASTArray(static, const, volatile, restrict, vla, size))
2793             else:
2794                 break
2795         param = self._parse_parameters(paramMode)
2796         if param is None and len(arrayOps) == 0:
2797             # perhaps a bit-field
2798             if named and paramMode == 'type' and typed:
2799                 self.skip_ws()
2800                 if self.skip_string(':'):
2801                     size = self._parse_constant_expression()
2802                     return ASTDeclaratorNameBitField(declId=declId, size=size)
2803         return ASTDeclaratorNameParam(declId=declId, arrayOps=arrayOps,
2804                                       param=param)
2805 
2806     def _parse_declarator(self, named: Union[bool, str], paramMode: str,
2807                           typed: bool = True) -> ASTDeclarator:
2808         # 'typed' here means 'parse return type stuff'
2809         if paramMode not in ('type', 'function'):
2810             raise Exception(
2811                 "Internal error, unknown paramMode '%s'." % paramMode)
2812         prevErrors = []
2813         self.skip_ws()
2814         if typed and self.skip_string('*'):
2815             self.skip_ws()
2816             restrict = False
2817             volatile = False
2818             const = False
2819             attrs = []
2820             while 1:
2821                 if not restrict:
2822                     restrict = self.skip_word_and_ws('restrict')
2823                     if restrict:
2824                         continue
2825                 if not volatile:
2826                     volatile = self.skip_word_and_ws('volatile')
2827                     if volatile:
2828                         continue
2829                 if not const:
2830                     const = self.skip_word_and_ws('const')
2831                     if const:
2832                         continue
2833                 attr = self._parse_attribute()
2834                 if attr is not None:
2835                     attrs.append(attr)
2836                     continue
2837                 break
2838             next = self._parse_declarator(named, paramMode, typed)
2839             return ASTDeclaratorPtr(next=next,
2840                                     restrict=restrict, volatile=volatile, const=const,
2841                                     attrs=attrs)
2842         if typed and self.current_char == '(':  # note: peeking, not skipping
2843             # maybe this is the beginning of params, try that first,
2844             # otherwise assume it's noptr->declarator > ( ptr-declarator )
2845             pos = self.pos
2846             try:
2847                 # assume this is params
2848                 res = self._parse_declarator_name_suffix(named, paramMode,
2849                                                          typed)
2850                 return res
2851             except DefinitionError as exParamQual:
2852                 msg = "If declarator-id with parameters"
2853                 if paramMode == 'function':
2854                     msg += " (e.g., 'void f(int arg)')"
2855                 prevErrors.append((exParamQual, msg))
2856                 self.pos = pos
2857                 try:
2858                     assert self.current_char == '('
2859                     self.skip_string('(')
2860                     # TODO: hmm, if there is a name, it must be in inner, right?
2861                     # TODO: hmm, if there must be parameters, they must b
2862                     # inside, right?
2863                     inner = self._parse_declarator(named, paramMode, typed)
2864                     if not self.skip_string(')'):
2865                         self.fail("Expected ')' in \"( ptr-declarator )\"")
2866                     next = self._parse_declarator(named=False,
2867                                                   paramMode="type",
2868                                                   typed=typed)
2869                     return ASTDeclaratorParen(inner=inner, next=next)
2870                 except DefinitionError as exNoPtrParen:
2871                     self.pos = pos
2872                     msg = "If parenthesis in noptr-declarator"
2873                     if paramMode == 'function':
2874                         msg += " (e.g., 'void (*f(int arg))(double)')"
2875                     prevErrors.append((exNoPtrParen, msg))
2876                     header = "Error in declarator"
2877                     raise self._make_multi_error(prevErrors, header) from exNoPtrParen
2878         pos = self.pos
2879         try:
2880             return self._parse_declarator_name_suffix(named, paramMode, typed)
2881         except DefinitionError as e:
2882             self.pos = pos
2883             prevErrors.append((e, "If declarator-id"))
2884             header = "Error in declarator or parameters"
2885             raise self._make_multi_error(prevErrors, header) from e
2886 
2887     def _parse_initializer(self, outer: str = None, allowFallback: bool = True
2888                            ) -> ASTInitializer:
2889         self.skip_ws()
2890         if outer == 'member' and False:  # TODO
2891             bracedInit = self._parse_braced_init_list()
2892             if bracedInit is not None:
2893                 return ASTInitializer(bracedInit, hasAssign=False)
2894 
2895         if not self.skip_string('='):
2896             return None
2897 
2898         bracedInit = self._parse_braced_init_list()
2899         if bracedInit is not None:
2900             return ASTInitializer(bracedInit)
2901 
2902         if outer == 'member':
2903             fallbackEnd: List[str] = []
2904         elif outer is None:  # function parameter
2905             fallbackEnd = [',', ')']
2906         else:
2907             self.fail("Internal error, initializer for outer '%s' not "
2908                       "implemented." % outer)
2909 
2910         def parser():
2911             return self._parse_assignment_expression()
2912 
2913         value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)
2914         return ASTInitializer(value)
2915 
2916     def _parse_type(self, named: Union[bool, str], outer: str = None) -> ASTType:
2917         """
2918         named=False|'single'|True: 'single' is e.g., for function objects which
2919         doesn't need to name the arguments, but otherwise is a single name
2920         """
2921         if outer:  # always named
2922             if outer not in ('type', 'member', 'function'):
2923                 raise Exception('Internal error, unknown outer "%s".' % outer)
2924             assert named
2925 
2926         if outer == 'type':
2927             # We allow type objects to just be a name.
2928             prevErrors = []
2929             startPos = self.pos
2930             # first try without the type
2931             try:
2932                 declSpecs = self._parse_decl_specs(outer=outer, typed=False)
2933                 decl = self._parse_declarator(named=True, paramMode=outer,
2934                                               typed=False)
2935                 self.assert_end(allowSemicolon=True)
2936             except DefinitionError as exUntyped:
2937                 desc = "If just a name"
2938                 prevErrors.append((exUntyped, desc))
2939                 self.pos = startPos
2940                 try:
2941                     declSpecs = self._parse_decl_specs(outer=outer)
2942                     decl = self._parse_declarator(named=True, paramMode=outer)
2943                 except DefinitionError as exTyped:
2944                     self.pos = startPos
2945                     desc = "If typedef-like declaration"
2946                     prevErrors.append((exTyped, desc))
2947                     # Retain the else branch for easier debugging.
2948                     # TODO: it would be nice to save the previous stacktrace
2949                     #       and output it here.
2950                     if True:
2951                         header = "Type must be either just a name or a "
2952                         header += "typedef-like declaration."
2953                         raise self._make_multi_error(prevErrors, header) from exTyped
2954                     else:
2955                         # For testing purposes.
2956                         # do it again to get the proper traceback (how do you
2957                         # reliably save a traceback when an exception is
2958                         # constructed?)
2959                         self.pos = startPos
2960                         typed = True
2961                         declSpecs = self._parse_decl_specs(outer=outer, typed=typed)
2962                         decl = self._parse_declarator(named=True, paramMode=outer,
2963                                                       typed=typed)
2964         elif outer == 'function':
2965             declSpecs = self._parse_decl_specs(outer=outer)
2966             decl = self._parse_declarator(named=True, paramMode=outer)
2967         else:
2968             paramMode = 'type'
2969             if outer == 'member':  # i.e., member
2970                 named = True
2971             declSpecs = self._parse_decl_specs(outer=outer)
2972             decl = self._parse_declarator(named=named, paramMode=paramMode)
2973         return ASTType(declSpecs, decl)
2974 
2975     def _parse_type_with_init(self, named: Union[bool, str], outer: str) -> ASTTypeWithInit:
2976         if outer:
2977             assert outer in ('type', 'member', 'function')
2978         type = self._parse_type(outer=outer, named=named)
2979         init = self._parse_initializer(outer=outer)
2980         return ASTTypeWithInit(type, init)
2981 
2982     def _parse_macro(self) -> ASTMacro:
2983         self.skip_ws()
2984         ident = self._parse_nested_name()
2985         if ident is None:
2986             self.fail("Expected identifier in macro definition.")
2987         self.skip_ws()
2988         if not self.skip_string_and_ws('('):
2989             return ASTMacro(ident, None)
2990         if self.skip_string(')'):
2991             return ASTMacro(ident, [])
2992         args = []
2993         while 1:
2994             self.skip_ws()
2995             if self.skip_string('...'):
2996                 args.append(ASTMacroParameter(None, True))
2997                 self.skip_ws()
2998                 if not self.skip_string(')'):
2999                     self.fail('Expected ")" after "..." in macro parameters.')
3000                 break
3001             if not self.match(identifier_re):
3002                 self.fail("Expected identifier in macro parameters.")
3003             nn = ASTNestedName([ASTIdentifier(self.matched_text)], rooted=False)
3004             # Allow named variadic args:
3005             # https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html
3006             self.skip_ws()
3007             if self.skip_string_and_ws('...'):
3008                 args.append(ASTMacroParameter(nn, False, True))
3009                 self.skip_ws()
3010                 if not self.skip_string(')'):
3011                     self.fail('Expected ")" after "..." in macro parameters.')
3012                 break
3013             args.append(ASTMacroParameter(nn))
3014             if self.skip_string_and_ws(','):
3015                 continue
3016             elif self.skip_string_and_ws(')'):
3017                 break
3018             else:
3019                 self.fail("Expected identifier, ')', or ',' in macro parameter list.")
3020         return ASTMacro(ident, args)
3021 
3022     def _parse_struct(self) -> ASTStruct:
3023         name = self._parse_nested_name()
3024         return ASTStruct(name)
3025 
3026     def _parse_union(self) -> ASTUnion:
3027         name = self._parse_nested_name()
3028         return ASTUnion(name)
3029 
3030     def _parse_enum(self) -> ASTEnum:
3031         name = self._parse_nested_name()
3032         return ASTEnum(name)
3033 
3034     def _parse_enumerator(self) -> ASTEnumerator:
3035         name = self._parse_nested_name()
3036         self.skip_ws()
3037         init = None
3038         if self.skip_string('='):
3039             self.skip_ws()
3040 
3041             def parser() -> ASTExpression:
3042                 return self._parse_constant_expression()
3043 
3044             initVal = self._parse_expression_fallback([], parser)
3045             init = ASTInitializer(initVal)
3046         return ASTEnumerator(name, init)
3047 
3048     def parse_pre_v3_type_definition(self) -> ASTDeclaration:
3049         self.skip_ws()
3050         declaration: DeclarationType = None
3051         if self.skip_word('struct'):
3052             typ = 'struct'
3053             declaration = self._parse_struct()
3054         elif self.skip_word('union'):
3055             typ = 'union'
3056             declaration = self._parse_union()
3057         elif self.skip_word('enum'):
3058             typ = 'enum'
3059             declaration = self._parse_enum()
3060         else:
3061             self.fail("Could not parse pre-v3 type directive."
3062                       " Must start with 'struct', 'union', or 'enum'.")
3063         return ASTDeclaration(typ, typ, declaration, False)
3064 
3065     def parse_declaration(self, objectType: str, directiveType: str) -> ASTDeclaration:
3066         if objectType not in ('function', 'member',
3067                               'macro', 'struct', 'union', 'enum', 'enumerator', 'type'):
3068             raise Exception('Internal error, unknown objectType "%s".' % objectType)
3069         if directiveType not in ('function', 'member', 'var',
3070                                  'macro', 'struct', 'union', 'enum', 'enumerator', 'type'):
3071             raise Exception('Internal error, unknown directiveType "%s".' % directiveType)
3072 
3073         declaration: DeclarationType = None
3074         if objectType == 'member':
3075             declaration = self._parse_type_with_init(named=True, outer='member')
3076         elif objectType == 'function':
3077             declaration = self._parse_type(named=True, outer='function')
3078         elif objectType == 'macro':
3079             declaration = self._parse_macro()
3080         elif objectType == 'struct':
3081             declaration = self._parse_struct()
3082         elif objectType == 'union':
3083             declaration = self._parse_union()
3084         elif objectType == 'enum':
3085             declaration = self._parse_enum()
3086         elif objectType == 'enumerator':
3087             declaration = self._parse_enumerator()
3088         elif objectType == 'type':
3089             declaration = self._parse_type(named=True, outer='type')
3090         else:
3091             assert False
3092         if objectType != 'macro':
3093             self.skip_ws()
3094             semicolon = self.skip_string(';')
3095         else:
3096             semicolon = False
3097         return ASTDeclaration(objectType, directiveType, declaration, semicolon)
3098 
3099     def parse_namespace_object(self) -> ASTNestedName:
3100         return self._parse_nested_name()
3101 
3102     def parse_xref_object(self) -> ASTNestedName:
3103         name = self._parse_nested_name()
3104         # if there are '()' left, just skip them
3105         self.skip_ws()
3106         self.skip_string('()')
3107         self.assert_end()
3108         return name
3109 
3110     def parse_expression(self) -> Union[ASTExpression, ASTType]:
3111         pos = self.pos
3112         res: Union[ASTExpression, ASTType] = None
3113         try:
3114             res = self._parse_expression()
3115             self.skip_ws()
3116             self.assert_end()
3117         except DefinitionError as exExpr:
3118             self.pos = pos
3119             try:
3120                 res = self._parse_type(False)
3121                 self.skip_ws()
3122                 self.assert_end()
3123             except DefinitionError as exType:
3124                 header = "Error when parsing (type) expression."
3125                 errs = []
3126                 errs.append((exExpr, "If expression"))
3127                 errs.append((exType, "If type"))
3128                 raise self._make_multi_error(errs, header) from exType
3129         return res

</code><intended_behavior>Adjust the id_attributes property and perhaps the setup method as needed to ensure that when Sphinx encounters attributes in enum value declarations (like __attribute__((__deprecated__)) or macros intended for deprecation signals), these attributes are either ignored or processed in a way that does not interfere with the correct identification of the enum value names. This might involve modifying how c_id_attributes is used within this parsing context to ensure attributes in enums are handled according to the expected documentation output, without misinterpretation or causing duplicate declaration issues.</intended_behavior>, <file>sphinx/domains/cpp.py</file>
<class>DefinitionParser</class>
<method>None</method>
<code>
5087 class DefinitionParser(BaseParser):
5088     @property
5089     def language(self) -> str:
5090         return 'C++'
5091 
5092     @property
5093     def id_attributes(self):
5094         return self.config.cpp_id_attributes
5095 
5096     @property
5097     def paren_attributes(self):
5098         return self.config.cpp_paren_attributes
5099 
5100     def _parse_string(self) -> str:
5101         if self.current_char != '"':
5102             return None
5103         startPos = self.pos
5104         self.pos += 1
5105         escape = False
5106         while True:
5107             if self.eof:
5108                 self.fail("Unexpected end during inside string.")
5109             elif self.current_char == '"' and not escape:
5110                 self.pos += 1
5111                 break
5112             elif self.current_char == '\\':
5113                 escape = True
5114             else:
5115                 escape = False
5116             self.pos += 1
5117         return self.definition[startPos:self.pos]
5118 
5119     def _parse_literal(self) -> ASTLiteral:
5120         # -> integer-literal
5121         #  | character-literal
5122         #  | floating-literal
5123         #  | string-literal
5124         #  | boolean-literal -> "false" | "true"
5125         #  | pointer-literal -> "nullptr"
5126         #  | user-defined-literal
5127 
5128         def _udl(literal: ASTLiteral) -> ASTLiteral:
5129             if not self.match(udl_identifier_re):
5130                 return literal
5131             # hmm, should we care if it's a keyword?
5132             # it looks like GCC does not disallow keywords
5133             ident = ASTIdentifier(self.matched_text)
5134             return ASTUserDefinedLiteral(literal, ident)
5135 
5136         self.skip_ws()
5137         if self.skip_word('nullptr'):
5138             return ASTPointerLiteral()
5139         if self.skip_word('true'):
5140             return ASTBooleanLiteral(True)
5141         if self.skip_word('false'):
5142             return ASTBooleanLiteral(False)
5143         pos = self.pos
5144         if self.match(float_literal_re):
5145             hasSuffix = self.match(float_literal_suffix_re)
5146             floatLit = ASTNumberLiteral(self.definition[pos:self.pos])
5147             if hasSuffix:
5148                 return floatLit
5149             else:
5150                 return _udl(floatLit)
5151         for regex in [binary_literal_re, hex_literal_re,
5152                       integer_literal_re, octal_literal_re]:
5153             if self.match(regex):
5154                 hasSuffix = self.match(integers_literal_suffix_re)
5155                 intLit = ASTNumberLiteral(self.definition[pos:self.pos])
5156                 if hasSuffix:
5157                     return intLit
5158                 else:
5159                     return _udl(intLit)
5160 
5161         string = self._parse_string()
5162         if string is not None:
5163             return _udl(ASTStringLiteral(string))
5164 
5165         # character-literal
5166         if self.match(char_literal_re):
5167             prefix = self.last_match.group(1)  # may be None when no prefix
5168             data = self.last_match.group(2)
5169             try:
5170                 charLit = ASTCharLiteral(prefix, data)
5171             except UnicodeDecodeError as e:
5172                 self.fail("Can not handle character literal. Internal error was: %s" % e)
5173             except UnsupportedMultiCharacterCharLiteral:
5174                 self.fail("Can not handle character literal"
5175                           " resulting in multiple decoded characters.")
5176             return _udl(charLit)
5177         return None
5178 
5179     def _parse_fold_or_paren_expression(self) -> ASTExpression:
5180         # "(" expression ")"
5181         # fold-expression
5182         # -> ( cast-expression fold-operator ... )
5183         #  | ( ... fold-operator cast-expression )
5184         #  | ( cast-expression fold-operator ... fold-operator cast-expression
5185         if self.current_char != '(':
5186             return None
5187         self.pos += 1
5188         self.skip_ws()
5189         if self.skip_string_and_ws("..."):
5190             # ( ... fold-operator cast-expression )
5191             if not self.match(_fold_operator_re):
5192                 self.fail("Expected fold operator after '...' in fold expression.")
5193             op = self.matched_text
5194             rightExpr = self._parse_cast_expression()
5195             if not self.skip_string(')'):
5196                 self.fail("Expected ')' in end of fold expression.")
5197             return ASTFoldExpr(None, op, rightExpr)
5198         # try first parsing a unary right fold, or a binary fold
5199         pos = self.pos
5200         try:
5201             self.skip_ws()
5202             leftExpr = self._parse_cast_expression()
5203             self.skip_ws()
5204             if not self.match(_fold_operator_re):
5205                 self.fail("Expected fold operator after left expression in fold expression.")
5206             op = self.matched_text
5207             self.skip_ws()
5208             if not self.skip_string_and_ws('...'):
5209                 self.fail("Expected '...' after fold operator in fold expression.")
5210         except DefinitionError as eFold:
5211             self.pos = pos
5212             # fall back to a paren expression
5213             try:
5214                 res = self._parse_expression()
5215                 self.skip_ws()
5216                 if not self.skip_string(')'):
5217                     self.fail("Expected ')' in end of parenthesized expression.")
5218             except DefinitionError as eExpr:
5219                 raise self._make_multi_error([
5220                     (eFold, "If fold expression"),
5221                     (eExpr, "If parenthesized expression")
5222                 ], "Error in fold expression or parenthesized expression.") from eExpr
5223             return ASTParenExpr(res)
5224         # now it definitely is a fold expression
5225         if self.skip_string(')'):
5226             return ASTFoldExpr(leftExpr, op, None)
5227         if not self.match(_fold_operator_re):
5228             self.fail("Expected fold operator or ')' after '...' in fold expression.")
5229         if op != self.matched_text:
5230             self.fail("Operators are different in binary fold: '%s' and '%s'."
5231                       % (op, self.matched_text))
5232         rightExpr = self._parse_cast_expression()
5233         self.skip_ws()
5234         if not self.skip_string(')'):
5235             self.fail("Expected ')' to end binary fold expression.")
5236         return ASTFoldExpr(leftExpr, op, rightExpr)
5237 
5238     def _parse_primary_expression(self) -> ASTExpression:
5239         # literal
5240         # "this"
5241         # lambda-expression
5242         # "(" expression ")"
5243         # fold-expression
5244         # id-expression -> we parse this with _parse_nested_name
5245         self.skip_ws()
5246         res: ASTExpression = self._parse_literal()
5247         if res is not None:
5248             return res
5249         self.skip_ws()
5250         if self.skip_word("this"):
5251             return ASTThisLiteral()
5252         # TODO: try lambda expression
5253         res = self._parse_fold_or_paren_expression()
5254         if res is not None:
5255             return res
5256         nn = self._parse_nested_name()
5257         if nn is not None:
5258             return ASTIdExpression(nn)
5259         return None
5260 
5261     def _parse_initializer_list(self, name: str, open: str, close: str
5262                                 ) -> Tuple[List[Union[ASTExpression,
5263                                                       ASTBracedInitList]],
5264                                            bool]:
5265         # Parse open and close with the actual initializer-list in between
5266         # -> initializer-clause '...'[opt]
5267         #  | initializer-list ',' initializer-clause '...'[opt]
5268         self.skip_ws()
5269         if not self.skip_string_and_ws(open):
5270             return None, None
5271         if self.skip_string(close):
5272             return [], False
5273 
5274         exprs: List[Union[ASTExpression, ASTBracedInitList]] = []
5275         trailingComma = False
5276         while True:
5277             self.skip_ws()
5278             expr = self._parse_initializer_clause()
5279             self.skip_ws()
5280             if self.skip_string('...'):
5281                 exprs.append(ASTPackExpansionExpr(expr))
5282             else:
5283                 exprs.append(expr)
5284             self.skip_ws()
5285             if self.skip_string(close):
5286                 break
5287             if not self.skip_string_and_ws(','):
5288                 self.fail("Error in %s, expected ',' or '%s'." % (name, close))
5289             if self.current_char == close and close == '}':
5290                 self.pos += 1
5291                 trailingComma = True
5292                 break
5293         return exprs, trailingComma
5294 
5295     def _parse_paren_expression_list(self) -> ASTParenExprList:
5296         # -> '(' expression-list ')'
5297         # though, we relax it to also allow empty parens
5298         # as it's needed in some cases
5299         #
5300         # expression-list
5301         # -> initializer-list
5302         exprs, trailingComma = self._parse_initializer_list("parenthesized expression-list",
5303                                                             '(', ')')
5304         if exprs is None:
5305             return None
5306         return ASTParenExprList(exprs)
5307 
5308     def _parse_initializer_clause(self) -> Union[ASTExpression, ASTBracedInitList]:
5309         bracedInitList = self._parse_braced_init_list()
5310         if bracedInitList is not None:
5311             return bracedInitList
5312         return self._parse_assignment_expression(inTemplate=False)
5313 
5314     def _parse_braced_init_list(self) -> ASTBracedInitList:
5315         # -> '{' initializer-list ','[opt] '}'
5316         #  | '{' '}'
5317         exprs, trailingComma = self._parse_initializer_list("braced-init-list", '{', '}')
5318         if exprs is None:
5319             return None
5320         return ASTBracedInitList(exprs, trailingComma)
5321 
5322     def _parse_expression_list_or_braced_init_list(
5323         self
5324     ) -> Union[ASTParenExprList, ASTBracedInitList]:
5325         paren = self._parse_paren_expression_list()
5326         if paren is not None:
5327             return paren
5328         return self._parse_braced_init_list()
5329 
5330     def _parse_postfix_expression(self) -> ASTPostfixExpr:
5331         # -> primary
5332         #  | postfix "[" expression "]"
5333         #  | postfix "[" braced-init-list [opt] "]"
5334         #  | postfix "(" expression-list [opt] ")"
5335         #  | postfix "." "template" [opt] id-expression
5336         #  | postfix "->" "template" [opt] id-expression
5337         #  | postfix "." pseudo-destructor-name
5338         #  | postfix "->" pseudo-destructor-name
5339         #  | postfix "++"
5340         #  | postfix "--"
5341         #  | simple-type-specifier "(" expression-list [opt] ")"
5342         #  | simple-type-specifier braced-init-list
5343         #  | typename-specifier "(" expression-list [opt] ")"
5344         #  | typename-specifier braced-init-list
5345         #  | "dynamic_cast" "<" type-id ">" "(" expression ")"
5346         #  | "static_cast" "<" type-id ">" "(" expression ")"
5347         #  | "reinterpret_cast" "<" type-id ">" "(" expression ")"
5348         #  | "const_cast" "<" type-id ">" "(" expression ")"
5349         #  | "typeid" "(" expression ")"
5350         #  | "typeid" "(" type-id ")"
5351 
5352         prefixType = None
5353         prefix: Any = None
5354         self.skip_ws()
5355 
5356         cast = None
5357         for c in _id_explicit_cast:
5358             if self.skip_word_and_ws(c):
5359                 cast = c
5360                 break
5361         if cast is not None:
5362             prefixType = "cast"
5363             if not self.skip_string("<"):
5364                 self.fail("Expected '<' after '%s'." % cast)
5365             typ = self._parse_type(False)
5366             self.skip_ws()
5367             if not self.skip_string_and_ws(">"):
5368                 self.fail("Expected '>' after type in '%s'." % cast)
5369             if not self.skip_string("("):
5370                 self.fail("Expected '(' in '%s'." % cast)
5371 
5372             def parser() -> ASTExpression:
5373                 return self._parse_expression()
5374             expr = self._parse_expression_fallback([')'], parser)
5375             self.skip_ws()
5376             if not self.skip_string(")"):
5377                 self.fail("Expected ')' to end '%s'." % cast)
5378             prefix = ASTExplicitCast(cast, typ, expr)
5379         elif self.skip_word_and_ws("typeid"):
5380             prefixType = "typeid"
5381             if not self.skip_string_and_ws('('):
5382                 self.fail("Expected '(' after 'typeid'.")
5383             pos = self.pos
5384             try:
5385                 typ = self._parse_type(False)
5386                 prefix = ASTTypeId(typ, isType=True)
5387                 if not self.skip_string(')'):
5388                     self.fail("Expected ')' to end 'typeid' of type.")
5389             except DefinitionError as eType:
5390                 self.pos = pos
5391                 try:
5392 
5393                     def parser() -> ASTExpression:
5394                         return self._parse_expression()
5395                     expr = self._parse_expression_fallback([')'], parser)
5396                     prefix = ASTTypeId(expr, isType=False)
5397                     if not self.skip_string(')'):
5398                         self.fail("Expected ')' to end 'typeid' of expression.")
5399                 except DefinitionError as eExpr:
5400                     self.pos = pos
5401                     header = "Error in 'typeid(...)'."
5402                     header += " Expected type or expression."
5403                     errors = []
5404                     errors.append((eType, "If type"))
5405                     errors.append((eExpr, "If expression"))
5406                     raise self._make_multi_error(errors, header) from eExpr
5407         else:  # a primary expression or a type
5408             pos = self.pos
5409             try:
5410                 prefix = self._parse_primary_expression()
5411                 prefixType = 'expr'
5412             except DefinitionError as eOuter:
5413                 self.pos = pos
5414                 try:
5415                     # we are potentially casting, so save parens for us
5416                     # TODO: hmm, would we need to try both with operatorCast and with None?
5417                     prefix = self._parse_type(False, 'operatorCast')
5418                     prefixType = 'typeOperatorCast'
5419                     #  | simple-type-specifier "(" expression-list [opt] ")"
5420                     #  | simple-type-specifier braced-init-list
5421                     #  | typename-specifier "(" expression-list [opt] ")"
5422                     #  | typename-specifier braced-init-list
5423                     self.skip_ws()
5424                     if self.current_char != '(' and self.current_char != '{':
5425                         self.fail("Expecting '(' or '{' after type in cast expression.")
5426                 except DefinitionError as eInner:
5427                     self.pos = pos
5428                     header = "Error in postfix expression,"
5429                     header += " expected primary expression or type."
5430                     errors = []
5431                     errors.append((eOuter, "If primary expression"))
5432                     errors.append((eInner, "If type"))
5433                     raise self._make_multi_error(errors, header) from eInner
5434 
5435         # and now parse postfixes
5436         postFixes: List[ASTPostfixOp] = []
5437         while True:
5438             self.skip_ws()
5439             if prefixType in ('expr', 'cast', 'typeid'):
5440                 if self.skip_string_and_ws('['):
5441                     expr = self._parse_expression()
5442                     self.skip_ws()
5443                     if not self.skip_string(']'):
5444                         self.fail("Expected ']' in end of postfix expression.")
5445                     postFixes.append(ASTPostfixArray(expr))
5446                     continue
5447                 if self.skip_string('.'):
5448                     if self.skip_string('*'):
5449                         # don't steal the dot
5450                         self.pos -= 2
5451                     elif self.skip_string('..'):
5452                         # don't steal the dot
5453                         self.pos -= 3
5454                     else:
5455                         name = self._parse_nested_name()
5456                         postFixes.append(ASTPostfixMember(name))
5457                         continue
5458                 if self.skip_string('->'):
5459                     if self.skip_string('*'):
5460                         # don't steal the arrow
5461                         self.pos -= 3
5462                     else:
5463                         name = self._parse_nested_name()
5464                         postFixes.append(ASTPostfixMemberOfPointer(name))
5465                         continue
5466                 if self.skip_string('++'):
5467                     postFixes.append(ASTPostfixInc())
5468                     continue
5469                 if self.skip_string('--'):
5470                     postFixes.append(ASTPostfixDec())
5471                     continue
5472             lst = self._parse_expression_list_or_braced_init_list()
5473             if lst is not None:
5474                 postFixes.append(ASTPostfixCallExpr(lst))
5475                 continue
5476             break
5477         return ASTPostfixExpr(prefix, postFixes)
5478 
5479     def _parse_unary_expression(self) -> ASTExpression:
5480         # -> postfix
5481         #  | "++" cast
5482         #  | "--" cast
5483         #  | unary-operator cast -> (* | & | + | - | ! | ~) cast
5484         # The rest:
5485         #  | "sizeof" unary
5486         #  | "sizeof" "(" type-id ")"
5487         #  | "sizeof" "..." "(" identifier ")"
5488         #  | "alignof" "(" type-id ")"
5489         #  | noexcept-expression -> noexcept "(" expression ")"
5490         #  | new-expression
5491         #  | delete-expression
5492         self.skip_ws()
5493         for op in _expression_unary_ops:
5494             # TODO: hmm, should we be able to backtrack here?
5495             if op[0] in 'cn':
5496                 res = self.skip_word(op)
5497             else:
5498                 res = self.skip_string(op)
5499             if res:
5500                 expr = self._parse_cast_expression()
5501                 return ASTUnaryOpExpr(op, expr)
5502         if self.skip_word_and_ws('sizeof'):
5503             if self.skip_string_and_ws('...'):
5504                 if not self.skip_string_and_ws('('):
5505                     self.fail("Expecting '(' after 'sizeof...'.")
5506                 if not self.match(identifier_re):
5507                     self.fail("Expecting identifier for 'sizeof...'.")
5508                 ident = ASTIdentifier(self.matched_text)
5509                 self.skip_ws()
5510                 if not self.skip_string(")"):
5511                     self.fail("Expecting ')' to end 'sizeof...'.")
5512                 return ASTSizeofParamPack(ident)
5513             if self.skip_string_and_ws('('):
5514                 typ = self._parse_type(named=False)
5515                 self.skip_ws()
5516                 if not self.skip_string(')'):
5517                     self.fail("Expecting ')' to end 'sizeof'.")
5518                 return ASTSizeofType(typ)
5519             expr = self._parse_unary_expression()
5520             return ASTSizeofExpr(expr)
5521         if self.skip_word_and_ws('alignof'):
5522             if not self.skip_string_and_ws('('):
5523                 self.fail("Expecting '(' after 'alignof'.")
5524             typ = self._parse_type(named=False)
5525             self.skip_ws()
5526             if not self.skip_string(')'):
5527                 self.fail("Expecting ')' to end 'alignof'.")
5528             return ASTAlignofExpr(typ)
5529         if self.skip_word_and_ws('noexcept'):
5530             if not self.skip_string_and_ws('('):
5531                 self.fail("Expecting '(' after 'noexcept'.")
5532             expr = self._parse_expression()
5533             self.skip_ws()
5534             if not self.skip_string(')'):
5535                 self.fail("Expecting ')' to end 'noexcept'.")
5536             return ASTNoexceptExpr(expr)
5537         # new-expression
5538         pos = self.pos
5539         rooted = self.skip_string('::')
5540         self.skip_ws()
5541         if not self.skip_word_and_ws('new'):
5542             self.pos = pos
5543         else:
5544             # new-placement[opt] new-type-id new-initializer[opt]
5545             # new-placement[opt] ( type-id ) new-initializer[opt]
5546             isNewTypeId = True
5547             if self.skip_string_and_ws('('):
5548                 # either this is a new-placement or it's the second production
5549                 # without placement, and it's actually the ( type-id ) part
5550                 self.fail("Sorry, neither new-placement nor parenthesised type-id "
5551                           "in new-epression is supported yet.")
5552                 # set isNewTypeId = False if it's (type-id)
5553             if isNewTypeId:
5554                 declSpecs = self._parse_decl_specs(outer=None)
5555                 decl = self._parse_declarator(named=False, paramMode="new")
5556             else:
5557                 self.fail("Sorry, parenthesised type-id in new expression not yet supported.")
5558             lst = self._parse_expression_list_or_braced_init_list()
5559             return ASTNewExpr(rooted, isNewTypeId, ASTType(declSpecs, decl), lst)
5560         # delete-expression
5561         pos = self.pos
5562         rooted = self.skip_string('::')
5563         self.skip_ws()
5564         if not self.skip_word_and_ws('delete'):
5565             self.pos = pos
5566         else:
5567             array = self.skip_string_and_ws('[')
5568             if array and not self.skip_string_and_ws(']'):
5569                 self.fail("Expected ']' in array delete-expression.")
5570             expr = self._parse_cast_expression()
5571             return ASTDeleteExpr(rooted, array, expr)
5572         return self._parse_postfix_expression()
5573 
5574     def _parse_cast_expression(self) -> ASTExpression:
5575         # -> unary  | "(" type-id ")" cast
5576         pos = self.pos
5577         self.skip_ws()
5578         if self.skip_string('('):
5579             try:
5580                 typ = self._parse_type(False)
5581                 if not self.skip_string(')'):
5582                     self.fail("Expected ')' in cast expression.")
5583                 expr = self._parse_cast_expression()
5584                 return ASTCastExpr(typ, expr)
5585             except DefinitionError as exCast:
5586                 self.pos = pos
5587                 try:
5588                     return self._parse_unary_expression()
5589                 except DefinitionError as exUnary:
5590                     errs = []
5591                     errs.append((exCast, "If type cast expression"))
5592                     errs.append((exUnary, "If unary expression"))
5593                     raise self._make_multi_error(errs,
5594                                                  "Error in cast expression.") from exUnary
5595         else:
5596             return self._parse_unary_expression()
5597 
5598     def _parse_logical_or_expression(self, inTemplate: bool) -> ASTExpression:
5599         # logical-or     = logical-and      ||
5600         # logical-and    = inclusive-or     &&
5601         # inclusive-or   = exclusive-or     |
5602         # exclusive-or   = and              ^
5603         # and            = equality         &
5604         # equality       = relational       ==, !=
5605         # relational     = shift            <, >, <=, >=, <=>
5606         # shift          = additive         <<, >>
5607         # additive       = multiplicative   +, -
5608         # multiplicative = pm               *, /, %
5609         # pm             = cast             .*, ->*
5610         def _parse_bin_op_expr(self: DefinitionParser,
5611                                opId: int, inTemplate: bool) -> ASTExpression:
5612             if opId + 1 == len(_expression_bin_ops):
5613                 def parser(inTemplate: bool) -> ASTExpression:
5614                     return self._parse_cast_expression()
5615             else:
5616                 def parser(inTemplate: bool) -> ASTExpression:
5617                     return _parse_bin_op_expr(self, opId + 1, inTemplate=inTemplate)
5618             exprs = []
5619             ops = []
5620             exprs.append(parser(inTemplate=inTemplate))
5621             while True:
5622                 self.skip_ws()
5623                 if inTemplate and self.current_char == '>':
5624                     break
5625                 pos = self.pos
5626                 oneMore = False
5627                 for op in _expression_bin_ops[opId]:
5628                     if op[0] in 'abcnox':
5629                         if not self.skip_word(op):
5630                             continue
5631                     else:
5632                         if not self.skip_string(op):
5633                             continue
5634                     if op == '&' and self.current_char == '&':
5635                         # don't split the && 'token'
5636                         self.pos -= 1
5637                         # and btw. && has lower precedence, so we are done
5638                         break
5639                     try:
5640                         expr = parser(inTemplate=inTemplate)
5641                         exprs.append(expr)
5642                         ops.append(op)
5643                         oneMore = True
5644                         break
5645                     except DefinitionError:
5646                         self.pos = pos
5647                 if not oneMore:
5648                     break
5649             return ASTBinOpExpr(exprs, ops)
5650         return _parse_bin_op_expr(self, 0, inTemplate=inTemplate)
5651 
5652     def _parse_conditional_expression_tail(self, orExprHead: ASTExpression,
5653                                            inTemplate: bool) -> Optional[ASTConditionalExpr]:
5654         # Consumes the orExprHead on success.
5655 
5656         # -> "?" expression ":" assignment-expression
5657         self.skip_ws()
5658         if not self.skip_string("?"):
5659             return None
5660         thenExpr = self._parse_expression()
5661         self.skip_ws()
5662         if not self.skip_string(":"):
5663             self.fail('Expected ":" after then-expression in conditional expression.')
5664         elseExpr = self._parse_assignment_expression(inTemplate)
5665         return ASTConditionalExpr(orExprHead, thenExpr, elseExpr)
5666 
5667     def _parse_assignment_expression(self, inTemplate: bool) -> ASTExpression:
5668         # -> conditional-expression
5669         #  | logical-or-expression assignment-operator initializer-clause
5670         #  | yield-expression -> "co_yield" assignment-expression
5671         #                      | "co_yield" braced-init-list
5672         #  | throw-expression -> "throw" assignment-expression[opt]
5673         # TODO: yield-expression
5674         # TODO: throw-expression
5675 
5676         # Now we have (after expanding conditional-expression:
5677         #     logical-or-expression
5678         #   | logical-or-expression "?" expression ":" assignment-expression
5679         #   | logical-or-expression assignment-operator initializer-clause
5680         leftExpr = self._parse_logical_or_expression(inTemplate=inTemplate)
5681         # the ternary operator
5682         condExpr = self._parse_conditional_expression_tail(leftExpr, inTemplate)
5683         if condExpr is not None:
5684             return condExpr
5685         # and actual assignment
5686         for op in _expression_assignment_ops:
5687             if op[0] in 'anox':
5688                 if not self.skip_word(op):
5689                     continue
5690             else:
5691                 if not self.skip_string(op):
5692                     continue
5693             rightExpr = self._parse_initializer_clause()
5694             return ASTAssignmentExpr(leftExpr, op, rightExpr)
5695         # just a logical-or-expression
5696         return leftExpr
5697 
5698     def _parse_constant_expression(self, inTemplate: bool) -> ASTExpression:
5699         # -> conditional-expression ->
5700         #    logical-or-expression
5701         #  | logical-or-expression "?" expression ":" assignment-expression
5702         orExpr = self._parse_logical_or_expression(inTemplate=inTemplate)
5703         condExpr = self._parse_conditional_expression_tail(orExpr, inTemplate)
5704         if condExpr is not None:
5705             return condExpr
5706         return orExpr
5707 
5708     def _parse_expression(self) -> ASTExpression:
5709         # -> assignment-expression
5710         #  | expression "," assignment-expression
5711         exprs = [self._parse_assignment_expression(inTemplate=False)]
5712         while True:
5713             self.skip_ws()
5714             if not self.skip_string(','):
5715                 break
5716             exprs.append(self._parse_assignment_expression(inTemplate=False))
5717         if len(exprs) == 1:
5718             return exprs[0]
5719         else:
5720             return ASTCommaExpr(exprs)
5721 
5722     def _parse_expression_fallback(self, end: List[str],
5723                                    parser: Callable[[], ASTExpression],
5724                                    allow: bool = True) -> ASTExpression:
5725         # Stupidly "parse" an expression.
5726         # 'end' should be a list of characters which ends the expression.
5727 
5728         # first try to use the provided parser
5729         prevPos = self.pos
5730         try:
5731             return parser()
5732         except DefinitionError as e:
5733             # some places (e.g., template parameters) we really don't want to use fallback,
5734             # and for testing we may want to globally disable it
5735             if not allow or not self.allowFallbackExpressionParsing:
5736                 raise
5737             self.warn("Parsing of expression failed. Using fallback parser."
5738                       " Error was:\n%s" % e)
5739             self.pos = prevPos
5740         # and then the fallback scanning
5741         assert end is not None
5742         self.skip_ws()
5743         startPos = self.pos
5744         if self.match(_string_re):
5745             value = self.matched_text
5746         else:
5747             # TODO: add handling of more bracket-like things, and quote handling
5748             brackets = {'(': ')', '{': '}', '[': ']', '<': '>'}
5749             symbols: List[str] = []
5750             while not self.eof:
5751                 if (len(symbols) == 0 and self.current_char in end):
5752                     break
5753                 if self.current_char in brackets.keys():
5754                     symbols.append(brackets[self.current_char])
5755                 elif len(symbols) > 0 and self.current_char == symbols[-1]:
5756                     symbols.pop()
5757                 self.pos += 1
5758             if len(end) > 0 and self.eof:
5759                 self.fail("Could not find end of expression starting at %d."
5760                           % startPos)
5761             value = self.definition[startPos:self.pos].strip()
5762         return ASTFallbackExpr(value.strip())
5763 
5764     # ==========================================================================
5765 
5766     def _parse_operator(self) -> ASTOperator:
5767         self.skip_ws()
5768         # adapted from the old code
5769         # yay, a regular operator definition
5770         if self.match(_operator_re):
5771             return ASTOperatorBuildIn(self.matched_text)
5772 
5773         # new/delete operator?
5774         for op in 'new', 'delete':
5775             if not self.skip_word(op):
5776                 continue
5777             self.skip_ws()
5778             if self.skip_string('['):
5779                 self.skip_ws()
5780                 if not self.skip_string(']'):
5781                     self.fail('Expected "]" after  "operator ' + op + '["')
5782                 op += '[]'
5783             return ASTOperatorBuildIn(op)
5784 
5785         # user-defined literal?
5786         if self.skip_string('""'):
5787             self.skip_ws()
5788             if not self.match(identifier_re):
5789                 self.fail("Expected user-defined literal suffix.")
5790             identifier = ASTIdentifier(self.matched_text)
5791             return ASTOperatorLiteral(identifier)
5792 
5793         # oh well, looks like a cast operator definition.
5794         # In that case, eat another type.
5795         type = self._parse_type(named=False, outer="operatorCast")
5796         return ASTOperatorType(type)
5797 
5798     def _parse_template_argument_list(self) -> ASTTemplateArgs:
5799         # template-argument-list: (but we include the < and > here
5800         #    template-argument ...[opt]
5801         #    template-argument-list, template-argument ...[opt]
5802         # template-argument:
5803         #    constant-expression
5804         #    type-id
5805         #    id-expression
5806         self.skip_ws()
5807         if not self.skip_string_and_ws('<'):
5808             return None
5809         if self.skip_string('>'):
5810             return ASTTemplateArgs([], False)
5811         prevErrors = []
5812         templateArgs: List[Union[ASTType, ASTTemplateArgConstant]] = []
5813         packExpansion = False
5814         while 1:
5815             pos = self.pos
5816             parsedComma = False
5817             parsedEnd = False
5818             try:
5819                 type = self._parse_type(named=False)
5820                 self.skip_ws()
5821                 if self.skip_string_and_ws('...'):
5822                     packExpansion = True
5823                     parsedEnd = True
5824                     if not self.skip_string('>'):
5825                         self.fail('Expected ">" after "..." in template argument list.')
5826                 elif self.skip_string('>'):
5827                     parsedEnd = True
5828                 elif self.skip_string(','):
5829                     parsedComma = True
5830                 else:
5831                     self.fail('Expected "...>", ">" or "," in template argument list.')
5832                 templateArgs.append(type)
5833             except DefinitionError as e:
5834                 prevErrors.append((e, "If type argument"))
5835                 self.pos = pos
5836                 try:
5837                     value = self._parse_constant_expression(inTemplate=True)
5838                     self.skip_ws()
5839                     if self.skip_string_and_ws('...'):
5840                         packExpansion = True
5841                         parsedEnd = True
5842                         if not self.skip_string('>'):
5843                             self.fail('Expected ">" after "..." in template argument list.')
5844                     elif self.skip_string('>'):
5845                         parsedEnd = True
5846                     elif self.skip_string(','):
5847                         parsedComma = True
5848                     else:
5849                         self.fail('Expected "...>", ">" or "," in template argument list.')
5850                     templateArgs.append(ASTTemplateArgConstant(value))
5851                 except DefinitionError as e:
5852                     self.pos = pos
5853                     prevErrors.append((e, "If non-type argument"))
5854                     header = "Error in parsing template argument list."
5855                     raise self._make_multi_error(prevErrors, header) from e
5856             if parsedEnd:
5857                 assert not parsedComma
5858                 break
5859             else:
5860                 assert not packExpansion
5861         return ASTTemplateArgs(templateArgs, packExpansion)
5862 
5863     def _parse_nested_name(self, memberPointer: bool = False) -> ASTNestedName:
5864         names: List[ASTNestedNameElement] = []
5865         templates: List[bool] = []
5866 
5867         self.skip_ws()
5868         rooted = False
5869         if self.skip_string('::'):
5870             rooted = True
5871         while 1:
5872             self.skip_ws()
5873             if len(names) > 0:
5874                 template = self.skip_word_and_ws('template')
5875             else:
5876                 template = False
5877             templates.append(template)
5878             identOrOp: Union[ASTIdentifier, ASTOperator] = None
5879             if self.skip_word_and_ws('operator'):
5880                 identOrOp = self._parse_operator()
5881             else:
5882                 if not self.match(identifier_re):
5883                     if memberPointer and len(names) > 0:
5884                         templates.pop()
5885                         break
5886                     self.fail("Expected identifier in nested name.")
5887                 identifier = self.matched_text
5888                 # make sure there isn't a keyword
5889                 if identifier in _keywords:
5890                     self.fail("Expected identifier in nested name, "
5891                               "got keyword: %s" % identifier)
5892                 identOrOp = ASTIdentifier(identifier)
5893             # try greedily to get template arguments,
5894             # but otherwise a < might be because we are in an expression
5895             pos = self.pos
5896             try:
5897                 templateArgs = self._parse_template_argument_list()
5898             except DefinitionError as ex:
5899                 self.pos = pos
5900                 templateArgs = None
5901                 self.otherErrors.append(ex)
5902             names.append(ASTNestedNameElement(identOrOp, templateArgs))
5903 
5904             self.skip_ws()
5905             if not self.skip_string('::'):
5906                 if memberPointer:
5907                     self.fail("Expected '::' in pointer to member (function).")
5908                 break
5909         return ASTNestedName(names, templates, rooted)
5910 
5911     # ==========================================================================
5912 
5913     def _parse_simple_type_specifiers(self) -> ASTTrailingTypeSpecFundamental:
5914         modifier: Optional[str] = None
5915         signedness: Optional[str] = None
5916         width: List[str] = []
5917         typ: Optional[str] = None
5918         names: List[str] = []  # the parsed sequence
5919 
5920         self.skip_ws()
5921         while self.match(_simple_type_specifiers_re):
5922             t = self.matched_text
5923             names.append(t)
5924             if t in ('auto', 'void', 'bool',
5925                      'char', 'wchar_t', 'char8_t', 'char16_t', 'char32_t',
5926                      'int', '__int64', '__int128',
5927                      'float', 'double',
5928                      '__float80', '_Float64x', '__float128', '_Float128'):
5929                 if typ is not None:
5930                     self.fail("Can not have both {} and {}.".format(t, typ))
5931                 typ = t
5932             elif t in ('signed', 'unsigned'):
5933                 if signedness is not None:
5934                     self.fail("Can not have both {} and {}.".format(t, signedness))
5935                 signedness = t
5936             elif t == 'short':
5937                 if len(width) != 0:
5938                     self.fail("Can not have both {} and {}.".format(t, width[0]))
5939                 width.append(t)
5940             elif t == 'long':
5941                 if len(width) != 0 and width[0] != 'long':
5942                     self.fail("Can not have both {} and {}.".format(t, width[0]))
5943                 width.append(t)
5944             elif t in ('_Imaginary', '_Complex'):
5945                 if modifier is not None:
5946                     self.fail("Can not have both {} and {}.".format(t, modifier))
5947                 modifier = t
5948             self.skip_ws()
5949         if len(names) == 0:
5950             return None
5951 
5952         if typ in ('auto', 'void', 'bool',
5953                    'wchar_t', 'char8_t', 'char16_t', 'char32_t',
5954                    '__float80', '_Float64x', '__float128', '_Float128'):
5955             if modifier is not None:
5956                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5957             if signedness is not None:
5958                 self.fail("Can not have both {} and {}.".format(typ, signedness))
5959             if len(width) != 0:
5960                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5961         elif typ == 'char':
5962             if modifier is not None:
5963                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5964             if len(width) != 0:
5965                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5966         elif typ == 'int':
5967             if modifier is not None:
5968                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5969         elif typ in ('__int64', '__int128'):
5970             if modifier is not None:
5971                 self.fail("Can not have both {} and {}.".format(typ, modifier))
5972             if len(width) != 0:
5973                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5974         elif typ == 'float':
5975             if signedness is not None:
5976                 self.fail("Can not have both {} and {}.".format(typ, signedness))
5977             if len(width) != 0:
5978                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5979         elif typ == 'double':
5980             if signedness is not None:
5981                 self.fail("Can not have both {} and {}.".format(typ, signedness))
5982             if len(width) > 1:
5983                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5984             if len(width) == 1 and width[0] != 'long':
5985                 self.fail("Can not have both {} and {}.".format(typ, ' '.join(width)))
5986         elif typ is None:
5987             if modifier is not None:
5988                 self.fail("Can not have {} without a floating point type.".format(modifier))
5989         else:
5990             assert False, "Unhandled type {}".format(typ)
5991 
5992         canonNames: List[str] = []
5993         if modifier is not None:
5994             canonNames.append(modifier)
5995         if signedness is not None:
5996             canonNames.append(signedness)
5997         canonNames.extend(width)
5998         if typ is not None:
5999             canonNames.append(typ)
6000         return ASTTrailingTypeSpecFundamental(names, canonNames)
6001 
6002     def _parse_trailing_type_spec(self) -> ASTTrailingTypeSpec:
6003         # fundamental types, https://en.cppreference.com/w/cpp/language/type
6004         # and extensions
6005         self.skip_ws()
6006         res = self._parse_simple_type_specifiers()
6007         if res is not None:
6008             return res
6009 
6010         # decltype
6011         self.skip_ws()
6012         if self.skip_word_and_ws('decltype'):
6013             if not self.skip_string_and_ws('('):
6014                 self.fail("Expected '(' after 'decltype'.")
6015             if self.skip_word_and_ws('auto'):
6016                 if not self.skip_string(')'):
6017                     self.fail("Expected ')' after 'decltype(auto'.")
6018                 return ASTTrailingTypeSpecDecltypeAuto()
6019             expr = self._parse_expression()
6020             self.skip_ws()
6021             if not self.skip_string(')'):
6022                 self.fail("Expected ')' after 'decltype(<expr>'.")
6023             return ASTTrailingTypeSpecDecltype(expr)
6024 
6025         # prefixed
6026         prefix = None
6027         self.skip_ws()
6028         for k in ('class', 'struct', 'enum', 'union', 'typename'):
6029             if self.skip_word_and_ws(k):
6030                 prefix = k
6031                 break
6032         nestedName = self._parse_nested_name()
6033         self.skip_ws()
6034         placeholderType = None
6035         if self.skip_word('auto'):
6036             placeholderType = 'auto'
6037         elif self.skip_word_and_ws('decltype'):
6038             if not self.skip_string_and_ws('('):
6039                 self.fail("Expected '(' after 'decltype' in placeholder type specifier.")
6040             if not self.skip_word_and_ws('auto'):
6041                 self.fail("Expected 'auto' after 'decltype(' in placeholder type specifier.")
6042             if not self.skip_string_and_ws(')'):
6043                 self.fail("Expected ')' after 'decltype(auto' in placeholder type specifier.")
6044             placeholderType = 'decltype(auto)'
6045         return ASTTrailingTypeSpecName(prefix, nestedName, placeholderType)
6046 
6047     def _parse_parameters_and_qualifiers(self, paramMode: str) -> ASTParametersQualifiers:
6048         if paramMode == 'new':
6049             return None
6050         self.skip_ws()
6051         if not self.skip_string('('):
6052             if paramMode == 'function':
6053                 self.fail('Expecting "(" in parameters-and-qualifiers.')
6054             else:
6055                 return None
6056         args = []
6057         self.skip_ws()
6058         if not self.skip_string(')'):
6059             while 1:
6060                 self.skip_ws()
6061                 if self.skip_string('...'):
6062                     args.append(ASTFunctionParameter(None, True))
6063                     self.skip_ws()
6064                     if not self.skip_string(')'):
6065                         self.fail('Expected ")" after "..." in '
6066                                   'parameters-and-qualifiers.')
6067                     break
6068                 # note: it seems that function arguments can always be named,
6069                 # even in function pointers and similar.
6070                 arg = self._parse_type_with_init(outer=None, named='single')
6071                 # TODO: parse default parameters # TODO: didn't we just do that?
6072                 args.append(ASTFunctionParameter(arg))
6073 
6074                 self.skip_ws()
6075                 if self.skip_string(','):
6076                     continue
6077                 elif self.skip_string(')'):
6078                     break
6079                 else:
6080                     self.fail(
6081                         'Expecting "," or ")" in parameters-and-qualifiers, '
6082                         'got "%s".' % self.current_char)
6083 
6084         self.skip_ws()
6085         const = self.skip_word_and_ws('const')
6086         volatile = self.skip_word_and_ws('volatile')
6087         if not const:  # the can be permuted
6088             const = self.skip_word_and_ws('const')
6089 
6090         refQual = None
6091         if self.skip_string('&&'):
6092             refQual = '&&'
6093         if not refQual and self.skip_string('&'):
6094             refQual = '&'
6095 
6096         exceptionSpec = None
6097         self.skip_ws()
6098         if self.skip_string('noexcept'):
6099             if self.skip_string_and_ws('('):
6100                 expr = self._parse_constant_expression(False)
6101                 self.skip_ws()
6102                 if not self.skip_string(')'):
6103                     self.fail("Expecting ')' to end 'noexcept'.")
6104                 exceptionSpec = ASTNoexceptSpec(expr)
6105             else:
6106                 exceptionSpec = ASTNoexceptSpec(None)
6107 
6108         self.skip_ws()
6109         if self.skip_string('->'):
6110             trailingReturn = self._parse_type(named=False)
6111         else:
6112             trailingReturn = None
6113 
6114         self.skip_ws()
6115         override = self.skip_word_and_ws('override')
6116         final = self.skip_word_and_ws('final')
6117         if not override:
6118             override = self.skip_word_and_ws(
6119                 'override')  # they can be permuted
6120 
6121         attrs = []
6122         while True:
6123             attr = self._parse_attribute()
6124             if attr is None:
6125                 break
6126             attrs.append(attr)
6127 
6128         self.skip_ws()
6129         initializer = None
6130         # if this is a function pointer we should not swallow an initializer
6131         if paramMode == 'function' and self.skip_string('='):
6132             self.skip_ws()
6133             valid = ('0', 'delete', 'default')
6134             for w in valid:
6135                 if self.skip_word_and_ws(w):
6136                     initializer = w
6137                     break
6138             if not initializer:
6139                 self.fail(
6140                     'Expected "%s" in initializer-specifier.'
6141                     % '" or "'.join(valid))
6142 
6143         return ASTParametersQualifiers(
6144             args, volatile, const, refQual, exceptionSpec, trailingReturn,
6145             override, final, attrs, initializer)
6146 
6147     def _parse_decl_specs_simple(self, outer: str, typed: bool) -> ASTDeclSpecsSimple:
6148         """Just parse the simple ones."""
6149         storage = None
6150         threadLocal = None
6151         inline = None
6152         virtual = None
6153         explicitSpec = None
6154         consteval = None
6155         constexpr = None
6156         constinit = None
6157         volatile = None
6158         const = None
6159         friend = None
6160         attrs = []
6161         while 1:  # accept any permutation of a subset of some decl-specs
6162             self.skip_ws()
6163             if not const and typed:
6164                 const = self.skip_word('const')
6165                 if const:
6166                     continue
6167             if not volatile and typed:
6168                 volatile = self.skip_word('volatile')
6169                 if volatile:
6170                     continue
6171             if not storage:
6172                 if outer in ('member', 'function'):
6173                     if self.skip_word('static'):
6174                         storage = 'static'
6175                         continue
6176                     if self.skip_word('extern'):
6177                         storage = 'extern'
6178                         continue
6179                 if outer == 'member':
6180                     if self.skip_word('mutable'):
6181                         storage = 'mutable'
6182                         continue
6183                 if self.skip_word('register'):
6184                     storage = 'register'
6185                     continue
6186             if not inline and outer in ('function', 'member'):
6187                 inline = self.skip_word('inline')
6188                 if inline:
6189                     continue
6190             if not constexpr and outer in ('member', 'function'):
6191                 constexpr = self.skip_word("constexpr")
6192                 if constexpr:
6193                     continue
6194 
6195             if outer == 'member':
6196                 if not constinit:
6197                     constinit = self.skip_word('constinit')
6198                     if constinit:
6199                         continue
6200                 if not threadLocal:
6201                     threadLocal = self.skip_word('thread_local')
6202                     if threadLocal:
6203                         continue
6204             if outer == 'function':
6205                 if not consteval:
6206                     consteval = self.skip_word('consteval')
6207                     if consteval:
6208                         continue
6209                 if not friend:
6210                     friend = self.skip_word('friend')
6211                     if friend:
6212                         continue
6213                 if not virtual:
6214                     virtual = self.skip_word('virtual')
6215                     if virtual:
6216                         continue
6217                 if not explicitSpec:
6218                     explicit = self.skip_word_and_ws('explicit')
6219                     if explicit:
6220                         expr: ASTExpression = None
6221                         if self.skip_string('('):
6222                             expr = self._parse_constant_expression(inTemplate=False)
6223                             if not expr:
6224                                 self.fail("Expected constant expression after '('" +
6225                                           " in explicit specifier.")
6226                             self.skip_ws()
6227                             if not self.skip_string(')'):
6228                                 self.fail("Expected ')' to end explicit specifier.")
6229                         explicitSpec = ASTExplicitSpec(expr)
6230                         continue
6231             attr = self._parse_attribute()
6232             if attr:
6233                 attrs.append(attr)
6234                 continue
6235             break
6236         return ASTDeclSpecsSimple(storage, threadLocal, inline, virtual,
6237                                   explicitSpec, consteval, constexpr, constinit,
6238                                   volatile, const, friend, attrs)
6239 
6240     def _parse_decl_specs(self, outer: str, typed: bool = True) -> ASTDeclSpecs:
6241         if outer:
6242             if outer not in ('type', 'member', 'function', 'templateParam'):
6243                 raise Exception('Internal error, unknown outer "%s".' % outer)
6244         """
6245         storage-class-specifier function-specifier "constexpr"
6246         "volatile" "const" trailing-type-specifier
6247 
6248         storage-class-specifier ->
6249               "static" (only for member_object and function_object)
6250             | "register"
6251 
6252         function-specifier -> "inline" | "virtual" | "explicit" (only for
6253         function_object)
6254 
6255         "constexpr" (only for member_object and function_object)
6256         """
6257         leftSpecs = self._parse_decl_specs_simple(outer, typed)
6258         rightSpecs = None
6259 
6260         if typed:
6261             trailing = self._parse_trailing_type_spec()
6262             rightSpecs = self._parse_decl_specs_simple(outer, typed)
6263         else:
6264             trailing = None
6265         return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)
6266 
6267     def _parse_declarator_name_suffix(
6268         self, named: Union[bool, str], paramMode: str, typed: bool
6269     ) -> Union[ASTDeclaratorNameParamQual, ASTDeclaratorNameBitField]:
6270         # now we should parse the name, and then suffixes
6271         if named == 'maybe':
6272             pos = self.pos
6273             try:
6274                 declId = self._parse_nested_name()
6275             except DefinitionError:
6276                 self.pos = pos
6277                 declId = None
6278         elif named == 'single':
6279             if self.match(identifier_re):
6280                 identifier = ASTIdentifier(self.matched_text)
6281                 nne = ASTNestedNameElement(identifier, None)
6282                 declId = ASTNestedName([nne], [False], rooted=False)
6283                 # if it's a member pointer, we may have '::', which should be an error
6284                 self.skip_ws()
6285                 if self.current_char == ':':
6286                     self.fail("Unexpected ':' after identifier.")
6287             else:
6288                 declId = None
6289         elif named:
6290             declId = self._parse_nested_name()
6291         else:
6292             declId = None
6293         arrayOps = []
6294         while 1:
6295             self.skip_ws()
6296             if typed and self.skip_string('['):
6297                 self.skip_ws()
6298                 if self.skip_string(']'):
6299                     arrayOps.append(ASTArray(None))
6300                     continue
6301 
6302                 def parser() -> ASTExpression:
6303                     return self._parse_expression()
6304                 value = self._parse_expression_fallback([']'], parser)
6305                 if not self.skip_string(']'):
6306                     self.fail("Expected ']' in end of array operator.")
6307                 arrayOps.append(ASTArray(value))
6308                 continue
6309             else:
6310                 break
6311         paramQual = self._parse_parameters_and_qualifiers(paramMode)
6312         if paramQual is None and len(arrayOps) == 0:
6313             # perhaps a bit-field
6314             if named and paramMode == 'type' and typed:
6315                 self.skip_ws()
6316                 if self.skip_string(':'):
6317                     size = self._parse_constant_expression(inTemplate=False)
6318                     return ASTDeclaratorNameBitField(declId=declId, size=size)
6319         return ASTDeclaratorNameParamQual(declId=declId, arrayOps=arrayOps,
6320                                           paramQual=paramQual)
6321 
6322     def _parse_declarator(self, named: Union[bool, str], paramMode: str,
6323                           typed: bool = True
6324                           ) -> ASTDeclarator:
6325         # 'typed' here means 'parse return type stuff'
6326         if paramMode not in ('type', 'function', 'operatorCast', 'new'):
6327             raise Exception(
6328                 "Internal error, unknown paramMode '%s'." % paramMode)
6329         prevErrors = []
6330         self.skip_ws()
6331         if typed and self.skip_string('*'):
6332             self.skip_ws()
6333             volatile = False
6334             const = False
6335             attrs = []
6336             while 1:
6337                 if not volatile:
6338                     volatile = self.skip_word_and_ws('volatile')
6339                     if volatile:
6340                         continue
6341                 if not const:
6342                     const = self.skip_word_and_ws('const')
6343                     if const:
6344                         continue
6345                 attr = self._parse_attribute()
6346                 if attr is not None:
6347                     attrs.append(attr)
6348                     continue
6349                 break
6350             next = self._parse_declarator(named, paramMode, typed)
6351             return ASTDeclaratorPtr(next=next, volatile=volatile, const=const, attrs=attrs)
6352         # TODO: shouldn't we parse an R-value ref here first?
6353         if typed and self.skip_string("&"):
6354             attrs = []
6355             while 1:
6356                 attr = self._parse_attribute()
6357                 if attr is None:
6358                     break
6359                 attrs.append(attr)
6360             next = self._parse_declarator(named, paramMode, typed)
6361             return ASTDeclaratorRef(next=next, attrs=attrs)
6362         if typed and self.skip_string("..."):
6363             next = self._parse_declarator(named, paramMode, False)
6364             return ASTDeclaratorParamPack(next=next)
6365         if typed and self.current_char == '(':  # note: peeking, not skipping
6366             if paramMode == "operatorCast":
6367                 # TODO: we should be able to parse cast operators which return
6368                 # function pointers. For now, just hax it and ignore.
6369                 return ASTDeclaratorNameParamQual(declId=None, arrayOps=[],
6370                                                   paramQual=None)
6371             # maybe this is the beginning of params and quals,try that first,
6372             # otherwise assume it's noptr->declarator > ( ptr-declarator )
6373             pos = self.pos
6374             try:
6375                 # assume this is params and quals
6376                 res = self._parse_declarator_name_suffix(named, paramMode,
6377                                                          typed)
6378                 return res
6379             except DefinitionError as exParamQual:
6380                 prevErrors.append((exParamQual,
6381                                    "If declarator-id with parameters-and-qualifiers"))
6382                 self.pos = pos
6383                 try:
6384                     assert self.current_char == '('
6385                     self.skip_string('(')
6386                     # TODO: hmm, if there is a name, it must be in inner, right?
6387                     # TODO: hmm, if there must be parameters, they must be
6388                     #       inside, right?
6389                     inner = self._parse_declarator(named, paramMode, typed)
6390                     if not self.skip_string(')'):
6391                         self.fail("Expected ')' in \"( ptr-declarator )\"")
6392                     next = self._parse_declarator(named=False,
6393                                                   paramMode="type",
6394                                                   typed=typed)
6395                     return ASTDeclaratorParen(inner=inner, next=next)
6396                 except DefinitionError as exNoPtrParen:
6397                     self.pos = pos
6398                     prevErrors.append((exNoPtrParen, "If parenthesis in noptr-declarator"))
6399                     header = "Error in declarator"
6400                     raise self._make_multi_error(prevErrors, header) from exNoPtrParen
6401         if typed:  # pointer to member
6402             pos = self.pos
6403             try:
6404                 name = self._parse_nested_name(memberPointer=True)
6405                 self.skip_ws()
6406                 if not self.skip_string('*'):
6407                     self.fail("Expected '*' in pointer to member declarator.")
6408                 self.skip_ws()
6409             except DefinitionError as e:
6410                 self.pos = pos
6411                 prevErrors.append((e, "If pointer to member declarator"))
6412             else:
6413                 volatile = False
6414                 const = False
6415                 while 1:
6416                     if not volatile:
6417                         volatile = self.skip_word_and_ws('volatile')
6418                         if volatile:
6419                             continue
6420                     if not const:
6421                         const = self.skip_word_and_ws('const')
6422                         if const:
6423                             continue
6424                     break
6425                 next = self._parse_declarator(named, paramMode, typed)
6426                 return ASTDeclaratorMemPtr(name, const, volatile, next=next)
6427         pos = self.pos
6428         try:
6429             res = self._parse_declarator_name_suffix(named, paramMode, typed)
6430             # this is a heuristic for error messages, for when there is a < after a
6431             # nested name, but it was not a successful template argument list
6432             if self.current_char == '<':
6433                 self.otherErrors.append(self._make_multi_error(prevErrors, ""))
6434             return res
6435         except DefinitionError as e:
6436             self.pos = pos
6437             prevErrors.append((e, "If declarator-id"))
6438             header = "Error in declarator or parameters-and-qualifiers"
6439             raise self._make_multi_error(prevErrors, header) from e
6440 
6441     def _parse_initializer(self, outer: str = None, allowFallback: bool = True
6442                            ) -> ASTInitializer:
6443         # initializer                           # global vars
6444         # -> brace-or-equal-initializer
6445         #  | '(' expression-list ')'
6446         #
6447         # brace-or-equal-initializer            # member vars
6448         # -> '=' initializer-clause
6449         #  | braced-init-list
6450         #
6451         # initializer-clause  # function params, non-type template params (with '=' in front)
6452         # -> assignment-expression
6453         #  | braced-init-list
6454         #
6455         # we don't distinguish between global and member vars, so disallow paren:
6456         #
6457         # -> braced-init-list             # var only
6458         #  | '=' assignment-expression
6459         #  | '=' braced-init-list
6460         self.skip_ws()
6461         if outer == 'member':
6462             bracedInit = self._parse_braced_init_list()
6463             if bracedInit is not None:
6464                 return ASTInitializer(bracedInit, hasAssign=False)
6465 
6466         if not self.skip_string('='):
6467             return None
6468 
6469         bracedInit = self._parse_braced_init_list()
6470         if bracedInit is not None:
6471             return ASTInitializer(bracedInit)
6472 
6473         if outer == 'member':
6474             fallbackEnd: List[str] = []
6475         elif outer == 'templateParam':
6476             fallbackEnd = [',', '>']
6477         elif outer is None:  # function parameter
6478             fallbackEnd = [',', ')']
6479         else:
6480             self.fail("Internal error, initializer for outer '%s' not "
6481                       "implemented." % outer)
6482 
6483         inTemplate = outer == 'templateParam'
6484 
6485         def parser() -> ASTExpression:
6486             return self._parse_assignment_expression(inTemplate=inTemplate)
6487         value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)
6488         return ASTInitializer(value)
6489 
6490     def _parse_type(self, named: Union[bool, str], outer: str = None) -> ASTType:
6491         """
6492         named=False|'maybe'|True: 'maybe' is e.g., for function objects which
6493         doesn't need to name the arguments
6494 
6495         outer == operatorCast: annoying case, we should not take the params
6496         """
6497         if outer:  # always named
6498             if outer not in ('type', 'member', 'function',
6499                              'operatorCast', 'templateParam'):
6500                 raise Exception('Internal error, unknown outer "%s".' % outer)
6501             if outer != 'operatorCast':
6502                 assert named
6503         if outer in ('type', 'function'):
6504             # We allow type objects to just be a name.
6505             # Some functions don't have normal return types: constructors,
6506             # destructors, cast operators
6507             prevErrors = []
6508             startPos = self.pos
6509             # first try without the type
6510             try:
6511                 declSpecs = self._parse_decl_specs(outer=outer, typed=False)
6512                 decl = self._parse_declarator(named=True, paramMode=outer,
6513                                               typed=False)
6514                 self.assert_end(allowSemicolon=True)
6515             except DefinitionError as exUntyped:
6516                 if outer == 'type':
6517                     desc = "If just a name"
6518                 elif outer == 'function':
6519                     desc = "If the function has no return type"
6520                 else:
6521                     assert False
6522                 prevErrors.append((exUntyped, desc))
6523                 self.pos = startPos
6524                 try:
6525                     declSpecs = self._parse_decl_specs(outer=outer)
6526                     decl = self._parse_declarator(named=True, paramMode=outer)
6527                 except DefinitionError as exTyped:
6528                     self.pos = startPos
6529                     if outer == 'type':
6530                         desc = "If typedef-like declaration"
6531                     elif outer == 'function':
6532                         desc = "If the function has a return type"
6533                     else:
6534                         assert False
6535                     prevErrors.append((exTyped, desc))
6536                     # Retain the else branch for easier debugging.
6537                     # TODO: it would be nice to save the previous stacktrace
6538                     #       and output it here.
6539                     if True:
6540                         if outer == 'type':
6541                             header = "Type must be either just a name or a "
6542                             header += "typedef-like declaration."
6543                         elif outer == 'function':
6544                             header = "Error when parsing function declaration."
6545                         else:
6546                             assert False
6547                         raise self._make_multi_error(prevErrors, header) from exTyped
6548                     else:
6549                         # For testing purposes.
6550                         # do it again to get the proper traceback (how do you
6551                         # reliably save a traceback when an exception is
6552                         # constructed?)
6553                         self.pos = startPos
6554                         typed = True
6555                         declSpecs = self._parse_decl_specs(outer=outer, typed=typed)
6556                         decl = self._parse_declarator(named=True, paramMode=outer,
6557                                                       typed=typed)
6558         else:
6559             paramMode = 'type'
6560             if outer == 'member':
6561                 named = True
6562             elif outer == 'operatorCast':
6563                 paramMode = 'operatorCast'
6564                 outer = None
6565             elif outer == 'templateParam':
6566                 named = 'single'
6567             declSpecs = self._parse_decl_specs(outer=outer)
6568             decl = self._parse_declarator(named=named, paramMode=paramMode)
6569         return ASTType(declSpecs, decl)
6570 
6571     def _parse_type_with_init(
6572             self, named: Union[bool, str],
6573             outer: str) -> Union[ASTTypeWithInit, ASTTemplateParamConstrainedTypeWithInit]:
6574         if outer:
6575             assert outer in ('type', 'member', 'function', 'templateParam')
6576         type = self._parse_type(outer=outer, named=named)
6577         if outer != 'templateParam':
6578             init = self._parse_initializer(outer=outer)
6579             return ASTTypeWithInit(type, init)
6580         # it could also be a constrained type parameter, e.g., C T = int&
6581         pos = self.pos
6582         eExpr = None
6583         try:
6584             init = self._parse_initializer(outer=outer, allowFallback=False)
6585             # note: init may be None if there is no =
6586             if init is None:
6587                 return ASTTypeWithInit(type, None)
6588             # we parsed an expression, so we must have a , or a >,
6589             # otherwise the expression didn't get everything
6590             self.skip_ws()
6591             if self.current_char != ',' and self.current_char != '>':
6592                 # pretend it didn't happen
6593                 self.pos = pos
6594                 init = None
6595             else:
6596                 # we assume that it was indeed an expression
6597                 return ASTTypeWithInit(type, init)
6598         except DefinitionError as e:
6599             self.pos = pos
6600             eExpr = e
6601         if not self.skip_string("="):
6602             return ASTTypeWithInit(type, None)
6603         try:
6604             typeInit = self._parse_type(named=False, outer=None)
6605             return ASTTemplateParamConstrainedTypeWithInit(type, typeInit)
6606         except DefinitionError as eType:
6607             if eExpr is None:
6608                 raise eType
6609             errs = []
6610             errs.append((eExpr, "If default template argument is an expression"))
6611             errs.append((eType, "If default template argument is a type"))
6612             msg = "Error in non-type template parameter"
6613             msg += " or constrained template parameter."
6614             raise self._make_multi_error(errs, msg) from eType
6615 
6616     def _parse_type_using(self) -> ASTTypeUsing:
6617         name = self._parse_nested_name()
6618         self.skip_ws()
6619         if not self.skip_string('='):
6620             return ASTTypeUsing(name, None)
6621         type = self._parse_type(False, None)
6622         return ASTTypeUsing(name, type)
6623 
6624     def _parse_concept(self) -> ASTConcept:
6625         nestedName = self._parse_nested_name()
6626         self.skip_ws()
6627         initializer = self._parse_initializer('member')
6628         return ASTConcept(nestedName, initializer)
6629 
6630     def _parse_class(self) -> ASTClass:
6631         attrs = []
6632         while 1:
6633             attr = self._parse_attribute()
6634             if attr is None:
6635                 break
6636             attrs.append(attr)
6637         name = self._parse_nested_name()
6638         self.skip_ws()
6639         final = self.skip_word_and_ws('final')
6640         bases = []
6641         self.skip_ws()
6642         if self.skip_string(':'):
6643             while 1:
6644                 self.skip_ws()
6645                 visibility = None
6646                 virtual = False
6647                 pack = False
6648                 if self.skip_word_and_ws('virtual'):
6649                     virtual = True
6650                 if self.match(_visibility_re):
6651                     visibility = self.matched_text
6652                     self.skip_ws()
6653                 if not virtual and self.skip_word_and_ws('virtual'):
6654                     virtual = True
6655                 baseName = self._parse_nested_name()
6656                 self.skip_ws()
6657                 pack = self.skip_string('...')
6658                 bases.append(ASTBaseClass(baseName, visibility, virtual, pack))
6659                 self.skip_ws()
6660                 if self.skip_string(','):
6661                     continue
6662                 else:
6663                     break
6664         return ASTClass(name, final, bases, attrs)
6665 
6666     def _parse_union(self) -> ASTUnion:
6667         attrs = []
6668         while 1:
6669             attr = self._parse_attribute()
6670             if attr is None:
6671                 break
6672             attrs.append(attr)
6673         name = self._parse_nested_name()
6674         return ASTUnion(name, attrs)
6675 
6676     def _parse_enum(self) -> ASTEnum:
6677         scoped = None  # is set by CPPEnumObject
6678         attrs = []
6679         while 1:
6680             attr = self._parse_attribute()
6681             if attr is None:
6682                 break
6683             attrs.append(attr)
6684         self.skip_ws()
6685         name = self._parse_nested_name()
6686         self.skip_ws()
6687         underlyingType = None
6688         if self.skip_string(':'):
6689             underlyingType = self._parse_type(named=False)
6690         return ASTEnum(name, scoped, underlyingType, attrs)
6691 
6692     def _parse_enumerator(self) -> ASTEnumerator:
6693         name = self._parse_nested_name()
6694         self.skip_ws()
6695         init = None
6696         if self.skip_string('='):
6697             self.skip_ws()
6698 
6699             def parser() -> ASTExpression:
6700                 return self._parse_constant_expression(inTemplate=False)
6701             initVal = self._parse_expression_fallback([], parser)
6702             init = ASTInitializer(initVal)
6703         return ASTEnumerator(name, init)
6704 
6705     # ==========================================================================
6706 
6707     def _parse_template_parameter(self) -> ASTTemplateParam:
6708         self.skip_ws()
6709         if self.skip_word('template'):
6710             # declare a tenplate template parameter
6711             nestedParams = self._parse_template_parameter_list()
6712         else:
6713             nestedParams = None
6714 
6715         pos = self.pos
6716         try:
6717             # Unconstrained type parameter or template type parameter
6718             key = None
6719             self.skip_ws()
6720             if self.skip_word_and_ws('typename'):
6721                 key = 'typename'
6722             elif self.skip_word_and_ws('class'):
6723                 key = 'class'
6724             elif nestedParams:
6725                 self.fail("Expected 'typename' or 'class' after "
6726                           "template template parameter list.")
6727             else:
6728                 self.fail("Expected 'typename' or 'class' in the "
6729                           "beginning of template type parameter.")
6730             self.skip_ws()
6731             parameterPack = self.skip_string('...')
6732             self.skip_ws()
6733             if self.match(identifier_re):
6734                 identifier = ASTIdentifier(self.matched_text)
6735             else:
6736                 identifier = None
6737             self.skip_ws()
6738             if not parameterPack and self.skip_string('='):
6739                 default = self._parse_type(named=False, outer=None)
6740             else:
6741                 default = None
6742                 if self.current_char not in ',>':
6743                     self.fail('Expected "," or ">" after (template) type parameter.')
6744             data = ASTTemplateKeyParamPackIdDefault(key, identifier,
6745                                                     parameterPack, default)
6746             if nestedParams:
6747                 return ASTTemplateParamTemplateType(nestedParams, data)
6748             else:
6749                 return ASTTemplateParamType(data)
6750         except DefinitionError as eType:
6751             if nestedParams:
6752                 raise
6753             try:
6754                 # non-type parameter or constrained type parameter
6755                 self.pos = pos
6756                 param = self._parse_type_with_init('maybe', 'templateParam')
6757                 return ASTTemplateParamNonType(param)
6758             except DefinitionError as eNonType:
6759                 self.pos = pos
6760                 header = "Error when parsing template parameter."
6761                 errs = []
6762                 errs.append(
6763                     (eType, "If unconstrained type parameter or template type parameter"))
6764                 errs.append(
6765                     (eNonType, "If constrained type parameter or non-type parameter"))
6766                 raise self._make_multi_error(errs, header)
6767 
6768     def _parse_template_parameter_list(self) -> ASTTemplateParams:
6769         # only: '<' parameter-list '>'
6770         # we assume that 'template' has just been parsed
6771         templateParams: List[ASTTemplateParam] = []
6772         self.skip_ws()
6773         if not self.skip_string("<"):
6774             self.fail("Expected '<' after 'template'")
6775         while 1:
6776             pos = self.pos
6777             err = None
6778             try:
6779                 param = self._parse_template_parameter()
6780                 templateParams.append(param)
6781             except DefinitionError as eParam:
6782                 self.pos = pos
6783                 err = eParam
6784             self.skip_ws()
6785             if self.skip_string('>'):
6786                 return ASTTemplateParams(templateParams)
6787             elif self.skip_string(','):
6788                 continue
6789             else:
6790                 header = "Error in template parameter list."
6791                 errs = []
6792                 if err:
6793                     errs.append((err, "If parameter"))
6794                 try:
6795                     self.fail('Expected "," or ">".')
6796                 except DefinitionError as e:
6797                     errs.append((e, "If no parameter"))
6798                 print(errs)
6799                 raise self._make_multi_error(errs, header)
6800 
6801     def _parse_template_introduction(self) -> ASTTemplateIntroduction:
6802         pos = self.pos
6803         try:
6804             concept = self._parse_nested_name()
6805         except Exception:
6806             self.pos = pos
6807             return None
6808         self.skip_ws()
6809         if not self.skip_string('{'):
6810             self.pos = pos
6811             return None
6812 
6813         # for sure it must be a template introduction now
6814         params = []
6815         while 1:
6816             self.skip_ws()
6817             parameterPack = self.skip_string('...')
6818             self.skip_ws()
6819             if not self.match(identifier_re):
6820                 self.fail("Expected identifier in template introduction list.")
6821             txt_identifier = self.matched_text
6822             # make sure there isn't a keyword
6823             if txt_identifier in _keywords:
6824                 self.fail("Expected identifier in template introduction list, "
6825                           "got keyword: %s" % txt_identifier)
6826             identifier = ASTIdentifier(txt_identifier)
6827             params.append(ASTTemplateIntroductionParameter(identifier, parameterPack))
6828 
6829             self.skip_ws()
6830             if self.skip_string('}'):
6831                 break
6832             elif self.skip_string(','):
6833                 continue
6834             else:
6835                 self.fail("Error in template introduction list. "
6836                           'Expected ",", or "}".')
6837         return ASTTemplateIntroduction(concept, params)
6838 
6839     def _parse_requires_clause(self) -> Optional[ASTRequiresClause]:
6840         # requires-clause -> 'requires' constraint-logical-or-expression
6841         # constraint-logical-or-expression
6842         #   -> constraint-logical-and-expression
6843         #    | constraint-logical-or-expression '||' constraint-logical-and-expression
6844         # constraint-logical-and-expression
6845         #   -> primary-expression
6846         #    | constraint-logical-and-expression '&&' primary-expression
6847         self.skip_ws()
6848         if not self.skip_word('requires'):
6849             return None
6850 
6851         def parse_and_expr(self: DefinitionParser) -> ASTExpression:
6852             andExprs = []
6853             ops = []
6854             andExprs.append(self._parse_primary_expression())
6855             while True:
6856                 self.skip_ws()
6857                 oneMore = False
6858                 if self.skip_string('&&'):
6859                     oneMore = True
6860                     ops.append('&&')
6861                 elif self.skip_word('and'):
6862                     oneMore = True
6863                     ops.append('and')
6864                 if not oneMore:
6865                     break
6866                 andExprs.append(self._parse_primary_expression())
6867             if len(andExprs) == 1:
6868                 return andExprs[0]
6869             else:
6870                 return ASTBinOpExpr(andExprs, ops)
6871 
6872         orExprs = []
6873         ops = []
6874         orExprs.append(parse_and_expr(self))
6875         while True:
6876             self.skip_ws()
6877             oneMore = False
6878             if self.skip_string('||'):
6879                 oneMore = True
6880                 ops.append('||')
6881             elif self.skip_word('or'):
6882                 oneMore = True
6883                 ops.append('or')
6884             if not oneMore:
6885                 break
6886             orExprs.append(parse_and_expr(self))
6887         if len(orExprs) == 1:
6888             return ASTRequiresClause(orExprs[0])
6889         else:
6890             return ASTRequiresClause(ASTBinOpExpr(orExprs, ops))
6891 
6892     def _parse_template_declaration_prefix(self, objectType: str
6893                                            ) -> Optional[ASTTemplateDeclarationPrefix]:
6894         templates: List[Union[ASTTemplateParams, ASTTemplateIntroduction]] = []
6895         while 1:
6896             self.skip_ws()
6897             # the saved position is only used to provide a better error message
6898             params: Union[ASTTemplateParams, ASTTemplateIntroduction] = None
6899             pos = self.pos
6900             if self.skip_word("template"):
6901                 try:
6902                     params = self._parse_template_parameter_list()
6903                 except DefinitionError as e:
6904                     if objectType == 'member' and len(templates) == 0:
6905                         return ASTTemplateDeclarationPrefix(None)
6906                     else:
6907                         raise e
6908             else:
6909                 params = self._parse_template_introduction()
6910                 if not params:
6911                     break
6912             if objectType == 'concept' and len(templates) > 0:
6913                 self.pos = pos
6914                 self.fail("More than 1 template parameter list for concept.")
6915             templates.append(params)
6916         if len(templates) == 0 and objectType == 'concept':
6917             self.fail('Missing template parameter list for concept.')
6918         if len(templates) == 0:
6919             return None
6920         else:
6921             return ASTTemplateDeclarationPrefix(templates)
6922 
6923     def _check_template_consistency(self, nestedName: ASTNestedName,
6924                                     templatePrefix: ASTTemplateDeclarationPrefix,
6925                                     fullSpecShorthand: bool, isMember: bool = False
6926                                     ) -> ASTTemplateDeclarationPrefix:
6927         numArgs = nestedName.num_templates()
6928         isMemberInstantiation = False
6929         if not templatePrefix:
6930             numParams = 0
6931         else:
6932             if isMember and templatePrefix.templates is None:
6933                 numParams = 0
6934                 isMemberInstantiation = True
6935             else:
6936                 numParams = len(templatePrefix.templates)
6937         if numArgs + 1 < numParams:
6938             self.fail("Too few template argument lists comapred to parameter"
6939                       " lists. Argument lists: %d, Parameter lists: %d."
6940                       % (numArgs, numParams))
6941         if numArgs > numParams:
6942             numExtra = numArgs - numParams
6943             if not fullSpecShorthand and not isMemberInstantiation:
6944                 msg = "Too many template argument lists compared to parameter" \
6945                     " lists. Argument lists: %d, Parameter lists: %d," \
6946                     " Extra empty parameters lists prepended: %d." \
6947                     % (numArgs, numParams, numExtra)
6948                 msg += " Declaration:\n\t"
6949                 if templatePrefix:
6950                     msg += "%s\n\t" % templatePrefix
6951                 msg += str(nestedName)
6952                 self.warn(msg)
6953 
6954             newTemplates: List[Union[ASTTemplateParams, ASTTemplateIntroduction]] = []
6955             for _i in range(numExtra):
6956                 newTemplates.append(ASTTemplateParams([]))
6957             if templatePrefix and not isMemberInstantiation:
6958                 newTemplates.extend(templatePrefix.templates)
6959             templatePrefix = ASTTemplateDeclarationPrefix(newTemplates)
6960         return templatePrefix
6961 
6962     def parse_declaration(self, objectType: str, directiveType: str) -> ASTDeclaration:
6963         if objectType not in ('class', 'union', 'function', 'member', 'type',
6964                               'concept', 'enum', 'enumerator'):
6965             raise Exception('Internal error, unknown objectType "%s".' % objectType)
6966         if directiveType not in ('class', 'struct', 'union', 'function', 'member', 'var',
6967                                  'type', 'concept',
6968                                  'enum', 'enum-struct', 'enum-class', 'enumerator'):
6969             raise Exception('Internal error, unknown directiveType "%s".' % directiveType)
6970         visibility = None
6971         templatePrefix = None
6972         requiresClause = None
6973         trailingRequiresClause = None
6974         declaration: Any = None
6975 
6976         self.skip_ws()
6977         if self.match(_visibility_re):
6978             visibility = self.matched_text
6979 
6980         if objectType in ('type', 'concept', 'member', 'function', 'class'):
6981             templatePrefix = self._parse_template_declaration_prefix(objectType)
6982             if objectType == 'function' and templatePrefix is not None:
6983                 requiresClause = self._parse_requires_clause()
6984 
6985         if objectType == 'type':
6986             prevErrors = []
6987             pos = self.pos
6988             try:
6989                 if not templatePrefix:
6990                     declaration = self._parse_type(named=True, outer='type')
6991             except DefinitionError as e:
6992                 prevErrors.append((e, "If typedef-like declaration"))
6993                 self.pos = pos
6994             pos = self.pos
6995             try:
6996                 if not declaration:
6997                     declaration = self._parse_type_using()
6998             except DefinitionError as e:
6999                 self.pos = pos
7000                 prevErrors.append((e, "If type alias or template alias"))
7001                 header = "Error in type declaration."
7002                 raise self._make_multi_error(prevErrors, header) from e
7003         elif objectType == 'concept':
7004             declaration = self._parse_concept()
7005         elif objectType == 'member':
7006             declaration = self._parse_type_with_init(named=True, outer='member')
7007         elif objectType == 'function':
7008             declaration = self._parse_type(named=True, outer='function')
7009             if templatePrefix is not None:
7010                 trailingRequiresClause = self._parse_requires_clause()
7011         elif objectType == 'class':
7012             declaration = self._parse_class()
7013         elif objectType == 'union':
7014             declaration = self._parse_union()
7015         elif objectType == 'enum':
7016             declaration = self._parse_enum()
7017         elif objectType == 'enumerator':
7018             declaration = self._parse_enumerator()
7019         else:
7020             assert False
7021         templatePrefix = self._check_template_consistency(declaration.name,
7022                                                           templatePrefix,
7023                                                           fullSpecShorthand=False,
7024                                                           isMember=objectType == 'member')
7025         self.skip_ws()
7026         semicolon = self.skip_string(';')
7027         return ASTDeclaration(objectType, directiveType, visibility,
7028                               templatePrefix, requiresClause, declaration,
7029                               trailingRequiresClause, semicolon)
7030 
7031     def parse_namespace_object(self) -> ASTNamespace:
7032         templatePrefix = self._parse_template_declaration_prefix(objectType="namespace")
7033         name = self._parse_nested_name()
7034         templatePrefix = self._check_template_consistency(name, templatePrefix,
7035                                                           fullSpecShorthand=False)
7036         res = ASTNamespace(name, templatePrefix)
7037         res.objectType = 'namespace'  # type: ignore
7038         return res
7039 
7040     def parse_xref_object(self) -> Tuple[Union[ASTNamespace, ASTDeclaration], bool]:
7041         pos = self.pos
7042         try:
7043             templatePrefix = self._parse_template_declaration_prefix(objectType="xref")
7044             name = self._parse_nested_name()
7045             # if there are '()' left, just skip them
7046             self.skip_ws()
7047             self.skip_string('()')
7048             self.assert_end()
7049             templatePrefix = self._check_template_consistency(name, templatePrefix,
7050                                                               fullSpecShorthand=True)
7051             res1 = ASTNamespace(name, templatePrefix)
7052             res1.objectType = 'xref'  # type: ignore
7053             return res1, True
7054         except DefinitionError as e1:
7055             try:
7056                 self.pos = pos
7057                 res2 = self.parse_declaration('function', 'function')
7058                 # if there are '()' left, just skip them
7059                 self.skip_ws()
7060                 self.skip_string('()')
7061                 self.assert_end()
7062                 return res2, False
7063             except DefinitionError as e2:
7064                 errs = []
7065                 errs.append((e1, "If shorthand ref"))
7066                 errs.append((e2, "If full function ref"))
7067                 msg = "Error in cross-reference."
7068                 raise self._make_multi_error(errs, msg) from e2
7069 
7070     def parse_expression(self) -> Union[ASTExpression, ASTType]:
7071         pos = self.pos
7072         try:
7073             expr = self._parse_expression()
7074             self.skip_ws()
7075             self.assert_end()
7076             return expr
7077         except DefinitionError as exExpr:
7078             self.pos = pos
7079             try:
7080                 typ = self._parse_type(False)
7081                 self.skip_ws()
7082                 self.assert_end()
7083                 return typ
7084             except DefinitionError as exType:
7085                 header = "Error when parsing (type) expression."
7086                 errs = []
7087                 errs.append((exExpr, "If expression"))
7088                 errs.append((exType, "If type"))
7089                 raise self._make_multi_error(errs, header) from exType

</code><intended_behavior>Similar to the C domain, the DefinitionParser class and the setup function in the C++ domain (cpp.py) should be adjusted to correctly handle cpp_id_attributes during enum parsing. This involves ensuring attributes tagged on enum values do not cause parsing issues or misnomers in the generated documentation. The correct approach would filter or properly recognize these attributes so that they do not lead to errors or misnamed enum values in the documentation output.</intended_behavior>]
2025-10-17 18:16:39.923 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 18:16:39.923 | INFO     | Search-only: skipping patch selection
2025-10-17 18:16:40.045 | INFO     | Task sphinx-doc__sphinx-10360 completed successfully.
2025-10-17 18:16:40.046 | INFO     | No patch generated. You can try running ACR again.
