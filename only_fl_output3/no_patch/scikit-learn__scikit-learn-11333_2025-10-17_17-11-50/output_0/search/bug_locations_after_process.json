[
    {
        "rel_file_path": "sklearn/utils/metaestimators.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.20/sklearn/utils/metaestimators.py",
        "start": 38,
        "end": 50,
        "class_name": "_BaseComposition",
        "method_name": "_set_params",
        "code": "38     def _set_params(self, attr, **params):\n39         # Ensure strict ordering of parameter setting:\n40         # 1. All steps\n41         if attr in params:\n42             setattr(self, attr, params.pop(attr))\n43         # 2. Step replacement\n44         names, _ = zip(*getattr(self, attr))\n45         for name in list(six.iterkeys(params)):\n46             if '__' not in name and name in names:\n47                 self._replace_estimator(attr, name, params.pop(name))\n48         # 3. Step parameters and other initialisation arguments\n49         super(_BaseComposition, self).set_params(**params)\n50         return self\n",
        "intended_behavior": "The `_set_params` method needs to be modified to gracefully handle the case when there are no transformers (or estimators) in a composition like `ColumnTransformer`. When `getattr(self, attr)` returns an empty collection (indicating no transformers are present), the method should not attempt to unpack `names, _` from it, thus avoiding the `ValueError: not enough values to unpack (expected 2, got 0)`. Instead, it should check whether the collection is empty and, if so, skip to directly setting any additional provided parameters without attempting to replace or update any transformers. This change preserves the method's existing functionality of setting and updating parameters while also supporting compositions with no initial transformers."
    },
    {
        "rel_file_path": "sklearn/utils/metaestimators.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__0.20/sklearn/utils/metaestimators.py",
        "start": 18,
        "end": 72,
        "class_name": "_BaseComposition",
        "method_name": null,
        "code": "18 class _BaseComposition(six.with_metaclass(ABCMeta, BaseEstimator)):\n19     \"\"\"Handles parameter management for classifiers composed of named estimators.\n20     \"\"\"\n21     @abstractmethod\n22     def __init__(self):\n23         pass\n24 \n25     def _get_params(self, attr, deep=True):\n26         out = super(_BaseComposition, self).get_params(deep=deep)\n27         if not deep:\n28             return out\n29         estimators = getattr(self, attr)\n30         out.update(estimators)\n31         for name, estimator in estimators:\n32             if hasattr(estimator, 'get_params'):\n33                 for key, value in six.iteritems(\n34                         estimator.get_params(deep=True)):\n35                     out['%s__%s' % (name, key)] = value\n36         return out\n37 \n38     def _set_params(self, attr, **params):\n39         # Ensure strict ordering of parameter setting:\n40         # 1. All steps\n41         if attr in params:\n42             setattr(self, attr, params.pop(attr))\n43         # 2. Step replacement\n44         names, _ = zip(*getattr(self, attr))\n45         for name in list(six.iterkeys(params)):\n46             if '__' not in name and name in names:\n47                 self._replace_estimator(attr, name, params.pop(name))\n48         # 3. Step parameters and other initialisation arguments\n49         super(_BaseComposition, self).set_params(**params)\n50         return self\n51 \n52     def _replace_estimator(self, attr, name, new_val):\n53         # assumes `name` is a valid estimator name\n54         new_estimators = list(getattr(self, attr))\n55         for i, (estimator_name, _) in enumerate(new_estimators):\n56             if estimator_name == name:\n57                 new_estimators[i] = (name, new_val)\n58                 break\n59         setattr(self, attr, new_estimators)\n60 \n61     def _validate_names(self, names):\n62         if len(set(names)) != len(names):\n63             raise ValueError('Names provided are not unique: '\n64                              '{0!r}'.format(list(names)))\n65         invalid_names = set(names).intersection(self.get_params(deep=False))\n66         if invalid_names:\n67             raise ValueError('Estimator names conflict with constructor '\n68                              'arguments: {0!r}'.format(sorted(invalid_names)))\n69         invalid_names = [name for name in names if '__' in name]\n70         if invalid_names:\n71             raise ValueError('Estimator names must not contain __: got '\n72                              '{0!r}'.format(invalid_names))\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]