[
    {
        "rel_file_path": "seaborn/relational.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/relational.py",
        "start": 570,
        "end": 613,
        "class_name": null,
        "method_name": "lineplot",
        "code": "570 def lineplot(\n571     data=None, *,\n572     x=None, y=None, hue=None, size=None, style=None, units=None,\n573     palette=None, hue_order=None, hue_norm=None,\n574     sizes=None, size_order=None, size_norm=None,\n575     dashes=True, markers=None, style_order=None,\n576     estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,\n577     orient=\"x\", sort=True, err_style=\"band\", err_kws=None,\n578     legend=\"auto\", ci=\"deprecated\", ax=None, **kwargs\n579 ):\n580 \n581     # Handle deprecation of ci parameter\n582     errorbar = _deprecate_ci(errorbar, ci)\n583 \n584     variables = _LinePlotter.get_semantics(locals())\n585     p = _LinePlotter(\n586         data=data, variables=variables,\n587         estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,\n588         sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,\n589         legend=legend,\n590     )\n591 \n592     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n593     p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n594     p.map_style(markers=markers, dashes=dashes, order=style_order)\n595 \n596     if ax is None:\n597         ax = plt.gca()\n598 \n599     if \"style\" not in p.variables and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX\n600         kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes\n601 \n602     if not p.has_xy_data:\n603         return ax\n604 \n605     p._attach(ax)\n606 \n607     # Other functions have color as an explicit param,\n608     # and we should probably do that here too\n609     color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n610     kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n611 \n612     p.plot(ax, kwargs)\n613     return ax\n",
        "intended_behavior": "The `lineplot` function should ensure consistent ordering of axes regardless of the presence of `pd.NA` or `np.nan` in the dataset. This may involve adjusting the sorting logic to handle `pd.NA` equivalently to `np.nan` or explicitly before plotting, ensuring that missing values do not influence the ordering of data points on the axis. A specific consideration should be given to how missing values are excluded or considered in the context of the `sort=True` default behavior, ensuring that axis order remains consistent with the input data order when missing values are present."
    },
    {
        "rel_file_path": "seaborn/regression.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/regression.py",
        "start": 56,
        "end": 64,
        "class_name": null,
        "method_name": "dropna",
        "code": "56     def dropna(self, *vars):\n57         \"\"\"Remove observations with missing data.\"\"\"\n58         vals = [getattr(self, var) for var in vars]\n59         vals = [v for v in vals if v is not None]\n60         not_na = np.all(np.column_stack([pd.notnull(v) for v in vals]), axis=1)\n61         for var in vars:\n62             val = getattr(self, var)\n63             if val is not None:\n64                 setattr(self, var, val[not_na])\n",
        "intended_behavior": "While `dropna` successfully filters out missing values, ensuring seamless data plotting, a revision might be necessary to confirm its handling of `pd.NA` does not inadvertently affect data processing in a way that could lead to axis inversion. The method should guarantee that the process of filtering out rows with missing values (`pd.NA` or `np.nan`) does not trigger any reordering or impact on the dataset that could lead to the observed issue. Although `dropna` might not be directly responsible for reversing axis order, ensuring its robustness in handling different missing value indicators is crucial for data integrity throughout the plotting process."
    },
    {
        "rel_file_path": "seaborn/regression.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/mwaskom__seaborn/setup_mwaskom__seaborn__0.13/seaborn/regression.py",
        "start": 56,
        "end": 64,
        "class_name": "_LinearPlotter",
        "method_name": "dropna",
        "code": "56     def dropna(self, *vars):\n57         \"\"\"Remove observations with missing data.\"\"\"\n58         vals = [getattr(self, var) for var in vars]\n59         vals = [v for v in vals if v is not None]\n60         not_na = np.all(np.column_stack([pd.notnull(v) for v in vals]), axis=1)\n61         for var in vars:\n62             val = getattr(self, var)\n63             if val is not None:\n64                 setattr(self, var, val[not_na])\n",
        "intended_behavior": "While `dropna` successfully filters out missing values, ensuring seamless data plotting, a revision might be necessary to confirm its handling of `pd.NA` does not inadvertently affect data processing in a way that could lead to axis inversion. The method should guarantee that the process of filtering out rows with missing values (`pd.NA` or `np.nan`) does not trigger any reordering or impact on the dataset that could lead to the observed issue. Although `dropna` might not be directly responsible for reversing axis order, ensuring its robustness in handling different missing value indicators is crucial for data integrity throughout the plotting process."
    }
]