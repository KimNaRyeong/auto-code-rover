[
    {
        "rel_file_path": "sympy/simplify/fu.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/simplify/fu.py",
        "start": 548,
        "end": 566,
        "class_name": null,
        "method_name": "TR6",
        "code": "548 def TR6(rv, max=4, pow=False):\n549     \"\"\"Replacement of cos**2 with 1 - sin(x)**2.\n550 \n551     See _TR56 docstring for advanced use of ``max`` and ``pow``.\n552 \n553     Examples\n554     ========\n555 \n556     >>> from sympy.simplify.fu import TR6\n557     >>> from sympy.abc import x\n558     >>> from sympy import cos\n559     >>> TR6(cos(x)**2)\n560     1 - sin(x)**2\n561     >>> TR6(cos(x)**-2)  #unchanged\n562     cos(x)**(-2)\n563     >>> TR6(cos(x)**4)\n564     (1 - sin(x)**2)**2\n565     \"\"\"\n566     return _TR56(rv, cos, sin, lambda x: 1 - x, max=max, pow=pow)\n",
        "intended_behavior": "The TR6 method should be modified to better handle cases where the exponent is a complex number. Specifically, it should check whether the exponent is complex and, if so, either apply a suitable simplification rule that is mathematically valid for complex exponents or skip the transformation if no such rule is appropriate. This would preserve the function's role in simplifying trigonometric expressions while preventing errors caused by invalid comparisons of complex numbers."
    },
    {
        "rel_file_path": "sympy/core/expr.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/core/expr.py",
        "start": 398,
        "end": 419,
        "class_name": "Expr",
        "method_name": "__lt__",
        "code": "398     def __lt__(self, other):\n399         from sympy import StrictLessThan\n400         try:\n401             other = _sympify(other)\n402         except SympifyError:\n403             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n404         for me in (self, other):\n405             if me.is_complex and me.is_extended_real is False:\n406                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n407             if me is S.NaN:\n408                 raise TypeError(\"Invalid NaN comparison\")\n409         n2 = _n2(self, other)\n410         if n2 is not None:\n411             return _sympify(n2 < 0)\n412         if self.is_extended_real and other.is_extended_real:\n413             if (self.is_infinite and self.is_extended_positive) \\\n414                     or (other.is_infinite and other.is_extended_negative):\n415                 return S.false\n416             neg = (self - other).is_extended_negative\n417             if neg is not None:\n418                 return sympify(neg)\n419         return StrictLessThan(self, other, evaluate=False)\n",
        "intended_behavior": "While the `__lt__` method itself correctly raises a TypeError on invalid comparisons involving complex numbers (as comparing complex numbers using less than/greater than is not mathematically valid), the context of its use indicates that there might be a need for upstream validation or handling before comparisons reach this point. Consequently, this suggests that upstream methods (like those involved in expression simplification or transformation, potentially `simplify` or `trigsimp`) may need enhancement to ensure they do not perform illegitimate comparisons on complex numbers. However, `__lt__` should remain unchanged as its behavior is correct; the change should rather be in how comparisons are formulated or performed in the simplification procedures, specifically ensuring that complex expressions are handled in a way to avoid direct comparison using `<` or `>` operations."
    },
    {
        "rel_file_path": "sympy/core/expr.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/core/expr.py",
        "start": 15,
        "end": 3653,
        "class_name": "Expr",
        "method_name": null,
        "code": "15 class Expr(Basic, EvalfMixin):\n16     \"\"\"\n17     Base class for algebraic expressions.\n18 \n19     Everything that requires arithmetic operations to be defined\n20     should subclass this class, instead of Basic (which should be\n21     used only for argument storage and expression manipulation, i.e.\n22     pattern matching, substitutions, etc).\n23 \n24     See Also\n25     ========\n26 \n27     sympy.core.basic.Basic\n28     \"\"\"\n29 \n30     __slots__ = []\n31 \n32     is_scalar = True  # self derivative is 1\n33 \n34     @property\n35     def _diff_wrt(self):\n36         \"\"\"Return True if one can differentiate with respect to this\n37         object, else False.\n38 \n39         Subclasses such as Symbol, Function and Derivative return True\n40         to enable derivatives wrt them. The implementation in Derivative\n41         separates the Symbol and non-Symbol (_diff_wrt=True) variables and\n42         temporarily converts the non-Symbols into Symbols when performing\n43         the differentiation. By default, any object deriving from Expr\n44         will behave like a scalar with self.diff(self) == 1. If this is\n45         not desired then the object must also set `is_scalar = False` or\n46         else define an _eval_derivative routine.\n47 \n48         Note, see the docstring of Derivative for how this should work\n49         mathematically. In particular, note that expr.subs(yourclass, Symbol)\n50         should be well-defined on a structural level, or this will lead to\n51         inconsistent results.\n52 \n53         Examples\n54         ========\n55 \n56         >>> from sympy import Expr\n57         >>> e = Expr()\n58         >>> e._diff_wrt\n59         False\n60         >>> class MyScalar(Expr):\n61         ...     _diff_wrt = True\n62         ...\n63         >>> MyScalar().diff(MyScalar())\n64         1\n65         >>> class MySymbol(Expr):\n66         ...     _diff_wrt = True\n67         ...     is_scalar = False\n68         ...\n69         >>> MySymbol().diff(MySymbol())\n70         Derivative(MySymbol(), MySymbol())\n71         \"\"\"\n72         return False\n73 \n74     @cacheit\n75     def sort_key(self, order=None):\n76 \n77         coeff, expr = self.as_coeff_Mul()\n78 \n79         if expr.is_Pow:\n80             expr, exp = expr.args\n81         else:\n82             expr, exp = expr, S.One\n83 \n84         if expr.is_Dummy:\n85             args = (expr.sort_key(),)\n86         elif expr.is_Atom:\n87             args = (str(expr),)\n88         else:\n89             if expr.is_Add:\n90                 args = expr.as_ordered_terms(order=order)\n91             elif expr.is_Mul:\n92                 args = expr.as_ordered_factors(order=order)\n93             else:\n94                 args = expr.args\n95 \n96             args = tuple(\n97                 [ default_sort_key(arg, order=order) for arg in args ])\n98 \n99         args = (len(args), tuple(args))\n100         exp = exp.sort_key(order=order)\n101 \n102         return expr.class_key(), args, exp, coeff\n103 \n104     def __hash__(self):\n105         # hash cannot be cached using cache_it because infinite recurrence\n106         # occurs as hash is needed for setting cache dictionary keys\n107         h = self._mhash\n108         if h is None:\n109             h = hash((type(self).__name__,) + self._hashable_content())\n110             self._mhash = h\n111         return h\n112 \n113     def _hashable_content(self):\n114         \"\"\"Return a tuple of information about self that can be used to\n115         compute the hash. If a class defines additional attributes,\n116         like ``name`` in Symbol, then this method should be updated\n117         accordingly to return such relevant attributes.\n118         Defining more than _hashable_content is necessary if __eq__ has\n119         been defined by a class. See note about this in Basic.__eq__.\"\"\"\n120         return self._args\n121 \n122     def __eq__(self, other):\n123         try:\n124             other = sympify(other)\n125             if not isinstance(other, Expr):\n126                 return False\n127         except (SympifyError, SyntaxError):\n128             return False\n129         # check for pure number expr\n130         if  not (self.is_Number and other.is_Number) and (\n131                 type(self) != type(other)):\n132             return False\n133         a, b = self._hashable_content(), other._hashable_content()\n134         if a != b:\n135             return False\n136         # check number *in* an expression\n137         for a, b in zip(a, b):\n138             if not isinstance(a, Expr):\n139                 continue\n140             if a.is_Number and type(a) != type(b):\n141                 return False\n142         return True\n143 \n144     # ***************\n145     # * Arithmetics *\n146     # ***************\n147     # Expr and its sublcasses use _op_priority to determine which object\n148     # passed to a binary special method (__mul__, etc.) will handle the\n149     # operation. In general, the 'call_highest_priority' decorator will choose\n150     # the object with the highest _op_priority to handle the call.\n151     # Custom subclasses that want to define their own binary special methods\n152     # should set an _op_priority value that is higher than the default.\n153     #\n154     # **NOTE**:\n155     # This is a temporary fix, and will eventually be replaced with\n156     # something better and more powerful.  See issue 5510.\n157     _op_priority = 10.0\n158 \n159     def __pos__(self):\n160         return self\n161 \n162     def __neg__(self):\n163         return Mul(S.NegativeOne, self)\n164 \n165     def __abs__(self):\n166         from sympy import Abs\n167         return Abs(self)\n168 \n169     @_sympifyit('other', NotImplemented)\n170     @call_highest_priority('__radd__')\n171     def __add__(self, other):\n172         return Add(self, other)\n173 \n174     @_sympifyit('other', NotImplemented)\n175     @call_highest_priority('__add__')\n176     def __radd__(self, other):\n177         return Add(other, self)\n178 \n179     @_sympifyit('other', NotImplemented)\n180     @call_highest_priority('__rsub__')\n181     def __sub__(self, other):\n182         return Add(self, -other)\n183 \n184     @_sympifyit('other', NotImplemented)\n185     @call_highest_priority('__sub__')\n186     def __rsub__(self, other):\n187         return Add(other, -self)\n188 \n189     @_sympifyit('other', NotImplemented)\n190     @call_highest_priority('__rmul__')\n191     def __mul__(self, other):\n192         return Mul(self, other)\n193 \n194     @_sympifyit('other', NotImplemented)\n195     @call_highest_priority('__mul__')\n196     def __rmul__(self, other):\n197         return Mul(other, self)\n198 \n199     @_sympifyit('other', NotImplemented)\n200     @call_highest_priority('__rpow__')\n201     def _pow(self, other):\n202         return Pow(self, other)\n203 \n204     def __pow__(self, other, mod=None):\n205         if mod is None:\n206             return self._pow(other)\n207         try:\n208             _self, other, mod = as_int(self), as_int(other), as_int(mod)\n209             if other >= 0:\n210                 return pow(_self, other, mod)\n211             else:\n212                 from sympy.core.numbers import mod_inverse\n213                 return mod_inverse(pow(_self, -other, mod), mod)\n214         except ValueError:\n215             power = self._pow(other)\n216             try:\n217                 return power%mod\n218             except TypeError:\n219                 return NotImplemented\n220 \n221     @_sympifyit('other', NotImplemented)\n222     @call_highest_priority('__pow__')\n223     def __rpow__(self, other):\n224         return Pow(other, self)\n225 \n226     @_sympifyit('other', NotImplemented)\n227     @call_highest_priority('__rdiv__')\n228     def __div__(self, other):\n229         return Mul(self, Pow(other, S.NegativeOne))\n230 \n231     @_sympifyit('other', NotImplemented)\n232     @call_highest_priority('__div__')\n233     def __rdiv__(self, other):\n234         return Mul(other, Pow(self, S.NegativeOne))\n235 \n236     __truediv__ = __div__\n237     __rtruediv__ = __rdiv__\n238 \n239     @_sympifyit('other', NotImplemented)\n240     @call_highest_priority('__rmod__')\n241     def __mod__(self, other):\n242         return Mod(self, other)\n243 \n244     @_sympifyit('other', NotImplemented)\n245     @call_highest_priority('__mod__')\n246     def __rmod__(self, other):\n247         return Mod(other, self)\n248 \n249     @_sympifyit('other', NotImplemented)\n250     @call_highest_priority('__rfloordiv__')\n251     def __floordiv__(self, other):\n252         from sympy.functions.elementary.integers import floor\n253         return floor(self / other)\n254 \n255     @_sympifyit('other', NotImplemented)\n256     @call_highest_priority('__floordiv__')\n257     def __rfloordiv__(self, other):\n258         from sympy.functions.elementary.integers import floor\n259         return floor(other / self)\n260 \n261 \n262     @_sympifyit('other', NotImplemented)\n263     @call_highest_priority('__rdivmod__')\n264     def __divmod__(self, other):\n265         from sympy.functions.elementary.integers import floor\n266         return floor(self / other), Mod(self, other)\n267 \n268     @_sympifyit('other', NotImplemented)\n269     @call_highest_priority('__divmod__')\n270     def __rdivmod__(self, other):\n271         from sympy.functions.elementary.integers import floor\n272         return floor(other / self), Mod(other, self)\n273 \n274     def __int__(self):\n275         # Although we only need to round to the units position, we'll\n276         # get one more digit so the extra testing below can be avoided\n277         # unless the rounded value rounded to an integer, e.g. if an\n278         # expression were equal to 1.9 and we rounded to the unit position\n279         # we would get a 2 and would not know if this rounded up or not\n280         # without doing a test (as done below). But if we keep an extra\n281         # digit we know that 1.9 is not the same as 1 and there is no\n282         # need for further testing: our int value is correct. If the value\n283         # were 1.99, however, this would round to 2.0 and our int value is\n284         # off by one. So...if our round value is the same as the int value\n285         # (regardless of how much extra work we do to calculate extra decimal\n286         # places) we need to test whether we are off by one.\n287         from sympy import Dummy\n288         if not self.is_number:\n289             raise TypeError(\"can't convert symbols to int\")\n290         r = self.round(2)\n291         if not r.is_Number:\n292             raise TypeError(\"can't convert complex to int\")\n293         if r in (S.NaN, S.Infinity, S.NegativeInfinity):\n294             raise TypeError(\"can't convert %s to int\" % r)\n295         i = int(r)\n296         if not i:\n297             return 0\n298         # off-by-one check\n299         if i == r and not (self - i).equals(0):\n300             isign = 1 if i > 0 else -1\n301             x = Dummy()\n302             # in the following (self - i).evalf(2) will not always work while\n303             # (self - r).evalf(2) and the use of subs does; if the test that\n304             # was added when this comment was added passes, it might be safe\n305             # to simply use sign to compute this rather than doing this by hand:\n306             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1\n307             if diff_sign != isign:\n308                 i -= isign\n309         return i\n310     __long__ = __int__\n311 \n312     def __float__(self):\n313         # Don't bother testing if it's a number; if it's not this is going\n314         # to fail, and if it is we still need to check that it evalf'ed to\n315         # a number.\n316         result = self.evalf()\n317         if result.is_Number:\n318             return float(result)\n319         if result.is_number and result.as_real_imag()[1]:\n320             raise TypeError(\"can't convert complex to float\")\n321         raise TypeError(\"can't convert expression to float\")\n322 \n323     def __complex__(self):\n324         result = self.evalf()\n325         re, im = result.as_real_imag()\n326         return complex(float(re), float(im))\n327 \n328     def __ge__(self, other):\n329         from sympy import GreaterThan\n330         try:\n331             other = _sympify(other)\n332         except SympifyError:\n333             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n334         for me in (self, other):\n335             if me.is_complex and me.is_extended_real is False:\n336                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n337             if me is S.NaN:\n338                 raise TypeError(\"Invalid NaN comparison\")\n339         n2 = _n2(self, other)\n340         if n2 is not None:\n341             return _sympify(n2 >= 0)\n342         if self.is_extended_real and other.is_extended_real:\n343             if (self.is_infinite and self.is_extended_positive) \\\n344                     or (other.is_infinite and other.is_extended_negative):\n345                 return S.true\n346             nneg = (self - other).is_extended_nonnegative\n347             if nneg is not None:\n348                 return sympify(nneg)\n349         return GreaterThan(self, other, evaluate=False)\n350 \n351     def __le__(self, other):\n352         from sympy import LessThan\n353         try:\n354             other = _sympify(other)\n355         except SympifyError:\n356             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n357         for me in (self, other):\n358             if me.is_complex and me.is_extended_real is False:\n359                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n360             if me is S.NaN:\n361                 raise TypeError(\"Invalid NaN comparison\")\n362         n2 = _n2(self, other)\n363         if n2 is not None:\n364             return _sympify(n2 <= 0)\n365         if self.is_extended_real and other.is_extended_real:\n366             if (self.is_infinite and self.is_extended_negative) \\\n367                     or (other.is_infinite and other.is_extended_positive):\n368                 return S.true\n369             npos = (self - other).is_extended_nonpositive\n370             if npos is not None:\n371                 return sympify(npos)\n372         return LessThan(self, other, evaluate=False)\n373 \n374     def __gt__(self, other):\n375         from sympy import StrictGreaterThan\n376         try:\n377             other = _sympify(other)\n378         except SympifyError:\n379             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n380         for me in (self, other):\n381             if me.is_complex and me.is_extended_real is False:\n382                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n383             if me is S.NaN:\n384                 raise TypeError(\"Invalid NaN comparison\")\n385         n2 = _n2(self, other)\n386         if n2 is not None:\n387             return _sympify(n2 > 0)\n388 \n389         if self.is_extended_real and other.is_extended_real:\n390             if (self.is_infinite and self.is_extended_negative) \\\n391                     or (other.is_infinite and other.is_extended_positive):\n392                 return S.false\n393             pos = (self - other).is_extended_positive\n394             if pos is not None:\n395                 return sympify(pos)\n396         return StrictGreaterThan(self, other, evaluate=False)\n397 \n398     def __lt__(self, other):\n399         from sympy import StrictLessThan\n400         try:\n401             other = _sympify(other)\n402         except SympifyError:\n403             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n404         for me in (self, other):\n405             if me.is_complex and me.is_extended_real is False:\n406                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n407             if me is S.NaN:\n408                 raise TypeError(\"Invalid NaN comparison\")\n409         n2 = _n2(self, other)\n410         if n2 is not None:\n411             return _sympify(n2 < 0)\n412         if self.is_extended_real and other.is_extended_real:\n413             if (self.is_infinite and self.is_extended_positive) \\\n414                     or (other.is_infinite and other.is_extended_negative):\n415                 return S.false\n416             neg = (self - other).is_extended_negative\n417             if neg is not None:\n418                 return sympify(neg)\n419         return StrictLessThan(self, other, evaluate=False)\n420 \n421     def __trunc__(self):\n422         if not self.is_number:\n423             raise TypeError(\"can't truncate symbols and expressions\")\n424         else:\n425             return Integer(self)\n426 \n427     @staticmethod\n428     def _from_mpmath(x, prec):\n429         from sympy import Float\n430         if hasattr(x, \"_mpf_\"):\n431             return Float._new(x._mpf_, prec)\n432         elif hasattr(x, \"_mpc_\"):\n433             re, im = x._mpc_\n434             re = Float._new(re, prec)\n435             im = Float._new(im, prec)*S.ImaginaryUnit\n436             return re + im\n437         else:\n438             raise TypeError(\"expected mpmath number (mpf or mpc)\")\n439 \n440     @property\n441     def is_number(self):\n442         \"\"\"Returns True if ``self`` has no free symbols and no\n443         undefined functions (AppliedUndef, to be precise). It will be\n444         faster than ``if not self.free_symbols``, however, since\n445         ``is_number`` will fail as soon as it hits a free symbol\n446         or undefined function.\n447 \n448         Examples\n449         ========\n450 \n451         >>> from sympy import log, Integral, cos, sin, pi\n452         >>> from sympy.core.function import Function\n453         >>> from sympy.abc import x\n454         >>> f = Function('f')\n455 \n456         >>> x.is_number\n457         False\n458         >>> f(1).is_number\n459         False\n460         >>> (2*x).is_number\n461         False\n462         >>> (2 + Integral(2, x)).is_number\n463         False\n464         >>> (2 + Integral(2, (x, 1, 2))).is_number\n465         True\n466 \n467         Not all numbers are Numbers in the SymPy sense:\n468 \n469         >>> pi.is_number, pi.is_Number\n470         (True, False)\n471 \n472         If something is a number it should evaluate to a number with\n473         real and imaginary parts that are Numbers; the result may not\n474         be comparable, however, since the real and/or imaginary part\n475         of the result may not have precision.\n476 \n477         >>> cos(1).is_number and cos(1).is_comparable\n478         True\n479 \n480         >>> z = cos(1)**2 + sin(1)**2 - 1\n481         >>> z.is_number\n482         True\n483         >>> z.is_comparable\n484         False\n485 \n486         See Also\n487         ========\n488         sympy.core.basic.is_comparable\n489         \"\"\"\n490         return all(obj.is_number for obj in self.args)\n491 \n492     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):\n493         \"\"\"Return self evaluated, if possible, replacing free symbols with\n494         random complex values, if necessary.\n495 \n496         The random complex value for each free symbol is generated\n497         by the random_complex_number routine giving real and imaginary\n498         parts in the range given by the re_min, re_max, im_min, and im_max\n499         values. The returned value is evaluated to a precision of n\n500         (if given) else the maximum of 15 and the precision needed\n501         to get more than 1 digit of precision. If the expression\n502         could not be evaluated to a number, or could not be evaluated\n503         to more than 1 digit of precision, then None is returned.\n504 \n505         Examples\n506         ========\n507 \n508         >>> from sympy import sqrt\n509         >>> from sympy.abc import x, y\n510         >>> x._random()                         # doctest: +SKIP\n511         0.0392918155679172 + 0.916050214307199*I\n512         >>> x._random(2)                        # doctest: +SKIP\n513         -0.77 - 0.87*I\n514         >>> (x + y/2)._random(2)                # doctest: +SKIP\n515         -0.57 + 0.16*I\n516         >>> sqrt(2)._random(2)\n517         1.4\n518 \n519         See Also\n520         ========\n521 \n522         sympy.utilities.randtest.random_complex_number\n523         \"\"\"\n524 \n525         free = self.free_symbols\n526         prec = 1\n527         if free:\n528             from sympy.utilities.randtest import random_complex_number\n529             a, c, b, d = re_min, re_max, im_min, im_max\n530             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)\n531                            for zi in free])))\n532             try:\n533                 nmag = abs(self.evalf(2, subs=reps))\n534             except (ValueError, TypeError):\n535                 # if an out of range value resulted in evalf problems\n536                 # then return None -- XXX is there a way to know how to\n537                 # select a good random number for a given expression?\n538                 # e.g. when calculating n! negative values for n should not\n539                 # be used\n540                 return None\n541         else:\n542             reps = {}\n543             nmag = abs(self.evalf(2))\n544 \n545         if not hasattr(nmag, '_prec'):\n546             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True\n547             return None\n548 \n549         if nmag._prec == 1:\n550             # increase the precision up to the default maximum\n551             # precision to see if we can get any significance\n552 \n553             from mpmath.libmp.libintmath import giant_steps\n554             from sympy.core.evalf import DEFAULT_MAXPREC as target\n555 \n556             # evaluate\n557             for prec in giant_steps(2, target):\n558                 nmag = abs(self.evalf(prec, subs=reps))\n559                 if nmag._prec != 1:\n560                     break\n561 \n562         if nmag._prec != 1:\n563             if n is None:\n564                 n = max(prec, 15)\n565             return self.evalf(n, subs=reps)\n566 \n567         # never got any significance\n568         return None\n569 \n570     def is_constant(self, *wrt, **flags):\n571         \"\"\"Return True if self is constant, False if not, or None if\n572         the constancy could not be determined conclusively.\n573 \n574         If an expression has no free symbols then it is a constant. If\n575         there are free symbols it is possible that the expression is a\n576         constant, perhaps (but not necessarily) zero. To test such\n577         expressions, two strategies are tried:\n578 \n579         1) numerical evaluation at two random points. If two such evaluations\n580         give two different values and the values have a precision greater than\n581         1 then self is not constant. If the evaluations agree or could not be\n582         obtained with any precision, no decision is made. The numerical testing\n583         is done only if ``wrt`` is different than the free symbols.\n584 \n585         2) differentiation with respect to variables in 'wrt' (or all free\n586         symbols if omitted) to see if the expression is constant or not. This\n587         will not always lead to an expression that is zero even though an\n588         expression is constant (see added test in test_expr.py). If\n589         all derivatives are zero then self is constant with respect to the\n590         given symbols.\n591 \n592         If neither evaluation nor differentiation can prove the expression is\n593         constant, None is returned unless two numerical values happened to be\n594         the same and the flag ``failing_number`` is True -- in that case the\n595         numerical value will be returned.\n596 \n597         If flag simplify=False is passed, self will not be simplified;\n598         the default is True since self should be simplified before testing.\n599 \n600         Examples\n601         ========\n602 \n603         >>> from sympy import cos, sin, Sum, S, pi\n604         >>> from sympy.abc import a, n, x, y\n605         >>> x.is_constant()\n606         False\n607         >>> S(2).is_constant()\n608         True\n609         >>> Sum(x, (x, 1, 10)).is_constant()\n610         True\n611         >>> Sum(x, (x, 1, n)).is_constant()\n612         False\n613         >>> Sum(x, (x, 1, n)).is_constant(y)\n614         True\n615         >>> Sum(x, (x, 1, n)).is_constant(n)\n616         False\n617         >>> Sum(x, (x, 1, n)).is_constant(x)\n618         True\n619         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a\n620         >>> eq.is_constant()\n621         True\n622         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0\n623         True\n624 \n625         >>> (0**x).is_constant()\n626         False\n627         >>> x.is_constant()\n628         False\n629         >>> (x**x).is_constant()\n630         False\n631         >>> one = cos(x)**2 + sin(x)**2\n632         >>> one.is_constant()\n633         True\n634         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1\n635         True\n636         \"\"\"\n637 \n638         simplify = flags.get('simplify', True)\n639 \n640         if self.is_number:\n641             return True\n642         free = self.free_symbols\n643         if not free:\n644             return True  # assume f(1) is some constant\n645 \n646         # if we are only interested in some symbols and they are not in the\n647         # free symbols then this expression is constant wrt those symbols\n648         wrt = set(wrt)\n649         if wrt and not wrt & free:\n650             return True\n651         wrt = wrt or free\n652 \n653         # simplify unless this has already been done\n654         expr = self\n655         if simplify:\n656             expr = expr.simplify()\n657 \n658         # is_zero should be a quick assumptions check; it can be wrong for\n659         # numbers (see test_is_not_constant test), giving False when it\n660         # shouldn't, but hopefully it will never give True unless it is sure.\n661         if expr.is_zero:\n662             return True\n663 \n664         # try numerical evaluation to see if we get two different values\n665         failing_number = None\n666         if wrt == free:\n667             # try 0 (for a) and 1 (for b)\n668             try:\n669                 a = expr.subs(list(zip(free, [0]*len(free))),\n670                     simultaneous=True)\n671                 if a is S.NaN:\n672                     # evaluation may succeed when substitution fails\n673                     a = expr._random(None, 0, 0, 0, 0)\n674             except ZeroDivisionError:\n675                 a = None\n676             if a is not None and a is not S.NaN:\n677                 try:\n678                     b = expr.subs(list(zip(free, [1]*len(free))),\n679                         simultaneous=True)\n680                     if b is S.NaN:\n681                         # evaluation may succeed when substitution fails\n682                         b = expr._random(None, 1, 0, 1, 0)\n683                 except ZeroDivisionError:\n684                     b = None\n685                 if b is not None and b is not S.NaN and b.equals(a) is False:\n686                     return False\n687                 # try random real\n688                 b = expr._random(None, -1, 0, 1, 0)\n689                 if b is not None and b is not S.NaN and b.equals(a) is False:\n690                     return False\n691                 # try random complex\n692                 b = expr._random()\n693                 if b is not None and b is not S.NaN:\n694                     if b.equals(a) is False:\n695                         return False\n696                     failing_number = a if a.is_number else b\n697 \n698         # now we will test each wrt symbol (or all free symbols) to see if the\n699         # expression depends on them or not using differentiation. This is\n700         # not sufficient for all expressions, however, so we don't return\n701         # False if we get a derivative other than 0 with free symbols.\n702         for w in wrt:\n703             deriv = expr.diff(w)\n704             if simplify:\n705                 deriv = deriv.simplify()\n706             if deriv != 0:\n707                 if not (pure_complex(deriv, or_real=True)):\n708                     if flags.get('failing_number', False):\n709                         return failing_number\n710                     elif deriv.free_symbols:\n711                         # dead line provided _random returns None in such cases\n712                         return None\n713                 return False\n714         return True\n715 \n716     def equals(self, other, failing_expression=False):\n717         \"\"\"Return True if self == other, False if it doesn't, or None. If\n718         failing_expression is True then the expression which did not simplify\n719         to a 0 will be returned instead of None.\n720 \n721         If ``self`` is a Number (or complex number) that is not zero, then\n722         the result is False.\n723 \n724         If ``self`` is a number and has not evaluated to zero, evalf will be\n725         used to test whether the expression evaluates to zero. If it does so\n726         and the result has significance (i.e. the precision is either -1, for\n727         a Rational result, or is greater than 1) then the evalf value will be\n728         used to return True or False.\n729 \n730         \"\"\"\n731         from sympy.simplify.simplify import nsimplify, simplify\n732         from sympy.solvers.solveset import solveset\n733         from sympy.solvers.solvers import solve\n734         from sympy.polys.polyerrors import NotAlgebraic\n735         from sympy.polys.numberfields import minimal_polynomial\n736 \n737         other = sympify(other)\n738         if self == other:\n739             return True\n740 \n741         # they aren't the same so see if we can make the difference 0;\n742         # don't worry about doing simplification steps one at a time\n743         # because if the expression ever goes to 0 then the subsequent\n744         # simplification steps that are done will be very fast.\n745         diff = factor_terms(simplify(self - other), radical=True)\n746 \n747         if not diff:\n748             return True\n749 \n750         if not diff.has(Add, Mod):\n751             # if there is no expanding to be done after simplifying\n752             # then this can't be a zero\n753             return False\n754 \n755         constant = diff.is_constant(simplify=False, failing_number=True)\n756 \n757         if constant is False:\n758             return False\n759 \n760         if not diff.is_number:\n761             if constant is None:\n762                 # e.g. unless the right simplification is done, a symbolic\n763                 # zero is possible (see expression of issue 6829: without\n764                 # simplification constant will be None).\n765                 return\n766 \n767         if constant is True:\n768             # this gives a number whether there are free symbols or not\n769             ndiff = diff._random()\n770             # is_comparable will work whether the result is real\n771             # or complex; it could be None, however.\n772             if ndiff and ndiff.is_comparable:\n773                 return False\n774 \n775         # sometimes we can use a simplified result to give a clue as to\n776         # what the expression should be; if the expression is *not* zero\n777         # then we should have been able to compute that and so now\n778         # we can just consider the cases where the approximation appears\n779         # to be zero -- we try to prove it via minimal_polynomial.\n780         #\n781         # removed\n782         # ns = nsimplify(diff)\n783         # if diff.is_number and (not ns or ns == diff):\n784         #\n785         # The thought was that if it nsimplifies to 0 that's a sure sign\n786         # to try the following to prove it; or if it changed but wasn't\n787         # zero that might be a sign that it's not going to be easy to\n788         # prove. But tests seem to be working without that logic.\n789         #\n790         if diff.is_number:\n791             # try to prove via self-consistency\n792             surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n793             # it seems to work better to try big ones first\n794             surds.sort(key=lambda x: -x.args[0])\n795             for s in surds:\n796                 try:\n797                     # simplify is False here -- this expression has already\n798                     # been identified as being hard to identify as zero;\n799                     # we will handle the checking ourselves using nsimplify\n800                     # to see if we are in the right ballpark or not and if so\n801                     # *then* the simplification will be attempted.\n802                     sol = solve(diff, s, simplify=False)\n803                     if sol:\n804                         if s in sol:\n805                             # the self-consistent result is present\n806                             return True\n807                         if all(si.is_Integer for si in sol):\n808                             # perfect powers are removed at instantiation\n809                             # so surd s cannot be an integer\n810                             return False\n811                         if all(i.is_algebraic is False for i in sol):\n812                             # a surd is algebraic\n813                             return False\n814                         if any(si in surds for si in sol):\n815                             # it wasn't equal to s but it is in surds\n816                             # and different surds are not equal\n817                             return False\n818                         if any(nsimplify(s - si) == 0 and\n819                                 simplify(s - si) == 0 for si in sol):\n820                             return True\n821                         if s.is_real:\n822                             if any(nsimplify(si, [s]) == s and simplify(si) == s\n823                                     for si in sol):\n824                                 return True\n825                 except NotImplementedError:\n826                     pass\n827 \n828             # try to prove with minimal_polynomial but know when\n829             # *not* to use this or else it can take a long time. e.g. issue 8354\n830             if True:  # change True to condition that assures non-hang\n831                 try:\n832                     mp = minimal_polynomial(diff)\n833                     if mp.is_Symbol:\n834                         return True\n835                     return False\n836                 except (NotAlgebraic, NotImplementedError):\n837                     pass\n838 \n839         # diff has not simplified to zero; constant is either None, True\n840         # or the number with significance (is_comparable) that was randomly\n841         # calculated twice as the same value.\n842         if constant not in (True, None) and constant != 0:\n843             return False\n844 \n845         if failing_expression:\n846             return diff\n847         return None\n848 \n849     def _eval_is_positive(self):\n850         finite = self.is_finite\n851         if finite is False:\n852             return False\n853         extended_positive = self.is_extended_positive\n854         if finite is True:\n855             return extended_positive\n856         if extended_positive is False:\n857             return False\n858 \n859     def _eval_is_negative(self):\n860         finite = self.is_finite\n861         if finite is False:\n862             return False\n863         extended_negative = self.is_extended_negative\n864         if finite is True:\n865             return extended_negative\n866         if extended_negative is False:\n867             return False\n868 \n869     def _eval_is_extended_positive(self):\n870         from sympy.polys.numberfields import minimal_polynomial\n871         from sympy.polys.polyerrors import NotAlgebraic\n872         if self.is_number:\n873             if self.is_extended_real is False:\n874                 return False\n875 \n876             # check to see that we can get a value\n877             try:\n878                 n2 = self._eval_evalf(2)\n879             # XXX: This shouldn't be caught here\n880             # Catches ValueError: hypsum() failed to converge to the requested\n881             # 34 bits of accuracy\n882             except ValueError:\n883                 return None\n884             if n2 is None:\n885                 return None\n886             if getattr(n2, '_prec', 1) == 1:  # no significance\n887                 return None\n888             if n2 == S.NaN:\n889                 return None\n890 \n891             r, i = self.evalf(2).as_real_imag()\n892             if not i.is_Number or not r.is_Number:\n893                 return False\n894             if r._prec != 1 and i._prec != 1:\n895                 return bool(not i and r > 0)\n896             elif r._prec == 1 and (not i or i._prec == 1) and \\\n897                     self.is_algebraic and not self.has(Function):\n898                 try:\n899                     if minimal_polynomial(self).is_Symbol:\n900                         return False\n901                 except (NotAlgebraic, NotImplementedError):\n902                     pass\n903 \n904     def _eval_is_extended_negative(self):\n905         from sympy.polys.numberfields import minimal_polynomial\n906         from sympy.polys.polyerrors import NotAlgebraic\n907         if self.is_number:\n908             if self.is_extended_real is False:\n909                 return False\n910 \n911             # check to see that we can get a value\n912             try:\n913                 n2 = self._eval_evalf(2)\n914             # XXX: This shouldn't be caught here\n915             # Catches ValueError: hypsum() failed to converge to the requested\n916             # 34 bits of accuracy\n917             except ValueError:\n918                 return None\n919             if n2 is None:\n920                 return None\n921             if getattr(n2, '_prec', 1) == 1:  # no significance\n922                 return None\n923             if n2 == S.NaN:\n924                 return None\n925 \n926             r, i = self.evalf(2).as_real_imag()\n927             if not i.is_Number or not r.is_Number:\n928                 return False\n929             if r._prec != 1 and i._prec != 1:\n930                 return bool(not i and r < 0)\n931             elif r._prec == 1 and (not i or i._prec == 1) and \\\n932                     self.is_algebraic and not self.has(Function):\n933                 try:\n934                     if minimal_polynomial(self).is_Symbol:\n935                         return False\n936                 except (NotAlgebraic, NotImplementedError):\n937                     pass\n938 \n939     def _eval_interval(self, x, a, b):\n940         \"\"\"\n941         Returns evaluation over an interval.  For most functions this is:\n942 \n943         self.subs(x, b) - self.subs(x, a),\n944 \n945         possibly using limit() if NaN is returned from subs, or if\n946         singularities are found between a and b.\n947 \n948         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),\n949         respectively.\n950 \n951         \"\"\"\n952         from sympy.series import limit, Limit\n953         from sympy.solvers.solveset import solveset\n954         from sympy.sets.sets import Interval\n955         from sympy.functions.elementary.exponential import log\n956         from sympy.calculus.util import AccumBounds\n957 \n958         if (a is None and b is None):\n959             raise ValueError('Both interval ends cannot be None.')\n960 \n961         if a == b:\n962             return 0\n963 \n964         if a is None:\n965             A = 0\n966         else:\n967             A = self.subs(x, a)\n968             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):\n969                 if (a < b) != False:\n970                     A = limit(self, x, a,\"+\")\n971                 else:\n972                     A = limit(self, x, a,\"-\")\n973 \n974                 if A is S.NaN:\n975                     return A\n976                 if isinstance(A, Limit):\n977                     raise NotImplementedError(\"Could not compute limit\")\n978 \n979         if b is None:\n980             B = 0\n981         else:\n982             B = self.subs(x, b)\n983             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):\n984                 if (a < b) != False:\n985                     B = limit(self, x, b,\"-\")\n986                 else:\n987                     B = limit(self, x, b,\"+\")\n988 \n989                 if isinstance(B, Limit):\n990                     raise NotImplementedError(\"Could not compute limit\")\n991 \n992         if (a and b) is None:\n993             return B - A\n994 \n995         value = B - A\n996 \n997         if a.is_comparable and b.is_comparable:\n998             if a < b:\n999                 domain = Interval(a, b)\n1000             else:\n1001                 domain = Interval(b, a)\n1002             # check the singularities of self within the interval\n1003             # if singularities is a ConditionSet (not iterable), catch the exception and pass\n1004             singularities = solveset(self.cancel().as_numer_denom()[1], x,\n1005                 domain=domain)\n1006             for logterm in self.atoms(log):\n1007                 singularities = singularities | solveset(logterm.args[0], x,\n1008                     domain=domain)\n1009             try:\n1010                 for s in singularities:\n1011                     if value is S.NaN:\n1012                         # no need to keep adding, it will stay NaN\n1013                         break\n1014                     if not s.is_comparable:\n1015                         continue\n1016                     if (a < s) == (s < b) == True:\n1017                         value += -limit(self, x, s, \"+\") + limit(self, x, s, \"-\")\n1018                     elif (b < s) == (s < a) == True:\n1019                         value += limit(self, x, s, \"+\") - limit(self, x, s, \"-\")\n1020             except TypeError:\n1021                 pass\n1022 \n1023         return value\n1024 \n1025     def _eval_power(self, other):\n1026         # subclass to compute self**other for cases when\n1027         # other is not NaN, 0, or 1\n1028         return None\n1029 \n1030     def _eval_conjugate(self):\n1031         if self.is_extended_real:\n1032             return self\n1033         elif self.is_imaginary:\n1034             return -self\n1035 \n1036     def conjugate(self):\n1037         from sympy.functions.elementary.complexes import conjugate as c\n1038         return c(self)\n1039 \n1040     def _eval_transpose(self):\n1041         from sympy.functions.elementary.complexes import conjugate\n1042         if self.is_complex:\n1043             return self\n1044         elif self.is_hermitian:\n1045             return conjugate(self)\n1046         elif self.is_antihermitian:\n1047             return -conjugate(self)\n1048 \n1049     def transpose(self):\n1050         from sympy.functions.elementary.complexes import transpose\n1051         return transpose(self)\n1052 \n1053     def _eval_adjoint(self):\n1054         from sympy.functions.elementary.complexes import conjugate, transpose\n1055         if self.is_hermitian:\n1056             return self\n1057         elif self.is_antihermitian:\n1058             return -self\n1059         obj = self._eval_conjugate()\n1060         if obj is not None:\n1061             return transpose(obj)\n1062         obj = self._eval_transpose()\n1063         if obj is not None:\n1064             return conjugate(obj)\n1065 \n1066     def adjoint(self):\n1067         from sympy.functions.elementary.complexes import adjoint\n1068         return adjoint(self)\n1069 \n1070     @classmethod\n1071     def _parse_order(cls, order):\n1072         \"\"\"Parse and configure the ordering of terms. \"\"\"\n1073         from sympy.polys.orderings import monomial_key\n1074 \n1075         startswith = getattr(order, \"startswith\", None)\n1076         if startswith is None:\n1077             reverse = False\n1078         else:\n1079             reverse = startswith('rev-')\n1080             if reverse:\n1081                 order = order[4:]\n1082 \n1083         monom_key = monomial_key(order)\n1084 \n1085         def neg(monom):\n1086             result = []\n1087 \n1088             for m in monom:\n1089                 if isinstance(m, tuple):\n1090                     result.append(neg(m))\n1091                 else:\n1092                     result.append(-m)\n1093 \n1094             return tuple(result)\n1095 \n1096         def key(term):\n1097             _, ((re, im), monom, ncpart) = term\n1098 \n1099             monom = neg(monom_key(monom))\n1100             ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n1101             coeff = ((bool(im), im), (re, im))\n1102 \n1103             return monom, ncpart, coeff\n1104 \n1105         return key, reverse\n1106 \n1107     def as_ordered_factors(self, order=None):\n1108         \"\"\"Return list of ordered factors (if Mul) else [self].\"\"\"\n1109         return [self]\n1110 \n1111     def as_ordered_terms(self, order=None, data=False):\n1112         \"\"\"\n1113         Transform an expression to an ordered list of terms.\n1114 \n1115         Examples\n1116         ========\n1117 \n1118         >>> from sympy import sin, cos\n1119         >>> from sympy.abc import x\n1120 \n1121         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()\n1122         [sin(x)**2*cos(x), sin(x)**2, 1]\n1123 \n1124         \"\"\"\n1125 \n1126         from .numbers import Number, NumberSymbol\n1127 \n1128         if order is None and self.is_Add:\n1129             # Spot the special case of Add(Number, Mul(Number, expr)) with the\n1130             # first number positive and thhe second number nagative\n1131             key = lambda x:not isinstance(x, (Number, NumberSymbol))\n1132             add_args = sorted(Add.make_args(self), key=key)\n1133             if (len(add_args) == 2\n1134                 and isinstance(add_args[0], (Number, NumberSymbol))\n1135                 and isinstance(add_args[1], Mul)):\n1136                 mul_args = sorted(Mul.make_args(add_args[1]), key=key)\n1137                 if (len(mul_args) == 2\n1138                     and isinstance(mul_args[0], Number)\n1139                     and add_args[0].is_positive\n1140                     and mul_args[0].is_negative):\n1141                     return add_args\n1142 \n1143         key, reverse = self._parse_order(order)\n1144         terms, gens = self.as_terms()\n1145 \n1146         if not any(term.is_Order for term, _ in terms):\n1147             ordered = sorted(terms, key=key, reverse=reverse)\n1148         else:\n1149             _terms, _order = [], []\n1150 \n1151             for term, repr in terms:\n1152                 if not term.is_Order:\n1153                     _terms.append((term, repr))\n1154                 else:\n1155                     _order.append((term, repr))\n1156 \n1157             ordered = sorted(_terms, key=key, reverse=True) \\\n1158                 + sorted(_order, key=key, reverse=True)\n1159 \n1160         if data:\n1161             return ordered, gens\n1162         else:\n1163             return [term for term, _ in ordered]\n1164 \n1165     def as_terms(self):\n1166         \"\"\"Transform an expression to a list of terms. \"\"\"\n1167         from .add import Add\n1168         from .mul import Mul\n1169         from .exprtools import decompose_power\n1170 \n1171         gens, terms = set([]), []\n1172 \n1173         for term in Add.make_args(self):\n1174             coeff, _term = term.as_coeff_Mul()\n1175 \n1176             coeff = complex(coeff)\n1177             cpart, ncpart = {}, []\n1178 \n1179             if _term is not S.One:\n1180                 for factor in Mul.make_args(_term):\n1181                     if factor.is_number:\n1182                         try:\n1183                             coeff *= complex(factor)\n1184                         except (TypeError, ValueError):\n1185                             pass\n1186                         else:\n1187                             continue\n1188 \n1189                     if factor.is_commutative:\n1190                         base, exp = decompose_power(factor)\n1191 \n1192                         cpart[base] = exp\n1193                         gens.add(base)\n1194                     else:\n1195                         ncpart.append(factor)\n1196 \n1197             coeff = coeff.real, coeff.imag\n1198             ncpart = tuple(ncpart)\n1199 \n1200             terms.append((term, (coeff, cpart, ncpart)))\n1201 \n1202         gens = sorted(gens, key=default_sort_key)\n1203 \n1204         k, indices = len(gens), {}\n1205 \n1206         for i, g in enumerate(gens):\n1207             indices[g] = i\n1208 \n1209         result = []\n1210 \n1211         for term, (coeff, cpart, ncpart) in terms:\n1212             monom = [0]*k\n1213 \n1214             for base, exp in cpart.items():\n1215                 monom[indices[base]] = exp\n1216 \n1217             result.append((term, (coeff, tuple(monom), ncpart)))\n1218 \n1219         return result, gens\n1220 \n1221     def removeO(self):\n1222         \"\"\"Removes the additive O(..) symbol if there is one\"\"\"\n1223         return self\n1224 \n1225     def getO(self):\n1226         \"\"\"Returns the additive O(..) symbol if there is one, else None.\"\"\"\n1227         return None\n1228 \n1229     def getn(self):\n1230         \"\"\"\n1231         Returns the order of the expression.\n1232 \n1233         The order is determined either from the O(...) term. If there\n1234         is no O(...) term, it returns None.\n1235 \n1236         Examples\n1237         ========\n1238 \n1239         >>> from sympy import O\n1240         >>> from sympy.abc import x\n1241         >>> (1 + x + O(x**2)).getn()\n1242         2\n1243         >>> (1 + x).getn()\n1244 \n1245         \"\"\"\n1246         from sympy import Dummy, Symbol\n1247         o = self.getO()\n1248         if o is None:\n1249             return None\n1250         elif o.is_Order:\n1251             o = o.expr\n1252             if o is S.One:\n1253                 return S.Zero\n1254             if o.is_Symbol:\n1255                 return S.One\n1256             if o.is_Pow:\n1257                 return o.args[1]\n1258             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n\n1259                 for oi in o.args:\n1260                     if oi.is_Symbol:\n1261                         return S.One\n1262                     if oi.is_Pow:\n1263                         syms = oi.atoms(Symbol)\n1264                         if len(syms) == 1:\n1265                             x = syms.pop()\n1266                             oi = oi.subs(x, Dummy('x', positive=True))\n1267                             if oi.base.is_Symbol and oi.exp.is_Rational:\n1268                                 return abs(oi.exp)\n1269 \n1270         raise NotImplementedError('not sure of order of %s' % o)\n1271 \n1272     def count_ops(self, visual=None):\n1273         \"\"\"wrapper for count_ops that returns the operation count.\"\"\"\n1274         from .function import count_ops\n1275         return count_ops(self, visual)\n1276 \n1277     def args_cnc(self, cset=False, warn=True, split_1=True):\n1278         \"\"\"Return [commutative factors, non-commutative factors] of self.\n1279 \n1280         self is treated as a Mul and the ordering of the factors is maintained.\n1281         If ``cset`` is True the commutative factors will be returned in a set.\n1282         If there were repeated factors (as may happen with an unevaluated Mul)\n1283         then an error will be raised unless it is explicitly suppressed by\n1284         setting ``warn`` to False.\n1285 \n1286         Note: -1 is always separated from a Number unless split_1 is False.\n1287 \n1288         >>> from sympy import symbols, oo\n1289         >>> A, B = symbols('A B', commutative=0)\n1290         >>> x, y = symbols('x y')\n1291         >>> (-2*x*y).args_cnc()\n1292         [[-1, 2, x, y], []]\n1293         >>> (-2.5*x).args_cnc()\n1294         [[-1, 2.5, x], []]\n1295         >>> (-2*x*A*B*y).args_cnc()\n1296         [[-1, 2, x, y], [A, B]]\n1297         >>> (-2*x*A*B*y).args_cnc(split_1=False)\n1298         [[-2, x, y], [A, B]]\n1299         >>> (-2*x*y).args_cnc(cset=True)\n1300         [{-1, 2, x, y}, []]\n1301 \n1302         The arg is always treated as a Mul:\n1303 \n1304         >>> (-2 + x + A).args_cnc()\n1305         [[], [x - 2 + A]]\n1306         >>> (-oo).args_cnc() # -oo is a singleton\n1307         [[-1, oo], []]\n1308         \"\"\"\n1309 \n1310         if self.is_Mul:\n1311             args = list(self.args)\n1312         else:\n1313             args = [self]\n1314         for i, mi in enumerate(args):\n1315             if not mi.is_commutative:\n1316                 c = args[:i]\n1317                 nc = args[i:]\n1318                 break\n1319         else:\n1320             c = args\n1321             nc = []\n1322 \n1323         if c and split_1 and (\n1324             c[0].is_Number and\n1325             c[0].is_extended_negative and\n1326                 c[0] is not S.NegativeOne):\n1327             c[:1] = [S.NegativeOne, -c[0]]\n1328 \n1329         if cset:\n1330             clen = len(c)\n1331             c = set(c)\n1332             if clen and warn and len(c) != clen:\n1333                 raise ValueError('repeated commutative arguments: %s' %\n1334                                  [ci for ci in c if list(self.args).count(ci) > 1])\n1335         return [c, nc]\n1336 \n1337     def coeff(self, x, n=1, right=False):\n1338         \"\"\"\n1339         Returns the coefficient from the term(s) containing ``x**n``. If ``n``\n1340         is zero then all terms independent of ``x`` will be returned.\n1341 \n1342         When ``x`` is noncommutative, the coefficient to the left (default) or\n1343         right of ``x`` can be returned. The keyword 'right' is ignored when\n1344         ``x`` is commutative.\n1345 \n1346         See Also\n1347         ========\n1348 \n1349         as_coefficient: separate the expression into a coefficient and factor\n1350         as_coeff_Add: separate the additive constant from an expression\n1351         as_coeff_Mul: separate the multiplicative constant from an expression\n1352         as_independent: separate x-dependent terms/factors from others\n1353         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1354         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1355 \n1356         Examples\n1357         ========\n1358 \n1359         >>> from sympy import symbols\n1360         >>> from sympy.abc import x, y, z\n1361 \n1362         You can select terms that have an explicit negative in front of them:\n1363 \n1364         >>> (-x + 2*y).coeff(-1)\n1365         x\n1366         >>> (x - 2*y).coeff(-1)\n1367         2*y\n1368 \n1369         You can select terms with no Rational coefficient:\n1370 \n1371         >>> (x + 2*y).coeff(1)\n1372         x\n1373         >>> (3 + 2*x + 4*x**2).coeff(1)\n1374         0\n1375 \n1376         You can select terms independent of x by making n=0; in this case\n1377         expr.as_independent(x)[0] is returned (and 0 will be returned instead\n1378         of None):\n1379 \n1380         >>> (3 + 2*x + 4*x**2).coeff(x, 0)\n1381         3\n1382         >>> eq = ((x + 1)**3).expand() + 1\n1383         >>> eq\n1384         x**3 + 3*x**2 + 3*x + 2\n1385         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1386         [1, 3, 3, 2]\n1387         >>> eq -= 2\n1388         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1389         [1, 3, 3, 0]\n1390 \n1391         You can select terms that have a numerical term in front of them:\n1392 \n1393         >>> (-x - 2*y).coeff(2)\n1394         -y\n1395         >>> from sympy import sqrt\n1396         >>> (x + sqrt(2)*x).coeff(sqrt(2))\n1397         x\n1398 \n1399         The matching is exact:\n1400 \n1401         >>> (3 + 2*x + 4*x**2).coeff(x)\n1402         2\n1403         >>> (3 + 2*x + 4*x**2).coeff(x**2)\n1404         4\n1405         >>> (3 + 2*x + 4*x**2).coeff(x**3)\n1406         0\n1407         >>> (z*(x + y)**2).coeff((x + y)**2)\n1408         z\n1409         >>> (z*(x + y)**2).coeff(x + y)\n1410         0\n1411 \n1412         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\n1413         from the following:\n1414 \n1415         >>> (x + z*(x + x*y)).coeff(x)\n1416         1\n1417 \n1418         If such factoring is desired, factor_terms can be used first:\n1419 \n1420         >>> from sympy import factor_terms\n1421         >>> factor_terms(x + z*(x + x*y)).coeff(x)\n1422         z*(y + 1) + 1\n1423 \n1424         >>> n, m, o = symbols('n m o', commutative=False)\n1425         >>> n.coeff(n)\n1426         1\n1427         >>> (3*n).coeff(n)\n1428         3\n1429         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n1430         1 + m\n1431         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\n1432         m\n1433 \n1434         If there is more than one possible coefficient 0 is returned:\n1435 \n1436         >>> (n*m + m*n).coeff(n)\n1437         0\n1438 \n1439         If there is only one possible coefficient, it is returned:\n1440 \n1441         >>> (n*m + x*m*n).coeff(m*n)\n1442         x\n1443         >>> (n*m + x*m*n).coeff(m*n, right=1)\n1444         1\n1445 \n1446         \"\"\"\n1447         x = sympify(x)\n1448         if not isinstance(x, Basic):\n1449             return S.Zero\n1450 \n1451         n = as_int(n)\n1452 \n1453         if not x:\n1454             return S.Zero\n1455 \n1456         if x == self:\n1457             if n == 1:\n1458                 return S.One\n1459             return S.Zero\n1460 \n1461         if x is S.One:\n1462             co = [a for a in Add.make_args(self)\n1463                   if a.as_coeff_Mul()[0] is S.One]\n1464             if not co:\n1465                 return S.Zero\n1466             return Add(*co)\n1467 \n1468         if n == 0:\n1469             if x.is_Add and self.is_Add:\n1470                 c = self.coeff(x, right=right)\n1471                 if not c:\n1472                     return S.Zero\n1473                 if not right:\n1474                     return self - Add(*[a*x for a in Add.make_args(c)])\n1475                 return self - Add(*[x*a for a in Add.make_args(c)])\n1476             return self.as_independent(x, as_Add=True)[0]\n1477 \n1478         # continue with the full method, looking for this power of x:\n1479         x = x**n\n1480 \n1481         def incommon(l1, l2):\n1482             if not l1 or not l2:\n1483                 return []\n1484             n = min(len(l1), len(l2))\n1485             for i in range(n):\n1486                 if l1[i] != l2[i]:\n1487                     return l1[:i]\n1488             return l1[:]\n1489 \n1490         def find(l, sub, first=True):\n1491             \"\"\" Find where list sub appears in list l. When ``first`` is True\n1492             the first occurrence from the left is returned, else the last\n1493             occurrence is returned. Return None if sub is not in l.\n1494 \n1495             >> l = range(5)*2\n1496             >> find(l, [2, 3])\n1497             2\n1498             >> find(l, [2, 3], first=0)\n1499             7\n1500             >> find(l, [2, 4])\n1501             None\n1502 \n1503             \"\"\"\n1504             if not sub or not l or len(sub) > len(l):\n1505                 return None\n1506             n = len(sub)\n1507             if not first:\n1508                 l.reverse()\n1509                 sub.reverse()\n1510             for i in range(0, len(l) - n + 1):\n1511                 if all(l[i + j] == sub[j] for j in range(n)):\n1512                     break\n1513             else:\n1514                 i = None\n1515             if not first:\n1516                 l.reverse()\n1517                 sub.reverse()\n1518             if i is not None and not first:\n1519                 i = len(l) - (i + n)\n1520             return i\n1521 \n1522         co = []\n1523         args = Add.make_args(self)\n1524         self_c = self.is_commutative\n1525         x_c = x.is_commutative\n1526         if self_c and not x_c:\n1527             return S.Zero\n1528 \n1529         if self_c:\n1530             xargs = x.args_cnc(cset=True, warn=False)[0]\n1531             for a in args:\n1532                 margs = a.args_cnc(cset=True, warn=False)[0]\n1533                 if len(xargs) > len(margs):\n1534                     continue\n1535                 resid = margs.difference(xargs)\n1536                 if len(resid) + len(xargs) == len(margs):\n1537                     co.append(Mul(*resid))\n1538             if co == []:\n1539                 return S.Zero\n1540             elif co:\n1541                 return Add(*co)\n1542         elif x_c:\n1543             xargs = x.args_cnc(cset=True, warn=False)[0]\n1544             for a in args:\n1545                 margs, nc = a.args_cnc(cset=True)\n1546                 if len(xargs) > len(margs):\n1547                     continue\n1548                 resid = margs.difference(xargs)\n1549                 if len(resid) + len(xargs) == len(margs):\n1550                     co.append(Mul(*(list(resid) + nc)))\n1551             if co == []:\n1552                 return S.Zero\n1553             elif co:\n1554                 return Add(*co)\n1555         else:  # both nc\n1556             xargs, nx = x.args_cnc(cset=True)\n1557             # find the parts that pass the commutative terms\n1558             for a in args:\n1559                 margs, nc = a.args_cnc(cset=True)\n1560                 if len(xargs) > len(margs):\n1561                     continue\n1562                 resid = margs.difference(xargs)\n1563                 if len(resid) + len(xargs) == len(margs):\n1564                     co.append((resid, nc))\n1565             # now check the non-comm parts\n1566             if not co:\n1567                 return S.Zero\n1568             if all(n == co[0][1] for r, n in co):\n1569                 ii = find(co[0][1], nx, right)\n1570                 if ii is not None:\n1571                     if not right:\n1572                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))\n1573                     else:\n1574                         return Mul(*co[0][1][ii + len(nx):])\n1575             beg = reduce(incommon, (n[1] for n in co))\n1576             if beg:\n1577                 ii = find(beg, nx, right)\n1578                 if ii is not None:\n1579                     if not right:\n1580                         gcdc = co[0][0]\n1581                         for i in range(1, len(co)):\n1582                             gcdc = gcdc.intersection(co[i][0])\n1583                             if not gcdc:\n1584                                 break\n1585                         return Mul(*(list(gcdc) + beg[:ii]))\n1586                     else:\n1587                         m = ii + len(nx)\n1588                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])\n1589             end = list(reversed(\n1590                 reduce(incommon, (list(reversed(n[1])) for n in co))))\n1591             if end:\n1592                 ii = find(end, nx, right)\n1593                 if ii is not None:\n1594                     if not right:\n1595                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])\n1596                     else:\n1597                         return Mul(*end[ii + len(nx):])\n1598             # look for single match\n1599             hit = None\n1600             for i, (r, n) in enumerate(co):\n1601                 ii = find(n, nx, right)\n1602                 if ii is not None:\n1603                     if not hit:\n1604                         hit = ii, r, n\n1605                     else:\n1606                         break\n1607             else:\n1608                 if hit:\n1609                     ii, r, n = hit\n1610                     if not right:\n1611                         return Mul(*(list(r) + n[:ii]))\n1612                     else:\n1613                         return Mul(*n[ii + len(nx):])\n1614 \n1615             return S.Zero\n1616 \n1617     def as_expr(self, *gens):\n1618         \"\"\"\n1619         Convert a polynomial to a SymPy expression.\n1620 \n1621         Examples\n1622         ========\n1623 \n1624         >>> from sympy import sin\n1625         >>> from sympy.abc import x, y\n1626 \n1627         >>> f = (x**2 + x*y).as_poly(x, y)\n1628         >>> f.as_expr()\n1629         x**2 + x*y\n1630 \n1631         >>> sin(x).as_expr()\n1632         sin(x)\n1633 \n1634         \"\"\"\n1635         return self\n1636 \n1637     def as_coefficient(self, expr):\n1638         \"\"\"\n1639         Extracts symbolic coefficient at the given expression. In\n1640         other words, this functions separates 'self' into the product\n1641         of 'expr' and 'expr'-free coefficient. If such separation\n1642         is not possible it will return None.\n1643 \n1644         Examples\n1645         ========\n1646 \n1647         >>> from sympy import E, pi, sin, I, Poly\n1648         >>> from sympy.abc import x\n1649 \n1650         >>> E.as_coefficient(E)\n1651         1\n1652         >>> (2*E).as_coefficient(E)\n1653         2\n1654         >>> (2*sin(E)*E).as_coefficient(E)\n1655 \n1656         Two terms have E in them so a sum is returned. (If one were\n1657         desiring the coefficient of the term exactly matching E then\n1658         the constant from the returned expression could be selected.\n1659         Or, for greater precision, a method of Poly can be used to\n1660         indicate the desired term from which the coefficient is\n1661         desired.)\n1662 \n1663         >>> (2*E + x*E).as_coefficient(E)\n1664         x + 2\n1665         >>> _.args[0]  # just want the exact match\n1666         2\n1667         >>> p = Poly(2*E + x*E); p\n1668         Poly(x*E + 2*E, x, E, domain='ZZ')\n1669         >>> p.coeff_monomial(E)\n1670         2\n1671         >>> p.nth(0, 1)\n1672         2\n1673 \n1674         Since the following cannot be written as a product containing\n1675         E as a factor, None is returned. (If the coefficient ``2*x`` is\n1676         desired then the ``coeff`` method should be used.)\n1677 \n1678         >>> (2*E*x + x).as_coefficient(E)\n1679         >>> (2*E*x + x).coeff(E)\n1680         2*x\n1681 \n1682         >>> (E*(x + 1) + x).as_coefficient(E)\n1683 \n1684         >>> (2*pi*I).as_coefficient(pi*I)\n1685         2\n1686         >>> (2*I).as_coefficient(pi*I)\n1687 \n1688         See Also\n1689         ========\n1690 \n1691         coeff: return sum of terms have a given factor\n1692         as_coeff_Add: separate the additive constant from an expression\n1693         as_coeff_Mul: separate the multiplicative constant from an expression\n1694         as_independent: separate x-dependent terms/factors from others\n1695         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1696         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1697 \n1698 \n1699         \"\"\"\n1700 \n1701         r = self.extract_multiplicatively(expr)\n1702         if r and not r.has(expr):\n1703             return r\n1704 \n1705     def as_independent(self, *deps, **hint):\n1706         \"\"\"\n1707         A mostly naive separation of a Mul or Add into arguments that are not\n1708         are dependent on deps. To obtain as complete a separation of variables\n1709         as possible, use a separation method first, e.g.:\n1710 \n1711         * separatevars() to change Mul, Add and Pow (including exp) into Mul\n1712         * .expand(mul=True) to change Add or Mul into Add\n1713         * .expand(log=True) to change log expr into an Add\n1714 \n1715         The only non-naive thing that is done here is to respect noncommutative\n1716         ordering of variables and to always return (0, 0) for `self` of zero\n1717         regardless of hints.\n1718 \n1719         For nonzero `self`, the returned tuple (i, d) has the\n1720         following interpretation:\n1721 \n1722         * i will has no variable that appears in deps\n1723         * d will either have terms that contain variables that are in deps, or\n1724           be equal to 0 (when self is an Add) or 1 (when self is a Mul)\n1725         * if self is an Add then self = i + d\n1726         * if self is a Mul then self = i*d\n1727         * otherwise (self, S.One) or (S.One, self) is returned.\n1728 \n1729         To force the expression to be treated as an Add, use the hint as_Add=True\n1730 \n1731         Examples\n1732         ========\n1733 \n1734         -- self is an Add\n1735 \n1736         >>> from sympy import sin, cos, exp\n1737         >>> from sympy.abc import x, y, z\n1738 \n1739         >>> (x + x*y).as_independent(x)\n1740         (0, x*y + x)\n1741         >>> (x + x*y).as_independent(y)\n1742         (x, x*y)\n1743         >>> (2*x*sin(x) + y + x + z).as_independent(x)\n1744         (y + z, 2*x*sin(x) + x)\n1745         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n1746         (z, 2*x*sin(x) + x + y)\n1747 \n1748         -- self is a Mul\n1749 \n1750         >>> (x*sin(x)*cos(y)).as_independent(x)\n1751         (cos(y), x*sin(x))\n1752 \n1753         non-commutative terms cannot always be separated out when self is a Mul\n1754 \n1755         >>> from sympy import symbols\n1756         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n1757         >>> (n1 + n1*n2).as_independent(n2)\n1758         (n1, n1*n2)\n1759         >>> (n2*n1 + n1*n2).as_independent(n2)\n1760         (0, n1*n2 + n2*n1)\n1761         >>> (n1*n2*n3).as_independent(n1)\n1762         (1, n1*n2*n3)\n1763         >>> (n1*n2*n3).as_independent(n2)\n1764         (n1, n2*n3)\n1765         >>> ((x-n1)*(x-y)).as_independent(x)\n1766         (1, (x - y)*(x - n1))\n1767 \n1768         -- self is anything else:\n1769 \n1770         >>> (sin(x)).as_independent(x)\n1771         (1, sin(x))\n1772         >>> (sin(x)).as_independent(y)\n1773         (sin(x), 1)\n1774         >>> exp(x+y).as_independent(x)\n1775         (1, exp(x + y))\n1776 \n1777         -- force self to be treated as an Add:\n1778 \n1779         >>> (3*x).as_independent(x, as_Add=True)\n1780         (0, 3*x)\n1781 \n1782         -- force self to be treated as a Mul:\n1783 \n1784         >>> (3+x).as_independent(x, as_Add=False)\n1785         (1, x + 3)\n1786         >>> (-3+x).as_independent(x, as_Add=False)\n1787         (1, x - 3)\n1788 \n1789         Note how the below differs from the above in making the\n1790         constant on the dep term positive.\n1791 \n1792         >>> (y*(-3+x)).as_independent(x)\n1793         (y, x - 3)\n1794 \n1795         -- use .as_independent() for true independence testing instead\n1796            of .has(). The former considers only symbols in the free\n1797            symbols while the latter considers all symbols\n1798 \n1799         >>> from sympy import Integral\n1800         >>> I = Integral(x, (x, 1, 2))\n1801         >>> I.has(x)\n1802         True\n1803         >>> x in I.free_symbols\n1804         False\n1805         >>> I.as_independent(x) == (I, 1)\n1806         True\n1807         >>> (I + x).as_independent(x) == (I, x)\n1808         True\n1809 \n1810         Note: when trying to get independent terms, a separation method\n1811         might need to be used first. In this case, it is important to keep\n1812         track of what you send to this routine so you know how to interpret\n1813         the returned values\n1814 \n1815         >>> from sympy import separatevars, log\n1816         >>> separatevars(exp(x+y)).as_independent(x)\n1817         (exp(y), exp(x))\n1818         >>> (x + x*y).as_independent(y)\n1819         (x, x*y)\n1820         >>> separatevars(x + x*y).as_independent(y)\n1821         (x, y + 1)\n1822         >>> (x*(1 + y)).as_independent(y)\n1823         (x, y + 1)\n1824         >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n1825         (x, x*y)\n1826         >>> a, b=symbols('a b', positive=True)\n1827         >>> (log(a*b).expand(log=True)).as_independent(b)\n1828         (log(a), log(b))\n1829 \n1830         See Also\n1831         ========\n1832         .separatevars(), .expand(log=True), Add.as_two_terms(),\n1833         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()\n1834         \"\"\"\n1835         from .symbol import Symbol\n1836         from .add import _unevaluated_Add\n1837         from .mul import _unevaluated_Mul\n1838         from sympy.utilities.iterables import sift\n1839 \n1840         if self.is_zero:\n1841             return S.Zero, S.Zero\n1842 \n1843         func = self.func\n1844         if hint.get('as_Add', isinstance(self, Add) ):\n1845             want = Add\n1846         else:\n1847             want = Mul\n1848 \n1849         # sift out deps into symbolic and other and ignore\n1850         # all symbols but those that are in the free symbols\n1851         sym = set()\n1852         other = []\n1853         for d in deps:\n1854             if isinstance(d, Symbol):  # Symbol.is_Symbol is True\n1855                 sym.add(d)\n1856             else:\n1857                 other.append(d)\n1858 \n1859         def has(e):\n1860             \"\"\"return the standard has() if there are no literal symbols, else\n1861             check to see that symbol-deps are in the free symbols.\"\"\"\n1862             has_other = e.has(*other)\n1863             if not sym:\n1864                 return has_other\n1865             return has_other or e.has(*(e.free_symbols & sym))\n1866 \n1867         if (want is not func or\n1868                 func is not Add and func is not Mul):\n1869             if has(self):\n1870                 return (want.identity, self)\n1871             else:\n1872                 return (self, want.identity)\n1873         else:\n1874             if func is Add:\n1875                 args = list(self.args)\n1876             else:\n1877                 args, nc = self.args_cnc()\n1878 \n1879         d = sift(args, lambda x: has(x))\n1880         depend = d[True]\n1881         indep = d[False]\n1882         if func is Add:  # all terms were treated as commutative\n1883             return (Add(*indep), _unevaluated_Add(*depend))\n1884         else:  # handle noncommutative by stopping at first dependent term\n1885             for i, n in enumerate(nc):\n1886                 if has(n):\n1887                     depend.extend(nc[i:])\n1888                     break\n1889                 indep.append(n)\n1890             return Mul(*indep), (\n1891                 Mul(*depend, evaluate=False) if nc else\n1892                 _unevaluated_Mul(*depend))\n1893 \n1894     def as_real_imag(self, deep=True, **hints):\n1895         \"\"\"Performs complex expansion on 'self' and returns a tuple\n1896            containing collected both real and imaginary parts. This\n1897            method can't be confused with re() and im() functions,\n1898            which does not perform complex expansion at evaluation.\n1899 \n1900            However it is possible to expand both re() and im()\n1901            functions and get exactly the same results as with\n1902            a single call to this function.\n1903 \n1904            >>> from sympy import symbols, I\n1905 \n1906            >>> x, y = symbols('x,y', real=True)\n1907 \n1908            >>> (x + y*I).as_real_imag()\n1909            (x, y)\n1910 \n1911            >>> from sympy.abc import z, w\n1912 \n1913            >>> (z + w*I).as_real_imag()\n1914            (re(z) - im(w), re(w) + im(z))\n1915 \n1916         \"\"\"\n1917         from sympy import im, re\n1918         if hints.get('ignore') == self:\n1919             return None\n1920         else:\n1921             return (re(self), im(self))\n1922 \n1923     def as_powers_dict(self):\n1924         \"\"\"Return self as a dictionary of factors with each factor being\n1925         treated as a power. The keys are the bases of the factors and the\n1926         values, the corresponding exponents. The resulting dictionary should\n1927         be used with caution if the expression is a Mul and contains non-\n1928         commutative factors since the order that they appeared will be lost in\n1929         the dictionary.\n1930 \n1931         See Also\n1932         ========\n1933         as_ordered_factors: An alternative for noncommutative applications,\n1934                             returning an ordered list of factors.\n1935         args_cnc: Similar to as_ordered_factors, but guarantees separation\n1936                   of commutative and noncommutative factors.\n1937         \"\"\"\n1938         d = defaultdict(int)\n1939         d.update(dict([self.as_base_exp()]))\n1940         return d\n1941 \n1942     def as_coefficients_dict(self):\n1943         \"\"\"Return a dictionary mapping terms to their Rational coefficient.\n1944         Since the dictionary is a defaultdict, inquiries about terms which\n1945         were not present will return a coefficient of 0. If an expression is\n1946         not an Add it is considered to have a single term.\n1947 \n1948         Examples\n1949         ========\n1950 \n1951         >>> from sympy.abc import a, x\n1952         >>> (3*x + a*x + 4).as_coefficients_dict()\n1953         {1: 4, x: 3, a*x: 1}\n1954         >>> _[a]\n1955         0\n1956         >>> (3*a*x).as_coefficients_dict()\n1957         {a*x: 3}\n1958 \n1959         \"\"\"\n1960         c, m = self.as_coeff_Mul()\n1961         if not c.is_Rational:\n1962             c = S.One\n1963             m = self\n1964         d = defaultdict(int)\n1965         d.update({m: c})\n1966         return d\n1967 \n1968     def as_base_exp(self):\n1969         # a -> b ** e\n1970         return self, S.One\n1971 \n1972     def as_coeff_mul(self, *deps, **kwargs):\n1973         \"\"\"Return the tuple (c, args) where self is written as a Mul, ``m``.\n1974 \n1975         c should be a Rational multiplied by any factors of the Mul that are\n1976         independent of deps.\n1977 \n1978         args should be a tuple of all other factors of m; args is empty\n1979         if self is a Number or if self is independent of deps (when given).\n1980 \n1981         This should be used when you don't know if self is a Mul or not but\n1982         you want to treat self as a Mul or if you want to process the\n1983         individual arguments of the tail of self as a Mul.\n1984 \n1985         - if you know self is a Mul and want only the head, use self.args[0];\n1986         - if you don't want to process the arguments of the tail but need the\n1987           tail then use self.as_two_terms() which gives the head and tail;\n1988         - if you want to split self into an independent and dependent parts\n1989           use ``self.as_independent(*deps)``\n1990 \n1991         >>> from sympy import S\n1992         >>> from sympy.abc import x, y\n1993         >>> (S(3)).as_coeff_mul()\n1994         (3, ())\n1995         >>> (3*x*y).as_coeff_mul()\n1996         (3, (x, y))\n1997         >>> (3*x*y).as_coeff_mul(x)\n1998         (3*y, (x,))\n1999         >>> (3*y).as_coeff_mul(x)\n2000         (3*y, ())\n2001         \"\"\"\n2002         if deps:\n2003             if not self.has(*deps):\n2004                 return self, tuple()\n2005         return S.One, (self,)\n2006 \n2007     def as_coeff_add(self, *deps):\n2008         \"\"\"Return the tuple (c, args) where self is written as an Add, ``a``.\n2009 \n2010         c should be a Rational added to any terms of the Add that are\n2011         independent of deps.\n2012 \n2013         args should be a tuple of all other terms of ``a``; args is empty\n2014         if self is a Number or if self is independent of deps (when given).\n2015 \n2016         This should be used when you don't know if self is an Add or not but\n2017         you want to treat self as an Add or if you want to process the\n2018         individual arguments of the tail of self as an Add.\n2019 \n2020         - if you know self is an Add and want only the head, use self.args[0];\n2021         - if you don't want to process the arguments of the tail but need the\n2022           tail then use self.as_two_terms() which gives the head and tail.\n2023         - if you want to split self into an independent and dependent parts\n2024           use ``self.as_independent(*deps)``\n2025 \n2026         >>> from sympy import S\n2027         >>> from sympy.abc import x, y\n2028         >>> (S(3)).as_coeff_add()\n2029         (3, ())\n2030         >>> (3 + x).as_coeff_add()\n2031         (3, (x,))\n2032         >>> (3 + x + y).as_coeff_add(x)\n2033         (y + 3, (x,))\n2034         >>> (3 + y).as_coeff_add(x)\n2035         (y + 3, ())\n2036 \n2037         \"\"\"\n2038         if deps:\n2039             if not self.has(*deps):\n2040                 return self, tuple()\n2041         return S.Zero, (self,)\n2042 \n2043     def primitive(self):\n2044         \"\"\"Return the positive Rational that can be extracted non-recursively\n2045         from every term of self (i.e., self is treated like an Add). This is\n2046         like the as_coeff_Mul() method but primitive always extracts a positive\n2047         Rational (never a negative or a Float).\n2048 \n2049         Examples\n2050         ========\n2051 \n2052         >>> from sympy.abc import x\n2053         >>> (3*(x + 1)**2).primitive()\n2054         (3, (x + 1)**2)\n2055         >>> a = (6*x + 2); a.primitive()\n2056         (2, 3*x + 1)\n2057         >>> b = (x/2 + 3); b.primitive()\n2058         (1/2, x + 6)\n2059         >>> (a*b).primitive() == (1, a*b)\n2060         True\n2061         \"\"\"\n2062         if not self:\n2063             return S.One, S.Zero\n2064         c, r = self.as_coeff_Mul(rational=True)\n2065         if c.is_negative:\n2066             c, r = -c, -r\n2067         return c, r\n2068 \n2069     def as_content_primitive(self, radical=False, clear=True):\n2070         \"\"\"This method should recursively remove a Rational from all arguments\n2071         and return that (content) and the new self (primitive). The content\n2072         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n2073         The primitive need not be in canonical form and should try to preserve\n2074         the underlying structure if possible (i.e. expand_mul should not be\n2075         applied to self).\n2076 \n2077         Examples\n2078         ========\n2079 \n2080         >>> from sympy import sqrt\n2081         >>> from sympy.abc import x, y, z\n2082 \n2083         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n2084 \n2085         The as_content_primitive function is recursive and retains structure:\n2086 \n2087         >>> eq.as_content_primitive()\n2088         (2, x + 3*y*(y + 1) + 1)\n2089 \n2090         Integer powers will have Rationals extracted from the base:\n2091 \n2092         >>> ((2 + 6*x)**2).as_content_primitive()\n2093         (4, (3*x + 1)**2)\n2094         >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n2095         (1, (2*(3*x + 1))**(2*y))\n2096 \n2097         Terms may end up joining once their as_content_primitives are added:\n2098 \n2099         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n2100         (11, x*(y + 1))\n2101         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n2102         (9, x*(y + 1))\n2103         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n2104         (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n2105         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n2106         (121, x**2*(y + 1)**2)\n2107         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()\n2108         (1, 121.0*x**2*(y + 1)**2)\n2109 \n2110         Radical content can also be factored out of the primitive:\n2111 \n2112         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n2113         (2, sqrt(2)*(1 + 2*sqrt(5)))\n2114 \n2115         If clear=False (default is True) then content will not be removed\n2116         from an Add if it can be distributed to leave one or more\n2117         terms with integer coefficients.\n2118 \n2119         >>> (x/2 + y).as_content_primitive()\n2120         (1/2, x + 2*y)\n2121         >>> (x/2 + y).as_content_primitive(clear=False)\n2122         (1, x/2 + y)\n2123         \"\"\"\n2124         return S.One, self\n2125 \n2126     def as_numer_denom(self):\n2127         \"\"\" expression -> a/b -> a, b\n2128 \n2129         This is just a stub that should be defined by\n2130         an object's class methods to get anything else.\n2131 \n2132         See Also\n2133         ========\n2134         normal: return a/b instead of a, b\n2135         \"\"\"\n2136 \n2137         return self, S.One\n2138 \n2139     def normal(self):\n2140         from .mul import _unevaluated_Mul\n2141         n, d = self.as_numer_denom()\n2142         if d is S.One:\n2143             return n\n2144         if d.is_Number:\n2145             return _unevaluated_Mul(n, 1/d)\n2146         else:\n2147             return n/d\n2148 \n2149     def extract_multiplicatively(self, c):\n2150         \"\"\"Return None if it's not possible to make self in the form\n2151            c * something in a nice way, i.e. preserving the properties\n2152            of arguments of self.\n2153 \n2154            Examples\n2155            ========\n2156 \n2157            >>> from sympy import symbols, Rational\n2158 \n2159            >>> x, y = symbols('x,y', real=True)\n2160 \n2161            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n2162            x*y**2\n2163 \n2164            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n2165 \n2166            >>> (2*x).extract_multiplicatively(2)\n2167            x\n2168 \n2169            >>> (2*x).extract_multiplicatively(3)\n2170 \n2171            >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n2172            x/6\n2173 \n2174         \"\"\"\n2175         c = sympify(c)\n2176         if self is S.NaN:\n2177             return None\n2178         if c is S.One:\n2179             return self\n2180         elif c == self:\n2181             return S.One\n2182 \n2183         if c.is_Add:\n2184             cc, pc = c.primitive()\n2185             if cc is not S.One:\n2186                 c = Mul(cc, pc, evaluate=False)\n2187 \n2188         if c.is_Mul:\n2189             a, b = c.as_two_terms()\n2190             x = self.extract_multiplicatively(a)\n2191             if x is not None:\n2192                 return x.extract_multiplicatively(b)\n2193 \n2194         quotient = self / c\n2195         if self.is_Number:\n2196             if self is S.Infinity:\n2197                 if c.is_positive:\n2198                     return S.Infinity\n2199             elif self is S.NegativeInfinity:\n2200                 if c.is_negative:\n2201                     return S.Infinity\n2202                 elif c.is_positive:\n2203                     return S.NegativeInfinity\n2204             elif self is S.ComplexInfinity:\n2205                 if not c.is_zero:\n2206                     return S.ComplexInfinity\n2207             elif self.is_Integer:\n2208                 if not quotient.is_Integer:\n2209                     return None\n2210                 elif self.is_positive and quotient.is_negative:\n2211                     return None\n2212                 else:\n2213                     return quotient\n2214             elif self.is_Rational:\n2215                 if not quotient.is_Rational:\n2216                     return None\n2217                 elif self.is_positive and quotient.is_negative:\n2218                     return None\n2219                 else:\n2220                     return quotient\n2221             elif self.is_Float:\n2222                 if not quotient.is_Float:\n2223                     return None\n2224                 elif self.is_positive and quotient.is_negative:\n2225                     return None\n2226                 else:\n2227                     return quotient\n2228         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n2229             if quotient.is_Mul and len(quotient.args) == 2:\n2230                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:\n2231                     return quotient\n2232             elif quotient.is_Integer and c.is_Number:\n2233                 return quotient\n2234         elif self.is_Add:\n2235             cs, ps = self.primitive()\n2236             # assert cs >= 1\n2237             if c.is_Number and c is not S.NegativeOne:\n2238                 # assert c != 1 (handled at top)\n2239                 if cs is not S.One:\n2240                     if c.is_negative:\n2241                         xc = -(cs.extract_multiplicatively(-c))\n2242                     else:\n2243                         xc = cs.extract_multiplicatively(c)\n2244                     if xc is not None:\n2245                         return xc*ps  # rely on 2-arg Mul to restore Add\n2246                 return  # |c| != 1 can only be extracted from cs\n2247             if c == ps:\n2248                 return cs\n2249             # check args of ps\n2250             newargs = []\n2251             for arg in ps.args:\n2252                 newarg = arg.extract_multiplicatively(c)\n2253                 if newarg is None:\n2254                     return  # all or nothing\n2255                 newargs.append(newarg)\n2256             # args should be in same order so use unevaluated return\n2257             if cs is not S.One:\n2258                 return Add._from_args([cs*t for t in newargs])\n2259             else:\n2260                 return Add._from_args(newargs)\n2261         elif self.is_Mul:\n2262             args = list(self.args)\n2263             for i, arg in enumerate(args):\n2264                 newarg = arg.extract_multiplicatively(c)\n2265                 if newarg is not None:\n2266                     args[i] = newarg\n2267                     return Mul(*args)\n2268         elif self.is_Pow:\n2269             if c.is_Pow and c.base == self.base:\n2270                 new_exp = self.exp.extract_additively(c.exp)\n2271                 if new_exp is not None:\n2272                     return self.base ** (new_exp)\n2273             elif c == self.base:\n2274                 new_exp = self.exp.extract_additively(1)\n2275                 if new_exp is not None:\n2276                     return self.base ** (new_exp)\n2277 \n2278     def extract_additively(self, c):\n2279         \"\"\"Return self - c if it's possible to subtract c from self and\n2280         make all matching coefficients move towards zero, else return None.\n2281 \n2282         Examples\n2283         ========\n2284 \n2285         >>> from sympy.abc import x, y\n2286         >>> e = 2*x + 3\n2287         >>> e.extract_additively(x + 1)\n2288         x + 2\n2289         >>> e.extract_additively(3*x)\n2290         >>> e.extract_additively(4)\n2291         >>> (y*(x + 1)).extract_additively(x + 1)\n2292         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)\n2293         (x + 1)*(x + 2*y) + 3\n2294 \n2295         Sometimes auto-expansion will return a less simplified result\n2296         than desired; gcd_terms might be used in such cases:\n2297 \n2298         >>> from sympy import gcd_terms\n2299         >>> (4*x*(y + 1) + y).extract_additively(x)\n2300         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y\n2301         >>> gcd_terms(_)\n2302         x*(4*y + 3) + y\n2303 \n2304         See Also\n2305         ========\n2306         extract_multiplicatively\n2307         coeff\n2308         as_coefficient\n2309 \n2310         \"\"\"\n2311 \n2312         c = sympify(c)\n2313         if self is S.NaN:\n2314             return None\n2315         if c is S.Zero:\n2316             return self\n2317         elif c == self:\n2318             return S.Zero\n2319         elif self is S.Zero:\n2320             return None\n2321 \n2322         if self.is_Number:\n2323             if not c.is_Number:\n2324                 return None\n2325             co = self\n2326             diff = co - c\n2327             # XXX should we match types? i.e should 3 - .1 succeed?\n2328             if (co > 0 and diff > 0 and diff < co or\n2329                     co < 0 and diff < 0 and diff > co):\n2330                 return diff\n2331             return None\n2332 \n2333         if c.is_Number:\n2334             co, t = self.as_coeff_Add()\n2335             xa = co.extract_additively(c)\n2336             if xa is None:\n2337                 return None\n2338             return xa + t\n2339 \n2340         # handle the args[0].is_Number case separately\n2341         # since we will have trouble looking for the coeff of\n2342         # a number.\n2343         if c.is_Add and c.args[0].is_Number:\n2344             # whole term as a term factor\n2345             co = self.coeff(c)\n2346             xa0 = (co.extract_additively(1) or 0)*c\n2347             if xa0:\n2348                 diff = self - co*c\n2349                 return (xa0 + (diff.extract_additively(c) or diff)) or None\n2350             # term-wise\n2351             h, t = c.as_coeff_Add()\n2352             sh, st = self.as_coeff_Add()\n2353             xa = sh.extract_additively(h)\n2354             if xa is None:\n2355                 return None\n2356             xa2 = st.extract_additively(t)\n2357             if xa2 is None:\n2358                 return None\n2359             return xa + xa2\n2360 \n2361         # whole term as a term factor\n2362         co = self.coeff(c)\n2363         xa0 = (co.extract_additively(1) or 0)*c\n2364         if xa0:\n2365             diff = self - co*c\n2366             return (xa0 + (diff.extract_additively(c) or diff)) or None\n2367         # term-wise\n2368         coeffs = []\n2369         for a in Add.make_args(c):\n2370             ac, at = a.as_coeff_Mul()\n2371             co = self.coeff(at)\n2372             if not co:\n2373                 return None\n2374             coc, cot = co.as_coeff_Add()\n2375             xa = coc.extract_additively(ac)\n2376             if xa is None:\n2377                 return None\n2378             self -= co*at\n2379             coeffs.append((cot + xa)*at)\n2380         coeffs.append(self)\n2381         return Add(*coeffs)\n2382 \n2383     @property\n2384     def expr_free_symbols(self):\n2385         \"\"\"\n2386         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.\n2387 \n2388         Examples\n2389         ========\n2390 \n2391         >>> from sympy.abc import x, y\n2392         >>> (x + y).expr_free_symbols\n2393         {x, y}\n2394 \n2395         If the expression is contained in a non-expression object, don't return\n2396         the free symbols. Compare:\n2397 \n2398         >>> from sympy import Tuple\n2399         >>> t = Tuple(x + y)\n2400         >>> t.expr_free_symbols\n2401         set()\n2402         >>> t.free_symbols\n2403         {x, y}\n2404         \"\"\"\n2405         return {j for i in self.args for j in i.expr_free_symbols}\n2406 \n2407     def could_extract_minus_sign(self):\n2408         \"\"\"Return True if self is not in a canonical form with respect\n2409         to its sign.\n2410 \n2411         For most expressions, e, there will be a difference in e and -e.\n2412         When there is, True will be returned for one and False for the\n2413         other; False will be returned if there is no difference.\n2414 \n2415         Examples\n2416         ========\n2417 \n2418         >>> from sympy.abc import x, y\n2419         >>> e = x - y\n2420         >>> {i.could_extract_minus_sign() for i in (e, -e)}\n2421         {False, True}\n2422 \n2423         \"\"\"\n2424         negative_self = -self\n2425         if self == negative_self:\n2426             return False  # e.g. zoo*x == -zoo*x\n2427         self_has_minus = (self.extract_multiplicatively(-1) is not None)\n2428         negative_self_has_minus = (\n2429             (negative_self).extract_multiplicatively(-1) is not None)\n2430         if self_has_minus != negative_self_has_minus:\n2431             return self_has_minus\n2432         else:\n2433             if self.is_Add:\n2434                 # We choose the one with less arguments with minus signs\n2435                 all_args = len(self.args)\n2436                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])\n2437                 positive_args = all_args - negative_args\n2438                 if positive_args > negative_args:\n2439                     return False\n2440                 elif positive_args < negative_args:\n2441                     return True\n2442             elif self.is_Mul:\n2443                 # We choose the one with an odd number of minus signs\n2444                 num, den = self.as_numer_denom()\n2445                 args = Mul.make_args(num) + Mul.make_args(den)\n2446                 arg_signs = [arg.could_extract_minus_sign() for arg in args]\n2447                 negative_args = list(filter(None, arg_signs))\n2448                 return len(negative_args) % 2 == 1\n2449 \n2450             # As a last resort, we choose the one with greater value of .sort_key()\n2451             return bool(self.sort_key() < negative_self.sort_key())\n2452 \n2453     def extract_branch_factor(self, allow_half=False):\n2454         \"\"\"\n2455         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.\n2456         Return (z, n).\n2457 \n2458         >>> from sympy import exp_polar, I, pi\n2459         >>> from sympy.abc import x, y\n2460         >>> exp_polar(I*pi).extract_branch_factor()\n2461         (exp_polar(I*pi), 0)\n2462         >>> exp_polar(2*I*pi).extract_branch_factor()\n2463         (1, 1)\n2464         >>> exp_polar(-pi*I).extract_branch_factor()\n2465         (exp_polar(I*pi), -1)\n2466         >>> exp_polar(3*pi*I + x).extract_branch_factor()\n2467         (exp_polar(x + I*pi), 1)\n2468         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()\n2469         (y*exp_polar(2*pi*x), -1)\n2470         >>> exp_polar(-I*pi/2).extract_branch_factor()\n2471         (exp_polar(-I*pi/2), 0)\n2472 \n2473         If allow_half is True, also extract exp_polar(I*pi):\n2474 \n2475         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)\n2476         (1, 1/2)\n2477         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)\n2478         (1, 1)\n2479         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)\n2480         (1, 3/2)\n2481         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)\n2482         (1, -1/2)\n2483         \"\"\"\n2484         from sympy import exp_polar, pi, I, ceiling, Add\n2485         n = S(0)\n2486         res = S(1)\n2487         args = Mul.make_args(self)\n2488         exps = []\n2489         for arg in args:\n2490             if isinstance(arg, exp_polar):\n2491                 exps += [arg.exp]\n2492             else:\n2493                 res *= arg\n2494         piimult = S(0)\n2495         extras = []\n2496         while exps:\n2497             exp = exps.pop()\n2498             if exp.is_Add:\n2499                 exps += exp.args\n2500                 continue\n2501             if exp.is_Mul:\n2502                 coeff = exp.as_coefficient(pi*I)\n2503                 if coeff is not None:\n2504                     piimult += coeff\n2505                     continue\n2506             extras += [exp]\n2507         if piimult.is_number:\n2508             coeff = piimult\n2509             tail = ()\n2510         else:\n2511             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)\n2512         # round down to nearest multiple of 2\n2513         branchfact = ceiling(coeff/2 - S(1)/2)*2\n2514         n += branchfact/2\n2515         c = coeff - branchfact\n2516         if allow_half:\n2517             nc = c.extract_additively(1)\n2518             if nc is not None:\n2519                 n += S(1)/2\n2520                 c = nc\n2521         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)\n2522         if newexp != 0:\n2523             res *= exp_polar(newexp)\n2524         return res, n\n2525 \n2526     def _eval_is_polynomial(self, syms):\n2527         if self.free_symbols.intersection(syms) == set([]):\n2528             return True\n2529         return False\n2530 \n2531     def is_polynomial(self, *syms):\n2532         r\"\"\"\n2533         Return True if self is a polynomial in syms and False otherwise.\n2534 \n2535         This checks if self is an exact polynomial in syms.  This function\n2536         returns False for expressions that are \"polynomials\" with symbolic\n2537         exponents.  Thus, you should be able to apply polynomial algorithms to\n2538         expressions for which this returns True, and Poly(expr, \\*syms) should\n2539         work if and only if expr.is_polynomial(\\*syms) returns True. The\n2540         polynomial does not have to be in expanded form.  If no symbols are\n2541         given, all free symbols in the expression will be used.\n2542 \n2543         This is not part of the assumptions system.  You cannot do\n2544         Symbol('z', polynomial=True).\n2545 \n2546         Examples\n2547         ========\n2548 \n2549         >>> from sympy import Symbol\n2550         >>> x = Symbol('x')\n2551         >>> ((x**2 + 1)**4).is_polynomial(x)\n2552         True\n2553         >>> ((x**2 + 1)**4).is_polynomial()\n2554         True\n2555         >>> (2**x + 1).is_polynomial(x)\n2556         False\n2557 \n2558 \n2559         >>> n = Symbol('n', nonnegative=True, integer=True)\n2560         >>> (x**n + 1).is_polynomial(x)\n2561         False\n2562 \n2563         This function does not attempt any nontrivial simplifications that may\n2564         result in an expression that does not appear to be a polynomial to\n2565         become one.\n2566 \n2567         >>> from sympy import sqrt, factor, cancel\n2568         >>> y = Symbol('y', positive=True)\n2569         >>> a = sqrt(y**2 + 2*y + 1)\n2570         >>> a.is_polynomial(y)\n2571         False\n2572         >>> factor(a)\n2573         y + 1\n2574         >>> factor(a).is_polynomial(y)\n2575         True\n2576 \n2577         >>> b = (y**2 + 2*y + 1)/(y + 1)\n2578         >>> b.is_polynomial(y)\n2579         False\n2580         >>> cancel(b)\n2581         y + 1\n2582         >>> cancel(b).is_polynomial(y)\n2583         True\n2584 \n2585         See also .is_rational_function()\n2586 \n2587         \"\"\"\n2588         if syms:\n2589             syms = set(map(sympify, syms))\n2590         else:\n2591             syms = self.free_symbols\n2592 \n2593         if syms.intersection(self.free_symbols) == set([]):\n2594             # constant polynomial\n2595             return True\n2596         else:\n2597             return self._eval_is_polynomial(syms)\n2598 \n2599     def _eval_is_rational_function(self, syms):\n2600         if self.free_symbols.intersection(syms) == set([]):\n2601             return True\n2602         return False\n2603 \n2604     def is_rational_function(self, *syms):\n2605         \"\"\"\n2606         Test whether function is a ratio of two polynomials in the given\n2607         symbols, syms. When syms is not given, all free symbols will be used.\n2608         The rational function does not have to be in expanded or in any kind of\n2609         canonical form.\n2610 \n2611         This function returns False for expressions that are \"rational\n2612         functions\" with symbolic exponents.  Thus, you should be able to call\n2613         .as_numer_denom() and apply polynomial algorithms to the result for\n2614         expressions for which this returns True.\n2615 \n2616         This is not part of the assumptions system.  You cannot do\n2617         Symbol('z', rational_function=True).\n2618 \n2619         Examples\n2620         ========\n2621 \n2622         >>> from sympy import Symbol, sin\n2623         >>> from sympy.abc import x, y\n2624 \n2625         >>> (x/y).is_rational_function()\n2626         True\n2627 \n2628         >>> (x**2).is_rational_function()\n2629         True\n2630 \n2631         >>> (x/sin(y)).is_rational_function(y)\n2632         False\n2633 \n2634         >>> n = Symbol('n', integer=True)\n2635         >>> (x**n + 1).is_rational_function(x)\n2636         False\n2637 \n2638         This function does not attempt any nontrivial simplifications that may\n2639         result in an expression that does not appear to be a rational function\n2640         to become one.\n2641 \n2642         >>> from sympy import sqrt, factor\n2643         >>> y = Symbol('y', positive=True)\n2644         >>> a = sqrt(y**2 + 2*y + 1)/y\n2645         >>> a.is_rational_function(y)\n2646         False\n2647         >>> factor(a)\n2648         (y + 1)/y\n2649         >>> factor(a).is_rational_function(y)\n2650         True\n2651 \n2652         See also is_algebraic_expr().\n2653 \n2654         \"\"\"\n2655         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:\n2656             return False\n2657 \n2658         if syms:\n2659             syms = set(map(sympify, syms))\n2660         else:\n2661             syms = self.free_symbols\n2662 \n2663         if syms.intersection(self.free_symbols) == set([]):\n2664             # constant rational function\n2665             return True\n2666         else:\n2667             return self._eval_is_rational_function(syms)\n2668 \n2669     def _eval_is_algebraic_expr(self, syms):\n2670         if self.free_symbols.intersection(syms) == set([]):\n2671             return True\n2672         return False\n2673 \n2674     def is_algebraic_expr(self, *syms):\n2675         \"\"\"\n2676         This tests whether a given expression is algebraic or not, in the\n2677         given symbols, syms. When syms is not given, all free symbols\n2678         will be used. The rational function does not have to be in expanded\n2679         or in any kind of canonical form.\n2680 \n2681         This function returns False for expressions that are \"algebraic\n2682         expressions\" with symbolic exponents. This is a simple extension to the\n2683         is_rational_function, including rational exponentiation.\n2684 \n2685         Examples\n2686         ========\n2687 \n2688         >>> from sympy import Symbol, sqrt\n2689         >>> x = Symbol('x', real=True)\n2690         >>> sqrt(1 + x).is_rational_function()\n2691         False\n2692         >>> sqrt(1 + x).is_algebraic_expr()\n2693         True\n2694 \n2695         This function does not attempt any nontrivial simplifications that may\n2696         result in an expression that does not appear to be an algebraic\n2697         expression to become one.\n2698 \n2699         >>> from sympy import exp, factor\n2700         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)\n2701         >>> a.is_algebraic_expr(x)\n2702         False\n2703         >>> factor(a).is_algebraic_expr()\n2704         True\n2705 \n2706         See Also\n2707         ========\n2708         is_rational_function()\n2709 \n2710         References\n2711         ==========\n2712 \n2713         - https://en.wikipedia.org/wiki/Algebraic_expression\n2714 \n2715         \"\"\"\n2716         if syms:\n2717             syms = set(map(sympify, syms))\n2718         else:\n2719             syms = self.free_symbols\n2720 \n2721         if syms.intersection(self.free_symbols) == set([]):\n2722             # constant algebraic expression\n2723             return True\n2724         else:\n2725             return self._eval_is_algebraic_expr(syms)\n2726 \n2727     ###################################################################################\n2728     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################\n2729     ###################################################################################\n2730 \n2731     def series(self, x=None, x0=0, n=6, dir=\"+\", logx=None):\n2732         \"\"\"\n2733         Series expansion of \"self\" around ``x = x0`` yielding either terms of\n2734         the series one by one (the lazy series given when n=None), else\n2735         all the terms at once when n != None.\n2736 \n2737         Returns the series expansion of \"self\" around the point ``x = x0``\n2738         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).\n2739 \n2740         If ``x=None`` and ``self`` is univariate, the univariate symbol will\n2741         be supplied, otherwise an error will be raised.\n2742 \n2743         Parameters\n2744         ==========\n2745 \n2746         expr : Expression\n2747                The expression whose series is to be expanded.\n2748 \n2749         x : Symbol\n2750             It is the variable of the expression to be calculated.\n2751 \n2752         x0 : Value\n2753              The value around which ``x`` is calculated. Can be any value\n2754              from ``-oo`` to ``oo``.\n2755 \n2756         n : Value\n2757             The number of terms upto which the series is to be expanded.\n2758 \n2759         dir : String, optional\n2760               The series-expansion can be bi-directional. If ``dir=\"+\"``,\n2761               then (x->x0+). If ``dir=\"-\", then (x->x0-). For infinite\n2762               ``x0`` (``oo`` or ``-oo``), the ``dir`` argument is determined\n2763               from the direction of the infinity (i.e., ``dir=\"-\"`` for\n2764               ``oo``).\n2765 \n2766         logx : optional\n2767                It is used to replace any log(x) in the returned series with a\n2768                symbolic value rather than evaluating the actual value.\n2769 \n2770         Examples\n2771         ========\n2772 \n2773         >>> from sympy import cos, exp, tan, oo, series\n2774         >>> from sympy.abc import x, y\n2775         >>> cos(x).series()\n2776         1 - x**2/2 + x**4/24 + O(x**6)\n2777         >>> cos(x).series(n=4)\n2778         1 - x**2/2 + O(x**4)\n2779         >>> cos(x).series(x, x0=1, n=2)\n2780         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))\n2781         >>> e = cos(x + exp(y))\n2782         >>> e.series(y, n=2)\n2783         cos(x + 1) - y*sin(x + 1) + O(y**2)\n2784         >>> e.series(x, n=2)\n2785         cos(exp(y)) - x*sin(exp(y)) + O(x**2)\n2786 \n2787         If ``n=None`` then a generator of the series terms will be returned.\n2788 \n2789         >>> term=cos(x).series(n=None)\n2790         >>> [next(term) for i in range(2)]\n2791         [1, -x**2/2]\n2792 \n2793         For ``dir=+`` (default) the series is calculated from the right and\n2794         for ``dir=-`` the series from the left. For smooth functions this\n2795         flag will not alter the results.\n2796 \n2797         >>> abs(x).series(dir=\"+\")\n2798         x\n2799         >>> abs(x).series(dir=\"-\")\n2800         -x\n2801         >>> f = tan(x)\n2802         >>> f.series(x, 2, 6, \"+\")\n2803         tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +\n2804         (x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +\n2805         5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +\n2806         2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))\n2807 \n2808         >>> f.series(x, 2, 3, \"-\")\n2809         tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))\n2810         + O((x - 2)**3, (x, 2))\n2811 \n2812         Returns\n2813         =======\n2814 \n2815         Expr : Expression\n2816             Series expansion of the expression about x0\n2817 \n2818         Raises\n2819         ======\n2820 \n2821         TypeError\n2822             If \"n\" and \"x0\" are infinity objects\n2823 \n2824         PoleError\n2825             If \"x0\" is an infinity object\n2826 \n2827         \"\"\"\n2828         from sympy import collect, Dummy, Order, Rational, Symbol, ceiling\n2829         if x is None:\n2830             syms = self.free_symbols\n2831             if not syms:\n2832                 return self\n2833             elif len(syms) > 1:\n2834                 raise ValueError('x must be given for multivariate functions.')\n2835             x = syms.pop()\n2836 \n2837         if isinstance(x, Symbol):\n2838             dep = x in self.free_symbols\n2839         else:\n2840             d = Dummy()\n2841             dep = d in self.xreplace({x: d}).free_symbols\n2842         if not dep:\n2843             if n is None:\n2844                 return (s for s in [self])\n2845             else:\n2846                 return self\n2847 \n2848         if len(dir) != 1 or dir not in '+-':\n2849             raise ValueError(\"Dir must be '+' or '-'\")\n2850 \n2851         if x0 in [S.Infinity, S.NegativeInfinity]:\n2852             sgn = 1 if x0 is S.Infinity else -1\n2853             s = self.subs(x, sgn/x).series(x, n=n, dir='+')\n2854             if n is None:\n2855                 return (si.subs(x, sgn/x) for si in s)\n2856             return s.subs(x, sgn/x)\n2857 \n2858 \n2859         # use rep to shift origin to x0 and change sign (if dir is negative)\n2860         # and undo the process with rep2\n2861         if x0 or dir == '-':\n2862             if dir == '-':\n2863                 rep = -x + x0\n2864                 rep2 = -x\n2865                 rep2b = x0\n2866             else:\n2867                 rep = x + x0\n2868                 rep2 = x\n2869                 rep2b = -x0\n2870             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)\n2871             if n is None:  # lseries...\n2872                 return (si.subs(x, rep2 + rep2b) for si in s)\n2873             return s.subs(x, rep2 + rep2b)\n2874 \n2875         # from here on it's x0=0 and dir='+' handling\n2876 \n2877         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:\n2878             # replace x with an x that has a positive assumption\n2879             xpos = Dummy('x', positive=True, finite=True)\n2880             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)\n2881             if n is None:\n2882                 return (s.subs(xpos, x) for s in rv)\n2883             else:\n2884                 return rv.subs(xpos, x)\n2885 \n2886         if n is not None:  # nseries handling\n2887             s1 = self._eval_nseries(x, n=n, logx=logx)\n2888             o = s1.getO() or S.Zero\n2889             if o:\n2890                 # make sure the requested order is returned\n2891                 ngot = o.getn()\n2892                 if ngot > n:\n2893                     # leave o in its current form (e.g. with x*log(x)) so\n2894                     # it eats terms properly, then replace it below\n2895                     if n != 0:\n2896                         s1 += o.subs(x, x**Rational(n, ngot))\n2897                     else:\n2898                         s1 += Order(1, x)\n2899                 elif ngot < n:\n2900                     # increase the requested number of terms to get the desired\n2901                     # number keep increasing (up to 9) until the received order\n2902                     # is different than the original order and then predict how\n2903                     # many additional terms are needed\n2904                     for more in range(1, 9):\n2905                         s1 = self._eval_nseries(x, n=n + more, logx=logx)\n2906                         newn = s1.getn()\n2907                         if newn != ngot:\n2908                             ndo = n + ceiling((n - ngot)*more/(newn - ngot))\n2909                             s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2910                             while s1.getn() < n:\n2911                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2912                                 ndo += 1\n2913                             break\n2914                     else:\n2915                         raise ValueError('Could not calculate %s terms for %s'\n2916                                          % (str(n), self))\n2917                     s1 += Order(x**n, x)\n2918                 o = s1.getO()\n2919                 s1 = s1.removeO()\n2920             else:\n2921                 o = Order(x**n, x)\n2922                 s1done = s1.doit()\n2923                 if (s1done + o).removeO() == s1done:\n2924                     o = S.Zero\n2925 \n2926             try:\n2927                 return collect(s1, x) + o\n2928             except NotImplementedError:\n2929                 return s1 + o\n2930 \n2931         else:  # lseries handling\n2932             def yield_lseries(s):\n2933                 \"\"\"Return terms of lseries one at a time.\"\"\"\n2934                 for si in s:\n2935                     if not si.is_Add:\n2936                         yield si\n2937                         continue\n2938                     # yield terms 1 at a time if possible\n2939                     # by increasing order until all the\n2940                     # terms have been returned\n2941                     yielded = 0\n2942                     o = Order(si, x)*x\n2943                     ndid = 0\n2944                     ndo = len(si.args)\n2945                     while 1:\n2946                         do = (si - yielded + o).removeO()\n2947                         o *= x\n2948                         if not do or do.is_Order:\n2949                             continue\n2950                         if do.is_Add:\n2951                             ndid += len(do.args)\n2952                         else:\n2953                             ndid += 1\n2954                         yield do\n2955                         if ndid == ndo:\n2956                             break\n2957                         yielded += do\n2958 \n2959             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))\n2960 \n2961     def taylor_term(self, n, x, *previous_terms):\n2962         \"\"\"General method for the taylor term.\n2963 \n2964         This method is slow, because it differentiates n-times. Subclasses can\n2965         redefine it to make it faster by using the \"previous_terms\".\n2966         \"\"\"\n2967         from sympy import Dummy, factorial\n2968         x = sympify(x)\n2969         _x = Dummy('x')\n2970         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)\n2971 \n2972     def lseries(self, x=None, x0=0, dir='+', logx=None):\n2973         \"\"\"\n2974         Wrapper for series yielding an iterator of the terms of the series.\n2975 \n2976         Note: an infinite series will yield an infinite iterator. The following,\n2977         for exaxmple, will never terminate. It will just keep printing terms\n2978         of the sin(x) series::\n2979 \n2980           for term in sin(x).lseries(x):\n2981               print term\n2982 \n2983         The advantage of lseries() over nseries() is that many times you are\n2984         just interested in the next term in the series (i.e. the first term for\n2985         example), but you don't know how many you should ask for in nseries()\n2986         using the \"n\" parameter.\n2987 \n2988         See also nseries().\n2989         \"\"\"\n2990         return self.series(x, x0, n=None, dir=dir, logx=logx)\n2991 \n2992     def _eval_lseries(self, x, logx=None):\n2993         # default implementation of lseries is using nseries(), and adaptively\n2994         # increasing the \"n\". As you can see, it is not very efficient, because\n2995         # we are calculating the series over and over again. Subclasses should\n2996         # override this method and implement much more efficient yielding of\n2997         # terms.\n2998         n = 0\n2999         series = self._eval_nseries(x, n=n, logx=logx)\n3000         if not series.is_Order:\n3001             if series.is_Add:\n3002                 yield series.removeO()\n3003             else:\n3004                 yield series\n3005             return\n3006 \n3007         while series.is_Order:\n3008             n += 1\n3009             series = self._eval_nseries(x, n=n, logx=logx)\n3010         e = series.removeO()\n3011         yield e\n3012         while 1:\n3013             while 1:\n3014                 n += 1\n3015                 series = self._eval_nseries(x, n=n, logx=logx).removeO()\n3016                 if e != series:\n3017                     break\n3018             yield series - e\n3019             e = series\n3020 \n3021     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):\n3022         \"\"\"\n3023         Wrapper to _eval_nseries if assumptions allow, else to series.\n3024 \n3025         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is\n3026         called. This calculates \"n\" terms in the innermost expressions and\n3027         then builds up the final series just by \"cross-multiplying\" everything\n3028         out.\n3029 \n3030         The optional ``logx`` parameter can be used to replace any log(x) in the\n3031         returned series with a symbolic value to avoid evaluating log(x) at 0. A\n3032         symbol to use in place of log(x) should be provided.\n3033 \n3034         Advantage -- it's fast, because we don't have to determine how many\n3035         terms we need to calculate in advance.\n3036 \n3037         Disadvantage -- you may end up with less terms than you may have\n3038         expected, but the O(x**n) term appended will always be correct and\n3039         so the result, though perhaps shorter, will also be correct.\n3040 \n3041         If any of those assumptions is not met, this is treated like a\n3042         wrapper to series which will try harder to return the correct\n3043         number of terms.\n3044 \n3045         See also lseries().\n3046 \n3047         Examples\n3048         ========\n3049 \n3050         >>> from sympy import sin, log, Symbol\n3051         >>> from sympy.abc import x, y\n3052         >>> sin(x).nseries(x, 0, 6)\n3053         x - x**3/6 + x**5/120 + O(x**6)\n3054         >>> log(x+1).nseries(x, 0, 5)\n3055         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)\n3056 \n3057         Handling of the ``logx`` parameter --- in the following example the\n3058         expansion fails since ``sin`` does not have an asymptotic expansion\n3059         at -oo (the limit of log(x) as x approaches 0):\n3060 \n3061         >>> e = sin(log(x))\n3062         >>> e.nseries(x, 0, 6)\n3063         Traceback (most recent call last):\n3064         ...\n3065         PoleError: ...\n3066         ...\n3067         >>> logx = Symbol('logx')\n3068         >>> e.nseries(x, 0, 6, logx=logx)\n3069         sin(logx)\n3070 \n3071         In the following example, the expansion works but gives only an Order term\n3072         unless the ``logx`` parameter is used:\n3073 \n3074         >>> e = x**y\n3075         >>> e.nseries(x, 0, 2)\n3076         O(log(x)**2)\n3077         >>> e.nseries(x, 0, 2, logx=logx)\n3078         exp(logx*y)\n3079 \n3080         \"\"\"\n3081         if x and not x in self.free_symbols:\n3082             return self\n3083         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):\n3084             return self.series(x, x0, n, dir)\n3085         else:\n3086             return self._eval_nseries(x, n=n, logx=logx)\n3087 \n3088     def _eval_nseries(self, x, n, logx):\n3089         \"\"\"\n3090         Return terms of series for self up to O(x**n) at x=0\n3091         from the positive direction.\n3092 \n3093         This is a method that should be overridden in subclasses. Users should\n3094         never call this method directly (use .nseries() instead), so you don't\n3095         have to write docstrings for _eval_nseries().\n3096         \"\"\"\n3097         from sympy.utilities.misc import filldedent\n3098         raise NotImplementedError(filldedent(\"\"\"\n3099                      The _eval_nseries method should be added to\n3100                      %s to give terms up to O(x**n) at x=0\n3101                      from the positive direction so it is available when\n3102                      nseries calls it.\"\"\" % self.func)\n3103                      )\n3104 \n3105     def limit(self, x, xlim, dir='+'):\n3106         \"\"\" Compute limit x->xlim.\n3107         \"\"\"\n3108         from sympy.series.limits import limit\n3109         return limit(self, x, xlim, dir)\n3110 \n3111     def compute_leading_term(self, x, logx=None):\n3112         \"\"\"\n3113         as_leading_term is only allowed for results of .series()\n3114         This is a wrapper to compute a series first.\n3115         \"\"\"\n3116         from sympy import Dummy, log\n3117         from sympy.series.gruntz import calculate_series\n3118 \n3119         if self.removeO() == 0:\n3120             return self\n3121 \n3122         if logx is None:\n3123             d = Dummy('logx')\n3124             s = calculate_series(self, x, d).subs(d, log(x))\n3125         else:\n3126             s = calculate_series(self, x, logx)\n3127 \n3128         return s.as_leading_term(x)\n3129 \n3130     @cacheit\n3131     def as_leading_term(self, *symbols):\n3132         \"\"\"\n3133         Returns the leading (nonzero) term of the series expansion of self.\n3134 \n3135         The _eval_as_leading_term routines are used to do this, and they must\n3136         always return a non-zero value.\n3137 \n3138         Examples\n3139         ========\n3140 \n3141         >>> from sympy.abc import x\n3142         >>> (1 + x + x**2).as_leading_term(x)\n3143         1\n3144         >>> (1/x**2 + x + x**2).as_leading_term(x)\n3145         x**(-2)\n3146 \n3147         \"\"\"\n3148         from sympy import powsimp\n3149         if len(symbols) > 1:\n3150             c = self\n3151             for x in symbols:\n3152                 c = c.as_leading_term(x)\n3153             return c\n3154         elif not symbols:\n3155             return self\n3156         x = sympify(symbols[0])\n3157         if not x.is_symbol:\n3158             raise ValueError('expecting a Symbol but got %s' % x)\n3159         if x not in self.free_symbols:\n3160             return self\n3161         obj = self._eval_as_leading_term(x)\n3162         if obj is not None:\n3163             return powsimp(obj, deep=True, combine='exp')\n3164         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))\n3165 \n3166     def _eval_as_leading_term(self, x):\n3167         return self\n3168 \n3169     def as_coeff_exponent(self, x):\n3170         \"\"\" ``c*x**e -> c,e`` where x can be any symbolic expression.\n3171         \"\"\"\n3172         from sympy import collect\n3173         s = collect(self, x)\n3174         c, p = s.as_coeff_mul(x)\n3175         if len(p) == 1:\n3176             b, e = p[0].as_base_exp()\n3177             if b == x:\n3178                 return c, e\n3179         return s, S.Zero\n3180 \n3181     def leadterm(self, x):\n3182         \"\"\"\n3183         Returns the leading term a*x**b as a tuple (a, b).\n3184 \n3185         Examples\n3186         ========\n3187 \n3188         >>> from sympy.abc import x\n3189         >>> (1+x+x**2).leadterm(x)\n3190         (1, 0)\n3191         >>> (1/x**2+x+x**2).leadterm(x)\n3192         (1, -2)\n3193 \n3194         \"\"\"\n3195         from sympy import Dummy, log\n3196         l = self.as_leading_term(x)\n3197         d = Dummy('logx')\n3198         if l.has(log(x)):\n3199             l = l.subs(log(x), d)\n3200         c, e = l.as_coeff_exponent(x)\n3201         if x in c.free_symbols:\n3202             from sympy.utilities.misc import filldedent\n3203             raise ValueError(filldedent(\"\"\"\n3204                 cannot compute leadterm(%s, %s). The coefficient\n3205                 should have been free of x but got %s\"\"\" % (self, x, c)))\n3206         c = c.subs(d, log(x))\n3207         return c, e\n3208 \n3209     def as_coeff_Mul(self, rational=False):\n3210         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n3211         return S.One, self\n3212 \n3213     def as_coeff_Add(self, rational=False):\n3214         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n3215         return S.Zero, self\n3216 \n3217     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,\n3218             full=False):\n3219         \"\"\"\n3220         Compute formal power power series of self.\n3221 \n3222         See the docstring of the :func:`fps` function in sympy.series.formal for\n3223         more information.\n3224         \"\"\"\n3225         from sympy.series.formal import fps\n3226 \n3227         return fps(self, x, x0, dir, hyper, order, rational, full)\n3228 \n3229     def fourier_series(self, limits=None):\n3230         \"\"\"Compute fourier sine/cosine series of self.\n3231 \n3232         See the docstring of the :func:`fourier_series` in sympy.series.fourier\n3233         for more information.\n3234         \"\"\"\n3235         from sympy.series.fourier import fourier_series\n3236 \n3237         return fourier_series(self, limits)\n3238 \n3239     ###################################################################################\n3240     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################\n3241     ###################################################################################\n3242 \n3243     def diff(self, *symbols, **assumptions):\n3244         assumptions.setdefault(\"evaluate\", True)\n3245         return Derivative(self, *symbols, **assumptions)\n3246 \n3247     ###########################################################################\n3248     ###################### EXPRESSION EXPANSION METHODS #######################\n3249     ###########################################################################\n3250 \n3251     # Relevant subclasses should override _eval_expand_hint() methods.  See\n3252     # the docstring of expand() for more info.\n3253 \n3254     def _eval_expand_complex(self, **hints):\n3255         real, imag = self.as_real_imag(**hints)\n3256         return real + S.ImaginaryUnit*imag\n3257 \n3258     @staticmethod\n3259     def _expand_hint(expr, hint, deep=True, **hints):\n3260         \"\"\"\n3261         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.\n3262 \n3263         Returns ``(expr, hit)``, where expr is the (possibly) expanded\n3264         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and\n3265         ``False`` otherwise.\n3266         \"\"\"\n3267         hit = False\n3268         # XXX: Hack to support non-Basic args\n3269         #              |\n3270         #              V\n3271         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:\n3272             sargs = []\n3273             for arg in expr.args:\n3274                 arg, arghit = Expr._expand_hint(arg, hint, **hints)\n3275                 hit |= arghit\n3276                 sargs.append(arg)\n3277 \n3278             if hit:\n3279                 expr = expr.func(*sargs)\n3280 \n3281         if hasattr(expr, hint):\n3282             newexpr = getattr(expr, hint)(**hints)\n3283             if newexpr != expr:\n3284                 return (newexpr, True)\n3285 \n3286         return (expr, hit)\n3287 \n3288     @cacheit\n3289     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,\n3290             mul=True, log=True, multinomial=True, basic=True, **hints):\n3291         \"\"\"\n3292         Expand an expression using hints.\n3293 \n3294         See the docstring of the expand() function in sympy.core.function for\n3295         more information.\n3296 \n3297         \"\"\"\n3298         from sympy.simplify.radsimp import fraction\n3299 \n3300         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,\n3301            log=log, multinomial=multinomial, basic=basic)\n3302 \n3303         expr = self\n3304         if hints.pop('frac', False):\n3305             n, d = [a.expand(deep=deep, modulus=modulus, **hints)\n3306                     for a in fraction(self)]\n3307             return n/d\n3308         elif hints.pop('denom', False):\n3309             n, d = fraction(self)\n3310             return n/d.expand(deep=deep, modulus=modulus, **hints)\n3311         elif hints.pop('numer', False):\n3312             n, d = fraction(self)\n3313             return n.expand(deep=deep, modulus=modulus, **hints)/d\n3314 \n3315         # Although the hints are sorted here, an earlier hint may get applied\n3316         # at a given node in the expression tree before another because of how\n3317         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +\n3318         # x*z) because while applying log at the top level, log and mul are\n3319         # applied at the deeper level in the tree so that when the log at the\n3320         # upper level gets applied, the mul has already been applied at the\n3321         # lower level.\n3322 \n3323         # Additionally, because hints are only applied once, the expression\n3324         # may not be expanded all the way.   For example, if mul is applied\n3325         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For\n3326         # now, we just use a special case to make multinomial run before mul,\n3327         # so that at least polynomials will be expanded all the way.  In the\n3328         # future, smarter heuristics should be applied.\n3329         # TODO: Smarter heuristics\n3330 \n3331         def _expand_hint_key(hint):\n3332             \"\"\"Make multinomial come before mul\"\"\"\n3333             if hint == 'mul':\n3334                 return 'mulz'\n3335             return hint\n3336 \n3337         for hint in sorted(hints.keys(), key=_expand_hint_key):\n3338             use_hint = hints[hint]\n3339             if use_hint:\n3340                 hint = '_eval_expand_' + hint\n3341                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n3342 \n3343         while True:\n3344             was = expr\n3345             if hints.get('multinomial', False):\n3346                 expr, _ = Expr._expand_hint(\n3347                     expr, '_eval_expand_multinomial', deep=deep, **hints)\n3348             if hints.get('mul', False):\n3349                 expr, _ = Expr._expand_hint(\n3350                     expr, '_eval_expand_mul', deep=deep, **hints)\n3351             if hints.get('log', False):\n3352                 expr, _ = Expr._expand_hint(\n3353                     expr, '_eval_expand_log', deep=deep, **hints)\n3354             if expr == was:\n3355                 break\n3356 \n3357         if modulus is not None:\n3358             modulus = sympify(modulus)\n3359 \n3360             if not modulus.is_Integer or modulus <= 0:\n3361                 raise ValueError(\n3362                     \"modulus must be a positive integer, got %s\" % modulus)\n3363 \n3364             terms = []\n3365 \n3366             for term in Add.make_args(expr):\n3367                 coeff, tail = term.as_coeff_Mul(rational=True)\n3368 \n3369                 coeff %= modulus\n3370 \n3371                 if coeff:\n3372                     terms.append(coeff*tail)\n3373 \n3374             expr = Add(*terms)\n3375 \n3376         return expr\n3377 \n3378     ###########################################################################\n3379     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################\n3380     ###########################################################################\n3381 \n3382     def integrate(self, *args, **kwargs):\n3383         \"\"\"See the integrate function in sympy.integrals\"\"\"\n3384         from sympy.integrals import integrate\n3385         return integrate(self, *args, **kwargs)\n3386 \n3387     def simplify(self, ratio=1.7, measure=None, rational=False, inverse=False):\n3388         \"\"\"See the simplify function in sympy.simplify\"\"\"\n3389         from sympy.simplify import simplify\n3390         from sympy.core.function import count_ops\n3391         measure = measure or count_ops\n3392         return simplify(self, ratio, measure)\n3393 \n3394     def nsimplify(self, constants=[], tolerance=None, full=False):\n3395         \"\"\"See the nsimplify function in sympy.simplify\"\"\"\n3396         from sympy.simplify import nsimplify\n3397         return nsimplify(self, constants, tolerance, full)\n3398 \n3399     def separate(self, deep=False, force=False):\n3400         \"\"\"See the separate function in sympy.simplify\"\"\"\n3401         from sympy.core.function import expand_power_base\n3402         return expand_power_base(self, deep=deep, force=force)\n3403 \n3404     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):\n3405         \"\"\"See the collect function in sympy.simplify\"\"\"\n3406         from sympy.simplify import collect\n3407         return collect(self, syms, func, evaluate, exact, distribute_order_term)\n3408 \n3409     def together(self, *args, **kwargs):\n3410         \"\"\"See the together function in sympy.polys\"\"\"\n3411         from sympy.polys import together\n3412         return together(self, *args, **kwargs)\n3413 \n3414     def apart(self, x=None, **args):\n3415         \"\"\"See the apart function in sympy.polys\"\"\"\n3416         from sympy.polys import apart\n3417         return apart(self, x, **args)\n3418 \n3419     def ratsimp(self):\n3420         \"\"\"See the ratsimp function in sympy.simplify\"\"\"\n3421         from sympy.simplify import ratsimp\n3422         return ratsimp(self)\n3423 \n3424     def trigsimp(self, **args):\n3425         \"\"\"See the trigsimp function in sympy.simplify\"\"\"\n3426         from sympy.simplify import trigsimp\n3427         return trigsimp(self, **args)\n3428 \n3429     def radsimp(self, **kwargs):\n3430         \"\"\"See the radsimp function in sympy.simplify\"\"\"\n3431         from sympy.simplify import radsimp\n3432         return radsimp(self, **kwargs)\n3433 \n3434     def powsimp(self, *args, **kwargs):\n3435         \"\"\"See the powsimp function in sympy.simplify\"\"\"\n3436         from sympy.simplify import powsimp\n3437         return powsimp(self, *args, **kwargs)\n3438 \n3439     def combsimp(self):\n3440         \"\"\"See the combsimp function in sympy.simplify\"\"\"\n3441         from sympy.simplify import combsimp\n3442         return combsimp(self)\n3443 \n3444     def gammasimp(self):\n3445         \"\"\"See the gammasimp function in sympy.simplify\"\"\"\n3446         from sympy.simplify import gammasimp\n3447         return gammasimp(self)\n3448 \n3449     def factor(self, *gens, **args):\n3450         \"\"\"See the factor() function in sympy.polys.polytools\"\"\"\n3451         from sympy.polys import factor\n3452         return factor(self, *gens, **args)\n3453 \n3454     def refine(self, assumption=True):\n3455         \"\"\"See the refine function in sympy.assumptions\"\"\"\n3456         from sympy.assumptions import refine\n3457         return refine(self, assumption)\n3458 \n3459     def cancel(self, *gens, **args):\n3460         \"\"\"See the cancel function in sympy.polys\"\"\"\n3461         from sympy.polys import cancel\n3462         return cancel(self, *gens, **args)\n3463 \n3464     def invert(self, g, *gens, **args):\n3465         \"\"\"Return the multiplicative inverse of ``self`` mod ``g``\n3466         where ``self`` (and ``g``) may be symbolic expressions).\n3467 \n3468         See Also\n3469         ========\n3470         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert\n3471         \"\"\"\n3472         from sympy.polys.polytools import invert\n3473         from sympy.core.numbers import mod_inverse\n3474         if self.is_number and getattr(g, 'is_number', True):\n3475             return mod_inverse(self, g)\n3476         return invert(self, g, *gens, **args)\n3477 \n3478     def round(self, n=None):\n3479         \"\"\"Return x rounded to the given decimal place.\n3480 \n3481         If a complex number would results, apply round to the real\n3482         and imaginary components of the number.\n3483 \n3484         Examples\n3485         ========\n3486 \n3487         >>> from sympy import pi, E, I, S, Add, Mul, Number\n3488         >>> pi.round()\n3489         3\n3490         >>> pi.round(2)\n3491         3.14\n3492         >>> (2*pi + E*I).round()\n3493         6 + 3*I\n3494 \n3495         The round method has a chopping effect:\n3496 \n3497         >>> (2*pi + I/10).round()\n3498         6\n3499         >>> (pi/10 + 2*I).round()\n3500         2*I\n3501         >>> (pi/10 + E*I).round(2)\n3502         0.31 + 2.72*I\n3503 \n3504         Notes\n3505         =====\n3506 \n3507         The Python builtin function, round, always returns a\n3508         float in Python 2 while the SymPy round method (and\n3509         round with a Number argument in Python 3) returns a\n3510         Number.\n3511 \n3512         >>> from sympy.core.compatibility import PY3\n3513         >>> isinstance(round(S(123), -2), Number if PY3 else float)\n3514         True\n3515 \n3516         For a consistent behavior, and Python 3 rounding\n3517         rules, import `round` from sympy.core.compatibility.\n3518 \n3519         >>> from sympy.core.compatibility import round\n3520         >>> isinstance(round(S(123), -2), Number)\n3521         True\n3522         \"\"\"\n3523         from sympy.core.power import integer_log\n3524         from sympy.core.numbers import Float\n3525 \n3526         x = self\n3527 \n3528         if not x.is_number:\n3529             raise TypeError(\"can't round symbolic expression\")\n3530         if not x.is_Atom:\n3531             if not pure_complex(x.n(2), or_real=True):\n3532                 raise TypeError(\n3533                     'Expected a number but got %s:' % func_name(x))\n3534         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n3535             return x\n3536         if not x.is_extended_real:\n3537             i, r = x.as_real_imag()\n3538             return i.round(n) + S.ImaginaryUnit*r.round(n)\n3539         if not x:\n3540             return S.Zero if n is None else x\n3541 \n3542 \n3543         p = as_int(n or 0)\n3544 \n3545         if x.is_Integer:\n3546             # XXX return Integer(round(int(x), p)) when Py2 is dropped\n3547             if p >= 0:\n3548                 return x\n3549             m = 10**-p\n3550             i, r = divmod(abs(x), m)\n3551             if i%2 and 2*r == m:\n3552               i += 1\n3553             elif 2*r > m:\n3554                 i += 1\n3555             if x < 0:\n3556                 i *= -1\n3557             return i*m\n3558 \n3559         digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1\n3560         allow = digits_needed = digits_to_decimal + p\n3561         precs = [f._prec for f in x.atoms(Float)]\n3562         dps = prec_to_dps(max(precs)) if precs else None\n3563         if dps is None:\n3564             # assume everything is exact so use the Python\n3565             # float default or whatever was requested\n3566             dps = max(15, allow)\n3567         else:\n3568             allow = min(allow, dps)\n3569         # this will shift all digits to right of decimal\n3570         # and give us dps to work with as an int\n3571         shift = -digits_to_decimal + dps\n3572         extra = 1  # how far we look past known digits\n3573         # NOTE\n3574         # mpmath will calculate the binary representation to\n3575         # an arbitrary number of digits but we must base our\n3576         # answer on a finite number of those digits, e.g.\n3577         # .575 2589569785738035/2**52 in binary.\n3578         # mpmath shows us that the first 18 digits are\n3579         #     >>> Float(.575).n(18)\n3580         #     0.574999999999999956\n3581         # The default precision is 15 digits and if we ask\n3582         # for 15 we get\n3583         #     >>> Float(.575).n(15)\n3584         #     0.575000000000000\n3585         # mpmath handles rounding at the 15th digit. But we\n3586         # need to be careful since the user might be asking\n3587         # for rounding at the last digit and our semantics\n3588         # are to round toward the even final digit when there\n3589         # is a tie. So the extra digit will be used to make\n3590         # that decision. In this case, the value is the same\n3591         # to 15 digits:\n3592         #     >>> Float(.575).n(16)\n3593         #     0.5750000000000000\n3594         # Now converting this to the 15 known digits gives\n3595         #     575000000000000.0\n3596         # which rounds to integer\n3597         #    5750000000000000\n3598         # And now we can round to the desired digt, e.g. at\n3599         # the second from the left and we get\n3600         #    5800000000000000\n3601         # and rescaling that gives\n3602         #    0.58\n3603         # as the final result.\n3604         # If the value is made slightly less than 0.575 we might\n3605         # still obtain the same value:\n3606         #    >>> Float(.575-1e-16).n(16)*10**15\n3607         #    574999999999999.8\n3608         # What 15 digits best represents the known digits (which are\n3609         # to the left of the decimal? 5750000000000000, the same as\n3610         # before. The only way we will round down (in this case) is\n3611         # if we declared that we had more than 15 digits of precision.\n3612         # For example, if we use 16 digits of precision, the integer\n3613         # we deal with is\n3614         #    >>> Float(.575-1e-16).n(17)*10**16\n3615         #    5749999999999998.4\n3616         # and this now rounds to 5749999999999998 and (if we round to\n3617         # the 2nd digit from the left) we get 5700000000000000.\n3618         #\n3619         xf = x.n(dps + extra)*Pow(10, shift)\n3620         xi = Integer(xf)\n3621         # use the last digit to select the value of xi\n3622         # nearest to x before rounding at the desired digit\n3623         sign = 1 if x > 0 else -1\n3624         dif2 = sign*(xf - xi).n(extra)\n3625         if dif2 < 0:\n3626             raise NotImplementedError(\n3627                 'not expecting int(x) to round away from 0')\n3628         if dif2 > .5:\n3629             xi += sign  # round away from 0\n3630         elif dif2 == .5:\n3631             xi += sign if xi%2 else -sign  # round toward even\n3632         # shift p to the new position\n3633         ip = p - shift\n3634         # let Python handle the int rounding then rescale\n3635         xr = xi.round(ip) # when Py2 is drop make this round(xi.p, ip)\n3636         # restore scale\n3637         rv = Rational(xr, Pow(10, shift))\n3638         # return Float or Integer\n3639         if rv.is_Integer:\n3640             if n is None:  # the single-arg case\n3641                 return rv\n3642             # use str or else it won't be a float\n3643             return Float(str(rv), dps)  # keep same precision\n3644         else:\n3645             if not allow and rv > self:\n3646                 allow += 1\n3647             return Float(rv, allow)\n3648 \n3649     __round__ = round\n3650 \n3651     def _eval_derivative_matrix_lines(self, x):\n3652         from sympy.matrices.expressions.matexpr import _LeftRightArgs\n3653         return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]