2025-10-17 20:50:58.877 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 20:51:07.466 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=12, cost=0.007580
2025-10-17 20:51:13.962 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=902, output_tokens=287, cost=0.017630
2025-10-17 20:51:15.390 | INFO     | registered non reproducing test 0
2025-10-17 20:51:27.275 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1574, output_tokens=468, cost=0.029780
2025-10-17 20:51:28.541 | INFO     | registered non reproducing test 1
2025-10-17 20:51:39.164 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2676, output_tokens=402, cost=0.038820
2025-10-17 20:51:40.445 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:51:49.791 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=999, output_tokens=368, cost=0.021030
2025-10-17 20:51:49.798 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:51:54.271 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=147, cost=0.011630
2025-10-17 20:51:54.273 | DEBUG    | Extracted a valid json.
2025-10-17 20:51:54.273 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"simplify\", \"sympy/simplify/simplify.py\")",
        "search_method_in_file(\"trigsimp\", \"sympy/simplify/trigsimp.py\")",
        "search_method_in_file(\"_futrig\", \"sympy/simplify/trigsimp.py\")",
        "search_method_in_file(\"bottom_up\", \"sympy/simplify/simplify.py\")",
        "search_method_in_file(\"TR6\", \"sympy/simplify/fu.py\")",
        "search_method_in_file(\"__lt__\", \"sympy/core/expr.py\")"
    ],
    "bug_locations": []
}
2025-10-17 20:51:54.381 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:51:54.382 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:52:17.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7314, output_tokens=961, cost=0.101970
2025-10-17 20:52:17.259 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:52:29.476 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8491, output_tokens=420, cost=0.097510
2025-10-17 20:52:29.484 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:52:38.806 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=774, output_tokens=341, cost=0.017970
2025-10-17 20:52:38.807 | DEBUG    | Extracted a valid json.
2025-10-17 20:52:38.808 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/simplify/fu.py",
            "class": "",
            "method": "TR6",
            "intended_behavior": "The TR6 method should be modified to better handle cases where the exponent is a complex number. Specifically, it should check whether the exponent is complex and, if so, either apply a suitable simplification rule that is mathematically valid for complex exponents or skip the transformation if no such rule is appropriate. This would preserve the function's role in simplifying trigonometric expressions while preventing errors caused by invalid comparisons of complex numbers."
        },
        {
            "file": "sympy/core/expr.py",
            "class": "Expr",
            "method": "__lt__",
            "intended_behavior": "While the `__lt__` method itself correctly raises a TypeError on invalid comparisons involving complex numbers (as comparing complex numbers using less than/greater than is not mathematically valid), the context of its use indicates that there might be a need for upstream validation or handling before comparisons reach this point. Consequently, this suggests that upstream methods (like those involved in expression simplification or transformation, potentially `simplify` or `trigsimp`) may need enhancement to ensure they do not perform illegitimate comparisons on complex numbers. However, `__lt__` should remain unchanged as its behavior is correct; the change should rather be in how comparisons are formulated or performed in the simplification procedures, specifically ensuring that complex expressions are handled in a way to avoid direct comparison using `<` or `>` operations."
        }
    ]
}
2025-10-17 20:52:38.824 | DEBUG    | Bug location extracted successfully: [<file>sympy/simplify/fu.py</file>
<class>None</class>
<method>TR6</method>
<code>
548 def TR6(rv, max=4, pow=False):
549     """Replacement of cos**2 with 1 - sin(x)**2.
550 
551     See _TR56 docstring for advanced use of ``max`` and ``pow``.
552 
553     Examples
554     ========
555 
556     >>> from sympy.simplify.fu import TR6
557     >>> from sympy.abc import x
558     >>> from sympy import cos
559     >>> TR6(cos(x)**2)
560     1 - sin(x)**2
561     >>> TR6(cos(x)**-2)  #unchanged
562     cos(x)**(-2)
563     >>> TR6(cos(x)**4)
564     (1 - sin(x)**2)**2
565     """
566     return _TR56(rv, cos, sin, lambda x: 1 - x, max=max, pow=pow)

</code><intended_behavior>The TR6 method should be modified to better handle cases where the exponent is a complex number. Specifically, it should check whether the exponent is complex and, if so, either apply a suitable simplification rule that is mathematically valid for complex exponents or skip the transformation if no such rule is appropriate. This would preserve the function's role in simplifying trigonometric expressions while preventing errors caused by invalid comparisons of complex numbers.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>__lt__</method>
<code>
398     def __lt__(self, other):
399         from sympy import StrictLessThan
400         try:
401             other = _sympify(other)
402         except SympifyError:
403             raise TypeError("Invalid comparison %s < %s" % (self, other))
404         for me in (self, other):
405             if me.is_complex and me.is_extended_real is False:
406                 raise TypeError("Invalid comparison of complex %s" % me)
407             if me is S.NaN:
408                 raise TypeError("Invalid NaN comparison")
409         n2 = _n2(self, other)
410         if n2 is not None:
411             return _sympify(n2 < 0)
412         if self.is_extended_real and other.is_extended_real:
413             if (self.is_infinite and self.is_extended_positive) \
414                     or (other.is_infinite and other.is_extended_negative):
415                 return S.false
416             neg = (self - other).is_extended_negative
417             if neg is not None:
418                 return sympify(neg)
419         return StrictLessThan(self, other, evaluate=False)

</code><intended_behavior>While the `__lt__` method itself correctly raises a TypeError on invalid comparisons involving complex numbers (as comparing complex numbers using less than/greater than is not mathematically valid), the context of its use indicates that there might be a need for upstream validation or handling before comparisons reach this point. Consequently, this suggests that upstream methods (like those involved in expression simplification or transformation, potentially `simplify` or `trigsimp`) may need enhancement to ensure they do not perform illegitimate comparisons on complex numbers. However, `__lt__` should remain unchanged as its behavior is correct; the change should rather be in how comparisons are formulated or performed in the simplification procedures, specifically ensuring that complex expressions are handled in a way to avoid direct comparison using `<` or `>` operations.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     is_scalar = True  # self derivative is 1
33 
34     @property
35     def _diff_wrt(self):
36         """Return True if one can differentiate with respect to this
37         object, else False.
38 
39         Subclasses such as Symbol, Function and Derivative return True
40         to enable derivatives wrt them. The implementation in Derivative
41         separates the Symbol and non-Symbol (_diff_wrt=True) variables and
42         temporarily converts the non-Symbols into Symbols when performing
43         the differentiation. By default, any object deriving from Expr
44         will behave like a scalar with self.diff(self) == 1. If this is
45         not desired then the object must also set `is_scalar = False` or
46         else define an _eval_derivative routine.
47 
48         Note, see the docstring of Derivative for how this should work
49         mathematically. In particular, note that expr.subs(yourclass, Symbol)
50         should be well-defined on a structural level, or this will lead to
51         inconsistent results.
52 
53         Examples
54         ========
55 
56         >>> from sympy import Expr
57         >>> e = Expr()
58         >>> e._diff_wrt
59         False
60         >>> class MyScalar(Expr):
61         ...     _diff_wrt = True
62         ...
63         >>> MyScalar().diff(MyScalar())
64         1
65         >>> class MySymbol(Expr):
66         ...     _diff_wrt = True
67         ...     is_scalar = False
68         ...
69         >>> MySymbol().diff(MySymbol())
70         Derivative(MySymbol(), MySymbol())
71         """
72         return False
73 
74     @cacheit
75     def sort_key(self, order=None):
76 
77         coeff, expr = self.as_coeff_Mul()
78 
79         if expr.is_Pow:
80             expr, exp = expr.args
81         else:
82             expr, exp = expr, S.One
83 
84         if expr.is_Dummy:
85             args = (expr.sort_key(),)
86         elif expr.is_Atom:
87             args = (str(expr),)
88         else:
89             if expr.is_Add:
90                 args = expr.as_ordered_terms(order=order)
91             elif expr.is_Mul:
92                 args = expr.as_ordered_factors(order=order)
93             else:
94                 args = expr.args
95 
96             args = tuple(
97                 [ default_sort_key(arg, order=order) for arg in args ])
98 
99         args = (len(args), tuple(args))
100         exp = exp.sort_key(order=order)
101 
102         return expr.class_key(), args, exp, coeff
103 
104     def __hash__(self):
105         # hash cannot be cached using cache_it because infinite recurrence
106         # occurs as hash is needed for setting cache dictionary keys
107         h = self._mhash
108         if h is None:
109             h = hash((type(self).__name__,) + self._hashable_content())
110             self._mhash = h
111         return h
112 
113     def _hashable_content(self):
114         """Return a tuple of information about self that can be used to
115         compute the hash. If a class defines additional attributes,
116         like ``name`` in Symbol, then this method should be updated
117         accordingly to return such relevant attributes.
118         Defining more than _hashable_content is necessary if __eq__ has
119         been defined by a class. See note about this in Basic.__eq__."""
120         return self._args
121 
122     def __eq__(self, other):
123         try:
124             other = sympify(other)
125             if not isinstance(other, Expr):
126                 return False
127         except (SympifyError, SyntaxError):
128             return False
129         # check for pure number expr
130         if  not (self.is_Number and other.is_Number) and (
131                 type(self) != type(other)):
132             return False
133         a, b = self._hashable_content(), other._hashable_content()
134         if a != b:
135             return False
136         # check number *in* an expression
137         for a, b in zip(a, b):
138             if not isinstance(a, Expr):
139                 continue
140             if a.is_Number and type(a) != type(b):
141                 return False
142         return True
143 
144     # ***************
145     # * Arithmetics *
146     # ***************
147     # Expr and its sublcasses use _op_priority to determine which object
148     # passed to a binary special method (__mul__, etc.) will handle the
149     # operation. In general, the 'call_highest_priority' decorator will choose
150     # the object with the highest _op_priority to handle the call.
151     # Custom subclasses that want to define their own binary special methods
152     # should set an _op_priority value that is higher than the default.
153     #
154     # **NOTE**:
155     # This is a temporary fix, and will eventually be replaced with
156     # something better and more powerful.  See issue 5510.
157     _op_priority = 10.0
158 
159     def __pos__(self):
160         return self
161 
162     def __neg__(self):
163         return Mul(S.NegativeOne, self)
164 
165     def __abs__(self):
166         from sympy import Abs
167         return Abs(self)
168 
169     @_sympifyit('other', NotImplemented)
170     @call_highest_priority('__radd__')
171     def __add__(self, other):
172         return Add(self, other)
173 
174     @_sympifyit('other', NotImplemented)
175     @call_highest_priority('__add__')
176     def __radd__(self, other):
177         return Add(other, self)
178 
179     @_sympifyit('other', NotImplemented)
180     @call_highest_priority('__rsub__')
181     def __sub__(self, other):
182         return Add(self, -other)
183 
184     @_sympifyit('other', NotImplemented)
185     @call_highest_priority('__sub__')
186     def __rsub__(self, other):
187         return Add(other, -self)
188 
189     @_sympifyit('other', NotImplemented)
190     @call_highest_priority('__rmul__')
191     def __mul__(self, other):
192         return Mul(self, other)
193 
194     @_sympifyit('other', NotImplemented)
195     @call_highest_priority('__mul__')
196     def __rmul__(self, other):
197         return Mul(other, self)
198 
199     @_sympifyit('other', NotImplemented)
200     @call_highest_priority('__rpow__')
201     def _pow(self, other):
202         return Pow(self, other)
203 
204     def __pow__(self, other, mod=None):
205         if mod is None:
206             return self._pow(other)
207         try:
208             _self, other, mod = as_int(self), as_int(other), as_int(mod)
209             if other >= 0:
210                 return pow(_self, other, mod)
211             else:
212                 from sympy.core.numbers import mod_inverse
213                 return mod_inverse(pow(_self, -other, mod), mod)
214         except ValueError:
215             power = self._pow(other)
216             try:
217                 return power%mod
218             except TypeError:
219                 return NotImplemented
220 
221     @_sympifyit('other', NotImplemented)
222     @call_highest_priority('__pow__')
223     def __rpow__(self, other):
224         return Pow(other, self)
225 
226     @_sympifyit('other', NotImplemented)
227     @call_highest_priority('__rdiv__')
228     def __div__(self, other):
229         return Mul(self, Pow(other, S.NegativeOne))
230 
231     @_sympifyit('other', NotImplemented)
232     @call_highest_priority('__div__')
233     def __rdiv__(self, other):
234         return Mul(other, Pow(self, S.NegativeOne))
235 
236     __truediv__ = __div__
237     __rtruediv__ = __rdiv__
238 
239     @_sympifyit('other', NotImplemented)
240     @call_highest_priority('__rmod__')
241     def __mod__(self, other):
242         return Mod(self, other)
243 
244     @_sympifyit('other', NotImplemented)
245     @call_highest_priority('__mod__')
246     def __rmod__(self, other):
247         return Mod(other, self)
248 
249     @_sympifyit('other', NotImplemented)
250     @call_highest_priority('__rfloordiv__')
251     def __floordiv__(self, other):
252         from sympy.functions.elementary.integers import floor
253         return floor(self / other)
254 
255     @_sympifyit('other', NotImplemented)
256     @call_highest_priority('__floordiv__')
257     def __rfloordiv__(self, other):
258         from sympy.functions.elementary.integers import floor
259         return floor(other / self)
260 
261 
262     @_sympifyit('other', NotImplemented)
263     @call_highest_priority('__rdivmod__')
264     def __divmod__(self, other):
265         from sympy.functions.elementary.integers import floor
266         return floor(self / other), Mod(self, other)
267 
268     @_sympifyit('other', NotImplemented)
269     @call_highest_priority('__divmod__')
270     def __rdivmod__(self, other):
271         from sympy.functions.elementary.integers import floor
272         return floor(other / self), Mod(other, self)
273 
274     def __int__(self):
275         # Although we only need to round to the units position, we'll
276         # get one more digit so the extra testing below can be avoided
277         # unless the rounded value rounded to an integer, e.g. if an
278         # expression were equal to 1.9 and we rounded to the unit position
279         # we would get a 2 and would not know if this rounded up or not
280         # without doing a test (as done below). But if we keep an extra
281         # digit we know that 1.9 is not the same as 1 and there is no
282         # need for further testing: our int value is correct. If the value
283         # were 1.99, however, this would round to 2.0 and our int value is
284         # off by one. So...if our round value is the same as the int value
285         # (regardless of how much extra work we do to calculate extra decimal
286         # places) we need to test whether we are off by one.
287         from sympy import Dummy
288         if not self.is_number:
289             raise TypeError("can't convert symbols to int")
290         r = self.round(2)
291         if not r.is_Number:
292             raise TypeError("can't convert complex to int")
293         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
294             raise TypeError("can't convert %s to int" % r)
295         i = int(r)
296         if not i:
297             return 0
298         # off-by-one check
299         if i == r and not (self - i).equals(0):
300             isign = 1 if i > 0 else -1
301             x = Dummy()
302             # in the following (self - i).evalf(2) will not always work while
303             # (self - r).evalf(2) and the use of subs does; if the test that
304             # was added when this comment was added passes, it might be safe
305             # to simply use sign to compute this rather than doing this by hand:
306             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
307             if diff_sign != isign:
308                 i -= isign
309         return i
310     __long__ = __int__
311 
312     def __float__(self):
313         # Don't bother testing if it's a number; if it's not this is going
314         # to fail, and if it is we still need to check that it evalf'ed to
315         # a number.
316         result = self.evalf()
317         if result.is_Number:
318             return float(result)
319         if result.is_number and result.as_real_imag()[1]:
320             raise TypeError("can't convert complex to float")
321         raise TypeError("can't convert expression to float")
322 
323     def __complex__(self):
324         result = self.evalf()
325         re, im = result.as_real_imag()
326         return complex(float(re), float(im))
327 
328     def __ge__(self, other):
329         from sympy import GreaterThan
330         try:
331             other = _sympify(other)
332         except SympifyError:
333             raise TypeError("Invalid comparison %s >= %s" % (self, other))
334         for me in (self, other):
335             if me.is_complex and me.is_extended_real is False:
336                 raise TypeError("Invalid comparison of complex %s" % me)
337             if me is S.NaN:
338                 raise TypeError("Invalid NaN comparison")
339         n2 = _n2(self, other)
340         if n2 is not None:
341             return _sympify(n2 >= 0)
342         if self.is_extended_real and other.is_extended_real:
343             if (self.is_infinite and self.is_extended_positive) \
344                     or (other.is_infinite and other.is_extended_negative):
345                 return S.true
346             nneg = (self - other).is_extended_nonnegative
347             if nneg is not None:
348                 return sympify(nneg)
349         return GreaterThan(self, other, evaluate=False)
350 
351     def __le__(self, other):
352         from sympy import LessThan
353         try:
354             other = _sympify(other)
355         except SympifyError:
356             raise TypeError("Invalid comparison %s <= %s" % (self, other))
357         for me in (self, other):
358             if me.is_complex and me.is_extended_real is False:
359                 raise TypeError("Invalid comparison of complex %s" % me)
360             if me is S.NaN:
361                 raise TypeError("Invalid NaN comparison")
362         n2 = _n2(self, other)
363         if n2 is not None:
364             return _sympify(n2 <= 0)
365         if self.is_extended_real and other.is_extended_real:
366             if (self.is_infinite and self.is_extended_negative) \
367                     or (other.is_infinite and other.is_extended_positive):
368                 return S.true
369             npos = (self - other).is_extended_nonpositive
370             if npos is not None:
371                 return sympify(npos)
372         return LessThan(self, other, evaluate=False)
373 
374     def __gt__(self, other):
375         from sympy import StrictGreaterThan
376         try:
377             other = _sympify(other)
378         except SympifyError:
379             raise TypeError("Invalid comparison %s > %s" % (self, other))
380         for me in (self, other):
381             if me.is_complex and me.is_extended_real is False:
382                 raise TypeError("Invalid comparison of complex %s" % me)
383             if me is S.NaN:
384                 raise TypeError("Invalid NaN comparison")
385         n2 = _n2(self, other)
386         if n2 is not None:
387             return _sympify(n2 > 0)
388 
389         if self.is_extended_real and other.is_extended_real:
390             if (self.is_infinite and self.is_extended_negative) \
391                     or (other.is_infinite and other.is_extended_positive):
392                 return S.false
393             pos = (self - other).is_extended_positive
394             if pos is not None:
395                 return sympify(pos)
396         return StrictGreaterThan(self, other, evaluate=False)
397 
398     def __lt__(self, other):
399         from sympy import StrictLessThan
400         try:
401             other = _sympify(other)
402         except SympifyError:
403             raise TypeError("Invalid comparison %s < %s" % (self, other))
404         for me in (self, other):
405             if me.is_complex and me.is_extended_real is False:
406                 raise TypeError("Invalid comparison of complex %s" % me)
407             if me is S.NaN:
408                 raise TypeError("Invalid NaN comparison")
409         n2 = _n2(self, other)
410         if n2 is not None:
411             return _sympify(n2 < 0)
412         if self.is_extended_real and other.is_extended_real:
413             if (self.is_infinite and self.is_extended_positive) \
414                     or (other.is_infinite and other.is_extended_negative):
415                 return S.false
416             neg = (self - other).is_extended_negative
417             if neg is not None:
418                 return sympify(neg)
419         return StrictLessThan(self, other, evaluate=False)
420 
421     def __trunc__(self):
422         if not self.is_number:
423             raise TypeError("can't truncate symbols and expressions")
424         else:
425             return Integer(self)
426 
427     @staticmethod
428     def _from_mpmath(x, prec):
429         from sympy import Float
430         if hasattr(x, "_mpf_"):
431             return Float._new(x._mpf_, prec)
432         elif hasattr(x, "_mpc_"):
433             re, im = x._mpc_
434             re = Float._new(re, prec)
435             im = Float._new(im, prec)*S.ImaginaryUnit
436             return re + im
437         else:
438             raise TypeError("expected mpmath number (mpf or mpc)")
439 
440     @property
441     def is_number(self):
442         """Returns True if ``self`` has no free symbols and no
443         undefined functions (AppliedUndef, to be precise). It will be
444         faster than ``if not self.free_symbols``, however, since
445         ``is_number`` will fail as soon as it hits a free symbol
446         or undefined function.
447 
448         Examples
449         ========
450 
451         >>> from sympy import log, Integral, cos, sin, pi
452         >>> from sympy.core.function import Function
453         >>> from sympy.abc import x
454         >>> f = Function('f')
455 
456         >>> x.is_number
457         False
458         >>> f(1).is_number
459         False
460         >>> (2*x).is_number
461         False
462         >>> (2 + Integral(2, x)).is_number
463         False
464         >>> (2 + Integral(2, (x, 1, 2))).is_number
465         True
466 
467         Not all numbers are Numbers in the SymPy sense:
468 
469         >>> pi.is_number, pi.is_Number
470         (True, False)
471 
472         If something is a number it should evaluate to a number with
473         real and imaginary parts that are Numbers; the result may not
474         be comparable, however, since the real and/or imaginary part
475         of the result may not have precision.
476 
477         >>> cos(1).is_number and cos(1).is_comparable
478         True
479 
480         >>> z = cos(1)**2 + sin(1)**2 - 1
481         >>> z.is_number
482         True
483         >>> z.is_comparable
484         False
485 
486         See Also
487         ========
488         sympy.core.basic.is_comparable
489         """
490         return all(obj.is_number for obj in self.args)
491 
492     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
493         """Return self evaluated, if possible, replacing free symbols with
494         random complex values, if necessary.
495 
496         The random complex value for each free symbol is generated
497         by the random_complex_number routine giving real and imaginary
498         parts in the range given by the re_min, re_max, im_min, and im_max
499         values. The returned value is evaluated to a precision of n
500         (if given) else the maximum of 15 and the precision needed
501         to get more than 1 digit of precision. If the expression
502         could not be evaluated to a number, or could not be evaluated
503         to more than 1 digit of precision, then None is returned.
504 
505         Examples
506         ========
507 
508         >>> from sympy import sqrt
509         >>> from sympy.abc import x, y
510         >>> x._random()                         # doctest: +SKIP
511         0.0392918155679172 + 0.916050214307199*I
512         >>> x._random(2)                        # doctest: +SKIP
513         -0.77 - 0.87*I
514         >>> (x + y/2)._random(2)                # doctest: +SKIP
515         -0.57 + 0.16*I
516         >>> sqrt(2)._random(2)
517         1.4
518 
519         See Also
520         ========
521 
522         sympy.utilities.randtest.random_complex_number
523         """
524 
525         free = self.free_symbols
526         prec = 1
527         if free:
528             from sympy.utilities.randtest import random_complex_number
529             a, c, b, d = re_min, re_max, im_min, im_max
530             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
531                            for zi in free])))
532             try:
533                 nmag = abs(self.evalf(2, subs=reps))
534             except (ValueError, TypeError):
535                 # if an out of range value resulted in evalf problems
536                 # then return None -- XXX is there a way to know how to
537                 # select a good random number for a given expression?
538                 # e.g. when calculating n! negative values for n should not
539                 # be used
540                 return None
541         else:
542             reps = {}
543             nmag = abs(self.evalf(2))
544 
545         if not hasattr(nmag, '_prec'):
546             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
547             return None
548 
549         if nmag._prec == 1:
550             # increase the precision up to the default maximum
551             # precision to see if we can get any significance
552 
553             from mpmath.libmp.libintmath import giant_steps
554             from sympy.core.evalf import DEFAULT_MAXPREC as target
555 
556             # evaluate
557             for prec in giant_steps(2, target):
558                 nmag = abs(self.evalf(prec, subs=reps))
559                 if nmag._prec != 1:
560                     break
561 
562         if nmag._prec != 1:
563             if n is None:
564                 n = max(prec, 15)
565             return self.evalf(n, subs=reps)
566 
567         # never got any significance
568         return None
569 
570     def is_constant(self, *wrt, **flags):
571         """Return True if self is constant, False if not, or None if
572         the constancy could not be determined conclusively.
573 
574         If an expression has no free symbols then it is a constant. If
575         there are free symbols it is possible that the expression is a
576         constant, perhaps (but not necessarily) zero. To test such
577         expressions, two strategies are tried:
578 
579         1) numerical evaluation at two random points. If two such evaluations
580         give two different values and the values have a precision greater than
581         1 then self is not constant. If the evaluations agree or could not be
582         obtained with any precision, no decision is made. The numerical testing
583         is done only if ``wrt`` is different than the free symbols.
584 
585         2) differentiation with respect to variables in 'wrt' (or all free
586         symbols if omitted) to see if the expression is constant or not. This
587         will not always lead to an expression that is zero even though an
588         expression is constant (see added test in test_expr.py). If
589         all derivatives are zero then self is constant with respect to the
590         given symbols.
591 
592         If neither evaluation nor differentiation can prove the expression is
593         constant, None is returned unless two numerical values happened to be
594         the same and the flag ``failing_number`` is True -- in that case the
595         numerical value will be returned.
596 
597         If flag simplify=False is passed, self will not be simplified;
598         the default is True since self should be simplified before testing.
599 
600         Examples
601         ========
602 
603         >>> from sympy import cos, sin, Sum, S, pi
604         >>> from sympy.abc import a, n, x, y
605         >>> x.is_constant()
606         False
607         >>> S(2).is_constant()
608         True
609         >>> Sum(x, (x, 1, 10)).is_constant()
610         True
611         >>> Sum(x, (x, 1, n)).is_constant()
612         False
613         >>> Sum(x, (x, 1, n)).is_constant(y)
614         True
615         >>> Sum(x, (x, 1, n)).is_constant(n)
616         False
617         >>> Sum(x, (x, 1, n)).is_constant(x)
618         True
619         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
620         >>> eq.is_constant()
621         True
622         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
623         True
624 
625         >>> (0**x).is_constant()
626         False
627         >>> x.is_constant()
628         False
629         >>> (x**x).is_constant()
630         False
631         >>> one = cos(x)**2 + sin(x)**2
632         >>> one.is_constant()
633         True
634         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
635         True
636         """
637 
638         simplify = flags.get('simplify', True)
639 
640         if self.is_number:
641             return True
642         free = self.free_symbols
643         if not free:
644             return True  # assume f(1) is some constant
645 
646         # if we are only interested in some symbols and they are not in the
647         # free symbols then this expression is constant wrt those symbols
648         wrt = set(wrt)
649         if wrt and not wrt & free:
650             return True
651         wrt = wrt or free
652 
653         # simplify unless this has already been done
654         expr = self
655         if simplify:
656             expr = expr.simplify()
657 
658         # is_zero should be a quick assumptions check; it can be wrong for
659         # numbers (see test_is_not_constant test), giving False when it
660         # shouldn't, but hopefully it will never give True unless it is sure.
661         if expr.is_zero:
662             return True
663 
664         # try numerical evaluation to see if we get two different values
665         failing_number = None
666         if wrt == free:
667             # try 0 (for a) and 1 (for b)
668             try:
669                 a = expr.subs(list(zip(free, [0]*len(free))),
670                     simultaneous=True)
671                 if a is S.NaN:
672                     # evaluation may succeed when substitution fails
673                     a = expr._random(None, 0, 0, 0, 0)
674             except ZeroDivisionError:
675                 a = None
676             if a is not None and a is not S.NaN:
677                 try:
678                     b = expr.subs(list(zip(free, [1]*len(free))),
679                         simultaneous=True)
680                     if b is S.NaN:
681                         # evaluation may succeed when substitution fails
682                         b = expr._random(None, 1, 0, 1, 0)
683                 except ZeroDivisionError:
684                     b = None
685                 if b is not None and b is not S.NaN and b.equals(a) is False:
686                     return False
687                 # try random real
688                 b = expr._random(None, -1, 0, 1, 0)
689                 if b is not None and b is not S.NaN and b.equals(a) is False:
690                     return False
691                 # try random complex
692                 b = expr._random()
693                 if b is not None and b is not S.NaN:
694                     if b.equals(a) is False:
695                         return False
696                     failing_number = a if a.is_number else b
697 
698         # now we will test each wrt symbol (or all free symbols) to see if the
699         # expression depends on them or not using differentiation. This is
700         # not sufficient for all expressions, however, so we don't return
701         # False if we get a derivative other than 0 with free symbols.
702         for w in wrt:
703             deriv = expr.diff(w)
704             if simplify:
705                 deriv = deriv.simplify()
706             if deriv != 0:
707                 if not (pure_complex(deriv, or_real=True)):
708                     if flags.get('failing_number', False):
709                         return failing_number
710                     elif deriv.free_symbols:
711                         # dead line provided _random returns None in such cases
712                         return None
713                 return False
714         return True
715 
716     def equals(self, other, failing_expression=False):
717         """Return True if self == other, False if it doesn't, or None. If
718         failing_expression is True then the expression which did not simplify
719         to a 0 will be returned instead of None.
720 
721         If ``self`` is a Number (or complex number) that is not zero, then
722         the result is False.
723 
724         If ``self`` is a number and has not evaluated to zero, evalf will be
725         used to test whether the expression evaluates to zero. If it does so
726         and the result has significance (i.e. the precision is either -1, for
727         a Rational result, or is greater than 1) then the evalf value will be
728         used to return True or False.
729 
730         """
731         from sympy.simplify.simplify import nsimplify, simplify
732         from sympy.solvers.solveset import solveset
733         from sympy.solvers.solvers import solve
734         from sympy.polys.polyerrors import NotAlgebraic
735         from sympy.polys.numberfields import minimal_polynomial
736 
737         other = sympify(other)
738         if self == other:
739             return True
740 
741         # they aren't the same so see if we can make the difference 0;
742         # don't worry about doing simplification steps one at a time
743         # because if the expression ever goes to 0 then the subsequent
744         # simplification steps that are done will be very fast.
745         diff = factor_terms(simplify(self - other), radical=True)
746 
747         if not diff:
748             return True
749 
750         if not diff.has(Add, Mod):
751             # if there is no expanding to be done after simplifying
752             # then this can't be a zero
753             return False
754 
755         constant = diff.is_constant(simplify=False, failing_number=True)
756 
757         if constant is False:
758             return False
759 
760         if not diff.is_number:
761             if constant is None:
762                 # e.g. unless the right simplification is done, a symbolic
763                 # zero is possible (see expression of issue 6829: without
764                 # simplification constant will be None).
765                 return
766 
767         if constant is True:
768             # this gives a number whether there are free symbols or not
769             ndiff = diff._random()
770             # is_comparable will work whether the result is real
771             # or complex; it could be None, however.
772             if ndiff and ndiff.is_comparable:
773                 return False
774 
775         # sometimes we can use a simplified result to give a clue as to
776         # what the expression should be; if the expression is *not* zero
777         # then we should have been able to compute that and so now
778         # we can just consider the cases where the approximation appears
779         # to be zero -- we try to prove it via minimal_polynomial.
780         #
781         # removed
782         # ns = nsimplify(diff)
783         # if diff.is_number and (not ns or ns == diff):
784         #
785         # The thought was that if it nsimplifies to 0 that's a sure sign
786         # to try the following to prove it; or if it changed but wasn't
787         # zero that might be a sign that it's not going to be easy to
788         # prove. But tests seem to be working without that logic.
789         #
790         if diff.is_number:
791             # try to prove via self-consistency
792             surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
793             # it seems to work better to try big ones first
794             surds.sort(key=lambda x: -x.args[0])
795             for s in surds:
796                 try:
797                     # simplify is False here -- this expression has already
798                     # been identified as being hard to identify as zero;
799                     # we will handle the checking ourselves using nsimplify
800                     # to see if we are in the right ballpark or not and if so
801                     # *then* the simplification will be attempted.
802                     sol = solve(diff, s, simplify=False)
803                     if sol:
804                         if s in sol:
805                             # the self-consistent result is present
806                             return True
807                         if all(si.is_Integer for si in sol):
808                             # perfect powers are removed at instantiation
809                             # so surd s cannot be an integer
810                             return False
811                         if all(i.is_algebraic is False for i in sol):
812                             # a surd is algebraic
813                             return False
814                         if any(si in surds for si in sol):
815                             # it wasn't equal to s but it is in surds
816                             # and different surds are not equal
817                             return False
818                         if any(nsimplify(s - si) == 0 and
819                                 simplify(s - si) == 0 for si in sol):
820                             return True
821                         if s.is_real:
822                             if any(nsimplify(si, [s]) == s and simplify(si) == s
823                                     for si in sol):
824                                 return True
825                 except NotImplementedError:
826                     pass
827 
828             # try to prove with minimal_polynomial but know when
829             # *not* to use this or else it can take a long time. e.g. issue 8354
830             if True:  # change True to condition that assures non-hang
831                 try:
832                     mp = minimal_polynomial(diff)
833                     if mp.is_Symbol:
834                         return True
835                     return False
836                 except (NotAlgebraic, NotImplementedError):
837                     pass
838 
839         # diff has not simplified to zero; constant is either None, True
840         # or the number with significance (is_comparable) that was randomly
841         # calculated twice as the same value.
842         if constant not in (True, None) and constant != 0:
843             return False
844 
845         if failing_expression:
846             return diff
847         return None
848 
849     def _eval_is_positive(self):
850         finite = self.is_finite
851         if finite is False:
852             return False
853         extended_positive = self.is_extended_positive
854         if finite is True:
855             return extended_positive
856         if extended_positive is False:
857             return False
858 
859     def _eval_is_negative(self):
860         finite = self.is_finite
861         if finite is False:
862             return False
863         extended_negative = self.is_extended_negative
864         if finite is True:
865             return extended_negative
866         if extended_negative is False:
867             return False
868 
869     def _eval_is_extended_positive(self):
870         from sympy.polys.numberfields import minimal_polynomial
871         from sympy.polys.polyerrors import NotAlgebraic
872         if self.is_number:
873             if self.is_extended_real is False:
874                 return False
875 
876             # check to see that we can get a value
877             try:
878                 n2 = self._eval_evalf(2)
879             # XXX: This shouldn't be caught here
880             # Catches ValueError: hypsum() failed to converge to the requested
881             # 34 bits of accuracy
882             except ValueError:
883                 return None
884             if n2 is None:
885                 return None
886             if getattr(n2, '_prec', 1) == 1:  # no significance
887                 return None
888             if n2 == S.NaN:
889                 return None
890 
891             r, i = self.evalf(2).as_real_imag()
892             if not i.is_Number or not r.is_Number:
893                 return False
894             if r._prec != 1 and i._prec != 1:
895                 return bool(not i and r > 0)
896             elif r._prec == 1 and (not i or i._prec == 1) and \
897                     self.is_algebraic and not self.has(Function):
898                 try:
899                     if minimal_polynomial(self).is_Symbol:
900                         return False
901                 except (NotAlgebraic, NotImplementedError):
902                     pass
903 
904     def _eval_is_extended_negative(self):
905         from sympy.polys.numberfields import minimal_polynomial
906         from sympy.polys.polyerrors import NotAlgebraic
907         if self.is_number:
908             if self.is_extended_real is False:
909                 return False
910 
911             # check to see that we can get a value
912             try:
913                 n2 = self._eval_evalf(2)
914             # XXX: This shouldn't be caught here
915             # Catches ValueError: hypsum() failed to converge to the requested
916             # 34 bits of accuracy
917             except ValueError:
918                 return None
919             if n2 is None:
920                 return None
921             if getattr(n2, '_prec', 1) == 1:  # no significance
922                 return None
923             if n2 == S.NaN:
924                 return None
925 
926             r, i = self.evalf(2).as_real_imag()
927             if not i.is_Number or not r.is_Number:
928                 return False
929             if r._prec != 1 and i._prec != 1:
930                 return bool(not i and r < 0)
931             elif r._prec == 1 and (not i or i._prec == 1) and \
932                     self.is_algebraic and not self.has(Function):
933                 try:
934                     if minimal_polynomial(self).is_Symbol:
935                         return False
936                 except (NotAlgebraic, NotImplementedError):
937                     pass
938 
939     def _eval_interval(self, x, a, b):
940         """
941         Returns evaluation over an interval.  For most functions this is:
942 
943         self.subs(x, b) - self.subs(x, a),
944 
945         possibly using limit() if NaN is returned from subs, or if
946         singularities are found between a and b.
947 
948         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
949         respectively.
950 
951         """
952         from sympy.series import limit, Limit
953         from sympy.solvers.solveset import solveset
954         from sympy.sets.sets import Interval
955         from sympy.functions.elementary.exponential import log
956         from sympy.calculus.util import AccumBounds
957 
958         if (a is None and b is None):
959             raise ValueError('Both interval ends cannot be None.')
960 
961         if a == b:
962             return 0
963 
964         if a is None:
965             A = 0
966         else:
967             A = self.subs(x, a)
968             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
969                 if (a < b) != False:
970                     A = limit(self, x, a,"+")
971                 else:
972                     A = limit(self, x, a,"-")
973 
974                 if A is S.NaN:
975                     return A
976                 if isinstance(A, Limit):
977                     raise NotImplementedError("Could not compute limit")
978 
979         if b is None:
980             B = 0
981         else:
982             B = self.subs(x, b)
983             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
984                 if (a < b) != False:
985                     B = limit(self, x, b,"-")
986                 else:
987                     B = limit(self, x, b,"+")
988 
989                 if isinstance(B, Limit):
990                     raise NotImplementedError("Could not compute limit")
991 
992         if (a and b) is None:
993             return B - A
994 
995         value = B - A
996 
997         if a.is_comparable and b.is_comparable:
998             if a < b:
999                 domain = Interval(a, b)
1000             else:
1001                 domain = Interval(b, a)
1002             # check the singularities of self within the interval
1003             # if singularities is a ConditionSet (not iterable), catch the exception and pass
1004             singularities = solveset(self.cancel().as_numer_denom()[1], x,
1005                 domain=domain)
1006             for logterm in self.atoms(log):
1007                 singularities = singularities | solveset(logterm.args[0], x,
1008                     domain=domain)
1009             try:
1010                 for s in singularities:
1011                     if value is S.NaN:
1012                         # no need to keep adding, it will stay NaN
1013                         break
1014                     if not s.is_comparable:
1015                         continue
1016                     if (a < s) == (s < b) == True:
1017                         value += -limit(self, x, s, "+") + limit(self, x, s, "-")
1018                     elif (b < s) == (s < a) == True:
1019                         value += limit(self, x, s, "+") - limit(self, x, s, "-")
1020             except TypeError:
1021                 pass
1022 
1023         return value
1024 
1025     def _eval_power(self, other):
1026         # subclass to compute self**other for cases when
1027         # other is not NaN, 0, or 1
1028         return None
1029 
1030     def _eval_conjugate(self):
1031         if self.is_extended_real:
1032             return self
1033         elif self.is_imaginary:
1034             return -self
1035 
1036     def conjugate(self):
1037         from sympy.functions.elementary.complexes import conjugate as c
1038         return c(self)
1039 
1040     def _eval_transpose(self):
1041         from sympy.functions.elementary.complexes import conjugate
1042         if self.is_complex:
1043             return self
1044         elif self.is_hermitian:
1045             return conjugate(self)
1046         elif self.is_antihermitian:
1047             return -conjugate(self)
1048 
1049     def transpose(self):
1050         from sympy.functions.elementary.complexes import transpose
1051         return transpose(self)
1052 
1053     def _eval_adjoint(self):
1054         from sympy.functions.elementary.complexes import conjugate, transpose
1055         if self.is_hermitian:
1056             return self
1057         elif self.is_antihermitian:
1058             return -self
1059         obj = self._eval_conjugate()
1060         if obj is not None:
1061             return transpose(obj)
1062         obj = self._eval_transpose()
1063         if obj is not None:
1064             return conjugate(obj)
1065 
1066     def adjoint(self):
1067         from sympy.functions.elementary.complexes import adjoint
1068         return adjoint(self)
1069 
1070     @classmethod
1071     def _parse_order(cls, order):
1072         """Parse and configure the ordering of terms. """
1073         from sympy.polys.orderings import monomial_key
1074 
1075         startswith = getattr(order, "startswith", None)
1076         if startswith is None:
1077             reverse = False
1078         else:
1079             reverse = startswith('rev-')
1080             if reverse:
1081                 order = order[4:]
1082 
1083         monom_key = monomial_key(order)
1084 
1085         def neg(monom):
1086             result = []
1087 
1088             for m in monom:
1089                 if isinstance(m, tuple):
1090                     result.append(neg(m))
1091                 else:
1092                     result.append(-m)
1093 
1094             return tuple(result)
1095 
1096         def key(term):
1097             _, ((re, im), monom, ncpart) = term
1098 
1099             monom = neg(monom_key(monom))
1100             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
1101             coeff = ((bool(im), im), (re, im))
1102 
1103             return monom, ncpart, coeff
1104 
1105         return key, reverse
1106 
1107     def as_ordered_factors(self, order=None):
1108         """Return list of ordered factors (if Mul) else [self]."""
1109         return [self]
1110 
1111     def as_ordered_terms(self, order=None, data=False):
1112         """
1113         Transform an expression to an ordered list of terms.
1114 
1115         Examples
1116         ========
1117 
1118         >>> from sympy import sin, cos
1119         >>> from sympy.abc import x
1120 
1121         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
1122         [sin(x)**2*cos(x), sin(x)**2, 1]
1123 
1124         """
1125 
1126         from .numbers import Number, NumberSymbol
1127 
1128         if order is None and self.is_Add:
1129             # Spot the special case of Add(Number, Mul(Number, expr)) with the
1130             # first number positive and thhe second number nagative
1131             key = lambda x:not isinstance(x, (Number, NumberSymbol))
1132             add_args = sorted(Add.make_args(self), key=key)
1133             if (len(add_args) == 2
1134                 and isinstance(add_args[0], (Number, NumberSymbol))
1135                 and isinstance(add_args[1], Mul)):
1136                 mul_args = sorted(Mul.make_args(add_args[1]), key=key)
1137                 if (len(mul_args) == 2
1138                     and isinstance(mul_args[0], Number)
1139                     and add_args[0].is_positive
1140                     and mul_args[0].is_negative):
1141                     return add_args
1142 
1143         key, reverse = self._parse_order(order)
1144         terms, gens = self.as_terms()
1145 
1146         if not any(term.is_Order for term, _ in terms):
1147             ordered = sorted(terms, key=key, reverse=reverse)
1148         else:
1149             _terms, _order = [], []
1150 
1151             for term, repr in terms:
1152                 if not term.is_Order:
1153                     _terms.append((term, repr))
1154                 else:
1155                     _order.append((term, repr))
1156 
1157             ordered = sorted(_terms, key=key, reverse=True) \
1158                 + sorted(_order, key=key, reverse=True)
1159 
1160         if data:
1161             return ordered, gens
1162         else:
1163             return [term for term, _ in ordered]
1164 
1165     def as_terms(self):
1166         """Transform an expression to a list of terms. """
1167         from .add import Add
1168         from .mul import Mul
1169         from .exprtools import decompose_power
1170 
1171         gens, terms = set([]), []
1172 
1173         for term in Add.make_args(self):
1174             coeff, _term = term.as_coeff_Mul()
1175 
1176             coeff = complex(coeff)
1177             cpart, ncpart = {}, []
1178 
1179             if _term is not S.One:
1180                 for factor in Mul.make_args(_term):
1181                     if factor.is_number:
1182                         try:
1183                             coeff *= complex(factor)
1184                         except (TypeError, ValueError):
1185                             pass
1186                         else:
1187                             continue
1188 
1189                     if factor.is_commutative:
1190                         base, exp = decompose_power(factor)
1191 
1192                         cpart[base] = exp
1193                         gens.add(base)
1194                     else:
1195                         ncpart.append(factor)
1196 
1197             coeff = coeff.real, coeff.imag
1198             ncpart = tuple(ncpart)
1199 
1200             terms.append((term, (coeff, cpart, ncpart)))
1201 
1202         gens = sorted(gens, key=default_sort_key)
1203 
1204         k, indices = len(gens), {}
1205 
1206         for i, g in enumerate(gens):
1207             indices[g] = i
1208 
1209         result = []
1210 
1211         for term, (coeff, cpart, ncpart) in terms:
1212             monom = [0]*k
1213 
1214             for base, exp in cpart.items():
1215                 monom[indices[base]] = exp
1216 
1217             result.append((term, (coeff, tuple(monom), ncpart)))
1218 
1219         return result, gens
1220 
1221     def removeO(self):
1222         """Removes the additive O(..) symbol if there is one"""
1223         return self
1224 
1225     def getO(self):
1226         """Returns the additive O(..) symbol if there is one, else None."""
1227         return None
1228 
1229     def getn(self):
1230         """
1231         Returns the order of the expression.
1232 
1233         The order is determined either from the O(...) term. If there
1234         is no O(...) term, it returns None.
1235 
1236         Examples
1237         ========
1238 
1239         >>> from sympy import O
1240         >>> from sympy.abc import x
1241         >>> (1 + x + O(x**2)).getn()
1242         2
1243         >>> (1 + x).getn()
1244 
1245         """
1246         from sympy import Dummy, Symbol
1247         o = self.getO()
1248         if o is None:
1249             return None
1250         elif o.is_Order:
1251             o = o.expr
1252             if o is S.One:
1253                 return S.Zero
1254             if o.is_Symbol:
1255                 return S.One
1256             if o.is_Pow:
1257                 return o.args[1]
1258             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1259                 for oi in o.args:
1260                     if oi.is_Symbol:
1261                         return S.One
1262                     if oi.is_Pow:
1263                         syms = oi.atoms(Symbol)
1264                         if len(syms) == 1:
1265                             x = syms.pop()
1266                             oi = oi.subs(x, Dummy('x', positive=True))
1267                             if oi.base.is_Symbol and oi.exp.is_Rational:
1268                                 return abs(oi.exp)
1269 
1270         raise NotImplementedError('not sure of order of %s' % o)
1271 
1272     def count_ops(self, visual=None):
1273         """wrapper for count_ops that returns the operation count."""
1274         from .function import count_ops
1275         return count_ops(self, visual)
1276 
1277     def args_cnc(self, cset=False, warn=True, split_1=True):
1278         """Return [commutative factors, non-commutative factors] of self.
1279 
1280         self is treated as a Mul and the ordering of the factors is maintained.
1281         If ``cset`` is True the commutative factors will be returned in a set.
1282         If there were repeated factors (as may happen with an unevaluated Mul)
1283         then an error will be raised unless it is explicitly suppressed by
1284         setting ``warn`` to False.
1285 
1286         Note: -1 is always separated from a Number unless split_1 is False.
1287 
1288         >>> from sympy import symbols, oo
1289         >>> A, B = symbols('A B', commutative=0)
1290         >>> x, y = symbols('x y')
1291         >>> (-2*x*y).args_cnc()
1292         [[-1, 2, x, y], []]
1293         >>> (-2.5*x).args_cnc()
1294         [[-1, 2.5, x], []]
1295         >>> (-2*x*A*B*y).args_cnc()
1296         [[-1, 2, x, y], [A, B]]
1297         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1298         [[-2, x, y], [A, B]]
1299         >>> (-2*x*y).args_cnc(cset=True)
1300         [{-1, 2, x, y}, []]
1301 
1302         The arg is always treated as a Mul:
1303 
1304         >>> (-2 + x + A).args_cnc()
1305         [[], [x - 2 + A]]
1306         >>> (-oo).args_cnc() # -oo is a singleton
1307         [[-1, oo], []]
1308         """
1309 
1310         if self.is_Mul:
1311             args = list(self.args)
1312         else:
1313             args = [self]
1314         for i, mi in enumerate(args):
1315             if not mi.is_commutative:
1316                 c = args[:i]
1317                 nc = args[i:]
1318                 break
1319         else:
1320             c = args
1321             nc = []
1322 
1323         if c and split_1 and (
1324             c[0].is_Number and
1325             c[0].is_extended_negative and
1326                 c[0] is not S.NegativeOne):
1327             c[:1] = [S.NegativeOne, -c[0]]
1328 
1329         if cset:
1330             clen = len(c)
1331             c = set(c)
1332             if clen and warn and len(c) != clen:
1333                 raise ValueError('repeated commutative arguments: %s' %
1334                                  [ci for ci in c if list(self.args).count(ci) > 1])
1335         return [c, nc]
1336 
1337     def coeff(self, x, n=1, right=False):
1338         """
1339         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1340         is zero then all terms independent of ``x`` will be returned.
1341 
1342         When ``x`` is noncommutative, the coefficient to the left (default) or
1343         right of ``x`` can be returned. The keyword 'right' is ignored when
1344         ``x`` is commutative.
1345 
1346         See Also
1347         ========
1348 
1349         as_coefficient: separate the expression into a coefficient and factor
1350         as_coeff_Add: separate the additive constant from an expression
1351         as_coeff_Mul: separate the multiplicative constant from an expression
1352         as_independent: separate x-dependent terms/factors from others
1353         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1354         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1355 
1356         Examples
1357         ========
1358 
1359         >>> from sympy import symbols
1360         >>> from sympy.abc import x, y, z
1361 
1362         You can select terms that have an explicit negative in front of them:
1363 
1364         >>> (-x + 2*y).coeff(-1)
1365         x
1366         >>> (x - 2*y).coeff(-1)
1367         2*y
1368 
1369         You can select terms with no Rational coefficient:
1370 
1371         >>> (x + 2*y).coeff(1)
1372         x
1373         >>> (3 + 2*x + 4*x**2).coeff(1)
1374         0
1375 
1376         You can select terms independent of x by making n=0; in this case
1377         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1378         of None):
1379 
1380         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1381         3
1382         >>> eq = ((x + 1)**3).expand() + 1
1383         >>> eq
1384         x**3 + 3*x**2 + 3*x + 2
1385         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1386         [1, 3, 3, 2]
1387         >>> eq -= 2
1388         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1389         [1, 3, 3, 0]
1390 
1391         You can select terms that have a numerical term in front of them:
1392 
1393         >>> (-x - 2*y).coeff(2)
1394         -y
1395         >>> from sympy import sqrt
1396         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1397         x
1398 
1399         The matching is exact:
1400 
1401         >>> (3 + 2*x + 4*x**2).coeff(x)
1402         2
1403         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1404         4
1405         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1406         0
1407         >>> (z*(x + y)**2).coeff((x + y)**2)
1408         z
1409         >>> (z*(x + y)**2).coeff(x + y)
1410         0
1411 
1412         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1413         from the following:
1414 
1415         >>> (x + z*(x + x*y)).coeff(x)
1416         1
1417 
1418         If such factoring is desired, factor_terms can be used first:
1419 
1420         >>> from sympy import factor_terms
1421         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1422         z*(y + 1) + 1
1423 
1424         >>> n, m, o = symbols('n m o', commutative=False)
1425         >>> n.coeff(n)
1426         1
1427         >>> (3*n).coeff(n)
1428         3
1429         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1430         1 + m
1431         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1432         m
1433 
1434         If there is more than one possible coefficient 0 is returned:
1435 
1436         >>> (n*m + m*n).coeff(n)
1437         0
1438 
1439         If there is only one possible coefficient, it is returned:
1440 
1441         >>> (n*m + x*m*n).coeff(m*n)
1442         x
1443         >>> (n*m + x*m*n).coeff(m*n, right=1)
1444         1
1445 
1446         """
1447         x = sympify(x)
1448         if not isinstance(x, Basic):
1449             return S.Zero
1450 
1451         n = as_int(n)
1452 
1453         if not x:
1454             return S.Zero
1455 
1456         if x == self:
1457             if n == 1:
1458                 return S.One
1459             return S.Zero
1460 
1461         if x is S.One:
1462             co = [a for a in Add.make_args(self)
1463                   if a.as_coeff_Mul()[0] is S.One]
1464             if not co:
1465                 return S.Zero
1466             return Add(*co)
1467 
1468         if n == 0:
1469             if x.is_Add and self.is_Add:
1470                 c = self.coeff(x, right=right)
1471                 if not c:
1472                     return S.Zero
1473                 if not right:
1474                     return self - Add(*[a*x for a in Add.make_args(c)])
1475                 return self - Add(*[x*a for a in Add.make_args(c)])
1476             return self.as_independent(x, as_Add=True)[0]
1477 
1478         # continue with the full method, looking for this power of x:
1479         x = x**n
1480 
1481         def incommon(l1, l2):
1482             if not l1 or not l2:
1483                 return []
1484             n = min(len(l1), len(l2))
1485             for i in range(n):
1486                 if l1[i] != l2[i]:
1487                     return l1[:i]
1488             return l1[:]
1489 
1490         def find(l, sub, first=True):
1491             """ Find where list sub appears in list l. When ``first`` is True
1492             the first occurrence from the left is returned, else the last
1493             occurrence is returned. Return None if sub is not in l.
1494 
1495             >> l = range(5)*2
1496             >> find(l, [2, 3])
1497             2
1498             >> find(l, [2, 3], first=0)
1499             7
1500             >> find(l, [2, 4])
1501             None
1502 
1503             """
1504             if not sub or not l or len(sub) > len(l):
1505                 return None
1506             n = len(sub)
1507             if not first:
1508                 l.reverse()
1509                 sub.reverse()
1510             for i in range(0, len(l) - n + 1):
1511                 if all(l[i + j] == sub[j] for j in range(n)):
1512                     break
1513             else:
1514                 i = None
1515             if not first:
1516                 l.reverse()
1517                 sub.reverse()
1518             if i is not None and not first:
1519                 i = len(l) - (i + n)
1520             return i
1521 
1522         co = []
1523         args = Add.make_args(self)
1524         self_c = self.is_commutative
1525         x_c = x.is_commutative
1526         if self_c and not x_c:
1527             return S.Zero
1528 
1529         if self_c:
1530             xargs = x.args_cnc(cset=True, warn=False)[0]
1531             for a in args:
1532                 margs = a.args_cnc(cset=True, warn=False)[0]
1533                 if len(xargs) > len(margs):
1534                     continue
1535                 resid = margs.difference(xargs)
1536                 if len(resid) + len(xargs) == len(margs):
1537                     co.append(Mul(*resid))
1538             if co == []:
1539                 return S.Zero
1540             elif co:
1541                 return Add(*co)
1542         elif x_c:
1543             xargs = x.args_cnc(cset=True, warn=False)[0]
1544             for a in args:
1545                 margs, nc = a.args_cnc(cset=True)
1546                 if len(xargs) > len(margs):
1547                     continue
1548                 resid = margs.difference(xargs)
1549                 if len(resid) + len(xargs) == len(margs):
1550                     co.append(Mul(*(list(resid) + nc)))
1551             if co == []:
1552                 return S.Zero
1553             elif co:
1554                 return Add(*co)
1555         else:  # both nc
1556             xargs, nx = x.args_cnc(cset=True)
1557             # find the parts that pass the commutative terms
1558             for a in args:
1559                 margs, nc = a.args_cnc(cset=True)
1560                 if len(xargs) > len(margs):
1561                     continue
1562                 resid = margs.difference(xargs)
1563                 if len(resid) + len(xargs) == len(margs):
1564                     co.append((resid, nc))
1565             # now check the non-comm parts
1566             if not co:
1567                 return S.Zero
1568             if all(n == co[0][1] for r, n in co):
1569                 ii = find(co[0][1], nx, right)
1570                 if ii is not None:
1571                     if not right:
1572                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1573                     else:
1574                         return Mul(*co[0][1][ii + len(nx):])
1575             beg = reduce(incommon, (n[1] for n in co))
1576             if beg:
1577                 ii = find(beg, nx, right)
1578                 if ii is not None:
1579                     if not right:
1580                         gcdc = co[0][0]
1581                         for i in range(1, len(co)):
1582                             gcdc = gcdc.intersection(co[i][0])
1583                             if not gcdc:
1584                                 break
1585                         return Mul(*(list(gcdc) + beg[:ii]))
1586                     else:
1587                         m = ii + len(nx)
1588                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1589             end = list(reversed(
1590                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1591             if end:
1592                 ii = find(end, nx, right)
1593                 if ii is not None:
1594                     if not right:
1595                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1596                     else:
1597                         return Mul(*end[ii + len(nx):])
1598             # look for single match
1599             hit = None
1600             for i, (r, n) in enumerate(co):
1601                 ii = find(n, nx, right)
1602                 if ii is not None:
1603                     if not hit:
1604                         hit = ii, r, n
1605                     else:
1606                         break
1607             else:
1608                 if hit:
1609                     ii, r, n = hit
1610                     if not right:
1611                         return Mul(*(list(r) + n[:ii]))
1612                     else:
1613                         return Mul(*n[ii + len(nx):])
1614 
1615             return S.Zero
1616 
1617     def as_expr(self, *gens):
1618         """
1619         Convert a polynomial to a SymPy expression.
1620 
1621         Examples
1622         ========
1623 
1624         >>> from sympy import sin
1625         >>> from sympy.abc import x, y
1626 
1627         >>> f = (x**2 + x*y).as_poly(x, y)
1628         >>> f.as_expr()
1629         x**2 + x*y
1630 
1631         >>> sin(x).as_expr()
1632         sin(x)
1633 
1634         """
1635         return self
1636 
1637     def as_coefficient(self, expr):
1638         """
1639         Extracts symbolic coefficient at the given expression. In
1640         other words, this functions separates 'self' into the product
1641         of 'expr' and 'expr'-free coefficient. If such separation
1642         is not possible it will return None.
1643 
1644         Examples
1645         ========
1646 
1647         >>> from sympy import E, pi, sin, I, Poly
1648         >>> from sympy.abc import x
1649 
1650         >>> E.as_coefficient(E)
1651         1
1652         >>> (2*E).as_coefficient(E)
1653         2
1654         >>> (2*sin(E)*E).as_coefficient(E)
1655 
1656         Two terms have E in them so a sum is returned. (If one were
1657         desiring the coefficient of the term exactly matching E then
1658         the constant from the returned expression could be selected.
1659         Or, for greater precision, a method of Poly can be used to
1660         indicate the desired term from which the coefficient is
1661         desired.)
1662 
1663         >>> (2*E + x*E).as_coefficient(E)
1664         x + 2
1665         >>> _.args[0]  # just want the exact match
1666         2
1667         >>> p = Poly(2*E + x*E); p
1668         Poly(x*E + 2*E, x, E, domain='ZZ')
1669         >>> p.coeff_monomial(E)
1670         2
1671         >>> p.nth(0, 1)
1672         2
1673 
1674         Since the following cannot be written as a product containing
1675         E as a factor, None is returned. (If the coefficient ``2*x`` is
1676         desired then the ``coeff`` method should be used.)
1677 
1678         >>> (2*E*x + x).as_coefficient(E)
1679         >>> (2*E*x + x).coeff(E)
1680         2*x
1681 
1682         >>> (E*(x + 1) + x).as_coefficient(E)
1683 
1684         >>> (2*pi*I).as_coefficient(pi*I)
1685         2
1686         >>> (2*I).as_coefficient(pi*I)
1687 
1688         See Also
1689         ========
1690 
1691         coeff: return sum of terms have a given factor
1692         as_coeff_Add: separate the additive constant from an expression
1693         as_coeff_Mul: separate the multiplicative constant from an expression
1694         as_independent: separate x-dependent terms/factors from others
1695         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1696         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1697 
1698 
1699         """
1700 
1701         r = self.extract_multiplicatively(expr)
1702         if r and not r.has(expr):
1703             return r
1704 
1705     def as_independent(self, *deps, **hint):
1706         """
1707         A mostly naive separation of a Mul or Add into arguments that are not
1708         are dependent on deps. To obtain as complete a separation of variables
1709         as possible, use a separation method first, e.g.:
1710 
1711         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1712         * .expand(mul=True) to change Add or Mul into Add
1713         * .expand(log=True) to change log expr into an Add
1714 
1715         The only non-naive thing that is done here is to respect noncommutative
1716         ordering of variables and to always return (0, 0) for `self` of zero
1717         regardless of hints.
1718 
1719         For nonzero `self`, the returned tuple (i, d) has the
1720         following interpretation:
1721 
1722         * i will has no variable that appears in deps
1723         * d will either have terms that contain variables that are in deps, or
1724           be equal to 0 (when self is an Add) or 1 (when self is a Mul)
1725         * if self is an Add then self = i + d
1726         * if self is a Mul then self = i*d
1727         * otherwise (self, S.One) or (S.One, self) is returned.
1728 
1729         To force the expression to be treated as an Add, use the hint as_Add=True
1730 
1731         Examples
1732         ========
1733 
1734         -- self is an Add
1735 
1736         >>> from sympy import sin, cos, exp
1737         >>> from sympy.abc import x, y, z
1738 
1739         >>> (x + x*y).as_independent(x)
1740         (0, x*y + x)
1741         >>> (x + x*y).as_independent(y)
1742         (x, x*y)
1743         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1744         (y + z, 2*x*sin(x) + x)
1745         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1746         (z, 2*x*sin(x) + x + y)
1747 
1748         -- self is a Mul
1749 
1750         >>> (x*sin(x)*cos(y)).as_independent(x)
1751         (cos(y), x*sin(x))
1752 
1753         non-commutative terms cannot always be separated out when self is a Mul
1754 
1755         >>> from sympy import symbols
1756         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1757         >>> (n1 + n1*n2).as_independent(n2)
1758         (n1, n1*n2)
1759         >>> (n2*n1 + n1*n2).as_independent(n2)
1760         (0, n1*n2 + n2*n1)
1761         >>> (n1*n2*n3).as_independent(n1)
1762         (1, n1*n2*n3)
1763         >>> (n1*n2*n3).as_independent(n2)
1764         (n1, n2*n3)
1765         >>> ((x-n1)*(x-y)).as_independent(x)
1766         (1, (x - y)*(x - n1))
1767 
1768         -- self is anything else:
1769 
1770         >>> (sin(x)).as_independent(x)
1771         (1, sin(x))
1772         >>> (sin(x)).as_independent(y)
1773         (sin(x), 1)
1774         >>> exp(x+y).as_independent(x)
1775         (1, exp(x + y))
1776 
1777         -- force self to be treated as an Add:
1778 
1779         >>> (3*x).as_independent(x, as_Add=True)
1780         (0, 3*x)
1781 
1782         -- force self to be treated as a Mul:
1783 
1784         >>> (3+x).as_independent(x, as_Add=False)
1785         (1, x + 3)
1786         >>> (-3+x).as_independent(x, as_Add=False)
1787         (1, x - 3)
1788 
1789         Note how the below differs from the above in making the
1790         constant on the dep term positive.
1791 
1792         >>> (y*(-3+x)).as_independent(x)
1793         (y, x - 3)
1794 
1795         -- use .as_independent() for true independence testing instead
1796            of .has(). The former considers only symbols in the free
1797            symbols while the latter considers all symbols
1798 
1799         >>> from sympy import Integral
1800         >>> I = Integral(x, (x, 1, 2))
1801         >>> I.has(x)
1802         True
1803         >>> x in I.free_symbols
1804         False
1805         >>> I.as_independent(x) == (I, 1)
1806         True
1807         >>> (I + x).as_independent(x) == (I, x)
1808         True
1809 
1810         Note: when trying to get independent terms, a separation method
1811         might need to be used first. In this case, it is important to keep
1812         track of what you send to this routine so you know how to interpret
1813         the returned values
1814 
1815         >>> from sympy import separatevars, log
1816         >>> separatevars(exp(x+y)).as_independent(x)
1817         (exp(y), exp(x))
1818         >>> (x + x*y).as_independent(y)
1819         (x, x*y)
1820         >>> separatevars(x + x*y).as_independent(y)
1821         (x, y + 1)
1822         >>> (x*(1 + y)).as_independent(y)
1823         (x, y + 1)
1824         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1825         (x, x*y)
1826         >>> a, b=symbols('a b', positive=True)
1827         >>> (log(a*b).expand(log=True)).as_independent(b)
1828         (log(a), log(b))
1829 
1830         See Also
1831         ========
1832         .separatevars(), .expand(log=True), Add.as_two_terms(),
1833         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1834         """
1835         from .symbol import Symbol
1836         from .add import _unevaluated_Add
1837         from .mul import _unevaluated_Mul
1838         from sympy.utilities.iterables import sift
1839 
1840         if self.is_zero:
1841             return S.Zero, S.Zero
1842 
1843         func = self.func
1844         if hint.get('as_Add', isinstance(self, Add) ):
1845             want = Add
1846         else:
1847             want = Mul
1848 
1849         # sift out deps into symbolic and other and ignore
1850         # all symbols but those that are in the free symbols
1851         sym = set()
1852         other = []
1853         for d in deps:
1854             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1855                 sym.add(d)
1856             else:
1857                 other.append(d)
1858 
1859         def has(e):
1860             """return the standard has() if there are no literal symbols, else
1861             check to see that symbol-deps are in the free symbols."""
1862             has_other = e.has(*other)
1863             if not sym:
1864                 return has_other
1865             return has_other or e.has(*(e.free_symbols & sym))
1866 
1867         if (want is not func or
1868                 func is not Add and func is not Mul):
1869             if has(self):
1870                 return (want.identity, self)
1871             else:
1872                 return (self, want.identity)
1873         else:
1874             if func is Add:
1875                 args = list(self.args)
1876             else:
1877                 args, nc = self.args_cnc()
1878 
1879         d = sift(args, lambda x: has(x))
1880         depend = d[True]
1881         indep = d[False]
1882         if func is Add:  # all terms were treated as commutative
1883             return (Add(*indep), _unevaluated_Add(*depend))
1884         else:  # handle noncommutative by stopping at first dependent term
1885             for i, n in enumerate(nc):
1886                 if has(n):
1887                     depend.extend(nc[i:])
1888                     break
1889                 indep.append(n)
1890             return Mul(*indep), (
1891                 Mul(*depend, evaluate=False) if nc else
1892                 _unevaluated_Mul(*depend))
1893 
1894     def as_real_imag(self, deep=True, **hints):
1895         """Performs complex expansion on 'self' and returns a tuple
1896            containing collected both real and imaginary parts. This
1897            method can't be confused with re() and im() functions,
1898            which does not perform complex expansion at evaluation.
1899 
1900            However it is possible to expand both re() and im()
1901            functions and get exactly the same results as with
1902            a single call to this function.
1903 
1904            >>> from sympy import symbols, I
1905 
1906            >>> x, y = symbols('x,y', real=True)
1907 
1908            >>> (x + y*I).as_real_imag()
1909            (x, y)
1910 
1911            >>> from sympy.abc import z, w
1912 
1913            >>> (z + w*I).as_real_imag()
1914            (re(z) - im(w), re(w) + im(z))
1915 
1916         """
1917         from sympy import im, re
1918         if hints.get('ignore') == self:
1919             return None
1920         else:
1921             return (re(self), im(self))
1922 
1923     def as_powers_dict(self):
1924         """Return self as a dictionary of factors with each factor being
1925         treated as a power. The keys are the bases of the factors and the
1926         values, the corresponding exponents. The resulting dictionary should
1927         be used with caution if the expression is a Mul and contains non-
1928         commutative factors since the order that they appeared will be lost in
1929         the dictionary.
1930 
1931         See Also
1932         ========
1933         as_ordered_factors: An alternative for noncommutative applications,
1934                             returning an ordered list of factors.
1935         args_cnc: Similar to as_ordered_factors, but guarantees separation
1936                   of commutative and noncommutative factors.
1937         """
1938         d = defaultdict(int)
1939         d.update(dict([self.as_base_exp()]))
1940         return d
1941 
1942     def as_coefficients_dict(self):
1943         """Return a dictionary mapping terms to their Rational coefficient.
1944         Since the dictionary is a defaultdict, inquiries about terms which
1945         were not present will return a coefficient of 0. If an expression is
1946         not an Add it is considered to have a single term.
1947 
1948         Examples
1949         ========
1950 
1951         >>> from sympy.abc import a, x
1952         >>> (3*x + a*x + 4).as_coefficients_dict()
1953         {1: 4, x: 3, a*x: 1}
1954         >>> _[a]
1955         0
1956         >>> (3*a*x).as_coefficients_dict()
1957         {a*x: 3}
1958 
1959         """
1960         c, m = self.as_coeff_Mul()
1961         if not c.is_Rational:
1962             c = S.One
1963             m = self
1964         d = defaultdict(int)
1965         d.update({m: c})
1966         return d
1967 
1968     def as_base_exp(self):
1969         # a -> b ** e
1970         return self, S.One
1971 
1972     def as_coeff_mul(self, *deps, **kwargs):
1973         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1974 
1975         c should be a Rational multiplied by any factors of the Mul that are
1976         independent of deps.
1977 
1978         args should be a tuple of all other factors of m; args is empty
1979         if self is a Number or if self is independent of deps (when given).
1980 
1981         This should be used when you don't know if self is a Mul or not but
1982         you want to treat self as a Mul or if you want to process the
1983         individual arguments of the tail of self as a Mul.
1984 
1985         - if you know self is a Mul and want only the head, use self.args[0];
1986         - if you don't want to process the arguments of the tail but need the
1987           tail then use self.as_two_terms() which gives the head and tail;
1988         - if you want to split self into an independent and dependent parts
1989           use ``self.as_independent(*deps)``
1990 
1991         >>> from sympy import S
1992         >>> from sympy.abc import x, y
1993         >>> (S(3)).as_coeff_mul()
1994         (3, ())
1995         >>> (3*x*y).as_coeff_mul()
1996         (3, (x, y))
1997         >>> (3*x*y).as_coeff_mul(x)
1998         (3*y, (x,))
1999         >>> (3*y).as_coeff_mul(x)
2000         (3*y, ())
2001         """
2002         if deps:
2003             if not self.has(*deps):
2004                 return self, tuple()
2005         return S.One, (self,)
2006 
2007     def as_coeff_add(self, *deps):
2008         """Return the tuple (c, args) where self is written as an Add, ``a``.
2009 
2010         c should be a Rational added to any terms of the Add that are
2011         independent of deps.
2012 
2013         args should be a tuple of all other terms of ``a``; args is empty
2014         if self is a Number or if self is independent of deps (when given).
2015 
2016         This should be used when you don't know if self is an Add or not but
2017         you want to treat self as an Add or if you want to process the
2018         individual arguments of the tail of self as an Add.
2019 
2020         - if you know self is an Add and want only the head, use self.args[0];
2021         - if you don't want to process the arguments of the tail but need the
2022           tail then use self.as_two_terms() which gives the head and tail.
2023         - if you want to split self into an independent and dependent parts
2024           use ``self.as_independent(*deps)``
2025 
2026         >>> from sympy import S
2027         >>> from sympy.abc import x, y
2028         >>> (S(3)).as_coeff_add()
2029         (3, ())
2030         >>> (3 + x).as_coeff_add()
2031         (3, (x,))
2032         >>> (3 + x + y).as_coeff_add(x)
2033         (y + 3, (x,))
2034         >>> (3 + y).as_coeff_add(x)
2035         (y + 3, ())
2036 
2037         """
2038         if deps:
2039             if not self.has(*deps):
2040                 return self, tuple()
2041         return S.Zero, (self,)
2042 
2043     def primitive(self):
2044         """Return the positive Rational that can be extracted non-recursively
2045         from every term of self (i.e., self is treated like an Add). This is
2046         like the as_coeff_Mul() method but primitive always extracts a positive
2047         Rational (never a negative or a Float).
2048 
2049         Examples
2050         ========
2051 
2052         >>> from sympy.abc import x
2053         >>> (3*(x + 1)**2).primitive()
2054         (3, (x + 1)**2)
2055         >>> a = (6*x + 2); a.primitive()
2056         (2, 3*x + 1)
2057         >>> b = (x/2 + 3); b.primitive()
2058         (1/2, x + 6)
2059         >>> (a*b).primitive() == (1, a*b)
2060         True
2061         """
2062         if not self:
2063             return S.One, S.Zero
2064         c, r = self.as_coeff_Mul(rational=True)
2065         if c.is_negative:
2066             c, r = -c, -r
2067         return c, r
2068 
2069     def as_content_primitive(self, radical=False, clear=True):
2070         """This method should recursively remove a Rational from all arguments
2071         and return that (content) and the new self (primitive). The content
2072         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
2073         The primitive need not be in canonical form and should try to preserve
2074         the underlying structure if possible (i.e. expand_mul should not be
2075         applied to self).
2076 
2077         Examples
2078         ========
2079 
2080         >>> from sympy import sqrt
2081         >>> from sympy.abc import x, y, z
2082 
2083         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
2084 
2085         The as_content_primitive function is recursive and retains structure:
2086 
2087         >>> eq.as_content_primitive()
2088         (2, x + 3*y*(y + 1) + 1)
2089 
2090         Integer powers will have Rationals extracted from the base:
2091 
2092         >>> ((2 + 6*x)**2).as_content_primitive()
2093         (4, (3*x + 1)**2)
2094         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
2095         (1, (2*(3*x + 1))**(2*y))
2096 
2097         Terms may end up joining once their as_content_primitives are added:
2098 
2099         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2100         (11, x*(y + 1))
2101         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2102         (9, x*(y + 1))
2103         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
2104         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
2105         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
2106         (121, x**2*(y + 1)**2)
2107         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
2108         (1, 121.0*x**2*(y + 1)**2)
2109 
2110         Radical content can also be factored out of the primitive:
2111 
2112         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
2113         (2, sqrt(2)*(1 + 2*sqrt(5)))
2114 
2115         If clear=False (default is True) then content will not be removed
2116         from an Add if it can be distributed to leave one or more
2117         terms with integer coefficients.
2118 
2119         >>> (x/2 + y).as_content_primitive()
2120         (1/2, x + 2*y)
2121         >>> (x/2 + y).as_content_primitive(clear=False)
2122         (1, x/2 + y)
2123         """
2124         return S.One, self
2125 
2126     def as_numer_denom(self):
2127         """ expression -> a/b -> a, b
2128 
2129         This is just a stub that should be defined by
2130         an object's class methods to get anything else.
2131 
2132         See Also
2133         ========
2134         normal: return a/b instead of a, b
2135         """
2136 
2137         return self, S.One
2138 
2139     def normal(self):
2140         from .mul import _unevaluated_Mul
2141         n, d = self.as_numer_denom()
2142         if d is S.One:
2143             return n
2144         if d.is_Number:
2145             return _unevaluated_Mul(n, 1/d)
2146         else:
2147             return n/d
2148 
2149     def extract_multiplicatively(self, c):
2150         """Return None if it's not possible to make self in the form
2151            c * something in a nice way, i.e. preserving the properties
2152            of arguments of self.
2153 
2154            Examples
2155            ========
2156 
2157            >>> from sympy import symbols, Rational
2158 
2159            >>> x, y = symbols('x,y', real=True)
2160 
2161            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
2162            x*y**2
2163 
2164            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
2165 
2166            >>> (2*x).extract_multiplicatively(2)
2167            x
2168 
2169            >>> (2*x).extract_multiplicatively(3)
2170 
2171            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
2172            x/6
2173 
2174         """
2175         c = sympify(c)
2176         if self is S.NaN:
2177             return None
2178         if c is S.One:
2179             return self
2180         elif c == self:
2181             return S.One
2182 
2183         if c.is_Add:
2184             cc, pc = c.primitive()
2185             if cc is not S.One:
2186                 c = Mul(cc, pc, evaluate=False)
2187 
2188         if c.is_Mul:
2189             a, b = c.as_two_terms()
2190             x = self.extract_multiplicatively(a)
2191             if x is not None:
2192                 return x.extract_multiplicatively(b)
2193 
2194         quotient = self / c
2195         if self.is_Number:
2196             if self is S.Infinity:
2197                 if c.is_positive:
2198                     return S.Infinity
2199             elif self is S.NegativeInfinity:
2200                 if c.is_negative:
2201                     return S.Infinity
2202                 elif c.is_positive:
2203                     return S.NegativeInfinity
2204             elif self is S.ComplexInfinity:
2205                 if not c.is_zero:
2206                     return S.ComplexInfinity
2207             elif self.is_Integer:
2208                 if not quotient.is_Integer:
2209                     return None
2210                 elif self.is_positive and quotient.is_negative:
2211                     return None
2212                 else:
2213                     return quotient
2214             elif self.is_Rational:
2215                 if not quotient.is_Rational:
2216                     return None
2217                 elif self.is_positive and quotient.is_negative:
2218                     return None
2219                 else:
2220                     return quotient
2221             elif self.is_Float:
2222                 if not quotient.is_Float:
2223                     return None
2224                 elif self.is_positive and quotient.is_negative:
2225                     return None
2226                 else:
2227                     return quotient
2228         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2229             if quotient.is_Mul and len(quotient.args) == 2:
2230                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2231                     return quotient
2232             elif quotient.is_Integer and c.is_Number:
2233                 return quotient
2234         elif self.is_Add:
2235             cs, ps = self.primitive()
2236             # assert cs >= 1
2237             if c.is_Number and c is not S.NegativeOne:
2238                 # assert c != 1 (handled at top)
2239                 if cs is not S.One:
2240                     if c.is_negative:
2241                         xc = -(cs.extract_multiplicatively(-c))
2242                     else:
2243                         xc = cs.extract_multiplicatively(c)
2244                     if xc is not None:
2245                         return xc*ps  # rely on 2-arg Mul to restore Add
2246                 return  # |c| != 1 can only be extracted from cs
2247             if c == ps:
2248                 return cs
2249             # check args of ps
2250             newargs = []
2251             for arg in ps.args:
2252                 newarg = arg.extract_multiplicatively(c)
2253                 if newarg is None:
2254                     return  # all or nothing
2255                 newargs.append(newarg)
2256             # args should be in same order so use unevaluated return
2257             if cs is not S.One:
2258                 return Add._from_args([cs*t for t in newargs])
2259             else:
2260                 return Add._from_args(newargs)
2261         elif self.is_Mul:
2262             args = list(self.args)
2263             for i, arg in enumerate(args):
2264                 newarg = arg.extract_multiplicatively(c)
2265                 if newarg is not None:
2266                     args[i] = newarg
2267                     return Mul(*args)
2268         elif self.is_Pow:
2269             if c.is_Pow and c.base == self.base:
2270                 new_exp = self.exp.extract_additively(c.exp)
2271                 if new_exp is not None:
2272                     return self.base ** (new_exp)
2273             elif c == self.base:
2274                 new_exp = self.exp.extract_additively(1)
2275                 if new_exp is not None:
2276                     return self.base ** (new_exp)
2277 
2278     def extract_additively(self, c):
2279         """Return self - c if it's possible to subtract c from self and
2280         make all matching coefficients move towards zero, else return None.
2281 
2282         Examples
2283         ========
2284 
2285         >>> from sympy.abc import x, y
2286         >>> e = 2*x + 3
2287         >>> e.extract_additively(x + 1)
2288         x + 2
2289         >>> e.extract_additively(3*x)
2290         >>> e.extract_additively(4)
2291         >>> (y*(x + 1)).extract_additively(x + 1)
2292         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2293         (x + 1)*(x + 2*y) + 3
2294 
2295         Sometimes auto-expansion will return a less simplified result
2296         than desired; gcd_terms might be used in such cases:
2297 
2298         >>> from sympy import gcd_terms
2299         >>> (4*x*(y + 1) + y).extract_additively(x)
2300         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2301         >>> gcd_terms(_)
2302         x*(4*y + 3) + y
2303 
2304         See Also
2305         ========
2306         extract_multiplicatively
2307         coeff
2308         as_coefficient
2309 
2310         """
2311 
2312         c = sympify(c)
2313         if self is S.NaN:
2314             return None
2315         if c is S.Zero:
2316             return self
2317         elif c == self:
2318             return S.Zero
2319         elif self is S.Zero:
2320             return None
2321 
2322         if self.is_Number:
2323             if not c.is_Number:
2324                 return None
2325             co = self
2326             diff = co - c
2327             # XXX should we match types? i.e should 3 - .1 succeed?
2328             if (co > 0 and diff > 0 and diff < co or
2329                     co < 0 and diff < 0 and diff > co):
2330                 return diff
2331             return None
2332 
2333         if c.is_Number:
2334             co, t = self.as_coeff_Add()
2335             xa = co.extract_additively(c)
2336             if xa is None:
2337                 return None
2338             return xa + t
2339 
2340         # handle the args[0].is_Number case separately
2341         # since we will have trouble looking for the coeff of
2342         # a number.
2343         if c.is_Add and c.args[0].is_Number:
2344             # whole term as a term factor
2345             co = self.coeff(c)
2346             xa0 = (co.extract_additively(1) or 0)*c
2347             if xa0:
2348                 diff = self - co*c
2349                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2350             # term-wise
2351             h, t = c.as_coeff_Add()
2352             sh, st = self.as_coeff_Add()
2353             xa = sh.extract_additively(h)
2354             if xa is None:
2355                 return None
2356             xa2 = st.extract_additively(t)
2357             if xa2 is None:
2358                 return None
2359             return xa + xa2
2360 
2361         # whole term as a term factor
2362         co = self.coeff(c)
2363         xa0 = (co.extract_additively(1) or 0)*c
2364         if xa0:
2365             diff = self - co*c
2366             return (xa0 + (diff.extract_additively(c) or diff)) or None
2367         # term-wise
2368         coeffs = []
2369         for a in Add.make_args(c):
2370             ac, at = a.as_coeff_Mul()
2371             co = self.coeff(at)
2372             if not co:
2373                 return None
2374             coc, cot = co.as_coeff_Add()
2375             xa = coc.extract_additively(ac)
2376             if xa is None:
2377                 return None
2378             self -= co*at
2379             coeffs.append((cot + xa)*at)
2380         coeffs.append(self)
2381         return Add(*coeffs)
2382 
2383     @property
2384     def expr_free_symbols(self):
2385         """
2386         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.
2387 
2388         Examples
2389         ========
2390 
2391         >>> from sympy.abc import x, y
2392         >>> (x + y).expr_free_symbols
2393         {x, y}
2394 
2395         If the expression is contained in a non-expression object, don't return
2396         the free symbols. Compare:
2397 
2398         >>> from sympy import Tuple
2399         >>> t = Tuple(x + y)
2400         >>> t.expr_free_symbols
2401         set()
2402         >>> t.free_symbols
2403         {x, y}
2404         """
2405         return {j for i in self.args for j in i.expr_free_symbols}
2406 
2407     def could_extract_minus_sign(self):
2408         """Return True if self is not in a canonical form with respect
2409         to its sign.
2410 
2411         For most expressions, e, there will be a difference in e and -e.
2412         When there is, True will be returned for one and False for the
2413         other; False will be returned if there is no difference.
2414 
2415         Examples
2416         ========
2417 
2418         >>> from sympy.abc import x, y
2419         >>> e = x - y
2420         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2421         {False, True}
2422 
2423         """
2424         negative_self = -self
2425         if self == negative_self:
2426             return False  # e.g. zoo*x == -zoo*x
2427         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2428         negative_self_has_minus = (
2429             (negative_self).extract_multiplicatively(-1) is not None)
2430         if self_has_minus != negative_self_has_minus:
2431             return self_has_minus
2432         else:
2433             if self.is_Add:
2434                 # We choose the one with less arguments with minus signs
2435                 all_args = len(self.args)
2436                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2437                 positive_args = all_args - negative_args
2438                 if positive_args > negative_args:
2439                     return False
2440                 elif positive_args < negative_args:
2441                     return True
2442             elif self.is_Mul:
2443                 # We choose the one with an odd number of minus signs
2444                 num, den = self.as_numer_denom()
2445                 args = Mul.make_args(num) + Mul.make_args(den)
2446                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2447                 negative_args = list(filter(None, arg_signs))
2448                 return len(negative_args) % 2 == 1
2449 
2450             # As a last resort, we choose the one with greater value of .sort_key()
2451             return bool(self.sort_key() < negative_self.sort_key())
2452 
2453     def extract_branch_factor(self, allow_half=False):
2454         """
2455         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2456         Return (z, n).
2457 
2458         >>> from sympy import exp_polar, I, pi
2459         >>> from sympy.abc import x, y
2460         >>> exp_polar(I*pi).extract_branch_factor()
2461         (exp_polar(I*pi), 0)
2462         >>> exp_polar(2*I*pi).extract_branch_factor()
2463         (1, 1)
2464         >>> exp_polar(-pi*I).extract_branch_factor()
2465         (exp_polar(I*pi), -1)
2466         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2467         (exp_polar(x + I*pi), 1)
2468         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2469         (y*exp_polar(2*pi*x), -1)
2470         >>> exp_polar(-I*pi/2).extract_branch_factor()
2471         (exp_polar(-I*pi/2), 0)
2472 
2473         If allow_half is True, also extract exp_polar(I*pi):
2474 
2475         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2476         (1, 1/2)
2477         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2478         (1, 1)
2479         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2480         (1, 3/2)
2481         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2482         (1, -1/2)
2483         """
2484         from sympy import exp_polar, pi, I, ceiling, Add
2485         n = S(0)
2486         res = S(1)
2487         args = Mul.make_args(self)
2488         exps = []
2489         for arg in args:
2490             if isinstance(arg, exp_polar):
2491                 exps += [arg.exp]
2492             else:
2493                 res *= arg
2494         piimult = S(0)
2495         extras = []
2496         while exps:
2497             exp = exps.pop()
2498             if exp.is_Add:
2499                 exps += exp.args
2500                 continue
2501             if exp.is_Mul:
2502                 coeff = exp.as_coefficient(pi*I)
2503                 if coeff is not None:
2504                     piimult += coeff
2505                     continue
2506             extras += [exp]
2507         if piimult.is_number:
2508             coeff = piimult
2509             tail = ()
2510         else:
2511             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2512         # round down to nearest multiple of 2
2513         branchfact = ceiling(coeff/2 - S(1)/2)*2
2514         n += branchfact/2
2515         c = coeff - branchfact
2516         if allow_half:
2517             nc = c.extract_additively(1)
2518             if nc is not None:
2519                 n += S(1)/2
2520                 c = nc
2521         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2522         if newexp != 0:
2523             res *= exp_polar(newexp)
2524         return res, n
2525 
2526     def _eval_is_polynomial(self, syms):
2527         if self.free_symbols.intersection(syms) == set([]):
2528             return True
2529         return False
2530 
2531     def is_polynomial(self, *syms):
2532         r"""
2533         Return True if self is a polynomial in syms and False otherwise.
2534 
2535         This checks if self is an exact polynomial in syms.  This function
2536         returns False for expressions that are "polynomials" with symbolic
2537         exponents.  Thus, you should be able to apply polynomial algorithms to
2538         expressions for which this returns True, and Poly(expr, \*syms) should
2539         work if and only if expr.is_polynomial(\*syms) returns True. The
2540         polynomial does not have to be in expanded form.  If no symbols are
2541         given, all free symbols in the expression will be used.
2542 
2543         This is not part of the assumptions system.  You cannot do
2544         Symbol('z', polynomial=True).
2545 
2546         Examples
2547         ========
2548 
2549         >>> from sympy import Symbol
2550         >>> x = Symbol('x')
2551         >>> ((x**2 + 1)**4).is_polynomial(x)
2552         True
2553         >>> ((x**2 + 1)**4).is_polynomial()
2554         True
2555         >>> (2**x + 1).is_polynomial(x)
2556         False
2557 
2558 
2559         >>> n = Symbol('n', nonnegative=True, integer=True)
2560         >>> (x**n + 1).is_polynomial(x)
2561         False
2562 
2563         This function does not attempt any nontrivial simplifications that may
2564         result in an expression that does not appear to be a polynomial to
2565         become one.
2566 
2567         >>> from sympy import sqrt, factor, cancel
2568         >>> y = Symbol('y', positive=True)
2569         >>> a = sqrt(y**2 + 2*y + 1)
2570         >>> a.is_polynomial(y)
2571         False
2572         >>> factor(a)
2573         y + 1
2574         >>> factor(a).is_polynomial(y)
2575         True
2576 
2577         >>> b = (y**2 + 2*y + 1)/(y + 1)
2578         >>> b.is_polynomial(y)
2579         False
2580         >>> cancel(b)
2581         y + 1
2582         >>> cancel(b).is_polynomial(y)
2583         True
2584 
2585         See also .is_rational_function()
2586 
2587         """
2588         if syms:
2589             syms = set(map(sympify, syms))
2590         else:
2591             syms = self.free_symbols
2592 
2593         if syms.intersection(self.free_symbols) == set([]):
2594             # constant polynomial
2595             return True
2596         else:
2597             return self._eval_is_polynomial(syms)
2598 
2599     def _eval_is_rational_function(self, syms):
2600         if self.free_symbols.intersection(syms) == set([]):
2601             return True
2602         return False
2603 
2604     def is_rational_function(self, *syms):
2605         """
2606         Test whether function is a ratio of two polynomials in the given
2607         symbols, syms. When syms is not given, all free symbols will be used.
2608         The rational function does not have to be in expanded or in any kind of
2609         canonical form.
2610 
2611         This function returns False for expressions that are "rational
2612         functions" with symbolic exponents.  Thus, you should be able to call
2613         .as_numer_denom() and apply polynomial algorithms to the result for
2614         expressions for which this returns True.
2615 
2616         This is not part of the assumptions system.  You cannot do
2617         Symbol('z', rational_function=True).
2618 
2619         Examples
2620         ========
2621 
2622         >>> from sympy import Symbol, sin
2623         >>> from sympy.abc import x, y
2624 
2625         >>> (x/y).is_rational_function()
2626         True
2627 
2628         >>> (x**2).is_rational_function()
2629         True
2630 
2631         >>> (x/sin(y)).is_rational_function(y)
2632         False
2633 
2634         >>> n = Symbol('n', integer=True)
2635         >>> (x**n + 1).is_rational_function(x)
2636         False
2637 
2638         This function does not attempt any nontrivial simplifications that may
2639         result in an expression that does not appear to be a rational function
2640         to become one.
2641 
2642         >>> from sympy import sqrt, factor
2643         >>> y = Symbol('y', positive=True)
2644         >>> a = sqrt(y**2 + 2*y + 1)/y
2645         >>> a.is_rational_function(y)
2646         False
2647         >>> factor(a)
2648         (y + 1)/y
2649         >>> factor(a).is_rational_function(y)
2650         True
2651 
2652         See also is_algebraic_expr().
2653 
2654         """
2655         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2656             return False
2657 
2658         if syms:
2659             syms = set(map(sympify, syms))
2660         else:
2661             syms = self.free_symbols
2662 
2663         if syms.intersection(self.free_symbols) == set([]):
2664             # constant rational function
2665             return True
2666         else:
2667             return self._eval_is_rational_function(syms)
2668 
2669     def _eval_is_algebraic_expr(self, syms):
2670         if self.free_symbols.intersection(syms) == set([]):
2671             return True
2672         return False
2673 
2674     def is_algebraic_expr(self, *syms):
2675         """
2676         This tests whether a given expression is algebraic or not, in the
2677         given symbols, syms. When syms is not given, all free symbols
2678         will be used. The rational function does not have to be in expanded
2679         or in any kind of canonical form.
2680 
2681         This function returns False for expressions that are "algebraic
2682         expressions" with symbolic exponents. This is a simple extension to the
2683         is_rational_function, including rational exponentiation.
2684 
2685         Examples
2686         ========
2687 
2688         >>> from sympy import Symbol, sqrt
2689         >>> x = Symbol('x', real=True)
2690         >>> sqrt(1 + x).is_rational_function()
2691         False
2692         >>> sqrt(1 + x).is_algebraic_expr()
2693         True
2694 
2695         This function does not attempt any nontrivial simplifications that may
2696         result in an expression that does not appear to be an algebraic
2697         expression to become one.
2698 
2699         >>> from sympy import exp, factor
2700         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2701         >>> a.is_algebraic_expr(x)
2702         False
2703         >>> factor(a).is_algebraic_expr()
2704         True
2705 
2706         See Also
2707         ========
2708         is_rational_function()
2709 
2710         References
2711         ==========
2712 
2713         - https://en.wikipedia.org/wiki/Algebraic_expression
2714 
2715         """
2716         if syms:
2717             syms = set(map(sympify, syms))
2718         else:
2719             syms = self.free_symbols
2720 
2721         if syms.intersection(self.free_symbols) == set([]):
2722             # constant algebraic expression
2723             return True
2724         else:
2725             return self._eval_is_algebraic_expr(syms)
2726 
2727     ###################################################################################
2728     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2729     ###################################################################################
2730 
2731     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2732         """
2733         Series expansion of "self" around ``x = x0`` yielding either terms of
2734         the series one by one (the lazy series given when n=None), else
2735         all the terms at once when n != None.
2736 
2737         Returns the series expansion of "self" around the point ``x = x0``
2738         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2739 
2740         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2741         be supplied, otherwise an error will be raised.
2742 
2743         Parameters
2744         ==========
2745 
2746         expr : Expression
2747                The expression whose series is to be expanded.
2748 
2749         x : Symbol
2750             It is the variable of the expression to be calculated.
2751 
2752         x0 : Value
2753              The value around which ``x`` is calculated. Can be any value
2754              from ``-oo`` to ``oo``.
2755 
2756         n : Value
2757             The number of terms upto which the series is to be expanded.
2758 
2759         dir : String, optional
2760               The series-expansion can be bi-directional. If ``dir="+"``,
2761               then (x->x0+). If ``dir="-", then (x->x0-). For infinite
2762               ``x0`` (``oo`` or ``-oo``), the ``dir`` argument is determined
2763               from the direction of the infinity (i.e., ``dir="-"`` for
2764               ``oo``).
2765 
2766         logx : optional
2767                It is used to replace any log(x) in the returned series with a
2768                symbolic value rather than evaluating the actual value.
2769 
2770         Examples
2771         ========
2772 
2773         >>> from sympy import cos, exp, tan, oo, series
2774         >>> from sympy.abc import x, y
2775         >>> cos(x).series()
2776         1 - x**2/2 + x**4/24 + O(x**6)
2777         >>> cos(x).series(n=4)
2778         1 - x**2/2 + O(x**4)
2779         >>> cos(x).series(x, x0=1, n=2)
2780         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2781         >>> e = cos(x + exp(y))
2782         >>> e.series(y, n=2)
2783         cos(x + 1) - y*sin(x + 1) + O(y**2)
2784         >>> e.series(x, n=2)
2785         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2786 
2787         If ``n=None`` then a generator of the series terms will be returned.
2788 
2789         >>> term=cos(x).series(n=None)
2790         >>> [next(term) for i in range(2)]
2791         [1, -x**2/2]
2792 
2793         For ``dir=+`` (default) the series is calculated from the right and
2794         for ``dir=-`` the series from the left. For smooth functions this
2795         flag will not alter the results.
2796 
2797         >>> abs(x).series(dir="+")
2798         x
2799         >>> abs(x).series(dir="-")
2800         -x
2801         >>> f = tan(x)
2802         >>> f.series(x, 2, 6, "+")
2803         tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +
2804         (x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +
2805         5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +
2806         2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))
2807 
2808         >>> f.series(x, 2, 3, "-")
2809         tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))
2810         + O((x - 2)**3, (x, 2))
2811 
2812         Returns
2813         =======
2814 
2815         Expr : Expression
2816             Series expansion of the expression about x0
2817 
2818         Raises
2819         ======
2820 
2821         TypeError
2822             If "n" and "x0" are infinity objects
2823 
2824         PoleError
2825             If "x0" is an infinity object
2826 
2827         """
2828         from sympy import collect, Dummy, Order, Rational, Symbol, ceiling
2829         if x is None:
2830             syms = self.free_symbols
2831             if not syms:
2832                 return self
2833             elif len(syms) > 1:
2834                 raise ValueError('x must be given for multivariate functions.')
2835             x = syms.pop()
2836 
2837         if isinstance(x, Symbol):
2838             dep = x in self.free_symbols
2839         else:
2840             d = Dummy()
2841             dep = d in self.xreplace({x: d}).free_symbols
2842         if not dep:
2843             if n is None:
2844                 return (s for s in [self])
2845             else:
2846                 return self
2847 
2848         if len(dir) != 1 or dir not in '+-':
2849             raise ValueError("Dir must be '+' or '-'")
2850 
2851         if x0 in [S.Infinity, S.NegativeInfinity]:
2852             sgn = 1 if x0 is S.Infinity else -1
2853             s = self.subs(x, sgn/x).series(x, n=n, dir='+')
2854             if n is None:
2855                 return (si.subs(x, sgn/x) for si in s)
2856             return s.subs(x, sgn/x)
2857 
2858 
2859         # use rep to shift origin to x0 and change sign (if dir is negative)
2860         # and undo the process with rep2
2861         if x0 or dir == '-':
2862             if dir == '-':
2863                 rep = -x + x0
2864                 rep2 = -x
2865                 rep2b = x0
2866             else:
2867                 rep = x + x0
2868                 rep2 = x
2869                 rep2b = -x0
2870             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2871             if n is None:  # lseries...
2872                 return (si.subs(x, rep2 + rep2b) for si in s)
2873             return s.subs(x, rep2 + rep2b)
2874 
2875         # from here on it's x0=0 and dir='+' handling
2876 
2877         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2878             # replace x with an x that has a positive assumption
2879             xpos = Dummy('x', positive=True, finite=True)
2880             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2881             if n is None:
2882                 return (s.subs(xpos, x) for s in rv)
2883             else:
2884                 return rv.subs(xpos, x)
2885 
2886         if n is not None:  # nseries handling
2887             s1 = self._eval_nseries(x, n=n, logx=logx)
2888             o = s1.getO() or S.Zero
2889             if o:
2890                 # make sure the requested order is returned
2891                 ngot = o.getn()
2892                 if ngot > n:
2893                     # leave o in its current form (e.g. with x*log(x)) so
2894                     # it eats terms properly, then replace it below
2895                     if n != 0:
2896                         s1 += o.subs(x, x**Rational(n, ngot))
2897                     else:
2898                         s1 += Order(1, x)
2899                 elif ngot < n:
2900                     # increase the requested number of terms to get the desired
2901                     # number keep increasing (up to 9) until the received order
2902                     # is different than the original order and then predict how
2903                     # many additional terms are needed
2904                     for more in range(1, 9):
2905                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2906                         newn = s1.getn()
2907                         if newn != ngot:
2908                             ndo = n + ceiling((n - ngot)*more/(newn - ngot))
2909                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2910                             while s1.getn() < n:
2911                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2912                                 ndo += 1
2913                             break
2914                     else:
2915                         raise ValueError('Could not calculate %s terms for %s'
2916                                          % (str(n), self))
2917                     s1 += Order(x**n, x)
2918                 o = s1.getO()
2919                 s1 = s1.removeO()
2920             else:
2921                 o = Order(x**n, x)
2922                 s1done = s1.doit()
2923                 if (s1done + o).removeO() == s1done:
2924                     o = S.Zero
2925 
2926             try:
2927                 return collect(s1, x) + o
2928             except NotImplementedError:
2929                 return s1 + o
2930 
2931         else:  # lseries handling
2932             def yield_lseries(s):
2933                 """Return terms of lseries one at a time."""
2934                 for si in s:
2935                     if not si.is_Add:
2936                         yield si
2937                         continue
2938                     # yield terms 1 at a time if possible
2939                     # by increasing order until all the
2940                     # terms have been returned
2941                     yielded = 0
2942                     o = Order(si, x)*x
2943                     ndid = 0
2944                     ndo = len(si.args)
2945                     while 1:
2946                         do = (si - yielded + o).removeO()
2947                         o *= x
2948                         if not do or do.is_Order:
2949                             continue
2950                         if do.is_Add:
2951                             ndid += len(do.args)
2952                         else:
2953                             ndid += 1
2954                         yield do
2955                         if ndid == ndo:
2956                             break
2957                         yielded += do
2958 
2959             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2960 
2961     def taylor_term(self, n, x, *previous_terms):
2962         """General method for the taylor term.
2963 
2964         This method is slow, because it differentiates n-times. Subclasses can
2965         redefine it to make it faster by using the "previous_terms".
2966         """
2967         from sympy import Dummy, factorial
2968         x = sympify(x)
2969         _x = Dummy('x')
2970         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2971 
2972     def lseries(self, x=None, x0=0, dir='+', logx=None):
2973         """
2974         Wrapper for series yielding an iterator of the terms of the series.
2975 
2976         Note: an infinite series will yield an infinite iterator. The following,
2977         for exaxmple, will never terminate. It will just keep printing terms
2978         of the sin(x) series::
2979 
2980           for term in sin(x).lseries(x):
2981               print term
2982 
2983         The advantage of lseries() over nseries() is that many times you are
2984         just interested in the next term in the series (i.e. the first term for
2985         example), but you don't know how many you should ask for in nseries()
2986         using the "n" parameter.
2987 
2988         See also nseries().
2989         """
2990         return self.series(x, x0, n=None, dir=dir, logx=logx)
2991 
2992     def _eval_lseries(self, x, logx=None):
2993         # default implementation of lseries is using nseries(), and adaptively
2994         # increasing the "n". As you can see, it is not very efficient, because
2995         # we are calculating the series over and over again. Subclasses should
2996         # override this method and implement much more efficient yielding of
2997         # terms.
2998         n = 0
2999         series = self._eval_nseries(x, n=n, logx=logx)
3000         if not series.is_Order:
3001             if series.is_Add:
3002                 yield series.removeO()
3003             else:
3004                 yield series
3005             return
3006 
3007         while series.is_Order:
3008             n += 1
3009             series = self._eval_nseries(x, n=n, logx=logx)
3010         e = series.removeO()
3011         yield e
3012         while 1:
3013             while 1:
3014                 n += 1
3015                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
3016                 if e != series:
3017                     break
3018             yield series - e
3019             e = series
3020 
3021     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
3022         """
3023         Wrapper to _eval_nseries if assumptions allow, else to series.
3024 
3025         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
3026         called. This calculates "n" terms in the innermost expressions and
3027         then builds up the final series just by "cross-multiplying" everything
3028         out.
3029 
3030         The optional ``logx`` parameter can be used to replace any log(x) in the
3031         returned series with a symbolic value to avoid evaluating log(x) at 0. A
3032         symbol to use in place of log(x) should be provided.
3033 
3034         Advantage -- it's fast, because we don't have to determine how many
3035         terms we need to calculate in advance.
3036 
3037         Disadvantage -- you may end up with less terms than you may have
3038         expected, but the O(x**n) term appended will always be correct and
3039         so the result, though perhaps shorter, will also be correct.
3040 
3041         If any of those assumptions is not met, this is treated like a
3042         wrapper to series which will try harder to return the correct
3043         number of terms.
3044 
3045         See also lseries().
3046 
3047         Examples
3048         ========
3049 
3050         >>> from sympy import sin, log, Symbol
3051         >>> from sympy.abc import x, y
3052         >>> sin(x).nseries(x, 0, 6)
3053         x - x**3/6 + x**5/120 + O(x**6)
3054         >>> log(x+1).nseries(x, 0, 5)
3055         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
3056 
3057         Handling of the ``logx`` parameter --- in the following example the
3058         expansion fails since ``sin`` does not have an asymptotic expansion
3059         at -oo (the limit of log(x) as x approaches 0):
3060 
3061         >>> e = sin(log(x))
3062         >>> e.nseries(x, 0, 6)
3063         Traceback (most recent call last):
3064         ...
3065         PoleError: ...
3066         ...
3067         >>> logx = Symbol('logx')
3068         >>> e.nseries(x, 0, 6, logx=logx)
3069         sin(logx)
3070 
3071         In the following example, the expansion works but gives only an Order term
3072         unless the ``logx`` parameter is used:
3073 
3074         >>> e = x**y
3075         >>> e.nseries(x, 0, 2)
3076         O(log(x)**2)
3077         >>> e.nseries(x, 0, 2, logx=logx)
3078         exp(logx*y)
3079 
3080         """
3081         if x and not x in self.free_symbols:
3082             return self
3083         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
3084             return self.series(x, x0, n, dir)
3085         else:
3086             return self._eval_nseries(x, n=n, logx=logx)
3087 
3088     def _eval_nseries(self, x, n, logx):
3089         """
3090         Return terms of series for self up to O(x**n) at x=0
3091         from the positive direction.
3092 
3093         This is a method that should be overridden in subclasses. Users should
3094         never call this method directly (use .nseries() instead), so you don't
3095         have to write docstrings for _eval_nseries().
3096         """
3097         from sympy.utilities.misc import filldedent
3098         raise NotImplementedError(filldedent("""
3099                      The _eval_nseries method should be added to
3100                      %s to give terms up to O(x**n) at x=0
3101                      from the positive direction so it is available when
3102                      nseries calls it.""" % self.func)
3103                      )
3104 
3105     def limit(self, x, xlim, dir='+'):
3106         """ Compute limit x->xlim.
3107         """
3108         from sympy.series.limits import limit
3109         return limit(self, x, xlim, dir)
3110 
3111     def compute_leading_term(self, x, logx=None):
3112         """
3113         as_leading_term is only allowed for results of .series()
3114         This is a wrapper to compute a series first.
3115         """
3116         from sympy import Dummy, log
3117         from sympy.series.gruntz import calculate_series
3118 
3119         if self.removeO() == 0:
3120             return self
3121 
3122         if logx is None:
3123             d = Dummy('logx')
3124             s = calculate_series(self, x, d).subs(d, log(x))
3125         else:
3126             s = calculate_series(self, x, logx)
3127 
3128         return s.as_leading_term(x)
3129 
3130     @cacheit
3131     def as_leading_term(self, *symbols):
3132         """
3133         Returns the leading (nonzero) term of the series expansion of self.
3134 
3135         The _eval_as_leading_term routines are used to do this, and they must
3136         always return a non-zero value.
3137 
3138         Examples
3139         ========
3140 
3141         >>> from sympy.abc import x
3142         >>> (1 + x + x**2).as_leading_term(x)
3143         1
3144         >>> (1/x**2 + x + x**2).as_leading_term(x)
3145         x**(-2)
3146 
3147         """
3148         from sympy import powsimp
3149         if len(symbols) > 1:
3150             c = self
3151             for x in symbols:
3152                 c = c.as_leading_term(x)
3153             return c
3154         elif not symbols:
3155             return self
3156         x = sympify(symbols[0])
3157         if not x.is_symbol:
3158             raise ValueError('expecting a Symbol but got %s' % x)
3159         if x not in self.free_symbols:
3160             return self
3161         obj = self._eval_as_leading_term(x)
3162         if obj is not None:
3163             return powsimp(obj, deep=True, combine='exp')
3164         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
3165 
3166     def _eval_as_leading_term(self, x):
3167         return self
3168 
3169     def as_coeff_exponent(self, x):
3170         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
3171         """
3172         from sympy import collect
3173         s = collect(self, x)
3174         c, p = s.as_coeff_mul(x)
3175         if len(p) == 1:
3176             b, e = p[0].as_base_exp()
3177             if b == x:
3178                 return c, e
3179         return s, S.Zero
3180 
3181     def leadterm(self, x):
3182         """
3183         Returns the leading term a*x**b as a tuple (a, b).
3184 
3185         Examples
3186         ========
3187 
3188         >>> from sympy.abc import x
3189         >>> (1+x+x**2).leadterm(x)
3190         (1, 0)
3191         >>> (1/x**2+x+x**2).leadterm(x)
3192         (1, -2)
3193 
3194         """
3195         from sympy import Dummy, log
3196         l = self.as_leading_term(x)
3197         d = Dummy('logx')
3198         if l.has(log(x)):
3199             l = l.subs(log(x), d)
3200         c, e = l.as_coeff_exponent(x)
3201         if x in c.free_symbols:
3202             from sympy.utilities.misc import filldedent
3203             raise ValueError(filldedent("""
3204                 cannot compute leadterm(%s, %s). The coefficient
3205                 should have been free of x but got %s""" % (self, x, c)))
3206         c = c.subs(d, log(x))
3207         return c, e
3208 
3209     def as_coeff_Mul(self, rational=False):
3210         """Efficiently extract the coefficient of a product. """
3211         return S.One, self
3212 
3213     def as_coeff_Add(self, rational=False):
3214         """Efficiently extract the coefficient of a summation. """
3215         return S.Zero, self
3216 
3217     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3218             full=False):
3219         """
3220         Compute formal power power series of self.
3221 
3222         See the docstring of the :func:`fps` function in sympy.series.formal for
3223         more information.
3224         """
3225         from sympy.series.formal import fps
3226 
3227         return fps(self, x, x0, dir, hyper, order, rational, full)
3228 
3229     def fourier_series(self, limits=None):
3230         """Compute fourier sine/cosine series of self.
3231 
3232         See the docstring of the :func:`fourier_series` in sympy.series.fourier
3233         for more information.
3234         """
3235         from sympy.series.fourier import fourier_series
3236 
3237         return fourier_series(self, limits)
3238 
3239     ###################################################################################
3240     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
3241     ###################################################################################
3242 
3243     def diff(self, *symbols, **assumptions):
3244         assumptions.setdefault("evaluate", True)
3245         return Derivative(self, *symbols, **assumptions)
3246 
3247     ###########################################################################
3248     ###################### EXPRESSION EXPANSION METHODS #######################
3249     ###########################################################################
3250 
3251     # Relevant subclasses should override _eval_expand_hint() methods.  See
3252     # the docstring of expand() for more info.
3253 
3254     def _eval_expand_complex(self, **hints):
3255         real, imag = self.as_real_imag(**hints)
3256         return real + S.ImaginaryUnit*imag
3257 
3258     @staticmethod
3259     def _expand_hint(expr, hint, deep=True, **hints):
3260         """
3261         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
3262 
3263         Returns ``(expr, hit)``, where expr is the (possibly) expanded
3264         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
3265         ``False`` otherwise.
3266         """
3267         hit = False
3268         # XXX: Hack to support non-Basic args
3269         #              |
3270         #              V
3271         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
3272             sargs = []
3273             for arg in expr.args:
3274                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
3275                 hit |= arghit
3276                 sargs.append(arg)
3277 
3278             if hit:
3279                 expr = expr.func(*sargs)
3280 
3281         if hasattr(expr, hint):
3282             newexpr = getattr(expr, hint)(**hints)
3283             if newexpr != expr:
3284                 return (newexpr, True)
3285 
3286         return (expr, hit)
3287 
3288     @cacheit
3289     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
3290             mul=True, log=True, multinomial=True, basic=True, **hints):
3291         """
3292         Expand an expression using hints.
3293 
3294         See the docstring of the expand() function in sympy.core.function for
3295         more information.
3296 
3297         """
3298         from sympy.simplify.radsimp import fraction
3299 
3300         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3301            log=log, multinomial=multinomial, basic=basic)
3302 
3303         expr = self
3304         if hints.pop('frac', False):
3305             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3306                     for a in fraction(self)]
3307             return n/d
3308         elif hints.pop('denom', False):
3309             n, d = fraction(self)
3310             return n/d.expand(deep=deep, modulus=modulus, **hints)
3311         elif hints.pop('numer', False):
3312             n, d = fraction(self)
3313             return n.expand(deep=deep, modulus=modulus, **hints)/d
3314 
3315         # Although the hints are sorted here, an earlier hint may get applied
3316         # at a given node in the expression tree before another because of how
3317         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3318         # x*z) because while applying log at the top level, log and mul are
3319         # applied at the deeper level in the tree so that when the log at the
3320         # upper level gets applied, the mul has already been applied at the
3321         # lower level.
3322 
3323         # Additionally, because hints are only applied once, the expression
3324         # may not be expanded all the way.   For example, if mul is applied
3325         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3326         # now, we just use a special case to make multinomial run before mul,
3327         # so that at least polynomials will be expanded all the way.  In the
3328         # future, smarter heuristics should be applied.
3329         # TODO: Smarter heuristics
3330 
3331         def _expand_hint_key(hint):
3332             """Make multinomial come before mul"""
3333             if hint == 'mul':
3334                 return 'mulz'
3335             return hint
3336 
3337         for hint in sorted(hints.keys(), key=_expand_hint_key):
3338             use_hint = hints[hint]
3339             if use_hint:
3340                 hint = '_eval_expand_' + hint
3341                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3342 
3343         while True:
3344             was = expr
3345             if hints.get('multinomial', False):
3346                 expr, _ = Expr._expand_hint(
3347                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3348             if hints.get('mul', False):
3349                 expr, _ = Expr._expand_hint(
3350                     expr, '_eval_expand_mul', deep=deep, **hints)
3351             if hints.get('log', False):
3352                 expr, _ = Expr._expand_hint(
3353                     expr, '_eval_expand_log', deep=deep, **hints)
3354             if expr == was:
3355                 break
3356 
3357         if modulus is not None:
3358             modulus = sympify(modulus)
3359 
3360             if not modulus.is_Integer or modulus <= 0:
3361                 raise ValueError(
3362                     "modulus must be a positive integer, got %s" % modulus)
3363 
3364             terms = []
3365 
3366             for term in Add.make_args(expr):
3367                 coeff, tail = term.as_coeff_Mul(rational=True)
3368 
3369                 coeff %= modulus
3370 
3371                 if coeff:
3372                     terms.append(coeff*tail)
3373 
3374             expr = Add(*terms)
3375 
3376         return expr
3377 
3378     ###########################################################################
3379     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3380     ###########################################################################
3381 
3382     def integrate(self, *args, **kwargs):
3383         """See the integrate function in sympy.integrals"""
3384         from sympy.integrals import integrate
3385         return integrate(self, *args, **kwargs)
3386 
3387     def simplify(self, ratio=1.7, measure=None, rational=False, inverse=False):
3388         """See the simplify function in sympy.simplify"""
3389         from sympy.simplify import simplify
3390         from sympy.core.function import count_ops
3391         measure = measure or count_ops
3392         return simplify(self, ratio, measure)
3393 
3394     def nsimplify(self, constants=[], tolerance=None, full=False):
3395         """See the nsimplify function in sympy.simplify"""
3396         from sympy.simplify import nsimplify
3397         return nsimplify(self, constants, tolerance, full)
3398 
3399     def separate(self, deep=False, force=False):
3400         """See the separate function in sympy.simplify"""
3401         from sympy.core.function import expand_power_base
3402         return expand_power_base(self, deep=deep, force=force)
3403 
3404     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3405         """See the collect function in sympy.simplify"""
3406         from sympy.simplify import collect
3407         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3408 
3409     def together(self, *args, **kwargs):
3410         """See the together function in sympy.polys"""
3411         from sympy.polys import together
3412         return together(self, *args, **kwargs)
3413 
3414     def apart(self, x=None, **args):
3415         """See the apart function in sympy.polys"""
3416         from sympy.polys import apart
3417         return apart(self, x, **args)
3418 
3419     def ratsimp(self):
3420         """See the ratsimp function in sympy.simplify"""
3421         from sympy.simplify import ratsimp
3422         return ratsimp(self)
3423 
3424     def trigsimp(self, **args):
3425         """See the trigsimp function in sympy.simplify"""
3426         from sympy.simplify import trigsimp
3427         return trigsimp(self, **args)
3428 
3429     def radsimp(self, **kwargs):
3430         """See the radsimp function in sympy.simplify"""
3431         from sympy.simplify import radsimp
3432         return radsimp(self, **kwargs)
3433 
3434     def powsimp(self, *args, **kwargs):
3435         """See the powsimp function in sympy.simplify"""
3436         from sympy.simplify import powsimp
3437         return powsimp(self, *args, **kwargs)
3438 
3439     def combsimp(self):
3440         """See the combsimp function in sympy.simplify"""
3441         from sympy.simplify import combsimp
3442         return combsimp(self)
3443 
3444     def gammasimp(self):
3445         """See the gammasimp function in sympy.simplify"""
3446         from sympy.simplify import gammasimp
3447         return gammasimp(self)
3448 
3449     def factor(self, *gens, **args):
3450         """See the factor() function in sympy.polys.polytools"""
3451         from sympy.polys import factor
3452         return factor(self, *gens, **args)
3453 
3454     def refine(self, assumption=True):
3455         """See the refine function in sympy.assumptions"""
3456         from sympy.assumptions import refine
3457         return refine(self, assumption)
3458 
3459     def cancel(self, *gens, **args):
3460         """See the cancel function in sympy.polys"""
3461         from sympy.polys import cancel
3462         return cancel(self, *gens, **args)
3463 
3464     def invert(self, g, *gens, **args):
3465         """Return the multiplicative inverse of ``self`` mod ``g``
3466         where ``self`` (and ``g``) may be symbolic expressions).
3467 
3468         See Also
3469         ========
3470         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3471         """
3472         from sympy.polys.polytools import invert
3473         from sympy.core.numbers import mod_inverse
3474         if self.is_number and getattr(g, 'is_number', True):
3475             return mod_inverse(self, g)
3476         return invert(self, g, *gens, **args)
3477 
3478     def round(self, n=None):
3479         """Return x rounded to the given decimal place.
3480 
3481         If a complex number would results, apply round to the real
3482         and imaginary components of the number.
3483 
3484         Examples
3485         ========
3486 
3487         >>> from sympy import pi, E, I, S, Add, Mul, Number
3488         >>> pi.round()
3489         3
3490         >>> pi.round(2)
3491         3.14
3492         >>> (2*pi + E*I).round()
3493         6 + 3*I
3494 
3495         The round method has a chopping effect:
3496 
3497         >>> (2*pi + I/10).round()
3498         6
3499         >>> (pi/10 + 2*I).round()
3500         2*I
3501         >>> (pi/10 + E*I).round(2)
3502         0.31 + 2.72*I
3503 
3504         Notes
3505         =====
3506 
3507         The Python builtin function, round, always returns a
3508         float in Python 2 while the SymPy round method (and
3509         round with a Number argument in Python 3) returns a
3510         Number.
3511 
3512         >>> from sympy.core.compatibility import PY3
3513         >>> isinstance(round(S(123), -2), Number if PY3 else float)
3514         True
3515 
3516         For a consistent behavior, and Python 3 rounding
3517         rules, import `round` from sympy.core.compatibility.
3518 
3519         >>> from sympy.core.compatibility import round
3520         >>> isinstance(round(S(123), -2), Number)
3521         True
3522         """
3523         from sympy.core.power import integer_log
3524         from sympy.core.numbers import Float
3525 
3526         x = self
3527 
3528         if not x.is_number:
3529             raise TypeError("can't round symbolic expression")
3530         if not x.is_Atom:
3531             if not pure_complex(x.n(2), or_real=True):
3532                 raise TypeError(
3533                     'Expected a number but got %s:' % func_name(x))
3534         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3535             return x
3536         if not x.is_extended_real:
3537             i, r = x.as_real_imag()
3538             return i.round(n) + S.ImaginaryUnit*r.round(n)
3539         if not x:
3540             return S.Zero if n is None else x
3541 
3542 
3543         p = as_int(n or 0)
3544 
3545         if x.is_Integer:
3546             # XXX return Integer(round(int(x), p)) when Py2 is dropped
3547             if p >= 0:
3548                 return x
3549             m = 10**-p
3550             i, r = divmod(abs(x), m)
3551             if i%2 and 2*r == m:
3552               i += 1
3553             elif 2*r > m:
3554                 i += 1
3555             if x < 0:
3556                 i *= -1
3557             return i*m
3558 
3559         digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1
3560         allow = digits_needed = digits_to_decimal + p
3561         precs = [f._prec for f in x.atoms(Float)]
3562         dps = prec_to_dps(max(precs)) if precs else None
3563         if dps is None:
3564             # assume everything is exact so use the Python
3565             # float default or whatever was requested
3566             dps = max(15, allow)
3567         else:
3568             allow = min(allow, dps)
3569         # this will shift all digits to right of decimal
3570         # and give us dps to work with as an int
3571         shift = -digits_to_decimal + dps
3572         extra = 1  # how far we look past known digits
3573         # NOTE
3574         # mpmath will calculate the binary representation to
3575         # an arbitrary number of digits but we must base our
3576         # answer on a finite number of those digits, e.g.
3577         # .575 2589569785738035/2**52 in binary.
3578         # mpmath shows us that the first 18 digits are
3579         #     >>> Float(.575).n(18)
3580         #     0.574999999999999956
3581         # The default precision is 15 digits and if we ask
3582         # for 15 we get
3583         #     >>> Float(.575).n(15)
3584         #     0.575000000000000
3585         # mpmath handles rounding at the 15th digit. But we
3586         # need to be careful since the user might be asking
3587         # for rounding at the last digit and our semantics
3588         # are to round toward the even final digit when there
3589         # is a tie. So the extra digit will be used to make
3590         # that decision. In this case, the value is the same
3591         # to 15 digits:
3592         #     >>> Float(.575).n(16)
3593         #     0.5750000000000000
3594         # Now converting this to the 15 known digits gives
3595         #     575000000000000.0
3596         # which rounds to integer
3597         #    5750000000000000
3598         # And now we can round to the desired digt, e.g. at
3599         # the second from the left and we get
3600         #    5800000000000000
3601         # and rescaling that gives
3602         #    0.58
3603         # as the final result.
3604         # If the value is made slightly less than 0.575 we might
3605         # still obtain the same value:
3606         #    >>> Float(.575-1e-16).n(16)*10**15
3607         #    574999999999999.8
3608         # What 15 digits best represents the known digits (which are
3609         # to the left of the decimal? 5750000000000000, the same as
3610         # before. The only way we will round down (in this case) is
3611         # if we declared that we had more than 15 digits of precision.
3612         # For example, if we use 16 digits of precision, the integer
3613         # we deal with is
3614         #    >>> Float(.575-1e-16).n(17)*10**16
3615         #    5749999999999998.4
3616         # and this now rounds to 5749999999999998 and (if we round to
3617         # the 2nd digit from the left) we get 5700000000000000.
3618         #
3619         xf = x.n(dps + extra)*Pow(10, shift)
3620         xi = Integer(xf)
3621         # use the last digit to select the value of xi
3622         # nearest to x before rounding at the desired digit
3623         sign = 1 if x > 0 else -1
3624         dif2 = sign*(xf - xi).n(extra)
3625         if dif2 < 0:
3626             raise NotImplementedError(
3627                 'not expecting int(x) to round away from 0')
3628         if dif2 > .5:
3629             xi += sign  # round away from 0
3630         elif dif2 == .5:
3631             xi += sign if xi%2 else -sign  # round toward even
3632         # shift p to the new position
3633         ip = p - shift
3634         # let Python handle the int rounding then rescale
3635         xr = xi.round(ip) # when Py2 is drop make this round(xi.p, ip)
3636         # restore scale
3637         rv = Rational(xr, Pow(10, shift))
3638         # return Float or Integer
3639         if rv.is_Integer:
3640             if n is None:  # the single-arg case
3641                 return rv
3642             # use str or else it won't be a float
3643             return Float(str(rv), dps)  # keep same precision
3644         else:
3645             if not allow and rv > self:
3646                 allow += 1
3647             return Float(rv, allow)
3648 
3649     __round__ = round
3650 
3651     def _eval_derivative_matrix_lines(self, x):
3652         from sympy.matrices.expressions.matexpr import _LeftRightArgs
3653         return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 20:52:38.824 | INFO     | Search completed. Bug locations: [<file>sympy/simplify/fu.py</file>
<class>None</class>
<method>TR6</method>
<code>
548 def TR6(rv, max=4, pow=False):
549     """Replacement of cos**2 with 1 - sin(x)**2.
550 
551     See _TR56 docstring for advanced use of ``max`` and ``pow``.
552 
553     Examples
554     ========
555 
556     >>> from sympy.simplify.fu import TR6
557     >>> from sympy.abc import x
558     >>> from sympy import cos
559     >>> TR6(cos(x)**2)
560     1 - sin(x)**2
561     >>> TR6(cos(x)**-2)  #unchanged
562     cos(x)**(-2)
563     >>> TR6(cos(x)**4)
564     (1 - sin(x)**2)**2
565     """
566     return _TR56(rv, cos, sin, lambda x: 1 - x, max=max, pow=pow)

</code><intended_behavior>The TR6 method should be modified to better handle cases where the exponent is a complex number. Specifically, it should check whether the exponent is complex and, if so, either apply a suitable simplification rule that is mathematically valid for complex exponents or skip the transformation if no such rule is appropriate. This would preserve the function's role in simplifying trigonometric expressions while preventing errors caused by invalid comparisons of complex numbers.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>__lt__</method>
<code>
398     def __lt__(self, other):
399         from sympy import StrictLessThan
400         try:
401             other = _sympify(other)
402         except SympifyError:
403             raise TypeError("Invalid comparison %s < %s" % (self, other))
404         for me in (self, other):
405             if me.is_complex and me.is_extended_real is False:
406                 raise TypeError("Invalid comparison of complex %s" % me)
407             if me is S.NaN:
408                 raise TypeError("Invalid NaN comparison")
409         n2 = _n2(self, other)
410         if n2 is not None:
411             return _sympify(n2 < 0)
412         if self.is_extended_real and other.is_extended_real:
413             if (self.is_infinite and self.is_extended_positive) \
414                     or (other.is_infinite and other.is_extended_negative):
415                 return S.false
416             neg = (self - other).is_extended_negative
417             if neg is not None:
418                 return sympify(neg)
419         return StrictLessThan(self, other, evaluate=False)

</code><intended_behavior>While the `__lt__` method itself correctly raises a TypeError on invalid comparisons involving complex numbers (as comparing complex numbers using less than/greater than is not mathematically valid), the context of its use indicates that there might be a need for upstream validation or handling before comparisons reach this point. Consequently, this suggests that upstream methods (like those involved in expression simplification or transformation, potentially `simplify` or `trigsimp`) may need enhancement to ensure they do not perform illegitimate comparisons on complex numbers. However, `__lt__` should remain unchanged as its behavior is correct; the change should rather be in how comparisons are formulated or performed in the simplification procedures, specifically ensuring that complex expressions are handled in a way to avoid direct comparison using `<` or `>` operations.</intended_behavior>, <file>sympy/core/expr.py</file>
<class>Expr</class>
<method>None</method>
<code>
15 class Expr(Basic, EvalfMixin):
16     """
17     Base class for algebraic expressions.
18 
19     Everything that requires arithmetic operations to be defined
20     should subclass this class, instead of Basic (which should be
21     used only for argument storage and expression manipulation, i.e.
22     pattern matching, substitutions, etc).
23 
24     See Also
25     ========
26 
27     sympy.core.basic.Basic
28     """
29 
30     __slots__ = []
31 
32     is_scalar = True  # self derivative is 1
33 
34     @property
35     def _diff_wrt(self):
36         """Return True if one can differentiate with respect to this
37         object, else False.
38 
39         Subclasses such as Symbol, Function and Derivative return True
40         to enable derivatives wrt them. The implementation in Derivative
41         separates the Symbol and non-Symbol (_diff_wrt=True) variables and
42         temporarily converts the non-Symbols into Symbols when performing
43         the differentiation. By default, any object deriving from Expr
44         will behave like a scalar with self.diff(self) == 1. If this is
45         not desired then the object must also set `is_scalar = False` or
46         else define an _eval_derivative routine.
47 
48         Note, see the docstring of Derivative for how this should work
49         mathematically. In particular, note that expr.subs(yourclass, Symbol)
50         should be well-defined on a structural level, or this will lead to
51         inconsistent results.
52 
53         Examples
54         ========
55 
56         >>> from sympy import Expr
57         >>> e = Expr()
58         >>> e._diff_wrt
59         False
60         >>> class MyScalar(Expr):
61         ...     _diff_wrt = True
62         ...
63         >>> MyScalar().diff(MyScalar())
64         1
65         >>> class MySymbol(Expr):
66         ...     _diff_wrt = True
67         ...     is_scalar = False
68         ...
69         >>> MySymbol().diff(MySymbol())
70         Derivative(MySymbol(), MySymbol())
71         """
72         return False
73 
74     @cacheit
75     def sort_key(self, order=None):
76 
77         coeff, expr = self.as_coeff_Mul()
78 
79         if expr.is_Pow:
80             expr, exp = expr.args
81         else:
82             expr, exp = expr, S.One
83 
84         if expr.is_Dummy:
85             args = (expr.sort_key(),)
86         elif expr.is_Atom:
87             args = (str(expr),)
88         else:
89             if expr.is_Add:
90                 args = expr.as_ordered_terms(order=order)
91             elif expr.is_Mul:
92                 args = expr.as_ordered_factors(order=order)
93             else:
94                 args = expr.args
95 
96             args = tuple(
97                 [ default_sort_key(arg, order=order) for arg in args ])
98 
99         args = (len(args), tuple(args))
100         exp = exp.sort_key(order=order)
101 
102         return expr.class_key(), args, exp, coeff
103 
104     def __hash__(self):
105         # hash cannot be cached using cache_it because infinite recurrence
106         # occurs as hash is needed for setting cache dictionary keys
107         h = self._mhash
108         if h is None:
109             h = hash((type(self).__name__,) + self._hashable_content())
110             self._mhash = h
111         return h
112 
113     def _hashable_content(self):
114         """Return a tuple of information about self that can be used to
115         compute the hash. If a class defines additional attributes,
116         like ``name`` in Symbol, then this method should be updated
117         accordingly to return such relevant attributes.
118         Defining more than _hashable_content is necessary if __eq__ has
119         been defined by a class. See note about this in Basic.__eq__."""
120         return self._args
121 
122     def __eq__(self, other):
123         try:
124             other = sympify(other)
125             if not isinstance(other, Expr):
126                 return False
127         except (SympifyError, SyntaxError):
128             return False
129         # check for pure number expr
130         if  not (self.is_Number and other.is_Number) and (
131                 type(self) != type(other)):
132             return False
133         a, b = self._hashable_content(), other._hashable_content()
134         if a != b:
135             return False
136         # check number *in* an expression
137         for a, b in zip(a, b):
138             if not isinstance(a, Expr):
139                 continue
140             if a.is_Number and type(a) != type(b):
141                 return False
142         return True
143 
144     # ***************
145     # * Arithmetics *
146     # ***************
147     # Expr and its sublcasses use _op_priority to determine which object
148     # passed to a binary special method (__mul__, etc.) will handle the
149     # operation. In general, the 'call_highest_priority' decorator will choose
150     # the object with the highest _op_priority to handle the call.
151     # Custom subclasses that want to define their own binary special methods
152     # should set an _op_priority value that is higher than the default.
153     #
154     # **NOTE**:
155     # This is a temporary fix, and will eventually be replaced with
156     # something better and more powerful.  See issue 5510.
157     _op_priority = 10.0
158 
159     def __pos__(self):
160         return self
161 
162     def __neg__(self):
163         return Mul(S.NegativeOne, self)
164 
165     def __abs__(self):
166         from sympy import Abs
167         return Abs(self)
168 
169     @_sympifyit('other', NotImplemented)
170     @call_highest_priority('__radd__')
171     def __add__(self, other):
172         return Add(self, other)
173 
174     @_sympifyit('other', NotImplemented)
175     @call_highest_priority('__add__')
176     def __radd__(self, other):
177         return Add(other, self)
178 
179     @_sympifyit('other', NotImplemented)
180     @call_highest_priority('__rsub__')
181     def __sub__(self, other):
182         return Add(self, -other)
183 
184     @_sympifyit('other', NotImplemented)
185     @call_highest_priority('__sub__')
186     def __rsub__(self, other):
187         return Add(other, -self)
188 
189     @_sympifyit('other', NotImplemented)
190     @call_highest_priority('__rmul__')
191     def __mul__(self, other):
192         return Mul(self, other)
193 
194     @_sympifyit('other', NotImplemented)
195     @call_highest_priority('__mul__')
196     def __rmul__(self, other):
197         return Mul(other, self)
198 
199     @_sympifyit('other', NotImplemented)
200     @call_highest_priority('__rpow__')
201     def _pow(self, other):
202         return Pow(self, other)
203 
204     def __pow__(self, other, mod=None):
205         if mod is None:
206             return self._pow(other)
207         try:
208             _self, other, mod = as_int(self), as_int(other), as_int(mod)
209             if other >= 0:
210                 return pow(_self, other, mod)
211             else:
212                 from sympy.core.numbers import mod_inverse
213                 return mod_inverse(pow(_self, -other, mod), mod)
214         except ValueError:
215             power = self._pow(other)
216             try:
217                 return power%mod
218             except TypeError:
219                 return NotImplemented
220 
221     @_sympifyit('other', NotImplemented)
222     @call_highest_priority('__pow__')
223     def __rpow__(self, other):
224         return Pow(other, self)
225 
226     @_sympifyit('other', NotImplemented)
227     @call_highest_priority('__rdiv__')
228     def __div__(self, other):
229         return Mul(self, Pow(other, S.NegativeOne))
230 
231     @_sympifyit('other', NotImplemented)
232     @call_highest_priority('__div__')
233     def __rdiv__(self, other):
234         return Mul(other, Pow(self, S.NegativeOne))
235 
236     __truediv__ = __div__
237     __rtruediv__ = __rdiv__
238 
239     @_sympifyit('other', NotImplemented)
240     @call_highest_priority('__rmod__')
241     def __mod__(self, other):
242         return Mod(self, other)
243 
244     @_sympifyit('other', NotImplemented)
245     @call_highest_priority('__mod__')
246     def __rmod__(self, other):
247         return Mod(other, self)
248 
249     @_sympifyit('other', NotImplemented)
250     @call_highest_priority('__rfloordiv__')
251     def __floordiv__(self, other):
252         from sympy.functions.elementary.integers import floor
253         return floor(self / other)
254 
255     @_sympifyit('other', NotImplemented)
256     @call_highest_priority('__floordiv__')
257     def __rfloordiv__(self, other):
258         from sympy.functions.elementary.integers import floor
259         return floor(other / self)
260 
261 
262     @_sympifyit('other', NotImplemented)
263     @call_highest_priority('__rdivmod__')
264     def __divmod__(self, other):
265         from sympy.functions.elementary.integers import floor
266         return floor(self / other), Mod(self, other)
267 
268     @_sympifyit('other', NotImplemented)
269     @call_highest_priority('__divmod__')
270     def __rdivmod__(self, other):
271         from sympy.functions.elementary.integers import floor
272         return floor(other / self), Mod(other, self)
273 
274     def __int__(self):
275         # Although we only need to round to the units position, we'll
276         # get one more digit so the extra testing below can be avoided
277         # unless the rounded value rounded to an integer, e.g. if an
278         # expression were equal to 1.9 and we rounded to the unit position
279         # we would get a 2 and would not know if this rounded up or not
280         # without doing a test (as done below). But if we keep an extra
281         # digit we know that 1.9 is not the same as 1 and there is no
282         # need for further testing: our int value is correct. If the value
283         # were 1.99, however, this would round to 2.0 and our int value is
284         # off by one. So...if our round value is the same as the int value
285         # (regardless of how much extra work we do to calculate extra decimal
286         # places) we need to test whether we are off by one.
287         from sympy import Dummy
288         if not self.is_number:
289             raise TypeError("can't convert symbols to int")
290         r = self.round(2)
291         if not r.is_Number:
292             raise TypeError("can't convert complex to int")
293         if r in (S.NaN, S.Infinity, S.NegativeInfinity):
294             raise TypeError("can't convert %s to int" % r)
295         i = int(r)
296         if not i:
297             return 0
298         # off-by-one check
299         if i == r and not (self - i).equals(0):
300             isign = 1 if i > 0 else -1
301             x = Dummy()
302             # in the following (self - i).evalf(2) will not always work while
303             # (self - r).evalf(2) and the use of subs does; if the test that
304             # was added when this comment was added passes, it might be safe
305             # to simply use sign to compute this rather than doing this by hand:
306             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1
307             if diff_sign != isign:
308                 i -= isign
309         return i
310     __long__ = __int__
311 
312     def __float__(self):
313         # Don't bother testing if it's a number; if it's not this is going
314         # to fail, and if it is we still need to check that it evalf'ed to
315         # a number.
316         result = self.evalf()
317         if result.is_Number:
318             return float(result)
319         if result.is_number and result.as_real_imag()[1]:
320             raise TypeError("can't convert complex to float")
321         raise TypeError("can't convert expression to float")
322 
323     def __complex__(self):
324         result = self.evalf()
325         re, im = result.as_real_imag()
326         return complex(float(re), float(im))
327 
328     def __ge__(self, other):
329         from sympy import GreaterThan
330         try:
331             other = _sympify(other)
332         except SympifyError:
333             raise TypeError("Invalid comparison %s >= %s" % (self, other))
334         for me in (self, other):
335             if me.is_complex and me.is_extended_real is False:
336                 raise TypeError("Invalid comparison of complex %s" % me)
337             if me is S.NaN:
338                 raise TypeError("Invalid NaN comparison")
339         n2 = _n2(self, other)
340         if n2 is not None:
341             return _sympify(n2 >= 0)
342         if self.is_extended_real and other.is_extended_real:
343             if (self.is_infinite and self.is_extended_positive) \
344                     or (other.is_infinite and other.is_extended_negative):
345                 return S.true
346             nneg = (self - other).is_extended_nonnegative
347             if nneg is not None:
348                 return sympify(nneg)
349         return GreaterThan(self, other, evaluate=False)
350 
351     def __le__(self, other):
352         from sympy import LessThan
353         try:
354             other = _sympify(other)
355         except SympifyError:
356             raise TypeError("Invalid comparison %s <= %s" % (self, other))
357         for me in (self, other):
358             if me.is_complex and me.is_extended_real is False:
359                 raise TypeError("Invalid comparison of complex %s" % me)
360             if me is S.NaN:
361                 raise TypeError("Invalid NaN comparison")
362         n2 = _n2(self, other)
363         if n2 is not None:
364             return _sympify(n2 <= 0)
365         if self.is_extended_real and other.is_extended_real:
366             if (self.is_infinite and self.is_extended_negative) \
367                     or (other.is_infinite and other.is_extended_positive):
368                 return S.true
369             npos = (self - other).is_extended_nonpositive
370             if npos is not None:
371                 return sympify(npos)
372         return LessThan(self, other, evaluate=False)
373 
374     def __gt__(self, other):
375         from sympy import StrictGreaterThan
376         try:
377             other = _sympify(other)
378         except SympifyError:
379             raise TypeError("Invalid comparison %s > %s" % (self, other))
380         for me in (self, other):
381             if me.is_complex and me.is_extended_real is False:
382                 raise TypeError("Invalid comparison of complex %s" % me)
383             if me is S.NaN:
384                 raise TypeError("Invalid NaN comparison")
385         n2 = _n2(self, other)
386         if n2 is not None:
387             return _sympify(n2 > 0)
388 
389         if self.is_extended_real and other.is_extended_real:
390             if (self.is_infinite and self.is_extended_negative) \
391                     or (other.is_infinite and other.is_extended_positive):
392                 return S.false
393             pos = (self - other).is_extended_positive
394             if pos is not None:
395                 return sympify(pos)
396         return StrictGreaterThan(self, other, evaluate=False)
397 
398     def __lt__(self, other):
399         from sympy import StrictLessThan
400         try:
401             other = _sympify(other)
402         except SympifyError:
403             raise TypeError("Invalid comparison %s < %s" % (self, other))
404         for me in (self, other):
405             if me.is_complex and me.is_extended_real is False:
406                 raise TypeError("Invalid comparison of complex %s" % me)
407             if me is S.NaN:
408                 raise TypeError("Invalid NaN comparison")
409         n2 = _n2(self, other)
410         if n2 is not None:
411             return _sympify(n2 < 0)
412         if self.is_extended_real and other.is_extended_real:
413             if (self.is_infinite and self.is_extended_positive) \
414                     or (other.is_infinite and other.is_extended_negative):
415                 return S.false
416             neg = (self - other).is_extended_negative
417             if neg is not None:
418                 return sympify(neg)
419         return StrictLessThan(self, other, evaluate=False)
420 
421     def __trunc__(self):
422         if not self.is_number:
423             raise TypeError("can't truncate symbols and expressions")
424         else:
425             return Integer(self)
426 
427     @staticmethod
428     def _from_mpmath(x, prec):
429         from sympy import Float
430         if hasattr(x, "_mpf_"):
431             return Float._new(x._mpf_, prec)
432         elif hasattr(x, "_mpc_"):
433             re, im = x._mpc_
434             re = Float._new(re, prec)
435             im = Float._new(im, prec)*S.ImaginaryUnit
436             return re + im
437         else:
438             raise TypeError("expected mpmath number (mpf or mpc)")
439 
440     @property
441     def is_number(self):
442         """Returns True if ``self`` has no free symbols and no
443         undefined functions (AppliedUndef, to be precise). It will be
444         faster than ``if not self.free_symbols``, however, since
445         ``is_number`` will fail as soon as it hits a free symbol
446         or undefined function.
447 
448         Examples
449         ========
450 
451         >>> from sympy import log, Integral, cos, sin, pi
452         >>> from sympy.core.function import Function
453         >>> from sympy.abc import x
454         >>> f = Function('f')
455 
456         >>> x.is_number
457         False
458         >>> f(1).is_number
459         False
460         >>> (2*x).is_number
461         False
462         >>> (2 + Integral(2, x)).is_number
463         False
464         >>> (2 + Integral(2, (x, 1, 2))).is_number
465         True
466 
467         Not all numbers are Numbers in the SymPy sense:
468 
469         >>> pi.is_number, pi.is_Number
470         (True, False)
471 
472         If something is a number it should evaluate to a number with
473         real and imaginary parts that are Numbers; the result may not
474         be comparable, however, since the real and/or imaginary part
475         of the result may not have precision.
476 
477         >>> cos(1).is_number and cos(1).is_comparable
478         True
479 
480         >>> z = cos(1)**2 + sin(1)**2 - 1
481         >>> z.is_number
482         True
483         >>> z.is_comparable
484         False
485 
486         See Also
487         ========
488         sympy.core.basic.is_comparable
489         """
490         return all(obj.is_number for obj in self.args)
491 
492     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):
493         """Return self evaluated, if possible, replacing free symbols with
494         random complex values, if necessary.
495 
496         The random complex value for each free symbol is generated
497         by the random_complex_number routine giving real and imaginary
498         parts in the range given by the re_min, re_max, im_min, and im_max
499         values. The returned value is evaluated to a precision of n
500         (if given) else the maximum of 15 and the precision needed
501         to get more than 1 digit of precision. If the expression
502         could not be evaluated to a number, or could not be evaluated
503         to more than 1 digit of precision, then None is returned.
504 
505         Examples
506         ========
507 
508         >>> from sympy import sqrt
509         >>> from sympy.abc import x, y
510         >>> x._random()                         # doctest: +SKIP
511         0.0392918155679172 + 0.916050214307199*I
512         >>> x._random(2)                        # doctest: +SKIP
513         -0.77 - 0.87*I
514         >>> (x + y/2)._random(2)                # doctest: +SKIP
515         -0.57 + 0.16*I
516         >>> sqrt(2)._random(2)
517         1.4
518 
519         See Also
520         ========
521 
522         sympy.utilities.randtest.random_complex_number
523         """
524 
525         free = self.free_symbols
526         prec = 1
527         if free:
528             from sympy.utilities.randtest import random_complex_number
529             a, c, b, d = re_min, re_max, im_min, im_max
530             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)
531                            for zi in free])))
532             try:
533                 nmag = abs(self.evalf(2, subs=reps))
534             except (ValueError, TypeError):
535                 # if an out of range value resulted in evalf problems
536                 # then return None -- XXX is there a way to know how to
537                 # select a good random number for a given expression?
538                 # e.g. when calculating n! negative values for n should not
539                 # be used
540                 return None
541         else:
542             reps = {}
543             nmag = abs(self.evalf(2))
544 
545         if not hasattr(nmag, '_prec'):
546             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True
547             return None
548 
549         if nmag._prec == 1:
550             # increase the precision up to the default maximum
551             # precision to see if we can get any significance
552 
553             from mpmath.libmp.libintmath import giant_steps
554             from sympy.core.evalf import DEFAULT_MAXPREC as target
555 
556             # evaluate
557             for prec in giant_steps(2, target):
558                 nmag = abs(self.evalf(prec, subs=reps))
559                 if nmag._prec != 1:
560                     break
561 
562         if nmag._prec != 1:
563             if n is None:
564                 n = max(prec, 15)
565             return self.evalf(n, subs=reps)
566 
567         # never got any significance
568         return None
569 
570     def is_constant(self, *wrt, **flags):
571         """Return True if self is constant, False if not, or None if
572         the constancy could not be determined conclusively.
573 
574         If an expression has no free symbols then it is a constant. If
575         there are free symbols it is possible that the expression is a
576         constant, perhaps (but not necessarily) zero. To test such
577         expressions, two strategies are tried:
578 
579         1) numerical evaluation at two random points. If two such evaluations
580         give two different values and the values have a precision greater than
581         1 then self is not constant. If the evaluations agree or could not be
582         obtained with any precision, no decision is made. The numerical testing
583         is done only if ``wrt`` is different than the free symbols.
584 
585         2) differentiation with respect to variables in 'wrt' (or all free
586         symbols if omitted) to see if the expression is constant or not. This
587         will not always lead to an expression that is zero even though an
588         expression is constant (see added test in test_expr.py). If
589         all derivatives are zero then self is constant with respect to the
590         given symbols.
591 
592         If neither evaluation nor differentiation can prove the expression is
593         constant, None is returned unless two numerical values happened to be
594         the same and the flag ``failing_number`` is True -- in that case the
595         numerical value will be returned.
596 
597         If flag simplify=False is passed, self will not be simplified;
598         the default is True since self should be simplified before testing.
599 
600         Examples
601         ========
602 
603         >>> from sympy import cos, sin, Sum, S, pi
604         >>> from sympy.abc import a, n, x, y
605         >>> x.is_constant()
606         False
607         >>> S(2).is_constant()
608         True
609         >>> Sum(x, (x, 1, 10)).is_constant()
610         True
611         >>> Sum(x, (x, 1, n)).is_constant()
612         False
613         >>> Sum(x, (x, 1, n)).is_constant(y)
614         True
615         >>> Sum(x, (x, 1, n)).is_constant(n)
616         False
617         >>> Sum(x, (x, 1, n)).is_constant(x)
618         True
619         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a
620         >>> eq.is_constant()
621         True
622         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0
623         True
624 
625         >>> (0**x).is_constant()
626         False
627         >>> x.is_constant()
628         False
629         >>> (x**x).is_constant()
630         False
631         >>> one = cos(x)**2 + sin(x)**2
632         >>> one.is_constant()
633         True
634         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1
635         True
636         """
637 
638         simplify = flags.get('simplify', True)
639 
640         if self.is_number:
641             return True
642         free = self.free_symbols
643         if not free:
644             return True  # assume f(1) is some constant
645 
646         # if we are only interested in some symbols and they are not in the
647         # free symbols then this expression is constant wrt those symbols
648         wrt = set(wrt)
649         if wrt and not wrt & free:
650             return True
651         wrt = wrt or free
652 
653         # simplify unless this has already been done
654         expr = self
655         if simplify:
656             expr = expr.simplify()
657 
658         # is_zero should be a quick assumptions check; it can be wrong for
659         # numbers (see test_is_not_constant test), giving False when it
660         # shouldn't, but hopefully it will never give True unless it is sure.
661         if expr.is_zero:
662             return True
663 
664         # try numerical evaluation to see if we get two different values
665         failing_number = None
666         if wrt == free:
667             # try 0 (for a) and 1 (for b)
668             try:
669                 a = expr.subs(list(zip(free, [0]*len(free))),
670                     simultaneous=True)
671                 if a is S.NaN:
672                     # evaluation may succeed when substitution fails
673                     a = expr._random(None, 0, 0, 0, 0)
674             except ZeroDivisionError:
675                 a = None
676             if a is not None and a is not S.NaN:
677                 try:
678                     b = expr.subs(list(zip(free, [1]*len(free))),
679                         simultaneous=True)
680                     if b is S.NaN:
681                         # evaluation may succeed when substitution fails
682                         b = expr._random(None, 1, 0, 1, 0)
683                 except ZeroDivisionError:
684                     b = None
685                 if b is not None and b is not S.NaN and b.equals(a) is False:
686                     return False
687                 # try random real
688                 b = expr._random(None, -1, 0, 1, 0)
689                 if b is not None and b is not S.NaN and b.equals(a) is False:
690                     return False
691                 # try random complex
692                 b = expr._random()
693                 if b is not None and b is not S.NaN:
694                     if b.equals(a) is False:
695                         return False
696                     failing_number = a if a.is_number else b
697 
698         # now we will test each wrt symbol (or all free symbols) to see if the
699         # expression depends on them or not using differentiation. This is
700         # not sufficient for all expressions, however, so we don't return
701         # False if we get a derivative other than 0 with free symbols.
702         for w in wrt:
703             deriv = expr.diff(w)
704             if simplify:
705                 deriv = deriv.simplify()
706             if deriv != 0:
707                 if not (pure_complex(deriv, or_real=True)):
708                     if flags.get('failing_number', False):
709                         return failing_number
710                     elif deriv.free_symbols:
711                         # dead line provided _random returns None in such cases
712                         return None
713                 return False
714         return True
715 
716     def equals(self, other, failing_expression=False):
717         """Return True if self == other, False if it doesn't, or None. If
718         failing_expression is True then the expression which did not simplify
719         to a 0 will be returned instead of None.
720 
721         If ``self`` is a Number (or complex number) that is not zero, then
722         the result is False.
723 
724         If ``self`` is a number and has not evaluated to zero, evalf will be
725         used to test whether the expression evaluates to zero. If it does so
726         and the result has significance (i.e. the precision is either -1, for
727         a Rational result, or is greater than 1) then the evalf value will be
728         used to return True or False.
729 
730         """
731         from sympy.simplify.simplify import nsimplify, simplify
732         from sympy.solvers.solveset import solveset
733         from sympy.solvers.solvers import solve
734         from sympy.polys.polyerrors import NotAlgebraic
735         from sympy.polys.numberfields import minimal_polynomial
736 
737         other = sympify(other)
738         if self == other:
739             return True
740 
741         # they aren't the same so see if we can make the difference 0;
742         # don't worry about doing simplification steps one at a time
743         # because if the expression ever goes to 0 then the subsequent
744         # simplification steps that are done will be very fast.
745         diff = factor_terms(simplify(self - other), radical=True)
746 
747         if not diff:
748             return True
749 
750         if not diff.has(Add, Mod):
751             # if there is no expanding to be done after simplifying
752             # then this can't be a zero
753             return False
754 
755         constant = diff.is_constant(simplify=False, failing_number=True)
756 
757         if constant is False:
758             return False
759 
760         if not diff.is_number:
761             if constant is None:
762                 # e.g. unless the right simplification is done, a symbolic
763                 # zero is possible (see expression of issue 6829: without
764                 # simplification constant will be None).
765                 return
766 
767         if constant is True:
768             # this gives a number whether there are free symbols or not
769             ndiff = diff._random()
770             # is_comparable will work whether the result is real
771             # or complex; it could be None, however.
772             if ndiff and ndiff.is_comparable:
773                 return False
774 
775         # sometimes we can use a simplified result to give a clue as to
776         # what the expression should be; if the expression is *not* zero
777         # then we should have been able to compute that and so now
778         # we can just consider the cases where the approximation appears
779         # to be zero -- we try to prove it via minimal_polynomial.
780         #
781         # removed
782         # ns = nsimplify(diff)
783         # if diff.is_number and (not ns or ns == diff):
784         #
785         # The thought was that if it nsimplifies to 0 that's a sure sign
786         # to try the following to prove it; or if it changed but wasn't
787         # zero that might be a sign that it's not going to be easy to
788         # prove. But tests seem to be working without that logic.
789         #
790         if diff.is_number:
791             # try to prove via self-consistency
792             surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]
793             # it seems to work better to try big ones first
794             surds.sort(key=lambda x: -x.args[0])
795             for s in surds:
796                 try:
797                     # simplify is False here -- this expression has already
798                     # been identified as being hard to identify as zero;
799                     # we will handle the checking ourselves using nsimplify
800                     # to see if we are in the right ballpark or not and if so
801                     # *then* the simplification will be attempted.
802                     sol = solve(diff, s, simplify=False)
803                     if sol:
804                         if s in sol:
805                             # the self-consistent result is present
806                             return True
807                         if all(si.is_Integer for si in sol):
808                             # perfect powers are removed at instantiation
809                             # so surd s cannot be an integer
810                             return False
811                         if all(i.is_algebraic is False for i in sol):
812                             # a surd is algebraic
813                             return False
814                         if any(si in surds for si in sol):
815                             # it wasn't equal to s but it is in surds
816                             # and different surds are not equal
817                             return False
818                         if any(nsimplify(s - si) == 0 and
819                                 simplify(s - si) == 0 for si in sol):
820                             return True
821                         if s.is_real:
822                             if any(nsimplify(si, [s]) == s and simplify(si) == s
823                                     for si in sol):
824                                 return True
825                 except NotImplementedError:
826                     pass
827 
828             # try to prove with minimal_polynomial but know when
829             # *not* to use this or else it can take a long time. e.g. issue 8354
830             if True:  # change True to condition that assures non-hang
831                 try:
832                     mp = minimal_polynomial(diff)
833                     if mp.is_Symbol:
834                         return True
835                     return False
836                 except (NotAlgebraic, NotImplementedError):
837                     pass
838 
839         # diff has not simplified to zero; constant is either None, True
840         # or the number with significance (is_comparable) that was randomly
841         # calculated twice as the same value.
842         if constant not in (True, None) and constant != 0:
843             return False
844 
845         if failing_expression:
846             return diff
847         return None
848 
849     def _eval_is_positive(self):
850         finite = self.is_finite
851         if finite is False:
852             return False
853         extended_positive = self.is_extended_positive
854         if finite is True:
855             return extended_positive
856         if extended_positive is False:
857             return False
858 
859     def _eval_is_negative(self):
860         finite = self.is_finite
861         if finite is False:
862             return False
863         extended_negative = self.is_extended_negative
864         if finite is True:
865             return extended_negative
866         if extended_negative is False:
867             return False
868 
869     def _eval_is_extended_positive(self):
870         from sympy.polys.numberfields import minimal_polynomial
871         from sympy.polys.polyerrors import NotAlgebraic
872         if self.is_number:
873             if self.is_extended_real is False:
874                 return False
875 
876             # check to see that we can get a value
877             try:
878                 n2 = self._eval_evalf(2)
879             # XXX: This shouldn't be caught here
880             # Catches ValueError: hypsum() failed to converge to the requested
881             # 34 bits of accuracy
882             except ValueError:
883                 return None
884             if n2 is None:
885                 return None
886             if getattr(n2, '_prec', 1) == 1:  # no significance
887                 return None
888             if n2 == S.NaN:
889                 return None
890 
891             r, i = self.evalf(2).as_real_imag()
892             if not i.is_Number or not r.is_Number:
893                 return False
894             if r._prec != 1 and i._prec != 1:
895                 return bool(not i and r > 0)
896             elif r._prec == 1 and (not i or i._prec == 1) and \
897                     self.is_algebraic and not self.has(Function):
898                 try:
899                     if minimal_polynomial(self).is_Symbol:
900                         return False
901                 except (NotAlgebraic, NotImplementedError):
902                     pass
903 
904     def _eval_is_extended_negative(self):
905         from sympy.polys.numberfields import minimal_polynomial
906         from sympy.polys.polyerrors import NotAlgebraic
907         if self.is_number:
908             if self.is_extended_real is False:
909                 return False
910 
911             # check to see that we can get a value
912             try:
913                 n2 = self._eval_evalf(2)
914             # XXX: This shouldn't be caught here
915             # Catches ValueError: hypsum() failed to converge to the requested
916             # 34 bits of accuracy
917             except ValueError:
918                 return None
919             if n2 is None:
920                 return None
921             if getattr(n2, '_prec', 1) == 1:  # no significance
922                 return None
923             if n2 == S.NaN:
924                 return None
925 
926             r, i = self.evalf(2).as_real_imag()
927             if not i.is_Number or not r.is_Number:
928                 return False
929             if r._prec != 1 and i._prec != 1:
930                 return bool(not i and r < 0)
931             elif r._prec == 1 and (not i or i._prec == 1) and \
932                     self.is_algebraic and not self.has(Function):
933                 try:
934                     if minimal_polynomial(self).is_Symbol:
935                         return False
936                 except (NotAlgebraic, NotImplementedError):
937                     pass
938 
939     def _eval_interval(self, x, a, b):
940         """
941         Returns evaluation over an interval.  For most functions this is:
942 
943         self.subs(x, b) - self.subs(x, a),
944 
945         possibly using limit() if NaN is returned from subs, or if
946         singularities are found between a and b.
947 
948         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),
949         respectively.
950 
951         """
952         from sympy.series import limit, Limit
953         from sympy.solvers.solveset import solveset
954         from sympy.sets.sets import Interval
955         from sympy.functions.elementary.exponential import log
956         from sympy.calculus.util import AccumBounds
957 
958         if (a is None and b is None):
959             raise ValueError('Both interval ends cannot be None.')
960 
961         if a == b:
962             return 0
963 
964         if a is None:
965             A = 0
966         else:
967             A = self.subs(x, a)
968             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
969                 if (a < b) != False:
970                     A = limit(self, x, a,"+")
971                 else:
972                     A = limit(self, x, a,"-")
973 
974                 if A is S.NaN:
975                     return A
976                 if isinstance(A, Limit):
977                     raise NotImplementedError("Could not compute limit")
978 
979         if b is None:
980             B = 0
981         else:
982             B = self.subs(x, b)
983             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity, AccumBounds):
984                 if (a < b) != False:
985                     B = limit(self, x, b,"-")
986                 else:
987                     B = limit(self, x, b,"+")
988 
989                 if isinstance(B, Limit):
990                     raise NotImplementedError("Could not compute limit")
991 
992         if (a and b) is None:
993             return B - A
994 
995         value = B - A
996 
997         if a.is_comparable and b.is_comparable:
998             if a < b:
999                 domain = Interval(a, b)
1000             else:
1001                 domain = Interval(b, a)
1002             # check the singularities of self within the interval
1003             # if singularities is a ConditionSet (not iterable), catch the exception and pass
1004             singularities = solveset(self.cancel().as_numer_denom()[1], x,
1005                 domain=domain)
1006             for logterm in self.atoms(log):
1007                 singularities = singularities | solveset(logterm.args[0], x,
1008                     domain=domain)
1009             try:
1010                 for s in singularities:
1011                     if value is S.NaN:
1012                         # no need to keep adding, it will stay NaN
1013                         break
1014                     if not s.is_comparable:
1015                         continue
1016                     if (a < s) == (s < b) == True:
1017                         value += -limit(self, x, s, "+") + limit(self, x, s, "-")
1018                     elif (b < s) == (s < a) == True:
1019                         value += limit(self, x, s, "+") - limit(self, x, s, "-")
1020             except TypeError:
1021                 pass
1022 
1023         return value
1024 
1025     def _eval_power(self, other):
1026         # subclass to compute self**other for cases when
1027         # other is not NaN, 0, or 1
1028         return None
1029 
1030     def _eval_conjugate(self):
1031         if self.is_extended_real:
1032             return self
1033         elif self.is_imaginary:
1034             return -self
1035 
1036     def conjugate(self):
1037         from sympy.functions.elementary.complexes import conjugate as c
1038         return c(self)
1039 
1040     def _eval_transpose(self):
1041         from sympy.functions.elementary.complexes import conjugate
1042         if self.is_complex:
1043             return self
1044         elif self.is_hermitian:
1045             return conjugate(self)
1046         elif self.is_antihermitian:
1047             return -conjugate(self)
1048 
1049     def transpose(self):
1050         from sympy.functions.elementary.complexes import transpose
1051         return transpose(self)
1052 
1053     def _eval_adjoint(self):
1054         from sympy.functions.elementary.complexes import conjugate, transpose
1055         if self.is_hermitian:
1056             return self
1057         elif self.is_antihermitian:
1058             return -self
1059         obj = self._eval_conjugate()
1060         if obj is not None:
1061             return transpose(obj)
1062         obj = self._eval_transpose()
1063         if obj is not None:
1064             return conjugate(obj)
1065 
1066     def adjoint(self):
1067         from sympy.functions.elementary.complexes import adjoint
1068         return adjoint(self)
1069 
1070     @classmethod
1071     def _parse_order(cls, order):
1072         """Parse and configure the ordering of terms. """
1073         from sympy.polys.orderings import monomial_key
1074 
1075         startswith = getattr(order, "startswith", None)
1076         if startswith is None:
1077             reverse = False
1078         else:
1079             reverse = startswith('rev-')
1080             if reverse:
1081                 order = order[4:]
1082 
1083         monom_key = monomial_key(order)
1084 
1085         def neg(monom):
1086             result = []
1087 
1088             for m in monom:
1089                 if isinstance(m, tuple):
1090                     result.append(neg(m))
1091                 else:
1092                     result.append(-m)
1093 
1094             return tuple(result)
1095 
1096         def key(term):
1097             _, ((re, im), monom, ncpart) = term
1098 
1099             monom = neg(monom_key(monom))
1100             ncpart = tuple([e.sort_key(order=order) for e in ncpart])
1101             coeff = ((bool(im), im), (re, im))
1102 
1103             return monom, ncpart, coeff
1104 
1105         return key, reverse
1106 
1107     def as_ordered_factors(self, order=None):
1108         """Return list of ordered factors (if Mul) else [self]."""
1109         return [self]
1110 
1111     def as_ordered_terms(self, order=None, data=False):
1112         """
1113         Transform an expression to an ordered list of terms.
1114 
1115         Examples
1116         ========
1117 
1118         >>> from sympy import sin, cos
1119         >>> from sympy.abc import x
1120 
1121         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()
1122         [sin(x)**2*cos(x), sin(x)**2, 1]
1123 
1124         """
1125 
1126         from .numbers import Number, NumberSymbol
1127 
1128         if order is None and self.is_Add:
1129             # Spot the special case of Add(Number, Mul(Number, expr)) with the
1130             # first number positive and thhe second number nagative
1131             key = lambda x:not isinstance(x, (Number, NumberSymbol))
1132             add_args = sorted(Add.make_args(self), key=key)
1133             if (len(add_args) == 2
1134                 and isinstance(add_args[0], (Number, NumberSymbol))
1135                 and isinstance(add_args[1], Mul)):
1136                 mul_args = sorted(Mul.make_args(add_args[1]), key=key)
1137                 if (len(mul_args) == 2
1138                     and isinstance(mul_args[0], Number)
1139                     and add_args[0].is_positive
1140                     and mul_args[0].is_negative):
1141                     return add_args
1142 
1143         key, reverse = self._parse_order(order)
1144         terms, gens = self.as_terms()
1145 
1146         if not any(term.is_Order for term, _ in terms):
1147             ordered = sorted(terms, key=key, reverse=reverse)
1148         else:
1149             _terms, _order = [], []
1150 
1151             for term, repr in terms:
1152                 if not term.is_Order:
1153                     _terms.append((term, repr))
1154                 else:
1155                     _order.append((term, repr))
1156 
1157             ordered = sorted(_terms, key=key, reverse=True) \
1158                 + sorted(_order, key=key, reverse=True)
1159 
1160         if data:
1161             return ordered, gens
1162         else:
1163             return [term for term, _ in ordered]
1164 
1165     def as_terms(self):
1166         """Transform an expression to a list of terms. """
1167         from .add import Add
1168         from .mul import Mul
1169         from .exprtools import decompose_power
1170 
1171         gens, terms = set([]), []
1172 
1173         for term in Add.make_args(self):
1174             coeff, _term = term.as_coeff_Mul()
1175 
1176             coeff = complex(coeff)
1177             cpart, ncpart = {}, []
1178 
1179             if _term is not S.One:
1180                 for factor in Mul.make_args(_term):
1181                     if factor.is_number:
1182                         try:
1183                             coeff *= complex(factor)
1184                         except (TypeError, ValueError):
1185                             pass
1186                         else:
1187                             continue
1188 
1189                     if factor.is_commutative:
1190                         base, exp = decompose_power(factor)
1191 
1192                         cpart[base] = exp
1193                         gens.add(base)
1194                     else:
1195                         ncpart.append(factor)
1196 
1197             coeff = coeff.real, coeff.imag
1198             ncpart = tuple(ncpart)
1199 
1200             terms.append((term, (coeff, cpart, ncpart)))
1201 
1202         gens = sorted(gens, key=default_sort_key)
1203 
1204         k, indices = len(gens), {}
1205 
1206         for i, g in enumerate(gens):
1207             indices[g] = i
1208 
1209         result = []
1210 
1211         for term, (coeff, cpart, ncpart) in terms:
1212             monom = [0]*k
1213 
1214             for base, exp in cpart.items():
1215                 monom[indices[base]] = exp
1216 
1217             result.append((term, (coeff, tuple(monom), ncpart)))
1218 
1219         return result, gens
1220 
1221     def removeO(self):
1222         """Removes the additive O(..) symbol if there is one"""
1223         return self
1224 
1225     def getO(self):
1226         """Returns the additive O(..) symbol if there is one, else None."""
1227         return None
1228 
1229     def getn(self):
1230         """
1231         Returns the order of the expression.
1232 
1233         The order is determined either from the O(...) term. If there
1234         is no O(...) term, it returns None.
1235 
1236         Examples
1237         ========
1238 
1239         >>> from sympy import O
1240         >>> from sympy.abc import x
1241         >>> (1 + x + O(x**2)).getn()
1242         2
1243         >>> (1 + x).getn()
1244 
1245         """
1246         from sympy import Dummy, Symbol
1247         o = self.getO()
1248         if o is None:
1249             return None
1250         elif o.is_Order:
1251             o = o.expr
1252             if o is S.One:
1253                 return S.Zero
1254             if o.is_Symbol:
1255                 return S.One
1256             if o.is_Pow:
1257                 return o.args[1]
1258             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n
1259                 for oi in o.args:
1260                     if oi.is_Symbol:
1261                         return S.One
1262                     if oi.is_Pow:
1263                         syms = oi.atoms(Symbol)
1264                         if len(syms) == 1:
1265                             x = syms.pop()
1266                             oi = oi.subs(x, Dummy('x', positive=True))
1267                             if oi.base.is_Symbol and oi.exp.is_Rational:
1268                                 return abs(oi.exp)
1269 
1270         raise NotImplementedError('not sure of order of %s' % o)
1271 
1272     def count_ops(self, visual=None):
1273         """wrapper for count_ops that returns the operation count."""
1274         from .function import count_ops
1275         return count_ops(self, visual)
1276 
1277     def args_cnc(self, cset=False, warn=True, split_1=True):
1278         """Return [commutative factors, non-commutative factors] of self.
1279 
1280         self is treated as a Mul and the ordering of the factors is maintained.
1281         If ``cset`` is True the commutative factors will be returned in a set.
1282         If there were repeated factors (as may happen with an unevaluated Mul)
1283         then an error will be raised unless it is explicitly suppressed by
1284         setting ``warn`` to False.
1285 
1286         Note: -1 is always separated from a Number unless split_1 is False.
1287 
1288         >>> from sympy import symbols, oo
1289         >>> A, B = symbols('A B', commutative=0)
1290         >>> x, y = symbols('x y')
1291         >>> (-2*x*y).args_cnc()
1292         [[-1, 2, x, y], []]
1293         >>> (-2.5*x).args_cnc()
1294         [[-1, 2.5, x], []]
1295         >>> (-2*x*A*B*y).args_cnc()
1296         [[-1, 2, x, y], [A, B]]
1297         >>> (-2*x*A*B*y).args_cnc(split_1=False)
1298         [[-2, x, y], [A, B]]
1299         >>> (-2*x*y).args_cnc(cset=True)
1300         [{-1, 2, x, y}, []]
1301 
1302         The arg is always treated as a Mul:
1303 
1304         >>> (-2 + x + A).args_cnc()
1305         [[], [x - 2 + A]]
1306         >>> (-oo).args_cnc() # -oo is a singleton
1307         [[-1, oo], []]
1308         """
1309 
1310         if self.is_Mul:
1311             args = list(self.args)
1312         else:
1313             args = [self]
1314         for i, mi in enumerate(args):
1315             if not mi.is_commutative:
1316                 c = args[:i]
1317                 nc = args[i:]
1318                 break
1319         else:
1320             c = args
1321             nc = []
1322 
1323         if c and split_1 and (
1324             c[0].is_Number and
1325             c[0].is_extended_negative and
1326                 c[0] is not S.NegativeOne):
1327             c[:1] = [S.NegativeOne, -c[0]]
1328 
1329         if cset:
1330             clen = len(c)
1331             c = set(c)
1332             if clen and warn and len(c) != clen:
1333                 raise ValueError('repeated commutative arguments: %s' %
1334                                  [ci for ci in c if list(self.args).count(ci) > 1])
1335         return [c, nc]
1336 
1337     def coeff(self, x, n=1, right=False):
1338         """
1339         Returns the coefficient from the term(s) containing ``x**n``. If ``n``
1340         is zero then all terms independent of ``x`` will be returned.
1341 
1342         When ``x`` is noncommutative, the coefficient to the left (default) or
1343         right of ``x`` can be returned. The keyword 'right' is ignored when
1344         ``x`` is commutative.
1345 
1346         See Also
1347         ========
1348 
1349         as_coefficient: separate the expression into a coefficient and factor
1350         as_coeff_Add: separate the additive constant from an expression
1351         as_coeff_Mul: separate the multiplicative constant from an expression
1352         as_independent: separate x-dependent terms/factors from others
1353         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1354         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1355 
1356         Examples
1357         ========
1358 
1359         >>> from sympy import symbols
1360         >>> from sympy.abc import x, y, z
1361 
1362         You can select terms that have an explicit negative in front of them:
1363 
1364         >>> (-x + 2*y).coeff(-1)
1365         x
1366         >>> (x - 2*y).coeff(-1)
1367         2*y
1368 
1369         You can select terms with no Rational coefficient:
1370 
1371         >>> (x + 2*y).coeff(1)
1372         x
1373         >>> (3 + 2*x + 4*x**2).coeff(1)
1374         0
1375 
1376         You can select terms independent of x by making n=0; in this case
1377         expr.as_independent(x)[0] is returned (and 0 will be returned instead
1378         of None):
1379 
1380         >>> (3 + 2*x + 4*x**2).coeff(x, 0)
1381         3
1382         >>> eq = ((x + 1)**3).expand() + 1
1383         >>> eq
1384         x**3 + 3*x**2 + 3*x + 2
1385         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1386         [1, 3, 3, 2]
1387         >>> eq -= 2
1388         >>> [eq.coeff(x, i) for i in reversed(range(4))]
1389         [1, 3, 3, 0]
1390 
1391         You can select terms that have a numerical term in front of them:
1392 
1393         >>> (-x - 2*y).coeff(2)
1394         -y
1395         >>> from sympy import sqrt
1396         >>> (x + sqrt(2)*x).coeff(sqrt(2))
1397         x
1398 
1399         The matching is exact:
1400 
1401         >>> (3 + 2*x + 4*x**2).coeff(x)
1402         2
1403         >>> (3 + 2*x + 4*x**2).coeff(x**2)
1404         4
1405         >>> (3 + 2*x + 4*x**2).coeff(x**3)
1406         0
1407         >>> (z*(x + y)**2).coeff((x + y)**2)
1408         z
1409         >>> (z*(x + y)**2).coeff(x + y)
1410         0
1411 
1412         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained
1413         from the following:
1414 
1415         >>> (x + z*(x + x*y)).coeff(x)
1416         1
1417 
1418         If such factoring is desired, factor_terms can be used first:
1419 
1420         >>> from sympy import factor_terms
1421         >>> factor_terms(x + z*(x + x*y)).coeff(x)
1422         z*(y + 1) + 1
1423 
1424         >>> n, m, o = symbols('n m o', commutative=False)
1425         >>> n.coeff(n)
1426         1
1427         >>> (3*n).coeff(n)
1428         3
1429         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m
1430         1 + m
1431         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m
1432         m
1433 
1434         If there is more than one possible coefficient 0 is returned:
1435 
1436         >>> (n*m + m*n).coeff(n)
1437         0
1438 
1439         If there is only one possible coefficient, it is returned:
1440 
1441         >>> (n*m + x*m*n).coeff(m*n)
1442         x
1443         >>> (n*m + x*m*n).coeff(m*n, right=1)
1444         1
1445 
1446         """
1447         x = sympify(x)
1448         if not isinstance(x, Basic):
1449             return S.Zero
1450 
1451         n = as_int(n)
1452 
1453         if not x:
1454             return S.Zero
1455 
1456         if x == self:
1457             if n == 1:
1458                 return S.One
1459             return S.Zero
1460 
1461         if x is S.One:
1462             co = [a for a in Add.make_args(self)
1463                   if a.as_coeff_Mul()[0] is S.One]
1464             if not co:
1465                 return S.Zero
1466             return Add(*co)
1467 
1468         if n == 0:
1469             if x.is_Add and self.is_Add:
1470                 c = self.coeff(x, right=right)
1471                 if not c:
1472                     return S.Zero
1473                 if not right:
1474                     return self - Add(*[a*x for a in Add.make_args(c)])
1475                 return self - Add(*[x*a for a in Add.make_args(c)])
1476             return self.as_independent(x, as_Add=True)[0]
1477 
1478         # continue with the full method, looking for this power of x:
1479         x = x**n
1480 
1481         def incommon(l1, l2):
1482             if not l1 or not l2:
1483                 return []
1484             n = min(len(l1), len(l2))
1485             for i in range(n):
1486                 if l1[i] != l2[i]:
1487                     return l1[:i]
1488             return l1[:]
1489 
1490         def find(l, sub, first=True):
1491             """ Find where list sub appears in list l. When ``first`` is True
1492             the first occurrence from the left is returned, else the last
1493             occurrence is returned. Return None if sub is not in l.
1494 
1495             >> l = range(5)*2
1496             >> find(l, [2, 3])
1497             2
1498             >> find(l, [2, 3], first=0)
1499             7
1500             >> find(l, [2, 4])
1501             None
1502 
1503             """
1504             if not sub or not l or len(sub) > len(l):
1505                 return None
1506             n = len(sub)
1507             if not first:
1508                 l.reverse()
1509                 sub.reverse()
1510             for i in range(0, len(l) - n + 1):
1511                 if all(l[i + j] == sub[j] for j in range(n)):
1512                     break
1513             else:
1514                 i = None
1515             if not first:
1516                 l.reverse()
1517                 sub.reverse()
1518             if i is not None and not first:
1519                 i = len(l) - (i + n)
1520             return i
1521 
1522         co = []
1523         args = Add.make_args(self)
1524         self_c = self.is_commutative
1525         x_c = x.is_commutative
1526         if self_c and not x_c:
1527             return S.Zero
1528 
1529         if self_c:
1530             xargs = x.args_cnc(cset=True, warn=False)[0]
1531             for a in args:
1532                 margs = a.args_cnc(cset=True, warn=False)[0]
1533                 if len(xargs) > len(margs):
1534                     continue
1535                 resid = margs.difference(xargs)
1536                 if len(resid) + len(xargs) == len(margs):
1537                     co.append(Mul(*resid))
1538             if co == []:
1539                 return S.Zero
1540             elif co:
1541                 return Add(*co)
1542         elif x_c:
1543             xargs = x.args_cnc(cset=True, warn=False)[0]
1544             for a in args:
1545                 margs, nc = a.args_cnc(cset=True)
1546                 if len(xargs) > len(margs):
1547                     continue
1548                 resid = margs.difference(xargs)
1549                 if len(resid) + len(xargs) == len(margs):
1550                     co.append(Mul(*(list(resid) + nc)))
1551             if co == []:
1552                 return S.Zero
1553             elif co:
1554                 return Add(*co)
1555         else:  # both nc
1556             xargs, nx = x.args_cnc(cset=True)
1557             # find the parts that pass the commutative terms
1558             for a in args:
1559                 margs, nc = a.args_cnc(cset=True)
1560                 if len(xargs) > len(margs):
1561                     continue
1562                 resid = margs.difference(xargs)
1563                 if len(resid) + len(xargs) == len(margs):
1564                     co.append((resid, nc))
1565             # now check the non-comm parts
1566             if not co:
1567                 return S.Zero
1568             if all(n == co[0][1] for r, n in co):
1569                 ii = find(co[0][1], nx, right)
1570                 if ii is not None:
1571                     if not right:
1572                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))
1573                     else:
1574                         return Mul(*co[0][1][ii + len(nx):])
1575             beg = reduce(incommon, (n[1] for n in co))
1576             if beg:
1577                 ii = find(beg, nx, right)
1578                 if ii is not None:
1579                     if not right:
1580                         gcdc = co[0][0]
1581                         for i in range(1, len(co)):
1582                             gcdc = gcdc.intersection(co[i][0])
1583                             if not gcdc:
1584                                 break
1585                         return Mul(*(list(gcdc) + beg[:ii]))
1586                     else:
1587                         m = ii + len(nx)
1588                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])
1589             end = list(reversed(
1590                 reduce(incommon, (list(reversed(n[1])) for n in co))))
1591             if end:
1592                 ii = find(end, nx, right)
1593                 if ii is not None:
1594                     if not right:
1595                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])
1596                     else:
1597                         return Mul(*end[ii + len(nx):])
1598             # look for single match
1599             hit = None
1600             for i, (r, n) in enumerate(co):
1601                 ii = find(n, nx, right)
1602                 if ii is not None:
1603                     if not hit:
1604                         hit = ii, r, n
1605                     else:
1606                         break
1607             else:
1608                 if hit:
1609                     ii, r, n = hit
1610                     if not right:
1611                         return Mul(*(list(r) + n[:ii]))
1612                     else:
1613                         return Mul(*n[ii + len(nx):])
1614 
1615             return S.Zero
1616 
1617     def as_expr(self, *gens):
1618         """
1619         Convert a polynomial to a SymPy expression.
1620 
1621         Examples
1622         ========
1623 
1624         >>> from sympy import sin
1625         >>> from sympy.abc import x, y
1626 
1627         >>> f = (x**2 + x*y).as_poly(x, y)
1628         >>> f.as_expr()
1629         x**2 + x*y
1630 
1631         >>> sin(x).as_expr()
1632         sin(x)
1633 
1634         """
1635         return self
1636 
1637     def as_coefficient(self, expr):
1638         """
1639         Extracts symbolic coefficient at the given expression. In
1640         other words, this functions separates 'self' into the product
1641         of 'expr' and 'expr'-free coefficient. If such separation
1642         is not possible it will return None.
1643 
1644         Examples
1645         ========
1646 
1647         >>> from sympy import E, pi, sin, I, Poly
1648         >>> from sympy.abc import x
1649 
1650         >>> E.as_coefficient(E)
1651         1
1652         >>> (2*E).as_coefficient(E)
1653         2
1654         >>> (2*sin(E)*E).as_coefficient(E)
1655 
1656         Two terms have E in them so a sum is returned. (If one were
1657         desiring the coefficient of the term exactly matching E then
1658         the constant from the returned expression could be selected.
1659         Or, for greater precision, a method of Poly can be used to
1660         indicate the desired term from which the coefficient is
1661         desired.)
1662 
1663         >>> (2*E + x*E).as_coefficient(E)
1664         x + 2
1665         >>> _.args[0]  # just want the exact match
1666         2
1667         >>> p = Poly(2*E + x*E); p
1668         Poly(x*E + 2*E, x, E, domain='ZZ')
1669         >>> p.coeff_monomial(E)
1670         2
1671         >>> p.nth(0, 1)
1672         2
1673 
1674         Since the following cannot be written as a product containing
1675         E as a factor, None is returned. (If the coefficient ``2*x`` is
1676         desired then the ``coeff`` method should be used.)
1677 
1678         >>> (2*E*x + x).as_coefficient(E)
1679         >>> (2*E*x + x).coeff(E)
1680         2*x
1681 
1682         >>> (E*(x + 1) + x).as_coefficient(E)
1683 
1684         >>> (2*pi*I).as_coefficient(pi*I)
1685         2
1686         >>> (2*I).as_coefficient(pi*I)
1687 
1688         See Also
1689         ========
1690 
1691         coeff: return sum of terms have a given factor
1692         as_coeff_Add: separate the additive constant from an expression
1693         as_coeff_Mul: separate the multiplicative constant from an expression
1694         as_independent: separate x-dependent terms/factors from others
1695         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly
1696         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used
1697 
1698 
1699         """
1700 
1701         r = self.extract_multiplicatively(expr)
1702         if r and not r.has(expr):
1703             return r
1704 
1705     def as_independent(self, *deps, **hint):
1706         """
1707         A mostly naive separation of a Mul or Add into arguments that are not
1708         are dependent on deps. To obtain as complete a separation of variables
1709         as possible, use a separation method first, e.g.:
1710 
1711         * separatevars() to change Mul, Add and Pow (including exp) into Mul
1712         * .expand(mul=True) to change Add or Mul into Add
1713         * .expand(log=True) to change log expr into an Add
1714 
1715         The only non-naive thing that is done here is to respect noncommutative
1716         ordering of variables and to always return (0, 0) for `self` of zero
1717         regardless of hints.
1718 
1719         For nonzero `self`, the returned tuple (i, d) has the
1720         following interpretation:
1721 
1722         * i will has no variable that appears in deps
1723         * d will either have terms that contain variables that are in deps, or
1724           be equal to 0 (when self is an Add) or 1 (when self is a Mul)
1725         * if self is an Add then self = i + d
1726         * if self is a Mul then self = i*d
1727         * otherwise (self, S.One) or (S.One, self) is returned.
1728 
1729         To force the expression to be treated as an Add, use the hint as_Add=True
1730 
1731         Examples
1732         ========
1733 
1734         -- self is an Add
1735 
1736         >>> from sympy import sin, cos, exp
1737         >>> from sympy.abc import x, y, z
1738 
1739         >>> (x + x*y).as_independent(x)
1740         (0, x*y + x)
1741         >>> (x + x*y).as_independent(y)
1742         (x, x*y)
1743         >>> (2*x*sin(x) + y + x + z).as_independent(x)
1744         (y + z, 2*x*sin(x) + x)
1745         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)
1746         (z, 2*x*sin(x) + x + y)
1747 
1748         -- self is a Mul
1749 
1750         >>> (x*sin(x)*cos(y)).as_independent(x)
1751         (cos(y), x*sin(x))
1752 
1753         non-commutative terms cannot always be separated out when self is a Mul
1754 
1755         >>> from sympy import symbols
1756         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)
1757         >>> (n1 + n1*n2).as_independent(n2)
1758         (n1, n1*n2)
1759         >>> (n2*n1 + n1*n2).as_independent(n2)
1760         (0, n1*n2 + n2*n1)
1761         >>> (n1*n2*n3).as_independent(n1)
1762         (1, n1*n2*n3)
1763         >>> (n1*n2*n3).as_independent(n2)
1764         (n1, n2*n3)
1765         >>> ((x-n1)*(x-y)).as_independent(x)
1766         (1, (x - y)*(x - n1))
1767 
1768         -- self is anything else:
1769 
1770         >>> (sin(x)).as_independent(x)
1771         (1, sin(x))
1772         >>> (sin(x)).as_independent(y)
1773         (sin(x), 1)
1774         >>> exp(x+y).as_independent(x)
1775         (1, exp(x + y))
1776 
1777         -- force self to be treated as an Add:
1778 
1779         >>> (3*x).as_independent(x, as_Add=True)
1780         (0, 3*x)
1781 
1782         -- force self to be treated as a Mul:
1783 
1784         >>> (3+x).as_independent(x, as_Add=False)
1785         (1, x + 3)
1786         >>> (-3+x).as_independent(x, as_Add=False)
1787         (1, x - 3)
1788 
1789         Note how the below differs from the above in making the
1790         constant on the dep term positive.
1791 
1792         >>> (y*(-3+x)).as_independent(x)
1793         (y, x - 3)
1794 
1795         -- use .as_independent() for true independence testing instead
1796            of .has(). The former considers only symbols in the free
1797            symbols while the latter considers all symbols
1798 
1799         >>> from sympy import Integral
1800         >>> I = Integral(x, (x, 1, 2))
1801         >>> I.has(x)
1802         True
1803         >>> x in I.free_symbols
1804         False
1805         >>> I.as_independent(x) == (I, 1)
1806         True
1807         >>> (I + x).as_independent(x) == (I, x)
1808         True
1809 
1810         Note: when trying to get independent terms, a separation method
1811         might need to be used first. In this case, it is important to keep
1812         track of what you send to this routine so you know how to interpret
1813         the returned values
1814 
1815         >>> from sympy import separatevars, log
1816         >>> separatevars(exp(x+y)).as_independent(x)
1817         (exp(y), exp(x))
1818         >>> (x + x*y).as_independent(y)
1819         (x, x*y)
1820         >>> separatevars(x + x*y).as_independent(y)
1821         (x, y + 1)
1822         >>> (x*(1 + y)).as_independent(y)
1823         (x, y + 1)
1824         >>> (x*(1 + y)).expand(mul=True).as_independent(y)
1825         (x, x*y)
1826         >>> a, b=symbols('a b', positive=True)
1827         >>> (log(a*b).expand(log=True)).as_independent(b)
1828         (log(a), log(b))
1829 
1830         See Also
1831         ========
1832         .separatevars(), .expand(log=True), Add.as_two_terms(),
1833         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()
1834         """
1835         from .symbol import Symbol
1836         from .add import _unevaluated_Add
1837         from .mul import _unevaluated_Mul
1838         from sympy.utilities.iterables import sift
1839 
1840         if self.is_zero:
1841             return S.Zero, S.Zero
1842 
1843         func = self.func
1844         if hint.get('as_Add', isinstance(self, Add) ):
1845             want = Add
1846         else:
1847             want = Mul
1848 
1849         # sift out deps into symbolic and other and ignore
1850         # all symbols but those that are in the free symbols
1851         sym = set()
1852         other = []
1853         for d in deps:
1854             if isinstance(d, Symbol):  # Symbol.is_Symbol is True
1855                 sym.add(d)
1856             else:
1857                 other.append(d)
1858 
1859         def has(e):
1860             """return the standard has() if there are no literal symbols, else
1861             check to see that symbol-deps are in the free symbols."""
1862             has_other = e.has(*other)
1863             if not sym:
1864                 return has_other
1865             return has_other or e.has(*(e.free_symbols & sym))
1866 
1867         if (want is not func or
1868                 func is not Add and func is not Mul):
1869             if has(self):
1870                 return (want.identity, self)
1871             else:
1872                 return (self, want.identity)
1873         else:
1874             if func is Add:
1875                 args = list(self.args)
1876             else:
1877                 args, nc = self.args_cnc()
1878 
1879         d = sift(args, lambda x: has(x))
1880         depend = d[True]
1881         indep = d[False]
1882         if func is Add:  # all terms were treated as commutative
1883             return (Add(*indep), _unevaluated_Add(*depend))
1884         else:  # handle noncommutative by stopping at first dependent term
1885             for i, n in enumerate(nc):
1886                 if has(n):
1887                     depend.extend(nc[i:])
1888                     break
1889                 indep.append(n)
1890             return Mul(*indep), (
1891                 Mul(*depend, evaluate=False) if nc else
1892                 _unevaluated_Mul(*depend))
1893 
1894     def as_real_imag(self, deep=True, **hints):
1895         """Performs complex expansion on 'self' and returns a tuple
1896            containing collected both real and imaginary parts. This
1897            method can't be confused with re() and im() functions,
1898            which does not perform complex expansion at evaluation.
1899 
1900            However it is possible to expand both re() and im()
1901            functions and get exactly the same results as with
1902            a single call to this function.
1903 
1904            >>> from sympy import symbols, I
1905 
1906            >>> x, y = symbols('x,y', real=True)
1907 
1908            >>> (x + y*I).as_real_imag()
1909            (x, y)
1910 
1911            >>> from sympy.abc import z, w
1912 
1913            >>> (z + w*I).as_real_imag()
1914            (re(z) - im(w), re(w) + im(z))
1915 
1916         """
1917         from sympy import im, re
1918         if hints.get('ignore') == self:
1919             return None
1920         else:
1921             return (re(self), im(self))
1922 
1923     def as_powers_dict(self):
1924         """Return self as a dictionary of factors with each factor being
1925         treated as a power. The keys are the bases of the factors and the
1926         values, the corresponding exponents. The resulting dictionary should
1927         be used with caution if the expression is a Mul and contains non-
1928         commutative factors since the order that they appeared will be lost in
1929         the dictionary.
1930 
1931         See Also
1932         ========
1933         as_ordered_factors: An alternative for noncommutative applications,
1934                             returning an ordered list of factors.
1935         args_cnc: Similar to as_ordered_factors, but guarantees separation
1936                   of commutative and noncommutative factors.
1937         """
1938         d = defaultdict(int)
1939         d.update(dict([self.as_base_exp()]))
1940         return d
1941 
1942     def as_coefficients_dict(self):
1943         """Return a dictionary mapping terms to their Rational coefficient.
1944         Since the dictionary is a defaultdict, inquiries about terms which
1945         were not present will return a coefficient of 0. If an expression is
1946         not an Add it is considered to have a single term.
1947 
1948         Examples
1949         ========
1950 
1951         >>> from sympy.abc import a, x
1952         >>> (3*x + a*x + 4).as_coefficients_dict()
1953         {1: 4, x: 3, a*x: 1}
1954         >>> _[a]
1955         0
1956         >>> (3*a*x).as_coefficients_dict()
1957         {a*x: 3}
1958 
1959         """
1960         c, m = self.as_coeff_Mul()
1961         if not c.is_Rational:
1962             c = S.One
1963             m = self
1964         d = defaultdict(int)
1965         d.update({m: c})
1966         return d
1967 
1968     def as_base_exp(self):
1969         # a -> b ** e
1970         return self, S.One
1971 
1972     def as_coeff_mul(self, *deps, **kwargs):
1973         """Return the tuple (c, args) where self is written as a Mul, ``m``.
1974 
1975         c should be a Rational multiplied by any factors of the Mul that are
1976         independent of deps.
1977 
1978         args should be a tuple of all other factors of m; args is empty
1979         if self is a Number or if self is independent of deps (when given).
1980 
1981         This should be used when you don't know if self is a Mul or not but
1982         you want to treat self as a Mul or if you want to process the
1983         individual arguments of the tail of self as a Mul.
1984 
1985         - if you know self is a Mul and want only the head, use self.args[0];
1986         - if you don't want to process the arguments of the tail but need the
1987           tail then use self.as_two_terms() which gives the head and tail;
1988         - if you want to split self into an independent and dependent parts
1989           use ``self.as_independent(*deps)``
1990 
1991         >>> from sympy import S
1992         >>> from sympy.abc import x, y
1993         >>> (S(3)).as_coeff_mul()
1994         (3, ())
1995         >>> (3*x*y).as_coeff_mul()
1996         (3, (x, y))
1997         >>> (3*x*y).as_coeff_mul(x)
1998         (3*y, (x,))
1999         >>> (3*y).as_coeff_mul(x)
2000         (3*y, ())
2001         """
2002         if deps:
2003             if not self.has(*deps):
2004                 return self, tuple()
2005         return S.One, (self,)
2006 
2007     def as_coeff_add(self, *deps):
2008         """Return the tuple (c, args) where self is written as an Add, ``a``.
2009 
2010         c should be a Rational added to any terms of the Add that are
2011         independent of deps.
2012 
2013         args should be a tuple of all other terms of ``a``; args is empty
2014         if self is a Number or if self is independent of deps (when given).
2015 
2016         This should be used when you don't know if self is an Add or not but
2017         you want to treat self as an Add or if you want to process the
2018         individual arguments of the tail of self as an Add.
2019 
2020         - if you know self is an Add and want only the head, use self.args[0];
2021         - if you don't want to process the arguments of the tail but need the
2022           tail then use self.as_two_terms() which gives the head and tail.
2023         - if you want to split self into an independent and dependent parts
2024           use ``self.as_independent(*deps)``
2025 
2026         >>> from sympy import S
2027         >>> from sympy.abc import x, y
2028         >>> (S(3)).as_coeff_add()
2029         (3, ())
2030         >>> (3 + x).as_coeff_add()
2031         (3, (x,))
2032         >>> (3 + x + y).as_coeff_add(x)
2033         (y + 3, (x,))
2034         >>> (3 + y).as_coeff_add(x)
2035         (y + 3, ())
2036 
2037         """
2038         if deps:
2039             if not self.has(*deps):
2040                 return self, tuple()
2041         return S.Zero, (self,)
2042 
2043     def primitive(self):
2044         """Return the positive Rational that can be extracted non-recursively
2045         from every term of self (i.e., self is treated like an Add). This is
2046         like the as_coeff_Mul() method but primitive always extracts a positive
2047         Rational (never a negative or a Float).
2048 
2049         Examples
2050         ========
2051 
2052         >>> from sympy.abc import x
2053         >>> (3*(x + 1)**2).primitive()
2054         (3, (x + 1)**2)
2055         >>> a = (6*x + 2); a.primitive()
2056         (2, 3*x + 1)
2057         >>> b = (x/2 + 3); b.primitive()
2058         (1/2, x + 6)
2059         >>> (a*b).primitive() == (1, a*b)
2060         True
2061         """
2062         if not self:
2063             return S.One, S.Zero
2064         c, r = self.as_coeff_Mul(rational=True)
2065         if c.is_negative:
2066             c, r = -c, -r
2067         return c, r
2068 
2069     def as_content_primitive(self, radical=False, clear=True):
2070         """This method should recursively remove a Rational from all arguments
2071         and return that (content) and the new self (primitive). The content
2072         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.
2073         The primitive need not be in canonical form and should try to preserve
2074         the underlying structure if possible (i.e. expand_mul should not be
2075         applied to self).
2076 
2077         Examples
2078         ========
2079 
2080         >>> from sympy import sqrt
2081         >>> from sympy.abc import x, y, z
2082 
2083         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)
2084 
2085         The as_content_primitive function is recursive and retains structure:
2086 
2087         >>> eq.as_content_primitive()
2088         (2, x + 3*y*(y + 1) + 1)
2089 
2090         Integer powers will have Rationals extracted from the base:
2091 
2092         >>> ((2 + 6*x)**2).as_content_primitive()
2093         (4, (3*x + 1)**2)
2094         >>> ((2 + 6*x)**(2*y)).as_content_primitive()
2095         (1, (2*(3*x + 1))**(2*y))
2096 
2097         Terms may end up joining once their as_content_primitives are added:
2098 
2099         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2100         (11, x*(y + 1))
2101         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()
2102         (9, x*(y + 1))
2103         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()
2104         (1, 6.0*x*(y + 1) + 3*z*(y + 1))
2105         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()
2106         (121, x**2*(y + 1)**2)
2107         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()
2108         (1, 121.0*x**2*(y + 1)**2)
2109 
2110         Radical content can also be factored out of the primitive:
2111 
2112         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
2113         (2, sqrt(2)*(1 + 2*sqrt(5)))
2114 
2115         If clear=False (default is True) then content will not be removed
2116         from an Add if it can be distributed to leave one or more
2117         terms with integer coefficients.
2118 
2119         >>> (x/2 + y).as_content_primitive()
2120         (1/2, x + 2*y)
2121         >>> (x/2 + y).as_content_primitive(clear=False)
2122         (1, x/2 + y)
2123         """
2124         return S.One, self
2125 
2126     def as_numer_denom(self):
2127         """ expression -> a/b -> a, b
2128 
2129         This is just a stub that should be defined by
2130         an object's class methods to get anything else.
2131 
2132         See Also
2133         ========
2134         normal: return a/b instead of a, b
2135         """
2136 
2137         return self, S.One
2138 
2139     def normal(self):
2140         from .mul import _unevaluated_Mul
2141         n, d = self.as_numer_denom()
2142         if d is S.One:
2143             return n
2144         if d.is_Number:
2145             return _unevaluated_Mul(n, 1/d)
2146         else:
2147             return n/d
2148 
2149     def extract_multiplicatively(self, c):
2150         """Return None if it's not possible to make self in the form
2151            c * something in a nice way, i.e. preserving the properties
2152            of arguments of self.
2153 
2154            Examples
2155            ========
2156 
2157            >>> from sympy import symbols, Rational
2158 
2159            >>> x, y = symbols('x,y', real=True)
2160 
2161            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)
2162            x*y**2
2163 
2164            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)
2165 
2166            >>> (2*x).extract_multiplicatively(2)
2167            x
2168 
2169            >>> (2*x).extract_multiplicatively(3)
2170 
2171            >>> (Rational(1, 2)*x).extract_multiplicatively(3)
2172            x/6
2173 
2174         """
2175         c = sympify(c)
2176         if self is S.NaN:
2177             return None
2178         if c is S.One:
2179             return self
2180         elif c == self:
2181             return S.One
2182 
2183         if c.is_Add:
2184             cc, pc = c.primitive()
2185             if cc is not S.One:
2186                 c = Mul(cc, pc, evaluate=False)
2187 
2188         if c.is_Mul:
2189             a, b = c.as_two_terms()
2190             x = self.extract_multiplicatively(a)
2191             if x is not None:
2192                 return x.extract_multiplicatively(b)
2193 
2194         quotient = self / c
2195         if self.is_Number:
2196             if self is S.Infinity:
2197                 if c.is_positive:
2198                     return S.Infinity
2199             elif self is S.NegativeInfinity:
2200                 if c.is_negative:
2201                     return S.Infinity
2202                 elif c.is_positive:
2203                     return S.NegativeInfinity
2204             elif self is S.ComplexInfinity:
2205                 if not c.is_zero:
2206                     return S.ComplexInfinity
2207             elif self.is_Integer:
2208                 if not quotient.is_Integer:
2209                     return None
2210                 elif self.is_positive and quotient.is_negative:
2211                     return None
2212                 else:
2213                     return quotient
2214             elif self.is_Rational:
2215                 if not quotient.is_Rational:
2216                     return None
2217                 elif self.is_positive and quotient.is_negative:
2218                     return None
2219                 else:
2220                     return quotient
2221             elif self.is_Float:
2222                 if not quotient.is_Float:
2223                     return None
2224                 elif self.is_positive and quotient.is_negative:
2225                     return None
2226                 else:
2227                     return quotient
2228         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:
2229             if quotient.is_Mul and len(quotient.args) == 2:
2230                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:
2231                     return quotient
2232             elif quotient.is_Integer and c.is_Number:
2233                 return quotient
2234         elif self.is_Add:
2235             cs, ps = self.primitive()
2236             # assert cs >= 1
2237             if c.is_Number and c is not S.NegativeOne:
2238                 # assert c != 1 (handled at top)
2239                 if cs is not S.One:
2240                     if c.is_negative:
2241                         xc = -(cs.extract_multiplicatively(-c))
2242                     else:
2243                         xc = cs.extract_multiplicatively(c)
2244                     if xc is not None:
2245                         return xc*ps  # rely on 2-arg Mul to restore Add
2246                 return  # |c| != 1 can only be extracted from cs
2247             if c == ps:
2248                 return cs
2249             # check args of ps
2250             newargs = []
2251             for arg in ps.args:
2252                 newarg = arg.extract_multiplicatively(c)
2253                 if newarg is None:
2254                     return  # all or nothing
2255                 newargs.append(newarg)
2256             # args should be in same order so use unevaluated return
2257             if cs is not S.One:
2258                 return Add._from_args([cs*t for t in newargs])
2259             else:
2260                 return Add._from_args(newargs)
2261         elif self.is_Mul:
2262             args = list(self.args)
2263             for i, arg in enumerate(args):
2264                 newarg = arg.extract_multiplicatively(c)
2265                 if newarg is not None:
2266                     args[i] = newarg
2267                     return Mul(*args)
2268         elif self.is_Pow:
2269             if c.is_Pow and c.base == self.base:
2270                 new_exp = self.exp.extract_additively(c.exp)
2271                 if new_exp is not None:
2272                     return self.base ** (new_exp)
2273             elif c == self.base:
2274                 new_exp = self.exp.extract_additively(1)
2275                 if new_exp is not None:
2276                     return self.base ** (new_exp)
2277 
2278     def extract_additively(self, c):
2279         """Return self - c if it's possible to subtract c from self and
2280         make all matching coefficients move towards zero, else return None.
2281 
2282         Examples
2283         ========
2284 
2285         >>> from sympy.abc import x, y
2286         >>> e = 2*x + 3
2287         >>> e.extract_additively(x + 1)
2288         x + 2
2289         >>> e.extract_additively(3*x)
2290         >>> e.extract_additively(4)
2291         >>> (y*(x + 1)).extract_additively(x + 1)
2292         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)
2293         (x + 1)*(x + 2*y) + 3
2294 
2295         Sometimes auto-expansion will return a less simplified result
2296         than desired; gcd_terms might be used in such cases:
2297 
2298         >>> from sympy import gcd_terms
2299         >>> (4*x*(y + 1) + y).extract_additively(x)
2300         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y
2301         >>> gcd_terms(_)
2302         x*(4*y + 3) + y
2303 
2304         See Also
2305         ========
2306         extract_multiplicatively
2307         coeff
2308         as_coefficient
2309 
2310         """
2311 
2312         c = sympify(c)
2313         if self is S.NaN:
2314             return None
2315         if c is S.Zero:
2316             return self
2317         elif c == self:
2318             return S.Zero
2319         elif self is S.Zero:
2320             return None
2321 
2322         if self.is_Number:
2323             if not c.is_Number:
2324                 return None
2325             co = self
2326             diff = co - c
2327             # XXX should we match types? i.e should 3 - .1 succeed?
2328             if (co > 0 and diff > 0 and diff < co or
2329                     co < 0 and diff < 0 and diff > co):
2330                 return diff
2331             return None
2332 
2333         if c.is_Number:
2334             co, t = self.as_coeff_Add()
2335             xa = co.extract_additively(c)
2336             if xa is None:
2337                 return None
2338             return xa + t
2339 
2340         # handle the args[0].is_Number case separately
2341         # since we will have trouble looking for the coeff of
2342         # a number.
2343         if c.is_Add and c.args[0].is_Number:
2344             # whole term as a term factor
2345             co = self.coeff(c)
2346             xa0 = (co.extract_additively(1) or 0)*c
2347             if xa0:
2348                 diff = self - co*c
2349                 return (xa0 + (diff.extract_additively(c) or diff)) or None
2350             # term-wise
2351             h, t = c.as_coeff_Add()
2352             sh, st = self.as_coeff_Add()
2353             xa = sh.extract_additively(h)
2354             if xa is None:
2355                 return None
2356             xa2 = st.extract_additively(t)
2357             if xa2 is None:
2358                 return None
2359             return xa + xa2
2360 
2361         # whole term as a term factor
2362         co = self.coeff(c)
2363         xa0 = (co.extract_additively(1) or 0)*c
2364         if xa0:
2365             diff = self - co*c
2366             return (xa0 + (diff.extract_additively(c) or diff)) or None
2367         # term-wise
2368         coeffs = []
2369         for a in Add.make_args(c):
2370             ac, at = a.as_coeff_Mul()
2371             co = self.coeff(at)
2372             if not co:
2373                 return None
2374             coc, cot = co.as_coeff_Add()
2375             xa = coc.extract_additively(ac)
2376             if xa is None:
2377                 return None
2378             self -= co*at
2379             coeffs.append((cot + xa)*at)
2380         coeffs.append(self)
2381         return Add(*coeffs)
2382 
2383     @property
2384     def expr_free_symbols(self):
2385         """
2386         Like ``free_symbols``, but returns the free symbols only if they are contained in an expression node.
2387 
2388         Examples
2389         ========
2390 
2391         >>> from sympy.abc import x, y
2392         >>> (x + y).expr_free_symbols
2393         {x, y}
2394 
2395         If the expression is contained in a non-expression object, don't return
2396         the free symbols. Compare:
2397 
2398         >>> from sympy import Tuple
2399         >>> t = Tuple(x + y)
2400         >>> t.expr_free_symbols
2401         set()
2402         >>> t.free_symbols
2403         {x, y}
2404         """
2405         return {j for i in self.args for j in i.expr_free_symbols}
2406 
2407     def could_extract_minus_sign(self):
2408         """Return True if self is not in a canonical form with respect
2409         to its sign.
2410 
2411         For most expressions, e, there will be a difference in e and -e.
2412         When there is, True will be returned for one and False for the
2413         other; False will be returned if there is no difference.
2414 
2415         Examples
2416         ========
2417 
2418         >>> from sympy.abc import x, y
2419         >>> e = x - y
2420         >>> {i.could_extract_minus_sign() for i in (e, -e)}
2421         {False, True}
2422 
2423         """
2424         negative_self = -self
2425         if self == negative_self:
2426             return False  # e.g. zoo*x == -zoo*x
2427         self_has_minus = (self.extract_multiplicatively(-1) is not None)
2428         negative_self_has_minus = (
2429             (negative_self).extract_multiplicatively(-1) is not None)
2430         if self_has_minus != negative_self_has_minus:
2431             return self_has_minus
2432         else:
2433             if self.is_Add:
2434                 # We choose the one with less arguments with minus signs
2435                 all_args = len(self.args)
2436                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])
2437                 positive_args = all_args - negative_args
2438                 if positive_args > negative_args:
2439                     return False
2440                 elif positive_args < negative_args:
2441                     return True
2442             elif self.is_Mul:
2443                 # We choose the one with an odd number of minus signs
2444                 num, den = self.as_numer_denom()
2445                 args = Mul.make_args(num) + Mul.make_args(den)
2446                 arg_signs = [arg.could_extract_minus_sign() for arg in args]
2447                 negative_args = list(filter(None, arg_signs))
2448                 return len(negative_args) % 2 == 1
2449 
2450             # As a last resort, we choose the one with greater value of .sort_key()
2451             return bool(self.sort_key() < negative_self.sort_key())
2452 
2453     def extract_branch_factor(self, allow_half=False):
2454         """
2455         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.
2456         Return (z, n).
2457 
2458         >>> from sympy import exp_polar, I, pi
2459         >>> from sympy.abc import x, y
2460         >>> exp_polar(I*pi).extract_branch_factor()
2461         (exp_polar(I*pi), 0)
2462         >>> exp_polar(2*I*pi).extract_branch_factor()
2463         (1, 1)
2464         >>> exp_polar(-pi*I).extract_branch_factor()
2465         (exp_polar(I*pi), -1)
2466         >>> exp_polar(3*pi*I + x).extract_branch_factor()
2467         (exp_polar(x + I*pi), 1)
2468         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()
2469         (y*exp_polar(2*pi*x), -1)
2470         >>> exp_polar(-I*pi/2).extract_branch_factor()
2471         (exp_polar(-I*pi/2), 0)
2472 
2473         If allow_half is True, also extract exp_polar(I*pi):
2474 
2475         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)
2476         (1, 1/2)
2477         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)
2478         (1, 1)
2479         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)
2480         (1, 3/2)
2481         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)
2482         (1, -1/2)
2483         """
2484         from sympy import exp_polar, pi, I, ceiling, Add
2485         n = S(0)
2486         res = S(1)
2487         args = Mul.make_args(self)
2488         exps = []
2489         for arg in args:
2490             if isinstance(arg, exp_polar):
2491                 exps += [arg.exp]
2492             else:
2493                 res *= arg
2494         piimult = S(0)
2495         extras = []
2496         while exps:
2497             exp = exps.pop()
2498             if exp.is_Add:
2499                 exps += exp.args
2500                 continue
2501             if exp.is_Mul:
2502                 coeff = exp.as_coefficient(pi*I)
2503                 if coeff is not None:
2504                     piimult += coeff
2505                     continue
2506             extras += [exp]
2507         if piimult.is_number:
2508             coeff = piimult
2509             tail = ()
2510         else:
2511             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)
2512         # round down to nearest multiple of 2
2513         branchfact = ceiling(coeff/2 - S(1)/2)*2
2514         n += branchfact/2
2515         c = coeff - branchfact
2516         if allow_half:
2517             nc = c.extract_additively(1)
2518             if nc is not None:
2519                 n += S(1)/2
2520                 c = nc
2521         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)
2522         if newexp != 0:
2523             res *= exp_polar(newexp)
2524         return res, n
2525 
2526     def _eval_is_polynomial(self, syms):
2527         if self.free_symbols.intersection(syms) == set([]):
2528             return True
2529         return False
2530 
2531     def is_polynomial(self, *syms):
2532         r"""
2533         Return True if self is a polynomial in syms and False otherwise.
2534 
2535         This checks if self is an exact polynomial in syms.  This function
2536         returns False for expressions that are "polynomials" with symbolic
2537         exponents.  Thus, you should be able to apply polynomial algorithms to
2538         expressions for which this returns True, and Poly(expr, \*syms) should
2539         work if and only if expr.is_polynomial(\*syms) returns True. The
2540         polynomial does not have to be in expanded form.  If no symbols are
2541         given, all free symbols in the expression will be used.
2542 
2543         This is not part of the assumptions system.  You cannot do
2544         Symbol('z', polynomial=True).
2545 
2546         Examples
2547         ========
2548 
2549         >>> from sympy import Symbol
2550         >>> x = Symbol('x')
2551         >>> ((x**2 + 1)**4).is_polynomial(x)
2552         True
2553         >>> ((x**2 + 1)**4).is_polynomial()
2554         True
2555         >>> (2**x + 1).is_polynomial(x)
2556         False
2557 
2558 
2559         >>> n = Symbol('n', nonnegative=True, integer=True)
2560         >>> (x**n + 1).is_polynomial(x)
2561         False
2562 
2563         This function does not attempt any nontrivial simplifications that may
2564         result in an expression that does not appear to be a polynomial to
2565         become one.
2566 
2567         >>> from sympy import sqrt, factor, cancel
2568         >>> y = Symbol('y', positive=True)
2569         >>> a = sqrt(y**2 + 2*y + 1)
2570         >>> a.is_polynomial(y)
2571         False
2572         >>> factor(a)
2573         y + 1
2574         >>> factor(a).is_polynomial(y)
2575         True
2576 
2577         >>> b = (y**2 + 2*y + 1)/(y + 1)
2578         >>> b.is_polynomial(y)
2579         False
2580         >>> cancel(b)
2581         y + 1
2582         >>> cancel(b).is_polynomial(y)
2583         True
2584 
2585         See also .is_rational_function()
2586 
2587         """
2588         if syms:
2589             syms = set(map(sympify, syms))
2590         else:
2591             syms = self.free_symbols
2592 
2593         if syms.intersection(self.free_symbols) == set([]):
2594             # constant polynomial
2595             return True
2596         else:
2597             return self._eval_is_polynomial(syms)
2598 
2599     def _eval_is_rational_function(self, syms):
2600         if self.free_symbols.intersection(syms) == set([]):
2601             return True
2602         return False
2603 
2604     def is_rational_function(self, *syms):
2605         """
2606         Test whether function is a ratio of two polynomials in the given
2607         symbols, syms. When syms is not given, all free symbols will be used.
2608         The rational function does not have to be in expanded or in any kind of
2609         canonical form.
2610 
2611         This function returns False for expressions that are "rational
2612         functions" with symbolic exponents.  Thus, you should be able to call
2613         .as_numer_denom() and apply polynomial algorithms to the result for
2614         expressions for which this returns True.
2615 
2616         This is not part of the assumptions system.  You cannot do
2617         Symbol('z', rational_function=True).
2618 
2619         Examples
2620         ========
2621 
2622         >>> from sympy import Symbol, sin
2623         >>> from sympy.abc import x, y
2624 
2625         >>> (x/y).is_rational_function()
2626         True
2627 
2628         >>> (x**2).is_rational_function()
2629         True
2630 
2631         >>> (x/sin(y)).is_rational_function(y)
2632         False
2633 
2634         >>> n = Symbol('n', integer=True)
2635         >>> (x**n + 1).is_rational_function(x)
2636         False
2637 
2638         This function does not attempt any nontrivial simplifications that may
2639         result in an expression that does not appear to be a rational function
2640         to become one.
2641 
2642         >>> from sympy import sqrt, factor
2643         >>> y = Symbol('y', positive=True)
2644         >>> a = sqrt(y**2 + 2*y + 1)/y
2645         >>> a.is_rational_function(y)
2646         False
2647         >>> factor(a)
2648         (y + 1)/y
2649         >>> factor(a).is_rational_function(y)
2650         True
2651 
2652         See also is_algebraic_expr().
2653 
2654         """
2655         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:
2656             return False
2657 
2658         if syms:
2659             syms = set(map(sympify, syms))
2660         else:
2661             syms = self.free_symbols
2662 
2663         if syms.intersection(self.free_symbols) == set([]):
2664             # constant rational function
2665             return True
2666         else:
2667             return self._eval_is_rational_function(syms)
2668 
2669     def _eval_is_algebraic_expr(self, syms):
2670         if self.free_symbols.intersection(syms) == set([]):
2671             return True
2672         return False
2673 
2674     def is_algebraic_expr(self, *syms):
2675         """
2676         This tests whether a given expression is algebraic or not, in the
2677         given symbols, syms. When syms is not given, all free symbols
2678         will be used. The rational function does not have to be in expanded
2679         or in any kind of canonical form.
2680 
2681         This function returns False for expressions that are "algebraic
2682         expressions" with symbolic exponents. This is a simple extension to the
2683         is_rational_function, including rational exponentiation.
2684 
2685         Examples
2686         ========
2687 
2688         >>> from sympy import Symbol, sqrt
2689         >>> x = Symbol('x', real=True)
2690         >>> sqrt(1 + x).is_rational_function()
2691         False
2692         >>> sqrt(1 + x).is_algebraic_expr()
2693         True
2694 
2695         This function does not attempt any nontrivial simplifications that may
2696         result in an expression that does not appear to be an algebraic
2697         expression to become one.
2698 
2699         >>> from sympy import exp, factor
2700         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)
2701         >>> a.is_algebraic_expr(x)
2702         False
2703         >>> factor(a).is_algebraic_expr()
2704         True
2705 
2706         See Also
2707         ========
2708         is_rational_function()
2709 
2710         References
2711         ==========
2712 
2713         - https://en.wikipedia.org/wiki/Algebraic_expression
2714 
2715         """
2716         if syms:
2717             syms = set(map(sympify, syms))
2718         else:
2719             syms = self.free_symbols
2720 
2721         if syms.intersection(self.free_symbols) == set([]):
2722             # constant algebraic expression
2723             return True
2724         else:
2725             return self._eval_is_algebraic_expr(syms)
2726 
2727     ###################################################################################
2728     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################
2729     ###################################################################################
2730 
2731     def series(self, x=None, x0=0, n=6, dir="+", logx=None):
2732         """
2733         Series expansion of "self" around ``x = x0`` yielding either terms of
2734         the series one by one (the lazy series given when n=None), else
2735         all the terms at once when n != None.
2736 
2737         Returns the series expansion of "self" around the point ``x = x0``
2738         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).
2739 
2740         If ``x=None`` and ``self`` is univariate, the univariate symbol will
2741         be supplied, otherwise an error will be raised.
2742 
2743         Parameters
2744         ==========
2745 
2746         expr : Expression
2747                The expression whose series is to be expanded.
2748 
2749         x : Symbol
2750             It is the variable of the expression to be calculated.
2751 
2752         x0 : Value
2753              The value around which ``x`` is calculated. Can be any value
2754              from ``-oo`` to ``oo``.
2755 
2756         n : Value
2757             The number of terms upto which the series is to be expanded.
2758 
2759         dir : String, optional
2760               The series-expansion can be bi-directional. If ``dir="+"``,
2761               then (x->x0+). If ``dir="-", then (x->x0-). For infinite
2762               ``x0`` (``oo`` or ``-oo``), the ``dir`` argument is determined
2763               from the direction of the infinity (i.e., ``dir="-"`` for
2764               ``oo``).
2765 
2766         logx : optional
2767                It is used to replace any log(x) in the returned series with a
2768                symbolic value rather than evaluating the actual value.
2769 
2770         Examples
2771         ========
2772 
2773         >>> from sympy import cos, exp, tan, oo, series
2774         >>> from sympy.abc import x, y
2775         >>> cos(x).series()
2776         1 - x**2/2 + x**4/24 + O(x**6)
2777         >>> cos(x).series(n=4)
2778         1 - x**2/2 + O(x**4)
2779         >>> cos(x).series(x, x0=1, n=2)
2780         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))
2781         >>> e = cos(x + exp(y))
2782         >>> e.series(y, n=2)
2783         cos(x + 1) - y*sin(x + 1) + O(y**2)
2784         >>> e.series(x, n=2)
2785         cos(exp(y)) - x*sin(exp(y)) + O(x**2)
2786 
2787         If ``n=None`` then a generator of the series terms will be returned.
2788 
2789         >>> term=cos(x).series(n=None)
2790         >>> [next(term) for i in range(2)]
2791         [1, -x**2/2]
2792 
2793         For ``dir=+`` (default) the series is calculated from the right and
2794         for ``dir=-`` the series from the left. For smooth functions this
2795         flag will not alter the results.
2796 
2797         >>> abs(x).series(dir="+")
2798         x
2799         >>> abs(x).series(dir="-")
2800         -x
2801         >>> f = tan(x)
2802         >>> f.series(x, 2, 6, "+")
2803         tan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +
2804         (x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +
2805         5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +
2806         2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2))
2807 
2808         >>> f.series(x, 2, 3, "-")
2809         tan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))
2810         + O((x - 2)**3, (x, 2))
2811 
2812         Returns
2813         =======
2814 
2815         Expr : Expression
2816             Series expansion of the expression about x0
2817 
2818         Raises
2819         ======
2820 
2821         TypeError
2822             If "n" and "x0" are infinity objects
2823 
2824         PoleError
2825             If "x0" is an infinity object
2826 
2827         """
2828         from sympy import collect, Dummy, Order, Rational, Symbol, ceiling
2829         if x is None:
2830             syms = self.free_symbols
2831             if not syms:
2832                 return self
2833             elif len(syms) > 1:
2834                 raise ValueError('x must be given for multivariate functions.')
2835             x = syms.pop()
2836 
2837         if isinstance(x, Symbol):
2838             dep = x in self.free_symbols
2839         else:
2840             d = Dummy()
2841             dep = d in self.xreplace({x: d}).free_symbols
2842         if not dep:
2843             if n is None:
2844                 return (s for s in [self])
2845             else:
2846                 return self
2847 
2848         if len(dir) != 1 or dir not in '+-':
2849             raise ValueError("Dir must be '+' or '-'")
2850 
2851         if x0 in [S.Infinity, S.NegativeInfinity]:
2852             sgn = 1 if x0 is S.Infinity else -1
2853             s = self.subs(x, sgn/x).series(x, n=n, dir='+')
2854             if n is None:
2855                 return (si.subs(x, sgn/x) for si in s)
2856             return s.subs(x, sgn/x)
2857 
2858 
2859         # use rep to shift origin to x0 and change sign (if dir is negative)
2860         # and undo the process with rep2
2861         if x0 or dir == '-':
2862             if dir == '-':
2863                 rep = -x + x0
2864                 rep2 = -x
2865                 rep2b = x0
2866             else:
2867                 rep = x + x0
2868                 rep2 = x
2869                 rep2b = -x0
2870             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)
2871             if n is None:  # lseries...
2872                 return (si.subs(x, rep2 + rep2b) for si in s)
2873             return s.subs(x, rep2 + rep2b)
2874 
2875         # from here on it's x0=0 and dir='+' handling
2876 
2877         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:
2878             # replace x with an x that has a positive assumption
2879             xpos = Dummy('x', positive=True, finite=True)
2880             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)
2881             if n is None:
2882                 return (s.subs(xpos, x) for s in rv)
2883             else:
2884                 return rv.subs(xpos, x)
2885 
2886         if n is not None:  # nseries handling
2887             s1 = self._eval_nseries(x, n=n, logx=logx)
2888             o = s1.getO() or S.Zero
2889             if o:
2890                 # make sure the requested order is returned
2891                 ngot = o.getn()
2892                 if ngot > n:
2893                     # leave o in its current form (e.g. with x*log(x)) so
2894                     # it eats terms properly, then replace it below
2895                     if n != 0:
2896                         s1 += o.subs(x, x**Rational(n, ngot))
2897                     else:
2898                         s1 += Order(1, x)
2899                 elif ngot < n:
2900                     # increase the requested number of terms to get the desired
2901                     # number keep increasing (up to 9) until the received order
2902                     # is different than the original order and then predict how
2903                     # many additional terms are needed
2904                     for more in range(1, 9):
2905                         s1 = self._eval_nseries(x, n=n + more, logx=logx)
2906                         newn = s1.getn()
2907                         if newn != ngot:
2908                             ndo = n + ceiling((n - ngot)*more/(newn - ngot))
2909                             s1 = self._eval_nseries(x, n=ndo, logx=logx)
2910                             while s1.getn() < n:
2911                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)
2912                                 ndo += 1
2913                             break
2914                     else:
2915                         raise ValueError('Could not calculate %s terms for %s'
2916                                          % (str(n), self))
2917                     s1 += Order(x**n, x)
2918                 o = s1.getO()
2919                 s1 = s1.removeO()
2920             else:
2921                 o = Order(x**n, x)
2922                 s1done = s1.doit()
2923                 if (s1done + o).removeO() == s1done:
2924                     o = S.Zero
2925 
2926             try:
2927                 return collect(s1, x) + o
2928             except NotImplementedError:
2929                 return s1 + o
2930 
2931         else:  # lseries handling
2932             def yield_lseries(s):
2933                 """Return terms of lseries one at a time."""
2934                 for si in s:
2935                     if not si.is_Add:
2936                         yield si
2937                         continue
2938                     # yield terms 1 at a time if possible
2939                     # by increasing order until all the
2940                     # terms have been returned
2941                     yielded = 0
2942                     o = Order(si, x)*x
2943                     ndid = 0
2944                     ndo = len(si.args)
2945                     while 1:
2946                         do = (si - yielded + o).removeO()
2947                         o *= x
2948                         if not do or do.is_Order:
2949                             continue
2950                         if do.is_Add:
2951                             ndid += len(do.args)
2952                         else:
2953                             ndid += 1
2954                         yield do
2955                         if ndid == ndo:
2956                             break
2957                         yielded += do
2958 
2959             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))
2960 
2961     def taylor_term(self, n, x, *previous_terms):
2962         """General method for the taylor term.
2963 
2964         This method is slow, because it differentiates n-times. Subclasses can
2965         redefine it to make it faster by using the "previous_terms".
2966         """
2967         from sympy import Dummy, factorial
2968         x = sympify(x)
2969         _x = Dummy('x')
2970         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)
2971 
2972     def lseries(self, x=None, x0=0, dir='+', logx=None):
2973         """
2974         Wrapper for series yielding an iterator of the terms of the series.
2975 
2976         Note: an infinite series will yield an infinite iterator. The following,
2977         for exaxmple, will never terminate. It will just keep printing terms
2978         of the sin(x) series::
2979 
2980           for term in sin(x).lseries(x):
2981               print term
2982 
2983         The advantage of lseries() over nseries() is that many times you are
2984         just interested in the next term in the series (i.e. the first term for
2985         example), but you don't know how many you should ask for in nseries()
2986         using the "n" parameter.
2987 
2988         See also nseries().
2989         """
2990         return self.series(x, x0, n=None, dir=dir, logx=logx)
2991 
2992     def _eval_lseries(self, x, logx=None):
2993         # default implementation of lseries is using nseries(), and adaptively
2994         # increasing the "n". As you can see, it is not very efficient, because
2995         # we are calculating the series over and over again. Subclasses should
2996         # override this method and implement much more efficient yielding of
2997         # terms.
2998         n = 0
2999         series = self._eval_nseries(x, n=n, logx=logx)
3000         if not series.is_Order:
3001             if series.is_Add:
3002                 yield series.removeO()
3003             else:
3004                 yield series
3005             return
3006 
3007         while series.is_Order:
3008             n += 1
3009             series = self._eval_nseries(x, n=n, logx=logx)
3010         e = series.removeO()
3011         yield e
3012         while 1:
3013             while 1:
3014                 n += 1
3015                 series = self._eval_nseries(x, n=n, logx=logx).removeO()
3016                 if e != series:
3017                     break
3018             yield series - e
3019             e = series
3020 
3021     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):
3022         """
3023         Wrapper to _eval_nseries if assumptions allow, else to series.
3024 
3025         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is
3026         called. This calculates "n" terms in the innermost expressions and
3027         then builds up the final series just by "cross-multiplying" everything
3028         out.
3029 
3030         The optional ``logx`` parameter can be used to replace any log(x) in the
3031         returned series with a symbolic value to avoid evaluating log(x) at 0. A
3032         symbol to use in place of log(x) should be provided.
3033 
3034         Advantage -- it's fast, because we don't have to determine how many
3035         terms we need to calculate in advance.
3036 
3037         Disadvantage -- you may end up with less terms than you may have
3038         expected, but the O(x**n) term appended will always be correct and
3039         so the result, though perhaps shorter, will also be correct.
3040 
3041         If any of those assumptions is not met, this is treated like a
3042         wrapper to series which will try harder to return the correct
3043         number of terms.
3044 
3045         See also lseries().
3046 
3047         Examples
3048         ========
3049 
3050         >>> from sympy import sin, log, Symbol
3051         >>> from sympy.abc import x, y
3052         >>> sin(x).nseries(x, 0, 6)
3053         x - x**3/6 + x**5/120 + O(x**6)
3054         >>> log(x+1).nseries(x, 0, 5)
3055         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)
3056 
3057         Handling of the ``logx`` parameter --- in the following example the
3058         expansion fails since ``sin`` does not have an asymptotic expansion
3059         at -oo (the limit of log(x) as x approaches 0):
3060 
3061         >>> e = sin(log(x))
3062         >>> e.nseries(x, 0, 6)
3063         Traceback (most recent call last):
3064         ...
3065         PoleError: ...
3066         ...
3067         >>> logx = Symbol('logx')
3068         >>> e.nseries(x, 0, 6, logx=logx)
3069         sin(logx)
3070 
3071         In the following example, the expansion works but gives only an Order term
3072         unless the ``logx`` parameter is used:
3073 
3074         >>> e = x**y
3075         >>> e.nseries(x, 0, 2)
3076         O(log(x)**2)
3077         >>> e.nseries(x, 0, 2, logx=logx)
3078         exp(logx*y)
3079 
3080         """
3081         if x and not x in self.free_symbols:
3082             return self
3083         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):
3084             return self.series(x, x0, n, dir)
3085         else:
3086             return self._eval_nseries(x, n=n, logx=logx)
3087 
3088     def _eval_nseries(self, x, n, logx):
3089         """
3090         Return terms of series for self up to O(x**n) at x=0
3091         from the positive direction.
3092 
3093         This is a method that should be overridden in subclasses. Users should
3094         never call this method directly (use .nseries() instead), so you don't
3095         have to write docstrings for _eval_nseries().
3096         """
3097         from sympy.utilities.misc import filldedent
3098         raise NotImplementedError(filldedent("""
3099                      The _eval_nseries method should be added to
3100                      %s to give terms up to O(x**n) at x=0
3101                      from the positive direction so it is available when
3102                      nseries calls it.""" % self.func)
3103                      )
3104 
3105     def limit(self, x, xlim, dir='+'):
3106         """ Compute limit x->xlim.
3107         """
3108         from sympy.series.limits import limit
3109         return limit(self, x, xlim, dir)
3110 
3111     def compute_leading_term(self, x, logx=None):
3112         """
3113         as_leading_term is only allowed for results of .series()
3114         This is a wrapper to compute a series first.
3115         """
3116         from sympy import Dummy, log
3117         from sympy.series.gruntz import calculate_series
3118 
3119         if self.removeO() == 0:
3120             return self
3121 
3122         if logx is None:
3123             d = Dummy('logx')
3124             s = calculate_series(self, x, d).subs(d, log(x))
3125         else:
3126             s = calculate_series(self, x, logx)
3127 
3128         return s.as_leading_term(x)
3129 
3130     @cacheit
3131     def as_leading_term(self, *symbols):
3132         """
3133         Returns the leading (nonzero) term of the series expansion of self.
3134 
3135         The _eval_as_leading_term routines are used to do this, and they must
3136         always return a non-zero value.
3137 
3138         Examples
3139         ========
3140 
3141         >>> from sympy.abc import x
3142         >>> (1 + x + x**2).as_leading_term(x)
3143         1
3144         >>> (1/x**2 + x + x**2).as_leading_term(x)
3145         x**(-2)
3146 
3147         """
3148         from sympy import powsimp
3149         if len(symbols) > 1:
3150             c = self
3151             for x in symbols:
3152                 c = c.as_leading_term(x)
3153             return c
3154         elif not symbols:
3155             return self
3156         x = sympify(symbols[0])
3157         if not x.is_symbol:
3158             raise ValueError('expecting a Symbol but got %s' % x)
3159         if x not in self.free_symbols:
3160             return self
3161         obj = self._eval_as_leading_term(x)
3162         if obj is not None:
3163             return powsimp(obj, deep=True, combine='exp')
3164         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))
3165 
3166     def _eval_as_leading_term(self, x):
3167         return self
3168 
3169     def as_coeff_exponent(self, x):
3170         """ ``c*x**e -> c,e`` where x can be any symbolic expression.
3171         """
3172         from sympy import collect
3173         s = collect(self, x)
3174         c, p = s.as_coeff_mul(x)
3175         if len(p) == 1:
3176             b, e = p[0].as_base_exp()
3177             if b == x:
3178                 return c, e
3179         return s, S.Zero
3180 
3181     def leadterm(self, x):
3182         """
3183         Returns the leading term a*x**b as a tuple (a, b).
3184 
3185         Examples
3186         ========
3187 
3188         >>> from sympy.abc import x
3189         >>> (1+x+x**2).leadterm(x)
3190         (1, 0)
3191         >>> (1/x**2+x+x**2).leadterm(x)
3192         (1, -2)
3193 
3194         """
3195         from sympy import Dummy, log
3196         l = self.as_leading_term(x)
3197         d = Dummy('logx')
3198         if l.has(log(x)):
3199             l = l.subs(log(x), d)
3200         c, e = l.as_coeff_exponent(x)
3201         if x in c.free_symbols:
3202             from sympy.utilities.misc import filldedent
3203             raise ValueError(filldedent("""
3204                 cannot compute leadterm(%s, %s). The coefficient
3205                 should have been free of x but got %s""" % (self, x, c)))
3206         c = c.subs(d, log(x))
3207         return c, e
3208 
3209     def as_coeff_Mul(self, rational=False):
3210         """Efficiently extract the coefficient of a product. """
3211         return S.One, self
3212 
3213     def as_coeff_Add(self, rational=False):
3214         """Efficiently extract the coefficient of a summation. """
3215         return S.Zero, self
3216 
3217     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,
3218             full=False):
3219         """
3220         Compute formal power power series of self.
3221 
3222         See the docstring of the :func:`fps` function in sympy.series.formal for
3223         more information.
3224         """
3225         from sympy.series.formal import fps
3226 
3227         return fps(self, x, x0, dir, hyper, order, rational, full)
3228 
3229     def fourier_series(self, limits=None):
3230         """Compute fourier sine/cosine series of self.
3231 
3232         See the docstring of the :func:`fourier_series` in sympy.series.fourier
3233         for more information.
3234         """
3235         from sympy.series.fourier import fourier_series
3236 
3237         return fourier_series(self, limits)
3238 
3239     ###################################################################################
3240     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################
3241     ###################################################################################
3242 
3243     def diff(self, *symbols, **assumptions):
3244         assumptions.setdefault("evaluate", True)
3245         return Derivative(self, *symbols, **assumptions)
3246 
3247     ###########################################################################
3248     ###################### EXPRESSION EXPANSION METHODS #######################
3249     ###########################################################################
3250 
3251     # Relevant subclasses should override _eval_expand_hint() methods.  See
3252     # the docstring of expand() for more info.
3253 
3254     def _eval_expand_complex(self, **hints):
3255         real, imag = self.as_real_imag(**hints)
3256         return real + S.ImaginaryUnit*imag
3257 
3258     @staticmethod
3259     def _expand_hint(expr, hint, deep=True, **hints):
3260         """
3261         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.
3262 
3263         Returns ``(expr, hit)``, where expr is the (possibly) expanded
3264         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
3265         ``False`` otherwise.
3266         """
3267         hit = False
3268         # XXX: Hack to support non-Basic args
3269         #              |
3270         #              V
3271         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
3272             sargs = []
3273             for arg in expr.args:
3274                 arg, arghit = Expr._expand_hint(arg, hint, **hints)
3275                 hit |= arghit
3276                 sargs.append(arg)
3277 
3278             if hit:
3279                 expr = expr.func(*sargs)
3280 
3281         if hasattr(expr, hint):
3282             newexpr = getattr(expr, hint)(**hints)
3283             if newexpr != expr:
3284                 return (newexpr, True)
3285 
3286         return (expr, hit)
3287 
3288     @cacheit
3289     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,
3290             mul=True, log=True, multinomial=True, basic=True, **hints):
3291         """
3292         Expand an expression using hints.
3293 
3294         See the docstring of the expand() function in sympy.core.function for
3295         more information.
3296 
3297         """
3298         from sympy.simplify.radsimp import fraction
3299 
3300         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,
3301            log=log, multinomial=multinomial, basic=basic)
3302 
3303         expr = self
3304         if hints.pop('frac', False):
3305             n, d = [a.expand(deep=deep, modulus=modulus, **hints)
3306                     for a in fraction(self)]
3307             return n/d
3308         elif hints.pop('denom', False):
3309             n, d = fraction(self)
3310             return n/d.expand(deep=deep, modulus=modulus, **hints)
3311         elif hints.pop('numer', False):
3312             n, d = fraction(self)
3313             return n.expand(deep=deep, modulus=modulus, **hints)/d
3314 
3315         # Although the hints are sorted here, an earlier hint may get applied
3316         # at a given node in the expression tree before another because of how
3317         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +
3318         # x*z) because while applying log at the top level, log and mul are
3319         # applied at the deeper level in the tree so that when the log at the
3320         # upper level gets applied, the mul has already been applied at the
3321         # lower level.
3322 
3323         # Additionally, because hints are only applied once, the expression
3324         # may not be expanded all the way.   For example, if mul is applied
3325         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For
3326         # now, we just use a special case to make multinomial run before mul,
3327         # so that at least polynomials will be expanded all the way.  In the
3328         # future, smarter heuristics should be applied.
3329         # TODO: Smarter heuristics
3330 
3331         def _expand_hint_key(hint):
3332             """Make multinomial come before mul"""
3333             if hint == 'mul':
3334                 return 'mulz'
3335             return hint
3336 
3337         for hint in sorted(hints.keys(), key=_expand_hint_key):
3338             use_hint = hints[hint]
3339             if use_hint:
3340                 hint = '_eval_expand_' + hint
3341                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)
3342 
3343         while True:
3344             was = expr
3345             if hints.get('multinomial', False):
3346                 expr, _ = Expr._expand_hint(
3347                     expr, '_eval_expand_multinomial', deep=deep, **hints)
3348             if hints.get('mul', False):
3349                 expr, _ = Expr._expand_hint(
3350                     expr, '_eval_expand_mul', deep=deep, **hints)
3351             if hints.get('log', False):
3352                 expr, _ = Expr._expand_hint(
3353                     expr, '_eval_expand_log', deep=deep, **hints)
3354             if expr == was:
3355                 break
3356 
3357         if modulus is not None:
3358             modulus = sympify(modulus)
3359 
3360             if not modulus.is_Integer or modulus <= 0:
3361                 raise ValueError(
3362                     "modulus must be a positive integer, got %s" % modulus)
3363 
3364             terms = []
3365 
3366             for term in Add.make_args(expr):
3367                 coeff, tail = term.as_coeff_Mul(rational=True)
3368 
3369                 coeff %= modulus
3370 
3371                 if coeff:
3372                     terms.append(coeff*tail)
3373 
3374             expr = Add(*terms)
3375 
3376         return expr
3377 
3378     ###########################################################################
3379     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################
3380     ###########################################################################
3381 
3382     def integrate(self, *args, **kwargs):
3383         """See the integrate function in sympy.integrals"""
3384         from sympy.integrals import integrate
3385         return integrate(self, *args, **kwargs)
3386 
3387     def simplify(self, ratio=1.7, measure=None, rational=False, inverse=False):
3388         """See the simplify function in sympy.simplify"""
3389         from sympy.simplify import simplify
3390         from sympy.core.function import count_ops
3391         measure = measure or count_ops
3392         return simplify(self, ratio, measure)
3393 
3394     def nsimplify(self, constants=[], tolerance=None, full=False):
3395         """See the nsimplify function in sympy.simplify"""
3396         from sympy.simplify import nsimplify
3397         return nsimplify(self, constants, tolerance, full)
3398 
3399     def separate(self, deep=False, force=False):
3400         """See the separate function in sympy.simplify"""
3401         from sympy.core.function import expand_power_base
3402         return expand_power_base(self, deep=deep, force=force)
3403 
3404     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):
3405         """See the collect function in sympy.simplify"""
3406         from sympy.simplify import collect
3407         return collect(self, syms, func, evaluate, exact, distribute_order_term)
3408 
3409     def together(self, *args, **kwargs):
3410         """See the together function in sympy.polys"""
3411         from sympy.polys import together
3412         return together(self, *args, **kwargs)
3413 
3414     def apart(self, x=None, **args):
3415         """See the apart function in sympy.polys"""
3416         from sympy.polys import apart
3417         return apart(self, x, **args)
3418 
3419     def ratsimp(self):
3420         """See the ratsimp function in sympy.simplify"""
3421         from sympy.simplify import ratsimp
3422         return ratsimp(self)
3423 
3424     def trigsimp(self, **args):
3425         """See the trigsimp function in sympy.simplify"""
3426         from sympy.simplify import trigsimp
3427         return trigsimp(self, **args)
3428 
3429     def radsimp(self, **kwargs):
3430         """See the radsimp function in sympy.simplify"""
3431         from sympy.simplify import radsimp
3432         return radsimp(self, **kwargs)
3433 
3434     def powsimp(self, *args, **kwargs):
3435         """See the powsimp function in sympy.simplify"""
3436         from sympy.simplify import powsimp
3437         return powsimp(self, *args, **kwargs)
3438 
3439     def combsimp(self):
3440         """See the combsimp function in sympy.simplify"""
3441         from sympy.simplify import combsimp
3442         return combsimp(self)
3443 
3444     def gammasimp(self):
3445         """See the gammasimp function in sympy.simplify"""
3446         from sympy.simplify import gammasimp
3447         return gammasimp(self)
3448 
3449     def factor(self, *gens, **args):
3450         """See the factor() function in sympy.polys.polytools"""
3451         from sympy.polys import factor
3452         return factor(self, *gens, **args)
3453 
3454     def refine(self, assumption=True):
3455         """See the refine function in sympy.assumptions"""
3456         from sympy.assumptions import refine
3457         return refine(self, assumption)
3458 
3459     def cancel(self, *gens, **args):
3460         """See the cancel function in sympy.polys"""
3461         from sympy.polys import cancel
3462         return cancel(self, *gens, **args)
3463 
3464     def invert(self, g, *gens, **args):
3465         """Return the multiplicative inverse of ``self`` mod ``g``
3466         where ``self`` (and ``g``) may be symbolic expressions).
3467 
3468         See Also
3469         ========
3470         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert
3471         """
3472         from sympy.polys.polytools import invert
3473         from sympy.core.numbers import mod_inverse
3474         if self.is_number and getattr(g, 'is_number', True):
3475             return mod_inverse(self, g)
3476         return invert(self, g, *gens, **args)
3477 
3478     def round(self, n=None):
3479         """Return x rounded to the given decimal place.
3480 
3481         If a complex number would results, apply round to the real
3482         and imaginary components of the number.
3483 
3484         Examples
3485         ========
3486 
3487         >>> from sympy import pi, E, I, S, Add, Mul, Number
3488         >>> pi.round()
3489         3
3490         >>> pi.round(2)
3491         3.14
3492         >>> (2*pi + E*I).round()
3493         6 + 3*I
3494 
3495         The round method has a chopping effect:
3496 
3497         >>> (2*pi + I/10).round()
3498         6
3499         >>> (pi/10 + 2*I).round()
3500         2*I
3501         >>> (pi/10 + E*I).round(2)
3502         0.31 + 2.72*I
3503 
3504         Notes
3505         =====
3506 
3507         The Python builtin function, round, always returns a
3508         float in Python 2 while the SymPy round method (and
3509         round with a Number argument in Python 3) returns a
3510         Number.
3511 
3512         >>> from sympy.core.compatibility import PY3
3513         >>> isinstance(round(S(123), -2), Number if PY3 else float)
3514         True
3515 
3516         For a consistent behavior, and Python 3 rounding
3517         rules, import `round` from sympy.core.compatibility.
3518 
3519         >>> from sympy.core.compatibility import round
3520         >>> isinstance(round(S(123), -2), Number)
3521         True
3522         """
3523         from sympy.core.power import integer_log
3524         from sympy.core.numbers import Float
3525 
3526         x = self
3527 
3528         if not x.is_number:
3529             raise TypeError("can't round symbolic expression")
3530         if not x.is_Atom:
3531             if not pure_complex(x.n(2), or_real=True):
3532                 raise TypeError(
3533                     'Expected a number but got %s:' % func_name(x))
3534         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):
3535             return x
3536         if not x.is_extended_real:
3537             i, r = x.as_real_imag()
3538             return i.round(n) + S.ImaginaryUnit*r.round(n)
3539         if not x:
3540             return S.Zero if n is None else x
3541 
3542 
3543         p = as_int(n or 0)
3544 
3545         if x.is_Integer:
3546             # XXX return Integer(round(int(x), p)) when Py2 is dropped
3547             if p >= 0:
3548                 return x
3549             m = 10**-p
3550             i, r = divmod(abs(x), m)
3551             if i%2 and 2*r == m:
3552               i += 1
3553             elif 2*r > m:
3554                 i += 1
3555             if x < 0:
3556                 i *= -1
3557             return i*m
3558 
3559         digits_to_decimal = _mag(x)  # _mag(12) = 2, _mag(.012) = -1
3560         allow = digits_needed = digits_to_decimal + p
3561         precs = [f._prec for f in x.atoms(Float)]
3562         dps = prec_to_dps(max(precs)) if precs else None
3563         if dps is None:
3564             # assume everything is exact so use the Python
3565             # float default or whatever was requested
3566             dps = max(15, allow)
3567         else:
3568             allow = min(allow, dps)
3569         # this will shift all digits to right of decimal
3570         # and give us dps to work with as an int
3571         shift = -digits_to_decimal + dps
3572         extra = 1  # how far we look past known digits
3573         # NOTE
3574         # mpmath will calculate the binary representation to
3575         # an arbitrary number of digits but we must base our
3576         # answer on a finite number of those digits, e.g.
3577         # .575 2589569785738035/2**52 in binary.
3578         # mpmath shows us that the first 18 digits are
3579         #     >>> Float(.575).n(18)
3580         #     0.574999999999999956
3581         # The default precision is 15 digits and if we ask
3582         # for 15 we get
3583         #     >>> Float(.575).n(15)
3584         #     0.575000000000000
3585         # mpmath handles rounding at the 15th digit. But we
3586         # need to be careful since the user might be asking
3587         # for rounding at the last digit and our semantics
3588         # are to round toward the even final digit when there
3589         # is a tie. So the extra digit will be used to make
3590         # that decision. In this case, the value is the same
3591         # to 15 digits:
3592         #     >>> Float(.575).n(16)
3593         #     0.5750000000000000
3594         # Now converting this to the 15 known digits gives
3595         #     575000000000000.0
3596         # which rounds to integer
3597         #    5750000000000000
3598         # And now we can round to the desired digt, e.g. at
3599         # the second from the left and we get
3600         #    5800000000000000
3601         # and rescaling that gives
3602         #    0.58
3603         # as the final result.
3604         # If the value is made slightly less than 0.575 we might
3605         # still obtain the same value:
3606         #    >>> Float(.575-1e-16).n(16)*10**15
3607         #    574999999999999.8
3608         # What 15 digits best represents the known digits (which are
3609         # to the left of the decimal? 5750000000000000, the same as
3610         # before. The only way we will round down (in this case) is
3611         # if we declared that we had more than 15 digits of precision.
3612         # For example, if we use 16 digits of precision, the integer
3613         # we deal with is
3614         #    >>> Float(.575-1e-16).n(17)*10**16
3615         #    5749999999999998.4
3616         # and this now rounds to 5749999999999998 and (if we round to
3617         # the 2nd digit from the left) we get 5700000000000000.
3618         #
3619         xf = x.n(dps + extra)*Pow(10, shift)
3620         xi = Integer(xf)
3621         # use the last digit to select the value of xi
3622         # nearest to x before rounding at the desired digit
3623         sign = 1 if x > 0 else -1
3624         dif2 = sign*(xf - xi).n(extra)
3625         if dif2 < 0:
3626             raise NotImplementedError(
3627                 'not expecting int(x) to round away from 0')
3628         if dif2 > .5:
3629             xi += sign  # round away from 0
3630         elif dif2 == .5:
3631             xi += sign if xi%2 else -sign  # round toward even
3632         # shift p to the new position
3633         ip = p - shift
3634         # let Python handle the int rounding then rescale
3635         xr = xi.round(ip) # when Py2 is drop make this round(xi.p, ip)
3636         # restore scale
3637         rv = Rational(xr, Pow(10, shift))
3638         # return Float or Integer
3639         if rv.is_Integer:
3640             if n is None:  # the single-arg case
3641                 return rv
3642             # use str or else it won't be a float
3643             return Float(str(rv), dps)  # keep same precision
3644         else:
3645             if not allow and rv > self:
3646                 allow += 1
3647             return Float(rv, allow)
3648 
3649     __round__ = round
3650 
3651     def _eval_derivative_matrix_lines(self, x):
3652         from sympy.matrices.expressions.matexpr import _LeftRightArgs
3653         return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 20:52:38.825 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 20:52:38.825 | INFO     | Search-only: skipping patch selection
2025-10-17 20:52:38.919 | INFO     | Task sympy__sympy-17139 completed successfully.
2025-10-17 20:52:38.920 | INFO     | No patch generated. You can try running ACR again.
