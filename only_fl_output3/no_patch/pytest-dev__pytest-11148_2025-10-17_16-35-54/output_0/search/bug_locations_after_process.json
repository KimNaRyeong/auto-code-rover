[
    {
        "rel_file_path": "src/_pytest/pathlib.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/pathlib.py",
        "start": 1,
        "end": 787,
        "class_name": null,
        "method_name": null,
        "code": "1 import atexit\n2 import contextlib\n3 import fnmatch\n4 import importlib.util\n5 import itertools\n6 import os\n7 import shutil\n8 import sys\n9 import types\n10 import uuid\n11 import warnings\n12 from enum import Enum\n13 from errno import EBADF\n14 from errno import ELOOP\n15 from errno import ENOENT\n16 from errno import ENOTDIR\n17 from functools import partial\n18 from os.path import expanduser\n19 from os.path import expandvars\n20 from os.path import isabs\n21 from os.path import sep\n22 from pathlib import Path\n23 from pathlib import PurePath\n24 from posixpath import sep as posix_sep\n25 from types import ModuleType\n26 from typing import Callable\n27 from typing import Dict\n28 from typing import Iterable\n29 from typing import Iterator\n30 from typing import List\n31 from typing import Optional\n32 from typing import Set\n33 from typing import Tuple\n34 from typing import Type\n35 from typing import TypeVar\n36 from typing import Union\n37 \n38 from _pytest.compat import assert_never\n39 from _pytest.outcomes import skip\n40 from _pytest.warning_types import PytestWarning\n41 \n42 LOCK_TIMEOUT = 60 * 60 * 24 * 3\n43 \n44 \n45 _AnyPurePath = TypeVar(\"_AnyPurePath\", bound=PurePath)\n46 \n47 # The following function, variables and comments were\n48 # copied from cpython 3.9 Lib/pathlib.py file.\n49 \n50 # EBADF - guard against macOS `stat` throwing EBADF\n51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)\n52 \n53 _IGNORED_WINERRORS = (\n54     21,  # ERROR_NOT_READY - drive exists but is not accessible\n55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself\n56 )\n57 \n58 \n59 def _ignore_error(exception):\n60     return (\n61         getattr(exception, \"errno\", None) in _IGNORED_ERRORS\n62         or getattr(exception, \"winerror\", None) in _IGNORED_WINERRORS\n63     )\n64 \n65 \n66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:\n67     return path.joinpath(\".lock\")\n68 \n69 \n70 def on_rm_rf_error(\n71     func,\n72     path: str,\n73     excinfo: Union[\n74         BaseException,\n75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],\n76     ],\n77     *,\n78     start_path: Path,\n79 ) -> bool:\n80     \"\"\"Handle known read-only errors during rmtree.\n81 \n82     The returned value is used only by our own tests.\n83     \"\"\"\n84     if isinstance(excinfo, BaseException):\n85         exc = excinfo\n86     else:\n87         exc = excinfo[1]\n88 \n89     # Another process removed the file in the middle of the \"rm_rf\" (xdist for example).\n90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018\n91     if isinstance(exc, FileNotFoundError):\n92         return False\n93 \n94     if not isinstance(exc, PermissionError):\n95         warnings.warn(\n96             PytestWarning(f\"(rm_rf) error removing {path}\\n{type(exc)}: {exc}\")\n97         )\n98         return False\n99 \n100     if func not in (os.rmdir, os.remove, os.unlink):\n101         if func not in (os.open,):\n102             warnings.warn(\n103                 PytestWarning(\n104                     \"(rm_rf) unknown function {} when removing {}:\\n{}: {}\".format(\n105                         func, path, type(exc), exc\n106                     )\n107                 )\n108             )\n109         return False\n110 \n111     # Chmod + retry.\n112     import stat\n113 \n114     def chmod_rw(p: str) -> None:\n115         mode = os.stat(p).st_mode\n116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)\n117 \n118     # For files, we need to recursively go upwards in the directories to\n119     # ensure they all are also writable.\n120     p = Path(path)\n121     if p.is_file():\n122         for parent in p.parents:\n123             chmod_rw(str(parent))\n124             # Stop when we reach the original path passed to rm_rf.\n125             if parent == start_path:\n126                 break\n127     chmod_rw(str(path))\n128 \n129     func(path)\n130     return True\n131 \n132 \n133 def ensure_extended_length_path(path: Path) -> Path:\n134     \"\"\"Get the extended-length version of a path (Windows).\n135 \n136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260\n137     characters, and operations on paths longer than that fail. But it is possible\n138     to overcome this by converting the path to \"extended-length\" form before\n139     performing the operation:\n140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation\n141 \n142     On Windows, this function returns the extended-length absolute version of path.\n143     On other platforms it returns path unchanged.\n144     \"\"\"\n145     if sys.platform.startswith(\"win32\"):\n146         path = path.resolve()\n147         path = Path(get_extended_length_path_str(str(path)))\n148     return path\n149 \n150 \n151 def get_extended_length_path_str(path: str) -> str:\n152     \"\"\"Convert a path to a Windows extended length path.\"\"\"\n153     long_path_prefix = \"\\\\\\\\?\\\\\"\n154     unc_long_path_prefix = \"\\\\\\\\?\\\\UNC\\\\\"\n155     if path.startswith((long_path_prefix, unc_long_path_prefix)):\n156         return path\n157     # UNC\n158     if path.startswith(\"\\\\\\\\\"):\n159         return unc_long_path_prefix + path[2:]\n160     return long_path_prefix + path\n161 \n162 \n163 def rm_rf(path: Path) -> None:\n164     \"\"\"Remove the path contents recursively, even if some elements\n165     are read-only.\"\"\"\n166     path = ensure_extended_length_path(path)\n167     onerror = partial(on_rm_rf_error, start_path=path)\n168     if sys.version_info >= (3, 12):\n169         shutil.rmtree(str(path), onexc=onerror)\n170     else:\n171         shutil.rmtree(str(path), onerror=onerror)\n172 \n173 \n174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\n175     \"\"\"Find all elements in root that begin with the prefix, case insensitive.\"\"\"\n176     l_prefix = prefix.lower()\n177     for x in root.iterdir():\n178         if x.name.lower().startswith(l_prefix):\n179             yield x\n180 \n181 \n182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\n183     \"\"\"Return the parts of the paths following the prefix.\n184 \n185     :param iter: Iterator over path names.\n186     :param prefix: Expected prefix of the path names.\n187     \"\"\"\n188     p_len = len(prefix)\n189     for p in iter:\n190         yield p.name[p_len:]\n191 \n192 \n193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:\n194     \"\"\"Combine find_prefixes and extract_suffixes.\"\"\"\n195     return extract_suffixes(find_prefixed(root, prefix), prefix)\n196 \n197 \n198 def parse_num(maybe_num) -> int:\n199     \"\"\"Parse number path suffixes, returns -1 on error.\"\"\"\n200     try:\n201         return int(maybe_num)\n202     except ValueError:\n203         return -1\n204 \n205 \n206 def _force_symlink(\n207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]\n208 ) -> None:\n209     \"\"\"Helper to create the current symlink.\n210 \n211     It's full of race conditions that are reasonably OK to ignore\n212     for the context of best effort linking to the latest test run.\n213 \n214     The presumption being that in case of much parallelism\n215     the inaccuracy is going to be acceptable.\n216     \"\"\"\n217     current_symlink = root.joinpath(target)\n218     try:\n219         current_symlink.unlink()\n220     except OSError:\n221         pass\n222     try:\n223         current_symlink.symlink_to(link_to)\n224     except Exception:\n225         pass\n226 \n227 \n228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:\n229     \"\"\"Create a directory with an increased number as suffix for the given prefix.\"\"\"\n230     for i in range(10):\n231         # try up to 10 times to create the folder\n232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n233         new_number = max_existing + 1\n234         new_path = root.joinpath(f\"{prefix}{new_number}\")\n235         try:\n236             new_path.mkdir(mode=mode)\n237         except Exception:\n238             pass\n239         else:\n240             _force_symlink(root, prefix + \"current\", new_path)\n241             return new_path\n242     else:\n243         raise OSError(\n244             \"could not create numbered dir with prefix \"\n245             \"{prefix} in {root} after 10 tries\".format(prefix=prefix, root=root)\n246         )\n247 \n248 \n249 def create_cleanup_lock(p: Path) -> Path:\n250     \"\"\"Create a lock to prevent premature folder cleanup.\"\"\"\n251     lock_path = get_lock_path(p)\n252     try:\n253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)\n254     except FileExistsError as e:\n255         raise OSError(f\"cannot create lockfile in {p}\") from e\n256     else:\n257         pid = os.getpid()\n258         spid = str(pid).encode()\n259         os.write(fd, spid)\n260         os.close(fd)\n261         if not lock_path.is_file():\n262             raise OSError(\"lock path got renamed after successful creation\")\n263         return lock_path\n264 \n265 \n266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):\n267     \"\"\"Register a cleanup function for removing a lock, by default on atexit.\"\"\"\n268     pid = os.getpid()\n269 \n270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:\n271         current_pid = os.getpid()\n272         if current_pid != original_pid:\n273             # fork\n274             return\n275         try:\n276             lock_path.unlink()\n277         except OSError:\n278             pass\n279 \n280     return register(cleanup_on_exit)\n281 \n282 \n283 def maybe_delete_a_numbered_dir(path: Path) -> None:\n284     \"\"\"Remove a numbered directory if its lock can be obtained and it does\n285     not seem to be in use.\"\"\"\n286     path = ensure_extended_length_path(path)\n287     lock_path = None\n288     try:\n289         lock_path = create_cleanup_lock(path)\n290         parent = path.parent\n291 \n292         garbage = parent.joinpath(f\"garbage-{uuid.uuid4()}\")\n293         path.rename(garbage)\n294         rm_rf(garbage)\n295     except OSError:\n296         #  known races:\n297         #  * other process did a cleanup at the same time\n298         #  * deletable folder was found\n299         #  * process cwd (Windows)\n300         return\n301     finally:\n302         # If we created the lock, ensure we remove it even if we failed\n303         # to properly remove the numbered dir.\n304         if lock_path is not None:\n305             try:\n306                 lock_path.unlink()\n307             except OSError:\n308                 pass\n309 \n310 \n311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:\n312     \"\"\"Check if `path` is deletable based on whether the lock file is expired.\"\"\"\n313     if path.is_symlink():\n314         return False\n315     lock = get_lock_path(path)\n316     try:\n317         if not lock.is_file():\n318             return True\n319     except OSError:\n320         # we might not have access to the lock file at all, in this case assume\n321         # we don't have access to the entire directory (#7491).\n322         return False\n323     try:\n324         lock_time = lock.stat().st_mtime\n325     except Exception:\n326         return False\n327     else:\n328         if lock_time < consider_lock_dead_if_created_before:\n329             # We want to ignore any errors while trying to remove the lock such as:\n330             # - PermissionDenied, like the file permissions have changed since the lock creation;\n331             # - FileNotFoundError, in case another pytest process got here first;\n332             # and any other cause of failure.\n333             with contextlib.suppress(OSError):\n334                 lock.unlink()\n335                 return True\n336         return False\n337 \n338 \n339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:\n340     \"\"\"Try to cleanup a folder if we can ensure it's deletable.\"\"\"\n341     if ensure_deletable(path, consider_lock_dead_if_created_before):\n342         maybe_delete_a_numbered_dir(path)\n343 \n344 \n345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\n346     \"\"\"List candidates for numbered directories to be removed - follows py.path.\"\"\"\n347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n348     max_delete = max_existing - keep\n349     paths = find_prefixed(root, prefix)\n350     paths, paths2 = itertools.tee(paths)\n351     numbers = map(parse_num, extract_suffixes(paths2, prefix))\n352     for path, number in zip(paths, numbers):\n353         if number <= max_delete:\n354             yield path\n355 \n356 \n357 def cleanup_dead_symlinks(root: Path):\n358     for left_dir in root.iterdir():\n359         if left_dir.is_symlink():\n360             if not left_dir.resolve().exists():\n361                 left_dir.unlink()\n362 \n363 \n364 def cleanup_numbered_dir(\n365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float\n366 ) -> None:\n367     \"\"\"Cleanup for lock driven numbered directories.\"\"\"\n368     if not root.exists():\n369         return\n370     for path in cleanup_candidates(root, prefix, keep):\n371         try_cleanup(path, consider_lock_dead_if_created_before)\n372     for path in root.glob(\"garbage-*\"):\n373         try_cleanup(path, consider_lock_dead_if_created_before)\n374 \n375     cleanup_dead_symlinks(root)\n376 \n377 \n378 def make_numbered_dir_with_cleanup(\n379     root: Path,\n380     prefix: str,\n381     keep: int,\n382     lock_timeout: float,\n383     mode: int,\n384 ) -> Path:\n385     \"\"\"Create a numbered dir with a cleanup lock and remove old ones.\"\"\"\n386     e = None\n387     for i in range(10):\n388         try:\n389             p = make_numbered_dir(root, prefix, mode)\n390             # Only lock the current dir when keep is not 0\n391             if keep != 0:\n392                 lock_path = create_cleanup_lock(p)\n393                 register_cleanup_lock_removal(lock_path)\n394         except Exception as exc:\n395             e = exc\n396         else:\n397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout\n398             # Register a cleanup for program exit\n399             atexit.register(\n400                 cleanup_numbered_dir,\n401                 root,\n402                 prefix,\n403                 keep,\n404                 consider_lock_dead_if_created_before,\n405             )\n406             return p\n407     assert e is not None\n408     raise e\n409 \n410 \n411 def resolve_from_str(input: str, rootpath: Path) -> Path:\n412     input = expanduser(input)\n413     input = expandvars(input)\n414     if isabs(input):\n415         return Path(input)\n416     else:\n417         return rootpath.joinpath(input)\n418 \n419 \n420 def fnmatch_ex(pattern: str, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n421     \"\"\"A port of FNMatcher from py.path.common which works with PurePath() instances.\n422 \n423     The difference between this algorithm and PurePath.match() is that the\n424     latter matches \"**\" glob expressions for each part of the path, while\n425     this algorithm uses the whole path instead.\n426 \n427     For example:\n428         \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\"\n429         with this algorithm, but not with PurePath.match().\n430 \n431     This algorithm was ported to keep backward-compatibility with existing\n432     settings which assume paths match according this logic.\n433 \n434     References:\n435     * https://bugs.python.org/issue29249\n436     * https://bugs.python.org/issue34731\n437     \"\"\"\n438     path = PurePath(path)\n439     iswin32 = sys.platform.startswith(\"win\")\n440 \n441     if iswin32 and sep not in pattern and posix_sep in pattern:\n442         # Running on Windows, the pattern has no Windows path separators,\n443         # and the pattern has one or more Posix path separators. Replace\n444         # the Posix path separators with the Windows path separator.\n445         pattern = pattern.replace(posix_sep, sep)\n446 \n447     if sep not in pattern:\n448         name = path.name\n449     else:\n450         name = str(path)\n451         if path.is_absolute() and not os.path.isabs(pattern):\n452             pattern = f\"*{os.sep}{pattern}\"\n453     return fnmatch.fnmatch(name, pattern)\n454 \n455 \n456 def parts(s: str) -> Set[str]:\n457     parts = s.split(sep)\n458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}\n459 \n460 \n461 def symlink_or_skip(src, dst, **kwargs):\n462     \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n463     try:\n464         os.symlink(str(src), str(dst), **kwargs)\n465     except OSError as e:\n466         skip(f\"symlinks not supported: {e}\")\n467 \n468 \n469 class ImportMode(Enum):\n470     \"\"\"Possible values for `mode` parameter of `import_path`.\"\"\"\n471 \n472     prepend = \"prepend\"\n473     append = \"append\"\n474     importlib = \"importlib\"\n475 \n476 \n477 class ImportPathMismatchError(ImportError):\n478     \"\"\"Raised on import_path() if there is a mismatch of __file__'s.\n479 \n480     This can happen when `import_path` is called multiple times with different filenames that has\n481     the same basename but reside in packages\n482     (for example \"/tests1/test_foo.py\" and \"/tests2/test_foo.py\").\n483     \"\"\"\n484 \n485 \n486 def import_path(\n487     p: Union[str, \"os.PathLike[str]\"],\n488     *,\n489     mode: Union[str, ImportMode] = ImportMode.prepend,\n490     root: Path,\n491 ) -> ModuleType:\n492     \"\"\"Import and return a module from the given path, which can be a file (a module) or\n493     a directory (a package).\n494 \n495     The import mechanism used is controlled by the `mode` parameter:\n496 \n497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking\n498       `__init__.py` files into account) will be put at the *start* of `sys.path` before\n499       being imported with `importlib.import_module`.\n500 \n501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended\n502       to the end of `sys.path`, if not already in `sys.path`.\n503 \n504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`\n505       to import the module, which avoids having to muck with `sys.path` at all. It effectively\n506       allows having same-named test modules in different places.\n507 \n508     :param root:\n509         Used as an anchor when mode == ImportMode.importlib to obtain\n510         a unique name for the module being imported so it can safely be stored\n511         into ``sys.modules``.\n512 \n513     :raises ImportPathMismatchError:\n514         If after importing the given `path` and the module `__file__`\n515         are different. Only raised in `prepend` and `append` modes.\n516     \"\"\"\n517     mode = ImportMode(mode)\n518 \n519     path = Path(p)\n520 \n521     if not path.exists():\n522         raise ImportError(path)\n523 \n524     if mode is ImportMode.importlib:\n525         module_name = module_name_from_path(path, root)\n526 \n527         for meta_importer in sys.meta_path:\n528             spec = meta_importer.find_spec(module_name, [str(path.parent)])\n529             if spec is not None:\n530                 break\n531         else:\n532             spec = importlib.util.spec_from_file_location(module_name, str(path))\n533 \n534         if spec is None:\n535             raise ImportError(f\"Can't find module {module_name} at location {path}\")\n536         mod = importlib.util.module_from_spec(spec)\n537         sys.modules[module_name] = mod\n538         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n539         insert_missing_modules(sys.modules, module_name)\n540         return mod\n541 \n542     pkg_path = resolve_package_path(path)\n543     if pkg_path is not None:\n544         pkg_root = pkg_path.parent\n545         names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n546         if names[-1] == \"__init__\":\n547             names.pop()\n548         module_name = \".\".join(names)\n549     else:\n550         pkg_root = path.parent\n551         module_name = path.stem\n552 \n553     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n554     # problems because of delayed imports: for example, a conftest.py file imported by this function\n555     # might have local imports, which would fail at runtime if we restored sys.path.\n556     if mode is ImportMode.append:\n557         if str(pkg_root) not in sys.path:\n558             sys.path.append(str(pkg_root))\n559     elif mode is ImportMode.prepend:\n560         if str(pkg_root) != sys.path[0]:\n561             sys.path.insert(0, str(pkg_root))\n562     else:\n563         assert_never(mode)\n564 \n565     importlib.import_module(module_name)\n566 \n567     mod = sys.modules[module_name]\n568     if path.name == \"__init__.py\":\n569         return mod\n570 \n571     ignore = os.environ.get(\"PY_IGNORE_IMPORTMISMATCH\", \"\")\n572     if ignore != \"1\":\n573         module_file = mod.__file__\n574         if module_file is None:\n575             raise ImportPathMismatchError(module_name, module_file, path)\n576 \n577         if module_file.endswith((\".pyc\", \".pyo\")):\n578             module_file = module_file[:-1]\n579         if module_file.endswith(os.sep + \"__init__.py\"):\n580             module_file = module_file[: -(len(os.sep + \"__init__.py\"))]\n581 \n582         try:\n583             is_same = _is_same(str(path), module_file)\n584         except FileNotFoundError:\n585             is_same = False\n586 \n587         if not is_same:\n588             raise ImportPathMismatchError(module_name, module_file, path)\n589 \n590     return mod\n591 \n592 \n593 # Implement a special _is_same function on Windows which returns True if the two filenames\n594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).\n595 if sys.platform.startswith(\"win\"):\n596 \n597     def _is_same(f1: str, f2: str) -> bool:\n598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)\n599 \n600 else:\n601 \n602     def _is_same(f1: str, f2: str) -> bool:\n603         return os.path.samefile(f1, f2)\n604 \n605 \n606 def module_name_from_path(path: Path, root: Path) -> str:\n607     \"\"\"\n608     Return a dotted module name based on the given path, anchored on root.\n609 \n610     For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n611     resulting module name will be \"src.tests.test_foo\".\n612     \"\"\"\n613     path = path.with_suffix(\"\")\n614     try:\n615         relative_path = path.relative_to(root)\n616     except ValueError:\n617         # If we can't get a relative path to root, use the full path, except\n618         # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n619         path_parts = path.parts[1:]\n620     else:\n621         # Use the parts for the relative path to the root path.\n622         path_parts = relative_path.parts\n623 \n624     return \".\".join(path_parts)\n625 \n626 \n627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n628     \"\"\"\n629     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n630 \n631     When we want to import a module as \"src.tests.test_foo\" for example, we need\n632     to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n633     otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n634     \"\"\"\n635     module_parts = module_name.split(\".\")\n636     child_module: Union[ModuleType, None] = None\n637     module: Union[ModuleType, None] = None\n638     child_name: str = \"\"\n639     while module_name:\n640         if module_name not in modules:\n641             try:\n642                 # If sys.meta_path is empty, calling import_module will issue\n643                 # a warning and raise ModuleNotFoundError. To avoid the\n644                 # warning, we check sys.meta_path explicitly and raise the error\n645                 # ourselves to fall back to creating a dummy module.\n646                 if not sys.meta_path:\n647                     raise ModuleNotFoundError\n648                 module = importlib.import_module(module_name)\n649             except ModuleNotFoundError:\n650                 module = ModuleType(\n651                     module_name,\n652                     doc=\"Empty module created by pytest's importmode=importlib.\",\n653                 )\n654         else:\n655             module = modules[module_name]\n656         if child_module:\n657             # Add child attribute to the parent that can reference the child\n658             # modules.\n659             if not hasattr(module, child_name):\n660                 setattr(module, child_name, child_module)\n661                 modules[module_name] = module\n662         # Keep track of the child module while moving up the tree.\n663         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n664         module_parts.pop(-1)\n665         module_name = \".\".join(module_parts)\n666 \n667 \n668 def resolve_package_path(path: Path) -> Optional[Path]:\n669     \"\"\"Return the Python package path by looking for the last\n670     directory upwards which still contains an __init__.py.\n671 \n672     Returns None if it can not be determined.\n673     \"\"\"\n674     result = None\n675     for parent in itertools.chain((path,), path.parents):\n676         if parent.is_dir():\n677             if not parent.joinpath(\"__init__.py\").is_file():\n678                 break\n679             if not parent.name.isidentifier():\n680                 break\n681             result = parent\n682     return result\n683 \n684 \n685 def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n686     \"\"\"Scan a directory recursively, in breadth-first order.\n687 \n688     The returned entries are sorted.\n689     \"\"\"\n690     entries = []\n691     with os.scandir(path) as s:\n692         # Skip entries with symlink loops and other brokenness, so the caller\n693         # doesn't have to deal with it.\n694         for entry in s:\n695             try:\n696                 entry.is_file()\n697             except OSError as err:\n698                 if _ignore_error(err):\n699                     continue\n700                 raise\n701             entries.append(entry)\n702     entries.sort(key=lambda entry: entry.name)\n703     return entries\n704 \n705 \n706 def visit(\n707     path: Union[str, \"os.PathLike[str]\"], recurse: Callable[[\"os.DirEntry[str]\"], bool]\n708 ) -> Iterator[\"os.DirEntry[str]\"]:\n709     \"\"\"Walk a directory recursively, in breadth-first order.\n710 \n711     The `recurse` predicate determines whether a directory is recursed.\n712 \n713     Entries at each directory level are sorted.\n714     \"\"\"\n715     entries = scandir(path)\n716     yield from entries\n717     for entry in entries:\n718         if entry.is_dir() and recurse(entry):\n719             yield from visit(entry.path, recurse)\n720 \n721 \n722 def absolutepath(path: Union[Path, str]) -> Path:\n723     \"\"\"Convert a path to an absolute path using os.path.abspath.\n724 \n725     Prefer this over Path.resolve() (see #6523).\n726     Prefer this over Path.absolute() (not public, doesn't normalize).\n727     \"\"\"\n728     return Path(os.path.abspath(str(path)))\n729 \n730 \n731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:\n732     \"\"\"Return the common part shared with the other path, or None if there is\n733     no common part.\n734 \n735     If one path is relative and one is absolute, returns None.\n736     \"\"\"\n737     try:\n738         return Path(os.path.commonpath((str(path1), str(path2))))\n739     except ValueError:\n740         return None\n741 \n742 \n743 def bestrelpath(directory: Path, dest: Path) -> str:\n744     \"\"\"Return a string which is a relative path from directory to dest such\n745     that directory/bestrelpath == dest.\n746 \n747     The paths must be either both absolute or both relative.\n748 \n749     If no such path can be determined, returns dest.\n750     \"\"\"\n751     assert isinstance(directory, Path)\n752     assert isinstance(dest, Path)\n753     if dest == directory:\n754         return os.curdir\n755     # Find the longest common directory.\n756     base = commonpath(directory, dest)\n757     # Can be the case on Windows for two absolute paths on different drives.\n758     # Can be the case for two relative paths without common prefix.\n759     # Can be the case for a relative path and an absolute path.\n760     if not base:\n761         return str(dest)\n762     reldirectory = directory.relative_to(base)\n763     reldest = dest.relative_to(base)\n764     return os.path.join(\n765         # Back from directory to base.\n766         *([os.pardir] * len(reldirectory.parts)),\n767         # Forward from base to dest.\n768         *reldest.parts,\n769     )\n770 \n771 \n772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.\n773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)\n774 def copytree(source: Path, target: Path) -> None:\n775     \"\"\"Recursively copy a source directory to target.\"\"\"\n776     assert source.is_dir()\n777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):\n778         x = Path(entry)\n779         relpath = x.relative_to(source)\n780         newx = target / relpath\n781         newx.parent.mkdir(exist_ok=True)\n782         if x.is_symlink():\n783             newx.symlink_to(os.readlink(x))\n784         elif x.is_file():\n785             shutil.copyfile(x, newx)\n786         elif x.is_dir():\n787             newx.mkdir(exist_ok=True)\n",
        "intended_behavior": "Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module."
    },
    {
        "rel_file_path": "src/_pytest/assertion/rewrite.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/assertion/rewrite.py",
        "start": 1,
        "end": 1171,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Rewrite assertion AST to produce nice error messages.\"\"\"\n2 import ast\n3 import errno\n4 import functools\n5 import importlib.abc\n6 import importlib.machinery\n7 import importlib.util\n8 import io\n9 import itertools\n10 import marshal\n11 import os\n12 import struct\n13 import sys\n14 import tokenize\n15 import types\n16 from pathlib import Path\n17 from pathlib import PurePath\n18 from typing import Callable\n19 from typing import Dict\n20 from typing import IO\n21 from typing import Iterable\n22 from typing import Iterator\n23 from typing import List\n24 from typing import Optional\n25 from typing import Sequence\n26 from typing import Set\n27 from typing import Tuple\n28 from typing import TYPE_CHECKING\n29 from typing import Union\n30 \n31 from _pytest._io.saferepr import DEFAULT_REPR_MAX_SIZE\n32 from _pytest._io.saferepr import saferepr\n33 from _pytest._version import version\n34 from _pytest.assertion import util\n35 from _pytest.assertion.util import (  # noqa: F401\n36     format_explanation as _format_explanation,\n37 )\n38 from _pytest.config import Config\n39 from _pytest.main import Session\n40 from _pytest.pathlib import absolutepath\n41 from _pytest.pathlib import fnmatch_ex\n42 from _pytest.stash import StashKey\n43 \n44 if TYPE_CHECKING:\n45     from _pytest.assertion import AssertionState\n46 \n47 \n48 assertstate_key = StashKey[\"AssertionState\"]()\n49 \n50 # pytest caches rewritten pycs in pycache dirs\n51 PYTEST_TAG = f\"{sys.implementation.cache_tag}-pytest-{version}\"\n52 PYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\n53 PYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\n54 \n55 \n56 class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n57     \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n58 \n59     def __init__(self, config: Config) -> None:\n60         self.config = config\n61         try:\n62             self.fnpats = config.getini(\"python_files\")\n63         except ValueError:\n64             self.fnpats = [\"test_*.py\", \"*_test.py\"]\n65         self.session: Optional[Session] = None\n66         self._rewritten_names: Dict[str, Path] = {}\n67         self._must_rewrite: Set[str] = set()\n68         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n69         # which might result in infinite recursion (#3506)\n70         self._writing_pyc = False\n71         self._basenames_to_check_rewrite = {\"conftest\"}\n72         self._marked_for_rewrite_cache: Dict[str, bool] = {}\n73         self._session_paths_checked = False\n74 \n75     def set_session(self, session: Optional[Session]) -> None:\n76         self.session = session\n77         self._session_paths_checked = False\n78 \n79     # Indirection so we can mock calls to find_spec originated from the hook during testing\n80     _find_spec = importlib.machinery.PathFinder.find_spec\n81 \n82     def find_spec(\n83         self,\n84         name: str,\n85         path: Optional[Sequence[Union[str, bytes]]] = None,\n86         target: Optional[types.ModuleType] = None,\n87     ) -> Optional[importlib.machinery.ModuleSpec]:\n88         if self._writing_pyc:\n89             return None\n90         state = self.config.stash[assertstate_key]\n91         if self._early_rewrite_bailout(name, state):\n92             return None\n93         state.trace(\"find_module called for: %s\" % name)\n94 \n95         # Type ignored because mypy is confused about the `self` binding here.\n96         spec = self._find_spec(name, path)  # type: ignore\n97         if (\n98             # the import machinery could not find a file to import\n99             spec is None\n100             # this is a namespace package (without `__init__.py`)\n101             # there's nothing to rewrite there\n102             or spec.origin is None\n103             # we can only rewrite source files\n104             or not isinstance(spec.loader, importlib.machinery.SourceFileLoader)\n105             # if the file doesn't exist, we can't rewrite it\n106             or not os.path.exists(spec.origin)\n107         ):\n108             return None\n109         else:\n110             fn = spec.origin\n111 \n112         if not self._should_rewrite(name, fn, state):\n113             return None\n114 \n115         return importlib.util.spec_from_file_location(\n116             name,\n117             fn,\n118             loader=self,\n119             submodule_search_locations=spec.submodule_search_locations,\n120         )\n121 \n122     def create_module(\n123         self, spec: importlib.machinery.ModuleSpec\n124     ) -> Optional[types.ModuleType]:\n125         return None  # default behaviour is fine\n126 \n127     def exec_module(self, module: types.ModuleType) -> None:\n128         assert module.__spec__ is not None\n129         assert module.__spec__.origin is not None\n130         fn = Path(module.__spec__.origin)\n131         state = self.config.stash[assertstate_key]\n132 \n133         self._rewritten_names[module.__name__] = fn\n134 \n135         # The requested module looks like a test file, so rewrite it. This is\n136         # the most magical part of the process: load the source, rewrite the\n137         # asserts, and load the rewritten source. We also cache the rewritten\n138         # module code in a special pyc. We must be aware of the possibility of\n139         # concurrent pytest processes rewriting and loading pycs. To avoid\n140         # tricky race conditions, we maintain the following invariant: The\n141         # cached pyc is always a complete, valid pyc. Operations on it must be\n142         # atomic. POSIX's atomic rename comes in handy.\n143         write = not sys.dont_write_bytecode\n144         cache_dir = get_cache_dir(fn)\n145         if write:\n146             ok = try_makedirs(cache_dir)\n147             if not ok:\n148                 write = False\n149                 state.trace(f\"read only directory: {cache_dir}\")\n150 \n151         cache_name = fn.name[:-3] + PYC_TAIL\n152         pyc = cache_dir / cache_name\n153         # Notice that even if we're in a read-only directory, I'm going\n154         # to check for a cached pyc. This may not be optimal...\n155         co = _read_pyc(fn, pyc, state.trace)\n156         if co is None:\n157             state.trace(f\"rewriting {fn!r}\")\n158             source_stat, co = _rewrite_test(fn, self.config)\n159             if write:\n160                 self._writing_pyc = True\n161                 try:\n162                     _write_pyc(state, co, source_stat, pyc)\n163                 finally:\n164                     self._writing_pyc = False\n165         else:\n166             state.trace(f\"found cached rewritten pyc for {fn}\")\n167         exec(co, module.__dict__)\n168 \n169     def _early_rewrite_bailout(self, name: str, state: \"AssertionState\") -> bool:\n170         \"\"\"A fast way to get out of rewriting modules.\n171 \n172         Profiling has shown that the call to PathFinder.find_spec (inside of\n173         the find_spec from this class) is a major slowdown, so, this method\n174         tries to filter what we're sure won't be rewritten before getting to\n175         it.\n176         \"\"\"\n177         if self.session is not None and not self._session_paths_checked:\n178             self._session_paths_checked = True\n179             for initial_path in self.session._initialpaths:\n180                 # Make something as c:/projects/my_project/path.py ->\n181                 #     ['c:', 'projects', 'my_project', 'path.py']\n182                 parts = str(initial_path).split(os.sep)\n183                 # add 'path' to basenames to be checked.\n184                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])\n185 \n186         # Note: conftest already by default in _basenames_to_check_rewrite.\n187         parts = name.split(\".\")\n188         if parts[-1] in self._basenames_to_check_rewrite:\n189             return False\n190 \n191         # For matching the name it must be as if it was a filename.\n192         path = PurePath(*parts).with_suffix(\".py\")\n193 \n194         for pat in self.fnpats:\n195             # if the pattern contains subdirectories (\"tests/**.py\" for example) we can't bail out based\n196             # on the name alone because we need to match against the full path\n197             if os.path.dirname(pat):\n198                 return False\n199             if fnmatch_ex(pat, path):\n200                 return False\n201 \n202         if self._is_marked_for_rewrite(name, state):\n203             return False\n204 \n205         state.trace(f\"early skip of rewriting module: {name}\")\n206         return True\n207 \n208     def _should_rewrite(self, name: str, fn: str, state: \"AssertionState\") -> bool:\n209         # always rewrite conftest files\n210         if os.path.basename(fn) == \"conftest.py\":\n211             state.trace(f\"rewriting conftest file: {fn!r}\")\n212             return True\n213 \n214         if self.session is not None:\n215             if self.session.isinitpath(absolutepath(fn)):\n216                 state.trace(f\"matched test file (was specified on cmdline): {fn!r}\")\n217                 return True\n218 \n219         # modules not passed explicitly on the command line are only\n220         # rewritten if they match the naming convention for test files\n221         fn_path = PurePath(fn)\n222         for pat in self.fnpats:\n223             if fnmatch_ex(pat, fn_path):\n224                 state.trace(f\"matched test file {fn!r}\")\n225                 return True\n226 \n227         return self._is_marked_for_rewrite(name, state)\n228 \n229     def _is_marked_for_rewrite(self, name: str, state: \"AssertionState\") -> bool:\n230         try:\n231             return self._marked_for_rewrite_cache[name]\n232         except KeyError:\n233             for marked in self._must_rewrite:\n234                 if name == marked or name.startswith(marked + \".\"):\n235                     state.trace(f\"matched marked file {name!r} (from {marked!r})\")\n236                     self._marked_for_rewrite_cache[name] = True\n237                     return True\n238 \n239             self._marked_for_rewrite_cache[name] = False\n240             return False\n241 \n242     def mark_rewrite(self, *names: str) -> None:\n243         \"\"\"Mark import names as needing to be rewritten.\n244 \n245         The named module or package as well as any nested modules will\n246         be rewritten on import.\n247         \"\"\"\n248         already_imported = (\n249             set(names).intersection(sys.modules).difference(self._rewritten_names)\n250         )\n251         for name in already_imported:\n252             mod = sys.modules[name]\n253             if not AssertionRewriter.is_rewrite_disabled(\n254                 mod.__doc__ or \"\"\n255             ) and not isinstance(mod.__loader__, type(self)):\n256                 self._warn_already_imported(name)\n257         self._must_rewrite.update(names)\n258         self._marked_for_rewrite_cache.clear()\n259 \n260     def _warn_already_imported(self, name: str) -> None:\n261         from _pytest.warning_types import PytestAssertRewriteWarning\n262 \n263         self.config.issue_config_time_warning(\n264             PytestAssertRewriteWarning(\n265                 \"Module already imported so cannot be rewritten: %s\" % name\n266             ),\n267             stacklevel=5,\n268         )\n269 \n270     def get_data(self, pathname: Union[str, bytes]) -> bytes:\n271         \"\"\"Optional PEP302 get_data API.\"\"\"\n272         with open(pathname, \"rb\") as f:\n273             return f.read()\n274 \n275     if sys.version_info >= (3, 10):\n276         if sys.version_info >= (3, 12):\n277             from importlib.resources.abc import TraversableResources\n278         else:\n279             from importlib.abc import TraversableResources\n280 \n281         def get_resource_reader(self, name: str) -> TraversableResources:  # type: ignore\n282             if sys.version_info < (3, 11):\n283                 from importlib.readers import FileReader\n284             else:\n285                 from importlib.resources.readers import FileReader\n286 \n287             return FileReader(  # type:ignore[no-any-return]\n288                 types.SimpleNamespace(path=self._rewritten_names[name])\n289             )\n290 \n291 \n292 def _write_pyc_fp(\n293     fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType\n294 ) -> None:\n295     # Technically, we don't have to have the same pyc format as\n296     # (C)Python, since these \"pycs\" should never be seen by builtin\n297     # import. However, there's little reason to deviate.\n298     fp.write(importlib.util.MAGIC_NUMBER)\n299     # https://www.python.org/dev/peps/pep-0552/\n300     flags = b\"\\x00\\x00\\x00\\x00\"\n301     fp.write(flags)\n302     # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)\n303     mtime = int(source_stat.st_mtime) & 0xFFFFFFFF\n304     size = source_stat.st_size & 0xFFFFFFFF\n305     # \"<LL\" stands for 2 unsigned longs, little-endian.\n306     fp.write(struct.pack(\"<LL\", mtime, size))\n307     fp.write(marshal.dumps(co))\n308 \n309 \n310 def _write_pyc(\n311     state: \"AssertionState\",\n312     co: types.CodeType,\n313     source_stat: os.stat_result,\n314     pyc: Path,\n315 ) -> bool:\n316     proc_pyc = f\"{pyc}.{os.getpid()}\"\n317     try:\n318         with open(proc_pyc, \"wb\") as fp:\n319             _write_pyc_fp(fp, source_stat, co)\n320     except OSError as e:\n321         state.trace(f\"error writing pyc file at {proc_pyc}: errno={e.errno}\")\n322         return False\n323 \n324     try:\n325         os.replace(proc_pyc, pyc)\n326     except OSError as e:\n327         state.trace(f\"error writing pyc file at {pyc}: {e}\")\n328         # we ignore any failure to write the cache file\n329         # there are many reasons, permission-denied, pycache dir being a\n330         # file etc.\n331         return False\n332     return True\n333 \n334 \n335 def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeType]:\n336     \"\"\"Read and rewrite *fn* and return the code object.\"\"\"\n337     stat = os.stat(fn)\n338     source = fn.read_bytes()\n339     strfn = str(fn)\n340     tree = ast.parse(source, filename=strfn)\n341     rewrite_asserts(tree, source, strfn, config)\n342     co = compile(tree, strfn, \"exec\", dont_inherit=True)\n343     return stat, co\n344 \n345 \n346 def _read_pyc(\n347     source: Path, pyc: Path, trace: Callable[[str], None] = lambda x: None\n348 ) -> Optional[types.CodeType]:\n349     \"\"\"Possibly read a pytest pyc containing rewritten code.\n350 \n351     Return rewritten code if successful or None if not.\n352     \"\"\"\n353     try:\n354         fp = open(pyc, \"rb\")\n355     except OSError:\n356         return None\n357     with fp:\n358         try:\n359             stat_result = os.stat(source)\n360             mtime = int(stat_result.st_mtime)\n361             size = stat_result.st_size\n362             data = fp.read(16)\n363         except OSError as e:\n364             trace(f\"_read_pyc({source}): OSError {e}\")\n365             return None\n366         # Check for invalid or out of date pyc file.\n367         if len(data) != (16):\n368             trace(\"_read_pyc(%s): invalid pyc (too short)\" % source)\n369             return None\n370         if data[:4] != importlib.util.MAGIC_NUMBER:\n371             trace(\"_read_pyc(%s): invalid pyc (bad magic number)\" % source)\n372             return None\n373         if data[4:8] != b\"\\x00\\x00\\x00\\x00\":\n374             trace(\"_read_pyc(%s): invalid pyc (unsupported flags)\" % source)\n375             return None\n376         mtime_data = data[8:12]\n377         if int.from_bytes(mtime_data, \"little\") != mtime & 0xFFFFFFFF:\n378             trace(\"_read_pyc(%s): out of date\" % source)\n379             return None\n380         size_data = data[12:16]\n381         if int.from_bytes(size_data, \"little\") != size & 0xFFFFFFFF:\n382             trace(\"_read_pyc(%s): invalid pyc (incorrect size)\" % source)\n383             return None\n384         try:\n385             co = marshal.load(fp)\n386         except Exception as e:\n387             trace(f\"_read_pyc({source}): marshal.load error {e}\")\n388             return None\n389         if not isinstance(co, types.CodeType):\n390             trace(\"_read_pyc(%s): not a code object\" % source)\n391             return None\n392         return co\n393 \n394 \n395 def rewrite_asserts(\n396     mod: ast.Module,\n397     source: bytes,\n398     module_path: Optional[str] = None,\n399     config: Optional[Config] = None,\n400 ) -> None:\n401     \"\"\"Rewrite the assert statements in mod.\"\"\"\n402     AssertionRewriter(module_path, config, source).run(mod)\n403 \n404 \n405 def _saferepr(obj: object) -> str:\n406     r\"\"\"Get a safe repr of an object for assertion error messages.\n407 \n408     The assertion formatting (util.format_explanation()) requires\n409     newlines to be escaped since they are a special character for it.\n410     Normally assertion.util.format_explanation() does this but for a\n411     custom repr it is possible to contain one of the special escape\n412     sequences, especially '\\n{' and '\\n}' are likely to be present in\n413     JSON reprs.\n414     \"\"\"\n415     maxsize = _get_maxsize_for_saferepr(util._config)\n416     return saferepr(obj, maxsize=maxsize).replace(\"\\n\", \"\\\\n\")\n417 \n418 \n419 def _get_maxsize_for_saferepr(config: Optional[Config]) -> Optional[int]:\n420     \"\"\"Get `maxsize` configuration for saferepr based on the given config object.\"\"\"\n421     verbosity = config.getoption(\"verbose\") if config is not None else 0\n422     if verbosity >= 2:\n423         return None\n424     if verbosity >= 1:\n425         return DEFAULT_REPR_MAX_SIZE * 10\n426     return DEFAULT_REPR_MAX_SIZE\n427 \n428 \n429 def _format_assertmsg(obj: object) -> str:\n430     r\"\"\"Format the custom assertion message given.\n431 \n432     For strings this simply replaces newlines with '\\n~' so that\n433     util.format_explanation() will preserve them instead of escaping\n434     newlines.  For other objects saferepr() is used first.\n435     \"\"\"\n436     # reprlib appears to have a bug which means that if a string\n437     # contains a newline it gets escaped, however if an object has a\n438     # .__repr__() which contains newlines it does not get escaped.\n439     # However in either case we want to preserve the newline.\n440     replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n441     if not isinstance(obj, str):\n442         obj = saferepr(obj)\n443         replaces.append((\"\\\\n\", \"\\n~\"))\n444 \n445     for r1, r2 in replaces:\n446         obj = obj.replace(r1, r2)\n447 \n448     return obj\n449 \n450 \n451 def _should_repr_global_name(obj: object) -> bool:\n452     if callable(obj):\n453         return False\n454 \n455     try:\n456         return not hasattr(obj, \"__name__\")\n457     except Exception:\n458         return True\n459 \n460 \n461 def _format_boolop(explanations: Iterable[str], is_or: bool) -> str:\n462     explanation = \"(\" + (is_or and \" or \" or \" and \").join(explanations) + \")\"\n463     return explanation.replace(\"%\", \"%%\")\n464 \n465 \n466 def _call_reprcompare(\n467     ops: Sequence[str],\n468     results: Sequence[bool],\n469     expls: Sequence[str],\n470     each_obj: Sequence[object],\n471 ) -> str:\n472     for i, res, expl in zip(range(len(ops)), results, expls):\n473         try:\n474             done = not res\n475         except Exception:\n476             done = True\n477         if done:\n478             break\n479     if util._reprcompare is not None:\n480         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n481         if custom is not None:\n482             return custom\n483     return expl\n484 \n485 \n486 def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:\n487     if util._assertion_pass is not None:\n488         util._assertion_pass(lineno, orig, expl)\n489 \n490 \n491 def _check_if_assertion_pass_impl() -> bool:\n492     \"\"\"Check if any plugins implement the pytest_assertion_pass hook\n493     in order not to generate explanation unnecessarily (might be expensive).\"\"\"\n494     return True if util._assertion_pass else False\n495 \n496 \n497 UNARY_MAP = {ast.Not: \"not %s\", ast.Invert: \"~%s\", ast.USub: \"-%s\", ast.UAdd: \"+%s\"}\n498 \n499 BINOP_MAP = {\n500     ast.BitOr: \"|\",\n501     ast.BitXor: \"^\",\n502     ast.BitAnd: \"&\",\n503     ast.LShift: \"<<\",\n504     ast.RShift: \">>\",\n505     ast.Add: \"+\",\n506     ast.Sub: \"-\",\n507     ast.Mult: \"*\",\n508     ast.Div: \"/\",\n509     ast.FloorDiv: \"//\",\n510     ast.Mod: \"%%\",  # escaped for string formatting\n511     ast.Eq: \"==\",\n512     ast.NotEq: \"!=\",\n513     ast.Lt: \"<\",\n514     ast.LtE: \"<=\",\n515     ast.Gt: \">\",\n516     ast.GtE: \">=\",\n517     ast.Pow: \"**\",\n518     ast.Is: \"is\",\n519     ast.IsNot: \"is not\",\n520     ast.In: \"in\",\n521     ast.NotIn: \"not in\",\n522     ast.MatMult: \"@\",\n523 }\n524 \n525 \n526 def traverse_node(node: ast.AST) -> Iterator[ast.AST]:\n527     \"\"\"Recursively yield node and all its children in depth-first order.\"\"\"\n528     yield node\n529     for child in ast.iter_child_nodes(node):\n530         yield from traverse_node(child)\n531 \n532 \n533 @functools.lru_cache(maxsize=1)\n534 def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n535     \"\"\"Return a mapping from {lineno: \"assertion test expression\"}.\"\"\"\n536     ret: Dict[int, str] = {}\n537 \n538     depth = 0\n539     lines: List[str] = []\n540     assert_lineno: Optional[int] = None\n541     seen_lines: Set[int] = set()\n542 \n543     def _write_and_reset() -> None:\n544         nonlocal depth, lines, assert_lineno, seen_lines\n545         assert assert_lineno is not None\n546         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n547         depth = 0\n548         lines = []\n549         assert_lineno = None\n550         seen_lines = set()\n551 \n552     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n553     for tp, source, (lineno, offset), _, line in tokens:\n554         if tp == tokenize.NAME and source == \"assert\":\n555             assert_lineno = lineno\n556         elif assert_lineno is not None:\n557             # keep track of depth for the assert-message `,` lookup\n558             if tp == tokenize.OP and source in \"([{\":\n559                 depth += 1\n560             elif tp == tokenize.OP and source in \")]}\":\n561                 depth -= 1\n562 \n563             if not lines:\n564                 lines.append(line[offset:])\n565                 seen_lines.add(lineno)\n566             # a non-nested comma separates the expression from the message\n567             elif depth == 0 and tp == tokenize.OP and source == \",\":\n568                 # one line assert with message\n569                 if lineno in seen_lines and len(lines) == 1:\n570                     offset_in_trimmed = offset + len(lines[-1]) - len(line)\n571                     lines[-1] = lines[-1][:offset_in_trimmed]\n572                 # multi-line assert with message\n573                 elif lineno in seen_lines:\n574                     lines[-1] = lines[-1][:offset]\n575                 # multi line assert with escapd newline before message\n576                 else:\n577                     lines.append(line[:offset])\n578                 _write_and_reset()\n579             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n580                 _write_and_reset()\n581             elif lines and lineno not in seen_lines:\n582                 lines.append(line)\n583                 seen_lines.add(lineno)\n584 \n585     return ret\n586 \n587 \n588 class AssertionRewriter(ast.NodeVisitor):\n589     \"\"\"Assertion rewriting implementation.\n590 \n591     The main entrypoint is to call .run() with an ast.Module instance,\n592     this will then find all the assert statements and rewrite them to\n593     provide intermediate values and a detailed assertion error.  See\n594     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n595     for an overview of how this works.\n596 \n597     The entry point here is .run() which will iterate over all the\n598     statements in an ast.Module and for each ast.Assert statement it\n599     finds call .visit() with it.  Then .visit_Assert() takes over and\n600     is responsible for creating new ast statements to replace the\n601     original assert statement: it rewrites the test of an assertion\n602     to provide intermediate values and replace it with an if statement\n603     which raises an assertion error with a detailed explanation in\n604     case the expression is false and calls pytest_assertion_pass hook\n605     if expression is true.\n606 \n607     For this .visit_Assert() uses the visitor pattern to visit all the\n608     AST nodes of the ast.Assert.test field, each visit call returning\n609     an AST node and the corresponding explanation string.  During this\n610     state is kept in several instance attributes:\n611 \n612     :statements: All the AST statements which will replace the assert\n613        statement.\n614 \n615     :variables: This is populated by .variable() with each variable\n616        used by the statements so that they can all be set to None at\n617        the end of the statements.\n618 \n619     :variable_counter: Counter to create new unique variables needed\n620        by statements.  Variables are created using .variable() and\n621        have the form of \"@py_assert0\".\n622 \n623     :expl_stmts: The AST statements which will be executed to get\n624        data from the assertion.  This is the code which will construct\n625        the detailed assertion message that is used in the AssertionError\n626        or for the pytest_assertion_pass hook.\n627 \n628     :explanation_specifiers: A dict filled by .explanation_param()\n629        with %-formatting placeholders and their corresponding\n630        expressions to use in the building of an assertion message.\n631        This is used by .pop_format_context() to build a message.\n632 \n633     :stack: A stack of the explanation_specifiers dicts maintained by\n634        .push_format_context() and .pop_format_context() which allows\n635        to build another %-formatted string while already building one.\n636 \n637     :variables_overwrite: A dict filled with references to variables\n638        that change value within an assert. This happens when a variable is\n639        reassigned with the walrus operator\n640 \n641     This state, except the variables_overwrite,  is reset on every new assert\n642     statement visited and used by the other visitors.\n643     \"\"\"\n644 \n645     def __init__(\n646         self, module_path: Optional[str], config: Optional[Config], source: bytes\n647     ) -> None:\n648         super().__init__()\n649         self.module_path = module_path\n650         self.config = config\n651         if config is not None:\n652             self.enable_assertion_pass_hook = config.getini(\n653                 \"enable_assertion_pass_hook\"\n654             )\n655         else:\n656             self.enable_assertion_pass_hook = False\n657         self.source = source\n658         self.variables_overwrite: Dict[str, str] = {}\n659 \n660     def run(self, mod: ast.Module) -> None:\n661         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n662         if not mod.body:\n663             # Nothing to do.\n664             return\n665 \n666         # We'll insert some special imports at the top of the module, but after any\n667         # docstrings and __future__ imports, so first figure out where that is.\n668         doc = getattr(mod, \"docstring\", None)\n669         expect_docstring = doc is None\n670         if doc is not None and self.is_rewrite_disabled(doc):\n671             return\n672         pos = 0\n673         item = None\n674         for item in mod.body:\n675             if (\n676                 expect_docstring\n677                 and isinstance(item, ast.Expr)\n678                 and isinstance(item.value, ast.Constant)\n679             ):\n680                 doc = item.value.value\n681                 if self.is_rewrite_disabled(doc):\n682                     return\n683                 expect_docstring = False\n684             elif (\n685                 isinstance(item, ast.ImportFrom)\n686                 and item.level == 0\n687                 and item.module == \"__future__\"\n688             ):\n689                 pass\n690             else:\n691                 break\n692             pos += 1\n693         # Special case: for a decorated function, set the lineno to that of the\n694         # first decorator, not the `def`. Issue #4984.\n695         if isinstance(item, ast.FunctionDef) and item.decorator_list:\n696             lineno = item.decorator_list[0].lineno\n697         else:\n698             lineno = item.lineno\n699         # Now actually insert the special imports.\n700         if sys.version_info >= (3, 10):\n701             aliases = [\n702                 ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n703                 ast.alias(\n704                     \"_pytest.assertion.rewrite\",\n705                     \"@pytest_ar\",\n706                     lineno=lineno,\n707                     col_offset=0,\n708                 ),\n709             ]\n710         else:\n711             aliases = [\n712                 ast.alias(\"builtins\", \"@py_builtins\"),\n713                 ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n714             ]\n715         imports = [\n716             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n717         ]\n718         mod.body[pos:pos] = imports\n719 \n720         # Collect asserts.\n721         nodes: List[ast.AST] = [mod]\n722         while nodes:\n723             node = nodes.pop()\n724             for name, field in ast.iter_fields(node):\n725                 if isinstance(field, list):\n726                     new: List[ast.AST] = []\n727                     for i, child in enumerate(field):\n728                         if isinstance(child, ast.Assert):\n729                             # Transform assert.\n730                             new.extend(self.visit(child))\n731                         else:\n732                             new.append(child)\n733                             if isinstance(child, ast.AST):\n734                                 nodes.append(child)\n735                     setattr(node, name, new)\n736                 elif (\n737                     isinstance(field, ast.AST)\n738                     # Don't recurse into expressions as they can't contain\n739                     # asserts.\n740                     and not isinstance(field, ast.expr)\n741                 ):\n742                     nodes.append(field)\n743 \n744     @staticmethod\n745     def is_rewrite_disabled(docstring: str) -> bool:\n746         return \"PYTEST_DONT_REWRITE\" in docstring\n747 \n748     def variable(self) -> str:\n749         \"\"\"Get a new variable.\"\"\"\n750         # Use a character invalid in python identifiers to avoid clashing.\n751         name = \"@py_assert\" + str(next(self.variable_counter))\n752         self.variables.append(name)\n753         return name\n754 \n755     def assign(self, expr: ast.expr) -> ast.Name:\n756         \"\"\"Give *expr* a name.\"\"\"\n757         name = self.variable()\n758         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n759         return ast.Name(name, ast.Load())\n760 \n761     def display(self, expr: ast.expr) -> ast.expr:\n762         \"\"\"Call saferepr on the expression.\"\"\"\n763         return self.helper(\"_saferepr\", expr)\n764 \n765     def helper(self, name: str, *args: ast.expr) -> ast.expr:\n766         \"\"\"Call a helper in this module.\"\"\"\n767         py_name = ast.Name(\"@pytest_ar\", ast.Load())\n768         attr = ast.Attribute(py_name, name, ast.Load())\n769         return ast.Call(attr, list(args), [])\n770 \n771     def builtin(self, name: str) -> ast.Attribute:\n772         \"\"\"Return the builtin called *name*.\"\"\"\n773         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n774         return ast.Attribute(builtin_name, name, ast.Load())\n775 \n776     def explanation_param(self, expr: ast.expr) -> str:\n777         \"\"\"Return a new named %-formatting placeholder for expr.\n778 \n779         This creates a %-formatting placeholder for expr in the\n780         current formatting context, e.g. ``%(py0)s``.  The placeholder\n781         and expr are placed in the current format context so that it\n782         can be used on the next call to .pop_format_context().\n783         \"\"\"\n784         specifier = \"py\" + str(next(self.variable_counter))\n785         self.explanation_specifiers[specifier] = expr\n786         return \"%(\" + specifier + \")s\"\n787 \n788     def push_format_context(self) -> None:\n789         \"\"\"Create a new formatting context.\n790 \n791         The format context is used for when an explanation wants to\n792         have a variable value formatted in the assertion message.  In\n793         this case the value required can be added using\n794         .explanation_param().  Finally .pop_format_context() is used\n795         to format a string of %-formatted values as added by\n796         .explanation_param().\n797         \"\"\"\n798         self.explanation_specifiers: Dict[str, ast.expr] = {}\n799         self.stack.append(self.explanation_specifiers)\n800 \n801     def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:\n802         \"\"\"Format the %-formatted string with current format context.\n803 \n804         The expl_expr should be an str ast.expr instance constructed from\n805         the %-placeholders created by .explanation_param().  This will\n806         add the required code to format said string to .expl_stmts and\n807         return the ast.Name instance of the formatted string.\n808         \"\"\"\n809         current = self.stack.pop()\n810         if self.stack:\n811             self.explanation_specifiers = self.stack[-1]\n812         keys = [ast.Constant(key) for key in current.keys()]\n813         format_dict = ast.Dict(keys, list(current.values()))\n814         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n815         name = \"@py_format\" + str(next(self.variable_counter))\n816         if self.enable_assertion_pass_hook:\n817             self.format_variables.append(name)\n818         self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))\n819         return ast.Name(name, ast.Load())\n820 \n821     def generic_visit(self, node: ast.AST) -> Tuple[ast.Name, str]:\n822         \"\"\"Handle expressions we don't have custom code for.\"\"\"\n823         assert isinstance(node, ast.expr)\n824         res = self.assign(node)\n825         return res, self.explanation_param(self.display(res))\n826 \n827     def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n828         \"\"\"Return the AST statements to replace the ast.Assert instance.\n829 \n830         This rewrites the test of an assertion to provide\n831         intermediate values and replace it with an if statement which\n832         raises an assertion error with a detailed explanation in case\n833         the expression is false.\n834         \"\"\"\n835         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n836             from _pytest.warning_types import PytestAssertRewriteWarning\n837             import warnings\n838 \n839             # TODO: This assert should not be needed.\n840             assert self.module_path is not None\n841             warnings.warn_explicit(\n842                 PytestAssertRewriteWarning(\n843                     \"assertion is always true, perhaps remove parentheses?\"\n844                 ),\n845                 category=None,\n846                 filename=self.module_path,\n847                 lineno=assert_.lineno,\n848             )\n849 \n850         self.statements: List[ast.stmt] = []\n851         self.variables: List[str] = []\n852         self.variable_counter = itertools.count()\n853 \n854         if self.enable_assertion_pass_hook:\n855             self.format_variables: List[str] = []\n856 \n857         self.stack: List[Dict[str, ast.expr]] = []\n858         self.expl_stmts: List[ast.stmt] = []\n859         self.push_format_context()\n860         # Rewrite assert into a bunch of statements.\n861         top_condition, explanation = self.visit(assert_.test)\n862 \n863         negation = ast.UnaryOp(ast.Not(), top_condition)\n864 \n865         if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n866             msg = self.pop_format_context(ast.Constant(explanation))\n867 \n868             # Failed\n869             if assert_.msg:\n870                 assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n871                 gluestr = \"\\n>assert \"\n872             else:\n873                 assertmsg = ast.Constant(\"\")\n874                 gluestr = \"assert \"\n875             err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)\n876             err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n877             err_name = ast.Name(\"AssertionError\", ast.Load())\n878             fmt = self.helper(\"_format_explanation\", err_msg)\n879             exc = ast.Call(err_name, [fmt], [])\n880             raise_ = ast.Raise(exc, None)\n881             statements_fail = []\n882             statements_fail.extend(self.expl_stmts)\n883             statements_fail.append(raise_)\n884 \n885             # Passed\n886             fmt_pass = self.helper(\"_format_explanation\", msg)\n887             orig = _get_assertion_exprs(self.source)[assert_.lineno]\n888             hook_call_pass = ast.Expr(\n889                 self.helper(\n890                     \"_call_assertion_pass\",\n891                     ast.Constant(assert_.lineno),\n892                     ast.Constant(orig),\n893                     fmt_pass,\n894                 )\n895             )\n896             # If any hooks implement assert_pass hook\n897             hook_impl_test = ast.If(\n898                 self.helper(\"_check_if_assertion_pass_impl\"),\n899                 self.expl_stmts + [hook_call_pass],\n900                 [],\n901             )\n902             statements_pass = [hook_impl_test]\n903 \n904             # Test for assertion condition\n905             main_test = ast.If(negation, statements_fail, statements_pass)\n906             self.statements.append(main_test)\n907             if self.format_variables:\n908                 variables = [\n909                     ast.Name(name, ast.Store()) for name in self.format_variables\n910                 ]\n911                 clear_format = ast.Assign(variables, ast.Constant(None))\n912                 self.statements.append(clear_format)\n913 \n914         else:  # Original assertion rewriting\n915             # Create failure message.\n916             body = self.expl_stmts\n917             self.statements.append(ast.If(negation, body, []))\n918             if assert_.msg:\n919                 assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n920                 explanation = \"\\n>assert \" + explanation\n921             else:\n922                 assertmsg = ast.Constant(\"\")\n923                 explanation = \"assert \" + explanation\n924             template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))\n925             msg = self.pop_format_context(template)\n926             fmt = self.helper(\"_format_explanation\", msg)\n927             err_name = ast.Name(\"AssertionError\", ast.Load())\n928             exc = ast.Call(err_name, [fmt], [])\n929             raise_ = ast.Raise(exc, None)\n930 \n931             body.append(raise_)\n932 \n933         # Clear temporary variables by setting them to None.\n934         if self.variables:\n935             variables = [ast.Name(name, ast.Store()) for name in self.variables]\n936             clear = ast.Assign(variables, ast.Constant(None))\n937             self.statements.append(clear)\n938         # Fix locations (line numbers/column offsets).\n939         for stmt in self.statements:\n940             for node in traverse_node(stmt):\n941                 ast.copy_location(node, assert_)\n942         return self.statements\n943 \n944     def visit_NamedExpr(self, name: ast.NamedExpr) -> Tuple[ast.NamedExpr, str]:\n945         # This method handles the 'walrus operator' repr of the target\n946         # name if it's a local variable or _should_repr_global_name()\n947         # thinks it's acceptable.\n948         locs = ast.Call(self.builtin(\"locals\"), [], [])\n949         target_id = name.target.id  # type: ignore[attr-defined]\n950         inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])\n951         dorepr = self.helper(\"_should_repr_global_name\", name)\n952         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n953         expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))\n954         return name, self.explanation_param(expr)\n955 \n956     def visit_Name(self, name: ast.Name) -> Tuple[ast.Name, str]:\n957         # Display the repr of the name if it's a local variable or\n958         # _should_repr_global_name() thinks it's acceptable.\n959         locs = ast.Call(self.builtin(\"locals\"), [], [])\n960         inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])\n961         dorepr = self.helper(\"_should_repr_global_name\", name)\n962         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n963         expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))\n964         return name, self.explanation_param(expr)\n965 \n966     def visit_BoolOp(self, boolop: ast.BoolOp) -> Tuple[ast.Name, str]:\n967         res_var = self.variable()\n968         expl_list = self.assign(ast.List([], ast.Load()))\n969         app = ast.Attribute(expl_list, \"append\", ast.Load())\n970         is_or = int(isinstance(boolop.op, ast.Or))\n971         body = save = self.statements\n972         fail_save = self.expl_stmts\n973         levels = len(boolop.values) - 1\n974         self.push_format_context()\n975         # Process each operand, short-circuiting if needed.\n976         for i, v in enumerate(boolop.values):\n977             if i:\n978                 fail_inner: List[ast.stmt] = []\n979                 # cond is set in a prior loop iteration below\n980                 self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa\n981                 self.expl_stmts = fail_inner\n982                 # Check if the left operand is a ast.NamedExpr and the value has already been visited\n983                 if (\n984                     isinstance(v, ast.Compare)\n985                     and isinstance(v.left, ast.NamedExpr)\n986                     and v.left.target.id\n987                     in [\n988                         ast_expr.id\n989                         for ast_expr in boolop.values[:i]\n990                         if hasattr(ast_expr, \"id\")\n991                     ]\n992                 ):\n993                     pytest_temp = self.variable()\n994                     self.variables_overwrite[\n995                         v.left.target.id\n996                     ] = v.left  # type:ignore[assignment]\n997                     v.left.target.id = pytest_temp\n998             self.push_format_context()\n999             res, expl = self.visit(v)\n1000             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n1001             expl_format = self.pop_format_context(ast.Constant(expl))\n1002             call = ast.Call(app, [expl_format], [])\n1003             self.expl_stmts.append(ast.Expr(call))\n1004             if i < levels:\n1005                 cond: ast.expr = res\n1006                 if is_or:\n1007                     cond = ast.UnaryOp(ast.Not(), cond)\n1008                 inner: List[ast.stmt] = []\n1009                 self.statements.append(ast.If(cond, inner, []))\n1010                 self.statements = body = inner\n1011         self.statements = save\n1012         self.expl_stmts = fail_save\n1013         expl_template = self.helper(\"_format_boolop\", expl_list, ast.Constant(is_or))\n1014         expl = self.pop_format_context(expl_template)\n1015         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n1016 \n1017     def visit_UnaryOp(self, unary: ast.UnaryOp) -> Tuple[ast.Name, str]:\n1018         pattern = UNARY_MAP[unary.op.__class__]\n1019         operand_res, operand_expl = self.visit(unary.operand)\n1020         res = self.assign(ast.UnaryOp(unary.op, operand_res))\n1021         return res, pattern % (operand_expl,)\n1022 \n1023     def visit_BinOp(self, binop: ast.BinOp) -> Tuple[ast.Name, str]:\n1024         symbol = BINOP_MAP[binop.op.__class__]\n1025         left_expr, left_expl = self.visit(binop.left)\n1026         right_expr, right_expl = self.visit(binop.right)\n1027         explanation = f\"({left_expl} {symbol} {right_expl})\"\n1028         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n1029         return res, explanation\n1030 \n1031     def visit_Call(self, call: ast.Call) -> Tuple[ast.Name, str]:\n1032         new_func, func_expl = self.visit(call.func)\n1033         arg_expls = []\n1034         new_args = []\n1035         new_kwargs = []\n1036         for arg in call.args:\n1037             if isinstance(arg, ast.Name) and arg.id in self.variables_overwrite:\n1038                 arg = self.variables_overwrite[arg.id]  # type:ignore[assignment]\n1039             res, expl = self.visit(arg)\n1040             arg_expls.append(expl)\n1041             new_args.append(res)\n1042         for keyword in call.keywords:\n1043             if (\n1044                 isinstance(keyword.value, ast.Name)\n1045                 and keyword.value.id in self.variables_overwrite\n1046             ):\n1047                 keyword.value = self.variables_overwrite[\n1048                     keyword.value.id\n1049                 ]  # type:ignore[assignment]\n1050             res, expl = self.visit(keyword.value)\n1051             new_kwargs.append(ast.keyword(keyword.arg, res))\n1052             if keyword.arg:\n1053                 arg_expls.append(keyword.arg + \"=\" + expl)\n1054             else:  # **args have `arg` keywords with an .arg of None\n1055                 arg_expls.append(\"**\" + expl)\n1056 \n1057         expl = \"{}({})\".format(func_expl, \", \".join(arg_expls))\n1058         new_call = ast.Call(new_func, new_args, new_kwargs)\n1059         res = self.assign(new_call)\n1060         res_expl = self.explanation_param(self.display(res))\n1061         outer_expl = f\"{res_expl}\\n{{{res_expl} = {expl}\\n}}\"\n1062         return res, outer_expl\n1063 \n1064     def visit_Starred(self, starred: ast.Starred) -> Tuple[ast.Starred, str]:\n1065         # A Starred node can appear in a function call.\n1066         res, expl = self.visit(starred.value)\n1067         new_starred = ast.Starred(res, starred.ctx)\n1068         return new_starred, \"*\" + expl\n1069 \n1070     def visit_Attribute(self, attr: ast.Attribute) -> Tuple[ast.Name, str]:\n1071         if not isinstance(attr.ctx, ast.Load):\n1072             return self.generic_visit(attr)\n1073         value, value_expl = self.visit(attr.value)\n1074         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n1075         res_expl = self.explanation_param(self.display(res))\n1076         pat = \"%s\\n{%s = %s.%s\\n}\"\n1077         expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n1078         return res, expl\n1079 \n1080     def visit_Compare(self, comp: ast.Compare) -> Tuple[ast.expr, str]:\n1081         self.push_format_context()\n1082         # We first check if we have overwritten a variable in the previous assert\n1083         if isinstance(comp.left, ast.Name) and comp.left.id in self.variables_overwrite:\n1084             comp.left = self.variables_overwrite[\n1085                 comp.left.id\n1086             ]  # type:ignore[assignment]\n1087         if isinstance(comp.left, ast.NamedExpr):\n1088             self.variables_overwrite[\n1089                 comp.left.target.id\n1090             ] = comp.left  # type:ignore[assignment]\n1091         left_res, left_expl = self.visit(comp.left)\n1092         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n1093             left_expl = f\"({left_expl})\"\n1094         res_variables = [self.variable() for i in range(len(comp.ops))]\n1095         load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n1096         store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n1097         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n1098         expls = []\n1099         syms = []\n1100         results = [left_res]\n1101         for i, op, next_operand in it:\n1102             if (\n1103                 isinstance(next_operand, ast.NamedExpr)\n1104                 and isinstance(left_res, ast.Name)\n1105                 and next_operand.target.id == left_res.id\n1106             ):\n1107                 next_operand.target.id = self.variable()\n1108                 self.variables_overwrite[\n1109                     left_res.id\n1110                 ] = next_operand  # type:ignore[assignment]\n1111             next_res, next_expl = self.visit(next_operand)\n1112             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n1113                 next_expl = f\"({next_expl})\"\n1114             results.append(next_res)\n1115             sym = BINOP_MAP[op.__class__]\n1116             syms.append(ast.Constant(sym))\n1117             expl = f\"{left_expl} {sym} {next_expl}\"\n1118             expls.append(ast.Constant(expl))\n1119             res_expr = ast.Compare(left_res, [op], [next_res])\n1120             self.statements.append(ast.Assign([store_names[i]], res_expr))\n1121             left_res, left_expl = next_res, next_expl\n1122         # Use pytest.assertion.util._reprcompare if that's available.\n1123         expl_call = self.helper(\n1124             \"_call_reprcompare\",\n1125             ast.Tuple(syms, ast.Load()),\n1126             ast.Tuple(load_names, ast.Load()),\n1127             ast.Tuple(expls, ast.Load()),\n1128             ast.Tuple(results, ast.Load()),\n1129         )\n1130         if len(comp.ops) > 1:\n1131             res: ast.expr = ast.BoolOp(ast.And(), load_names)\n1132         else:\n1133             res = load_names[0]\n1134 \n1135         return res, self.explanation_param(self.pop_format_context(expl_call))\n1136 \n1137 \n1138 def try_makedirs(cache_dir: Path) -> bool:\n1139     \"\"\"Attempt to create the given directory and sub-directories exist.\n1140 \n1141     Returns True if successful or if it already exists.\n1142     \"\"\"\n1143     try:\n1144         os.makedirs(cache_dir, exist_ok=True)\n1145     except (FileNotFoundError, NotADirectoryError, FileExistsError):\n1146         # One of the path components was not a directory:\n1147         # - we're in a zip file\n1148         # - it is a file\n1149         return False\n1150     except PermissionError:\n1151         return False\n1152     except OSError as e:\n1153         # as of now, EROFS doesn't have an equivalent OSError-subclass\n1154         if e.errno == errno.EROFS:\n1155             return False\n1156         raise\n1157     return True\n1158 \n1159 \n1160 def get_cache_dir(file_path: Path) -> Path:\n1161     \"\"\"Return the cache directory to write .pyc files for the given .py file path.\"\"\"\n1162     if sys.pycache_prefix:\n1163         # given:\n1164         #   prefix = '/tmp/pycs'\n1165         #   path = '/home/user/proj/test_app.py'\n1166         # we want:\n1167         #   '/tmp/pycs/home/user/proj'\n1168         return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])\n1169     else:\n1170         # classic pycache directory\n1171         return file_path.parent / \"__pycache__\"\n",
        "intended_behavior": "Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module."
    },
    {
        "rel_file_path": "testing/test_config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/testing/test_config.py",
        "start": 1,
        "end": 2172,
        "class_name": null,
        "method_name": null,
        "code": "1 import dataclasses\n2 import importlib.metadata\n3 import os\n4 import re\n5 import sys\n6 import textwrap\n7 from pathlib import Path\n8 from typing import Dict\n9 from typing import List\n10 from typing import Sequence\n11 from typing import Tuple\n12 from typing import Type\n13 from typing import Union\n14 \n15 import _pytest._code\n16 import pytest\n17 from _pytest.config import _get_plugin_specs_as_list\n18 from _pytest.config import _iter_rewritable_modules\n19 from _pytest.config import _strtobool\n20 from _pytest.config import Config\n21 from _pytest.config import ConftestImportFailure\n22 from _pytest.config import ExitCode\n23 from _pytest.config import parse_warning_filter\n24 from _pytest.config.exceptions import UsageError\n25 from _pytest.config.findpaths import determine_setup\n26 from _pytest.config.findpaths import get_common_ancestor\n27 from _pytest.config.findpaths import locate_config\n28 from _pytest.monkeypatch import MonkeyPatch\n29 from _pytest.pathlib import absolutepath\n30 from _pytest.pytester import Pytester\n31 \n32 \n33 class TestParseIni:\n34     @pytest.mark.parametrize(\n35         \"section, filename\", [(\"pytest\", \"pytest.ini\"), (\"tool:pytest\", \"setup.cfg\")]\n36     )\n37     def test_getcfg_and_config(\n38         self,\n39         pytester: Pytester,\n40         tmp_path: Path,\n41         section: str,\n42         filename: str,\n43         monkeypatch: MonkeyPatch,\n44     ) -> None:\n45         sub = tmp_path / \"sub\"\n46         sub.mkdir()\n47         monkeypatch.chdir(sub)\n48         (tmp_path / filename).write_text(\n49             textwrap.dedent(\n50                 \"\"\"\\\n51                 [{section}]\n52                 name = value\n53                 \"\"\".format(\n54                     section=section\n55                 )\n56             ),\n57             encoding=\"utf-8\",\n58         )\n59         _, _, cfg = locate_config([sub])\n60         assert cfg[\"name\"] == \"value\"\n61         config = pytester.parseconfigure(str(sub))\n62         assert config.inicfg[\"name\"] == \"value\"\n63 \n64     def test_setupcfg_uses_toolpytest_with_pytest(self, pytester: Pytester) -> None:\n65         p1 = pytester.makepyfile(\"def test(): pass\")\n66         pytester.makefile(\n67             \".cfg\",\n68             setup=\"\"\"\n69                 [tool:pytest]\n70                 testpaths=%s\n71                 [pytest]\n72                 testpaths=ignored\n73         \"\"\"\n74             % p1.name,\n75         )\n76         result = pytester.runpytest()\n77         result.stdout.fnmatch_lines([\"configfile: setup.cfg\", \"* 1 passed in *\"])\n78         assert result.ret == 0\n79 \n80     def test_append_parse_args(\n81         self, pytester: Pytester, tmp_path: Path, monkeypatch: MonkeyPatch\n82     ) -> None:\n83         monkeypatch.setenv(\"PYTEST_ADDOPTS\", '--color no -rs --tb=\"short\"')\n84         tmp_path.joinpath(\"pytest.ini\").write_text(\n85             textwrap.dedent(\n86                 \"\"\"\\\n87                 [pytest]\n88                 addopts = --verbose\n89                 \"\"\"\n90             ),\n91             encoding=\"utf-8\",\n92         )\n93         config = pytester.parseconfig(tmp_path)\n94         assert config.option.color == \"no\"\n95         assert config.option.reportchars == \"s\"\n96         assert config.option.tbstyle == \"short\"\n97         assert config.option.verbose\n98 \n99     def test_tox_ini_wrong_version(self, pytester: Pytester) -> None:\n100         pytester.makefile(\n101             \".ini\",\n102             tox=\"\"\"\n103             [pytest]\n104             minversion=999.0\n105         \"\"\",\n106         )\n107         result = pytester.runpytest()\n108         assert result.ret != 0\n109         result.stderr.fnmatch_lines(\n110             [\"*tox.ini: 'minversion' requires pytest-999.0, actual pytest-*\"]\n111         )\n112 \n113     @pytest.mark.parametrize(\n114         \"section, name\",\n115         [\n116             (\"tool:pytest\", \"setup.cfg\"),\n117             (\"pytest\", \"tox.ini\"),\n118             (\"pytest\", \"pytest.ini\"),\n119             (\"pytest\", \".pytest.ini\"),\n120         ],\n121     )\n122     def test_ini_names(self, pytester: Pytester, name, section) -> None:\n123         pytester.path.joinpath(name).write_text(\n124             textwrap.dedent(\n125                 \"\"\"\n126             [{section}]\n127             minversion = 3.36\n128         \"\"\".format(\n129                     section=section\n130                 )\n131             ),\n132             encoding=\"utf-8\",\n133         )\n134         config = pytester.parseconfig()\n135         assert config.getini(\"minversion\") == \"3.36\"\n136 \n137     def test_pyproject_toml(self, pytester: Pytester) -> None:\n138         pytester.makepyprojecttoml(\n139             \"\"\"\n140             [tool.pytest.ini_options]\n141             minversion = \"1.0\"\n142         \"\"\"\n143         )\n144         config = pytester.parseconfig()\n145         assert config.getini(\"minversion\") == \"1.0\"\n146 \n147     def test_toxini_before_lower_pytestini(self, pytester: Pytester) -> None:\n148         sub = pytester.mkdir(\"sub\")\n149         sub.joinpath(\"tox.ini\").write_text(\n150             textwrap.dedent(\n151                 \"\"\"\n152             [pytest]\n153             minversion = 2.0\n154         \"\"\"\n155             ),\n156             encoding=\"utf-8\",\n157         )\n158         pytester.path.joinpath(\"pytest.ini\").write_text(\n159             textwrap.dedent(\n160                 \"\"\"\n161             [pytest]\n162             minversion = 1.5\n163         \"\"\"\n164             ),\n165             encoding=\"utf-8\",\n166         )\n167         config = pytester.parseconfigure(sub)\n168         assert config.getini(\"minversion\") == \"2.0\"\n169 \n170     def test_ini_parse_error(self, pytester: Pytester) -> None:\n171         pytester.path.joinpath(\"pytest.ini\").write_text(\n172             \"addopts = -x\", encoding=\"utf-8\"\n173         )\n174         result = pytester.runpytest()\n175         assert result.ret != 0\n176         result.stderr.fnmatch_lines(\"ERROR: *pytest.ini:1: no section header defined\")\n177 \n178     def test_toml_parse_error(self, pytester: Pytester) -> None:\n179         pytester.makepyprojecttoml(\n180             \"\"\"\n181             \\\\\"\n182             \"\"\"\n183         )\n184         result = pytester.runpytest()\n185         assert result.ret != 0\n186         result.stderr.fnmatch_lines(\"ERROR: *pyproject.toml: Invalid statement*\")\n187 \n188     def test_confcutdir_default_without_configfile(self, pytester: Pytester) -> None:\n189         # If --confcutdir is not specified, and there is no configfile, default\n190         # to the roothpath.\n191         sub = pytester.mkdir(\"sub\")\n192         os.chdir(sub)\n193         config = pytester.parseconfigure()\n194         assert config.pluginmanager._confcutdir == sub\n195 \n196     def test_confcutdir_default_with_configfile(self, pytester: Pytester) -> None:\n197         # If --confcutdir is not specified, and there is a configfile, default\n198         # to the configfile's directory.\n199         pytester.makeini(\"[pytest]\")\n200         sub = pytester.mkdir(\"sub\")\n201         os.chdir(sub)\n202         config = pytester.parseconfigure()\n203         assert config.pluginmanager._confcutdir == pytester.path\n204 \n205     @pytest.mark.xfail(reason=\"probably not needed\")\n206     def test_confcutdir(self, pytester: Pytester) -> None:\n207         sub = pytester.mkdir(\"sub\")\n208         os.chdir(sub)\n209         pytester.makeini(\n210             \"\"\"\n211             [pytest]\n212             addopts = --qwe\n213         \"\"\"\n214         )\n215         result = pytester.inline_run(\"--confcutdir=.\")\n216         assert result.ret == 0\n217 \n218     @pytest.mark.parametrize(\n219         \"ini_file_text, invalid_keys, warning_output, exception_text\",\n220         [\n221             pytest.param(\n222                 \"\"\"\n223                 [pytest]\n224                 unknown_ini = value1\n225                 another_unknown_ini = value2\n226                 \"\"\",\n227                 [\"unknown_ini\", \"another_unknown_ini\"],\n228                 [\n229                     \"=*= warnings summary =*=\",\n230                     \"*PytestConfigWarning:*Unknown config option: another_unknown_ini\",\n231                     \"*PytestConfigWarning:*Unknown config option: unknown_ini\",\n232                 ],\n233                 \"Unknown config option: another_unknown_ini\",\n234                 id=\"2-unknowns\",\n235             ),\n236             pytest.param(\n237                 \"\"\"\n238                 [pytest]\n239                 unknown_ini = value1\n240                 minversion = 5.0.0\n241                 \"\"\",\n242                 [\"unknown_ini\"],\n243                 [\n244                     \"=*= warnings summary =*=\",\n245                     \"*PytestConfigWarning:*Unknown config option: unknown_ini\",\n246                 ],\n247                 \"Unknown config option: unknown_ini\",\n248                 id=\"1-unknown\",\n249             ),\n250             pytest.param(\n251                 \"\"\"\n252                 [some_other_header]\n253                 unknown_ini = value1\n254                 [pytest]\n255                 minversion = 5.0.0\n256                 \"\"\",\n257                 [],\n258                 [],\n259                 \"\",\n260                 id=\"unknown-in-other-header\",\n261             ),\n262             pytest.param(\n263                 \"\"\"\n264                 [pytest]\n265                 minversion = 5.0.0\n266                 \"\"\",\n267                 [],\n268                 [],\n269                 \"\",\n270                 id=\"no-unknowns\",\n271             ),\n272             pytest.param(\n273                 \"\"\"\n274                 [pytest]\n275                 conftest_ini_key = 1\n276                 \"\"\",\n277                 [],\n278                 [],\n279                 \"\",\n280                 id=\"1-known\",\n281             ),\n282         ],\n283     )\n284     @pytest.mark.filterwarnings(\"default\")\n285     def test_invalid_config_options(\n286         self,\n287         pytester: Pytester,\n288         ini_file_text,\n289         invalid_keys,\n290         warning_output,\n291         exception_text,\n292     ) -> None:\n293         pytester.makeconftest(\n294             \"\"\"\n295             def pytest_addoption(parser):\n296                 parser.addini(\"conftest_ini_key\", \"\")\n297             \"\"\"\n298         )\n299         pytester.makepyfile(\"def test(): pass\")\n300         pytester.makeini(ini_file_text)\n301 \n302         config = pytester.parseconfig()\n303         assert sorted(config._get_unknown_ini_keys()) == sorted(invalid_keys)\n304 \n305         result = pytester.runpytest()\n306         result.stdout.fnmatch_lines(warning_output)\n307 \n308         result = pytester.runpytest(\"--strict-config\")\n309         if exception_text:\n310             result.stderr.fnmatch_lines(\"ERROR: \" + exception_text)\n311             assert result.ret == pytest.ExitCode.USAGE_ERROR\n312         else:\n313             result.stderr.no_fnmatch_line(exception_text)\n314             assert result.ret == pytest.ExitCode.OK\n315 \n316     @pytest.mark.filterwarnings(\"default\")\n317     def test_silence_unknown_key_warning(self, pytester: Pytester) -> None:\n318         \"\"\"Unknown config key warnings can be silenced using filterwarnings (#7620)\"\"\"\n319         pytester.makeini(\n320             \"\"\"\n321             [pytest]\n322             filterwarnings =\n323                 ignore:Unknown config option:pytest.PytestConfigWarning\n324             foobar=1\n325         \"\"\"\n326         )\n327         result = pytester.runpytest()\n328         result.stdout.no_fnmatch_line(\"*PytestConfigWarning*\")\n329 \n330     @pytest.mark.filterwarnings(\"default::pytest.PytestConfigWarning\")\n331     def test_disable_warnings_plugin_disables_config_warnings(\n332         self, pytester: Pytester\n333     ) -> None:\n334         \"\"\"Disabling 'warnings' plugin also disables config time warnings\"\"\"\n335         pytester.makeconftest(\n336             \"\"\"\n337             import pytest\n338             def pytest_configure(config):\n339                 config.issue_config_time_warning(\n340                     pytest.PytestConfigWarning(\"custom config warning\"),\n341                     stacklevel=2,\n342                 )\n343         \"\"\"\n344         )\n345         result = pytester.runpytest(\"-pno:warnings\")\n346         result.stdout.no_fnmatch_line(\"*PytestConfigWarning*\")\n347 \n348     @pytest.mark.parametrize(\n349         \"ini_file_text, plugin_version, exception_text\",\n350         [\n351             pytest.param(\n352                 \"\"\"\n353                 [pytest]\n354                 required_plugins = a z\n355                 \"\"\",\n356                 \"1.5\",\n357                 \"Missing required plugins: a, z\",\n358                 id=\"2-missing\",\n359             ),\n360             pytest.param(\n361                 \"\"\"\n362                 [pytest]\n363                 required_plugins = a z myplugin\n364                 \"\"\",\n365                 \"1.5\",\n366                 \"Missing required plugins: a, z\",\n367                 id=\"2-missing-1-ok\",\n368             ),\n369             pytest.param(\n370                 \"\"\"\n371                 [pytest]\n372                 required_plugins = myplugin\n373                 \"\"\",\n374                 \"1.5\",\n375                 None,\n376                 id=\"1-ok\",\n377             ),\n378             pytest.param(\n379                 \"\"\"\n380                 [pytest]\n381                 required_plugins = myplugin==1.5\n382                 \"\"\",\n383                 \"1.5\",\n384                 None,\n385                 id=\"1-ok-pin-exact\",\n386             ),\n387             pytest.param(\n388                 \"\"\"\n389                 [pytest]\n390                 required_plugins = myplugin>1.0,<2.0\n391                 \"\"\",\n392                 \"1.5\",\n393                 None,\n394                 id=\"1-ok-pin-loose\",\n395             ),\n396             pytest.param(\n397                 \"\"\"\n398                 [pytest]\n399                 required_plugins = myplugin\n400                 \"\"\",\n401                 \"1.5a1\",\n402                 None,\n403                 id=\"1-ok-prerelease\",\n404             ),\n405             pytest.param(\n406                 \"\"\"\n407                 [pytest]\n408                 required_plugins = myplugin==1.6\n409                 \"\"\",\n410                 \"1.5\",\n411                 \"Missing required plugins: myplugin==1.6\",\n412                 id=\"missing-version\",\n413             ),\n414             pytest.param(\n415                 \"\"\"\n416                 [pytest]\n417                 required_plugins = myplugin==1.6 other==1.0\n418                 \"\"\",\n419                 \"1.5\",\n420                 \"Missing required plugins: myplugin==1.6, other==1.0\",\n421                 id=\"missing-versions\",\n422             ),\n423             pytest.param(\n424                 \"\"\"\n425                 [some_other_header]\n426                 required_plugins = won't be triggered\n427                 [pytest]\n428                 \"\"\",\n429                 \"1.5\",\n430                 None,\n431                 id=\"invalid-header\",\n432             ),\n433         ],\n434     )\n435     def test_missing_required_plugins(\n436         self,\n437         pytester: Pytester,\n438         monkeypatch: MonkeyPatch,\n439         ini_file_text: str,\n440         plugin_version: str,\n441         exception_text: str,\n442     ) -> None:\n443         \"\"\"Check 'required_plugins' option with various settings.\n444 \n445         This test installs a mock \"myplugin-1.5\" which is used in the parametrized test cases.\n446         \"\"\"\n447 \n448         @dataclasses.dataclass\n449         class DummyEntryPoint:\n450             name: str\n451             module: str\n452             group: str = \"pytest11\"\n453 \n454             def load(self):\n455                 __import__(self.module)\n456                 return sys.modules[self.module]\n457 \n458         entry_points = [\n459             DummyEntryPoint(\"myplugin1\", \"myplugin1_module\"),\n460         ]\n461 \n462         @dataclasses.dataclass\n463         class DummyDist:\n464             entry_points: object\n465             files: object = ()\n466             version: str = plugin_version\n467 \n468             @property\n469             def metadata(self):\n470                 return {\"name\": \"myplugin\"}\n471 \n472         def my_dists():\n473             return [DummyDist(entry_points)]\n474 \n475         pytester.makepyfile(myplugin1_module=\"# my plugin module\")\n476         pytester.syspathinsert()\n477 \n478         monkeypatch.setattr(importlib.metadata, \"distributions\", my_dists)\n479         monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n480 \n481         pytester.makeini(ini_file_text)\n482 \n483         if exception_text:\n484             with pytest.raises(pytest.UsageError, match=exception_text):\n485                 pytester.parseconfig()\n486         else:\n487             pytester.parseconfig()\n488 \n489     def test_early_config_cmdline(\n490         self, pytester: Pytester, monkeypatch: MonkeyPatch\n491     ) -> None:\n492         \"\"\"early_config contains options registered by third-party plugins.\n493 \n494         This is a regression involving pytest-cov (and possibly others) introduced in #7700.\n495         \"\"\"\n496         pytester.makepyfile(\n497             myplugin=\"\"\"\n498             def pytest_addoption(parser):\n499                 parser.addoption('--foo', default=None, dest='foo')\n500 \n501             def pytest_load_initial_conftests(early_config, parser, args):\n502                 assert early_config.known_args_namespace.foo == \"1\"\n503             \"\"\"\n504         )\n505         monkeypatch.setenv(\"PYTEST_PLUGINS\", \"myplugin\")\n506         pytester.syspathinsert()\n507         result = pytester.runpytest(\"--foo=1\")\n508         result.stdout.fnmatch_lines(\"* no tests ran in *\")\n509 \n510 \n511 class TestConfigCmdlineParsing:\n512     def test_parsing_again_fails(self, pytester: Pytester) -> None:\n513         config = pytester.parseconfig()\n514         pytest.raises(AssertionError, lambda: config.parse([]))\n515 \n516     def test_explicitly_specified_config_file_is_loaded(\n517         self, pytester: Pytester\n518     ) -> None:\n519         pytester.makeconftest(\n520             \"\"\"\n521             def pytest_addoption(parser):\n522                 parser.addini(\"custom\", \"\")\n523         \"\"\"\n524         )\n525         pytester.makeini(\n526             \"\"\"\n527             [pytest]\n528             custom = 0\n529         \"\"\"\n530         )\n531         pytester.makefile(\n532             \".ini\",\n533             custom=\"\"\"\n534             [pytest]\n535             custom = 1\n536         \"\"\",\n537         )\n538         config = pytester.parseconfig(\"-c\", \"custom.ini\")\n539         assert config.getini(\"custom\") == \"1\"\n540         config = pytester.parseconfig(\"--config-file\", \"custom.ini\")\n541         assert config.getini(\"custom\") == \"1\"\n542 \n543         pytester.makefile(\n544             \".cfg\",\n545             custom_tool_pytest_section=\"\"\"\n546             [tool:pytest]\n547             custom = 1\n548         \"\"\",\n549         )\n550         config = pytester.parseconfig(\"-c\", \"custom_tool_pytest_section.cfg\")\n551         assert config.getini(\"custom\") == \"1\"\n552         config = pytester.parseconfig(\"--config-file\", \"custom_tool_pytest_section.cfg\")\n553         assert config.getini(\"custom\") == \"1\"\n554 \n555         pytester.makefile(\n556             \".toml\",\n557             custom=\"\"\"\n558                 [tool.pytest.ini_options]\n559                 custom = 1\n560                 value = [\n561                 ]  # this is here on purpose, as it makes this an invalid '.ini' file\n562             \"\"\",\n563         )\n564         config = pytester.parseconfig(\"-c\", \"custom.toml\")\n565         assert config.getini(\"custom\") == \"1\"\n566         config = pytester.parseconfig(\"--config-file\", \"custom.toml\")\n567         assert config.getini(\"custom\") == \"1\"\n568 \n569     def test_absolute_win32_path(self, pytester: Pytester) -> None:\n570         temp_ini_file = pytester.makefile(\n571             \".ini\",\n572             custom=\"\"\"\n573             [pytest]\n574             addopts = --version\n575         \"\"\",\n576         )\n577         from os.path import normpath\n578 \n579         temp_ini_file_norm = normpath(str(temp_ini_file))\n580         ret = pytest.main([\"-c\", temp_ini_file_norm])\n581         assert ret == ExitCode.OK\n582         ret = pytest.main([\"--config-file\", temp_ini_file_norm])\n583         assert ret == ExitCode.OK\n584 \n585 \n586 class TestConfigAPI:\n587     def test_config_trace(self, pytester: Pytester) -> None:\n588         config = pytester.parseconfig()\n589         values: List[str] = []\n590         config.trace.root.setwriter(values.append)\n591         config.trace(\"hello\")\n592         assert len(values) == 1\n593         assert values[0] == \"hello [config]\\n\"\n594 \n595     def test_config_getoption(self, pytester: Pytester) -> None:\n596         pytester.makeconftest(\n597             \"\"\"\n598             def pytest_addoption(parser):\n599                 parser.addoption(\"--hello\", \"-X\", dest=\"hello\")\n600         \"\"\"\n601         )\n602         config = pytester.parseconfig(\"--hello=this\")\n603         for x in (\"hello\", \"--hello\", \"-X\"):\n604             assert config.getoption(x) == \"this\"\n605         pytest.raises(ValueError, config.getoption, \"qweqwe\")\n606 \n607     def test_config_getoption_unicode(self, pytester: Pytester) -> None:\n608         pytester.makeconftest(\n609             \"\"\"\n610             def pytest_addoption(parser):\n611                 parser.addoption('--hello', type=str)\n612         \"\"\"\n613         )\n614         config = pytester.parseconfig(\"--hello=this\")\n615         assert config.getoption(\"hello\") == \"this\"\n616 \n617     def test_config_getvalueorskip(self, pytester: Pytester) -> None:\n618         config = pytester.parseconfig()\n619         pytest.raises(pytest.skip.Exception, config.getvalueorskip, \"hello\")\n620         verbose = config.getvalueorskip(\"verbose\")\n621         assert verbose == config.option.verbose\n622 \n623     def test_config_getvalueorskip_None(self, pytester: Pytester) -> None:\n624         pytester.makeconftest(\n625             \"\"\"\n626             def pytest_addoption(parser):\n627                 parser.addoption(\"--hello\")\n628         \"\"\"\n629         )\n630         config = pytester.parseconfig()\n631         with pytest.raises(pytest.skip.Exception):\n632             config.getvalueorskip(\"hello\")\n633 \n634     def test_getoption(self, pytester: Pytester) -> None:\n635         config = pytester.parseconfig()\n636         with pytest.raises(ValueError):\n637             config.getvalue(\"x\")\n638         assert config.getoption(\"x\", 1) == 1\n639 \n640     def test_getconftest_pathlist(self, pytester: Pytester, tmp_path: Path) -> None:\n641         somepath = tmp_path.joinpath(\"x\", \"y\", \"z\")\n642         p = tmp_path.joinpath(\"conftest.py\")\n643         p.write_text(f\"mylist = {['.', str(somepath)]}\", encoding=\"utf-8\")\n644         config = pytester.parseconfigure(p)\n645         assert (\n646             config._getconftest_pathlist(\"notexist\", path=tmp_path, rootpath=tmp_path)\n647             is None\n648         )\n649         pl = (\n650             config._getconftest_pathlist(\"mylist\", path=tmp_path, rootpath=tmp_path)\n651             or []\n652         )\n653         print(pl)\n654         assert len(pl) == 2\n655         assert pl[0] == tmp_path\n656         assert pl[1] == somepath\n657 \n658     @pytest.mark.parametrize(\"maybe_type\", [\"not passed\", \"None\", '\"string\"'])\n659     def test_addini(self, pytester: Pytester, maybe_type: str) -> None:\n660         if maybe_type == \"not passed\":\n661             type_string = \"\"\n662         else:\n663             type_string = f\", {maybe_type}\"\n664 \n665         pytester.makeconftest(\n666             f\"\"\"\n667             def pytest_addoption(parser):\n668                 parser.addini(\"myname\", \"my new ini value\"{type_string})\n669         \"\"\"\n670         )\n671         pytester.makeini(\n672             \"\"\"\n673             [pytest]\n674             myname=hello\n675         \"\"\"\n676         )\n677         config = pytester.parseconfig()\n678         val = config.getini(\"myname\")\n679         assert val == \"hello\"\n680         pytest.raises(ValueError, config.getini, \"other\")\n681 \n682     @pytest.mark.parametrize(\"config_type\", [\"ini\", \"pyproject\"])\n683     def test_addini_paths(self, pytester: Pytester, config_type: str) -> None:\n684         pytester.makeconftest(\n685             \"\"\"\n686             def pytest_addoption(parser):\n687                 parser.addini(\"paths\", \"my new ini value\", type=\"paths\")\n688                 parser.addini(\"abc\", \"abc value\")\n689         \"\"\"\n690         )\n691         if config_type == \"ini\":\n692             inipath = pytester.makeini(\n693                 \"\"\"\n694                 [pytest]\n695                 paths=hello world/sub.py\n696             \"\"\"\n697             )\n698         elif config_type == \"pyproject\":\n699             inipath = pytester.makepyprojecttoml(\n700                 \"\"\"\n701                 [tool.pytest.ini_options]\n702                 paths=[\"hello\", \"world/sub.py\"]\n703             \"\"\"\n704             )\n705         config = pytester.parseconfig()\n706         values = config.getini(\"paths\")\n707         assert len(values) == 2\n708         assert values[0] == inipath.parent.joinpath(\"hello\")\n709         assert values[1] == inipath.parent.joinpath(\"world/sub.py\")\n710         pytest.raises(ValueError, config.getini, \"other\")\n711 \n712     def make_conftest_for_args(self, pytester: Pytester) -> None:\n713         pytester.makeconftest(\n714             \"\"\"\n715             def pytest_addoption(parser):\n716                 parser.addini(\"args\", \"new args\", type=\"args\")\n717                 parser.addini(\"a2\", \"\", \"args\", default=\"1 2 3\".split())\n718         \"\"\"\n719         )\n720 \n721     def test_addini_args_ini_files(self, pytester: Pytester) -> None:\n722         self.make_conftest_for_args(pytester)\n723         pytester.makeini(\n724             \"\"\"\n725             [pytest]\n726             args=123 \"123 hello\" \"this\"\n727             \"\"\"\n728         )\n729         self.check_config_args(pytester)\n730 \n731     def test_addini_args_pyproject_toml(self, pytester: Pytester) -> None:\n732         self.make_conftest_for_args(pytester)\n733         pytester.makepyprojecttoml(\n734             \"\"\"\n735             [tool.pytest.ini_options]\n736             args = [\"123\", \"123 hello\", \"this\"]\n737             \"\"\"\n738         )\n739         self.check_config_args(pytester)\n740 \n741     def check_config_args(self, pytester: Pytester) -> None:\n742         config = pytester.parseconfig()\n743         values = config.getini(\"args\")\n744         assert values == [\"123\", \"123 hello\", \"this\"]\n745         values = config.getini(\"a2\")\n746         assert values == list(\"123\")\n747 \n748     def make_conftest_for_linelist(self, pytester: Pytester) -> None:\n749         pytester.makeconftest(\n750             \"\"\"\n751             def pytest_addoption(parser):\n752                 parser.addini(\"xy\", \"\", type=\"linelist\")\n753                 parser.addini(\"a2\", \"\", \"linelist\")\n754         \"\"\"\n755         )\n756 \n757     def test_addini_linelist_ini_files(self, pytester: Pytester) -> None:\n758         self.make_conftest_for_linelist(pytester)\n759         pytester.makeini(\n760             \"\"\"\n761             [pytest]\n762             xy= 123 345\n763                 second line\n764         \"\"\"\n765         )\n766         self.check_config_linelist(pytester)\n767 \n768     def test_addini_linelist_pprojecttoml(self, pytester: Pytester) -> None:\n769         self.make_conftest_for_linelist(pytester)\n770         pytester.makepyprojecttoml(\n771             \"\"\"\n772             [tool.pytest.ini_options]\n773             xy = [\"123 345\", \"second line\"]\n774         \"\"\"\n775         )\n776         self.check_config_linelist(pytester)\n777 \n778     def check_config_linelist(self, pytester: Pytester) -> None:\n779         config = pytester.parseconfig()\n780         values = config.getini(\"xy\")\n781         assert len(values) == 2\n782         assert values == [\"123 345\", \"second line\"]\n783         values = config.getini(\"a2\")\n784         assert values == []\n785 \n786     @pytest.mark.parametrize(\n787         \"str_val, bool_val\", [(\"True\", True), (\"no\", False), (\"no-ini\", True)]\n788     )\n789     def test_addini_bool(\n790         self, pytester: Pytester, str_val: str, bool_val: bool\n791     ) -> None:\n792         pytester.makeconftest(\n793             \"\"\"\n794             def pytest_addoption(parser):\n795                 parser.addini(\"strip\", \"\", type=\"bool\", default=True)\n796         \"\"\"\n797         )\n798         if str_val != \"no-ini\":\n799             pytester.makeini(\n800                 \"\"\"\n801                 [pytest]\n802                 strip=%s\n803             \"\"\"\n804                 % str_val\n805             )\n806         config = pytester.parseconfig()\n807         assert config.getini(\"strip\") is bool_val\n808 \n809     def test_addinivalue_line_existing(self, pytester: Pytester) -> None:\n810         pytester.makeconftest(\n811             \"\"\"\n812             def pytest_addoption(parser):\n813                 parser.addini(\"xy\", \"\", type=\"linelist\")\n814         \"\"\"\n815         )\n816         pytester.makeini(\n817             \"\"\"\n818             [pytest]\n819             xy= 123\n820         \"\"\"\n821         )\n822         config = pytester.parseconfig()\n823         values = config.getini(\"xy\")\n824         assert len(values) == 1\n825         assert values == [\"123\"]\n826         config.addinivalue_line(\"xy\", \"456\")\n827         values = config.getini(\"xy\")\n828         assert len(values) == 2\n829         assert values == [\"123\", \"456\"]\n830 \n831     def test_addinivalue_line_new(self, pytester: Pytester) -> None:\n832         pytester.makeconftest(\n833             \"\"\"\n834             def pytest_addoption(parser):\n835                 parser.addini(\"xy\", \"\", type=\"linelist\")\n836         \"\"\"\n837         )\n838         config = pytester.parseconfig()\n839         assert not config.getini(\"xy\")\n840         config.addinivalue_line(\"xy\", \"456\")\n841         values = config.getini(\"xy\")\n842         assert len(values) == 1\n843         assert values == [\"456\"]\n844         config.addinivalue_line(\"xy\", \"123\")\n845         values = config.getini(\"xy\")\n846         assert len(values) == 2\n847         assert values == [\"456\", \"123\"]\n848 \n849     def test_confcutdir_check_isdir(self, pytester: Pytester) -> None:\n850         \"\"\"Give an error if --confcutdir is not a valid directory (#2078)\"\"\"\n851         exp_match = r\"^--confcutdir must be a directory, given: \"\n852         with pytest.raises(pytest.UsageError, match=exp_match):\n853             pytester.parseconfig(\"--confcutdir\", pytester.path.joinpath(\"file\"))\n854         with pytest.raises(pytest.UsageError, match=exp_match):\n855             pytester.parseconfig(\"--confcutdir\", pytester.path.joinpath(\"nonexistent\"))\n856 \n857         p = pytester.mkdir(\"dir\")\n858         config = pytester.parseconfig(\"--confcutdir\", p)\n859         assert config.getoption(\"confcutdir\") == str(p)\n860 \n861     @pytest.mark.parametrize(\n862         \"names, expected\",\n863         [\n864             # dist-info based distributions root are files as will be put in PYTHONPATH\n865             ([\"bar.py\"], [\"bar\"]),\n866             ([\"foo/bar.py\"], [\"bar\"]),\n867             ([\"foo/bar.pyc\"], []),\n868             ([\"foo/__init__.py\"], [\"foo\"]),\n869             ([\"bar/__init__.py\", \"xz.py\"], [\"bar\", \"xz\"]),\n870             ([\"setup.py\"], []),\n871             # egg based distributions root contain the files from the dist root\n872             ([\"src/bar/__init__.py\"], [\"bar\"]),\n873             ([\"src/bar/__init__.py\", \"setup.py\"], [\"bar\"]),\n874             ([\"source/python/bar/__init__.py\", \"setup.py\"], [\"bar\"]),\n875             # editable installation finder modules\n876             ([\"__editable___xyz_finder.py\"], []),\n877             ([\"bar/__init__.py\", \"__editable___xyz_finder.py\"], [\"bar\"]),\n878         ],\n879     )\n880     def test_iter_rewritable_modules(self, names, expected) -> None:\n881         assert list(_iter_rewritable_modules(names)) == expected\n882 \n883 \n884 class TestConfigFromdictargs:\n885     def test_basic_behavior(self, _sys_snapshot) -> None:\n886         option_dict = {\"verbose\": 444, \"foo\": \"bar\", \"capture\": \"no\"}\n887         args = [\"a\", \"b\"]\n888 \n889         config = Config.fromdictargs(option_dict, args)\n890         with pytest.raises(AssertionError):\n891             config.parse([\"should refuse to parse again\"])\n892         assert config.option.verbose == 444\n893         assert config.option.foo == \"bar\"\n894         assert config.option.capture == \"no\"\n895         assert config.args == args\n896 \n897     def test_invocation_params_args(self, _sys_snapshot) -> None:\n898         \"\"\"Show that fromdictargs can handle args in their \"orig\" format\"\"\"\n899         option_dict: Dict[str, object] = {}\n900         args = [\"-vvvv\", \"-s\", \"a\", \"b\"]\n901 \n902         config = Config.fromdictargs(option_dict, args)\n903         assert config.args == [\"a\", \"b\"]\n904         assert config.invocation_params.args == tuple(args)\n905         assert config.option.verbose == 4\n906         assert config.option.capture == \"no\"\n907 \n908     def test_inifilename(self, tmp_path: Path) -> None:\n909         d1 = tmp_path.joinpath(\"foo\")\n910         d1.mkdir()\n911         p1 = d1.joinpath(\"bar.ini\")\n912         p1.touch()\n913         p1.write_text(\n914             textwrap.dedent(\n915                 \"\"\"\\\n916                 [pytest]\n917                 name = value\n918                 \"\"\"\n919             ),\n920             encoding=\"utf-8\",\n921         )\n922 \n923         inifilename = \"../../foo/bar.ini\"\n924         option_dict = {\"inifilename\": inifilename, \"capture\": \"no\"}\n925 \n926         cwd = tmp_path.joinpath(\"a/b\")\n927         cwd.mkdir(parents=True)\n928         p2 = cwd.joinpath(\"pytest.ini\")\n929         p2.touch()\n930         p2.write_text(\n931             textwrap.dedent(\n932                 \"\"\"\\\n933                 [pytest]\n934                 name = wrong-value\n935                 should_not_be_set = true\n936                 \"\"\"\n937             ),\n938             encoding=\"utf-8\",\n939         )\n940         with MonkeyPatch.context() as mp:\n941             mp.chdir(cwd)\n942             config = Config.fromdictargs(option_dict, ())\n943             inipath = absolutepath(inifilename)\n944 \n945         assert config.args == [str(cwd)]\n946         assert config.option.inifilename == inifilename\n947         assert config.option.capture == \"no\"\n948 \n949         # this indicates this is the file used for getting configuration values\n950         assert config.inipath == inipath\n951         assert config.inicfg.get(\"name\") == \"value\"\n952         assert config.inicfg.get(\"should_not_be_set\") is None\n953 \n954 \n955 def test_options_on_small_file_do_not_blow_up(pytester: Pytester) -> None:\n956     def runfiletest(opts: Sequence[str]) -> None:\n957         reprec = pytester.inline_run(*opts)\n958         passed, skipped, failed = reprec.countoutcomes()\n959         assert failed == 2\n960         assert skipped == passed == 0\n961 \n962     path = str(\n963         pytester.makepyfile(\n964             \"\"\"\n965         def test_f1(): assert 0\n966         def test_f2(): assert 0\n967     \"\"\"\n968         )\n969     )\n970 \n971     runfiletest([path])\n972     runfiletest([\"-l\", path])\n973     runfiletest([\"-s\", path])\n974     runfiletest([\"--tb=no\", path])\n975     runfiletest([\"--tb=short\", path])\n976     runfiletest([\"--tb=long\", path])\n977     runfiletest([\"--fulltrace\", path])\n978     runfiletest([\"--traceconfig\", path])\n979     runfiletest([\"-v\", path])\n980     runfiletest([\"-v\", \"-v\", path])\n981 \n982 \n983 def test_preparse_ordering_with_setuptools(\n984     pytester: Pytester, monkeypatch: MonkeyPatch\n985 ) -> None:\n986     monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n987 \n988     class EntryPoint:\n989         name = \"mytestplugin\"\n990         group = \"pytest11\"\n991 \n992         def load(self):\n993             class PseudoPlugin:\n994                 x = 42\n995 \n996             return PseudoPlugin()\n997 \n998     class Dist:\n999         files = ()\n1000         metadata = {\"name\": \"foo\"}\n1001         entry_points = (EntryPoint(),)\n1002 \n1003     def my_dists():\n1004         return (Dist,)\n1005 \n1006     monkeypatch.setattr(importlib.metadata, \"distributions\", my_dists)\n1007     pytester.makeconftest(\n1008         \"\"\"\n1009         pytest_plugins = \"mytestplugin\",\n1010     \"\"\"\n1011     )\n1012     monkeypatch.setenv(\"PYTEST_PLUGINS\", \"mytestplugin\")\n1013     config = pytester.parseconfig()\n1014     plugin = config.pluginmanager.getplugin(\"mytestplugin\")\n1015     assert plugin.x == 42\n1016 \n1017 \n1018 def test_setuptools_importerror_issue1479(\n1019     pytester: Pytester, monkeypatch: MonkeyPatch\n1020 ) -> None:\n1021     monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n1022 \n1023     class DummyEntryPoint:\n1024         name = \"mytestplugin\"\n1025         group = \"pytest11\"\n1026 \n1027         def load(self):\n1028             raise ImportError(\"Don't hide me!\")\n1029 \n1030     class Distribution:\n1031         version = \"1.0\"\n1032         files = (\"foo.txt\",)\n1033         metadata = {\"name\": \"foo\"}\n1034         entry_points = (DummyEntryPoint(),)\n1035 \n1036     def distributions():\n1037         return (Distribution(),)\n1038 \n1039     monkeypatch.setattr(importlib.metadata, \"distributions\", distributions)\n1040     with pytest.raises(ImportError):\n1041         pytester.parseconfig()\n1042 \n1043 \n1044 def test_importlib_metadata_broken_distribution(\n1045     pytester: Pytester, monkeypatch: MonkeyPatch\n1046 ) -> None:\n1047     \"\"\"Integration test for broken distributions with 'files' metadata being None (#5389)\"\"\"\n1048     monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n1049 \n1050     class DummyEntryPoint:\n1051         name = \"mytestplugin\"\n1052         group = \"pytest11\"\n1053 \n1054         def load(self):\n1055             return object()\n1056 \n1057     class Distribution:\n1058         version = \"1.0\"\n1059         files = None\n1060         metadata = {\"name\": \"foo\"}\n1061         entry_points = (DummyEntryPoint(),)\n1062 \n1063     def distributions():\n1064         return (Distribution(),)\n1065 \n1066     monkeypatch.setattr(importlib.metadata, \"distributions\", distributions)\n1067     pytester.parseconfig()\n1068 \n1069 \n1070 @pytest.mark.parametrize(\"block_it\", [True, False])\n1071 def test_plugin_preparse_prevents_setuptools_loading(\n1072     pytester: Pytester, monkeypatch: MonkeyPatch, block_it: bool\n1073 ) -> None:\n1074     monkeypatch.delenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", raising=False)\n1075 \n1076     plugin_module_placeholder = object()\n1077 \n1078     class DummyEntryPoint:\n1079         name = \"mytestplugin\"\n1080         group = \"pytest11\"\n1081 \n1082         def load(self):\n1083             return plugin_module_placeholder\n1084 \n1085     class Distribution:\n1086         version = \"1.0\"\n1087         files = (\"foo.txt\",)\n1088         metadata = {\"name\": \"foo\"}\n1089         entry_points = (DummyEntryPoint(),)\n1090 \n1091     def distributions():\n1092         return (Distribution(),)\n1093 \n1094     monkeypatch.setattr(importlib.metadata, \"distributions\", distributions)\n1095     args = (\"-p\", \"no:mytestplugin\") if block_it else ()\n1096     config = pytester.parseconfig(*args)\n1097     config.pluginmanager.import_plugin(\"mytestplugin\")\n1098     if block_it:\n1099         assert \"mytestplugin\" not in sys.modules\n1100         assert config.pluginmanager.get_plugin(\"mytestplugin\") is None\n1101     else:\n1102         assert (\n1103             config.pluginmanager.get_plugin(\"mytestplugin\") is plugin_module_placeholder\n1104         )\n1105 \n1106 \n1107 @pytest.mark.parametrize(\n1108     \"parse_args,should_load\", [((\"-p\", \"mytestplugin\"), True), ((), False)]\n1109 )\n1110 def test_disable_plugin_autoload(\n1111     pytester: Pytester,\n1112     monkeypatch: MonkeyPatch,\n1113     parse_args: Union[Tuple[str, str], Tuple[()]],\n1114     should_load: bool,\n1115 ) -> None:\n1116     class DummyEntryPoint:\n1117         project_name = name = \"mytestplugin\"\n1118         group = \"pytest11\"\n1119         version = \"1.0\"\n1120 \n1121         def load(self):\n1122             return sys.modules[self.name]\n1123 \n1124     class Distribution:\n1125         metadata = {\"name\": \"foo\"}\n1126         entry_points = (DummyEntryPoint(),)\n1127         files = ()\n1128 \n1129     class PseudoPlugin:\n1130         x = 42\n1131 \n1132         attrs_used = []\n1133 \n1134         def __getattr__(self, name):\n1135             assert name == \"__loader__\"\n1136             self.attrs_used.append(name)\n1137             return object()\n1138 \n1139     def distributions():\n1140         return (Distribution(),)\n1141 \n1142     monkeypatch.setenv(\"PYTEST_DISABLE_PLUGIN_AUTOLOAD\", \"1\")\n1143     monkeypatch.setattr(importlib.metadata, \"distributions\", distributions)\n1144     monkeypatch.setitem(sys.modules, \"mytestplugin\", PseudoPlugin())  # type: ignore[misc]\n1145     config = pytester.parseconfig(*parse_args)\n1146     has_loaded = config.pluginmanager.get_plugin(\"mytestplugin\") is not None\n1147     assert has_loaded == should_load\n1148     if should_load:\n1149         assert PseudoPlugin.attrs_used == [\"__loader__\"]\n1150     else:\n1151         assert PseudoPlugin.attrs_used == []\n1152 \n1153 \n1154 def test_plugin_loading_order(pytester: Pytester) -> None:\n1155     \"\"\"Test order of plugin loading with `-p`.\"\"\"\n1156     p1 = pytester.makepyfile(\n1157         \"\"\"\n1158         def test_terminal_plugin(request):\n1159             import myplugin\n1160             assert myplugin.terminal_plugin == [False, True]\n1161         \"\"\",\n1162         **{\n1163             \"myplugin\": \"\"\"\n1164             terminal_plugin = []\n1165 \n1166             def pytest_configure(config):\n1167                 terminal_plugin.append(bool(config.pluginmanager.get_plugin(\"terminalreporter\")))\n1168 \n1169             def pytest_sessionstart(session):\n1170                 config = session.config\n1171                 terminal_plugin.append(bool(config.pluginmanager.get_plugin(\"terminalreporter\")))\n1172             \"\"\"\n1173         },\n1174     )\n1175     pytester.syspathinsert()\n1176     result = pytester.runpytest(\"-p\", \"myplugin\", str(p1))\n1177     assert result.ret == 0\n1178 \n1179 \n1180 def test_cmdline_processargs_simple(pytester: Pytester) -> None:\n1181     pytester.makeconftest(\n1182         \"\"\"\n1183         def pytest_cmdline_preparse(args):\n1184             args.append(\"-h\")\n1185     \"\"\"\n1186     )\n1187     result = pytester.runpytest(\"-Wignore::pytest.PytestRemovedIn8Warning\")\n1188     result.stdout.fnmatch_lines([\"*pytest*\", \"*-h*\"])\n1189 \n1190 \n1191 def test_invalid_options_show_extra_information(pytester: Pytester) -> None:\n1192     \"\"\"Display extra information when pytest exits due to unrecognized\n1193     options in the command-line.\"\"\"\n1194     pytester.makeini(\n1195         \"\"\"\n1196         [pytest]\n1197         addopts = --invalid-option\n1198     \"\"\"\n1199     )\n1200     result = pytester.runpytest()\n1201     result.stderr.fnmatch_lines(\n1202         [\n1203             \"*error: unrecognized arguments: --invalid-option*\",\n1204             \"*  inifile: %s*\" % pytester.path.joinpath(\"tox.ini\"),\n1205             \"*  rootdir: %s*\" % pytester.path,\n1206         ]\n1207     )\n1208 \n1209 \n1210 @pytest.mark.parametrize(\n1211     \"args\",\n1212     [\n1213         [\"dir1\", \"dir2\", \"-v\"],\n1214         [\"dir1\", \"-v\", \"dir2\"],\n1215         [\"dir2\", \"-v\", \"dir1\"],\n1216         [\"-v\", \"dir2\", \"dir1\"],\n1217     ],\n1218 )\n1219 def test_consider_args_after_options_for_rootdir(\n1220     pytester: Pytester, args: List[str]\n1221 ) -> None:\n1222     \"\"\"\n1223     Consider all arguments in the command-line for rootdir\n1224     discovery, even if they happen to occur after an option. #949\n1225     \"\"\"\n1226     # replace \"dir1\" and \"dir2\" from \"args\" into their real directory\n1227     root = pytester.mkdir(\"myroot\")\n1228     d1 = root.joinpath(\"dir1\")\n1229     d1.mkdir()\n1230     d2 = root.joinpath(\"dir2\")\n1231     d2.mkdir()\n1232     for i, arg in enumerate(args):\n1233         if arg == \"dir1\":\n1234             args[i] = str(d1)\n1235         elif arg == \"dir2\":\n1236             args[i] = str(d2)\n1237     with MonkeyPatch.context() as mp:\n1238         mp.chdir(root)\n1239         result = pytester.runpytest(*args)\n1240     result.stdout.fnmatch_lines([\"*rootdir: *myroot\"])\n1241 \n1242 \n1243 def test_toolongargs_issue224(pytester: Pytester) -> None:\n1244     result = pytester.runpytest(\"-m\", \"hello\" * 500)\n1245     assert result.ret == ExitCode.NO_TESTS_COLLECTED\n1246 \n1247 \n1248 def test_config_in_subdirectory_colon_command_line_issue2148(\n1249     pytester: Pytester,\n1250 ) -> None:\n1251     conftest_source = \"\"\"\n1252         def pytest_addoption(parser):\n1253             parser.addini('foo', 'foo')\n1254     \"\"\"\n1255 \n1256     pytester.makefile(\n1257         \".ini\",\n1258         **{\"pytest\": \"[pytest]\\nfoo = root\", \"subdir/pytest\": \"[pytest]\\nfoo = subdir\"},\n1259     )\n1260 \n1261     pytester.makepyfile(\n1262         **{\n1263             \"conftest\": conftest_source,\n1264             \"subdir/conftest\": conftest_source,\n1265             \"subdir/test_foo\": \"\"\"\\\n1266             def test_foo(pytestconfig):\n1267                 assert pytestconfig.getini('foo') == 'subdir'\n1268             \"\"\",\n1269         }\n1270     )\n1271 \n1272     result = pytester.runpytest(\"subdir/test_foo.py::test_foo\")\n1273     assert result.ret == 0\n1274 \n1275 \n1276 def test_notify_exception(pytester: Pytester, capfd) -> None:\n1277     config = pytester.parseconfig()\n1278     with pytest.raises(ValueError) as excinfo:\n1279         raise ValueError(1)\n1280     config.notify_exception(excinfo, config.option)\n1281     _, err = capfd.readouterr()\n1282     assert \"ValueError\" in err\n1283 \n1284     class A:\n1285         def pytest_internalerror(self):\n1286             return True\n1287 \n1288     config.pluginmanager.register(A())\n1289     config.notify_exception(excinfo, config.option)\n1290     _, err = capfd.readouterr()\n1291     assert not err\n1292 \n1293     config = pytester.parseconfig(\"-p\", \"no:terminal\")\n1294     with pytest.raises(ValueError) as excinfo:\n1295         raise ValueError(1)\n1296     config.notify_exception(excinfo, config.option)\n1297     _, err = capfd.readouterr()\n1298     assert \"ValueError\" in err\n1299 \n1300 \n1301 def test_no_terminal_discovery_error(pytester: Pytester) -> None:\n1302     pytester.makepyfile(\"raise TypeError('oops!')\")\n1303     result = pytester.runpytest(\"-p\", \"no:terminal\", \"--collect-only\")\n1304     assert result.ret == ExitCode.INTERRUPTED\n1305 \n1306 \n1307 def test_load_initial_conftest_last_ordering(_config_for_test):\n1308     pm = _config_for_test.pluginmanager\n1309 \n1310     class My:\n1311         def pytest_load_initial_conftests(self):\n1312             pass\n1313 \n1314     m = My()\n1315     pm.register(m)\n1316     hc = pm.hook.pytest_load_initial_conftests\n1317     hookimpls = [\n1318         (\n1319             hookimpl.function.__module__,\n1320             \"wrapper\" if hookimpl.hookwrapper else \"nonwrapper\",\n1321         )\n1322         for hookimpl in hc.get_hookimpls()\n1323     ]\n1324     assert hookimpls == [\n1325         (\"_pytest.config\", \"nonwrapper\"),\n1326         (m.__module__, \"nonwrapper\"),\n1327         (\"_pytest.legacypath\", \"nonwrapper\"),\n1328         (\"_pytest.python_path\", \"nonwrapper\"),\n1329         (\"_pytest.capture\", \"wrapper\"),\n1330         (\"_pytest.warnings\", \"wrapper\"),\n1331     ]\n1332 \n1333 \n1334 def test_get_plugin_specs_as_list() -> None:\n1335     def exp_match(val: object) -> str:\n1336         return (\n1337             \"Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %s\"\n1338             % re.escape(repr(val))\n1339         )\n1340 \n1341     with pytest.raises(pytest.UsageError, match=exp_match({\"foo\"})):\n1342         _get_plugin_specs_as_list({\"foo\"})  # type: ignore[arg-type]\n1343     with pytest.raises(pytest.UsageError, match=exp_match({})):\n1344         _get_plugin_specs_as_list(dict())  # type: ignore[arg-type]\n1345 \n1346     assert _get_plugin_specs_as_list(None) == []\n1347     assert _get_plugin_specs_as_list(\"\") == []\n1348     assert _get_plugin_specs_as_list(\"foo\") == [\"foo\"]\n1349     assert _get_plugin_specs_as_list(\"foo,bar\") == [\"foo\", \"bar\"]\n1350     assert _get_plugin_specs_as_list([\"foo\", \"bar\"]) == [\"foo\", \"bar\"]\n1351     assert _get_plugin_specs_as_list((\"foo\", \"bar\")) == [\"foo\", \"bar\"]\n1352 \n1353 \n1354 def test_collect_pytest_prefix_bug_integration(pytester: Pytester) -> None:\n1355     \"\"\"Integration test for issue #3775\"\"\"\n1356     p = pytester.copy_example(\"config/collect_pytest_prefix\")\n1357     result = pytester.runpytest(p)\n1358     result.stdout.fnmatch_lines([\"* 1 passed *\"])\n1359 \n1360 \n1361 def test_collect_pytest_prefix_bug(pytestconfig):\n1362     \"\"\"Ensure we collect only actual functions from conftest files (#3775)\"\"\"\n1363 \n1364     class Dummy:\n1365         class pytest_something:\n1366             pass\n1367 \n1368     pm = pytestconfig.pluginmanager\n1369     assert pm.parse_hookimpl_opts(Dummy(), \"pytest_something\") is None\n1370 \n1371 \n1372 class TestRootdir:\n1373     def test_simple_noini(self, tmp_path: Path, monkeypatch: MonkeyPatch) -> None:\n1374         assert get_common_ancestor([tmp_path]) == tmp_path\n1375         a = tmp_path / \"a\"\n1376         a.mkdir()\n1377         assert get_common_ancestor([a, tmp_path]) == tmp_path\n1378         assert get_common_ancestor([tmp_path, a]) == tmp_path\n1379         monkeypatch.chdir(tmp_path)\n1380         assert get_common_ancestor([]) == tmp_path\n1381         no_path = tmp_path / \"does-not-exist\"\n1382         assert get_common_ancestor([no_path]) == tmp_path\n1383         assert get_common_ancestor([no_path / \"a\"]) == tmp_path\n1384 \n1385     @pytest.mark.parametrize(\n1386         \"name, contents\",\n1387         [\n1388             pytest.param(\"pytest.ini\", \"[pytest]\\nx=10\", id=\"pytest.ini\"),\n1389             pytest.param(\n1390                 \"pyproject.toml\", \"[tool.pytest.ini_options]\\nx=10\", id=\"pyproject.toml\"\n1391             ),\n1392             pytest.param(\"tox.ini\", \"[pytest]\\nx=10\", id=\"tox.ini\"),\n1393             pytest.param(\"setup.cfg\", \"[tool:pytest]\\nx=10\", id=\"setup.cfg\"),\n1394         ],\n1395     )\n1396     def test_with_ini(self, tmp_path: Path, name: str, contents: str) -> None:\n1397         inipath = tmp_path / name\n1398         inipath.write_text(contents, encoding=\"utf-8\")\n1399 \n1400         a = tmp_path / \"a\"\n1401         a.mkdir()\n1402         b = a / \"b\"\n1403         b.mkdir()\n1404         for args in ([str(tmp_path)], [str(a)], [str(b)]):\n1405             rootpath, parsed_inipath, _ = determine_setup(None, args)\n1406             assert rootpath == tmp_path\n1407             assert parsed_inipath == inipath\n1408         rootpath, parsed_inipath, ini_config = determine_setup(None, [str(b), str(a)])\n1409         assert rootpath == tmp_path\n1410         assert parsed_inipath == inipath\n1411         assert ini_config == {\"x\": \"10\"}\n1412 \n1413     @pytest.mark.parametrize(\"name\", [\"setup.cfg\", \"tox.ini\"])\n1414     def test_pytestini_overrides_empty_other(self, tmp_path: Path, name: str) -> None:\n1415         inipath = tmp_path / \"pytest.ini\"\n1416         inipath.touch()\n1417         a = tmp_path / \"a\"\n1418         a.mkdir()\n1419         (a / name).touch()\n1420         rootpath, parsed_inipath, _ = determine_setup(None, [str(a)])\n1421         assert rootpath == tmp_path\n1422         assert parsed_inipath == inipath\n1423 \n1424     def test_setuppy_fallback(self, tmp_path: Path) -> None:\n1425         a = tmp_path / \"a\"\n1426         a.mkdir()\n1427         (a / \"setup.cfg\").touch()\n1428         (tmp_path / \"setup.py\").touch()\n1429         rootpath, inipath, inicfg = determine_setup(None, [str(a)])\n1430         assert rootpath == tmp_path\n1431         assert inipath is None\n1432         assert inicfg == {}\n1433 \n1434     def test_nothing(self, tmp_path: Path, monkeypatch: MonkeyPatch) -> None:\n1435         monkeypatch.chdir(tmp_path)\n1436         rootpath, inipath, inicfg = determine_setup(None, [str(tmp_path)])\n1437         assert rootpath == tmp_path\n1438         assert inipath is None\n1439         assert inicfg == {}\n1440 \n1441     @pytest.mark.parametrize(\n1442         \"name, contents\",\n1443         [\n1444             # pytest.param(\"pytest.ini\", \"[pytest]\\nx=10\", id=\"pytest.ini\"),\n1445             pytest.param(\n1446                 \"pyproject.toml\", \"[tool.pytest.ini_options]\\nx=10\", id=\"pyproject.toml\"\n1447             ),\n1448             # pytest.param(\"tox.ini\", \"[pytest]\\nx=10\", id=\"tox.ini\"),\n1449             # pytest.param(\"setup.cfg\", \"[tool:pytest]\\nx=10\", id=\"setup.cfg\"),\n1450         ],\n1451     )\n1452     def test_with_specific_inifile(\n1453         self, tmp_path: Path, name: str, contents: str\n1454     ) -> None:\n1455         p = tmp_path / name\n1456         p.touch()\n1457         p.write_text(contents, encoding=\"utf-8\")\n1458         rootpath, inipath, ini_config = determine_setup(str(p), [str(tmp_path)])\n1459         assert rootpath == tmp_path\n1460         assert inipath == p\n1461         assert ini_config == {\"x\": \"10\"}\n1462 \n1463     def test_explicit_config_file_sets_rootdir(\n1464         self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch\n1465     ) -> None:\n1466         tests_dir = tmp_path / \"tests\"\n1467         tests_dir.mkdir()\n1468 \n1469         monkeypatch.chdir(tmp_path)\n1470 \n1471         # No config file is explicitly given: rootdir is determined to be cwd.\n1472         rootpath, found_inipath, *_ = determine_setup(None, [str(tests_dir)])\n1473         assert rootpath == tmp_path\n1474         assert found_inipath is None\n1475 \n1476         # Config file is explicitly given: rootdir is determined to be inifile's directory.\n1477         inipath = tmp_path / \"pytest.ini\"\n1478         inipath.touch()\n1479         rootpath, found_inipath, *_ = determine_setup(str(inipath), [str(tests_dir)])\n1480         assert rootpath == tmp_path\n1481         assert found_inipath == inipath\n1482 \n1483     def test_with_arg_outside_cwd_without_inifile(\n1484         self, tmp_path: Path, monkeypatch: MonkeyPatch\n1485     ) -> None:\n1486         monkeypatch.chdir(tmp_path)\n1487         a = tmp_path / \"a\"\n1488         a.mkdir()\n1489         b = tmp_path / \"b\"\n1490         b.mkdir()\n1491         rootpath, inifile, _ = determine_setup(None, [str(a), str(b)])\n1492         assert rootpath == tmp_path\n1493         assert inifile is None\n1494 \n1495     def test_with_arg_outside_cwd_with_inifile(self, tmp_path: Path) -> None:\n1496         a = tmp_path / \"a\"\n1497         a.mkdir()\n1498         b = tmp_path / \"b\"\n1499         b.mkdir()\n1500         inipath = a / \"pytest.ini\"\n1501         inipath.touch()\n1502         rootpath, parsed_inipath, _ = determine_setup(None, [str(a), str(b)])\n1503         assert rootpath == a\n1504         assert inipath == parsed_inipath\n1505 \n1506     @pytest.mark.parametrize(\"dirs\", ([], [\"does-not-exist\"], [\"a/does-not-exist\"]))\n1507     def test_with_non_dir_arg(\n1508         self, dirs: Sequence[str], tmp_path: Path, monkeypatch: MonkeyPatch\n1509     ) -> None:\n1510         monkeypatch.chdir(tmp_path)\n1511         rootpath, inipath, _ = determine_setup(None, dirs)\n1512         assert rootpath == tmp_path\n1513         assert inipath is None\n1514 \n1515     def test_with_existing_file_in_subdir(\n1516         self, tmp_path: Path, monkeypatch: MonkeyPatch\n1517     ) -> None:\n1518         a = tmp_path / \"a\"\n1519         a.mkdir()\n1520         (a / \"exists\").touch()\n1521         monkeypatch.chdir(tmp_path)\n1522         rootpath, inipath, _ = determine_setup(None, [\"a/exist\"])\n1523         assert rootpath == tmp_path\n1524         assert inipath is None\n1525 \n1526     def test_with_config_also_in_parent_directory(\n1527         self, tmp_path: Path, monkeypatch: MonkeyPatch\n1528     ) -> None:\n1529         \"\"\"Regression test for #7807.\"\"\"\n1530         (tmp_path / \"setup.cfg\").write_text(\"[tool:pytest]\\n\", \"utf-8\")\n1531         (tmp_path / \"myproject\").mkdir()\n1532         (tmp_path / \"myproject\" / \"setup.cfg\").write_text(\"[tool:pytest]\\n\", \"utf-8\")\n1533         (tmp_path / \"myproject\" / \"tests\").mkdir()\n1534         monkeypatch.chdir(tmp_path / \"myproject\")\n1535 \n1536         rootpath, inipath, _ = determine_setup(None, [\"tests/\"])\n1537 \n1538         assert rootpath == tmp_path / \"myproject\"\n1539         assert inipath == tmp_path / \"myproject\" / \"setup.cfg\"\n1540 \n1541 \n1542 class TestOverrideIniArgs:\n1543     @pytest.mark.parametrize(\"name\", \"setup.cfg tox.ini pytest.ini\".split())\n1544     def test_override_ini_names(self, pytester: Pytester, name: str) -> None:\n1545         section = \"[pytest]\" if name != \"setup.cfg\" else \"[tool:pytest]\"\n1546         pytester.path.joinpath(name).write_text(\n1547             textwrap.dedent(\n1548                 \"\"\"\n1549             {section}\n1550             custom = 1.0\"\"\".format(\n1551                     section=section\n1552                 )\n1553             ),\n1554             encoding=\"utf-8\",\n1555         )\n1556         pytester.makeconftest(\n1557             \"\"\"\n1558             def pytest_addoption(parser):\n1559                 parser.addini(\"custom\", \"\")\"\"\"\n1560         )\n1561         pytester.makepyfile(\n1562             \"\"\"\n1563             def test_pass(pytestconfig):\n1564                 ini_val = pytestconfig.getini(\"custom\")\n1565                 print('\\\\ncustom_option:%s\\\\n' % ini_val)\"\"\"\n1566         )\n1567 \n1568         result = pytester.runpytest(\"--override-ini\", \"custom=2.0\", \"-s\")\n1569         assert result.ret == 0\n1570         result.stdout.fnmatch_lines([\"custom_option:2.0\"])\n1571 \n1572         result = pytester.runpytest(\n1573             \"--override-ini\", \"custom=2.0\", \"--override-ini=custom=3.0\", \"-s\"\n1574         )\n1575         assert result.ret == 0\n1576         result.stdout.fnmatch_lines([\"custom_option:3.0\"])\n1577 \n1578     def test_override_ini_paths(self, pytester: Pytester) -> None:\n1579         pytester.makeconftest(\n1580             \"\"\"\n1581             def pytest_addoption(parser):\n1582                 parser.addini(\"paths\", \"my new ini value\", type=\"paths\")\"\"\"\n1583         )\n1584         pytester.makeini(\n1585             \"\"\"\n1586             [pytest]\n1587             paths=blah.py\"\"\"\n1588         )\n1589         pytester.makepyfile(\n1590             r\"\"\"\n1591             def test_overriden(pytestconfig):\n1592                 config_paths = pytestconfig.getini(\"paths\")\n1593                 print(config_paths)\n1594                 for cpf in config_paths:\n1595                     print('\\nuser_path:%s' % cpf.name)\n1596             \"\"\"\n1597         )\n1598         result = pytester.runpytest(\n1599             \"--override-ini\", \"paths=foo/bar1.py foo/bar2.py\", \"-s\"\n1600         )\n1601         result.stdout.fnmatch_lines([\"user_path:bar1.py\", \"user_path:bar2.py\"])\n1602 \n1603     def test_override_multiple_and_default(self, pytester: Pytester) -> None:\n1604         pytester.makeconftest(\n1605             \"\"\"\n1606             def pytest_addoption(parser):\n1607                 addini = parser.addini\n1608                 addini(\"custom_option_1\", \"\", default=\"o1\")\n1609                 addini(\"custom_option_2\", \"\", default=\"o2\")\n1610                 addini(\"custom_option_3\", \"\", default=False, type=\"bool\")\n1611                 addini(\"custom_option_4\", \"\", default=True, type=\"bool\")\"\"\"\n1612         )\n1613         pytester.makeini(\n1614             \"\"\"\n1615             [pytest]\n1616             custom_option_1=custom_option_1\n1617             custom_option_2=custom_option_2\n1618         \"\"\"\n1619         )\n1620         pytester.makepyfile(\n1621             \"\"\"\n1622             def test_multiple_options(pytestconfig):\n1623                 prefix = \"custom_option\"\n1624                 for x in range(1, 5):\n1625                     ini_value=pytestconfig.getini(\"%s_%d\" % (prefix, x))\n1626                     print('\\\\nini%d:%s' % (x, ini_value))\n1627         \"\"\"\n1628         )\n1629         result = pytester.runpytest(\n1630             \"--override-ini\",\n1631             \"custom_option_1=fulldir=/tmp/user1\",\n1632             \"-o\",\n1633             \"custom_option_2=url=/tmp/user2?a=b&d=e\",\n1634             \"-o\",\n1635             \"custom_option_3=True\",\n1636             \"-o\",\n1637             \"custom_option_4=no\",\n1638             \"-s\",\n1639         )\n1640         result.stdout.fnmatch_lines(\n1641             [\n1642                 \"ini1:fulldir=/tmp/user1\",\n1643                 \"ini2:url=/tmp/user2?a=b&d=e\",\n1644                 \"ini3:True\",\n1645                 \"ini4:False\",\n1646             ]\n1647         )\n1648 \n1649     def test_override_ini_usage_error_bad_style(self, pytester: Pytester) -> None:\n1650         pytester.makeini(\n1651             \"\"\"\n1652             [pytest]\n1653             xdist_strict=False\n1654         \"\"\"\n1655         )\n1656         result = pytester.runpytest(\"--override-ini\", \"xdist_strict\", \"True\")\n1657         result.stderr.fnmatch_lines(\n1658             [\n1659                 \"ERROR: -o/--override-ini expects option=value style (got: 'xdist_strict').\",\n1660             ]\n1661         )\n1662 \n1663     @pytest.mark.parametrize(\"with_ini\", [True, False])\n1664     def test_override_ini_handled_asap(\n1665         self, pytester: Pytester, with_ini: bool\n1666     ) -> None:\n1667         \"\"\"-o should be handled as soon as possible and always override what's in ini files (#2238)\"\"\"\n1668         if with_ini:\n1669             pytester.makeini(\n1670                 \"\"\"\n1671                 [pytest]\n1672                 python_files=test_*.py\n1673             \"\"\"\n1674             )\n1675         pytester.makepyfile(\n1676             unittest_ini_handle=\"\"\"\n1677             def test():\n1678                 pass\n1679         \"\"\"\n1680         )\n1681         result = pytester.runpytest(\"--override-ini\", \"python_files=unittest_*.py\")\n1682         result.stdout.fnmatch_lines([\"*1 passed in*\"])\n1683 \n1684     def test_addopts_before_initini(\n1685         self, monkeypatch: MonkeyPatch, _config_for_test, _sys_snapshot\n1686     ) -> None:\n1687         cache_dir = \".custom_cache\"\n1688         monkeypatch.setenv(\"PYTEST_ADDOPTS\", \"-o cache_dir=%s\" % cache_dir)\n1689         config = _config_for_test\n1690         config._preparse([], addopts=True)\n1691         assert config._override_ini == [\"cache_dir=%s\" % cache_dir]\n1692 \n1693     def test_addopts_from_env_not_concatenated(\n1694         self, monkeypatch: MonkeyPatch, _config_for_test\n1695     ) -> None:\n1696         \"\"\"PYTEST_ADDOPTS should not take values from normal args (#4265).\"\"\"\n1697         monkeypatch.setenv(\"PYTEST_ADDOPTS\", \"-o\")\n1698         config = _config_for_test\n1699         with pytest.raises(UsageError) as excinfo:\n1700             config._preparse([\"cache_dir=ignored\"], addopts=True)\n1701         assert (\n1702             \"error: argument -o/--override-ini: expected one argument (via PYTEST_ADDOPTS)\"\n1703             in excinfo.value.args[0]\n1704         )\n1705 \n1706     def test_addopts_from_ini_not_concatenated(self, pytester: Pytester) -> None:\n1707         \"\"\"`addopts` from ini should not take values from normal args (#4265).\"\"\"\n1708         pytester.makeini(\n1709             \"\"\"\n1710             [pytest]\n1711             addopts=-o\n1712         \"\"\"\n1713         )\n1714         result = pytester.runpytest(\"cache_dir=ignored\")\n1715         result.stderr.fnmatch_lines(\n1716             [\n1717                 \"%s: error: argument -o/--override-ini: expected one argument (via addopts config)\"\n1718                 % (pytester._request.config._parser.optparser.prog,)\n1719             ]\n1720         )\n1721         assert result.ret == _pytest.config.ExitCode.USAGE_ERROR\n1722 \n1723     def test_override_ini_does_not_contain_paths(\n1724         self, _config_for_test, _sys_snapshot\n1725     ) -> None:\n1726         \"\"\"Check that -o no longer swallows all options after it (#3103)\"\"\"\n1727         config = _config_for_test\n1728         config._preparse([\"-o\", \"cache_dir=/cache\", \"/some/test/path\"])\n1729         assert config._override_ini == [\"cache_dir=/cache\"]\n1730 \n1731     def test_multiple_override_ini_options(self, pytester: Pytester) -> None:\n1732         \"\"\"Ensure a file path following a '-o' option does not generate an error (#3103)\"\"\"\n1733         pytester.makepyfile(\n1734             **{\n1735                 \"conftest.py\": \"\"\"\n1736                 def pytest_addoption(parser):\n1737                     parser.addini('foo', default=None, help='some option')\n1738                     parser.addini('bar', default=None, help='some option')\n1739             \"\"\",\n1740                 \"test_foo.py\": \"\"\"\n1741                 def test(pytestconfig):\n1742                     assert pytestconfig.getini('foo') == '1'\n1743                     assert pytestconfig.getini('bar') == '0'\n1744             \"\"\",\n1745                 \"test_bar.py\": \"\"\"\n1746                 def test():\n1747                     assert False\n1748             \"\"\",\n1749             }\n1750         )\n1751         result = pytester.runpytest(\"-o\", \"foo=1\", \"-o\", \"bar=0\", \"test_foo.py\")\n1752         assert \"ERROR:\" not in result.stderr.str()\n1753         result.stdout.fnmatch_lines([\"collected 1 item\", \"*= 1 passed in *=\"])\n1754 \n1755 \n1756 def test_help_via_addopts(pytester: Pytester) -> None:\n1757     pytester.makeini(\n1758         \"\"\"\n1759         [pytest]\n1760         addopts = --unknown-option-should-allow-for-help --help\n1761     \"\"\"\n1762     )\n1763     result = pytester.runpytest()\n1764     assert result.ret == 0\n1765     result.stdout.fnmatch_lines(\n1766         [\n1767             \"usage: *\",\n1768             \"positional arguments:\",\n1769             # Displays full/default help.\n1770             \"to see available markers type: pytest --markers\",\n1771         ]\n1772     )\n1773 \n1774 \n1775 def test_help_and_version_after_argument_error(pytester: Pytester) -> None:\n1776     pytester.makeconftest(\n1777         \"\"\"\n1778         def validate(arg):\n1779             raise argparse.ArgumentTypeError(\"argerror\")\n1780 \n1781         def pytest_addoption(parser):\n1782             group = parser.getgroup('cov')\n1783             group.addoption(\n1784                 \"--invalid-option-should-allow-for-help\",\n1785                 type=validate,\n1786             )\n1787         \"\"\"\n1788     )\n1789     pytester.makeini(\n1790         \"\"\"\n1791         [pytest]\n1792         addopts = --invalid-option-should-allow-for-help\n1793     \"\"\"\n1794     )\n1795     result = pytester.runpytest(\"--help\")\n1796     result.stdout.fnmatch_lines(\n1797         [\n1798             \"usage: *\",\n1799             \"positional arguments:\",\n1800             \"NOTE: displaying only minimal help due to UsageError.\",\n1801         ]\n1802     )\n1803     result.stderr.fnmatch_lines(\n1804         [\n1805             \"ERROR: usage: *\",\n1806             \"%s: error: argument --invalid-option-should-allow-for-help: expected one argument\"\n1807             % (pytester._request.config._parser.optparser.prog,),\n1808         ]\n1809     )\n1810     # Does not display full/default help.\n1811     assert \"to see available markers type: pytest --markers\" not in result.stdout.lines\n1812     assert result.ret == ExitCode.USAGE_ERROR\n1813 \n1814     result = pytester.runpytest(\"--version\")\n1815     result.stdout.fnmatch_lines([f\"pytest {pytest.__version__}\"])\n1816     assert result.ret == ExitCode.USAGE_ERROR\n1817 \n1818 \n1819 def test_help_formatter_uses_py_get_terminal_width(monkeypatch: MonkeyPatch) -> None:\n1820     from _pytest.config.argparsing import DropShorterLongHelpFormatter\n1821 \n1822     monkeypatch.setenv(\"COLUMNS\", \"90\")\n1823     formatter = DropShorterLongHelpFormatter(\"prog\")\n1824     assert formatter._width == 90\n1825 \n1826     monkeypatch.setattr(\"_pytest._io.get_terminal_width\", lambda: 160)\n1827     formatter = DropShorterLongHelpFormatter(\"prog\")\n1828     assert formatter._width == 160\n1829 \n1830     formatter = DropShorterLongHelpFormatter(\"prog\", width=42)\n1831     assert formatter._width == 42\n1832 \n1833 \n1834 def test_config_does_not_load_blocked_plugin_from_args(pytester: Pytester) -> None:\n1835     \"\"\"This tests that pytest's config setup handles \"-p no:X\".\"\"\"\n1836     p = pytester.makepyfile(\"def test(capfd): pass\")\n1837     result = pytester.runpytest(str(p), \"-pno:capture\")\n1838     result.stdout.fnmatch_lines([\"E       fixture 'capfd' not found\"])\n1839     assert result.ret == ExitCode.TESTS_FAILED\n1840 \n1841     result = pytester.runpytest(str(p), \"-pno:capture\", \"-s\")\n1842     result.stderr.fnmatch_lines([\"*: error: unrecognized arguments: -s\"])\n1843     assert result.ret == ExitCode.USAGE_ERROR\n1844 \n1845     result = pytester.runpytest(str(p), \"-p no:capture\", \"-s\")\n1846     result.stderr.fnmatch_lines([\"*: error: unrecognized arguments: -s\"])\n1847     assert result.ret == ExitCode.USAGE_ERROR\n1848 \n1849 \n1850 def test_invocation_args(pytester: Pytester) -> None:\n1851     \"\"\"Ensure that Config.invocation_* arguments are correctly defined\"\"\"\n1852 \n1853     class DummyPlugin:\n1854         pass\n1855 \n1856     p = pytester.makepyfile(\"def test(): pass\")\n1857     plugin = DummyPlugin()\n1858     rec = pytester.inline_run(p, \"-v\", plugins=[plugin])\n1859     calls = rec.getcalls(\"pytest_runtest_protocol\")\n1860     assert len(calls) == 1\n1861     call = calls[0]\n1862     config = call.item.config\n1863 \n1864     assert config.invocation_params.args == (str(p), \"-v\")\n1865     assert config.invocation_params.dir == pytester.path\n1866 \n1867     plugins = config.invocation_params.plugins\n1868     assert len(plugins) == 2\n1869     assert plugins[0] is plugin\n1870     assert type(plugins[1]).__name__ == \"Collect\"  # installed by pytester.inline_run()\n1871 \n1872     # args cannot be None\n1873     with pytest.raises(TypeError):\n1874         Config.InvocationParams(args=None, plugins=None, dir=Path())  # type: ignore[arg-type]\n1875 \n1876 \n1877 @pytest.mark.parametrize(\n1878     \"plugin\",\n1879     [\n1880         x\n1881         for x in _pytest.config.default_plugins\n1882         if x not in _pytest.config.essential_plugins\n1883     ],\n1884 )\n1885 def test_config_blocked_default_plugins(pytester: Pytester, plugin: str) -> None:\n1886     if plugin == \"debugging\":\n1887         # Fixed in xdist (after 1.27.0).\n1888         # https://github.com/pytest-dev/pytest-xdist/pull/422\n1889         try:\n1890             import xdist  # noqa: F401\n1891         except ImportError:\n1892             pass\n1893         else:\n1894             pytest.skip(\"does not work with xdist currently\")\n1895 \n1896     p = pytester.makepyfile(\"def test(): pass\")\n1897     result = pytester.runpytest(str(p), \"-pno:%s\" % plugin)\n1898 \n1899     if plugin == \"python\":\n1900         assert result.ret == ExitCode.USAGE_ERROR\n1901         result.stderr.fnmatch_lines(\n1902             [\n1903                 \"ERROR: found no collectors for */test_config_blocked_default_plugins.py\",\n1904             ]\n1905         )\n1906         return\n1907 \n1908     assert result.ret == ExitCode.OK\n1909     if plugin != \"terminal\":\n1910         result.stdout.fnmatch_lines([\"* 1 passed in *\"])\n1911 \n1912     p = pytester.makepyfile(\"def test(): assert 0\")\n1913     result = pytester.runpytest(str(p), \"-pno:%s\" % plugin)\n1914     assert result.ret == ExitCode.TESTS_FAILED\n1915     if plugin != \"terminal\":\n1916         result.stdout.fnmatch_lines([\"* 1 failed in *\"])\n1917     else:\n1918         assert result.stdout.lines == []\n1919 \n1920 \n1921 class TestSetupCfg:\n1922     def test_pytest_setup_cfg_unsupported(self, pytester: Pytester) -> None:\n1923         pytester.makefile(\n1924             \".cfg\",\n1925             setup=\"\"\"\n1926             [pytest]\n1927             addopts = --verbose\n1928         \"\"\",\n1929         )\n1930         with pytest.raises(pytest.fail.Exception):\n1931             pytester.runpytest()\n1932 \n1933     def test_pytest_custom_cfg_unsupported(self, pytester: Pytester) -> None:\n1934         pytester.makefile(\n1935             \".cfg\",\n1936             custom=\"\"\"\n1937             [pytest]\n1938             addopts = --verbose\n1939         \"\"\",\n1940         )\n1941         with pytest.raises(pytest.fail.Exception):\n1942             pytester.runpytest(\"-c\", \"custom.cfg\")\n1943 \n1944         with pytest.raises(pytest.fail.Exception):\n1945             pytester.runpytest(\"--config-file\", \"custom.cfg\")\n1946 \n1947 \n1948 class TestPytestPluginsVariable:\n1949     def test_pytest_plugins_in_non_top_level_conftest_unsupported(\n1950         self, pytester: Pytester\n1951     ) -> None:\n1952         pytester.makepyfile(\n1953             **{\n1954                 \"subdirectory/conftest.py\": \"\"\"\n1955             pytest_plugins=['capture']\n1956         \"\"\"\n1957             }\n1958         )\n1959         pytester.makepyfile(\n1960             \"\"\"\n1961             def test_func():\n1962                 pass\n1963         \"\"\"\n1964         )\n1965         res = pytester.runpytest()\n1966         assert res.ret == 2\n1967         msg = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n1968         res.stdout.fnmatch_lines([f\"*{msg}*\", f\"*subdirectory{os.sep}conftest.py*\"])\n1969 \n1970     @pytest.mark.parametrize(\"use_pyargs\", [True, False])\n1971     def test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs(\n1972         self, pytester: Pytester, use_pyargs: bool\n1973     ) -> None:\n1974         \"\"\"When using --pyargs, do not emit the warning about non-top-level conftest warnings (#4039, #4044)\"\"\"\n1975 \n1976         files = {\n1977             \"src/pkg/__init__.py\": \"\",\n1978             \"src/pkg/conftest.py\": \"\",\n1979             \"src/pkg/test_root.py\": \"def test(): pass\",\n1980             \"src/pkg/sub/__init__.py\": \"\",\n1981             \"src/pkg/sub/conftest.py\": \"pytest_plugins=['capture']\",\n1982             \"src/pkg/sub/test_bar.py\": \"def test(): pass\",\n1983         }\n1984         pytester.makepyfile(**files)\n1985         pytester.syspathinsert(pytester.path.joinpath(\"src\"))\n1986 \n1987         args = (\"--pyargs\", \"pkg\") if use_pyargs else ()\n1988         res = pytester.runpytest(*args)\n1989         assert res.ret == (0 if use_pyargs else 2)\n1990         msg = (\n1991             msg\n1992         ) = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n1993         if use_pyargs:\n1994             assert msg not in res.stdout.str()\n1995         else:\n1996             res.stdout.fnmatch_lines([f\"*{msg}*\"])\n1997 \n1998     def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest(\n1999         self, pytester: Pytester\n2000     ) -> None:\n2001         subdirectory = pytester.path.joinpath(\"subdirectory\")\n2002         subdirectory.mkdir()\n2003         pytester.makeconftest(\n2004             \"\"\"\n2005             pytest_plugins=['capture']\n2006         \"\"\"\n2007         )\n2008         pytester.path.joinpath(\"conftest.py\").rename(\n2009             subdirectory.joinpath(\"conftest.py\")\n2010         )\n2011 \n2012         pytester.makepyfile(\n2013             \"\"\"\n2014             def test_func():\n2015                 pass\n2016         \"\"\"\n2017         )\n2018 \n2019         res = pytester.runpytest_subprocess()\n2020         assert res.ret == 2\n2021         msg = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n2022         res.stdout.fnmatch_lines([f\"*{msg}*\", f\"*subdirectory{os.sep}conftest.py*\"])\n2023 \n2024     def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_false_positives(\n2025         self, pytester: Pytester\n2026     ) -> None:\n2027         pytester.makepyfile(\n2028             \"def test_func(): pass\",\n2029             **{\n2030                 \"subdirectory/conftest\": \"pass\",\n2031                 \"conftest\": \"\"\"\n2032                     import warnings\n2033                     warnings.filterwarnings('always', category=DeprecationWarning)\n2034                     pytest_plugins=['capture']\n2035                     \"\"\",\n2036             },\n2037         )\n2038         res = pytester.runpytest_subprocess()\n2039         assert res.ret == 0\n2040         msg = \"Defining 'pytest_plugins' in a non-top-level conftest is no longer supported\"\n2041         assert msg not in res.stdout.str()\n2042 \n2043 \n2044 def test_conftest_import_error_repr(tmp_path: Path) -> None:\n2045     \"\"\"`ConftestImportFailure` should use a short error message and readable\n2046     path to the failed conftest.py file.\"\"\"\n2047     path = tmp_path.joinpath(\"foo/conftest.py\")\n2048     with pytest.raises(\n2049         ConftestImportFailure,\n2050         match=re.escape(f\"RuntimeError: some error (from {path})\"),\n2051     ):\n2052         try:\n2053             raise RuntimeError(\"some error\")\n2054         except Exception as exc:\n2055             assert exc.__traceback__ is not None\n2056             exc_info = (type(exc), exc, exc.__traceback__)\n2057             raise ConftestImportFailure(path, exc_info) from exc\n2058 \n2059 \n2060 def test_strtobool() -> None:\n2061     assert _strtobool(\"YES\")\n2062     assert not _strtobool(\"NO\")\n2063     with pytest.raises(ValueError):\n2064         _strtobool(\"unknown\")\n2065 \n2066 \n2067 @pytest.mark.parametrize(\n2068     \"arg, escape, expected\",\n2069     [\n2070         (\"ignore\", False, (\"ignore\", \"\", Warning, \"\", 0)),\n2071         (\n2072             \"ignore::DeprecationWarning\",\n2073             False,\n2074             (\"ignore\", \"\", DeprecationWarning, \"\", 0),\n2075         ),\n2076         (\n2077             \"ignore:some msg:DeprecationWarning\",\n2078             False,\n2079             (\"ignore\", \"some msg\", DeprecationWarning, \"\", 0),\n2080         ),\n2081         (\n2082             \"ignore::DeprecationWarning:mod\",\n2083             False,\n2084             (\"ignore\", \"\", DeprecationWarning, \"mod\", 0),\n2085         ),\n2086         (\n2087             \"ignore::DeprecationWarning:mod:42\",\n2088             False,\n2089             (\"ignore\", \"\", DeprecationWarning, \"mod\", 42),\n2090         ),\n2091         (\"error:some\\\\msg:::\", True, (\"error\", \"some\\\\\\\\msg\", Warning, \"\", 0)),\n2092         (\"error:::mod\\\\foo:\", True, (\"error\", \"\", Warning, \"mod\\\\\\\\foo\\\\Z\", 0)),\n2093     ],\n2094 )\n2095 def test_parse_warning_filter(\n2096     arg: str, escape: bool, expected: Tuple[str, str, Type[Warning], str, int]\n2097 ) -> None:\n2098     assert parse_warning_filter(arg, escape=escape) == expected\n2099 \n2100 \n2101 @pytest.mark.parametrize(\n2102     \"arg\",\n2103     [\n2104         # Too much parts.\n2105         \":\" * 5,\n2106         # Invalid action.\n2107         \"FOO::\",\n2108         # ImportError when importing the warning class.\n2109         \"::test_parse_warning_filter_failure.NonExistentClass::\",\n2110         # Class is not a Warning subclass.\n2111         \"::list::\",\n2112         # Negative line number.\n2113         \"::::-1\",\n2114         # Not a line number.\n2115         \"::::not-a-number\",\n2116     ],\n2117 )\n2118 def test_parse_warning_filter_failure(arg: str) -> None:\n2119     with pytest.raises(pytest.UsageError):\n2120         parse_warning_filter(arg, escape=True)\n2121 \n2122 \n2123 class TestDebugOptions:\n2124     def test_without_debug_does_not_write_log(self, pytester: Pytester) -> None:\n2125         result = pytester.runpytest()\n2126         result.stderr.no_fnmatch_line(\n2127             \"*writing pytest debug information to*pytestdebug.log\"\n2128         )\n2129         result.stderr.no_fnmatch_line(\n2130             \"*wrote pytest debug information to*pytestdebug.log\"\n2131         )\n2132         assert not [f.name for f in pytester.path.glob(\"**/*.log\")]\n2133 \n2134     def test_with_only_debug_writes_pytestdebug_log(self, pytester: Pytester) -> None:\n2135         result = pytester.runpytest(\"--debug\")\n2136         result.stderr.fnmatch_lines(\n2137             [\n2138                 \"*writing pytest debug information to*pytestdebug.log\",\n2139                 \"*wrote pytest debug information to*pytestdebug.log\",\n2140             ]\n2141         )\n2142         assert \"pytestdebug.log\" in [f.name for f in pytester.path.glob(\"**/*.log\")]\n2143 \n2144     def test_multiple_custom_debug_logs(self, pytester: Pytester) -> None:\n2145         result = pytester.runpytest(\"--debug\", \"bar.log\")\n2146         result.stderr.fnmatch_lines(\n2147             [\n2148                 \"*writing pytest debug information to*bar.log\",\n2149                 \"*wrote pytest debug information to*bar.log\",\n2150             ]\n2151         )\n2152         result = pytester.runpytest(\"--debug\", \"foo.log\")\n2153         result.stderr.fnmatch_lines(\n2154             [\n2155                 \"*writing pytest debug information to*foo.log\",\n2156                 \"*wrote pytest debug information to*foo.log\",\n2157             ]\n2158         )\n2159 \n2160         assert {\"bar.log\", \"foo.log\"} == {\n2161             f.name for f in pytester.path.glob(\"**/*.log\")\n2162         }\n2163 \n2164     def test_debug_help(self, pytester: Pytester) -> None:\n2165         result = pytester.runpytest(\"-h\")\n2166         result.stdout.fnmatch_lines(\n2167             [\n2168                 \"*Store internal tracing debug information in this log*\",\n2169                 \"*file. This file is opened with 'w' and truncated as a*\",\n2170                 \"*Default: pytestdebug.log.\",\n2171             ]\n2172         )\n",
        "intended_behavior": "Test setup code should be carefully reviewed to ensure it does not inadvertently modify sys.modules in a way that could lead to module duplication. This includes avoiding unnecessary re-imports or removal of modules from sys.modules without a subsequent reload. Ensure all test configurations and dynamic imports follow a consistent path resolution and importing approach."
    },
    {
        "rel_file_path": "src/_pytest/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/main.py",
        "start": 843,
        "end": 857,
        "class_name": null,
        "method_name": "search_pypath",
        "code": "843 def search_pypath(module_name: str) -> str:\n844     \"\"\"Search sys.path for the given a dotted module name, and return its file system path.\"\"\"\n845     try:\n846         spec = importlib.util.find_spec(module_name)\n847     # AttributeError: looks like package module, but actually filename\n848     # ImportError: module does not exist\n849     # ValueError: not a module name\n850     except (AttributeError, ImportError, ValueError):\n851         return module_name\n852     if spec is None or spec.origin is None or spec.origin == \"namespace\":\n853         return module_name\n854     elif spec.submodule_search_locations:\n855         return os.path.dirname(spec.origin)\n856     else:\n857         return spec.origin\n",
        "intended_behavior": "The method search_pypath should ensure it respects the project's namespace package structures and does not bypass the standard module loading mechanism. Enhancements should support the uniqueness of module instances, particularly in contexts where the method's result influences dynamic importing decisions. Consider implementing additional checks or logs for module search and loading."
    }
]