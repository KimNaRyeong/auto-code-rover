2025-10-17 16:35:54.205 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 16:35:56.958 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=826, output_tokens=12, cost=0.008620
2025-10-17 16:35:56.959 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 16:35:56.963 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:36:06.131 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1123, output_tokens=274, cost=0.019450
2025-10-17 16:36:06.135 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:36:10.216 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=628, output_tokens=70, cost=0.008380
2025-10-17 16:36:10.217 | DEBUG    | Extracted a valid json.
2025-10-17 16:36:10.217 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file(\"Logger\", \"pmxbot/logging.py\")",
        "search_method_in_file(\"initialize\", \"pmxbot/core.py\")",
        "search_code_in_file(\"ConfigDict.from_yaml\", \"tests/unit/test_commands.py\")"
    ],
    "bug_locations": []
}
2025-10-17 16:36:10.221 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:36:10.222 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:36:17.915 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1604, output_tokens=287, cost=0.024650
2025-10-17 16:36:17.925 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:36:19.576 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2107, output_tokens=18, cost=0.021610
2025-10-17 16:36:19.578 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:36:21.286 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=372, output_tokens=35, cost=0.004770
2025-10-17 16:36:21.287 | DEBUG    | Extracted a valid json.
2025-10-17 16:36:21.287 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"Logger\")", "search_method(\"initialize\")", "search_code(\"importlib\")"],
    "bug_locations": []
}
2025-10-17 16:36:21.384 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:36:21.384 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:36:37.925 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2624, output_tokens=619, cost=0.044810
2025-10-17 16:36:37.934 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:36:49.838 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3459, output_tokens=527, cost=0.050400
2025-10-17 16:36:49.847 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:36:54.638 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=881, output_tokens=187, cost=0.014420
2025-10-17 16:36:54.639 | DEBUG    | Extracted a valid json.
2025-10-17 16:36:54.639 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"importlib.import_module\", \"testing/test_config.py\")",
        "search_code_in_file(\"import_module\", \"src/_pytest/pytester.py\")",
        "search_code_in_file(\"importlib.util.find_spec\", \"src/_pytest/pathlib.py\")"
    ],
    "bug_locations": [
        {
            "file": "src/_pytest/pytester.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that during test environment setup, handling of dynamic imports or module references through importlib consistently recognizes and operates on a singular reference to each module, especially those within the namespace affected by the switch to PEP 420. This may involve revisiting and possibly revising how tests dynamically import and reference modules, to ensure these operations respect and maintain the intended namespace package structure."
        }
    ]
}
2025-10-17 16:36:54.646 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:36:54.647 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:37:07.998 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4207, output_tokens=531, cost=0.058000
2025-10-17 16:37:08.008 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:37:20.986 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4954, output_tokens=469, cost=0.063610
2025-10-17 16:37:20.994 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:37:22.844 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=823, output_tokens=14, cost=0.008650
2025-10-17 16:37:22.845 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:37:22.845 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 16:37:24.930 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=823, output_tokens=14, cost=0.008650
2025-10-17 16:37:24.931 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:37:24.931 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 16:37:26.267 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=823, output_tokens=14, cost=0.008650
2025-10-17 16:37:26.268 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:37:26.274 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 16:37:28.318 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=823, output_tokens=14, cost=0.008650
2025-10-17 16:37:28.319 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:37:28.319 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 16:37:29.376 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=823, output_tokens=14, cost=0.008650
2025-10-17 16:37:29.378 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:37:29.378 | DEBUG    | Agent proxy return the following json: None
2025-10-17 16:37:29.378 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 16:37:29.379 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 16:37:29.379 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:37:52.525 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5450, output_tokens=557, cost=0.071210
2025-10-17 16:37:52.536 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:38:09.258 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=911, output_tokens=412, cost=0.021470
2025-10-17 16:38:09.259 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 16:38:09.259 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 16:38:19.569 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=911, output_tokens=368, cost=0.020150
2025-10-17 16:38:19.570 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 16:38:19.570 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 16:38:29.914 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=911, output_tokens=420, cost=0.021710
2025-10-17 16:38:29.915 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 16:38:29.915 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 16:38:37.628 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=911, output_tokens=326, cost=0.018890
2025-10-17 16:38:37.629 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 16:38:37.629 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 16:38:46.670 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=911, output_tokens=396, cost=0.020990
2025-10-17 16:38:46.671 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 16:38:46.672 | DEBUG    | Agent proxy return the following json: None
2025-10-17 16:38:46.672 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 16:38:46.673 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 16:38:46.673 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:38:57.219 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6034, output_tokens=436, cost=0.073420
2025-10-17 16:38:57.228 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:38:59.569 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-17 16:38:59.570 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:38:59.570 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 16:39:01.525 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-17 16:39:01.526 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:39:01.526 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 16:39:03.066 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-17 16:39:03.067 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:39:03.068 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 16:39:05.155 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-17 16:39:05.156 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:39:05.156 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 16:39:07.081 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=790, output_tokens=14, cost=0.008320
2025-10-17 16:39:07.082 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:39:07.082 | DEBUG    | Agent proxy return the following json: None
2025-10-17 16:39:07.083 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 16:39:07.084 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 16:39:07.084 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:39:18.804 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6497, output_tokens=413, cost=0.077360
2025-10-17 16:39:18.815 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:39:21.298 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=767, output_tokens=61, cost=0.009500
2025-10-17 16:39:21.299 | DEBUG    | Extracted a valid json.
2025-10-17 16:39:21.299 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"importlib\")",
        "search_code(\"PEP 420\")",
        "search_code(\"from pmxbot.logging import\")",
        "search_code(\"import pmxbot.logging\")"
    ],
    "bug_locations": []
}
2025-10-17 16:39:21.413 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:39:21.414 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:39:37.044 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7451, output_tokens=639, cost=0.093680
2025-10-17 16:39:37.053 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:39:51.779 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8306, output_tokens=559, cost=0.099830
2025-10-17 16:39:51.788 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:39:56.448 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=913, output_tokens=172, cost=0.014290
2025-10-17 16:39:56.449 | DEBUG    | Extracted a valid json.
2025-10-17 16:39:56.449 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "Various testing and src/_pytest files",
            "class": "",
            "method": "General use of `importlib` for dynamic imports",
            "intended_behavior": "The code should ensure that any use of `importlib` for importing modules supports the consistent recognition of a singular instance of each module within the project's execution context. This involves verifying that dynamic imports do not lead to the re-importation of modules already available in `sys.modules`, adhering to best practices for using `importlib` to respect Python's module caching mechanisms. For testing environments, specifically, care should be taken to import modules in a manner that aligns with the project's main application logic, preventing discrepancies that could lead to module duplication."
        }
    ]
}
2025-10-17 16:39:56.452 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-17 16:39:56.453 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 16:39:56.453 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:40:13.462 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8899, output_tokens=577, cost=0.106300
2025-10-17 16:40:13.473 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:40:14.319 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=14, cost=0.009730
2025-10-17 16:40:14.320 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:40:14.321 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 16:40:15.770 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=14, cost=0.009730
2025-10-17 16:40:15.771 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 16:40:15.771 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 16:40:18.261 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=931, output_tokens=57, cost=0.011020
2025-10-17 16:40:18.262 | DEBUG    | Extracted a valid json.
2025-10-17 16:40:18.262 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"importlib\")",
        "search_code(\"__init__.py\")",
        "search_code(\"importlib.util.find_spec\")",
        "search_code(\"sys.modules\")"
    ],
    "bug_locations": []
}
2025-10-17 16:40:18.508 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:40:18.508 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:40:41.730 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=11131, output_tokens=899, cost=0.138280
2025-10-17 16:40:41.738 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:40:58.052 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=12246, output_tokens=625, cost=0.141210
2025-10-17 16:40:58.063 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:41:08.153 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=979, output_tokens=418, cost=0.022330
2025-10-17 16:41:08.154 | DEBUG    | Extracted a valid json.
2025-10-17 16:41:08.154 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "src/_pytest/pathlib.py",
            "class": "",
            "method": "",
            "intended_behavior": "Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module."
        },
        {
            "file": "src/_pytest/assertion/rewrite.py",
            "class": "",
            "method": "",
            "intended_behavior": "Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module."
        },
        {
            "file": "testing/test_config.py",
            "class": "",
            "method": "",
            "intended_behavior": "Test setup code should be carefully reviewed to ensure it does not inadvertently modify sys.modules in a way that could lead to module duplication. This includes avoiding unnecessary re-imports or removal of modules from sys.modules without a subsequent reload. Ensure all test configurations and dynamic imports follow a consistent path resolution and importing approach."
        },
        {
            "file": "src/_pytest/main.py",
            "class": "",
            "method": "search_pypath",
            "intended_behavior": "The method search_pypath should ensure it respects the project's namespace package structures and does not bypass the standard module loading mechanism. Enhancements should support the uniqueness of module instances, particularly in contexts where the method's result influences dynamic importing decisions. Consider implementing additional checks or logs for module search and loading."
        }
    ]
}
2025-10-17 16:41:08.170 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import atexit
2 import contextlib
3 import fnmatch
4 import importlib.util
5 import itertools
6 import os
7 import shutil
8 import sys
9 import types
10 import uuid
11 import warnings
12 from enum import Enum
13 from errno import EBADF
14 from errno import ELOOP
15 from errno import ENOENT
16 from errno import ENOTDIR
17 from functools import partial
18 from os.path import expanduser
19 from os.path import expandvars
20 from os.path import isabs
21 from os.path import sep
22 from pathlib import Path
23 from pathlib import PurePath
24 from posixpath import sep as posix_sep
25 from types import ModuleType
26 from typing import Callable
27 from typing import Dict
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Set
33 from typing import Tuple
34 from typing import Type
35 from typing import TypeVar
36 from typing import Union
37 
38 from _pytest.compat import assert_never
39 from _pytest.outcomes import skip
40 from _pytest.warning_types import PytestWarning
41 
42 LOCK_TIMEOUT = 60 * 60 * 24 * 3
43 
44 
45 _AnyPurePath = TypeVar("_AnyPurePath", bound=PurePath)
46 
47 # The following function, variables and comments were
48 # copied from cpython 3.9 Lib/pathlib.py file.
49 
50 # EBADF - guard against macOS `stat` throwing EBADF
51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)
52 
53 _IGNORED_WINERRORS = (
54     21,  # ERROR_NOT_READY - drive exists but is not accessible
55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself
56 )
57 
58 
59 def _ignore_error(exception):
60     return (
61         getattr(exception, "errno", None) in _IGNORED_ERRORS
62         or getattr(exception, "winerror", None) in _IGNORED_WINERRORS
63     )
64 
65 
66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:
67     return path.joinpath(".lock")
68 
69 
70 def on_rm_rf_error(
71     func,
72     path: str,
73     excinfo: Union[
74         BaseException,
75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],
76     ],
77     *,
78     start_path: Path,
79 ) -> bool:
80     """Handle known read-only errors during rmtree.
81 
82     The returned value is used only by our own tests.
83     """
84     if isinstance(excinfo, BaseException):
85         exc = excinfo
86     else:
87         exc = excinfo[1]
88 
89     # Another process removed the file in the middle of the "rm_rf" (xdist for example).
90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018
91     if isinstance(exc, FileNotFoundError):
92         return False
93 
94     if not isinstance(exc, PermissionError):
95         warnings.warn(
96             PytestWarning(f"(rm_rf) error removing {path}\n{type(exc)}: {exc}")
97         )
98         return False
99 
100     if func not in (os.rmdir, os.remove, os.unlink):
101         if func not in (os.open,):
102             warnings.warn(
103                 PytestWarning(
104                     "(rm_rf) unknown function {} when removing {}:\n{}: {}".format(
105                         func, path, type(exc), exc
106                     )
107                 )
108             )
109         return False
110 
111     # Chmod + retry.
112     import stat
113 
114     def chmod_rw(p: str) -> None:
115         mode = os.stat(p).st_mode
116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)
117 
118     # For files, we need to recursively go upwards in the directories to
119     # ensure they all are also writable.
120     p = Path(path)
121     if p.is_file():
122         for parent in p.parents:
123             chmod_rw(str(parent))
124             # Stop when we reach the original path passed to rm_rf.
125             if parent == start_path:
126                 break
127     chmod_rw(str(path))
128 
129     func(path)
130     return True
131 
132 
133 def ensure_extended_length_path(path: Path) -> Path:
134     """Get the extended-length version of a path (Windows).
135 
136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260
137     characters, and operations on paths longer than that fail. But it is possible
138     to overcome this by converting the path to "extended-length" form before
139     performing the operation:
140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
141 
142     On Windows, this function returns the extended-length absolute version of path.
143     On other platforms it returns path unchanged.
144     """
145     if sys.platform.startswith("win32"):
146         path = path.resolve()
147         path = Path(get_extended_length_path_str(str(path)))
148     return path
149 
150 
151 def get_extended_length_path_str(path: str) -> str:
152     """Convert a path to a Windows extended length path."""
153     long_path_prefix = "\\\\?\\"
154     unc_long_path_prefix = "\\\\?\\UNC\\"
155     if path.startswith((long_path_prefix, unc_long_path_prefix)):
156         return path
157     # UNC
158     if path.startswith("\\\\"):
159         return unc_long_path_prefix + path[2:]
160     return long_path_prefix + path
161 
162 
163 def rm_rf(path: Path) -> None:
164     """Remove the path contents recursively, even if some elements
165     are read-only."""
166     path = ensure_extended_length_path(path)
167     onerror = partial(on_rm_rf_error, start_path=path)
168     if sys.version_info >= (3, 12):
169         shutil.rmtree(str(path), onexc=onerror)
170     else:
171         shutil.rmtree(str(path), onerror=onerror)
172 
173 
174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:
175     """Find all elements in root that begin with the prefix, case insensitive."""
176     l_prefix = prefix.lower()
177     for x in root.iterdir():
178         if x.name.lower().startswith(l_prefix):
179             yield x
180 
181 
182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:
183     """Return the parts of the paths following the prefix.
184 
185     :param iter: Iterator over path names.
186     :param prefix: Expected prefix of the path names.
187     """
188     p_len = len(prefix)
189     for p in iter:
190         yield p.name[p_len:]
191 
192 
193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
194     """Combine find_prefixes and extract_suffixes."""
195     return extract_suffixes(find_prefixed(root, prefix), prefix)
196 
197 
198 def parse_num(maybe_num) -> int:
199     """Parse number path suffixes, returns -1 on error."""
200     try:
201         return int(maybe_num)
202     except ValueError:
203         return -1
204 
205 
206 def _force_symlink(
207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]
208 ) -> None:
209     """Helper to create the current symlink.
210 
211     It's full of race conditions that are reasonably OK to ignore
212     for the context of best effort linking to the latest test run.
213 
214     The presumption being that in case of much parallelism
215     the inaccuracy is going to be acceptable.
216     """
217     current_symlink = root.joinpath(target)
218     try:
219         current_symlink.unlink()
220     except OSError:
221         pass
222     try:
223         current_symlink.symlink_to(link_to)
224     except Exception:
225         pass
226 
227 
228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
229     """Create a directory with an increased number as suffix for the given prefix."""
230     for i in range(10):
231         # try up to 10 times to create the folder
232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
233         new_number = max_existing + 1
234         new_path = root.joinpath(f"{prefix}{new_number}")
235         try:
236             new_path.mkdir(mode=mode)
237         except Exception:
238             pass
239         else:
240             _force_symlink(root, prefix + "current", new_path)
241             return new_path
242     else:
243         raise OSError(
244             "could not create numbered dir with prefix "
245             "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
246         )
247 
248 
249 def create_cleanup_lock(p: Path) -> Path:
250     """Create a lock to prevent premature folder cleanup."""
251     lock_path = get_lock_path(p)
252     try:
253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
254     except FileExistsError as e:
255         raise OSError(f"cannot create lockfile in {p}") from e
256     else:
257         pid = os.getpid()
258         spid = str(pid).encode()
259         os.write(fd, spid)
260         os.close(fd)
261         if not lock_path.is_file():
262             raise OSError("lock path got renamed after successful creation")
263         return lock_path
264 
265 
266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
267     """Register a cleanup function for removing a lock, by default on atexit."""
268     pid = os.getpid()
269 
270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
271         current_pid = os.getpid()
272         if current_pid != original_pid:
273             # fork
274             return
275         try:
276             lock_path.unlink()
277         except OSError:
278             pass
279 
280     return register(cleanup_on_exit)
281 
282 
283 def maybe_delete_a_numbered_dir(path: Path) -> None:
284     """Remove a numbered directory if its lock can be obtained and it does
285     not seem to be in use."""
286     path = ensure_extended_length_path(path)
287     lock_path = None
288     try:
289         lock_path = create_cleanup_lock(path)
290         parent = path.parent
291 
292         garbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
293         path.rename(garbage)
294         rm_rf(garbage)
295     except OSError:
296         #  known races:
297         #  * other process did a cleanup at the same time
298         #  * deletable folder was found
299         #  * process cwd (Windows)
300         return
301     finally:
302         # If we created the lock, ensure we remove it even if we failed
303         # to properly remove the numbered dir.
304         if lock_path is not None:
305             try:
306                 lock_path.unlink()
307             except OSError:
308                 pass
309 
310 
311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:
312     """Check if `path` is deletable based on whether the lock file is expired."""
313     if path.is_symlink():
314         return False
315     lock = get_lock_path(path)
316     try:
317         if not lock.is_file():
318             return True
319     except OSError:
320         # we might not have access to the lock file at all, in this case assume
321         # we don't have access to the entire directory (#7491).
322         return False
323     try:
324         lock_time = lock.stat().st_mtime
325     except Exception:
326         return False
327     else:
328         if lock_time < consider_lock_dead_if_created_before:
329             # We want to ignore any errors while trying to remove the lock such as:
330             # - PermissionDenied, like the file permissions have changed since the lock creation;
331             # - FileNotFoundError, in case another pytest process got here first;
332             # and any other cause of failure.
333             with contextlib.suppress(OSError):
334                 lock.unlink()
335                 return True
336         return False
337 
338 
339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:
340     """Try to cleanup a folder if we can ensure it's deletable."""
341     if ensure_deletable(path, consider_lock_dead_if_created_before):
342         maybe_delete_a_numbered_dir(path)
343 
344 
345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:
346     """List candidates for numbered directories to be removed - follows py.path."""
347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
348     max_delete = max_existing - keep
349     paths = find_prefixed(root, prefix)
350     paths, paths2 = itertools.tee(paths)
351     numbers = map(parse_num, extract_suffixes(paths2, prefix))
352     for path, number in zip(paths, numbers):
353         if number <= max_delete:
354             yield path
355 
356 
357 def cleanup_dead_symlinks(root: Path):
358     for left_dir in root.iterdir():
359         if left_dir.is_symlink():
360             if not left_dir.resolve().exists():
361                 left_dir.unlink()
362 
363 
364 def cleanup_numbered_dir(
365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float
366 ) -> None:
367     """Cleanup for lock driven numbered directories."""
368     if not root.exists():
369         return
370     for path in cleanup_candidates(root, prefix, keep):
371         try_cleanup(path, consider_lock_dead_if_created_before)
372     for path in root.glob("garbage-*"):
373         try_cleanup(path, consider_lock_dead_if_created_before)
374 
375     cleanup_dead_symlinks(root)
376 
377 
378 def make_numbered_dir_with_cleanup(
379     root: Path,
380     prefix: str,
381     keep: int,
382     lock_timeout: float,
383     mode: int,
384 ) -> Path:
385     """Create a numbered dir with a cleanup lock and remove old ones."""
386     e = None
387     for i in range(10):
388         try:
389             p = make_numbered_dir(root, prefix, mode)
390             # Only lock the current dir when keep is not 0
391             if keep != 0:
392                 lock_path = create_cleanup_lock(p)
393                 register_cleanup_lock_removal(lock_path)
394         except Exception as exc:
395             e = exc
396         else:
397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
398             # Register a cleanup for program exit
399             atexit.register(
400                 cleanup_numbered_dir,
401                 root,
402                 prefix,
403                 keep,
404                 consider_lock_dead_if_created_before,
405             )
406             return p
407     assert e is not None
408     raise e
409 
410 
411 def resolve_from_str(input: str, rootpath: Path) -> Path:
412     input = expanduser(input)
413     input = expandvars(input)
414     if isabs(input):
415         return Path(input)
416     else:
417         return rootpath.joinpath(input)
418 
419 
420 def fnmatch_ex(pattern: str, path: Union[str, "os.PathLike[str]"]) -> bool:
421     """A port of FNMatcher from py.path.common which works with PurePath() instances.
422 
423     The difference between this algorithm and PurePath.match() is that the
424     latter matches "**" glob expressions for each part of the path, while
425     this algorithm uses the whole path instead.
426 
427     For example:
428         "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
429         with this algorithm, but not with PurePath.match().
430 
431     This algorithm was ported to keep backward-compatibility with existing
432     settings which assume paths match according this logic.
433 
434     References:
435     * https://bugs.python.org/issue29249
436     * https://bugs.python.org/issue34731
437     """
438     path = PurePath(path)
439     iswin32 = sys.platform.startswith("win")
440 
441     if iswin32 and sep not in pattern and posix_sep in pattern:
442         # Running on Windows, the pattern has no Windows path separators,
443         # and the pattern has one or more Posix path separators. Replace
444         # the Posix path separators with the Windows path separator.
445         pattern = pattern.replace(posix_sep, sep)
446 
447     if sep not in pattern:
448         name = path.name
449     else:
450         name = str(path)
451         if path.is_absolute() and not os.path.isabs(pattern):
452             pattern = f"*{os.sep}{pattern}"
453     return fnmatch.fnmatch(name, pattern)
454 
455 
456 def parts(s: str) -> Set[str]:
457     parts = s.split(sep)
458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}
459 
460 
461 def symlink_or_skip(src, dst, **kwargs):
462     """Make a symlink, or skip the test in case symlinks are not supported."""
463     try:
464         os.symlink(str(src), str(dst), **kwargs)
465     except OSError as e:
466         skip(f"symlinks not supported: {e}")
467 
468 
469 class ImportMode(Enum):
470     """Possible values for `mode` parameter of `import_path`."""
471 
472     prepend = "prepend"
473     append = "append"
474     importlib = "importlib"
475 
476 
477 class ImportPathMismatchError(ImportError):
478     """Raised on import_path() if there is a mismatch of __file__'s.
479 
480     This can happen when `import_path` is called multiple times with different filenames that has
481     the same basename but reside in packages
482     (for example "/tests1/test_foo.py" and "/tests2/test_foo.py").
483     """
484 
485 
486 def import_path(
487     p: Union[str, "os.PathLike[str]"],
488     *,
489     mode: Union[str, ImportMode] = ImportMode.prepend,
490     root: Path,
491 ) -> ModuleType:
492     """Import and return a module from the given path, which can be a file (a module) or
493     a directory (a package).
494 
495     The import mechanism used is controlled by the `mode` parameter:
496 
497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking
498       `__init__.py` files into account) will be put at the *start* of `sys.path` before
499       being imported with `importlib.import_module`.
500 
501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
502       to the end of `sys.path`, if not already in `sys.path`.
503 
504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
505       to import the module, which avoids having to muck with `sys.path` at all. It effectively
506       allows having same-named test modules in different places.
507 
508     :param root:
509         Used as an anchor when mode == ImportMode.importlib to obtain
510         a unique name for the module being imported so it can safely be stored
511         into ``sys.modules``.
512 
513     :raises ImportPathMismatchError:
514         If after importing the given `path` and the module `__file__`
515         are different. Only raised in `prepend` and `append` modes.
516     """
517     mode = ImportMode(mode)
518 
519     path = Path(p)
520 
521     if not path.exists():
522         raise ImportError(path)
523 
524     if mode is ImportMode.importlib:
525         module_name = module_name_from_path(path, root)
526 
527         for meta_importer in sys.meta_path:
528             spec = meta_importer.find_spec(module_name, [str(path.parent)])
529             if spec is not None:
530                 break
531         else:
532             spec = importlib.util.spec_from_file_location(module_name, str(path))
533 
534         if spec is None:
535             raise ImportError(f"Can't find module {module_name} at location {path}")
536         mod = importlib.util.module_from_spec(spec)
537         sys.modules[module_name] = mod
538         spec.loader.exec_module(mod)  # type: ignore[union-attr]
539         insert_missing_modules(sys.modules, module_name)
540         return mod
541 
542     pkg_path = resolve_package_path(path)
543     if pkg_path is not None:
544         pkg_root = pkg_path.parent
545         names = list(path.with_suffix("").relative_to(pkg_root).parts)
546         if names[-1] == "__init__":
547             names.pop()
548         module_name = ".".join(names)
549     else:
550         pkg_root = path.parent
551         module_name = path.stem
552 
553     # Change sys.path permanently: restoring it at the end of this function would cause surprising
554     # problems because of delayed imports: for example, a conftest.py file imported by this function
555     # might have local imports, which would fail at runtime if we restored sys.path.
556     if mode is ImportMode.append:
557         if str(pkg_root) not in sys.path:
558             sys.path.append(str(pkg_root))
559     elif mode is ImportMode.prepend:
560         if str(pkg_root) != sys.path[0]:
561             sys.path.insert(0, str(pkg_root))
562     else:
563         assert_never(mode)
564 
565     importlib.import_module(module_name)
566 
567     mod = sys.modules[module_name]
568     if path.name == "__init__.py":
569         return mod
570 
571     ignore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")
572     if ignore != "1":
573         module_file = mod.__file__
574         if module_file is None:
575             raise ImportPathMismatchError(module_name, module_file, path)
576 
577         if module_file.endswith((".pyc", ".pyo")):
578             module_file = module_file[:-1]
579         if module_file.endswith(os.sep + "__init__.py"):
580             module_file = module_file[: -(len(os.sep + "__init__.py"))]
581 
582         try:
583             is_same = _is_same(str(path), module_file)
584         except FileNotFoundError:
585             is_same = False
586 
587         if not is_same:
588             raise ImportPathMismatchError(module_name, module_file, path)
589 
590     return mod
591 
592 
593 # Implement a special _is_same function on Windows which returns True if the two filenames
594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).
595 if sys.platform.startswith("win"):
596 
597     def _is_same(f1: str, f2: str) -> bool:
598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)
599 
600 else:
601 
602     def _is_same(f1: str, f2: str) -> bool:
603         return os.path.samefile(f1, f2)
604 
605 
606 def module_name_from_path(path: Path, root: Path) -> str:
607     """
608     Return a dotted module name based on the given path, anchored on root.
609 
610     For example: path="projects/src/tests/test_foo.py" and root="/projects", the
611     resulting module name will be "src.tests.test_foo".
612     """
613     path = path.with_suffix("")
614     try:
615         relative_path = path.relative_to(root)
616     except ValueError:
617         # If we can't get a relative path to root, use the full path, except
618         # for the first part ("d:\\" or "/" depending on the platform, for example).
619         path_parts = path.parts[1:]
620     else:
621         # Use the parts for the relative path to the root path.
622         path_parts = relative_path.parts
623 
624     return ".".join(path_parts)
625 
626 
627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:
628     """
629     Used by ``import_path`` to create intermediate modules when using mode=importlib.
630 
631     When we want to import a module as "src.tests.test_foo" for example, we need
632     to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
633     otherwise "src.tests.test_foo" is not importable by ``__import__``.
634     """
635     module_parts = module_name.split(".")
636     child_module: Union[ModuleType, None] = None
637     module: Union[ModuleType, None] = None
638     child_name: str = ""
639     while module_name:
640         if module_name not in modules:
641             try:
642                 # If sys.meta_path is empty, calling import_module will issue
643                 # a warning and raise ModuleNotFoundError. To avoid the
644                 # warning, we check sys.meta_path explicitly and raise the error
645                 # ourselves to fall back to creating a dummy module.
646                 if not sys.meta_path:
647                     raise ModuleNotFoundError
648                 module = importlib.import_module(module_name)
649             except ModuleNotFoundError:
650                 module = ModuleType(
651                     module_name,
652                     doc="Empty module created by pytest's importmode=importlib.",
653                 )
654         else:
655             module = modules[module_name]
656         if child_module:
657             # Add child attribute to the parent that can reference the child
658             # modules.
659             if not hasattr(module, child_name):
660                 setattr(module, child_name, child_module)
661                 modules[module_name] = module
662         # Keep track of the child module while moving up the tree.
663         child_module, child_name = module, module_name.rpartition(".")[-1]
664         module_parts.pop(-1)
665         module_name = ".".join(module_parts)
666 
667 
668 def resolve_package_path(path: Path) -> Optional[Path]:
669     """Return the Python package path by looking for the last
670     directory upwards which still contains an __init__.py.
671 
672     Returns None if it can not be determined.
673     """
674     result = None
675     for parent in itertools.chain((path,), path.parents):
676         if parent.is_dir():
677             if not parent.joinpath("__init__.py").is_file():
678                 break
679             if not parent.name.isidentifier():
680                 break
681             result = parent
682     return result
683 
684 
685 def scandir(path: Union[str, "os.PathLike[str]"]) -> List["os.DirEntry[str]"]:
686     """Scan a directory recursively, in breadth-first order.
687 
688     The returned entries are sorted.
689     """
690     entries = []
691     with os.scandir(path) as s:
692         # Skip entries with symlink loops and other brokenness, so the caller
693         # doesn't have to deal with it.
694         for entry in s:
695             try:
696                 entry.is_file()
697             except OSError as err:
698                 if _ignore_error(err):
699                     continue
700                 raise
701             entries.append(entry)
702     entries.sort(key=lambda entry: entry.name)
703     return entries
704 
705 
706 def visit(
707     path: Union[str, "os.PathLike[str]"], recurse: Callable[["os.DirEntry[str]"], bool]
708 ) -> Iterator["os.DirEntry[str]"]:
709     """Walk a directory recursively, in breadth-first order.
710 
711     The `recurse` predicate determines whether a directory is recursed.
712 
713     Entries at each directory level are sorted.
714     """
715     entries = scandir(path)
716     yield from entries
717     for entry in entries:
718         if entry.is_dir() and recurse(entry):
719             yield from visit(entry.path, recurse)
720 
721 
722 def absolutepath(path: Union[Path, str]) -> Path:
723     """Convert a path to an absolute path using os.path.abspath.
724 
725     Prefer this over Path.resolve() (see #6523).
726     Prefer this over Path.absolute() (not public, doesn't normalize).
727     """
728     return Path(os.path.abspath(str(path)))
729 
730 
731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:
732     """Return the common part shared with the other path, or None if there is
733     no common part.
734 
735     If one path is relative and one is absolute, returns None.
736     """
737     try:
738         return Path(os.path.commonpath((str(path1), str(path2))))
739     except ValueError:
740         return None
741 
742 
743 def bestrelpath(directory: Path, dest: Path) -> str:
744     """Return a string which is a relative path from directory to dest such
745     that directory/bestrelpath == dest.
746 
747     The paths must be either both absolute or both relative.
748 
749     If no such path can be determined, returns dest.
750     """
751     assert isinstance(directory, Path)
752     assert isinstance(dest, Path)
753     if dest == directory:
754         return os.curdir
755     # Find the longest common directory.
756     base = commonpath(directory, dest)
757     # Can be the case on Windows for two absolute paths on different drives.
758     # Can be the case for two relative paths without common prefix.
759     # Can be the case for a relative path and an absolute path.
760     if not base:
761         return str(dest)
762     reldirectory = directory.relative_to(base)
763     reldest = dest.relative_to(base)
764     return os.path.join(
765         # Back from directory to base.
766         *([os.pardir] * len(reldirectory.parts)),
767         # Forward from base to dest.
768         *reldest.parts,
769     )
770 
771 
772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.
773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)
774 def copytree(source: Path, target: Path) -> None:
775     """Recursively copy a source directory to target."""
776     assert source.is_dir()
777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):
778         x = Path(entry)
779         relpath = x.relative_to(source)
780         newx = target / relpath
781         newx.parent.mkdir(exist_ok=True)
782         if x.is_symlink():
783             newx.symlink_to(os.readlink(x))
784         elif x.is_file():
785             shutil.copyfile(x, newx)
786         elif x.is_dir():
787             newx.mkdir(exist_ok=True)

</code><intended_behavior>Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module.</intended_behavior>, <file>src/_pytest/assertion/rewrite.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Rewrite assertion AST to produce nice error messages."""
2 import ast
3 import errno
4 import functools
5 import importlib.abc
6 import importlib.machinery
7 import importlib.util
8 import io
9 import itertools
10 import marshal
11 import os
12 import struct
13 import sys
14 import tokenize
15 import types
16 from pathlib import Path
17 from pathlib import PurePath
18 from typing import Callable
19 from typing import Dict
20 from typing import IO
21 from typing import Iterable
22 from typing import Iterator
23 from typing import List
24 from typing import Optional
25 from typing import Sequence
26 from typing import Set
27 from typing import Tuple
28 from typing import TYPE_CHECKING
29 from typing import Union
30 
31 from _pytest._io.saferepr import DEFAULT_REPR_MAX_SIZE
32 from _pytest._io.saferepr import saferepr
33 from _pytest._version import version
34 from _pytest.assertion import util
35 from _pytest.assertion.util import (  # noqa: F401
36     format_explanation as _format_explanation,
37 )
38 from _pytest.config import Config
39 from _pytest.main import Session
40 from _pytest.pathlib import absolutepath
41 from _pytest.pathlib import fnmatch_ex
42 from _pytest.stash import StashKey
43 
44 if TYPE_CHECKING:
45     from _pytest.assertion import AssertionState
46 
47 
48 assertstate_key = StashKey["AssertionState"]()
49 
50 # pytest caches rewritten pycs in pycache dirs
51 PYTEST_TAG = f"{sys.implementation.cache_tag}-pytest-{version}"
52 PYC_EXT = ".py" + (__debug__ and "c" or "o")
53 PYC_TAIL = "." + PYTEST_TAG + PYC_EXT
54 
55 
56 class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):
57     """PEP302/PEP451 import hook which rewrites asserts."""
58 
59     def __init__(self, config: Config) -> None:
60         self.config = config
61         try:
62             self.fnpats = config.getini("python_files")
63         except ValueError:
64             self.fnpats = ["test_*.py", "*_test.py"]
65         self.session: Optional[Session] = None
66         self._rewritten_names: Dict[str, Path] = {}
67         self._must_rewrite: Set[str] = set()
68         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,
69         # which might result in infinite recursion (#3506)
70         self._writing_pyc = False
71         self._basenames_to_check_rewrite = {"conftest"}
72         self._marked_for_rewrite_cache: Dict[str, bool] = {}
73         self._session_paths_checked = False
74 
75     def set_session(self, session: Optional[Session]) -> None:
76         self.session = session
77         self._session_paths_checked = False
78 
79     # Indirection so we can mock calls to find_spec originated from the hook during testing
80     _find_spec = importlib.machinery.PathFinder.find_spec
81 
82     def find_spec(
83         self,
84         name: str,
85         path: Optional[Sequence[Union[str, bytes]]] = None,
86         target: Optional[types.ModuleType] = None,
87     ) -> Optional[importlib.machinery.ModuleSpec]:
88         if self._writing_pyc:
89             return None
90         state = self.config.stash[assertstate_key]
91         if self._early_rewrite_bailout(name, state):
92             return None
93         state.trace("find_module called for: %s" % name)
94 
95         # Type ignored because mypy is confused about the `self` binding here.
96         spec = self._find_spec(name, path)  # type: ignore
97         if (
98             # the import machinery could not find a file to import
99             spec is None
100             # this is a namespace package (without `__init__.py`)
101             # there's nothing to rewrite there
102             or spec.origin is None
103             # we can only rewrite source files
104             or not isinstance(spec.loader, importlib.machinery.SourceFileLoader)
105             # if the file doesn't exist, we can't rewrite it
106             or not os.path.exists(spec.origin)
107         ):
108             return None
109         else:
110             fn = spec.origin
111 
112         if not self._should_rewrite(name, fn, state):
113             return None
114 
115         return importlib.util.spec_from_file_location(
116             name,
117             fn,
118             loader=self,
119             submodule_search_locations=spec.submodule_search_locations,
120         )
121 
122     def create_module(
123         self, spec: importlib.machinery.ModuleSpec
124     ) -> Optional[types.ModuleType]:
125         return None  # default behaviour is fine
126 
127     def exec_module(self, module: types.ModuleType) -> None:
128         assert module.__spec__ is not None
129         assert module.__spec__.origin is not None
130         fn = Path(module.__spec__.origin)
131         state = self.config.stash[assertstate_key]
132 
133         self._rewritten_names[module.__name__] = fn
134 
135         # The requested module looks like a test file, so rewrite it. This is
136         # the most magical part of the process: load the source, rewrite the
137         # asserts, and load the rewritten source. We also cache the rewritten
138         # module code in a special pyc. We must be aware of the possibility of
139         # concurrent pytest processes rewriting and loading pycs. To avoid
140         # tricky race conditions, we maintain the following invariant: The
141         # cached pyc is always a complete, valid pyc. Operations on it must be
142         # atomic. POSIX's atomic rename comes in handy.
143         write = not sys.dont_write_bytecode
144         cache_dir = get_cache_dir(fn)
145         if write:
146             ok = try_makedirs(cache_dir)
147             if not ok:
148                 write = False
149                 state.trace(f"read only directory: {cache_dir}")
150 
151         cache_name = fn.name[:-3] + PYC_TAIL
152         pyc = cache_dir / cache_name
153         # Notice that even if we're in a read-only directory, I'm going
154         # to check for a cached pyc. This may not be optimal...
155         co = _read_pyc(fn, pyc, state.trace)
156         if co is None:
157             state.trace(f"rewriting {fn!r}")
158             source_stat, co = _rewrite_test(fn, self.config)
159             if write:
160                 self._writing_pyc = True
161                 try:
162                     _write_pyc(state, co, source_stat, pyc)
163                 finally:
164                     self._writing_pyc = False
165         else:
166             state.trace(f"found cached rewritten pyc for {fn}")
167         exec(co, module.__dict__)
168 
169     def _early_rewrite_bailout(self, name: str, state: "AssertionState") -> bool:
170         """A fast way to get out of rewriting modules.
171 
172         Profiling has shown that the call to PathFinder.find_spec (inside of
173         the find_spec from this class) is a major slowdown, so, this method
174         tries to filter what we're sure won't be rewritten before getting to
175         it.
176         """
177         if self.session is not None and not self._session_paths_checked:
178             self._session_paths_checked = True
179             for initial_path in self.session._initialpaths:
180                 # Make something as c:/projects/my_project/path.py ->
181                 #     ['c:', 'projects', 'my_project', 'path.py']
182                 parts = str(initial_path).split(os.sep)
183                 # add 'path' to basenames to be checked.
184                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])
185 
186         # Note: conftest already by default in _basenames_to_check_rewrite.
187         parts = name.split(".")
188         if parts[-1] in self._basenames_to_check_rewrite:
189             return False
190 
191         # For matching the name it must be as if it was a filename.
192         path = PurePath(*parts).with_suffix(".py")
193 
194         for pat in self.fnpats:
195             # if the pattern contains subdirectories ("tests/**.py" for example) we can't bail out based
196             # on the name alone because we need to match against the full path
197             if os.path.dirname(pat):
198                 return False
199             if fnmatch_ex(pat, path):
200                 return False
201 
202         if self._is_marked_for_rewrite(name, state):
203             return False
204 
205         state.trace(f"early skip of rewriting module: {name}")
206         return True
207 
208     def _should_rewrite(self, name: str, fn: str, state: "AssertionState") -> bool:
209         # always rewrite conftest files
210         if os.path.basename(fn) == "conftest.py":
211             state.trace(f"rewriting conftest file: {fn!r}")
212             return True
213 
214         if self.session is not None:
215             if self.session.isinitpath(absolutepath(fn)):
216                 state.trace(f"matched test file (was specified on cmdline): {fn!r}")
217                 return True
218 
219         # modules not passed explicitly on the command line are only
220         # rewritten if they match the naming convention for test files
221         fn_path = PurePath(fn)
222         for pat in self.fnpats:
223             if fnmatch_ex(pat, fn_path):
224                 state.trace(f"matched test file {fn!r}")
225                 return True
226 
227         return self._is_marked_for_rewrite(name, state)
228 
229     def _is_marked_for_rewrite(self, name: str, state: "AssertionState") -> bool:
230         try:
231             return self._marked_for_rewrite_cache[name]
232         except KeyError:
233             for marked in self._must_rewrite:
234                 if name == marked or name.startswith(marked + "."):
235                     state.trace(f"matched marked file {name!r} (from {marked!r})")
236                     self._marked_for_rewrite_cache[name] = True
237                     return True
238 
239             self._marked_for_rewrite_cache[name] = False
240             return False
241 
242     def mark_rewrite(self, *names: str) -> None:
243         """Mark import names as needing to be rewritten.
244 
245         The named module or package as well as any nested modules will
246         be rewritten on import.
247         """
248         already_imported = (
249             set(names).intersection(sys.modules).difference(self._rewritten_names)
250         )
251         for name in already_imported:
252             mod = sys.modules[name]
253             if not AssertionRewriter.is_rewrite_disabled(
254                 mod.__doc__ or ""
255             ) and not isinstance(mod.__loader__, type(self)):
256                 self._warn_already_imported(name)
257         self._must_rewrite.update(names)
258         self._marked_for_rewrite_cache.clear()
259 
260     def _warn_already_imported(self, name: str) -> None:
261         from _pytest.warning_types import PytestAssertRewriteWarning
262 
263         self.config.issue_config_time_warning(
264             PytestAssertRewriteWarning(
265                 "Module already imported so cannot be rewritten: %s" % name
266             ),
267             stacklevel=5,
268         )
269 
270     def get_data(self, pathname: Union[str, bytes]) -> bytes:
271         """Optional PEP302 get_data API."""
272         with open(pathname, "rb") as f:
273             return f.read()
274 
275     if sys.version_info >= (3, 10):
276         if sys.version_info >= (3, 12):
277             from importlib.resources.abc import TraversableResources
278         else:
279             from importlib.abc import TraversableResources
280 
281         def get_resource_reader(self, name: str) -> TraversableResources:  # type: ignore
282             if sys.version_info < (3, 11):
283                 from importlib.readers import FileReader
284             else:
285                 from importlib.resources.readers import FileReader
286 
287             return FileReader(  # type:ignore[no-any-return]
288                 types.SimpleNamespace(path=self._rewritten_names[name])
289             )
290 
291 
292 def _write_pyc_fp(
293     fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType
294 ) -> None:
295     # Technically, we don't have to have the same pyc format as
296     # (C)Python, since these "pycs" should never be seen by builtin
297     # import. However, there's little reason to deviate.
298     fp.write(importlib.util.MAGIC_NUMBER)
299     # https://www.python.org/dev/peps/pep-0552/
300     flags = b"\x00\x00\x00\x00"
301     fp.write(flags)
302     # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)
303     mtime = int(source_stat.st_mtime) & 0xFFFFFFFF
304     size = source_stat.st_size & 0xFFFFFFFF
305     # "<LL" stands for 2 unsigned longs, little-endian.
306     fp.write(struct.pack("<LL", mtime, size))
307     fp.write(marshal.dumps(co))
308 
309 
310 def _write_pyc(
311     state: "AssertionState",
312     co: types.CodeType,
313     source_stat: os.stat_result,
314     pyc: Path,
315 ) -> bool:
316     proc_pyc = f"{pyc}.{os.getpid()}"
317     try:
318         with open(proc_pyc, "wb") as fp:
319             _write_pyc_fp(fp, source_stat, co)
320     except OSError as e:
321         state.trace(f"error writing pyc file at {proc_pyc}: errno={e.errno}")
322         return False
323 
324     try:
325         os.replace(proc_pyc, pyc)
326     except OSError as e:
327         state.trace(f"error writing pyc file at {pyc}: {e}")
328         # we ignore any failure to write the cache file
329         # there are many reasons, permission-denied, pycache dir being a
330         # file etc.
331         return False
332     return True
333 
334 
335 def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeType]:
336     """Read and rewrite *fn* and return the code object."""
337     stat = os.stat(fn)
338     source = fn.read_bytes()
339     strfn = str(fn)
340     tree = ast.parse(source, filename=strfn)
341     rewrite_asserts(tree, source, strfn, config)
342     co = compile(tree, strfn, "exec", dont_inherit=True)
343     return stat, co
344 
345 
346 def _read_pyc(
347     source: Path, pyc: Path, trace: Callable[[str], None] = lambda x: None
348 ) -> Optional[types.CodeType]:
349     """Possibly read a pytest pyc containing rewritten code.
350 
351     Return rewritten code if successful or None if not.
352     """
353     try:
354         fp = open(pyc, "rb")
355     except OSError:
356         return None
357     with fp:
358         try:
359             stat_result = os.stat(source)
360             mtime = int(stat_result.st_mtime)
361             size = stat_result.st_size
362             data = fp.read(16)
363         except OSError as e:
364             trace(f"_read_pyc({source}): OSError {e}")
365             return None
366         # Check for invalid or out of date pyc file.
367         if len(data) != (16):
368             trace("_read_pyc(%s): invalid pyc (too short)" % source)
369             return None
370         if data[:4] != importlib.util.MAGIC_NUMBER:
371             trace("_read_pyc(%s): invalid pyc (bad magic number)" % source)
372             return None
373         if data[4:8] != b"\x00\x00\x00\x00":
374             trace("_read_pyc(%s): invalid pyc (unsupported flags)" % source)
375             return None
376         mtime_data = data[8:12]
377         if int.from_bytes(mtime_data, "little") != mtime & 0xFFFFFFFF:
378             trace("_read_pyc(%s): out of date" % source)
379             return None
380         size_data = data[12:16]
381         if int.from_bytes(size_data, "little") != size & 0xFFFFFFFF:
382             trace("_read_pyc(%s): invalid pyc (incorrect size)" % source)
383             return None
384         try:
385             co = marshal.load(fp)
386         except Exception as e:
387             trace(f"_read_pyc({source}): marshal.load error {e}")
388             return None
389         if not isinstance(co, types.CodeType):
390             trace("_read_pyc(%s): not a code object" % source)
391             return None
392         return co
393 
394 
395 def rewrite_asserts(
396     mod: ast.Module,
397     source: bytes,
398     module_path: Optional[str] = None,
399     config: Optional[Config] = None,
400 ) -> None:
401     """Rewrite the assert statements in mod."""
402     AssertionRewriter(module_path, config, source).run(mod)
403 
404 
405 def _saferepr(obj: object) -> str:
406     r"""Get a safe repr of an object for assertion error messages.
407 
408     The assertion formatting (util.format_explanation()) requires
409     newlines to be escaped since they are a special character for it.
410     Normally assertion.util.format_explanation() does this but for a
411     custom repr it is possible to contain one of the special escape
412     sequences, especially '\n{' and '\n}' are likely to be present in
413     JSON reprs.
414     """
415     maxsize = _get_maxsize_for_saferepr(util._config)
416     return saferepr(obj, maxsize=maxsize).replace("\n", "\\n")
417 
418 
419 def _get_maxsize_for_saferepr(config: Optional[Config]) -> Optional[int]:
420     """Get `maxsize` configuration for saferepr based on the given config object."""
421     verbosity = config.getoption("verbose") if config is not None else 0
422     if verbosity >= 2:
423         return None
424     if verbosity >= 1:
425         return DEFAULT_REPR_MAX_SIZE * 10
426     return DEFAULT_REPR_MAX_SIZE
427 
428 
429 def _format_assertmsg(obj: object) -> str:
430     r"""Format the custom assertion message given.
431 
432     For strings this simply replaces newlines with '\n~' so that
433     util.format_explanation() will preserve them instead of escaping
434     newlines.  For other objects saferepr() is used first.
435     """
436     # reprlib appears to have a bug which means that if a string
437     # contains a newline it gets escaped, however if an object has a
438     # .__repr__() which contains newlines it does not get escaped.
439     # However in either case we want to preserve the newline.
440     replaces = [("\n", "\n~"), ("%", "%%")]
441     if not isinstance(obj, str):
442         obj = saferepr(obj)
443         replaces.append(("\\n", "\n~"))
444 
445     for r1, r2 in replaces:
446         obj = obj.replace(r1, r2)
447 
448     return obj
449 
450 
451 def _should_repr_global_name(obj: object) -> bool:
452     if callable(obj):
453         return False
454 
455     try:
456         return not hasattr(obj, "__name__")
457     except Exception:
458         return True
459 
460 
461 def _format_boolop(explanations: Iterable[str], is_or: bool) -> str:
462     explanation = "(" + (is_or and " or " or " and ").join(explanations) + ")"
463     return explanation.replace("%", "%%")
464 
465 
466 def _call_reprcompare(
467     ops: Sequence[str],
468     results: Sequence[bool],
469     expls: Sequence[str],
470     each_obj: Sequence[object],
471 ) -> str:
472     for i, res, expl in zip(range(len(ops)), results, expls):
473         try:
474             done = not res
475         except Exception:
476             done = True
477         if done:
478             break
479     if util._reprcompare is not None:
480         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
481         if custom is not None:
482             return custom
483     return expl
484 
485 
486 def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:
487     if util._assertion_pass is not None:
488         util._assertion_pass(lineno, orig, expl)
489 
490 
491 def _check_if_assertion_pass_impl() -> bool:
492     """Check if any plugins implement the pytest_assertion_pass hook
493     in order not to generate explanation unnecessarily (might be expensive)."""
494     return True if util._assertion_pass else False
495 
496 
497 UNARY_MAP = {ast.Not: "not %s", ast.Invert: "~%s", ast.USub: "-%s", ast.UAdd: "+%s"}
498 
499 BINOP_MAP = {
500     ast.BitOr: "|",
501     ast.BitXor: "^",
502     ast.BitAnd: "&",
503     ast.LShift: "<<",
504     ast.RShift: ">>",
505     ast.Add: "+",
506     ast.Sub: "-",
507     ast.Mult: "*",
508     ast.Div: "/",
509     ast.FloorDiv: "//",
510     ast.Mod: "%%",  # escaped for string formatting
511     ast.Eq: "==",
512     ast.NotEq: "!=",
513     ast.Lt: "<",
514     ast.LtE: "<=",
515     ast.Gt: ">",
516     ast.GtE: ">=",
517     ast.Pow: "**",
518     ast.Is: "is",
519     ast.IsNot: "is not",
520     ast.In: "in",
521     ast.NotIn: "not in",
522     ast.MatMult: "@",
523 }
524 
525 
526 def traverse_node(node: ast.AST) -> Iterator[ast.AST]:
527     """Recursively yield node and all its children in depth-first order."""
528     yield node
529     for child in ast.iter_child_nodes(node):
530         yield from traverse_node(child)
531 
532 
533 @functools.lru_cache(maxsize=1)
534 def _get_assertion_exprs(src: bytes) -> Dict[int, str]:
535     """Return a mapping from {lineno: "assertion test expression"}."""
536     ret: Dict[int, str] = {}
537 
538     depth = 0
539     lines: List[str] = []
540     assert_lineno: Optional[int] = None
541     seen_lines: Set[int] = set()
542 
543     def _write_and_reset() -> None:
544         nonlocal depth, lines, assert_lineno, seen_lines
545         assert assert_lineno is not None
546         ret[assert_lineno] = "".join(lines).rstrip().rstrip("\\")
547         depth = 0
548         lines = []
549         assert_lineno = None
550         seen_lines = set()
551 
552     tokens = tokenize.tokenize(io.BytesIO(src).readline)
553     for tp, source, (lineno, offset), _, line in tokens:
554         if tp == tokenize.NAME and source == "assert":
555             assert_lineno = lineno
556         elif assert_lineno is not None:
557             # keep track of depth for the assert-message `,` lookup
558             if tp == tokenize.OP and source in "([{":
559                 depth += 1
560             elif tp == tokenize.OP and source in ")]}":
561                 depth -= 1
562 
563             if not lines:
564                 lines.append(line[offset:])
565                 seen_lines.add(lineno)
566             # a non-nested comma separates the expression from the message
567             elif depth == 0 and tp == tokenize.OP and source == ",":
568                 # one line assert with message
569                 if lineno in seen_lines and len(lines) == 1:
570                     offset_in_trimmed = offset + len(lines[-1]) - len(line)
571                     lines[-1] = lines[-1][:offset_in_trimmed]
572                 # multi-line assert with message
573                 elif lineno in seen_lines:
574                     lines[-1] = lines[-1][:offset]
575                 # multi line assert with escapd newline before message
576                 else:
577                     lines.append(line[:offset])
578                 _write_and_reset()
579             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:
580                 _write_and_reset()
581             elif lines and lineno not in seen_lines:
582                 lines.append(line)
583                 seen_lines.add(lineno)
584 
585     return ret
586 
587 
588 class AssertionRewriter(ast.NodeVisitor):
589     """Assertion rewriting implementation.
590 
591     The main entrypoint is to call .run() with an ast.Module instance,
592     this will then find all the assert statements and rewrite them to
593     provide intermediate values and a detailed assertion error.  See
594     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html
595     for an overview of how this works.
596 
597     The entry point here is .run() which will iterate over all the
598     statements in an ast.Module and for each ast.Assert statement it
599     finds call .visit() with it.  Then .visit_Assert() takes over and
600     is responsible for creating new ast statements to replace the
601     original assert statement: it rewrites the test of an assertion
602     to provide intermediate values and replace it with an if statement
603     which raises an assertion error with a detailed explanation in
604     case the expression is false and calls pytest_assertion_pass hook
605     if expression is true.
606 
607     For this .visit_Assert() uses the visitor pattern to visit all the
608     AST nodes of the ast.Assert.test field, each visit call returning
609     an AST node and the corresponding explanation string.  During this
610     state is kept in several instance attributes:
611 
612     :statements: All the AST statements which will replace the assert
613        statement.
614 
615     :variables: This is populated by .variable() with each variable
616        used by the statements so that they can all be set to None at
617        the end of the statements.
618 
619     :variable_counter: Counter to create new unique variables needed
620        by statements.  Variables are created using .variable() and
621        have the form of "@py_assert0".
622 
623     :expl_stmts: The AST statements which will be executed to get
624        data from the assertion.  This is the code which will construct
625        the detailed assertion message that is used in the AssertionError
626        or for the pytest_assertion_pass hook.
627 
628     :explanation_specifiers: A dict filled by .explanation_param()
629        with %-formatting placeholders and their corresponding
630        expressions to use in the building of an assertion message.
631        This is used by .pop_format_context() to build a message.
632 
633     :stack: A stack of the explanation_specifiers dicts maintained by
634        .push_format_context() and .pop_format_context() which allows
635        to build another %-formatted string while already building one.
636 
637     :variables_overwrite: A dict filled with references to variables
638        that change value within an assert. This happens when a variable is
639        reassigned with the walrus operator
640 
641     This state, except the variables_overwrite,  is reset on every new assert
642     statement visited and used by the other visitors.
643     """
644 
645     def __init__(
646         self, module_path: Optional[str], config: Optional[Config], source: bytes
647     ) -> None:
648         super().__init__()
649         self.module_path = module_path
650         self.config = config
651         if config is not None:
652             self.enable_assertion_pass_hook = config.getini(
653                 "enable_assertion_pass_hook"
654             )
655         else:
656             self.enable_assertion_pass_hook = False
657         self.source = source
658         self.variables_overwrite: Dict[str, str] = {}
659 
660     def run(self, mod: ast.Module) -> None:
661         """Find all assert statements in *mod* and rewrite them."""
662         if not mod.body:
663             # Nothing to do.
664             return
665 
666         # We'll insert some special imports at the top of the module, but after any
667         # docstrings and __future__ imports, so first figure out where that is.
668         doc = getattr(mod, "docstring", None)
669         expect_docstring = doc is None
670         if doc is not None and self.is_rewrite_disabled(doc):
671             return
672         pos = 0
673         item = None
674         for item in mod.body:
675             if (
676                 expect_docstring
677                 and isinstance(item, ast.Expr)
678                 and isinstance(item.value, ast.Constant)
679             ):
680                 doc = item.value.value
681                 if self.is_rewrite_disabled(doc):
682                     return
683                 expect_docstring = False
684             elif (
685                 isinstance(item, ast.ImportFrom)
686                 and item.level == 0
687                 and item.module == "__future__"
688             ):
689                 pass
690             else:
691                 break
692             pos += 1
693         # Special case: for a decorated function, set the lineno to that of the
694         # first decorator, not the `def`. Issue #4984.
695         if isinstance(item, ast.FunctionDef) and item.decorator_list:
696             lineno = item.decorator_list[0].lineno
697         else:
698             lineno = item.lineno
699         # Now actually insert the special imports.
700         if sys.version_info >= (3, 10):
701             aliases = [
702                 ast.alias("builtins", "@py_builtins", lineno=lineno, col_offset=0),
703                 ast.alias(
704                     "_pytest.assertion.rewrite",
705                     "@pytest_ar",
706                     lineno=lineno,
707                     col_offset=0,
708                 ),
709             ]
710         else:
711             aliases = [
712                 ast.alias("builtins", "@py_builtins"),
713                 ast.alias("_pytest.assertion.rewrite", "@pytest_ar"),
714             ]
715         imports = [
716             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases
717         ]
718         mod.body[pos:pos] = imports
719 
720         # Collect asserts.
721         nodes: List[ast.AST] = [mod]
722         while nodes:
723             node = nodes.pop()
724             for name, field in ast.iter_fields(node):
725                 if isinstance(field, list):
726                     new: List[ast.AST] = []
727                     for i, child in enumerate(field):
728                         if isinstance(child, ast.Assert):
729                             # Transform assert.
730                             new.extend(self.visit(child))
731                         else:
732                             new.append(child)
733                             if isinstance(child, ast.AST):
734                                 nodes.append(child)
735                     setattr(node, name, new)
736                 elif (
737                     isinstance(field, ast.AST)
738                     # Don't recurse into expressions as they can't contain
739                     # asserts.
740                     and not isinstance(field, ast.expr)
741                 ):
742                     nodes.append(field)
743 
744     @staticmethod
745     def is_rewrite_disabled(docstring: str) -> bool:
746         return "PYTEST_DONT_REWRITE" in docstring
747 
748     def variable(self) -> str:
749         """Get a new variable."""
750         # Use a character invalid in python identifiers to avoid clashing.
751         name = "@py_assert" + str(next(self.variable_counter))
752         self.variables.append(name)
753         return name
754 
755     def assign(self, expr: ast.expr) -> ast.Name:
756         """Give *expr* a name."""
757         name = self.variable()
758         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))
759         return ast.Name(name, ast.Load())
760 
761     def display(self, expr: ast.expr) -> ast.expr:
762         """Call saferepr on the expression."""
763         return self.helper("_saferepr", expr)
764 
765     def helper(self, name: str, *args: ast.expr) -> ast.expr:
766         """Call a helper in this module."""
767         py_name = ast.Name("@pytest_ar", ast.Load())
768         attr = ast.Attribute(py_name, name, ast.Load())
769         return ast.Call(attr, list(args), [])
770 
771     def builtin(self, name: str) -> ast.Attribute:
772         """Return the builtin called *name*."""
773         builtin_name = ast.Name("@py_builtins", ast.Load())
774         return ast.Attribute(builtin_name, name, ast.Load())
775 
776     def explanation_param(self, expr: ast.expr) -> str:
777         """Return a new named %-formatting placeholder for expr.
778 
779         This creates a %-formatting placeholder for expr in the
780         current formatting context, e.g. ``%(py0)s``.  The placeholder
781         and expr are placed in the current format context so that it
782         can be used on the next call to .pop_format_context().
783         """
784         specifier = "py" + str(next(self.variable_counter))
785         self.explanation_specifiers[specifier] = expr
786         return "%(" + specifier + ")s"
787 
788     def push_format_context(self) -> None:
789         """Create a new formatting context.
790 
791         The format context is used for when an explanation wants to
792         have a variable value formatted in the assertion message.  In
793         this case the value required can be added using
794         .explanation_param().  Finally .pop_format_context() is used
795         to format a string of %-formatted values as added by
796         .explanation_param().
797         """
798         self.explanation_specifiers: Dict[str, ast.expr] = {}
799         self.stack.append(self.explanation_specifiers)
800 
801     def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:
802         """Format the %-formatted string with current format context.
803 
804         The expl_expr should be an str ast.expr instance constructed from
805         the %-placeholders created by .explanation_param().  This will
806         add the required code to format said string to .expl_stmts and
807         return the ast.Name instance of the formatted string.
808         """
809         current = self.stack.pop()
810         if self.stack:
811             self.explanation_specifiers = self.stack[-1]
812         keys = [ast.Constant(key) for key in current.keys()]
813         format_dict = ast.Dict(keys, list(current.values()))
814         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)
815         name = "@py_format" + str(next(self.variable_counter))
816         if self.enable_assertion_pass_hook:
817             self.format_variables.append(name)
818         self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))
819         return ast.Name(name, ast.Load())
820 
821     def generic_visit(self, node: ast.AST) -> Tuple[ast.Name, str]:
822         """Handle expressions we don't have custom code for."""
823         assert isinstance(node, ast.expr)
824         res = self.assign(node)
825         return res, self.explanation_param(self.display(res))
826 
827     def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:
828         """Return the AST statements to replace the ast.Assert instance.
829 
830         This rewrites the test of an assertion to provide
831         intermediate values and replace it with an if statement which
832         raises an assertion error with a detailed explanation in case
833         the expression is false.
834         """
835         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
836             from _pytest.warning_types import PytestAssertRewriteWarning
837             import warnings
838 
839             # TODO: This assert should not be needed.
840             assert self.module_path is not None
841             warnings.warn_explicit(
842                 PytestAssertRewriteWarning(
843                     "assertion is always true, perhaps remove parentheses?"
844                 ),
845                 category=None,
846                 filename=self.module_path,
847                 lineno=assert_.lineno,
848             )
849 
850         self.statements: List[ast.stmt] = []
851         self.variables: List[str] = []
852         self.variable_counter = itertools.count()
853 
854         if self.enable_assertion_pass_hook:
855             self.format_variables: List[str] = []
856 
857         self.stack: List[Dict[str, ast.expr]] = []
858         self.expl_stmts: List[ast.stmt] = []
859         self.push_format_context()
860         # Rewrite assert into a bunch of statements.
861         top_condition, explanation = self.visit(assert_.test)
862 
863         negation = ast.UnaryOp(ast.Not(), top_condition)
864 
865         if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook
866             msg = self.pop_format_context(ast.Constant(explanation))
867 
868             # Failed
869             if assert_.msg:
870                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
871                 gluestr = "\n>assert "
872             else:
873                 assertmsg = ast.Constant("")
874                 gluestr = "assert "
875             err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)
876             err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)
877             err_name = ast.Name("AssertionError", ast.Load())
878             fmt = self.helper("_format_explanation", err_msg)
879             exc = ast.Call(err_name, [fmt], [])
880             raise_ = ast.Raise(exc, None)
881             statements_fail = []
882             statements_fail.extend(self.expl_stmts)
883             statements_fail.append(raise_)
884 
885             # Passed
886             fmt_pass = self.helper("_format_explanation", msg)
887             orig = _get_assertion_exprs(self.source)[assert_.lineno]
888             hook_call_pass = ast.Expr(
889                 self.helper(
890                     "_call_assertion_pass",
891                     ast.Constant(assert_.lineno),
892                     ast.Constant(orig),
893                     fmt_pass,
894                 )
895             )
896             # If any hooks implement assert_pass hook
897             hook_impl_test = ast.If(
898                 self.helper("_check_if_assertion_pass_impl"),
899                 self.expl_stmts + [hook_call_pass],
900                 [],
901             )
902             statements_pass = [hook_impl_test]
903 
904             # Test for assertion condition
905             main_test = ast.If(negation, statements_fail, statements_pass)
906             self.statements.append(main_test)
907             if self.format_variables:
908                 variables = [
909                     ast.Name(name, ast.Store()) for name in self.format_variables
910                 ]
911                 clear_format = ast.Assign(variables, ast.Constant(None))
912                 self.statements.append(clear_format)
913 
914         else:  # Original assertion rewriting
915             # Create failure message.
916             body = self.expl_stmts
917             self.statements.append(ast.If(negation, body, []))
918             if assert_.msg:
919                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
920                 explanation = "\n>assert " + explanation
921             else:
922                 assertmsg = ast.Constant("")
923                 explanation = "assert " + explanation
924             template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))
925             msg = self.pop_format_context(template)
926             fmt = self.helper("_format_explanation", msg)
927             err_name = ast.Name("AssertionError", ast.Load())
928             exc = ast.Call(err_name, [fmt], [])
929             raise_ = ast.Raise(exc, None)
930 
931             body.append(raise_)
932 
933         # Clear temporary variables by setting them to None.
934         if self.variables:
935             variables = [ast.Name(name, ast.Store()) for name in self.variables]
936             clear = ast.Assign(variables, ast.Constant(None))
937             self.statements.append(clear)
938         # Fix locations (line numbers/column offsets).
939         for stmt in self.statements:
940             for node in traverse_node(stmt):
941                 ast.copy_location(node, assert_)
942         return self.statements
943 
944     def visit_NamedExpr(self, name: ast.NamedExpr) -> Tuple[ast.NamedExpr, str]:
945         # This method handles the 'walrus operator' repr of the target
946         # name if it's a local variable or _should_repr_global_name()
947         # thinks it's acceptable.
948         locs = ast.Call(self.builtin("locals"), [], [])
949         target_id = name.target.id  # type: ignore[attr-defined]
950         inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])
951         dorepr = self.helper("_should_repr_global_name", name)
952         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
953         expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))
954         return name, self.explanation_param(expr)
955 
956     def visit_Name(self, name: ast.Name) -> Tuple[ast.Name, str]:
957         # Display the repr of the name if it's a local variable or
958         # _should_repr_global_name() thinks it's acceptable.
959         locs = ast.Call(self.builtin("locals"), [], [])
960         inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])
961         dorepr = self.helper("_should_repr_global_name", name)
962         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
963         expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))
964         return name, self.explanation_param(expr)
965 
966     def visit_BoolOp(self, boolop: ast.BoolOp) -> Tuple[ast.Name, str]:
967         res_var = self.variable()
968         expl_list = self.assign(ast.List([], ast.Load()))
969         app = ast.Attribute(expl_list, "append", ast.Load())
970         is_or = int(isinstance(boolop.op, ast.Or))
971         body = save = self.statements
972         fail_save = self.expl_stmts
973         levels = len(boolop.values) - 1
974         self.push_format_context()
975         # Process each operand, short-circuiting if needed.
976         for i, v in enumerate(boolop.values):
977             if i:
978                 fail_inner: List[ast.stmt] = []
979                 # cond is set in a prior loop iteration below
980                 self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa
981                 self.expl_stmts = fail_inner
982                 # Check if the left operand is a ast.NamedExpr and the value has already been visited
983                 if (
984                     isinstance(v, ast.Compare)
985                     and isinstance(v.left, ast.NamedExpr)
986                     and v.left.target.id
987                     in [
988                         ast_expr.id
989                         for ast_expr in boolop.values[:i]
990                         if hasattr(ast_expr, "id")
991                     ]
992                 ):
993                     pytest_temp = self.variable()
994                     self.variables_overwrite[
995                         v.left.target.id
996                     ] = v.left  # type:ignore[assignment]
997                     v.left.target.id = pytest_temp
998             self.push_format_context()
999             res, expl = self.visit(v)
1000             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))
1001             expl_format = self.pop_format_context(ast.Constant(expl))
1002             call = ast.Call(app, [expl_format], [])
1003             self.expl_stmts.append(ast.Expr(call))
1004             if i < levels:
1005                 cond: ast.expr = res
1006                 if is_or:
1007                     cond = ast.UnaryOp(ast.Not(), cond)
1008                 inner: List[ast.stmt] = []
1009                 self.statements.append(ast.If(cond, inner, []))
1010                 self.statements = body = inner
1011         self.statements = save
1012         self.expl_stmts = fail_save
1013         expl_template = self.helper("_format_boolop", expl_list, ast.Constant(is_or))
1014         expl = self.pop_format_context(expl_template)
1015         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)
1016 
1017     def visit_UnaryOp(self, unary: ast.UnaryOp) -> Tuple[ast.Name, str]:
1018         pattern = UNARY_MAP[unary.op.__class__]
1019         operand_res, operand_expl = self.visit(unary.operand)
1020         res = self.assign(ast.UnaryOp(unary.op, operand_res))
1021         return res, pattern % (operand_expl,)
1022 
1023     def visit_BinOp(self, binop: ast.BinOp) -> Tuple[ast.Name, str]:
1024         symbol = BINOP_MAP[binop.op.__class__]
1025         left_expr, left_expl = self.visit(binop.left)
1026         right_expr, right_expl = self.visit(binop.right)
1027         explanation = f"({left_expl} {symbol} {right_expl})"
1028         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))
1029         return res, explanation
1030 
1031     def visit_Call(self, call: ast.Call) -> Tuple[ast.Name, str]:
1032         new_func, func_expl = self.visit(call.func)
1033         arg_expls = []
1034         new_args = []
1035         new_kwargs = []
1036         for arg in call.args:
1037             if isinstance(arg, ast.Name) and arg.id in self.variables_overwrite:
1038                 arg = self.variables_overwrite[arg.id]  # type:ignore[assignment]
1039             res, expl = self.visit(arg)
1040             arg_expls.append(expl)
1041             new_args.append(res)
1042         for keyword in call.keywords:
1043             if (
1044                 isinstance(keyword.value, ast.Name)
1045                 and keyword.value.id in self.variables_overwrite
1046             ):
1047                 keyword.value = self.variables_overwrite[
1048                     keyword.value.id
1049                 ]  # type:ignore[assignment]
1050             res, expl = self.visit(keyword.value)
1051             new_kwargs.append(ast.keyword(keyword.arg, res))
1052             if keyword.arg:
1053                 arg_expls.append(keyword.arg + "=" + expl)
1054             else:  # **args have `arg` keywords with an .arg of None
1055                 arg_expls.append("**" + expl)
1056 
1057         expl = "{}({})".format(func_expl, ", ".join(arg_expls))
1058         new_call = ast.Call(new_func, new_args, new_kwargs)
1059         res = self.assign(new_call)
1060         res_expl = self.explanation_param(self.display(res))
1061         outer_expl = f"{res_expl}\n{{{res_expl} = {expl}\n}}"
1062         return res, outer_expl
1063 
1064     def visit_Starred(self, starred: ast.Starred) -> Tuple[ast.Starred, str]:
1065         # A Starred node can appear in a function call.
1066         res, expl = self.visit(starred.value)
1067         new_starred = ast.Starred(res, starred.ctx)
1068         return new_starred, "*" + expl
1069 
1070     def visit_Attribute(self, attr: ast.Attribute) -> Tuple[ast.Name, str]:
1071         if not isinstance(attr.ctx, ast.Load):
1072             return self.generic_visit(attr)
1073         value, value_expl = self.visit(attr.value)
1074         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))
1075         res_expl = self.explanation_param(self.display(res))
1076         pat = "%s\n{%s = %s.%s\n}"
1077         expl = pat % (res_expl, res_expl, value_expl, attr.attr)
1078         return res, expl
1079 
1080     def visit_Compare(self, comp: ast.Compare) -> Tuple[ast.expr, str]:
1081         self.push_format_context()
1082         # We first check if we have overwritten a variable in the previous assert
1083         if isinstance(comp.left, ast.Name) and comp.left.id in self.variables_overwrite:
1084             comp.left = self.variables_overwrite[
1085                 comp.left.id
1086             ]  # type:ignore[assignment]
1087         if isinstance(comp.left, ast.NamedExpr):
1088             self.variables_overwrite[
1089                 comp.left.target.id
1090             ] = comp.left  # type:ignore[assignment]
1091         left_res, left_expl = self.visit(comp.left)
1092         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):
1093             left_expl = f"({left_expl})"
1094         res_variables = [self.variable() for i in range(len(comp.ops))]
1095         load_names = [ast.Name(v, ast.Load()) for v in res_variables]
1096         store_names = [ast.Name(v, ast.Store()) for v in res_variables]
1097         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)
1098         expls = []
1099         syms = []
1100         results = [left_res]
1101         for i, op, next_operand in it:
1102             if (
1103                 isinstance(next_operand, ast.NamedExpr)
1104                 and isinstance(left_res, ast.Name)
1105                 and next_operand.target.id == left_res.id
1106             ):
1107                 next_operand.target.id = self.variable()
1108                 self.variables_overwrite[
1109                     left_res.id
1110                 ] = next_operand  # type:ignore[assignment]
1111             next_res, next_expl = self.visit(next_operand)
1112             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):
1113                 next_expl = f"({next_expl})"
1114             results.append(next_res)
1115             sym = BINOP_MAP[op.__class__]
1116             syms.append(ast.Constant(sym))
1117             expl = f"{left_expl} {sym} {next_expl}"
1118             expls.append(ast.Constant(expl))
1119             res_expr = ast.Compare(left_res, [op], [next_res])
1120             self.statements.append(ast.Assign([store_names[i]], res_expr))
1121             left_res, left_expl = next_res, next_expl
1122         # Use pytest.assertion.util._reprcompare if that's available.
1123         expl_call = self.helper(
1124             "_call_reprcompare",
1125             ast.Tuple(syms, ast.Load()),
1126             ast.Tuple(load_names, ast.Load()),
1127             ast.Tuple(expls, ast.Load()),
1128             ast.Tuple(results, ast.Load()),
1129         )
1130         if len(comp.ops) > 1:
1131             res: ast.expr = ast.BoolOp(ast.And(), load_names)
1132         else:
1133             res = load_names[0]
1134 
1135         return res, self.explanation_param(self.pop_format_context(expl_call))
1136 
1137 
1138 def try_makedirs(cache_dir: Path) -> bool:
1139     """Attempt to create the given directory and sub-directories exist.
1140 
1141     Returns True if successful or if it already exists.
1142     """
1143     try:
1144         os.makedirs(cache_dir, exist_ok=True)
1145     except (FileNotFoundError, NotADirectoryError, FileExistsError):
1146         # One of the path components was not a directory:
1147         # - we're in a zip file
1148         # - it is a file
1149         return False
1150     except PermissionError:
1151         return False
1152     except OSError as e:
1153         # as of now, EROFS doesn't have an equivalent OSError-subclass
1154         if e.errno == errno.EROFS:
1155             return False
1156         raise
1157     return True
1158 
1159 
1160 def get_cache_dir(file_path: Path) -> Path:
1161     """Return the cache directory to write .pyc files for the given .py file path."""
1162     if sys.pycache_prefix:
1163         # given:
1164         #   prefix = '/tmp/pycs'
1165         #   path = '/home/user/proj/test_app.py'
1166         # we want:
1167         #   '/tmp/pycs/home/user/proj'
1168         return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])
1169     else:
1170         # classic pycache directory
1171         return file_path.parent / "__pycache__"

</code><intended_behavior>Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module.</intended_behavior>, <file>testing/test_config.py</file>
<class>None</class>
<method>None</method>
<code>
1 import dataclasses
2 import importlib.metadata
3 import os
4 import re
5 import sys
6 import textwrap
7 from pathlib import Path
8 from typing import Dict
9 from typing import List
10 from typing import Sequence
11 from typing import Tuple
12 from typing import Type
13 from typing import Union
14 
15 import _pytest._code
16 import pytest
17 from _pytest.config import _get_plugin_specs_as_list
18 from _pytest.config import _iter_rewritable_modules
19 from _pytest.config import _strtobool
20 from _pytest.config import Config
21 from _pytest.config import ConftestImportFailure
22 from _pytest.config import ExitCode
23 from _pytest.config import parse_warning_filter
24 from _pytest.config.exceptions import UsageError
25 from _pytest.config.findpaths import determine_setup
26 from _pytest.config.findpaths import get_common_ancestor
27 from _pytest.config.findpaths import locate_config
28 from _pytest.monkeypatch import MonkeyPatch
29 from _pytest.pathlib import absolutepath
30 from _pytest.pytester import Pytester
31 
32 
33 class TestParseIni:
34     @pytest.mark.parametrize(
35         "section, filename", [("pytest", "pytest.ini"), ("tool:pytest", "setup.cfg")]
36     )
37     def test_getcfg_and_config(
38         self,
39         pytester: Pytester,
40         tmp_path: Path,
41         section: str,
42         filename: str,
43         monkeypatch: MonkeyPatch,
44     ) -> None:
45         sub = tmp_path / "sub"
46         sub.mkdir()
47         monkeypatch.chdir(sub)
48         (tmp_path / filename).write_text(
49             textwrap.dedent(
50                 """\
51                 [{section}]
52                 name = value
53                 """.format(
54                     section=section
55                 )
56             ),
57             encoding="utf-8",
58         )
59         _, _, cfg = locate_config([sub])
60         assert cfg["name"] == "value"
61         config = pytester.parseconfigure(str(sub))
62         assert config.inicfg["name"] == "value"
63 
64     def test_setupcfg_uses_toolpytest_with_pytest(self, pytester: Pytester) -> None:
65         p1 = pytester.makepyfile("def test(): pass")
66         pytester.makefile(
67             ".cfg",
68             setup="""
69                 [tool:pytest]
70                 testpaths=%s
71                 [pytest]
72                 testpaths=ignored
73         """
74             % p1.name,
75         )
76         result = pytester.runpytest()
77         result.stdout.fnmatch_lines(["configfile: setup.cfg", "* 1 passed in *"])
78         assert result.ret == 0
79 
80     def test_append_parse_args(
81         self, pytester: Pytester, tmp_path: Path, monkeypatch: MonkeyPatch
82     ) -> None:
83         monkeypatch.setenv("PYTEST_ADDOPTS", '--color no -rs --tb="short"')
84         tmp_path.joinpath("pytest.ini").write_text(
85             textwrap.dedent(
86                 """\
87                 [pytest]
88                 addopts = --verbose
89                 """
90             ),
91             encoding="utf-8",
92         )
93         config = pytester.parseconfig(tmp_path)
94         assert config.option.color == "no"
95         assert config.option.reportchars == "s"
96         assert config.option.tbstyle == "short"
97         assert config.option.verbose
98 
99     def test_tox_ini_wrong_version(self, pytester: Pytester) -> None:
100         pytester.makefile(
101             ".ini",
102             tox="""
103             [pytest]
104             minversion=999.0
105         """,
106         )
107         result = pytester.runpytest()
108         assert result.ret != 0
109         result.stderr.fnmatch_lines(
110             ["*tox.ini: 'minversion' requires pytest-999.0, actual pytest-*"]
111         )
112 
113     @pytest.mark.parametrize(
114         "section, name",
115         [
116             ("tool:pytest", "setup.cfg"),
117             ("pytest", "tox.ini"),
118             ("pytest", "pytest.ini"),
119             ("pytest", ".pytest.ini"),
120         ],
121     )
122     def test_ini_names(self, pytester: Pytester, name, section) -> None:
123         pytester.path.joinpath(name).write_text(
124             textwrap.dedent(
125                 """
126             [{section}]
127             minversion = 3.36
128         """.format(
129                     section=section
130                 )
131             ),
132             encoding="utf-8",
133         )
134         config = pytester.parseconfig()
135         assert config.getini("minversion") == "3.36"
136 
137     def test_pyproject_toml(self, pytester: Pytester) -> None:
138         pytester.makepyprojecttoml(
139             """
140             [tool.pytest.ini_options]
141             minversion = "1.0"
142         """
143         )
144         config = pytester.parseconfig()
145         assert config.getini("minversion") == "1.0"
146 
147     def test_toxini_before_lower_pytestini(self, pytester: Pytester) -> None:
148         sub = pytester.mkdir("sub")
149         sub.joinpath("tox.ini").write_text(
150             textwrap.dedent(
151                 """
152             [pytest]
153             minversion = 2.0
154         """
155             ),
156             encoding="utf-8",
157         )
158         pytester.path.joinpath("pytest.ini").write_text(
159             textwrap.dedent(
160                 """
161             [pytest]
162             minversion = 1.5
163         """
164             ),
165             encoding="utf-8",
166         )
167         config = pytester.parseconfigure(sub)
168         assert config.getini("minversion") == "2.0"
169 
170     def test_ini_parse_error(self, pytester: Pytester) -> None:
171         pytester.path.joinpath("pytest.ini").write_text(
172             "addopts = -x", encoding="utf-8"
173         )
174         result = pytester.runpytest()
175         assert result.ret != 0
176         result.stderr.fnmatch_lines("ERROR: *pytest.ini:1: no section header defined")
177 
178     def test_toml_parse_error(self, pytester: Pytester) -> None:
179         pytester.makepyprojecttoml(
180             """
181             \\"
182             """
183         )
184         result = pytester.runpytest()
185         assert result.ret != 0
186         result.stderr.fnmatch_lines("ERROR: *pyproject.toml: Invalid statement*")
187 
188     def test_confcutdir_default_without_configfile(self, pytester: Pytester) -> None:
189         # If --confcutdir is not specified, and there is no configfile, default
190         # to the roothpath.
191         sub = pytester.mkdir("sub")
192         os.chdir(sub)
193         config = pytester.parseconfigure()
194         assert config.pluginmanager._confcutdir == sub
195 
196     def test_confcutdir_default_with_configfile(self, pytester: Pytester) -> None:
197         # If --confcutdir is not specified, and there is a configfile, default
198         # to the configfile's directory.
199         pytester.makeini("[pytest]")
200         sub = pytester.mkdir("sub")
201         os.chdir(sub)
202         config = pytester.parseconfigure()
203         assert config.pluginmanager._confcutdir == pytester.path
204 
205     @pytest.mark.xfail(reason="probably not needed")
206     def test_confcutdir(self, pytester: Pytester) -> None:
207         sub = pytester.mkdir("sub")
208         os.chdir(sub)
209         pytester.makeini(
210             """
211             [pytest]
212             addopts = --qwe
213         """
214         )
215         result = pytester.inline_run("--confcutdir=.")
216         assert result.ret == 0
217 
218     @pytest.mark.parametrize(
219         "ini_file_text, invalid_keys, warning_output, exception_text",
220         [
221             pytest.param(
222                 """
223                 [pytest]
224                 unknown_ini = value1
225                 another_unknown_ini = value2
226                 """,
227                 ["unknown_ini", "another_unknown_ini"],
228                 [
229                     "=*= warnings summary =*=",
230                     "*PytestConfigWarning:*Unknown config option: another_unknown_ini",
231                     "*PytestConfigWarning:*Unknown config option: unknown_ini",
232                 ],
233                 "Unknown config option: another_unknown_ini",
234                 id="2-unknowns",
235             ),
236             pytest.param(
237                 """
238                 [pytest]
239                 unknown_ini = value1
240                 minversion = 5.0.0
241                 """,
242                 ["unknown_ini"],
243                 [
244                     "=*= warnings summary =*=",
245                     "*PytestConfigWarning:*Unknown config option: unknown_ini",
246                 ],
247                 "Unknown config option: unknown_ini",
248                 id="1-unknown",
249             ),
250             pytest.param(
251                 """
252                 [some_other_header]
253                 unknown_ini = value1
254                 [pytest]
255                 minversion = 5.0.0
256                 """,
257                 [],
258                 [],
259                 "",
260                 id="unknown-in-other-header",
261             ),
262             pytest.param(
263                 """
264                 [pytest]
265                 minversion = 5.0.0
266                 """,
267                 [],
268                 [],
269                 "",
270                 id="no-unknowns",
271             ),
272             pytest.param(
273                 """
274                 [pytest]
275                 conftest_ini_key = 1
276                 """,
277                 [],
278                 [],
279                 "",
280                 id="1-known",
281             ),
282         ],
283     )
284     @pytest.mark.filterwarnings("default")
285     def test_invalid_config_options(
286         self,
287         pytester: Pytester,
288         ini_file_text,
289         invalid_keys,
290         warning_output,
291         exception_text,
292     ) -> None:
293         pytester.makeconftest(
294             """
295             def pytest_addoption(parser):
296                 parser.addini("conftest_ini_key", "")
297             """
298         )
299         pytester.makepyfile("def test(): pass")
300         pytester.makeini(ini_file_text)
301 
302         config = pytester.parseconfig()
303         assert sorted(config._get_unknown_ini_keys()) == sorted(invalid_keys)
304 
305         result = pytester.runpytest()
306         result.stdout.fnmatch_lines(warning_output)
307 
308         result = pytester.runpytest("--strict-config")
309         if exception_text:
310             result.stderr.fnmatch_lines("ERROR: " + exception_text)
311             assert result.ret == pytest.ExitCode.USAGE_ERROR
312         else:
313             result.stderr.no_fnmatch_line(exception_text)
314             assert result.ret == pytest.ExitCode.OK
315 
316     @pytest.mark.filterwarnings("default")
317     def test_silence_unknown_key_warning(self, pytester: Pytester) -> None:
318         """Unknown config key warnings can be silenced using filterwarnings (#7620)"""
319         pytester.makeini(
320             """
321             [pytest]
322             filterwarnings =
323                 ignore:Unknown config option:pytest.PytestConfigWarning
324             foobar=1
325         """
326         )
327         result = pytester.runpytest()
328         result.stdout.no_fnmatch_line("*PytestConfigWarning*")
329 
330     @pytest.mark.filterwarnings("default::pytest.PytestConfigWarning")
331     def test_disable_warnings_plugin_disables_config_warnings(
332         self, pytester: Pytester
333     ) -> None:
334         """Disabling 'warnings' plugin also disables config time warnings"""
335         pytester.makeconftest(
336             """
337             import pytest
338             def pytest_configure(config):
339                 config.issue_config_time_warning(
340                     pytest.PytestConfigWarning("custom config warning"),
341                     stacklevel=2,
342                 )
343         """
344         )
345         result = pytester.runpytest("-pno:warnings")
346         result.stdout.no_fnmatch_line("*PytestConfigWarning*")
347 
348     @pytest.mark.parametrize(
349         "ini_file_text, plugin_version, exception_text",
350         [
351             pytest.param(
352                 """
353                 [pytest]
354                 required_plugins = a z
355                 """,
356                 "1.5",
357                 "Missing required plugins: a, z",
358                 id="2-missing",
359             ),
360             pytest.param(
361                 """
362                 [pytest]
363                 required_plugins = a z myplugin
364                 """,
365                 "1.5",
366                 "Missing required plugins: a, z",
367                 id="2-missing-1-ok",
368             ),
369             pytest.param(
370                 """
371                 [pytest]
372                 required_plugins = myplugin
373                 """,
374                 "1.5",
375                 None,
376                 id="1-ok",
377             ),
378             pytest.param(
379                 """
380                 [pytest]
381                 required_plugins = myplugin==1.5
382                 """,
383                 "1.5",
384                 None,
385                 id="1-ok-pin-exact",
386             ),
387             pytest.param(
388                 """
389                 [pytest]
390                 required_plugins = myplugin>1.0,<2.0
391                 """,
392                 "1.5",
393                 None,
394                 id="1-ok-pin-loose",
395             ),
396             pytest.param(
397                 """
398                 [pytest]
399                 required_plugins = myplugin
400                 """,
401                 "1.5a1",
402                 None,
403                 id="1-ok-prerelease",
404             ),
405             pytest.param(
406                 """
407                 [pytest]
408                 required_plugins = myplugin==1.6
409                 """,
410                 "1.5",
411                 "Missing required plugins: myplugin==1.6",
412                 id="missing-version",
413             ),
414             pytest.param(
415                 """
416                 [pytest]
417                 required_plugins = myplugin==1.6 other==1.0
418                 """,
419                 "1.5",
420                 "Missing required plugins: myplugin==1.6, other==1.0",
421                 id="missing-versions",
422             ),
423             pytest.param(
424                 """
425                 [some_other_header]
426                 required_plugins = won't be triggered
427                 [pytest]
428                 """,
429                 "1.5",
430                 None,
431                 id="invalid-header",
432             ),
433         ],
434     )
435     def test_missing_required_plugins(
436         self,
437         pytester: Pytester,
438         monkeypatch: MonkeyPatch,
439         ini_file_text: str,
440         plugin_version: str,
441         exception_text: str,
442     ) -> None:
443         """Check 'required_plugins' option with various settings.
444 
445         This test installs a mock "myplugin-1.5" which is used in the parametrized test cases.
446         """
447 
448         @dataclasses.dataclass
449         class DummyEntryPoint:
450             name: str
451             module: str
452             group: str = "pytest11"
453 
454             def load(self):
455                 __import__(self.module)
456                 return sys.modules[self.module]
457 
458         entry_points = [
459             DummyEntryPoint("myplugin1", "myplugin1_module"),
460         ]
461 
462         @dataclasses.dataclass
463         class DummyDist:
464             entry_points: object
465             files: object = ()
466             version: str = plugin_version
467 
468             @property
469             def metadata(self):
470                 return {"name": "myplugin"}
471 
472         def my_dists():
473             return [DummyDist(entry_points)]
474 
475         pytester.makepyfile(myplugin1_module="# my plugin module")
476         pytester.syspathinsert()
477 
478         monkeypatch.setattr(importlib.metadata, "distributions", my_dists)
479         monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
480 
481         pytester.makeini(ini_file_text)
482 
483         if exception_text:
484             with pytest.raises(pytest.UsageError, match=exception_text):
485                 pytester.parseconfig()
486         else:
487             pytester.parseconfig()
488 
489     def test_early_config_cmdline(
490         self, pytester: Pytester, monkeypatch: MonkeyPatch
491     ) -> None:
492         """early_config contains options registered by third-party plugins.
493 
494         This is a regression involving pytest-cov (and possibly others) introduced in #7700.
495         """
496         pytester.makepyfile(
497             myplugin="""
498             def pytest_addoption(parser):
499                 parser.addoption('--foo', default=None, dest='foo')
500 
501             def pytest_load_initial_conftests(early_config, parser, args):
502                 assert early_config.known_args_namespace.foo == "1"
503             """
504         )
505         monkeypatch.setenv("PYTEST_PLUGINS", "myplugin")
506         pytester.syspathinsert()
507         result = pytester.runpytest("--foo=1")
508         result.stdout.fnmatch_lines("* no tests ran in *")
509 
510 
511 class TestConfigCmdlineParsing:
512     def test_parsing_again_fails(self, pytester: Pytester) -> None:
513         config = pytester.parseconfig()
514         pytest.raises(AssertionError, lambda: config.parse([]))
515 
516     def test_explicitly_specified_config_file_is_loaded(
517         self, pytester: Pytester
518     ) -> None:
519         pytester.makeconftest(
520             """
521             def pytest_addoption(parser):
522                 parser.addini("custom", "")
523         """
524         )
525         pytester.makeini(
526             """
527             [pytest]
528             custom = 0
529         """
530         )
531         pytester.makefile(
532             ".ini",
533             custom="""
534             [pytest]
535             custom = 1
536         """,
537         )
538         config = pytester.parseconfig("-c", "custom.ini")
539         assert config.getini("custom") == "1"
540         config = pytester.parseconfig("--config-file", "custom.ini")
541         assert config.getini("custom") == "1"
542 
543         pytester.makefile(
544             ".cfg",
545             custom_tool_pytest_section="""
546             [tool:pytest]
547             custom = 1
548         """,
549         )
550         config = pytester.parseconfig("-c", "custom_tool_pytest_section.cfg")
551         assert config.getini("custom") == "1"
552         config = pytester.parseconfig("--config-file", "custom_tool_pytest_section.cfg")
553         assert config.getini("custom") == "1"
554 
555         pytester.makefile(
556             ".toml",
557             custom="""
558                 [tool.pytest.ini_options]
559                 custom = 1
560                 value = [
561                 ]  # this is here on purpose, as it makes this an invalid '.ini' file
562             """,
563         )
564         config = pytester.parseconfig("-c", "custom.toml")
565         assert config.getini("custom") == "1"
566         config = pytester.parseconfig("--config-file", "custom.toml")
567         assert config.getini("custom") == "1"
568 
569     def test_absolute_win32_path(self, pytester: Pytester) -> None:
570         temp_ini_file = pytester.makefile(
571             ".ini",
572             custom="""
573             [pytest]
574             addopts = --version
575         """,
576         )
577         from os.path import normpath
578 
579         temp_ini_file_norm = normpath(str(temp_ini_file))
580         ret = pytest.main(["-c", temp_ini_file_norm])
581         assert ret == ExitCode.OK
582         ret = pytest.main(["--config-file", temp_ini_file_norm])
583         assert ret == ExitCode.OK
584 
585 
586 class TestConfigAPI:
587     def test_config_trace(self, pytester: Pytester) -> None:
588         config = pytester.parseconfig()
589         values: List[str] = []
590         config.trace.root.setwriter(values.append)
591         config.trace("hello")
592         assert len(values) == 1
593         assert values[0] == "hello [config]\n"
594 
595     def test_config_getoption(self, pytester: Pytester) -> None:
596         pytester.makeconftest(
597             """
598             def pytest_addoption(parser):
599                 parser.addoption("--hello", "-X", dest="hello")
600         """
601         )
602         config = pytester.parseconfig("--hello=this")
603         for x in ("hello", "--hello", "-X"):
604             assert config.getoption(x) == "this"
605         pytest.raises(ValueError, config.getoption, "qweqwe")
606 
607     def test_config_getoption_unicode(self, pytester: Pytester) -> None:
608         pytester.makeconftest(
609             """
610             def pytest_addoption(parser):
611                 parser.addoption('--hello', type=str)
612         """
613         )
614         config = pytester.parseconfig("--hello=this")
615         assert config.getoption("hello") == "this"
616 
617     def test_config_getvalueorskip(self, pytester: Pytester) -> None:
618         config = pytester.parseconfig()
619         pytest.raises(pytest.skip.Exception, config.getvalueorskip, "hello")
620         verbose = config.getvalueorskip("verbose")
621         assert verbose == config.option.verbose
622 
623     def test_config_getvalueorskip_None(self, pytester: Pytester) -> None:
624         pytester.makeconftest(
625             """
626             def pytest_addoption(parser):
627                 parser.addoption("--hello")
628         """
629         )
630         config = pytester.parseconfig()
631         with pytest.raises(pytest.skip.Exception):
632             config.getvalueorskip("hello")
633 
634     def test_getoption(self, pytester: Pytester) -> None:
635         config = pytester.parseconfig()
636         with pytest.raises(ValueError):
637             config.getvalue("x")
638         assert config.getoption("x", 1) == 1
639 
640     def test_getconftest_pathlist(self, pytester: Pytester, tmp_path: Path) -> None:
641         somepath = tmp_path.joinpath("x", "y", "z")
642         p = tmp_path.joinpath("conftest.py")
643         p.write_text(f"mylist = {['.', str(somepath)]}", encoding="utf-8")
644         config = pytester.parseconfigure(p)
645         assert (
646             config._getconftest_pathlist("notexist", path=tmp_path, rootpath=tmp_path)
647             is None
648         )
649         pl = (
650             config._getconftest_pathlist("mylist", path=tmp_path, rootpath=tmp_path)
651             or []
652         )
653         print(pl)
654         assert len(pl) == 2
655         assert pl[0] == tmp_path
656         assert pl[1] == somepath
657 
658     @pytest.mark.parametrize("maybe_type", ["not passed", "None", '"string"'])
659     def test_addini(self, pytester: Pytester, maybe_type: str) -> None:
660         if maybe_type == "not passed":
661             type_string = ""
662         else:
663             type_string = f", {maybe_type}"
664 
665         pytester.makeconftest(
666             f"""
667             def pytest_addoption(parser):
668                 parser.addini("myname", "my new ini value"{type_string})
669         """
670         )
671         pytester.makeini(
672             """
673             [pytest]
674             myname=hello
675         """
676         )
677         config = pytester.parseconfig()
678         val = config.getini("myname")
679         assert val == "hello"
680         pytest.raises(ValueError, config.getini, "other")
681 
682     @pytest.mark.parametrize("config_type", ["ini", "pyproject"])
683     def test_addini_paths(self, pytester: Pytester, config_type: str) -> None:
684         pytester.makeconftest(
685             """
686             def pytest_addoption(parser):
687                 parser.addini("paths", "my new ini value", type="paths")
688                 parser.addini("abc", "abc value")
689         """
690         )
691         if config_type == "ini":
692             inipath = pytester.makeini(
693                 """
694                 [pytest]
695                 paths=hello world/sub.py
696             """
697             )
698         elif config_type == "pyproject":
699             inipath = pytester.makepyprojecttoml(
700                 """
701                 [tool.pytest.ini_options]
702                 paths=["hello", "world/sub.py"]
703             """
704             )
705         config = pytester.parseconfig()
706         values = config.getini("paths")
707         assert len(values) == 2
708         assert values[0] == inipath.parent.joinpath("hello")
709         assert values[1] == inipath.parent.joinpath("world/sub.py")
710         pytest.raises(ValueError, config.getini, "other")
711 
712     def make_conftest_for_args(self, pytester: Pytester) -> None:
713         pytester.makeconftest(
714             """
715             def pytest_addoption(parser):
716                 parser.addini("args", "new args", type="args")
717                 parser.addini("a2", "", "args", default="1 2 3".split())
718         """
719         )
720 
721     def test_addini_args_ini_files(self, pytester: Pytester) -> None:
722         self.make_conftest_for_args(pytester)
723         pytester.makeini(
724             """
725             [pytest]
726             args=123 "123 hello" "this"
727             """
728         )
729         self.check_config_args(pytester)
730 
731     def test_addini_args_pyproject_toml(self, pytester: Pytester) -> None:
732         self.make_conftest_for_args(pytester)
733         pytester.makepyprojecttoml(
734             """
735             [tool.pytest.ini_options]
736             args = ["123", "123 hello", "this"]
737             """
738         )
739         self.check_config_args(pytester)
740 
741     def check_config_args(self, pytester: Pytester) -> None:
742         config = pytester.parseconfig()
743         values = config.getini("args")
744         assert values == ["123", "123 hello", "this"]
745         values = config.getini("a2")
746         assert values == list("123")
747 
748     def make_conftest_for_linelist(self, pytester: Pytester) -> None:
749         pytester.makeconftest(
750             """
751             def pytest_addoption(parser):
752                 parser.addini("xy", "", type="linelist")
753                 parser.addini("a2", "", "linelist")
754         """
755         )
756 
757     def test_addini_linelist_ini_files(self, pytester: Pytester) -> None:
758         self.make_conftest_for_linelist(pytester)
759         pytester.makeini(
760             """
761             [pytest]
762             xy= 123 345
763                 second line
764         """
765         )
766         self.check_config_linelist(pytester)
767 
768     def test_addini_linelist_pprojecttoml(self, pytester: Pytester) -> None:
769         self.make_conftest_for_linelist(pytester)
770         pytester.makepyprojecttoml(
771             """
772             [tool.pytest.ini_options]
773             xy = ["123 345", "second line"]
774         """
775         )
776         self.check_config_linelist(pytester)
777 
778     def check_config_linelist(self, pytester: Pytester) -> None:
779         config = pytester.parseconfig()
780         values = config.getini("xy")
781         assert len(values) == 2
782         assert values == ["123 345", "second line"]
783         values = config.getini("a2")
784         assert values == []
785 
786     @pytest.mark.parametrize(
787         "str_val, bool_val", [("True", True), ("no", False), ("no-ini", True)]
788     )
789     def test_addini_bool(
790         self, pytester: Pytester, str_val: str, bool_val: bool
791     ) -> None:
792         pytester.makeconftest(
793             """
794             def pytest_addoption(parser):
795                 parser.addini("strip", "", type="bool", default=True)
796         """
797         )
798         if str_val != "no-ini":
799             pytester.makeini(
800                 """
801                 [pytest]
802                 strip=%s
803             """
804                 % str_val
805             )
806         config = pytester.parseconfig()
807         assert config.getini("strip") is bool_val
808 
809     def test_addinivalue_line_existing(self, pytester: Pytester) -> None:
810         pytester.makeconftest(
811             """
812             def pytest_addoption(parser):
813                 parser.addini("xy", "", type="linelist")
814         """
815         )
816         pytester.makeini(
817             """
818             [pytest]
819             xy= 123
820         """
821         )
822         config = pytester.parseconfig()
823         values = config.getini("xy")
824         assert len(values) == 1
825         assert values == ["123"]
826         config.addinivalue_line("xy", "456")
827         values = config.getini("xy")
828         assert len(values) == 2
829         assert values == ["123", "456"]
830 
831     def test_addinivalue_line_new(self, pytester: Pytester) -> None:
832         pytester.makeconftest(
833             """
834             def pytest_addoption(parser):
835                 parser.addini("xy", "", type="linelist")
836         """
837         )
838         config = pytester.parseconfig()
839         assert not config.getini("xy")
840         config.addinivalue_line("xy", "456")
841         values = config.getini("xy")
842         assert len(values) == 1
843         assert values == ["456"]
844         config.addinivalue_line("xy", "123")
845         values = config.getini("xy")
846         assert len(values) == 2
847         assert values == ["456", "123"]
848 
849     def test_confcutdir_check_isdir(self, pytester: Pytester) -> None:
850         """Give an error if --confcutdir is not a valid directory (#2078)"""
851         exp_match = r"^--confcutdir must be a directory, given: "
852         with pytest.raises(pytest.UsageError, match=exp_match):
853             pytester.parseconfig("--confcutdir", pytester.path.joinpath("file"))
854         with pytest.raises(pytest.UsageError, match=exp_match):
855             pytester.parseconfig("--confcutdir", pytester.path.joinpath("nonexistent"))
856 
857         p = pytester.mkdir("dir")
858         config = pytester.parseconfig("--confcutdir", p)
859         assert config.getoption("confcutdir") == str(p)
860 
861     @pytest.mark.parametrize(
862         "names, expected",
863         [
864             # dist-info based distributions root are files as will be put in PYTHONPATH
865             (["bar.py"], ["bar"]),
866             (["foo/bar.py"], ["bar"]),
867             (["foo/bar.pyc"], []),
868             (["foo/__init__.py"], ["foo"]),
869             (["bar/__init__.py", "xz.py"], ["bar", "xz"]),
870             (["setup.py"], []),
871             # egg based distributions root contain the files from the dist root
872             (["src/bar/__init__.py"], ["bar"]),
873             (["src/bar/__init__.py", "setup.py"], ["bar"]),
874             (["source/python/bar/__init__.py", "setup.py"], ["bar"]),
875             # editable installation finder modules
876             (["__editable___xyz_finder.py"], []),
877             (["bar/__init__.py", "__editable___xyz_finder.py"], ["bar"]),
878         ],
879     )
880     def test_iter_rewritable_modules(self, names, expected) -> None:
881         assert list(_iter_rewritable_modules(names)) == expected
882 
883 
884 class TestConfigFromdictargs:
885     def test_basic_behavior(self, _sys_snapshot) -> None:
886         option_dict = {"verbose": 444, "foo": "bar", "capture": "no"}
887         args = ["a", "b"]
888 
889         config = Config.fromdictargs(option_dict, args)
890         with pytest.raises(AssertionError):
891             config.parse(["should refuse to parse again"])
892         assert config.option.verbose == 444
893         assert config.option.foo == "bar"
894         assert config.option.capture == "no"
895         assert config.args == args
896 
897     def test_invocation_params_args(self, _sys_snapshot) -> None:
898         """Show that fromdictargs can handle args in their "orig" format"""
899         option_dict: Dict[str, object] = {}
900         args = ["-vvvv", "-s", "a", "b"]
901 
902         config = Config.fromdictargs(option_dict, args)
903         assert config.args == ["a", "b"]
904         assert config.invocation_params.args == tuple(args)
905         assert config.option.verbose == 4
906         assert config.option.capture == "no"
907 
908     def test_inifilename(self, tmp_path: Path) -> None:
909         d1 = tmp_path.joinpath("foo")
910         d1.mkdir()
911         p1 = d1.joinpath("bar.ini")
912         p1.touch()
913         p1.write_text(
914             textwrap.dedent(
915                 """\
916                 [pytest]
917                 name = value
918                 """
919             ),
920             encoding="utf-8",
921         )
922 
923         inifilename = "../../foo/bar.ini"
924         option_dict = {"inifilename": inifilename, "capture": "no"}
925 
926         cwd = tmp_path.joinpath("a/b")
927         cwd.mkdir(parents=True)
928         p2 = cwd.joinpath("pytest.ini")
929         p2.touch()
930         p2.write_text(
931             textwrap.dedent(
932                 """\
933                 [pytest]
934                 name = wrong-value
935                 should_not_be_set = true
936                 """
937             ),
938             encoding="utf-8",
939         )
940         with MonkeyPatch.context() as mp:
941             mp.chdir(cwd)
942             config = Config.fromdictargs(option_dict, ())
943             inipath = absolutepath(inifilename)
944 
945         assert config.args == [str(cwd)]
946         assert config.option.inifilename == inifilename
947         assert config.option.capture == "no"
948 
949         # this indicates this is the file used for getting configuration values
950         assert config.inipath == inipath
951         assert config.inicfg.get("name") == "value"
952         assert config.inicfg.get("should_not_be_set") is None
953 
954 
955 def test_options_on_small_file_do_not_blow_up(pytester: Pytester) -> None:
956     def runfiletest(opts: Sequence[str]) -> None:
957         reprec = pytester.inline_run(*opts)
958         passed, skipped, failed = reprec.countoutcomes()
959         assert failed == 2
960         assert skipped == passed == 0
961 
962     path = str(
963         pytester.makepyfile(
964             """
965         def test_f1(): assert 0
966         def test_f2(): assert 0
967     """
968         )
969     )
970 
971     runfiletest([path])
972     runfiletest(["-l", path])
973     runfiletest(["-s", path])
974     runfiletest(["--tb=no", path])
975     runfiletest(["--tb=short", path])
976     runfiletest(["--tb=long", path])
977     runfiletest(["--fulltrace", path])
978     runfiletest(["--traceconfig", path])
979     runfiletest(["-v", path])
980     runfiletest(["-v", "-v", path])
981 
982 
983 def test_preparse_ordering_with_setuptools(
984     pytester: Pytester, monkeypatch: MonkeyPatch
985 ) -> None:
986     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
987 
988     class EntryPoint:
989         name = "mytestplugin"
990         group = "pytest11"
991 
992         def load(self):
993             class PseudoPlugin:
994                 x = 42
995 
996             return PseudoPlugin()
997 
998     class Dist:
999         files = ()
1000         metadata = {"name": "foo"}
1001         entry_points = (EntryPoint(),)
1002 
1003     def my_dists():
1004         return (Dist,)
1005 
1006     monkeypatch.setattr(importlib.metadata, "distributions", my_dists)
1007     pytester.makeconftest(
1008         """
1009         pytest_plugins = "mytestplugin",
1010     """
1011     )
1012     monkeypatch.setenv("PYTEST_PLUGINS", "mytestplugin")
1013     config = pytester.parseconfig()
1014     plugin = config.pluginmanager.getplugin("mytestplugin")
1015     assert plugin.x == 42
1016 
1017 
1018 def test_setuptools_importerror_issue1479(
1019     pytester: Pytester, monkeypatch: MonkeyPatch
1020 ) -> None:
1021     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
1022 
1023     class DummyEntryPoint:
1024         name = "mytestplugin"
1025         group = "pytest11"
1026 
1027         def load(self):
1028             raise ImportError("Don't hide me!")
1029 
1030     class Distribution:
1031         version = "1.0"
1032         files = ("foo.txt",)
1033         metadata = {"name": "foo"}
1034         entry_points = (DummyEntryPoint(),)
1035 
1036     def distributions():
1037         return (Distribution(),)
1038 
1039     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1040     with pytest.raises(ImportError):
1041         pytester.parseconfig()
1042 
1043 
1044 def test_importlib_metadata_broken_distribution(
1045     pytester: Pytester, monkeypatch: MonkeyPatch
1046 ) -> None:
1047     """Integration test for broken distributions with 'files' metadata being None (#5389)"""
1048     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
1049 
1050     class DummyEntryPoint:
1051         name = "mytestplugin"
1052         group = "pytest11"
1053 
1054         def load(self):
1055             return object()
1056 
1057     class Distribution:
1058         version = "1.0"
1059         files = None
1060         metadata = {"name": "foo"}
1061         entry_points = (DummyEntryPoint(),)
1062 
1063     def distributions():
1064         return (Distribution(),)
1065 
1066     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1067     pytester.parseconfig()
1068 
1069 
1070 @pytest.mark.parametrize("block_it", [True, False])
1071 def test_plugin_preparse_prevents_setuptools_loading(
1072     pytester: Pytester, monkeypatch: MonkeyPatch, block_it: bool
1073 ) -> None:
1074     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
1075 
1076     plugin_module_placeholder = object()
1077 
1078     class DummyEntryPoint:
1079         name = "mytestplugin"
1080         group = "pytest11"
1081 
1082         def load(self):
1083             return plugin_module_placeholder
1084 
1085     class Distribution:
1086         version = "1.0"
1087         files = ("foo.txt",)
1088         metadata = {"name": "foo"}
1089         entry_points = (DummyEntryPoint(),)
1090 
1091     def distributions():
1092         return (Distribution(),)
1093 
1094     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1095     args = ("-p", "no:mytestplugin") if block_it else ()
1096     config = pytester.parseconfig(*args)
1097     config.pluginmanager.import_plugin("mytestplugin")
1098     if block_it:
1099         assert "mytestplugin" not in sys.modules
1100         assert config.pluginmanager.get_plugin("mytestplugin") is None
1101     else:
1102         assert (
1103             config.pluginmanager.get_plugin("mytestplugin") is plugin_module_placeholder
1104         )
1105 
1106 
1107 @pytest.mark.parametrize(
1108     "parse_args,should_load", [(("-p", "mytestplugin"), True), ((), False)]
1109 )
1110 def test_disable_plugin_autoload(
1111     pytester: Pytester,
1112     monkeypatch: MonkeyPatch,
1113     parse_args: Union[Tuple[str, str], Tuple[()]],
1114     should_load: bool,
1115 ) -> None:
1116     class DummyEntryPoint:
1117         project_name = name = "mytestplugin"
1118         group = "pytest11"
1119         version = "1.0"
1120 
1121         def load(self):
1122             return sys.modules[self.name]
1123 
1124     class Distribution:
1125         metadata = {"name": "foo"}
1126         entry_points = (DummyEntryPoint(),)
1127         files = ()
1128 
1129     class PseudoPlugin:
1130         x = 42
1131 
1132         attrs_used = []
1133 
1134         def __getattr__(self, name):
1135             assert name == "__loader__"
1136             self.attrs_used.append(name)
1137             return object()
1138 
1139     def distributions():
1140         return (Distribution(),)
1141 
1142     monkeypatch.setenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", "1")
1143     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1144     monkeypatch.setitem(sys.modules, "mytestplugin", PseudoPlugin())  # type: ignore[misc]
1145     config = pytester.parseconfig(*parse_args)
1146     has_loaded = config.pluginmanager.get_plugin("mytestplugin") is not None
1147     assert has_loaded == should_load
1148     if should_load:
1149         assert PseudoPlugin.attrs_used == ["__loader__"]
1150     else:
1151         assert PseudoPlugin.attrs_used == []
1152 
1153 
1154 def test_plugin_loading_order(pytester: Pytester) -> None:
1155     """Test order of plugin loading with `-p`."""
1156     p1 = pytester.makepyfile(
1157         """
1158         def test_terminal_plugin(request):
1159             import myplugin
1160             assert myplugin.terminal_plugin == [False, True]
1161         """,
1162         **{
1163             "myplugin": """
1164             terminal_plugin = []
1165 
1166             def pytest_configure(config):
1167                 terminal_plugin.append(bool(config.pluginmanager.get_plugin("terminalreporter")))
1168 
1169             def pytest_sessionstart(session):
1170                 config = session.config
1171                 terminal_plugin.append(bool(config.pluginmanager.get_plugin("terminalreporter")))
1172             """
1173         },
1174     )
1175     pytester.syspathinsert()
1176     result = pytester.runpytest("-p", "myplugin", str(p1))
1177     assert result.ret == 0
1178 
1179 
1180 def test_cmdline_processargs_simple(pytester: Pytester) -> None:
1181     pytester.makeconftest(
1182         """
1183         def pytest_cmdline_preparse(args):
1184             args.append("-h")
1185     """
1186     )
1187     result = pytester.runpytest("-Wignore::pytest.PytestRemovedIn8Warning")
1188     result.stdout.fnmatch_lines(["*pytest*", "*-h*"])
1189 
1190 
1191 def test_invalid_options_show_extra_information(pytester: Pytester) -> None:
1192     """Display extra information when pytest exits due to unrecognized
1193     options in the command-line."""
1194     pytester.makeini(
1195         """
1196         [pytest]
1197         addopts = --invalid-option
1198     """
1199     )
1200     result = pytester.runpytest()
1201     result.stderr.fnmatch_lines(
1202         [
1203             "*error: unrecognized arguments: --invalid-option*",
1204             "*  inifile: %s*" % pytester.path.joinpath("tox.ini"),
1205             "*  rootdir: %s*" % pytester.path,
1206         ]
1207     )
1208 
1209 
1210 @pytest.mark.parametrize(
1211     "args",
1212     [
1213         ["dir1", "dir2", "-v"],
1214         ["dir1", "-v", "dir2"],
1215         ["dir2", "-v", "dir1"],
1216         ["-v", "dir2", "dir1"],
1217     ],
1218 )
1219 def test_consider_args_after_options_for_rootdir(
1220     pytester: Pytester, args: List[str]
1221 ) -> None:
1222     """
1223     Consider all arguments in the command-line for rootdir
1224     discovery, even if they happen to occur after an option. #949
1225     """
1226     # replace "dir1" and "dir2" from "args" into their real directory
1227     root = pytester.mkdir("myroot")
1228     d1 = root.joinpath("dir1")
1229     d1.mkdir()
1230     d2 = root.joinpath("dir2")
1231     d2.mkdir()
1232     for i, arg in enumerate(args):
1233         if arg == "dir1":
1234             args[i] = str(d1)
1235         elif arg == "dir2":
1236             args[i] = str(d2)
1237     with MonkeyPatch.context() as mp:
1238         mp.chdir(root)
1239         result = pytester.runpytest(*args)
1240     result.stdout.fnmatch_lines(["*rootdir: *myroot"])
1241 
1242 
1243 def test_toolongargs_issue224(pytester: Pytester) -> None:
1244     result = pytester.runpytest("-m", "hello" * 500)
1245     assert result.ret == ExitCode.NO_TESTS_COLLECTED
1246 
1247 
1248 def test_config_in_subdirectory_colon_command_line_issue2148(
1249     pytester: Pytester,
1250 ) -> None:
1251     conftest_source = """
1252         def pytest_addoption(parser):
1253             parser.addini('foo', 'foo')
1254     """
1255 
1256     pytester.makefile(
1257         ".ini",
1258         **{"pytest": "[pytest]\nfoo = root", "subdir/pytest": "[pytest]\nfoo = subdir"},
1259     )
1260 
1261     pytester.makepyfile(
1262         **{
1263             "conftest": conftest_source,
1264             "subdir/conftest": conftest_source,
1265             "subdir/test_foo": """\
1266             def test_foo(pytestconfig):
1267                 assert pytestconfig.getini('foo') == 'subdir'
1268             """,
1269         }
1270     )
1271 
1272     result = pytester.runpytest("subdir/test_foo.py::test_foo")
1273     assert result.ret == 0
1274 
1275 
1276 def test_notify_exception(pytester: Pytester, capfd) -> None:
1277     config = pytester.parseconfig()
1278     with pytest.raises(ValueError) as excinfo:
1279         raise ValueError(1)
1280     config.notify_exception(excinfo, config.option)
1281     _, err = capfd.readouterr()
1282     assert "ValueError" in err
1283 
1284     class A:
1285         def pytest_internalerror(self):
1286             return True
1287 
1288     config.pluginmanager.register(A())
1289     config.notify_exception(excinfo, config.option)
1290     _, err = capfd.readouterr()
1291     assert not err
1292 
1293     config = pytester.parseconfig("-p", "no:terminal")
1294     with pytest.raises(ValueError) as excinfo:
1295         raise ValueError(1)
1296     config.notify_exception(excinfo, config.option)
1297     _, err = capfd.readouterr()
1298     assert "ValueError" in err
1299 
1300 
1301 def test_no_terminal_discovery_error(pytester: Pytester) -> None:
1302     pytester.makepyfile("raise TypeError('oops!')")
1303     result = pytester.runpytest("-p", "no:terminal", "--collect-only")
1304     assert result.ret == ExitCode.INTERRUPTED
1305 
1306 
1307 def test_load_initial_conftest_last_ordering(_config_for_test):
1308     pm = _config_for_test.pluginmanager
1309 
1310     class My:
1311         def pytest_load_initial_conftests(self):
1312             pass
1313 
1314     m = My()
1315     pm.register(m)
1316     hc = pm.hook.pytest_load_initial_conftests
1317     hookimpls = [
1318         (
1319             hookimpl.function.__module__,
1320             "wrapper" if hookimpl.hookwrapper else "nonwrapper",
1321         )
1322         for hookimpl in hc.get_hookimpls()
1323     ]
1324     assert hookimpls == [
1325         ("_pytest.config", "nonwrapper"),
1326         (m.__module__, "nonwrapper"),
1327         ("_pytest.legacypath", "nonwrapper"),
1328         ("_pytest.python_path", "nonwrapper"),
1329         ("_pytest.capture", "wrapper"),
1330         ("_pytest.warnings", "wrapper"),
1331     ]
1332 
1333 
1334 def test_get_plugin_specs_as_list() -> None:
1335     def exp_match(val: object) -> str:
1336         return (
1337             "Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %s"
1338             % re.escape(repr(val))
1339         )
1340 
1341     with pytest.raises(pytest.UsageError, match=exp_match({"foo"})):
1342         _get_plugin_specs_as_list({"foo"})  # type: ignore[arg-type]
1343     with pytest.raises(pytest.UsageError, match=exp_match({})):
1344         _get_plugin_specs_as_list(dict())  # type: ignore[arg-type]
1345 
1346     assert _get_plugin_specs_as_list(None) == []
1347     assert _get_plugin_specs_as_list("") == []
1348     assert _get_plugin_specs_as_list("foo") == ["foo"]
1349     assert _get_plugin_specs_as_list("foo,bar") == ["foo", "bar"]
1350     assert _get_plugin_specs_as_list(["foo", "bar"]) == ["foo", "bar"]
1351     assert _get_plugin_specs_as_list(("foo", "bar")) == ["foo", "bar"]
1352 
1353 
1354 def test_collect_pytest_prefix_bug_integration(pytester: Pytester) -> None:
1355     """Integration test for issue #3775"""
1356     p = pytester.copy_example("config/collect_pytest_prefix")
1357     result = pytester.runpytest(p)
1358     result.stdout.fnmatch_lines(["* 1 passed *"])
1359 
1360 
1361 def test_collect_pytest_prefix_bug(pytestconfig):
1362     """Ensure we collect only actual functions from conftest files (#3775)"""
1363 
1364     class Dummy:
1365         class pytest_something:
1366             pass
1367 
1368     pm = pytestconfig.pluginmanager
1369     assert pm.parse_hookimpl_opts(Dummy(), "pytest_something") is None
1370 
1371 
1372 class TestRootdir:
1373     def test_simple_noini(self, tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
1374         assert get_common_ancestor([tmp_path]) == tmp_path
1375         a = tmp_path / "a"
1376         a.mkdir()
1377         assert get_common_ancestor([a, tmp_path]) == tmp_path
1378         assert get_common_ancestor([tmp_path, a]) == tmp_path
1379         monkeypatch.chdir(tmp_path)
1380         assert get_common_ancestor([]) == tmp_path
1381         no_path = tmp_path / "does-not-exist"
1382         assert get_common_ancestor([no_path]) == tmp_path
1383         assert get_common_ancestor([no_path / "a"]) == tmp_path
1384 
1385     @pytest.mark.parametrize(
1386         "name, contents",
1387         [
1388             pytest.param("pytest.ini", "[pytest]\nx=10", id="pytest.ini"),
1389             pytest.param(
1390                 "pyproject.toml", "[tool.pytest.ini_options]\nx=10", id="pyproject.toml"
1391             ),
1392             pytest.param("tox.ini", "[pytest]\nx=10", id="tox.ini"),
1393             pytest.param("setup.cfg", "[tool:pytest]\nx=10", id="setup.cfg"),
1394         ],
1395     )
1396     def test_with_ini(self, tmp_path: Path, name: str, contents: str) -> None:
1397         inipath = tmp_path / name
1398         inipath.write_text(contents, encoding="utf-8")
1399 
1400         a = tmp_path / "a"
1401         a.mkdir()
1402         b = a / "b"
1403         b.mkdir()
1404         for args in ([str(tmp_path)], [str(a)], [str(b)]):
1405             rootpath, parsed_inipath, _ = determine_setup(None, args)
1406             assert rootpath == tmp_path
1407             assert parsed_inipath == inipath
1408         rootpath, parsed_inipath, ini_config = determine_setup(None, [str(b), str(a)])
1409         assert rootpath == tmp_path
1410         assert parsed_inipath == inipath
1411         assert ini_config == {"x": "10"}
1412 
1413     @pytest.mark.parametrize("name", ["setup.cfg", "tox.ini"])
1414     def test_pytestini_overrides_empty_other(self, tmp_path: Path, name: str) -> None:
1415         inipath = tmp_path / "pytest.ini"
1416         inipath.touch()
1417         a = tmp_path / "a"
1418         a.mkdir()
1419         (a / name).touch()
1420         rootpath, parsed_inipath, _ = determine_setup(None, [str(a)])
1421         assert rootpath == tmp_path
1422         assert parsed_inipath == inipath
1423 
1424     def test_setuppy_fallback(self, tmp_path: Path) -> None:
1425         a = tmp_path / "a"
1426         a.mkdir()
1427         (a / "setup.cfg").touch()
1428         (tmp_path / "setup.py").touch()
1429         rootpath, inipath, inicfg = determine_setup(None, [str(a)])
1430         assert rootpath == tmp_path
1431         assert inipath is None
1432         assert inicfg == {}
1433 
1434     def test_nothing(self, tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
1435         monkeypatch.chdir(tmp_path)
1436         rootpath, inipath, inicfg = determine_setup(None, [str(tmp_path)])
1437         assert rootpath == tmp_path
1438         assert inipath is None
1439         assert inicfg == {}
1440 
1441     @pytest.mark.parametrize(
1442         "name, contents",
1443         [
1444             # pytest.param("pytest.ini", "[pytest]\nx=10", id="pytest.ini"),
1445             pytest.param(
1446                 "pyproject.toml", "[tool.pytest.ini_options]\nx=10", id="pyproject.toml"
1447             ),
1448             # pytest.param("tox.ini", "[pytest]\nx=10", id="tox.ini"),
1449             # pytest.param("setup.cfg", "[tool:pytest]\nx=10", id="setup.cfg"),
1450         ],
1451     )
1452     def test_with_specific_inifile(
1453         self, tmp_path: Path, name: str, contents: str
1454     ) -> None:
1455         p = tmp_path / name
1456         p.touch()
1457         p.write_text(contents, encoding="utf-8")
1458         rootpath, inipath, ini_config = determine_setup(str(p), [str(tmp_path)])
1459         assert rootpath == tmp_path
1460         assert inipath == p
1461         assert ini_config == {"x": "10"}
1462 
1463     def test_explicit_config_file_sets_rootdir(
1464         self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
1465     ) -> None:
1466         tests_dir = tmp_path / "tests"
1467         tests_dir.mkdir()
1468 
1469         monkeypatch.chdir(tmp_path)
1470 
1471         # No config file is explicitly given: rootdir is determined to be cwd.
1472         rootpath, found_inipath, *_ = determine_setup(None, [str(tests_dir)])
1473         assert rootpath == tmp_path
1474         assert found_inipath is None
1475 
1476         # Config file is explicitly given: rootdir is determined to be inifile's directory.
1477         inipath = tmp_path / "pytest.ini"
1478         inipath.touch()
1479         rootpath, found_inipath, *_ = determine_setup(str(inipath), [str(tests_dir)])
1480         assert rootpath == tmp_path
1481         assert found_inipath == inipath
1482 
1483     def test_with_arg_outside_cwd_without_inifile(
1484         self, tmp_path: Path, monkeypatch: MonkeyPatch
1485     ) -> None:
1486         monkeypatch.chdir(tmp_path)
1487         a = tmp_path / "a"
1488         a.mkdir()
1489         b = tmp_path / "b"
1490         b.mkdir()
1491         rootpath, inifile, _ = determine_setup(None, [str(a), str(b)])
1492         assert rootpath == tmp_path
1493         assert inifile is None
1494 
1495     def test_with_arg_outside_cwd_with_inifile(self, tmp_path: Path) -> None:
1496         a = tmp_path / "a"
1497         a.mkdir()
1498         b = tmp_path / "b"
1499         b.mkdir()
1500         inipath = a / "pytest.ini"
1501         inipath.touch()
1502         rootpath, parsed_inipath, _ = determine_setup(None, [str(a), str(b)])
1503         assert rootpath == a
1504         assert inipath == parsed_inipath
1505 
1506     @pytest.mark.parametrize("dirs", ([], ["does-not-exist"], ["a/does-not-exist"]))
1507     def test_with_non_dir_arg(
1508         self, dirs: Sequence[str], tmp_path: Path, monkeypatch: MonkeyPatch
1509     ) -> None:
1510         monkeypatch.chdir(tmp_path)
1511         rootpath, inipath, _ = determine_setup(None, dirs)
1512         assert rootpath == tmp_path
1513         assert inipath is None
1514 
1515     def test_with_existing_file_in_subdir(
1516         self, tmp_path: Path, monkeypatch: MonkeyPatch
1517     ) -> None:
1518         a = tmp_path / "a"
1519         a.mkdir()
1520         (a / "exists").touch()
1521         monkeypatch.chdir(tmp_path)
1522         rootpath, inipath, _ = determine_setup(None, ["a/exist"])
1523         assert rootpath == tmp_path
1524         assert inipath is None
1525 
1526     def test_with_config_also_in_parent_directory(
1527         self, tmp_path: Path, monkeypatch: MonkeyPatch
1528     ) -> None:
1529         """Regression test for #7807."""
1530         (tmp_path / "setup.cfg").write_text("[tool:pytest]\n", "utf-8")
1531         (tmp_path / "myproject").mkdir()
1532         (tmp_path / "myproject" / "setup.cfg").write_text("[tool:pytest]\n", "utf-8")
1533         (tmp_path / "myproject" / "tests").mkdir()
1534         monkeypatch.chdir(tmp_path / "myproject")
1535 
1536         rootpath, inipath, _ = determine_setup(None, ["tests/"])
1537 
1538         assert rootpath == tmp_path / "myproject"
1539         assert inipath == tmp_path / "myproject" / "setup.cfg"
1540 
1541 
1542 class TestOverrideIniArgs:
1543     @pytest.mark.parametrize("name", "setup.cfg tox.ini pytest.ini".split())
1544     def test_override_ini_names(self, pytester: Pytester, name: str) -> None:
1545         section = "[pytest]" if name != "setup.cfg" else "[tool:pytest]"
1546         pytester.path.joinpath(name).write_text(
1547             textwrap.dedent(
1548                 """
1549             {section}
1550             custom = 1.0""".format(
1551                     section=section
1552                 )
1553             ),
1554             encoding="utf-8",
1555         )
1556         pytester.makeconftest(
1557             """
1558             def pytest_addoption(parser):
1559                 parser.addini("custom", "")"""
1560         )
1561         pytester.makepyfile(
1562             """
1563             def test_pass(pytestconfig):
1564                 ini_val = pytestconfig.getini("custom")
1565                 print('\\ncustom_option:%s\\n' % ini_val)"""
1566         )
1567 
1568         result = pytester.runpytest("--override-ini", "custom=2.0", "-s")
1569         assert result.ret == 0
1570         result.stdout.fnmatch_lines(["custom_option:2.0"])
1571 
1572         result = pytester.runpytest(
1573             "--override-ini", "custom=2.0", "--override-ini=custom=3.0", "-s"
1574         )
1575         assert result.ret == 0
1576         result.stdout.fnmatch_lines(["custom_option:3.0"])
1577 
1578     def test_override_ini_paths(self, pytester: Pytester) -> None:
1579         pytester.makeconftest(
1580             """
1581             def pytest_addoption(parser):
1582                 parser.addini("paths", "my new ini value", type="paths")"""
1583         )
1584         pytester.makeini(
1585             """
1586             [pytest]
1587             paths=blah.py"""
1588         )
1589         pytester.makepyfile(
1590             r"""
1591             def test_overriden(pytestconfig):
1592                 config_paths = pytestconfig.getini("paths")
1593                 print(config_paths)
1594                 for cpf in config_paths:
1595                     print('\nuser_path:%s' % cpf.name)
1596             """
1597         )
1598         result = pytester.runpytest(
1599             "--override-ini", "paths=foo/bar1.py foo/bar2.py", "-s"
1600         )
1601         result.stdout.fnmatch_lines(["user_path:bar1.py", "user_path:bar2.py"])
1602 
1603     def test_override_multiple_and_default(self, pytester: Pytester) -> None:
1604         pytester.makeconftest(
1605             """
1606             def pytest_addoption(parser):
1607                 addini = parser.addini
1608                 addini("custom_option_1", "", default="o1")
1609                 addini("custom_option_2", "", default="o2")
1610                 addini("custom_option_3", "", default=False, type="bool")
1611                 addini("custom_option_4", "", default=True, type="bool")"""
1612         )
1613         pytester.makeini(
1614             """
1615             [pytest]
1616             custom_option_1=custom_option_1
1617             custom_option_2=custom_option_2
1618         """
1619         )
1620         pytester.makepyfile(
1621             """
1622             def test_multiple_options(pytestconfig):
1623                 prefix = "custom_option"
1624                 for x in range(1, 5):
1625                     ini_value=pytestconfig.getini("%s_%d" % (prefix, x))
1626                     print('\\nini%d:%s' % (x, ini_value))
1627         """
1628         )
1629         result = pytester.runpytest(
1630             "--override-ini",
1631             "custom_option_1=fulldir=/tmp/user1",
1632             "-o",
1633             "custom_option_2=url=/tmp/user2?a=b&d=e",
1634             "-o",
1635             "custom_option_3=True",
1636             "-o",
1637             "custom_option_4=no",
1638             "-s",
1639         )
1640         result.stdout.fnmatch_lines(
1641             [
1642                 "ini1:fulldir=/tmp/user1",
1643                 "ini2:url=/tmp/user2?a=b&d=e",
1644                 "ini3:True",
1645                 "ini4:False",
1646             ]
1647         )
1648 
1649     def test_override_ini_usage_error_bad_style(self, pytester: Pytester) -> None:
1650         pytester.makeini(
1651             """
1652             [pytest]
1653             xdist_strict=False
1654         """
1655         )
1656         result = pytester.runpytest("--override-ini", "xdist_strict", "True")
1657         result.stderr.fnmatch_lines(
1658             [
1659                 "ERROR: -o/--override-ini expects option=value style (got: 'xdist_strict').",
1660             ]
1661         )
1662 
1663     @pytest.mark.parametrize("with_ini", [True, False])
1664     def test_override_ini_handled_asap(
1665         self, pytester: Pytester, with_ini: bool
1666     ) -> None:
1667         """-o should be handled as soon as possible and always override what's in ini files (#2238)"""
1668         if with_ini:
1669             pytester.makeini(
1670                 """
1671                 [pytest]
1672                 python_files=test_*.py
1673             """
1674             )
1675         pytester.makepyfile(
1676             unittest_ini_handle="""
1677             def test():
1678                 pass
1679         """
1680         )
1681         result = pytester.runpytest("--override-ini", "python_files=unittest_*.py")
1682         result.stdout.fnmatch_lines(["*1 passed in*"])
1683 
1684     def test_addopts_before_initini(
1685         self, monkeypatch: MonkeyPatch, _config_for_test, _sys_snapshot
1686     ) -> None:
1687         cache_dir = ".custom_cache"
1688         monkeypatch.setenv("PYTEST_ADDOPTS", "-o cache_dir=%s" % cache_dir)
1689         config = _config_for_test
1690         config._preparse([], addopts=True)
1691         assert config._override_ini == ["cache_dir=%s" % cache_dir]
1692 
1693     def test_addopts_from_env_not_concatenated(
1694         self, monkeypatch: MonkeyPatch, _config_for_test
1695     ) -> None:
1696         """PYTEST_ADDOPTS should not take values from normal args (#4265)."""
1697         monkeypatch.setenv("PYTEST_ADDOPTS", "-o")
1698         config = _config_for_test
1699         with pytest.raises(UsageError) as excinfo:
1700             config._preparse(["cache_dir=ignored"], addopts=True)
1701         assert (
1702             "error: argument -o/--override-ini: expected one argument (via PYTEST_ADDOPTS)"
1703             in excinfo.value.args[0]
1704         )
1705 
1706     def test_addopts_from_ini_not_concatenated(self, pytester: Pytester) -> None:
1707         """`addopts` from ini should not take values from normal args (#4265)."""
1708         pytester.makeini(
1709             """
1710             [pytest]
1711             addopts=-o
1712         """
1713         )
1714         result = pytester.runpytest("cache_dir=ignored")
1715         result.stderr.fnmatch_lines(
1716             [
1717                 "%s: error: argument -o/--override-ini: expected one argument (via addopts config)"
1718                 % (pytester._request.config._parser.optparser.prog,)
1719             ]
1720         )
1721         assert result.ret == _pytest.config.ExitCode.USAGE_ERROR
1722 
1723     def test_override_ini_does_not_contain_paths(
1724         self, _config_for_test, _sys_snapshot
1725     ) -> None:
1726         """Check that -o no longer swallows all options after it (#3103)"""
1727         config = _config_for_test
1728         config._preparse(["-o", "cache_dir=/cache", "/some/test/path"])
1729         assert config._override_ini == ["cache_dir=/cache"]
1730 
1731     def test_multiple_override_ini_options(self, pytester: Pytester) -> None:
1732         """Ensure a file path following a '-o' option does not generate an error (#3103)"""
1733         pytester.makepyfile(
1734             **{
1735                 "conftest.py": """
1736                 def pytest_addoption(parser):
1737                     parser.addini('foo', default=None, help='some option')
1738                     parser.addini('bar', default=None, help='some option')
1739             """,
1740                 "test_foo.py": """
1741                 def test(pytestconfig):
1742                     assert pytestconfig.getini('foo') == '1'
1743                     assert pytestconfig.getini('bar') == '0'
1744             """,
1745                 "test_bar.py": """
1746                 def test():
1747                     assert False
1748             """,
1749             }
1750         )
1751         result = pytester.runpytest("-o", "foo=1", "-o", "bar=0", "test_foo.py")
1752         assert "ERROR:" not in result.stderr.str()
1753         result.stdout.fnmatch_lines(["collected 1 item", "*= 1 passed in *="])
1754 
1755 
1756 def test_help_via_addopts(pytester: Pytester) -> None:
1757     pytester.makeini(
1758         """
1759         [pytest]
1760         addopts = --unknown-option-should-allow-for-help --help
1761     """
1762     )
1763     result = pytester.runpytest()
1764     assert result.ret == 0
1765     result.stdout.fnmatch_lines(
1766         [
1767             "usage: *",
1768             "positional arguments:",
1769             # Displays full/default help.
1770             "to see available markers type: pytest --markers",
1771         ]
1772     )
1773 
1774 
1775 def test_help_and_version_after_argument_error(pytester: Pytester) -> None:
1776     pytester.makeconftest(
1777         """
1778         def validate(arg):
1779             raise argparse.ArgumentTypeError("argerror")
1780 
1781         def pytest_addoption(parser):
1782             group = parser.getgroup('cov')
1783             group.addoption(
1784                 "--invalid-option-should-allow-for-help",
1785                 type=validate,
1786             )
1787         """
1788     )
1789     pytester.makeini(
1790         """
1791         [pytest]
1792         addopts = --invalid-option-should-allow-for-help
1793     """
1794     )
1795     result = pytester.runpytest("--help")
1796     result.stdout.fnmatch_lines(
1797         [
1798             "usage: *",
1799             "positional arguments:",
1800             "NOTE: displaying only minimal help due to UsageError.",
1801         ]
1802     )
1803     result.stderr.fnmatch_lines(
1804         [
1805             "ERROR: usage: *",
1806             "%s: error: argument --invalid-option-should-allow-for-help: expected one argument"
1807             % (pytester._request.config._parser.optparser.prog,),
1808         ]
1809     )
1810     # Does not display full/default help.
1811     assert "to see available markers type: pytest --markers" not in result.stdout.lines
1812     assert result.ret == ExitCode.USAGE_ERROR
1813 
1814     result = pytester.runpytest("--version")
1815     result.stdout.fnmatch_lines([f"pytest {pytest.__version__}"])
1816     assert result.ret == ExitCode.USAGE_ERROR
1817 
1818 
1819 def test_help_formatter_uses_py_get_terminal_width(monkeypatch: MonkeyPatch) -> None:
1820     from _pytest.config.argparsing import DropShorterLongHelpFormatter
1821 
1822     monkeypatch.setenv("COLUMNS", "90")
1823     formatter = DropShorterLongHelpFormatter("prog")
1824     assert formatter._width == 90
1825 
1826     monkeypatch.setattr("_pytest._io.get_terminal_width", lambda: 160)
1827     formatter = DropShorterLongHelpFormatter("prog")
1828     assert formatter._width == 160
1829 
1830     formatter = DropShorterLongHelpFormatter("prog", width=42)
1831     assert formatter._width == 42
1832 
1833 
1834 def test_config_does_not_load_blocked_plugin_from_args(pytester: Pytester) -> None:
1835     """This tests that pytest's config setup handles "-p no:X"."""
1836     p = pytester.makepyfile("def test(capfd): pass")
1837     result = pytester.runpytest(str(p), "-pno:capture")
1838     result.stdout.fnmatch_lines(["E       fixture 'capfd' not found"])
1839     assert result.ret == ExitCode.TESTS_FAILED
1840 
1841     result = pytester.runpytest(str(p), "-pno:capture", "-s")
1842     result.stderr.fnmatch_lines(["*: error: unrecognized arguments: -s"])
1843     assert result.ret == ExitCode.USAGE_ERROR
1844 
1845     result = pytester.runpytest(str(p), "-p no:capture", "-s")
1846     result.stderr.fnmatch_lines(["*: error: unrecognized arguments: -s"])
1847     assert result.ret == ExitCode.USAGE_ERROR
1848 
1849 
1850 def test_invocation_args(pytester: Pytester) -> None:
1851     """Ensure that Config.invocation_* arguments are correctly defined"""
1852 
1853     class DummyPlugin:
1854         pass
1855 
1856     p = pytester.makepyfile("def test(): pass")
1857     plugin = DummyPlugin()
1858     rec = pytester.inline_run(p, "-v", plugins=[plugin])
1859     calls = rec.getcalls("pytest_runtest_protocol")
1860     assert len(calls) == 1
1861     call = calls[0]
1862     config = call.item.config
1863 
1864     assert config.invocation_params.args == (str(p), "-v")
1865     assert config.invocation_params.dir == pytester.path
1866 
1867     plugins = config.invocation_params.plugins
1868     assert len(plugins) == 2
1869     assert plugins[0] is plugin
1870     assert type(plugins[1]).__name__ == "Collect"  # installed by pytester.inline_run()
1871 
1872     # args cannot be None
1873     with pytest.raises(TypeError):
1874         Config.InvocationParams(args=None, plugins=None, dir=Path())  # type: ignore[arg-type]
1875 
1876 
1877 @pytest.mark.parametrize(
1878     "plugin",
1879     [
1880         x
1881         for x in _pytest.config.default_plugins
1882         if x not in _pytest.config.essential_plugins
1883     ],
1884 )
1885 def test_config_blocked_default_plugins(pytester: Pytester, plugin: str) -> None:
1886     if plugin == "debugging":
1887         # Fixed in xdist (after 1.27.0).
1888         # https://github.com/pytest-dev/pytest-xdist/pull/422
1889         try:
1890             import xdist  # noqa: F401
1891         except ImportError:
1892             pass
1893         else:
1894             pytest.skip("does not work with xdist currently")
1895 
1896     p = pytester.makepyfile("def test(): pass")
1897     result = pytester.runpytest(str(p), "-pno:%s" % plugin)
1898 
1899     if plugin == "python":
1900         assert result.ret == ExitCode.USAGE_ERROR
1901         result.stderr.fnmatch_lines(
1902             [
1903                 "ERROR: found no collectors for */test_config_blocked_default_plugins.py",
1904             ]
1905         )
1906         return
1907 
1908     assert result.ret == ExitCode.OK
1909     if plugin != "terminal":
1910         result.stdout.fnmatch_lines(["* 1 passed in *"])
1911 
1912     p = pytester.makepyfile("def test(): assert 0")
1913     result = pytester.runpytest(str(p), "-pno:%s" % plugin)
1914     assert result.ret == ExitCode.TESTS_FAILED
1915     if plugin != "terminal":
1916         result.stdout.fnmatch_lines(["* 1 failed in *"])
1917     else:
1918         assert result.stdout.lines == []
1919 
1920 
1921 class TestSetupCfg:
1922     def test_pytest_setup_cfg_unsupported(self, pytester: Pytester) -> None:
1923         pytester.makefile(
1924             ".cfg",
1925             setup="""
1926             [pytest]
1927             addopts = --verbose
1928         """,
1929         )
1930         with pytest.raises(pytest.fail.Exception):
1931             pytester.runpytest()
1932 
1933     def test_pytest_custom_cfg_unsupported(self, pytester: Pytester) -> None:
1934         pytester.makefile(
1935             ".cfg",
1936             custom="""
1937             [pytest]
1938             addopts = --verbose
1939         """,
1940         )
1941         with pytest.raises(pytest.fail.Exception):
1942             pytester.runpytest("-c", "custom.cfg")
1943 
1944         with pytest.raises(pytest.fail.Exception):
1945             pytester.runpytest("--config-file", "custom.cfg")
1946 
1947 
1948 class TestPytestPluginsVariable:
1949     def test_pytest_plugins_in_non_top_level_conftest_unsupported(
1950         self, pytester: Pytester
1951     ) -> None:
1952         pytester.makepyfile(
1953             **{
1954                 "subdirectory/conftest.py": """
1955             pytest_plugins=['capture']
1956         """
1957             }
1958         )
1959         pytester.makepyfile(
1960             """
1961             def test_func():
1962                 pass
1963         """
1964         )
1965         res = pytester.runpytest()
1966         assert res.ret == 2
1967         msg = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
1968         res.stdout.fnmatch_lines([f"*{msg}*", f"*subdirectory{os.sep}conftest.py*"])
1969 
1970     @pytest.mark.parametrize("use_pyargs", [True, False])
1971     def test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs(
1972         self, pytester: Pytester, use_pyargs: bool
1973     ) -> None:
1974         """When using --pyargs, do not emit the warning about non-top-level conftest warnings (#4039, #4044)"""
1975 
1976         files = {
1977             "src/pkg/__init__.py": "",
1978             "src/pkg/conftest.py": "",
1979             "src/pkg/test_root.py": "def test(): pass",
1980             "src/pkg/sub/__init__.py": "",
1981             "src/pkg/sub/conftest.py": "pytest_plugins=['capture']",
1982             "src/pkg/sub/test_bar.py": "def test(): pass",
1983         }
1984         pytester.makepyfile(**files)
1985         pytester.syspathinsert(pytester.path.joinpath("src"))
1986 
1987         args = ("--pyargs", "pkg") if use_pyargs else ()
1988         res = pytester.runpytest(*args)
1989         assert res.ret == (0 if use_pyargs else 2)
1990         msg = (
1991             msg
1992         ) = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
1993         if use_pyargs:
1994             assert msg not in res.stdout.str()
1995         else:
1996             res.stdout.fnmatch_lines([f"*{msg}*"])
1997 
1998     def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest(
1999         self, pytester: Pytester
2000     ) -> None:
2001         subdirectory = pytester.path.joinpath("subdirectory")
2002         subdirectory.mkdir()
2003         pytester.makeconftest(
2004             """
2005             pytest_plugins=['capture']
2006         """
2007         )
2008         pytester.path.joinpath("conftest.py").rename(
2009             subdirectory.joinpath("conftest.py")
2010         )
2011 
2012         pytester.makepyfile(
2013             """
2014             def test_func():
2015                 pass
2016         """
2017         )
2018 
2019         res = pytester.runpytest_subprocess()
2020         assert res.ret == 2
2021         msg = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
2022         res.stdout.fnmatch_lines([f"*{msg}*", f"*subdirectory{os.sep}conftest.py*"])
2023 
2024     def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_false_positives(
2025         self, pytester: Pytester
2026     ) -> None:
2027         pytester.makepyfile(
2028             "def test_func(): pass",
2029             **{
2030                 "subdirectory/conftest": "pass",
2031                 "conftest": """
2032                     import warnings
2033                     warnings.filterwarnings('always', category=DeprecationWarning)
2034                     pytest_plugins=['capture']
2035                     """,
2036             },
2037         )
2038         res = pytester.runpytest_subprocess()
2039         assert res.ret == 0
2040         msg = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
2041         assert msg not in res.stdout.str()
2042 
2043 
2044 def test_conftest_import_error_repr(tmp_path: Path) -> None:
2045     """`ConftestImportFailure` should use a short error message and readable
2046     path to the failed conftest.py file."""
2047     path = tmp_path.joinpath("foo/conftest.py")
2048     with pytest.raises(
2049         ConftestImportFailure,
2050         match=re.escape(f"RuntimeError: some error (from {path})"),
2051     ):
2052         try:
2053             raise RuntimeError("some error")
2054         except Exception as exc:
2055             assert exc.__traceback__ is not None
2056             exc_info = (type(exc), exc, exc.__traceback__)
2057             raise ConftestImportFailure(path, exc_info) from exc
2058 
2059 
2060 def test_strtobool() -> None:
2061     assert _strtobool("YES")
2062     assert not _strtobool("NO")
2063     with pytest.raises(ValueError):
2064         _strtobool("unknown")
2065 
2066 
2067 @pytest.mark.parametrize(
2068     "arg, escape, expected",
2069     [
2070         ("ignore", False, ("ignore", "", Warning, "", 0)),
2071         (
2072             "ignore::DeprecationWarning",
2073             False,
2074             ("ignore", "", DeprecationWarning, "", 0),
2075         ),
2076         (
2077             "ignore:some msg:DeprecationWarning",
2078             False,
2079             ("ignore", "some msg", DeprecationWarning, "", 0),
2080         ),
2081         (
2082             "ignore::DeprecationWarning:mod",
2083             False,
2084             ("ignore", "", DeprecationWarning, "mod", 0),
2085         ),
2086         (
2087             "ignore::DeprecationWarning:mod:42",
2088             False,
2089             ("ignore", "", DeprecationWarning, "mod", 42),
2090         ),
2091         ("error:some\\msg:::", True, ("error", "some\\\\msg", Warning, "", 0)),
2092         ("error:::mod\\foo:", True, ("error", "", Warning, "mod\\\\foo\\Z", 0)),
2093     ],
2094 )
2095 def test_parse_warning_filter(
2096     arg: str, escape: bool, expected: Tuple[str, str, Type[Warning], str, int]
2097 ) -> None:
2098     assert parse_warning_filter(arg, escape=escape) == expected
2099 
2100 
2101 @pytest.mark.parametrize(
2102     "arg",
2103     [
2104         # Too much parts.
2105         ":" * 5,
2106         # Invalid action.
2107         "FOO::",
2108         # ImportError when importing the warning class.
2109         "::test_parse_warning_filter_failure.NonExistentClass::",
2110         # Class is not a Warning subclass.
2111         "::list::",
2112         # Negative line number.
2113         "::::-1",
2114         # Not a line number.
2115         "::::not-a-number",
2116     ],
2117 )
2118 def test_parse_warning_filter_failure(arg: str) -> None:
2119     with pytest.raises(pytest.UsageError):
2120         parse_warning_filter(arg, escape=True)
2121 
2122 
2123 class TestDebugOptions:
2124     def test_without_debug_does_not_write_log(self, pytester: Pytester) -> None:
2125         result = pytester.runpytest()
2126         result.stderr.no_fnmatch_line(
2127             "*writing pytest debug information to*pytestdebug.log"
2128         )
2129         result.stderr.no_fnmatch_line(
2130             "*wrote pytest debug information to*pytestdebug.log"
2131         )
2132         assert not [f.name for f in pytester.path.glob("**/*.log")]
2133 
2134     def test_with_only_debug_writes_pytestdebug_log(self, pytester: Pytester) -> None:
2135         result = pytester.runpytest("--debug")
2136         result.stderr.fnmatch_lines(
2137             [
2138                 "*writing pytest debug information to*pytestdebug.log",
2139                 "*wrote pytest debug information to*pytestdebug.log",
2140             ]
2141         )
2142         assert "pytestdebug.log" in [f.name for f in pytester.path.glob("**/*.log")]
2143 
2144     def test_multiple_custom_debug_logs(self, pytester: Pytester) -> None:
2145         result = pytester.runpytest("--debug", "bar.log")
2146         result.stderr.fnmatch_lines(
2147             [
2148                 "*writing pytest debug information to*bar.log",
2149                 "*wrote pytest debug information to*bar.log",
2150             ]
2151         )
2152         result = pytester.runpytest("--debug", "foo.log")
2153         result.stderr.fnmatch_lines(
2154             [
2155                 "*writing pytest debug information to*foo.log",
2156                 "*wrote pytest debug information to*foo.log",
2157             ]
2158         )
2159 
2160         assert {"bar.log", "foo.log"} == {
2161             f.name for f in pytester.path.glob("**/*.log")
2162         }
2163 
2164     def test_debug_help(self, pytester: Pytester) -> None:
2165         result = pytester.runpytest("-h")
2166         result.stdout.fnmatch_lines(
2167             [
2168                 "*Store internal tracing debug information in this log*",
2169                 "*file. This file is opened with 'w' and truncated as a*",
2170                 "*Default: pytestdebug.log.",
2171             ]
2172         )

</code><intended_behavior>Test setup code should be carefully reviewed to ensure it does not inadvertently modify sys.modules in a way that could lead to module duplication. This includes avoiding unnecessary re-imports or removal of modules from sys.modules without a subsequent reload. Ensure all test configurations and dynamic imports follow a consistent path resolution and importing approach.</intended_behavior>, <file>src/_pytest/main.py</file>
<class>None</class>
<method>search_pypath</method>
<code>
843 def search_pypath(module_name: str) -> str:
844     """Search sys.path for the given a dotted module name, and return its file system path."""
845     try:
846         spec = importlib.util.find_spec(module_name)
847     # AttributeError: looks like package module, but actually filename
848     # ImportError: module does not exist
849     # ValueError: not a module name
850     except (AttributeError, ImportError, ValueError):
851         return module_name
852     if spec is None or spec.origin is None or spec.origin == "namespace":
853         return module_name
854     elif spec.submodule_search_locations:
855         return os.path.dirname(spec.origin)
856     else:
857         return spec.origin

</code><intended_behavior>The method search_pypath should ensure it respects the project's namespace package structures and does not bypass the standard module loading mechanism. Enhancements should support the uniqueness of module instances, particularly in contexts where the method's result influences dynamic importing decisions. Consider implementing additional checks or logs for module search and loading.</intended_behavior>]
2025-10-17 16:41:08.170 | INFO     | Search completed. Bug locations: [<file>src/_pytest/pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import atexit
2 import contextlib
3 import fnmatch
4 import importlib.util
5 import itertools
6 import os
7 import shutil
8 import sys
9 import types
10 import uuid
11 import warnings
12 from enum import Enum
13 from errno import EBADF
14 from errno import ELOOP
15 from errno import ENOENT
16 from errno import ENOTDIR
17 from functools import partial
18 from os.path import expanduser
19 from os.path import expandvars
20 from os.path import isabs
21 from os.path import sep
22 from pathlib import Path
23 from pathlib import PurePath
24 from posixpath import sep as posix_sep
25 from types import ModuleType
26 from typing import Callable
27 from typing import Dict
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Set
33 from typing import Tuple
34 from typing import Type
35 from typing import TypeVar
36 from typing import Union
37 
38 from _pytest.compat import assert_never
39 from _pytest.outcomes import skip
40 from _pytest.warning_types import PytestWarning
41 
42 LOCK_TIMEOUT = 60 * 60 * 24 * 3
43 
44 
45 _AnyPurePath = TypeVar("_AnyPurePath", bound=PurePath)
46 
47 # The following function, variables and comments were
48 # copied from cpython 3.9 Lib/pathlib.py file.
49 
50 # EBADF - guard against macOS `stat` throwing EBADF
51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)
52 
53 _IGNORED_WINERRORS = (
54     21,  # ERROR_NOT_READY - drive exists but is not accessible
55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself
56 )
57 
58 
59 def _ignore_error(exception):
60     return (
61         getattr(exception, "errno", None) in _IGNORED_ERRORS
62         or getattr(exception, "winerror", None) in _IGNORED_WINERRORS
63     )
64 
65 
66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:
67     return path.joinpath(".lock")
68 
69 
70 def on_rm_rf_error(
71     func,
72     path: str,
73     excinfo: Union[
74         BaseException,
75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],
76     ],
77     *,
78     start_path: Path,
79 ) -> bool:
80     """Handle known read-only errors during rmtree.
81 
82     The returned value is used only by our own tests.
83     """
84     if isinstance(excinfo, BaseException):
85         exc = excinfo
86     else:
87         exc = excinfo[1]
88 
89     # Another process removed the file in the middle of the "rm_rf" (xdist for example).
90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018
91     if isinstance(exc, FileNotFoundError):
92         return False
93 
94     if not isinstance(exc, PermissionError):
95         warnings.warn(
96             PytestWarning(f"(rm_rf) error removing {path}\n{type(exc)}: {exc}")
97         )
98         return False
99 
100     if func not in (os.rmdir, os.remove, os.unlink):
101         if func not in (os.open,):
102             warnings.warn(
103                 PytestWarning(
104                     "(rm_rf) unknown function {} when removing {}:\n{}: {}".format(
105                         func, path, type(exc), exc
106                     )
107                 )
108             )
109         return False
110 
111     # Chmod + retry.
112     import stat
113 
114     def chmod_rw(p: str) -> None:
115         mode = os.stat(p).st_mode
116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)
117 
118     # For files, we need to recursively go upwards in the directories to
119     # ensure they all are also writable.
120     p = Path(path)
121     if p.is_file():
122         for parent in p.parents:
123             chmod_rw(str(parent))
124             # Stop when we reach the original path passed to rm_rf.
125             if parent == start_path:
126                 break
127     chmod_rw(str(path))
128 
129     func(path)
130     return True
131 
132 
133 def ensure_extended_length_path(path: Path) -> Path:
134     """Get the extended-length version of a path (Windows).
135 
136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260
137     characters, and operations on paths longer than that fail. But it is possible
138     to overcome this by converting the path to "extended-length" form before
139     performing the operation:
140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
141 
142     On Windows, this function returns the extended-length absolute version of path.
143     On other platforms it returns path unchanged.
144     """
145     if sys.platform.startswith("win32"):
146         path = path.resolve()
147         path = Path(get_extended_length_path_str(str(path)))
148     return path
149 
150 
151 def get_extended_length_path_str(path: str) -> str:
152     """Convert a path to a Windows extended length path."""
153     long_path_prefix = "\\\\?\\"
154     unc_long_path_prefix = "\\\\?\\UNC\\"
155     if path.startswith((long_path_prefix, unc_long_path_prefix)):
156         return path
157     # UNC
158     if path.startswith("\\\\"):
159         return unc_long_path_prefix + path[2:]
160     return long_path_prefix + path
161 
162 
163 def rm_rf(path: Path) -> None:
164     """Remove the path contents recursively, even if some elements
165     are read-only."""
166     path = ensure_extended_length_path(path)
167     onerror = partial(on_rm_rf_error, start_path=path)
168     if sys.version_info >= (3, 12):
169         shutil.rmtree(str(path), onexc=onerror)
170     else:
171         shutil.rmtree(str(path), onerror=onerror)
172 
173 
174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:
175     """Find all elements in root that begin with the prefix, case insensitive."""
176     l_prefix = prefix.lower()
177     for x in root.iterdir():
178         if x.name.lower().startswith(l_prefix):
179             yield x
180 
181 
182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:
183     """Return the parts of the paths following the prefix.
184 
185     :param iter: Iterator over path names.
186     :param prefix: Expected prefix of the path names.
187     """
188     p_len = len(prefix)
189     for p in iter:
190         yield p.name[p_len:]
191 
192 
193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
194     """Combine find_prefixes and extract_suffixes."""
195     return extract_suffixes(find_prefixed(root, prefix), prefix)
196 
197 
198 def parse_num(maybe_num) -> int:
199     """Parse number path suffixes, returns -1 on error."""
200     try:
201         return int(maybe_num)
202     except ValueError:
203         return -1
204 
205 
206 def _force_symlink(
207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]
208 ) -> None:
209     """Helper to create the current symlink.
210 
211     It's full of race conditions that are reasonably OK to ignore
212     for the context of best effort linking to the latest test run.
213 
214     The presumption being that in case of much parallelism
215     the inaccuracy is going to be acceptable.
216     """
217     current_symlink = root.joinpath(target)
218     try:
219         current_symlink.unlink()
220     except OSError:
221         pass
222     try:
223         current_symlink.symlink_to(link_to)
224     except Exception:
225         pass
226 
227 
228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
229     """Create a directory with an increased number as suffix for the given prefix."""
230     for i in range(10):
231         # try up to 10 times to create the folder
232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
233         new_number = max_existing + 1
234         new_path = root.joinpath(f"{prefix}{new_number}")
235         try:
236             new_path.mkdir(mode=mode)
237         except Exception:
238             pass
239         else:
240             _force_symlink(root, prefix + "current", new_path)
241             return new_path
242     else:
243         raise OSError(
244             "could not create numbered dir with prefix "
245             "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
246         )
247 
248 
249 def create_cleanup_lock(p: Path) -> Path:
250     """Create a lock to prevent premature folder cleanup."""
251     lock_path = get_lock_path(p)
252     try:
253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
254     except FileExistsError as e:
255         raise OSError(f"cannot create lockfile in {p}") from e
256     else:
257         pid = os.getpid()
258         spid = str(pid).encode()
259         os.write(fd, spid)
260         os.close(fd)
261         if not lock_path.is_file():
262             raise OSError("lock path got renamed after successful creation")
263         return lock_path
264 
265 
266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
267     """Register a cleanup function for removing a lock, by default on atexit."""
268     pid = os.getpid()
269 
270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
271         current_pid = os.getpid()
272         if current_pid != original_pid:
273             # fork
274             return
275         try:
276             lock_path.unlink()
277         except OSError:
278             pass
279 
280     return register(cleanup_on_exit)
281 
282 
283 def maybe_delete_a_numbered_dir(path: Path) -> None:
284     """Remove a numbered directory if its lock can be obtained and it does
285     not seem to be in use."""
286     path = ensure_extended_length_path(path)
287     lock_path = None
288     try:
289         lock_path = create_cleanup_lock(path)
290         parent = path.parent
291 
292         garbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
293         path.rename(garbage)
294         rm_rf(garbage)
295     except OSError:
296         #  known races:
297         #  * other process did a cleanup at the same time
298         #  * deletable folder was found
299         #  * process cwd (Windows)
300         return
301     finally:
302         # If we created the lock, ensure we remove it even if we failed
303         # to properly remove the numbered dir.
304         if lock_path is not None:
305             try:
306                 lock_path.unlink()
307             except OSError:
308                 pass
309 
310 
311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:
312     """Check if `path` is deletable based on whether the lock file is expired."""
313     if path.is_symlink():
314         return False
315     lock = get_lock_path(path)
316     try:
317         if not lock.is_file():
318             return True
319     except OSError:
320         # we might not have access to the lock file at all, in this case assume
321         # we don't have access to the entire directory (#7491).
322         return False
323     try:
324         lock_time = lock.stat().st_mtime
325     except Exception:
326         return False
327     else:
328         if lock_time < consider_lock_dead_if_created_before:
329             # We want to ignore any errors while trying to remove the lock such as:
330             # - PermissionDenied, like the file permissions have changed since the lock creation;
331             # - FileNotFoundError, in case another pytest process got here first;
332             # and any other cause of failure.
333             with contextlib.suppress(OSError):
334                 lock.unlink()
335                 return True
336         return False
337 
338 
339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:
340     """Try to cleanup a folder if we can ensure it's deletable."""
341     if ensure_deletable(path, consider_lock_dead_if_created_before):
342         maybe_delete_a_numbered_dir(path)
343 
344 
345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:
346     """List candidates for numbered directories to be removed - follows py.path."""
347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
348     max_delete = max_existing - keep
349     paths = find_prefixed(root, prefix)
350     paths, paths2 = itertools.tee(paths)
351     numbers = map(parse_num, extract_suffixes(paths2, prefix))
352     for path, number in zip(paths, numbers):
353         if number <= max_delete:
354             yield path
355 
356 
357 def cleanup_dead_symlinks(root: Path):
358     for left_dir in root.iterdir():
359         if left_dir.is_symlink():
360             if not left_dir.resolve().exists():
361                 left_dir.unlink()
362 
363 
364 def cleanup_numbered_dir(
365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float
366 ) -> None:
367     """Cleanup for lock driven numbered directories."""
368     if not root.exists():
369         return
370     for path in cleanup_candidates(root, prefix, keep):
371         try_cleanup(path, consider_lock_dead_if_created_before)
372     for path in root.glob("garbage-*"):
373         try_cleanup(path, consider_lock_dead_if_created_before)
374 
375     cleanup_dead_symlinks(root)
376 
377 
378 def make_numbered_dir_with_cleanup(
379     root: Path,
380     prefix: str,
381     keep: int,
382     lock_timeout: float,
383     mode: int,
384 ) -> Path:
385     """Create a numbered dir with a cleanup lock and remove old ones."""
386     e = None
387     for i in range(10):
388         try:
389             p = make_numbered_dir(root, prefix, mode)
390             # Only lock the current dir when keep is not 0
391             if keep != 0:
392                 lock_path = create_cleanup_lock(p)
393                 register_cleanup_lock_removal(lock_path)
394         except Exception as exc:
395             e = exc
396         else:
397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
398             # Register a cleanup for program exit
399             atexit.register(
400                 cleanup_numbered_dir,
401                 root,
402                 prefix,
403                 keep,
404                 consider_lock_dead_if_created_before,
405             )
406             return p
407     assert e is not None
408     raise e
409 
410 
411 def resolve_from_str(input: str, rootpath: Path) -> Path:
412     input = expanduser(input)
413     input = expandvars(input)
414     if isabs(input):
415         return Path(input)
416     else:
417         return rootpath.joinpath(input)
418 
419 
420 def fnmatch_ex(pattern: str, path: Union[str, "os.PathLike[str]"]) -> bool:
421     """A port of FNMatcher from py.path.common which works with PurePath() instances.
422 
423     The difference between this algorithm and PurePath.match() is that the
424     latter matches "**" glob expressions for each part of the path, while
425     this algorithm uses the whole path instead.
426 
427     For example:
428         "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
429         with this algorithm, but not with PurePath.match().
430 
431     This algorithm was ported to keep backward-compatibility with existing
432     settings which assume paths match according this logic.
433 
434     References:
435     * https://bugs.python.org/issue29249
436     * https://bugs.python.org/issue34731
437     """
438     path = PurePath(path)
439     iswin32 = sys.platform.startswith("win")
440 
441     if iswin32 and sep not in pattern and posix_sep in pattern:
442         # Running on Windows, the pattern has no Windows path separators,
443         # and the pattern has one or more Posix path separators. Replace
444         # the Posix path separators with the Windows path separator.
445         pattern = pattern.replace(posix_sep, sep)
446 
447     if sep not in pattern:
448         name = path.name
449     else:
450         name = str(path)
451         if path.is_absolute() and not os.path.isabs(pattern):
452             pattern = f"*{os.sep}{pattern}"
453     return fnmatch.fnmatch(name, pattern)
454 
455 
456 def parts(s: str) -> Set[str]:
457     parts = s.split(sep)
458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}
459 
460 
461 def symlink_or_skip(src, dst, **kwargs):
462     """Make a symlink, or skip the test in case symlinks are not supported."""
463     try:
464         os.symlink(str(src), str(dst), **kwargs)
465     except OSError as e:
466         skip(f"symlinks not supported: {e}")
467 
468 
469 class ImportMode(Enum):
470     """Possible values for `mode` parameter of `import_path`."""
471 
472     prepend = "prepend"
473     append = "append"
474     importlib = "importlib"
475 
476 
477 class ImportPathMismatchError(ImportError):
478     """Raised on import_path() if there is a mismatch of __file__'s.
479 
480     This can happen when `import_path` is called multiple times with different filenames that has
481     the same basename but reside in packages
482     (for example "/tests1/test_foo.py" and "/tests2/test_foo.py").
483     """
484 
485 
486 def import_path(
487     p: Union[str, "os.PathLike[str]"],
488     *,
489     mode: Union[str, ImportMode] = ImportMode.prepend,
490     root: Path,
491 ) -> ModuleType:
492     """Import and return a module from the given path, which can be a file (a module) or
493     a directory (a package).
494 
495     The import mechanism used is controlled by the `mode` parameter:
496 
497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking
498       `__init__.py` files into account) will be put at the *start* of `sys.path` before
499       being imported with `importlib.import_module`.
500 
501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
502       to the end of `sys.path`, if not already in `sys.path`.
503 
504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
505       to import the module, which avoids having to muck with `sys.path` at all. It effectively
506       allows having same-named test modules in different places.
507 
508     :param root:
509         Used as an anchor when mode == ImportMode.importlib to obtain
510         a unique name for the module being imported so it can safely be stored
511         into ``sys.modules``.
512 
513     :raises ImportPathMismatchError:
514         If after importing the given `path` and the module `__file__`
515         are different. Only raised in `prepend` and `append` modes.
516     """
517     mode = ImportMode(mode)
518 
519     path = Path(p)
520 
521     if not path.exists():
522         raise ImportError(path)
523 
524     if mode is ImportMode.importlib:
525         module_name = module_name_from_path(path, root)
526 
527         for meta_importer in sys.meta_path:
528             spec = meta_importer.find_spec(module_name, [str(path.parent)])
529             if spec is not None:
530                 break
531         else:
532             spec = importlib.util.spec_from_file_location(module_name, str(path))
533 
534         if spec is None:
535             raise ImportError(f"Can't find module {module_name} at location {path}")
536         mod = importlib.util.module_from_spec(spec)
537         sys.modules[module_name] = mod
538         spec.loader.exec_module(mod)  # type: ignore[union-attr]
539         insert_missing_modules(sys.modules, module_name)
540         return mod
541 
542     pkg_path = resolve_package_path(path)
543     if pkg_path is not None:
544         pkg_root = pkg_path.parent
545         names = list(path.with_suffix("").relative_to(pkg_root).parts)
546         if names[-1] == "__init__":
547             names.pop()
548         module_name = ".".join(names)
549     else:
550         pkg_root = path.parent
551         module_name = path.stem
552 
553     # Change sys.path permanently: restoring it at the end of this function would cause surprising
554     # problems because of delayed imports: for example, a conftest.py file imported by this function
555     # might have local imports, which would fail at runtime if we restored sys.path.
556     if mode is ImportMode.append:
557         if str(pkg_root) not in sys.path:
558             sys.path.append(str(pkg_root))
559     elif mode is ImportMode.prepend:
560         if str(pkg_root) != sys.path[0]:
561             sys.path.insert(0, str(pkg_root))
562     else:
563         assert_never(mode)
564 
565     importlib.import_module(module_name)
566 
567     mod = sys.modules[module_name]
568     if path.name == "__init__.py":
569         return mod
570 
571     ignore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")
572     if ignore != "1":
573         module_file = mod.__file__
574         if module_file is None:
575             raise ImportPathMismatchError(module_name, module_file, path)
576 
577         if module_file.endswith((".pyc", ".pyo")):
578             module_file = module_file[:-1]
579         if module_file.endswith(os.sep + "__init__.py"):
580             module_file = module_file[: -(len(os.sep + "__init__.py"))]
581 
582         try:
583             is_same = _is_same(str(path), module_file)
584         except FileNotFoundError:
585             is_same = False
586 
587         if not is_same:
588             raise ImportPathMismatchError(module_name, module_file, path)
589 
590     return mod
591 
592 
593 # Implement a special _is_same function on Windows which returns True if the two filenames
594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).
595 if sys.platform.startswith("win"):
596 
597     def _is_same(f1: str, f2: str) -> bool:
598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)
599 
600 else:
601 
602     def _is_same(f1: str, f2: str) -> bool:
603         return os.path.samefile(f1, f2)
604 
605 
606 def module_name_from_path(path: Path, root: Path) -> str:
607     """
608     Return a dotted module name based on the given path, anchored on root.
609 
610     For example: path="projects/src/tests/test_foo.py" and root="/projects", the
611     resulting module name will be "src.tests.test_foo".
612     """
613     path = path.with_suffix("")
614     try:
615         relative_path = path.relative_to(root)
616     except ValueError:
617         # If we can't get a relative path to root, use the full path, except
618         # for the first part ("d:\\" or "/" depending on the platform, for example).
619         path_parts = path.parts[1:]
620     else:
621         # Use the parts for the relative path to the root path.
622         path_parts = relative_path.parts
623 
624     return ".".join(path_parts)
625 
626 
627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:
628     """
629     Used by ``import_path`` to create intermediate modules when using mode=importlib.
630 
631     When we want to import a module as "src.tests.test_foo" for example, we need
632     to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
633     otherwise "src.tests.test_foo" is not importable by ``__import__``.
634     """
635     module_parts = module_name.split(".")
636     child_module: Union[ModuleType, None] = None
637     module: Union[ModuleType, None] = None
638     child_name: str = ""
639     while module_name:
640         if module_name not in modules:
641             try:
642                 # If sys.meta_path is empty, calling import_module will issue
643                 # a warning and raise ModuleNotFoundError. To avoid the
644                 # warning, we check sys.meta_path explicitly and raise the error
645                 # ourselves to fall back to creating a dummy module.
646                 if not sys.meta_path:
647                     raise ModuleNotFoundError
648                 module = importlib.import_module(module_name)
649             except ModuleNotFoundError:
650                 module = ModuleType(
651                     module_name,
652                     doc="Empty module created by pytest's importmode=importlib.",
653                 )
654         else:
655             module = modules[module_name]
656         if child_module:
657             # Add child attribute to the parent that can reference the child
658             # modules.
659             if not hasattr(module, child_name):
660                 setattr(module, child_name, child_module)
661                 modules[module_name] = module
662         # Keep track of the child module while moving up the tree.
663         child_module, child_name = module, module_name.rpartition(".")[-1]
664         module_parts.pop(-1)
665         module_name = ".".join(module_parts)
666 
667 
668 def resolve_package_path(path: Path) -> Optional[Path]:
669     """Return the Python package path by looking for the last
670     directory upwards which still contains an __init__.py.
671 
672     Returns None if it can not be determined.
673     """
674     result = None
675     for parent in itertools.chain((path,), path.parents):
676         if parent.is_dir():
677             if not parent.joinpath("__init__.py").is_file():
678                 break
679             if not parent.name.isidentifier():
680                 break
681             result = parent
682     return result
683 
684 
685 def scandir(path: Union[str, "os.PathLike[str]"]) -> List["os.DirEntry[str]"]:
686     """Scan a directory recursively, in breadth-first order.
687 
688     The returned entries are sorted.
689     """
690     entries = []
691     with os.scandir(path) as s:
692         # Skip entries with symlink loops and other brokenness, so the caller
693         # doesn't have to deal with it.
694         for entry in s:
695             try:
696                 entry.is_file()
697             except OSError as err:
698                 if _ignore_error(err):
699                     continue
700                 raise
701             entries.append(entry)
702     entries.sort(key=lambda entry: entry.name)
703     return entries
704 
705 
706 def visit(
707     path: Union[str, "os.PathLike[str]"], recurse: Callable[["os.DirEntry[str]"], bool]
708 ) -> Iterator["os.DirEntry[str]"]:
709     """Walk a directory recursively, in breadth-first order.
710 
711     The `recurse` predicate determines whether a directory is recursed.
712 
713     Entries at each directory level are sorted.
714     """
715     entries = scandir(path)
716     yield from entries
717     for entry in entries:
718         if entry.is_dir() and recurse(entry):
719             yield from visit(entry.path, recurse)
720 
721 
722 def absolutepath(path: Union[Path, str]) -> Path:
723     """Convert a path to an absolute path using os.path.abspath.
724 
725     Prefer this over Path.resolve() (see #6523).
726     Prefer this over Path.absolute() (not public, doesn't normalize).
727     """
728     return Path(os.path.abspath(str(path)))
729 
730 
731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:
732     """Return the common part shared with the other path, or None if there is
733     no common part.
734 
735     If one path is relative and one is absolute, returns None.
736     """
737     try:
738         return Path(os.path.commonpath((str(path1), str(path2))))
739     except ValueError:
740         return None
741 
742 
743 def bestrelpath(directory: Path, dest: Path) -> str:
744     """Return a string which is a relative path from directory to dest such
745     that directory/bestrelpath == dest.
746 
747     The paths must be either both absolute or both relative.
748 
749     If no such path can be determined, returns dest.
750     """
751     assert isinstance(directory, Path)
752     assert isinstance(dest, Path)
753     if dest == directory:
754         return os.curdir
755     # Find the longest common directory.
756     base = commonpath(directory, dest)
757     # Can be the case on Windows for two absolute paths on different drives.
758     # Can be the case for two relative paths without common prefix.
759     # Can be the case for a relative path and an absolute path.
760     if not base:
761         return str(dest)
762     reldirectory = directory.relative_to(base)
763     reldest = dest.relative_to(base)
764     return os.path.join(
765         # Back from directory to base.
766         *([os.pardir] * len(reldirectory.parts)),
767         # Forward from base to dest.
768         *reldest.parts,
769     )
770 
771 
772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.
773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)
774 def copytree(source: Path, target: Path) -> None:
775     """Recursively copy a source directory to target."""
776     assert source.is_dir()
777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):
778         x = Path(entry)
779         relpath = x.relative_to(source)
780         newx = target / relpath
781         newx.parent.mkdir(exist_ok=True)
782         if x.is_symlink():
783             newx.symlink_to(os.readlink(x))
784         elif x.is_file():
785             shutil.copyfile(x, newx)
786         elif x.is_dir():
787             newx.mkdir(exist_ok=True)

</code><intended_behavior>Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module.</intended_behavior>, <file>src/_pytest/assertion/rewrite.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Rewrite assertion AST to produce nice error messages."""
2 import ast
3 import errno
4 import functools
5 import importlib.abc
6 import importlib.machinery
7 import importlib.util
8 import io
9 import itertools
10 import marshal
11 import os
12 import struct
13 import sys
14 import tokenize
15 import types
16 from pathlib import Path
17 from pathlib import PurePath
18 from typing import Callable
19 from typing import Dict
20 from typing import IO
21 from typing import Iterable
22 from typing import Iterator
23 from typing import List
24 from typing import Optional
25 from typing import Sequence
26 from typing import Set
27 from typing import Tuple
28 from typing import TYPE_CHECKING
29 from typing import Union
30 
31 from _pytest._io.saferepr import DEFAULT_REPR_MAX_SIZE
32 from _pytest._io.saferepr import saferepr
33 from _pytest._version import version
34 from _pytest.assertion import util
35 from _pytest.assertion.util import (  # noqa: F401
36     format_explanation as _format_explanation,
37 )
38 from _pytest.config import Config
39 from _pytest.main import Session
40 from _pytest.pathlib import absolutepath
41 from _pytest.pathlib import fnmatch_ex
42 from _pytest.stash import StashKey
43 
44 if TYPE_CHECKING:
45     from _pytest.assertion import AssertionState
46 
47 
48 assertstate_key = StashKey["AssertionState"]()
49 
50 # pytest caches rewritten pycs in pycache dirs
51 PYTEST_TAG = f"{sys.implementation.cache_tag}-pytest-{version}"
52 PYC_EXT = ".py" + (__debug__ and "c" or "o")
53 PYC_TAIL = "." + PYTEST_TAG + PYC_EXT
54 
55 
56 class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):
57     """PEP302/PEP451 import hook which rewrites asserts."""
58 
59     def __init__(self, config: Config) -> None:
60         self.config = config
61         try:
62             self.fnpats = config.getini("python_files")
63         except ValueError:
64             self.fnpats = ["test_*.py", "*_test.py"]
65         self.session: Optional[Session] = None
66         self._rewritten_names: Dict[str, Path] = {}
67         self._must_rewrite: Set[str] = set()
68         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,
69         # which might result in infinite recursion (#3506)
70         self._writing_pyc = False
71         self._basenames_to_check_rewrite = {"conftest"}
72         self._marked_for_rewrite_cache: Dict[str, bool] = {}
73         self._session_paths_checked = False
74 
75     def set_session(self, session: Optional[Session]) -> None:
76         self.session = session
77         self._session_paths_checked = False
78 
79     # Indirection so we can mock calls to find_spec originated from the hook during testing
80     _find_spec = importlib.machinery.PathFinder.find_spec
81 
82     def find_spec(
83         self,
84         name: str,
85         path: Optional[Sequence[Union[str, bytes]]] = None,
86         target: Optional[types.ModuleType] = None,
87     ) -> Optional[importlib.machinery.ModuleSpec]:
88         if self._writing_pyc:
89             return None
90         state = self.config.stash[assertstate_key]
91         if self._early_rewrite_bailout(name, state):
92             return None
93         state.trace("find_module called for: %s" % name)
94 
95         # Type ignored because mypy is confused about the `self` binding here.
96         spec = self._find_spec(name, path)  # type: ignore
97         if (
98             # the import machinery could not find a file to import
99             spec is None
100             # this is a namespace package (without `__init__.py`)
101             # there's nothing to rewrite there
102             or spec.origin is None
103             # we can only rewrite source files
104             or not isinstance(spec.loader, importlib.machinery.SourceFileLoader)
105             # if the file doesn't exist, we can't rewrite it
106             or not os.path.exists(spec.origin)
107         ):
108             return None
109         else:
110             fn = spec.origin
111 
112         if not self._should_rewrite(name, fn, state):
113             return None
114 
115         return importlib.util.spec_from_file_location(
116             name,
117             fn,
118             loader=self,
119             submodule_search_locations=spec.submodule_search_locations,
120         )
121 
122     def create_module(
123         self, spec: importlib.machinery.ModuleSpec
124     ) -> Optional[types.ModuleType]:
125         return None  # default behaviour is fine
126 
127     def exec_module(self, module: types.ModuleType) -> None:
128         assert module.__spec__ is not None
129         assert module.__spec__.origin is not None
130         fn = Path(module.__spec__.origin)
131         state = self.config.stash[assertstate_key]
132 
133         self._rewritten_names[module.__name__] = fn
134 
135         # The requested module looks like a test file, so rewrite it. This is
136         # the most magical part of the process: load the source, rewrite the
137         # asserts, and load the rewritten source. We also cache the rewritten
138         # module code in a special pyc. We must be aware of the possibility of
139         # concurrent pytest processes rewriting and loading pycs. To avoid
140         # tricky race conditions, we maintain the following invariant: The
141         # cached pyc is always a complete, valid pyc. Operations on it must be
142         # atomic. POSIX's atomic rename comes in handy.
143         write = not sys.dont_write_bytecode
144         cache_dir = get_cache_dir(fn)
145         if write:
146             ok = try_makedirs(cache_dir)
147             if not ok:
148                 write = False
149                 state.trace(f"read only directory: {cache_dir}")
150 
151         cache_name = fn.name[:-3] + PYC_TAIL
152         pyc = cache_dir / cache_name
153         # Notice that even if we're in a read-only directory, I'm going
154         # to check for a cached pyc. This may not be optimal...
155         co = _read_pyc(fn, pyc, state.trace)
156         if co is None:
157             state.trace(f"rewriting {fn!r}")
158             source_stat, co = _rewrite_test(fn, self.config)
159             if write:
160                 self._writing_pyc = True
161                 try:
162                     _write_pyc(state, co, source_stat, pyc)
163                 finally:
164                     self._writing_pyc = False
165         else:
166             state.trace(f"found cached rewritten pyc for {fn}")
167         exec(co, module.__dict__)
168 
169     def _early_rewrite_bailout(self, name: str, state: "AssertionState") -> bool:
170         """A fast way to get out of rewriting modules.
171 
172         Profiling has shown that the call to PathFinder.find_spec (inside of
173         the find_spec from this class) is a major slowdown, so, this method
174         tries to filter what we're sure won't be rewritten before getting to
175         it.
176         """
177         if self.session is not None and not self._session_paths_checked:
178             self._session_paths_checked = True
179             for initial_path in self.session._initialpaths:
180                 # Make something as c:/projects/my_project/path.py ->
181                 #     ['c:', 'projects', 'my_project', 'path.py']
182                 parts = str(initial_path).split(os.sep)
183                 # add 'path' to basenames to be checked.
184                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])
185 
186         # Note: conftest already by default in _basenames_to_check_rewrite.
187         parts = name.split(".")
188         if parts[-1] in self._basenames_to_check_rewrite:
189             return False
190 
191         # For matching the name it must be as if it was a filename.
192         path = PurePath(*parts).with_suffix(".py")
193 
194         for pat in self.fnpats:
195             # if the pattern contains subdirectories ("tests/**.py" for example) we can't bail out based
196             # on the name alone because we need to match against the full path
197             if os.path.dirname(pat):
198                 return False
199             if fnmatch_ex(pat, path):
200                 return False
201 
202         if self._is_marked_for_rewrite(name, state):
203             return False
204 
205         state.trace(f"early skip of rewriting module: {name}")
206         return True
207 
208     def _should_rewrite(self, name: str, fn: str, state: "AssertionState") -> bool:
209         # always rewrite conftest files
210         if os.path.basename(fn) == "conftest.py":
211             state.trace(f"rewriting conftest file: {fn!r}")
212             return True
213 
214         if self.session is not None:
215             if self.session.isinitpath(absolutepath(fn)):
216                 state.trace(f"matched test file (was specified on cmdline): {fn!r}")
217                 return True
218 
219         # modules not passed explicitly on the command line are only
220         # rewritten if they match the naming convention for test files
221         fn_path = PurePath(fn)
222         for pat in self.fnpats:
223             if fnmatch_ex(pat, fn_path):
224                 state.trace(f"matched test file {fn!r}")
225                 return True
226 
227         return self._is_marked_for_rewrite(name, state)
228 
229     def _is_marked_for_rewrite(self, name: str, state: "AssertionState") -> bool:
230         try:
231             return self._marked_for_rewrite_cache[name]
232         except KeyError:
233             for marked in self._must_rewrite:
234                 if name == marked or name.startswith(marked + "."):
235                     state.trace(f"matched marked file {name!r} (from {marked!r})")
236                     self._marked_for_rewrite_cache[name] = True
237                     return True
238 
239             self._marked_for_rewrite_cache[name] = False
240             return False
241 
242     def mark_rewrite(self, *names: str) -> None:
243         """Mark import names as needing to be rewritten.
244 
245         The named module or package as well as any nested modules will
246         be rewritten on import.
247         """
248         already_imported = (
249             set(names).intersection(sys.modules).difference(self._rewritten_names)
250         )
251         for name in already_imported:
252             mod = sys.modules[name]
253             if not AssertionRewriter.is_rewrite_disabled(
254                 mod.__doc__ or ""
255             ) and not isinstance(mod.__loader__, type(self)):
256                 self._warn_already_imported(name)
257         self._must_rewrite.update(names)
258         self._marked_for_rewrite_cache.clear()
259 
260     def _warn_already_imported(self, name: str) -> None:
261         from _pytest.warning_types import PytestAssertRewriteWarning
262 
263         self.config.issue_config_time_warning(
264             PytestAssertRewriteWarning(
265                 "Module already imported so cannot be rewritten: %s" % name
266             ),
267             stacklevel=5,
268         )
269 
270     def get_data(self, pathname: Union[str, bytes]) -> bytes:
271         """Optional PEP302 get_data API."""
272         with open(pathname, "rb") as f:
273             return f.read()
274 
275     if sys.version_info >= (3, 10):
276         if sys.version_info >= (3, 12):
277             from importlib.resources.abc import TraversableResources
278         else:
279             from importlib.abc import TraversableResources
280 
281         def get_resource_reader(self, name: str) -> TraversableResources:  # type: ignore
282             if sys.version_info < (3, 11):
283                 from importlib.readers import FileReader
284             else:
285                 from importlib.resources.readers import FileReader
286 
287             return FileReader(  # type:ignore[no-any-return]
288                 types.SimpleNamespace(path=self._rewritten_names[name])
289             )
290 
291 
292 def _write_pyc_fp(
293     fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType
294 ) -> None:
295     # Technically, we don't have to have the same pyc format as
296     # (C)Python, since these "pycs" should never be seen by builtin
297     # import. However, there's little reason to deviate.
298     fp.write(importlib.util.MAGIC_NUMBER)
299     # https://www.python.org/dev/peps/pep-0552/
300     flags = b"\x00\x00\x00\x00"
301     fp.write(flags)
302     # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)
303     mtime = int(source_stat.st_mtime) & 0xFFFFFFFF
304     size = source_stat.st_size & 0xFFFFFFFF
305     # "<LL" stands for 2 unsigned longs, little-endian.
306     fp.write(struct.pack("<LL", mtime, size))
307     fp.write(marshal.dumps(co))
308 
309 
310 def _write_pyc(
311     state: "AssertionState",
312     co: types.CodeType,
313     source_stat: os.stat_result,
314     pyc: Path,
315 ) -> bool:
316     proc_pyc = f"{pyc}.{os.getpid()}"
317     try:
318         with open(proc_pyc, "wb") as fp:
319             _write_pyc_fp(fp, source_stat, co)
320     except OSError as e:
321         state.trace(f"error writing pyc file at {proc_pyc}: errno={e.errno}")
322         return False
323 
324     try:
325         os.replace(proc_pyc, pyc)
326     except OSError as e:
327         state.trace(f"error writing pyc file at {pyc}: {e}")
328         # we ignore any failure to write the cache file
329         # there are many reasons, permission-denied, pycache dir being a
330         # file etc.
331         return False
332     return True
333 
334 
335 def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeType]:
336     """Read and rewrite *fn* and return the code object."""
337     stat = os.stat(fn)
338     source = fn.read_bytes()
339     strfn = str(fn)
340     tree = ast.parse(source, filename=strfn)
341     rewrite_asserts(tree, source, strfn, config)
342     co = compile(tree, strfn, "exec", dont_inherit=True)
343     return stat, co
344 
345 
346 def _read_pyc(
347     source: Path, pyc: Path, trace: Callable[[str], None] = lambda x: None
348 ) -> Optional[types.CodeType]:
349     """Possibly read a pytest pyc containing rewritten code.
350 
351     Return rewritten code if successful or None if not.
352     """
353     try:
354         fp = open(pyc, "rb")
355     except OSError:
356         return None
357     with fp:
358         try:
359             stat_result = os.stat(source)
360             mtime = int(stat_result.st_mtime)
361             size = stat_result.st_size
362             data = fp.read(16)
363         except OSError as e:
364             trace(f"_read_pyc({source}): OSError {e}")
365             return None
366         # Check for invalid or out of date pyc file.
367         if len(data) != (16):
368             trace("_read_pyc(%s): invalid pyc (too short)" % source)
369             return None
370         if data[:4] != importlib.util.MAGIC_NUMBER:
371             trace("_read_pyc(%s): invalid pyc (bad magic number)" % source)
372             return None
373         if data[4:8] != b"\x00\x00\x00\x00":
374             trace("_read_pyc(%s): invalid pyc (unsupported flags)" % source)
375             return None
376         mtime_data = data[8:12]
377         if int.from_bytes(mtime_data, "little") != mtime & 0xFFFFFFFF:
378             trace("_read_pyc(%s): out of date" % source)
379             return None
380         size_data = data[12:16]
381         if int.from_bytes(size_data, "little") != size & 0xFFFFFFFF:
382             trace("_read_pyc(%s): invalid pyc (incorrect size)" % source)
383             return None
384         try:
385             co = marshal.load(fp)
386         except Exception as e:
387             trace(f"_read_pyc({source}): marshal.load error {e}")
388             return None
389         if not isinstance(co, types.CodeType):
390             trace("_read_pyc(%s): not a code object" % source)
391             return None
392         return co
393 
394 
395 def rewrite_asserts(
396     mod: ast.Module,
397     source: bytes,
398     module_path: Optional[str] = None,
399     config: Optional[Config] = None,
400 ) -> None:
401     """Rewrite the assert statements in mod."""
402     AssertionRewriter(module_path, config, source).run(mod)
403 
404 
405 def _saferepr(obj: object) -> str:
406     r"""Get a safe repr of an object for assertion error messages.
407 
408     The assertion formatting (util.format_explanation()) requires
409     newlines to be escaped since they are a special character for it.
410     Normally assertion.util.format_explanation() does this but for a
411     custom repr it is possible to contain one of the special escape
412     sequences, especially '\n{' and '\n}' are likely to be present in
413     JSON reprs.
414     """
415     maxsize = _get_maxsize_for_saferepr(util._config)
416     return saferepr(obj, maxsize=maxsize).replace("\n", "\\n")
417 
418 
419 def _get_maxsize_for_saferepr(config: Optional[Config]) -> Optional[int]:
420     """Get `maxsize` configuration for saferepr based on the given config object."""
421     verbosity = config.getoption("verbose") if config is not None else 0
422     if verbosity >= 2:
423         return None
424     if verbosity >= 1:
425         return DEFAULT_REPR_MAX_SIZE * 10
426     return DEFAULT_REPR_MAX_SIZE
427 
428 
429 def _format_assertmsg(obj: object) -> str:
430     r"""Format the custom assertion message given.
431 
432     For strings this simply replaces newlines with '\n~' so that
433     util.format_explanation() will preserve them instead of escaping
434     newlines.  For other objects saferepr() is used first.
435     """
436     # reprlib appears to have a bug which means that if a string
437     # contains a newline it gets escaped, however if an object has a
438     # .__repr__() which contains newlines it does not get escaped.
439     # However in either case we want to preserve the newline.
440     replaces = [("\n", "\n~"), ("%", "%%")]
441     if not isinstance(obj, str):
442         obj = saferepr(obj)
443         replaces.append(("\\n", "\n~"))
444 
445     for r1, r2 in replaces:
446         obj = obj.replace(r1, r2)
447 
448     return obj
449 
450 
451 def _should_repr_global_name(obj: object) -> bool:
452     if callable(obj):
453         return False
454 
455     try:
456         return not hasattr(obj, "__name__")
457     except Exception:
458         return True
459 
460 
461 def _format_boolop(explanations: Iterable[str], is_or: bool) -> str:
462     explanation = "(" + (is_or and " or " or " and ").join(explanations) + ")"
463     return explanation.replace("%", "%%")
464 
465 
466 def _call_reprcompare(
467     ops: Sequence[str],
468     results: Sequence[bool],
469     expls: Sequence[str],
470     each_obj: Sequence[object],
471 ) -> str:
472     for i, res, expl in zip(range(len(ops)), results, expls):
473         try:
474             done = not res
475         except Exception:
476             done = True
477         if done:
478             break
479     if util._reprcompare is not None:
480         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
481         if custom is not None:
482             return custom
483     return expl
484 
485 
486 def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:
487     if util._assertion_pass is not None:
488         util._assertion_pass(lineno, orig, expl)
489 
490 
491 def _check_if_assertion_pass_impl() -> bool:
492     """Check if any plugins implement the pytest_assertion_pass hook
493     in order not to generate explanation unnecessarily (might be expensive)."""
494     return True if util._assertion_pass else False
495 
496 
497 UNARY_MAP = {ast.Not: "not %s", ast.Invert: "~%s", ast.USub: "-%s", ast.UAdd: "+%s"}
498 
499 BINOP_MAP = {
500     ast.BitOr: "|",
501     ast.BitXor: "^",
502     ast.BitAnd: "&",
503     ast.LShift: "<<",
504     ast.RShift: ">>",
505     ast.Add: "+",
506     ast.Sub: "-",
507     ast.Mult: "*",
508     ast.Div: "/",
509     ast.FloorDiv: "//",
510     ast.Mod: "%%",  # escaped for string formatting
511     ast.Eq: "==",
512     ast.NotEq: "!=",
513     ast.Lt: "<",
514     ast.LtE: "<=",
515     ast.Gt: ">",
516     ast.GtE: ">=",
517     ast.Pow: "**",
518     ast.Is: "is",
519     ast.IsNot: "is not",
520     ast.In: "in",
521     ast.NotIn: "not in",
522     ast.MatMult: "@",
523 }
524 
525 
526 def traverse_node(node: ast.AST) -> Iterator[ast.AST]:
527     """Recursively yield node and all its children in depth-first order."""
528     yield node
529     for child in ast.iter_child_nodes(node):
530         yield from traverse_node(child)
531 
532 
533 @functools.lru_cache(maxsize=1)
534 def _get_assertion_exprs(src: bytes) -> Dict[int, str]:
535     """Return a mapping from {lineno: "assertion test expression"}."""
536     ret: Dict[int, str] = {}
537 
538     depth = 0
539     lines: List[str] = []
540     assert_lineno: Optional[int] = None
541     seen_lines: Set[int] = set()
542 
543     def _write_and_reset() -> None:
544         nonlocal depth, lines, assert_lineno, seen_lines
545         assert assert_lineno is not None
546         ret[assert_lineno] = "".join(lines).rstrip().rstrip("\\")
547         depth = 0
548         lines = []
549         assert_lineno = None
550         seen_lines = set()
551 
552     tokens = tokenize.tokenize(io.BytesIO(src).readline)
553     for tp, source, (lineno, offset), _, line in tokens:
554         if tp == tokenize.NAME and source == "assert":
555             assert_lineno = lineno
556         elif assert_lineno is not None:
557             # keep track of depth for the assert-message `,` lookup
558             if tp == tokenize.OP and source in "([{":
559                 depth += 1
560             elif tp == tokenize.OP and source in ")]}":
561                 depth -= 1
562 
563             if not lines:
564                 lines.append(line[offset:])
565                 seen_lines.add(lineno)
566             # a non-nested comma separates the expression from the message
567             elif depth == 0 and tp == tokenize.OP and source == ",":
568                 # one line assert with message
569                 if lineno in seen_lines and len(lines) == 1:
570                     offset_in_trimmed = offset + len(lines[-1]) - len(line)
571                     lines[-1] = lines[-1][:offset_in_trimmed]
572                 # multi-line assert with message
573                 elif lineno in seen_lines:
574                     lines[-1] = lines[-1][:offset]
575                 # multi line assert with escapd newline before message
576                 else:
577                     lines.append(line[:offset])
578                 _write_and_reset()
579             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:
580                 _write_and_reset()
581             elif lines and lineno not in seen_lines:
582                 lines.append(line)
583                 seen_lines.add(lineno)
584 
585     return ret
586 
587 
588 class AssertionRewriter(ast.NodeVisitor):
589     """Assertion rewriting implementation.
590 
591     The main entrypoint is to call .run() with an ast.Module instance,
592     this will then find all the assert statements and rewrite them to
593     provide intermediate values and a detailed assertion error.  See
594     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html
595     for an overview of how this works.
596 
597     The entry point here is .run() which will iterate over all the
598     statements in an ast.Module and for each ast.Assert statement it
599     finds call .visit() with it.  Then .visit_Assert() takes over and
600     is responsible for creating new ast statements to replace the
601     original assert statement: it rewrites the test of an assertion
602     to provide intermediate values and replace it with an if statement
603     which raises an assertion error with a detailed explanation in
604     case the expression is false and calls pytest_assertion_pass hook
605     if expression is true.
606 
607     For this .visit_Assert() uses the visitor pattern to visit all the
608     AST nodes of the ast.Assert.test field, each visit call returning
609     an AST node and the corresponding explanation string.  During this
610     state is kept in several instance attributes:
611 
612     :statements: All the AST statements which will replace the assert
613        statement.
614 
615     :variables: This is populated by .variable() with each variable
616        used by the statements so that they can all be set to None at
617        the end of the statements.
618 
619     :variable_counter: Counter to create new unique variables needed
620        by statements.  Variables are created using .variable() and
621        have the form of "@py_assert0".
622 
623     :expl_stmts: The AST statements which will be executed to get
624        data from the assertion.  This is the code which will construct
625        the detailed assertion message that is used in the AssertionError
626        or for the pytest_assertion_pass hook.
627 
628     :explanation_specifiers: A dict filled by .explanation_param()
629        with %-formatting placeholders and their corresponding
630        expressions to use in the building of an assertion message.
631        This is used by .pop_format_context() to build a message.
632 
633     :stack: A stack of the explanation_specifiers dicts maintained by
634        .push_format_context() and .pop_format_context() which allows
635        to build another %-formatted string while already building one.
636 
637     :variables_overwrite: A dict filled with references to variables
638        that change value within an assert. This happens when a variable is
639        reassigned with the walrus operator
640 
641     This state, except the variables_overwrite,  is reset on every new assert
642     statement visited and used by the other visitors.
643     """
644 
645     def __init__(
646         self, module_path: Optional[str], config: Optional[Config], source: bytes
647     ) -> None:
648         super().__init__()
649         self.module_path = module_path
650         self.config = config
651         if config is not None:
652             self.enable_assertion_pass_hook = config.getini(
653                 "enable_assertion_pass_hook"
654             )
655         else:
656             self.enable_assertion_pass_hook = False
657         self.source = source
658         self.variables_overwrite: Dict[str, str] = {}
659 
660     def run(self, mod: ast.Module) -> None:
661         """Find all assert statements in *mod* and rewrite them."""
662         if not mod.body:
663             # Nothing to do.
664             return
665 
666         # We'll insert some special imports at the top of the module, but after any
667         # docstrings and __future__ imports, so first figure out where that is.
668         doc = getattr(mod, "docstring", None)
669         expect_docstring = doc is None
670         if doc is not None and self.is_rewrite_disabled(doc):
671             return
672         pos = 0
673         item = None
674         for item in mod.body:
675             if (
676                 expect_docstring
677                 and isinstance(item, ast.Expr)
678                 and isinstance(item.value, ast.Constant)
679             ):
680                 doc = item.value.value
681                 if self.is_rewrite_disabled(doc):
682                     return
683                 expect_docstring = False
684             elif (
685                 isinstance(item, ast.ImportFrom)
686                 and item.level == 0
687                 and item.module == "__future__"
688             ):
689                 pass
690             else:
691                 break
692             pos += 1
693         # Special case: for a decorated function, set the lineno to that of the
694         # first decorator, not the `def`. Issue #4984.
695         if isinstance(item, ast.FunctionDef) and item.decorator_list:
696             lineno = item.decorator_list[0].lineno
697         else:
698             lineno = item.lineno
699         # Now actually insert the special imports.
700         if sys.version_info >= (3, 10):
701             aliases = [
702                 ast.alias("builtins", "@py_builtins", lineno=lineno, col_offset=0),
703                 ast.alias(
704                     "_pytest.assertion.rewrite",
705                     "@pytest_ar",
706                     lineno=lineno,
707                     col_offset=0,
708                 ),
709             ]
710         else:
711             aliases = [
712                 ast.alias("builtins", "@py_builtins"),
713                 ast.alias("_pytest.assertion.rewrite", "@pytest_ar"),
714             ]
715         imports = [
716             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases
717         ]
718         mod.body[pos:pos] = imports
719 
720         # Collect asserts.
721         nodes: List[ast.AST] = [mod]
722         while nodes:
723             node = nodes.pop()
724             for name, field in ast.iter_fields(node):
725                 if isinstance(field, list):
726                     new: List[ast.AST] = []
727                     for i, child in enumerate(field):
728                         if isinstance(child, ast.Assert):
729                             # Transform assert.
730                             new.extend(self.visit(child))
731                         else:
732                             new.append(child)
733                             if isinstance(child, ast.AST):
734                                 nodes.append(child)
735                     setattr(node, name, new)
736                 elif (
737                     isinstance(field, ast.AST)
738                     # Don't recurse into expressions as they can't contain
739                     # asserts.
740                     and not isinstance(field, ast.expr)
741                 ):
742                     nodes.append(field)
743 
744     @staticmethod
745     def is_rewrite_disabled(docstring: str) -> bool:
746         return "PYTEST_DONT_REWRITE" in docstring
747 
748     def variable(self) -> str:
749         """Get a new variable."""
750         # Use a character invalid in python identifiers to avoid clashing.
751         name = "@py_assert" + str(next(self.variable_counter))
752         self.variables.append(name)
753         return name
754 
755     def assign(self, expr: ast.expr) -> ast.Name:
756         """Give *expr* a name."""
757         name = self.variable()
758         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))
759         return ast.Name(name, ast.Load())
760 
761     def display(self, expr: ast.expr) -> ast.expr:
762         """Call saferepr on the expression."""
763         return self.helper("_saferepr", expr)
764 
765     def helper(self, name: str, *args: ast.expr) -> ast.expr:
766         """Call a helper in this module."""
767         py_name = ast.Name("@pytest_ar", ast.Load())
768         attr = ast.Attribute(py_name, name, ast.Load())
769         return ast.Call(attr, list(args), [])
770 
771     def builtin(self, name: str) -> ast.Attribute:
772         """Return the builtin called *name*."""
773         builtin_name = ast.Name("@py_builtins", ast.Load())
774         return ast.Attribute(builtin_name, name, ast.Load())
775 
776     def explanation_param(self, expr: ast.expr) -> str:
777         """Return a new named %-formatting placeholder for expr.
778 
779         This creates a %-formatting placeholder for expr in the
780         current formatting context, e.g. ``%(py0)s``.  The placeholder
781         and expr are placed in the current format context so that it
782         can be used on the next call to .pop_format_context().
783         """
784         specifier = "py" + str(next(self.variable_counter))
785         self.explanation_specifiers[specifier] = expr
786         return "%(" + specifier + ")s"
787 
788     def push_format_context(self) -> None:
789         """Create a new formatting context.
790 
791         The format context is used for when an explanation wants to
792         have a variable value formatted in the assertion message.  In
793         this case the value required can be added using
794         .explanation_param().  Finally .pop_format_context() is used
795         to format a string of %-formatted values as added by
796         .explanation_param().
797         """
798         self.explanation_specifiers: Dict[str, ast.expr] = {}
799         self.stack.append(self.explanation_specifiers)
800 
801     def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:
802         """Format the %-formatted string with current format context.
803 
804         The expl_expr should be an str ast.expr instance constructed from
805         the %-placeholders created by .explanation_param().  This will
806         add the required code to format said string to .expl_stmts and
807         return the ast.Name instance of the formatted string.
808         """
809         current = self.stack.pop()
810         if self.stack:
811             self.explanation_specifiers = self.stack[-1]
812         keys = [ast.Constant(key) for key in current.keys()]
813         format_dict = ast.Dict(keys, list(current.values()))
814         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)
815         name = "@py_format" + str(next(self.variable_counter))
816         if self.enable_assertion_pass_hook:
817             self.format_variables.append(name)
818         self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))
819         return ast.Name(name, ast.Load())
820 
821     def generic_visit(self, node: ast.AST) -> Tuple[ast.Name, str]:
822         """Handle expressions we don't have custom code for."""
823         assert isinstance(node, ast.expr)
824         res = self.assign(node)
825         return res, self.explanation_param(self.display(res))
826 
827     def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:
828         """Return the AST statements to replace the ast.Assert instance.
829 
830         This rewrites the test of an assertion to provide
831         intermediate values and replace it with an if statement which
832         raises an assertion error with a detailed explanation in case
833         the expression is false.
834         """
835         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
836             from _pytest.warning_types import PytestAssertRewriteWarning
837             import warnings
838 
839             # TODO: This assert should not be needed.
840             assert self.module_path is not None
841             warnings.warn_explicit(
842                 PytestAssertRewriteWarning(
843                     "assertion is always true, perhaps remove parentheses?"
844                 ),
845                 category=None,
846                 filename=self.module_path,
847                 lineno=assert_.lineno,
848             )
849 
850         self.statements: List[ast.stmt] = []
851         self.variables: List[str] = []
852         self.variable_counter = itertools.count()
853 
854         if self.enable_assertion_pass_hook:
855             self.format_variables: List[str] = []
856 
857         self.stack: List[Dict[str, ast.expr]] = []
858         self.expl_stmts: List[ast.stmt] = []
859         self.push_format_context()
860         # Rewrite assert into a bunch of statements.
861         top_condition, explanation = self.visit(assert_.test)
862 
863         negation = ast.UnaryOp(ast.Not(), top_condition)
864 
865         if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook
866             msg = self.pop_format_context(ast.Constant(explanation))
867 
868             # Failed
869             if assert_.msg:
870                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
871                 gluestr = "\n>assert "
872             else:
873                 assertmsg = ast.Constant("")
874                 gluestr = "assert "
875             err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)
876             err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)
877             err_name = ast.Name("AssertionError", ast.Load())
878             fmt = self.helper("_format_explanation", err_msg)
879             exc = ast.Call(err_name, [fmt], [])
880             raise_ = ast.Raise(exc, None)
881             statements_fail = []
882             statements_fail.extend(self.expl_stmts)
883             statements_fail.append(raise_)
884 
885             # Passed
886             fmt_pass = self.helper("_format_explanation", msg)
887             orig = _get_assertion_exprs(self.source)[assert_.lineno]
888             hook_call_pass = ast.Expr(
889                 self.helper(
890                     "_call_assertion_pass",
891                     ast.Constant(assert_.lineno),
892                     ast.Constant(orig),
893                     fmt_pass,
894                 )
895             )
896             # If any hooks implement assert_pass hook
897             hook_impl_test = ast.If(
898                 self.helper("_check_if_assertion_pass_impl"),
899                 self.expl_stmts + [hook_call_pass],
900                 [],
901             )
902             statements_pass = [hook_impl_test]
903 
904             # Test for assertion condition
905             main_test = ast.If(negation, statements_fail, statements_pass)
906             self.statements.append(main_test)
907             if self.format_variables:
908                 variables = [
909                     ast.Name(name, ast.Store()) for name in self.format_variables
910                 ]
911                 clear_format = ast.Assign(variables, ast.Constant(None))
912                 self.statements.append(clear_format)
913 
914         else:  # Original assertion rewriting
915             # Create failure message.
916             body = self.expl_stmts
917             self.statements.append(ast.If(negation, body, []))
918             if assert_.msg:
919                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
920                 explanation = "\n>assert " + explanation
921             else:
922                 assertmsg = ast.Constant("")
923                 explanation = "assert " + explanation
924             template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))
925             msg = self.pop_format_context(template)
926             fmt = self.helper("_format_explanation", msg)
927             err_name = ast.Name("AssertionError", ast.Load())
928             exc = ast.Call(err_name, [fmt], [])
929             raise_ = ast.Raise(exc, None)
930 
931             body.append(raise_)
932 
933         # Clear temporary variables by setting them to None.
934         if self.variables:
935             variables = [ast.Name(name, ast.Store()) for name in self.variables]
936             clear = ast.Assign(variables, ast.Constant(None))
937             self.statements.append(clear)
938         # Fix locations (line numbers/column offsets).
939         for stmt in self.statements:
940             for node in traverse_node(stmt):
941                 ast.copy_location(node, assert_)
942         return self.statements
943 
944     def visit_NamedExpr(self, name: ast.NamedExpr) -> Tuple[ast.NamedExpr, str]:
945         # This method handles the 'walrus operator' repr of the target
946         # name if it's a local variable or _should_repr_global_name()
947         # thinks it's acceptable.
948         locs = ast.Call(self.builtin("locals"), [], [])
949         target_id = name.target.id  # type: ignore[attr-defined]
950         inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])
951         dorepr = self.helper("_should_repr_global_name", name)
952         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
953         expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))
954         return name, self.explanation_param(expr)
955 
956     def visit_Name(self, name: ast.Name) -> Tuple[ast.Name, str]:
957         # Display the repr of the name if it's a local variable or
958         # _should_repr_global_name() thinks it's acceptable.
959         locs = ast.Call(self.builtin("locals"), [], [])
960         inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])
961         dorepr = self.helper("_should_repr_global_name", name)
962         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
963         expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))
964         return name, self.explanation_param(expr)
965 
966     def visit_BoolOp(self, boolop: ast.BoolOp) -> Tuple[ast.Name, str]:
967         res_var = self.variable()
968         expl_list = self.assign(ast.List([], ast.Load()))
969         app = ast.Attribute(expl_list, "append", ast.Load())
970         is_or = int(isinstance(boolop.op, ast.Or))
971         body = save = self.statements
972         fail_save = self.expl_stmts
973         levels = len(boolop.values) - 1
974         self.push_format_context()
975         # Process each operand, short-circuiting if needed.
976         for i, v in enumerate(boolop.values):
977             if i:
978                 fail_inner: List[ast.stmt] = []
979                 # cond is set in a prior loop iteration below
980                 self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa
981                 self.expl_stmts = fail_inner
982                 # Check if the left operand is a ast.NamedExpr and the value has already been visited
983                 if (
984                     isinstance(v, ast.Compare)
985                     and isinstance(v.left, ast.NamedExpr)
986                     and v.left.target.id
987                     in [
988                         ast_expr.id
989                         for ast_expr in boolop.values[:i]
990                         if hasattr(ast_expr, "id")
991                     ]
992                 ):
993                     pytest_temp = self.variable()
994                     self.variables_overwrite[
995                         v.left.target.id
996                     ] = v.left  # type:ignore[assignment]
997                     v.left.target.id = pytest_temp
998             self.push_format_context()
999             res, expl = self.visit(v)
1000             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))
1001             expl_format = self.pop_format_context(ast.Constant(expl))
1002             call = ast.Call(app, [expl_format], [])
1003             self.expl_stmts.append(ast.Expr(call))
1004             if i < levels:
1005                 cond: ast.expr = res
1006                 if is_or:
1007                     cond = ast.UnaryOp(ast.Not(), cond)
1008                 inner: List[ast.stmt] = []
1009                 self.statements.append(ast.If(cond, inner, []))
1010                 self.statements = body = inner
1011         self.statements = save
1012         self.expl_stmts = fail_save
1013         expl_template = self.helper("_format_boolop", expl_list, ast.Constant(is_or))
1014         expl = self.pop_format_context(expl_template)
1015         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)
1016 
1017     def visit_UnaryOp(self, unary: ast.UnaryOp) -> Tuple[ast.Name, str]:
1018         pattern = UNARY_MAP[unary.op.__class__]
1019         operand_res, operand_expl = self.visit(unary.operand)
1020         res = self.assign(ast.UnaryOp(unary.op, operand_res))
1021         return res, pattern % (operand_expl,)
1022 
1023     def visit_BinOp(self, binop: ast.BinOp) -> Tuple[ast.Name, str]:
1024         symbol = BINOP_MAP[binop.op.__class__]
1025         left_expr, left_expl = self.visit(binop.left)
1026         right_expr, right_expl = self.visit(binop.right)
1027         explanation = f"({left_expl} {symbol} {right_expl})"
1028         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))
1029         return res, explanation
1030 
1031     def visit_Call(self, call: ast.Call) -> Tuple[ast.Name, str]:
1032         new_func, func_expl = self.visit(call.func)
1033         arg_expls = []
1034         new_args = []
1035         new_kwargs = []
1036         for arg in call.args:
1037             if isinstance(arg, ast.Name) and arg.id in self.variables_overwrite:
1038                 arg = self.variables_overwrite[arg.id]  # type:ignore[assignment]
1039             res, expl = self.visit(arg)
1040             arg_expls.append(expl)
1041             new_args.append(res)
1042         for keyword in call.keywords:
1043             if (
1044                 isinstance(keyword.value, ast.Name)
1045                 and keyword.value.id in self.variables_overwrite
1046             ):
1047                 keyword.value = self.variables_overwrite[
1048                     keyword.value.id
1049                 ]  # type:ignore[assignment]
1050             res, expl = self.visit(keyword.value)
1051             new_kwargs.append(ast.keyword(keyword.arg, res))
1052             if keyword.arg:
1053                 arg_expls.append(keyword.arg + "=" + expl)
1054             else:  # **args have `arg` keywords with an .arg of None
1055                 arg_expls.append("**" + expl)
1056 
1057         expl = "{}({})".format(func_expl, ", ".join(arg_expls))
1058         new_call = ast.Call(new_func, new_args, new_kwargs)
1059         res = self.assign(new_call)
1060         res_expl = self.explanation_param(self.display(res))
1061         outer_expl = f"{res_expl}\n{{{res_expl} = {expl}\n}}"
1062         return res, outer_expl
1063 
1064     def visit_Starred(self, starred: ast.Starred) -> Tuple[ast.Starred, str]:
1065         # A Starred node can appear in a function call.
1066         res, expl = self.visit(starred.value)
1067         new_starred = ast.Starred(res, starred.ctx)
1068         return new_starred, "*" + expl
1069 
1070     def visit_Attribute(self, attr: ast.Attribute) -> Tuple[ast.Name, str]:
1071         if not isinstance(attr.ctx, ast.Load):
1072             return self.generic_visit(attr)
1073         value, value_expl = self.visit(attr.value)
1074         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))
1075         res_expl = self.explanation_param(self.display(res))
1076         pat = "%s\n{%s = %s.%s\n}"
1077         expl = pat % (res_expl, res_expl, value_expl, attr.attr)
1078         return res, expl
1079 
1080     def visit_Compare(self, comp: ast.Compare) -> Tuple[ast.expr, str]:
1081         self.push_format_context()
1082         # We first check if we have overwritten a variable in the previous assert
1083         if isinstance(comp.left, ast.Name) and comp.left.id in self.variables_overwrite:
1084             comp.left = self.variables_overwrite[
1085                 comp.left.id
1086             ]  # type:ignore[assignment]
1087         if isinstance(comp.left, ast.NamedExpr):
1088             self.variables_overwrite[
1089                 comp.left.target.id
1090             ] = comp.left  # type:ignore[assignment]
1091         left_res, left_expl = self.visit(comp.left)
1092         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):
1093             left_expl = f"({left_expl})"
1094         res_variables = [self.variable() for i in range(len(comp.ops))]
1095         load_names = [ast.Name(v, ast.Load()) for v in res_variables]
1096         store_names = [ast.Name(v, ast.Store()) for v in res_variables]
1097         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)
1098         expls = []
1099         syms = []
1100         results = [left_res]
1101         for i, op, next_operand in it:
1102             if (
1103                 isinstance(next_operand, ast.NamedExpr)
1104                 and isinstance(left_res, ast.Name)
1105                 and next_operand.target.id == left_res.id
1106             ):
1107                 next_operand.target.id = self.variable()
1108                 self.variables_overwrite[
1109                     left_res.id
1110                 ] = next_operand  # type:ignore[assignment]
1111             next_res, next_expl = self.visit(next_operand)
1112             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):
1113                 next_expl = f"({next_expl})"
1114             results.append(next_res)
1115             sym = BINOP_MAP[op.__class__]
1116             syms.append(ast.Constant(sym))
1117             expl = f"{left_expl} {sym} {next_expl}"
1118             expls.append(ast.Constant(expl))
1119             res_expr = ast.Compare(left_res, [op], [next_res])
1120             self.statements.append(ast.Assign([store_names[i]], res_expr))
1121             left_res, left_expl = next_res, next_expl
1122         # Use pytest.assertion.util._reprcompare if that's available.
1123         expl_call = self.helper(
1124             "_call_reprcompare",
1125             ast.Tuple(syms, ast.Load()),
1126             ast.Tuple(load_names, ast.Load()),
1127             ast.Tuple(expls, ast.Load()),
1128             ast.Tuple(results, ast.Load()),
1129         )
1130         if len(comp.ops) > 1:
1131             res: ast.expr = ast.BoolOp(ast.And(), load_names)
1132         else:
1133             res = load_names[0]
1134 
1135         return res, self.explanation_param(self.pop_format_context(expl_call))
1136 
1137 
1138 def try_makedirs(cache_dir: Path) -> bool:
1139     """Attempt to create the given directory and sub-directories exist.
1140 
1141     Returns True if successful or if it already exists.
1142     """
1143     try:
1144         os.makedirs(cache_dir, exist_ok=True)
1145     except (FileNotFoundError, NotADirectoryError, FileExistsError):
1146         # One of the path components was not a directory:
1147         # - we're in a zip file
1148         # - it is a file
1149         return False
1150     except PermissionError:
1151         return False
1152     except OSError as e:
1153         # as of now, EROFS doesn't have an equivalent OSError-subclass
1154         if e.errno == errno.EROFS:
1155             return False
1156         raise
1157     return True
1158 
1159 
1160 def get_cache_dir(file_path: Path) -> Path:
1161     """Return the cache directory to write .pyc files for the given .py file path."""
1162     if sys.pycache_prefix:
1163         # given:
1164         #   prefix = '/tmp/pycs'
1165         #   path = '/home/user/proj/test_app.py'
1166         # we want:
1167         #   '/tmp/pycs/home/user/proj'
1168         return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])
1169     else:
1170         # classic pycache directory
1171         return file_path.parent / "__pycache__"

</code><intended_behavior>Before importing a module dynamically using importlib, the code should first check sys.modules to see if the module is already loaded. If the module exists, it should use the existing instance rather than importing it again. Implement a centralized mechanism or utility function for dynamic imports that includes this check and logging or warnings when attempts are made to re-import an already loaded module.</intended_behavior>, <file>testing/test_config.py</file>
<class>None</class>
<method>None</method>
<code>
1 import dataclasses
2 import importlib.metadata
3 import os
4 import re
5 import sys
6 import textwrap
7 from pathlib import Path
8 from typing import Dict
9 from typing import List
10 from typing import Sequence
11 from typing import Tuple
12 from typing import Type
13 from typing import Union
14 
15 import _pytest._code
16 import pytest
17 from _pytest.config import _get_plugin_specs_as_list
18 from _pytest.config import _iter_rewritable_modules
19 from _pytest.config import _strtobool
20 from _pytest.config import Config
21 from _pytest.config import ConftestImportFailure
22 from _pytest.config import ExitCode
23 from _pytest.config import parse_warning_filter
24 from _pytest.config.exceptions import UsageError
25 from _pytest.config.findpaths import determine_setup
26 from _pytest.config.findpaths import get_common_ancestor
27 from _pytest.config.findpaths import locate_config
28 from _pytest.monkeypatch import MonkeyPatch
29 from _pytest.pathlib import absolutepath
30 from _pytest.pytester import Pytester
31 
32 
33 class TestParseIni:
34     @pytest.mark.parametrize(
35         "section, filename", [("pytest", "pytest.ini"), ("tool:pytest", "setup.cfg")]
36     )
37     def test_getcfg_and_config(
38         self,
39         pytester: Pytester,
40         tmp_path: Path,
41         section: str,
42         filename: str,
43         monkeypatch: MonkeyPatch,
44     ) -> None:
45         sub = tmp_path / "sub"
46         sub.mkdir()
47         monkeypatch.chdir(sub)
48         (tmp_path / filename).write_text(
49             textwrap.dedent(
50                 """\
51                 [{section}]
52                 name = value
53                 """.format(
54                     section=section
55                 )
56             ),
57             encoding="utf-8",
58         )
59         _, _, cfg = locate_config([sub])
60         assert cfg["name"] == "value"
61         config = pytester.parseconfigure(str(sub))
62         assert config.inicfg["name"] == "value"
63 
64     def test_setupcfg_uses_toolpytest_with_pytest(self, pytester: Pytester) -> None:
65         p1 = pytester.makepyfile("def test(): pass")
66         pytester.makefile(
67             ".cfg",
68             setup="""
69                 [tool:pytest]
70                 testpaths=%s
71                 [pytest]
72                 testpaths=ignored
73         """
74             % p1.name,
75         )
76         result = pytester.runpytest()
77         result.stdout.fnmatch_lines(["configfile: setup.cfg", "* 1 passed in *"])
78         assert result.ret == 0
79 
80     def test_append_parse_args(
81         self, pytester: Pytester, tmp_path: Path, monkeypatch: MonkeyPatch
82     ) -> None:
83         monkeypatch.setenv("PYTEST_ADDOPTS", '--color no -rs --tb="short"')
84         tmp_path.joinpath("pytest.ini").write_text(
85             textwrap.dedent(
86                 """\
87                 [pytest]
88                 addopts = --verbose
89                 """
90             ),
91             encoding="utf-8",
92         )
93         config = pytester.parseconfig(tmp_path)
94         assert config.option.color == "no"
95         assert config.option.reportchars == "s"
96         assert config.option.tbstyle == "short"
97         assert config.option.verbose
98 
99     def test_tox_ini_wrong_version(self, pytester: Pytester) -> None:
100         pytester.makefile(
101             ".ini",
102             tox="""
103             [pytest]
104             minversion=999.0
105         """,
106         )
107         result = pytester.runpytest()
108         assert result.ret != 0
109         result.stderr.fnmatch_lines(
110             ["*tox.ini: 'minversion' requires pytest-999.0, actual pytest-*"]
111         )
112 
113     @pytest.mark.parametrize(
114         "section, name",
115         [
116             ("tool:pytest", "setup.cfg"),
117             ("pytest", "tox.ini"),
118             ("pytest", "pytest.ini"),
119             ("pytest", ".pytest.ini"),
120         ],
121     )
122     def test_ini_names(self, pytester: Pytester, name, section) -> None:
123         pytester.path.joinpath(name).write_text(
124             textwrap.dedent(
125                 """
126             [{section}]
127             minversion = 3.36
128         """.format(
129                     section=section
130                 )
131             ),
132             encoding="utf-8",
133         )
134         config = pytester.parseconfig()
135         assert config.getini("minversion") == "3.36"
136 
137     def test_pyproject_toml(self, pytester: Pytester) -> None:
138         pytester.makepyprojecttoml(
139             """
140             [tool.pytest.ini_options]
141             minversion = "1.0"
142         """
143         )
144         config = pytester.parseconfig()
145         assert config.getini("minversion") == "1.0"
146 
147     def test_toxini_before_lower_pytestini(self, pytester: Pytester) -> None:
148         sub = pytester.mkdir("sub")
149         sub.joinpath("tox.ini").write_text(
150             textwrap.dedent(
151                 """
152             [pytest]
153             minversion = 2.0
154         """
155             ),
156             encoding="utf-8",
157         )
158         pytester.path.joinpath("pytest.ini").write_text(
159             textwrap.dedent(
160                 """
161             [pytest]
162             minversion = 1.5
163         """
164             ),
165             encoding="utf-8",
166         )
167         config = pytester.parseconfigure(sub)
168         assert config.getini("minversion") == "2.0"
169 
170     def test_ini_parse_error(self, pytester: Pytester) -> None:
171         pytester.path.joinpath("pytest.ini").write_text(
172             "addopts = -x", encoding="utf-8"
173         )
174         result = pytester.runpytest()
175         assert result.ret != 0
176         result.stderr.fnmatch_lines("ERROR: *pytest.ini:1: no section header defined")
177 
178     def test_toml_parse_error(self, pytester: Pytester) -> None:
179         pytester.makepyprojecttoml(
180             """
181             \\"
182             """
183         )
184         result = pytester.runpytest()
185         assert result.ret != 0
186         result.stderr.fnmatch_lines("ERROR: *pyproject.toml: Invalid statement*")
187 
188     def test_confcutdir_default_without_configfile(self, pytester: Pytester) -> None:
189         # If --confcutdir is not specified, and there is no configfile, default
190         # to the roothpath.
191         sub = pytester.mkdir("sub")
192         os.chdir(sub)
193         config = pytester.parseconfigure()
194         assert config.pluginmanager._confcutdir == sub
195 
196     def test_confcutdir_default_with_configfile(self, pytester: Pytester) -> None:
197         # If --confcutdir is not specified, and there is a configfile, default
198         # to the configfile's directory.
199         pytester.makeini("[pytest]")
200         sub = pytester.mkdir("sub")
201         os.chdir(sub)
202         config = pytester.parseconfigure()
203         assert config.pluginmanager._confcutdir == pytester.path
204 
205     @pytest.mark.xfail(reason="probably not needed")
206     def test_confcutdir(self, pytester: Pytester) -> None:
207         sub = pytester.mkdir("sub")
208         os.chdir(sub)
209         pytester.makeini(
210             """
211             [pytest]
212             addopts = --qwe
213         """
214         )
215         result = pytester.inline_run("--confcutdir=.")
216         assert result.ret == 0
217 
218     @pytest.mark.parametrize(
219         "ini_file_text, invalid_keys, warning_output, exception_text",
220         [
221             pytest.param(
222                 """
223                 [pytest]
224                 unknown_ini = value1
225                 another_unknown_ini = value2
226                 """,
227                 ["unknown_ini", "another_unknown_ini"],
228                 [
229                     "=*= warnings summary =*=",
230                     "*PytestConfigWarning:*Unknown config option: another_unknown_ini",
231                     "*PytestConfigWarning:*Unknown config option: unknown_ini",
232                 ],
233                 "Unknown config option: another_unknown_ini",
234                 id="2-unknowns",
235             ),
236             pytest.param(
237                 """
238                 [pytest]
239                 unknown_ini = value1
240                 minversion = 5.0.0
241                 """,
242                 ["unknown_ini"],
243                 [
244                     "=*= warnings summary =*=",
245                     "*PytestConfigWarning:*Unknown config option: unknown_ini",
246                 ],
247                 "Unknown config option: unknown_ini",
248                 id="1-unknown",
249             ),
250             pytest.param(
251                 """
252                 [some_other_header]
253                 unknown_ini = value1
254                 [pytest]
255                 minversion = 5.0.0
256                 """,
257                 [],
258                 [],
259                 "",
260                 id="unknown-in-other-header",
261             ),
262             pytest.param(
263                 """
264                 [pytest]
265                 minversion = 5.0.0
266                 """,
267                 [],
268                 [],
269                 "",
270                 id="no-unknowns",
271             ),
272             pytest.param(
273                 """
274                 [pytest]
275                 conftest_ini_key = 1
276                 """,
277                 [],
278                 [],
279                 "",
280                 id="1-known",
281             ),
282         ],
283     )
284     @pytest.mark.filterwarnings("default")
285     def test_invalid_config_options(
286         self,
287         pytester: Pytester,
288         ini_file_text,
289         invalid_keys,
290         warning_output,
291         exception_text,
292     ) -> None:
293         pytester.makeconftest(
294             """
295             def pytest_addoption(parser):
296                 parser.addini("conftest_ini_key", "")
297             """
298         )
299         pytester.makepyfile("def test(): pass")
300         pytester.makeini(ini_file_text)
301 
302         config = pytester.parseconfig()
303         assert sorted(config._get_unknown_ini_keys()) == sorted(invalid_keys)
304 
305         result = pytester.runpytest()
306         result.stdout.fnmatch_lines(warning_output)
307 
308         result = pytester.runpytest("--strict-config")
309         if exception_text:
310             result.stderr.fnmatch_lines("ERROR: " + exception_text)
311             assert result.ret == pytest.ExitCode.USAGE_ERROR
312         else:
313             result.stderr.no_fnmatch_line(exception_text)
314             assert result.ret == pytest.ExitCode.OK
315 
316     @pytest.mark.filterwarnings("default")
317     def test_silence_unknown_key_warning(self, pytester: Pytester) -> None:
318         """Unknown config key warnings can be silenced using filterwarnings (#7620)"""
319         pytester.makeini(
320             """
321             [pytest]
322             filterwarnings =
323                 ignore:Unknown config option:pytest.PytestConfigWarning
324             foobar=1
325         """
326         )
327         result = pytester.runpytest()
328         result.stdout.no_fnmatch_line("*PytestConfigWarning*")
329 
330     @pytest.mark.filterwarnings("default::pytest.PytestConfigWarning")
331     def test_disable_warnings_plugin_disables_config_warnings(
332         self, pytester: Pytester
333     ) -> None:
334         """Disabling 'warnings' plugin also disables config time warnings"""
335         pytester.makeconftest(
336             """
337             import pytest
338             def pytest_configure(config):
339                 config.issue_config_time_warning(
340                     pytest.PytestConfigWarning("custom config warning"),
341                     stacklevel=2,
342                 )
343         """
344         )
345         result = pytester.runpytest("-pno:warnings")
346         result.stdout.no_fnmatch_line("*PytestConfigWarning*")
347 
348     @pytest.mark.parametrize(
349         "ini_file_text, plugin_version, exception_text",
350         [
351             pytest.param(
352                 """
353                 [pytest]
354                 required_plugins = a z
355                 """,
356                 "1.5",
357                 "Missing required plugins: a, z",
358                 id="2-missing",
359             ),
360             pytest.param(
361                 """
362                 [pytest]
363                 required_plugins = a z myplugin
364                 """,
365                 "1.5",
366                 "Missing required plugins: a, z",
367                 id="2-missing-1-ok",
368             ),
369             pytest.param(
370                 """
371                 [pytest]
372                 required_plugins = myplugin
373                 """,
374                 "1.5",
375                 None,
376                 id="1-ok",
377             ),
378             pytest.param(
379                 """
380                 [pytest]
381                 required_plugins = myplugin==1.5
382                 """,
383                 "1.5",
384                 None,
385                 id="1-ok-pin-exact",
386             ),
387             pytest.param(
388                 """
389                 [pytest]
390                 required_plugins = myplugin>1.0,<2.0
391                 """,
392                 "1.5",
393                 None,
394                 id="1-ok-pin-loose",
395             ),
396             pytest.param(
397                 """
398                 [pytest]
399                 required_plugins = myplugin
400                 """,
401                 "1.5a1",
402                 None,
403                 id="1-ok-prerelease",
404             ),
405             pytest.param(
406                 """
407                 [pytest]
408                 required_plugins = myplugin==1.6
409                 """,
410                 "1.5",
411                 "Missing required plugins: myplugin==1.6",
412                 id="missing-version",
413             ),
414             pytest.param(
415                 """
416                 [pytest]
417                 required_plugins = myplugin==1.6 other==1.0
418                 """,
419                 "1.5",
420                 "Missing required plugins: myplugin==1.6, other==1.0",
421                 id="missing-versions",
422             ),
423             pytest.param(
424                 """
425                 [some_other_header]
426                 required_plugins = won't be triggered
427                 [pytest]
428                 """,
429                 "1.5",
430                 None,
431                 id="invalid-header",
432             ),
433         ],
434     )
435     def test_missing_required_plugins(
436         self,
437         pytester: Pytester,
438         monkeypatch: MonkeyPatch,
439         ini_file_text: str,
440         plugin_version: str,
441         exception_text: str,
442     ) -> None:
443         """Check 'required_plugins' option with various settings.
444 
445         This test installs a mock "myplugin-1.5" which is used in the parametrized test cases.
446         """
447 
448         @dataclasses.dataclass
449         class DummyEntryPoint:
450             name: str
451             module: str
452             group: str = "pytest11"
453 
454             def load(self):
455                 __import__(self.module)
456                 return sys.modules[self.module]
457 
458         entry_points = [
459             DummyEntryPoint("myplugin1", "myplugin1_module"),
460         ]
461 
462         @dataclasses.dataclass
463         class DummyDist:
464             entry_points: object
465             files: object = ()
466             version: str = plugin_version
467 
468             @property
469             def metadata(self):
470                 return {"name": "myplugin"}
471 
472         def my_dists():
473             return [DummyDist(entry_points)]
474 
475         pytester.makepyfile(myplugin1_module="# my plugin module")
476         pytester.syspathinsert()
477 
478         monkeypatch.setattr(importlib.metadata, "distributions", my_dists)
479         monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
480 
481         pytester.makeini(ini_file_text)
482 
483         if exception_text:
484             with pytest.raises(pytest.UsageError, match=exception_text):
485                 pytester.parseconfig()
486         else:
487             pytester.parseconfig()
488 
489     def test_early_config_cmdline(
490         self, pytester: Pytester, monkeypatch: MonkeyPatch
491     ) -> None:
492         """early_config contains options registered by third-party plugins.
493 
494         This is a regression involving pytest-cov (and possibly others) introduced in #7700.
495         """
496         pytester.makepyfile(
497             myplugin="""
498             def pytest_addoption(parser):
499                 parser.addoption('--foo', default=None, dest='foo')
500 
501             def pytest_load_initial_conftests(early_config, parser, args):
502                 assert early_config.known_args_namespace.foo == "1"
503             """
504         )
505         monkeypatch.setenv("PYTEST_PLUGINS", "myplugin")
506         pytester.syspathinsert()
507         result = pytester.runpytest("--foo=1")
508         result.stdout.fnmatch_lines("* no tests ran in *")
509 
510 
511 class TestConfigCmdlineParsing:
512     def test_parsing_again_fails(self, pytester: Pytester) -> None:
513         config = pytester.parseconfig()
514         pytest.raises(AssertionError, lambda: config.parse([]))
515 
516     def test_explicitly_specified_config_file_is_loaded(
517         self, pytester: Pytester
518     ) -> None:
519         pytester.makeconftest(
520             """
521             def pytest_addoption(parser):
522                 parser.addini("custom", "")
523         """
524         )
525         pytester.makeini(
526             """
527             [pytest]
528             custom = 0
529         """
530         )
531         pytester.makefile(
532             ".ini",
533             custom="""
534             [pytest]
535             custom = 1
536         """,
537         )
538         config = pytester.parseconfig("-c", "custom.ini")
539         assert config.getini("custom") == "1"
540         config = pytester.parseconfig("--config-file", "custom.ini")
541         assert config.getini("custom") == "1"
542 
543         pytester.makefile(
544             ".cfg",
545             custom_tool_pytest_section="""
546             [tool:pytest]
547             custom = 1
548         """,
549         )
550         config = pytester.parseconfig("-c", "custom_tool_pytest_section.cfg")
551         assert config.getini("custom") == "1"
552         config = pytester.parseconfig("--config-file", "custom_tool_pytest_section.cfg")
553         assert config.getini("custom") == "1"
554 
555         pytester.makefile(
556             ".toml",
557             custom="""
558                 [tool.pytest.ini_options]
559                 custom = 1
560                 value = [
561                 ]  # this is here on purpose, as it makes this an invalid '.ini' file
562             """,
563         )
564         config = pytester.parseconfig("-c", "custom.toml")
565         assert config.getini("custom") == "1"
566         config = pytester.parseconfig("--config-file", "custom.toml")
567         assert config.getini("custom") == "1"
568 
569     def test_absolute_win32_path(self, pytester: Pytester) -> None:
570         temp_ini_file = pytester.makefile(
571             ".ini",
572             custom="""
573             [pytest]
574             addopts = --version
575         """,
576         )
577         from os.path import normpath
578 
579         temp_ini_file_norm = normpath(str(temp_ini_file))
580         ret = pytest.main(["-c", temp_ini_file_norm])
581         assert ret == ExitCode.OK
582         ret = pytest.main(["--config-file", temp_ini_file_norm])
583         assert ret == ExitCode.OK
584 
585 
586 class TestConfigAPI:
587     def test_config_trace(self, pytester: Pytester) -> None:
588         config = pytester.parseconfig()
589         values: List[str] = []
590         config.trace.root.setwriter(values.append)
591         config.trace("hello")
592         assert len(values) == 1
593         assert values[0] == "hello [config]\n"
594 
595     def test_config_getoption(self, pytester: Pytester) -> None:
596         pytester.makeconftest(
597             """
598             def pytest_addoption(parser):
599                 parser.addoption("--hello", "-X", dest="hello")
600         """
601         )
602         config = pytester.parseconfig("--hello=this")
603         for x in ("hello", "--hello", "-X"):
604             assert config.getoption(x) == "this"
605         pytest.raises(ValueError, config.getoption, "qweqwe")
606 
607     def test_config_getoption_unicode(self, pytester: Pytester) -> None:
608         pytester.makeconftest(
609             """
610             def pytest_addoption(parser):
611                 parser.addoption('--hello', type=str)
612         """
613         )
614         config = pytester.parseconfig("--hello=this")
615         assert config.getoption("hello") == "this"
616 
617     def test_config_getvalueorskip(self, pytester: Pytester) -> None:
618         config = pytester.parseconfig()
619         pytest.raises(pytest.skip.Exception, config.getvalueorskip, "hello")
620         verbose = config.getvalueorskip("verbose")
621         assert verbose == config.option.verbose
622 
623     def test_config_getvalueorskip_None(self, pytester: Pytester) -> None:
624         pytester.makeconftest(
625             """
626             def pytest_addoption(parser):
627                 parser.addoption("--hello")
628         """
629         )
630         config = pytester.parseconfig()
631         with pytest.raises(pytest.skip.Exception):
632             config.getvalueorskip("hello")
633 
634     def test_getoption(self, pytester: Pytester) -> None:
635         config = pytester.parseconfig()
636         with pytest.raises(ValueError):
637             config.getvalue("x")
638         assert config.getoption("x", 1) == 1
639 
640     def test_getconftest_pathlist(self, pytester: Pytester, tmp_path: Path) -> None:
641         somepath = tmp_path.joinpath("x", "y", "z")
642         p = tmp_path.joinpath("conftest.py")
643         p.write_text(f"mylist = {['.', str(somepath)]}", encoding="utf-8")
644         config = pytester.parseconfigure(p)
645         assert (
646             config._getconftest_pathlist("notexist", path=tmp_path, rootpath=tmp_path)
647             is None
648         )
649         pl = (
650             config._getconftest_pathlist("mylist", path=tmp_path, rootpath=tmp_path)
651             or []
652         )
653         print(pl)
654         assert len(pl) == 2
655         assert pl[0] == tmp_path
656         assert pl[1] == somepath
657 
658     @pytest.mark.parametrize("maybe_type", ["not passed", "None", '"string"'])
659     def test_addini(self, pytester: Pytester, maybe_type: str) -> None:
660         if maybe_type == "not passed":
661             type_string = ""
662         else:
663             type_string = f", {maybe_type}"
664 
665         pytester.makeconftest(
666             f"""
667             def pytest_addoption(parser):
668                 parser.addini("myname", "my new ini value"{type_string})
669         """
670         )
671         pytester.makeini(
672             """
673             [pytest]
674             myname=hello
675         """
676         )
677         config = pytester.parseconfig()
678         val = config.getini("myname")
679         assert val == "hello"
680         pytest.raises(ValueError, config.getini, "other")
681 
682     @pytest.mark.parametrize("config_type", ["ini", "pyproject"])
683     def test_addini_paths(self, pytester: Pytester, config_type: str) -> None:
684         pytester.makeconftest(
685             """
686             def pytest_addoption(parser):
687                 parser.addini("paths", "my new ini value", type="paths")
688                 parser.addini("abc", "abc value")
689         """
690         )
691         if config_type == "ini":
692             inipath = pytester.makeini(
693                 """
694                 [pytest]
695                 paths=hello world/sub.py
696             """
697             )
698         elif config_type == "pyproject":
699             inipath = pytester.makepyprojecttoml(
700                 """
701                 [tool.pytest.ini_options]
702                 paths=["hello", "world/sub.py"]
703             """
704             )
705         config = pytester.parseconfig()
706         values = config.getini("paths")
707         assert len(values) == 2
708         assert values[0] == inipath.parent.joinpath("hello")
709         assert values[1] == inipath.parent.joinpath("world/sub.py")
710         pytest.raises(ValueError, config.getini, "other")
711 
712     def make_conftest_for_args(self, pytester: Pytester) -> None:
713         pytester.makeconftest(
714             """
715             def pytest_addoption(parser):
716                 parser.addini("args", "new args", type="args")
717                 parser.addini("a2", "", "args", default="1 2 3".split())
718         """
719         )
720 
721     def test_addini_args_ini_files(self, pytester: Pytester) -> None:
722         self.make_conftest_for_args(pytester)
723         pytester.makeini(
724             """
725             [pytest]
726             args=123 "123 hello" "this"
727             """
728         )
729         self.check_config_args(pytester)
730 
731     def test_addini_args_pyproject_toml(self, pytester: Pytester) -> None:
732         self.make_conftest_for_args(pytester)
733         pytester.makepyprojecttoml(
734             """
735             [tool.pytest.ini_options]
736             args = ["123", "123 hello", "this"]
737             """
738         )
739         self.check_config_args(pytester)
740 
741     def check_config_args(self, pytester: Pytester) -> None:
742         config = pytester.parseconfig()
743         values = config.getini("args")
744         assert values == ["123", "123 hello", "this"]
745         values = config.getini("a2")
746         assert values == list("123")
747 
748     def make_conftest_for_linelist(self, pytester: Pytester) -> None:
749         pytester.makeconftest(
750             """
751             def pytest_addoption(parser):
752                 parser.addini("xy", "", type="linelist")
753                 parser.addini("a2", "", "linelist")
754         """
755         )
756 
757     def test_addini_linelist_ini_files(self, pytester: Pytester) -> None:
758         self.make_conftest_for_linelist(pytester)
759         pytester.makeini(
760             """
761             [pytest]
762             xy= 123 345
763                 second line
764         """
765         )
766         self.check_config_linelist(pytester)
767 
768     def test_addini_linelist_pprojecttoml(self, pytester: Pytester) -> None:
769         self.make_conftest_for_linelist(pytester)
770         pytester.makepyprojecttoml(
771             """
772             [tool.pytest.ini_options]
773             xy = ["123 345", "second line"]
774         """
775         )
776         self.check_config_linelist(pytester)
777 
778     def check_config_linelist(self, pytester: Pytester) -> None:
779         config = pytester.parseconfig()
780         values = config.getini("xy")
781         assert len(values) == 2
782         assert values == ["123 345", "second line"]
783         values = config.getini("a2")
784         assert values == []
785 
786     @pytest.mark.parametrize(
787         "str_val, bool_val", [("True", True), ("no", False), ("no-ini", True)]
788     )
789     def test_addini_bool(
790         self, pytester: Pytester, str_val: str, bool_val: bool
791     ) -> None:
792         pytester.makeconftest(
793             """
794             def pytest_addoption(parser):
795                 parser.addini("strip", "", type="bool", default=True)
796         """
797         )
798         if str_val != "no-ini":
799             pytester.makeini(
800                 """
801                 [pytest]
802                 strip=%s
803             """
804                 % str_val
805             )
806         config = pytester.parseconfig()
807         assert config.getini("strip") is bool_val
808 
809     def test_addinivalue_line_existing(self, pytester: Pytester) -> None:
810         pytester.makeconftest(
811             """
812             def pytest_addoption(parser):
813                 parser.addini("xy", "", type="linelist")
814         """
815         )
816         pytester.makeini(
817             """
818             [pytest]
819             xy= 123
820         """
821         )
822         config = pytester.parseconfig()
823         values = config.getini("xy")
824         assert len(values) == 1
825         assert values == ["123"]
826         config.addinivalue_line("xy", "456")
827         values = config.getini("xy")
828         assert len(values) == 2
829         assert values == ["123", "456"]
830 
831     def test_addinivalue_line_new(self, pytester: Pytester) -> None:
832         pytester.makeconftest(
833             """
834             def pytest_addoption(parser):
835                 parser.addini("xy", "", type="linelist")
836         """
837         )
838         config = pytester.parseconfig()
839         assert not config.getini("xy")
840         config.addinivalue_line("xy", "456")
841         values = config.getini("xy")
842         assert len(values) == 1
843         assert values == ["456"]
844         config.addinivalue_line("xy", "123")
845         values = config.getini("xy")
846         assert len(values) == 2
847         assert values == ["456", "123"]
848 
849     def test_confcutdir_check_isdir(self, pytester: Pytester) -> None:
850         """Give an error if --confcutdir is not a valid directory (#2078)"""
851         exp_match = r"^--confcutdir must be a directory, given: "
852         with pytest.raises(pytest.UsageError, match=exp_match):
853             pytester.parseconfig("--confcutdir", pytester.path.joinpath("file"))
854         with pytest.raises(pytest.UsageError, match=exp_match):
855             pytester.parseconfig("--confcutdir", pytester.path.joinpath("nonexistent"))
856 
857         p = pytester.mkdir("dir")
858         config = pytester.parseconfig("--confcutdir", p)
859         assert config.getoption("confcutdir") == str(p)
860 
861     @pytest.mark.parametrize(
862         "names, expected",
863         [
864             # dist-info based distributions root are files as will be put in PYTHONPATH
865             (["bar.py"], ["bar"]),
866             (["foo/bar.py"], ["bar"]),
867             (["foo/bar.pyc"], []),
868             (["foo/__init__.py"], ["foo"]),
869             (["bar/__init__.py", "xz.py"], ["bar", "xz"]),
870             (["setup.py"], []),
871             # egg based distributions root contain the files from the dist root
872             (["src/bar/__init__.py"], ["bar"]),
873             (["src/bar/__init__.py", "setup.py"], ["bar"]),
874             (["source/python/bar/__init__.py", "setup.py"], ["bar"]),
875             # editable installation finder modules
876             (["__editable___xyz_finder.py"], []),
877             (["bar/__init__.py", "__editable___xyz_finder.py"], ["bar"]),
878         ],
879     )
880     def test_iter_rewritable_modules(self, names, expected) -> None:
881         assert list(_iter_rewritable_modules(names)) == expected
882 
883 
884 class TestConfigFromdictargs:
885     def test_basic_behavior(self, _sys_snapshot) -> None:
886         option_dict = {"verbose": 444, "foo": "bar", "capture": "no"}
887         args = ["a", "b"]
888 
889         config = Config.fromdictargs(option_dict, args)
890         with pytest.raises(AssertionError):
891             config.parse(["should refuse to parse again"])
892         assert config.option.verbose == 444
893         assert config.option.foo == "bar"
894         assert config.option.capture == "no"
895         assert config.args == args
896 
897     def test_invocation_params_args(self, _sys_snapshot) -> None:
898         """Show that fromdictargs can handle args in their "orig" format"""
899         option_dict: Dict[str, object] = {}
900         args = ["-vvvv", "-s", "a", "b"]
901 
902         config = Config.fromdictargs(option_dict, args)
903         assert config.args == ["a", "b"]
904         assert config.invocation_params.args == tuple(args)
905         assert config.option.verbose == 4
906         assert config.option.capture == "no"
907 
908     def test_inifilename(self, tmp_path: Path) -> None:
909         d1 = tmp_path.joinpath("foo")
910         d1.mkdir()
911         p1 = d1.joinpath("bar.ini")
912         p1.touch()
913         p1.write_text(
914             textwrap.dedent(
915                 """\
916                 [pytest]
917                 name = value
918                 """
919             ),
920             encoding="utf-8",
921         )
922 
923         inifilename = "../../foo/bar.ini"
924         option_dict = {"inifilename": inifilename, "capture": "no"}
925 
926         cwd = tmp_path.joinpath("a/b")
927         cwd.mkdir(parents=True)
928         p2 = cwd.joinpath("pytest.ini")
929         p2.touch()
930         p2.write_text(
931             textwrap.dedent(
932                 """\
933                 [pytest]
934                 name = wrong-value
935                 should_not_be_set = true
936                 """
937             ),
938             encoding="utf-8",
939         )
940         with MonkeyPatch.context() as mp:
941             mp.chdir(cwd)
942             config = Config.fromdictargs(option_dict, ())
943             inipath = absolutepath(inifilename)
944 
945         assert config.args == [str(cwd)]
946         assert config.option.inifilename == inifilename
947         assert config.option.capture == "no"
948 
949         # this indicates this is the file used for getting configuration values
950         assert config.inipath == inipath
951         assert config.inicfg.get("name") == "value"
952         assert config.inicfg.get("should_not_be_set") is None
953 
954 
955 def test_options_on_small_file_do_not_blow_up(pytester: Pytester) -> None:
956     def runfiletest(opts: Sequence[str]) -> None:
957         reprec = pytester.inline_run(*opts)
958         passed, skipped, failed = reprec.countoutcomes()
959         assert failed == 2
960         assert skipped == passed == 0
961 
962     path = str(
963         pytester.makepyfile(
964             """
965         def test_f1(): assert 0
966         def test_f2(): assert 0
967     """
968         )
969     )
970 
971     runfiletest([path])
972     runfiletest(["-l", path])
973     runfiletest(["-s", path])
974     runfiletest(["--tb=no", path])
975     runfiletest(["--tb=short", path])
976     runfiletest(["--tb=long", path])
977     runfiletest(["--fulltrace", path])
978     runfiletest(["--traceconfig", path])
979     runfiletest(["-v", path])
980     runfiletest(["-v", "-v", path])
981 
982 
983 def test_preparse_ordering_with_setuptools(
984     pytester: Pytester, monkeypatch: MonkeyPatch
985 ) -> None:
986     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
987 
988     class EntryPoint:
989         name = "mytestplugin"
990         group = "pytest11"
991 
992         def load(self):
993             class PseudoPlugin:
994                 x = 42
995 
996             return PseudoPlugin()
997 
998     class Dist:
999         files = ()
1000         metadata = {"name": "foo"}
1001         entry_points = (EntryPoint(),)
1002 
1003     def my_dists():
1004         return (Dist,)
1005 
1006     monkeypatch.setattr(importlib.metadata, "distributions", my_dists)
1007     pytester.makeconftest(
1008         """
1009         pytest_plugins = "mytestplugin",
1010     """
1011     )
1012     monkeypatch.setenv("PYTEST_PLUGINS", "mytestplugin")
1013     config = pytester.parseconfig()
1014     plugin = config.pluginmanager.getplugin("mytestplugin")
1015     assert plugin.x == 42
1016 
1017 
1018 def test_setuptools_importerror_issue1479(
1019     pytester: Pytester, monkeypatch: MonkeyPatch
1020 ) -> None:
1021     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
1022 
1023     class DummyEntryPoint:
1024         name = "mytestplugin"
1025         group = "pytest11"
1026 
1027         def load(self):
1028             raise ImportError("Don't hide me!")
1029 
1030     class Distribution:
1031         version = "1.0"
1032         files = ("foo.txt",)
1033         metadata = {"name": "foo"}
1034         entry_points = (DummyEntryPoint(),)
1035 
1036     def distributions():
1037         return (Distribution(),)
1038 
1039     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1040     with pytest.raises(ImportError):
1041         pytester.parseconfig()
1042 
1043 
1044 def test_importlib_metadata_broken_distribution(
1045     pytester: Pytester, monkeypatch: MonkeyPatch
1046 ) -> None:
1047     """Integration test for broken distributions with 'files' metadata being None (#5389)"""
1048     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
1049 
1050     class DummyEntryPoint:
1051         name = "mytestplugin"
1052         group = "pytest11"
1053 
1054         def load(self):
1055             return object()
1056 
1057     class Distribution:
1058         version = "1.0"
1059         files = None
1060         metadata = {"name": "foo"}
1061         entry_points = (DummyEntryPoint(),)
1062 
1063     def distributions():
1064         return (Distribution(),)
1065 
1066     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1067     pytester.parseconfig()
1068 
1069 
1070 @pytest.mark.parametrize("block_it", [True, False])
1071 def test_plugin_preparse_prevents_setuptools_loading(
1072     pytester: Pytester, monkeypatch: MonkeyPatch, block_it: bool
1073 ) -> None:
1074     monkeypatch.delenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", raising=False)
1075 
1076     plugin_module_placeholder = object()
1077 
1078     class DummyEntryPoint:
1079         name = "mytestplugin"
1080         group = "pytest11"
1081 
1082         def load(self):
1083             return plugin_module_placeholder
1084 
1085     class Distribution:
1086         version = "1.0"
1087         files = ("foo.txt",)
1088         metadata = {"name": "foo"}
1089         entry_points = (DummyEntryPoint(),)
1090 
1091     def distributions():
1092         return (Distribution(),)
1093 
1094     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1095     args = ("-p", "no:mytestplugin") if block_it else ()
1096     config = pytester.parseconfig(*args)
1097     config.pluginmanager.import_plugin("mytestplugin")
1098     if block_it:
1099         assert "mytestplugin" not in sys.modules
1100         assert config.pluginmanager.get_plugin("mytestplugin") is None
1101     else:
1102         assert (
1103             config.pluginmanager.get_plugin("mytestplugin") is plugin_module_placeholder
1104         )
1105 
1106 
1107 @pytest.mark.parametrize(
1108     "parse_args,should_load", [(("-p", "mytestplugin"), True), ((), False)]
1109 )
1110 def test_disable_plugin_autoload(
1111     pytester: Pytester,
1112     monkeypatch: MonkeyPatch,
1113     parse_args: Union[Tuple[str, str], Tuple[()]],
1114     should_load: bool,
1115 ) -> None:
1116     class DummyEntryPoint:
1117         project_name = name = "mytestplugin"
1118         group = "pytest11"
1119         version = "1.0"
1120 
1121         def load(self):
1122             return sys.modules[self.name]
1123 
1124     class Distribution:
1125         metadata = {"name": "foo"}
1126         entry_points = (DummyEntryPoint(),)
1127         files = ()
1128 
1129     class PseudoPlugin:
1130         x = 42
1131 
1132         attrs_used = []
1133 
1134         def __getattr__(self, name):
1135             assert name == "__loader__"
1136             self.attrs_used.append(name)
1137             return object()
1138 
1139     def distributions():
1140         return (Distribution(),)
1141 
1142     monkeypatch.setenv("PYTEST_DISABLE_PLUGIN_AUTOLOAD", "1")
1143     monkeypatch.setattr(importlib.metadata, "distributions", distributions)
1144     monkeypatch.setitem(sys.modules, "mytestplugin", PseudoPlugin())  # type: ignore[misc]
1145     config = pytester.parseconfig(*parse_args)
1146     has_loaded = config.pluginmanager.get_plugin("mytestplugin") is not None
1147     assert has_loaded == should_load
1148     if should_load:
1149         assert PseudoPlugin.attrs_used == ["__loader__"]
1150     else:
1151         assert PseudoPlugin.attrs_used == []
1152 
1153 
1154 def test_plugin_loading_order(pytester: Pytester) -> None:
1155     """Test order of plugin loading with `-p`."""
1156     p1 = pytester.makepyfile(
1157         """
1158         def test_terminal_plugin(request):
1159             import myplugin
1160             assert myplugin.terminal_plugin == [False, True]
1161         """,
1162         **{
1163             "myplugin": """
1164             terminal_plugin = []
1165 
1166             def pytest_configure(config):
1167                 terminal_plugin.append(bool(config.pluginmanager.get_plugin("terminalreporter")))
1168 
1169             def pytest_sessionstart(session):
1170                 config = session.config
1171                 terminal_plugin.append(bool(config.pluginmanager.get_plugin("terminalreporter")))
1172             """
1173         },
1174     )
1175     pytester.syspathinsert()
1176     result = pytester.runpytest("-p", "myplugin", str(p1))
1177     assert result.ret == 0
1178 
1179 
1180 def test_cmdline_processargs_simple(pytester: Pytester) -> None:
1181     pytester.makeconftest(
1182         """
1183         def pytest_cmdline_preparse(args):
1184             args.append("-h")
1185     """
1186     )
1187     result = pytester.runpytest("-Wignore::pytest.PytestRemovedIn8Warning")
1188     result.stdout.fnmatch_lines(["*pytest*", "*-h*"])
1189 
1190 
1191 def test_invalid_options_show_extra_information(pytester: Pytester) -> None:
1192     """Display extra information when pytest exits due to unrecognized
1193     options in the command-line."""
1194     pytester.makeini(
1195         """
1196         [pytest]
1197         addopts = --invalid-option
1198     """
1199     )
1200     result = pytester.runpytest()
1201     result.stderr.fnmatch_lines(
1202         [
1203             "*error: unrecognized arguments: --invalid-option*",
1204             "*  inifile: %s*" % pytester.path.joinpath("tox.ini"),
1205             "*  rootdir: %s*" % pytester.path,
1206         ]
1207     )
1208 
1209 
1210 @pytest.mark.parametrize(
1211     "args",
1212     [
1213         ["dir1", "dir2", "-v"],
1214         ["dir1", "-v", "dir2"],
1215         ["dir2", "-v", "dir1"],
1216         ["-v", "dir2", "dir1"],
1217     ],
1218 )
1219 def test_consider_args_after_options_for_rootdir(
1220     pytester: Pytester, args: List[str]
1221 ) -> None:
1222     """
1223     Consider all arguments in the command-line for rootdir
1224     discovery, even if they happen to occur after an option. #949
1225     """
1226     # replace "dir1" and "dir2" from "args" into their real directory
1227     root = pytester.mkdir("myroot")
1228     d1 = root.joinpath("dir1")
1229     d1.mkdir()
1230     d2 = root.joinpath("dir2")
1231     d2.mkdir()
1232     for i, arg in enumerate(args):
1233         if arg == "dir1":
1234             args[i] = str(d1)
1235         elif arg == "dir2":
1236             args[i] = str(d2)
1237     with MonkeyPatch.context() as mp:
1238         mp.chdir(root)
1239         result = pytester.runpytest(*args)
1240     result.stdout.fnmatch_lines(["*rootdir: *myroot"])
1241 
1242 
1243 def test_toolongargs_issue224(pytester: Pytester) -> None:
1244     result = pytester.runpytest("-m", "hello" * 500)
1245     assert result.ret == ExitCode.NO_TESTS_COLLECTED
1246 
1247 
1248 def test_config_in_subdirectory_colon_command_line_issue2148(
1249     pytester: Pytester,
1250 ) -> None:
1251     conftest_source = """
1252         def pytest_addoption(parser):
1253             parser.addini('foo', 'foo')
1254     """
1255 
1256     pytester.makefile(
1257         ".ini",
1258         **{"pytest": "[pytest]\nfoo = root", "subdir/pytest": "[pytest]\nfoo = subdir"},
1259     )
1260 
1261     pytester.makepyfile(
1262         **{
1263             "conftest": conftest_source,
1264             "subdir/conftest": conftest_source,
1265             "subdir/test_foo": """\
1266             def test_foo(pytestconfig):
1267                 assert pytestconfig.getini('foo') == 'subdir'
1268             """,
1269         }
1270     )
1271 
1272     result = pytester.runpytest("subdir/test_foo.py::test_foo")
1273     assert result.ret == 0
1274 
1275 
1276 def test_notify_exception(pytester: Pytester, capfd) -> None:
1277     config = pytester.parseconfig()
1278     with pytest.raises(ValueError) as excinfo:
1279         raise ValueError(1)
1280     config.notify_exception(excinfo, config.option)
1281     _, err = capfd.readouterr()
1282     assert "ValueError" in err
1283 
1284     class A:
1285         def pytest_internalerror(self):
1286             return True
1287 
1288     config.pluginmanager.register(A())
1289     config.notify_exception(excinfo, config.option)
1290     _, err = capfd.readouterr()
1291     assert not err
1292 
1293     config = pytester.parseconfig("-p", "no:terminal")
1294     with pytest.raises(ValueError) as excinfo:
1295         raise ValueError(1)
1296     config.notify_exception(excinfo, config.option)
1297     _, err = capfd.readouterr()
1298     assert "ValueError" in err
1299 
1300 
1301 def test_no_terminal_discovery_error(pytester: Pytester) -> None:
1302     pytester.makepyfile("raise TypeError('oops!')")
1303     result = pytester.runpytest("-p", "no:terminal", "--collect-only")
1304     assert result.ret == ExitCode.INTERRUPTED
1305 
1306 
1307 def test_load_initial_conftest_last_ordering(_config_for_test):
1308     pm = _config_for_test.pluginmanager
1309 
1310     class My:
1311         def pytest_load_initial_conftests(self):
1312             pass
1313 
1314     m = My()
1315     pm.register(m)
1316     hc = pm.hook.pytest_load_initial_conftests
1317     hookimpls = [
1318         (
1319             hookimpl.function.__module__,
1320             "wrapper" if hookimpl.hookwrapper else "nonwrapper",
1321         )
1322         for hookimpl in hc.get_hookimpls()
1323     ]
1324     assert hookimpls == [
1325         ("_pytest.config", "nonwrapper"),
1326         (m.__module__, "nonwrapper"),
1327         ("_pytest.legacypath", "nonwrapper"),
1328         ("_pytest.python_path", "nonwrapper"),
1329         ("_pytest.capture", "wrapper"),
1330         ("_pytest.warnings", "wrapper"),
1331     ]
1332 
1333 
1334 def test_get_plugin_specs_as_list() -> None:
1335     def exp_match(val: object) -> str:
1336         return (
1337             "Plugins may be specified as a sequence or a ','-separated string of plugin names. Got: %s"
1338             % re.escape(repr(val))
1339         )
1340 
1341     with pytest.raises(pytest.UsageError, match=exp_match({"foo"})):
1342         _get_plugin_specs_as_list({"foo"})  # type: ignore[arg-type]
1343     with pytest.raises(pytest.UsageError, match=exp_match({})):
1344         _get_plugin_specs_as_list(dict())  # type: ignore[arg-type]
1345 
1346     assert _get_plugin_specs_as_list(None) == []
1347     assert _get_plugin_specs_as_list("") == []
1348     assert _get_plugin_specs_as_list("foo") == ["foo"]
1349     assert _get_plugin_specs_as_list("foo,bar") == ["foo", "bar"]
1350     assert _get_plugin_specs_as_list(["foo", "bar"]) == ["foo", "bar"]
1351     assert _get_plugin_specs_as_list(("foo", "bar")) == ["foo", "bar"]
1352 
1353 
1354 def test_collect_pytest_prefix_bug_integration(pytester: Pytester) -> None:
1355     """Integration test for issue #3775"""
1356     p = pytester.copy_example("config/collect_pytest_prefix")
1357     result = pytester.runpytest(p)
1358     result.stdout.fnmatch_lines(["* 1 passed *"])
1359 
1360 
1361 def test_collect_pytest_prefix_bug(pytestconfig):
1362     """Ensure we collect only actual functions from conftest files (#3775)"""
1363 
1364     class Dummy:
1365         class pytest_something:
1366             pass
1367 
1368     pm = pytestconfig.pluginmanager
1369     assert pm.parse_hookimpl_opts(Dummy(), "pytest_something") is None
1370 
1371 
1372 class TestRootdir:
1373     def test_simple_noini(self, tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
1374         assert get_common_ancestor([tmp_path]) == tmp_path
1375         a = tmp_path / "a"
1376         a.mkdir()
1377         assert get_common_ancestor([a, tmp_path]) == tmp_path
1378         assert get_common_ancestor([tmp_path, a]) == tmp_path
1379         monkeypatch.chdir(tmp_path)
1380         assert get_common_ancestor([]) == tmp_path
1381         no_path = tmp_path / "does-not-exist"
1382         assert get_common_ancestor([no_path]) == tmp_path
1383         assert get_common_ancestor([no_path / "a"]) == tmp_path
1384 
1385     @pytest.mark.parametrize(
1386         "name, contents",
1387         [
1388             pytest.param("pytest.ini", "[pytest]\nx=10", id="pytest.ini"),
1389             pytest.param(
1390                 "pyproject.toml", "[tool.pytest.ini_options]\nx=10", id="pyproject.toml"
1391             ),
1392             pytest.param("tox.ini", "[pytest]\nx=10", id="tox.ini"),
1393             pytest.param("setup.cfg", "[tool:pytest]\nx=10", id="setup.cfg"),
1394         ],
1395     )
1396     def test_with_ini(self, tmp_path: Path, name: str, contents: str) -> None:
1397         inipath = tmp_path / name
1398         inipath.write_text(contents, encoding="utf-8")
1399 
1400         a = tmp_path / "a"
1401         a.mkdir()
1402         b = a / "b"
1403         b.mkdir()
1404         for args in ([str(tmp_path)], [str(a)], [str(b)]):
1405             rootpath, parsed_inipath, _ = determine_setup(None, args)
1406             assert rootpath == tmp_path
1407             assert parsed_inipath == inipath
1408         rootpath, parsed_inipath, ini_config = determine_setup(None, [str(b), str(a)])
1409         assert rootpath == tmp_path
1410         assert parsed_inipath == inipath
1411         assert ini_config == {"x": "10"}
1412 
1413     @pytest.mark.parametrize("name", ["setup.cfg", "tox.ini"])
1414     def test_pytestini_overrides_empty_other(self, tmp_path: Path, name: str) -> None:
1415         inipath = tmp_path / "pytest.ini"
1416         inipath.touch()
1417         a = tmp_path / "a"
1418         a.mkdir()
1419         (a / name).touch()
1420         rootpath, parsed_inipath, _ = determine_setup(None, [str(a)])
1421         assert rootpath == tmp_path
1422         assert parsed_inipath == inipath
1423 
1424     def test_setuppy_fallback(self, tmp_path: Path) -> None:
1425         a = tmp_path / "a"
1426         a.mkdir()
1427         (a / "setup.cfg").touch()
1428         (tmp_path / "setup.py").touch()
1429         rootpath, inipath, inicfg = determine_setup(None, [str(a)])
1430         assert rootpath == tmp_path
1431         assert inipath is None
1432         assert inicfg == {}
1433 
1434     def test_nothing(self, tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
1435         monkeypatch.chdir(tmp_path)
1436         rootpath, inipath, inicfg = determine_setup(None, [str(tmp_path)])
1437         assert rootpath == tmp_path
1438         assert inipath is None
1439         assert inicfg == {}
1440 
1441     @pytest.mark.parametrize(
1442         "name, contents",
1443         [
1444             # pytest.param("pytest.ini", "[pytest]\nx=10", id="pytest.ini"),
1445             pytest.param(
1446                 "pyproject.toml", "[tool.pytest.ini_options]\nx=10", id="pyproject.toml"
1447             ),
1448             # pytest.param("tox.ini", "[pytest]\nx=10", id="tox.ini"),
1449             # pytest.param("setup.cfg", "[tool:pytest]\nx=10", id="setup.cfg"),
1450         ],
1451     )
1452     def test_with_specific_inifile(
1453         self, tmp_path: Path, name: str, contents: str
1454     ) -> None:
1455         p = tmp_path / name
1456         p.touch()
1457         p.write_text(contents, encoding="utf-8")
1458         rootpath, inipath, ini_config = determine_setup(str(p), [str(tmp_path)])
1459         assert rootpath == tmp_path
1460         assert inipath == p
1461         assert ini_config == {"x": "10"}
1462 
1463     def test_explicit_config_file_sets_rootdir(
1464         self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
1465     ) -> None:
1466         tests_dir = tmp_path / "tests"
1467         tests_dir.mkdir()
1468 
1469         monkeypatch.chdir(tmp_path)
1470 
1471         # No config file is explicitly given: rootdir is determined to be cwd.
1472         rootpath, found_inipath, *_ = determine_setup(None, [str(tests_dir)])
1473         assert rootpath == tmp_path
1474         assert found_inipath is None
1475 
1476         # Config file is explicitly given: rootdir is determined to be inifile's directory.
1477         inipath = tmp_path / "pytest.ini"
1478         inipath.touch()
1479         rootpath, found_inipath, *_ = determine_setup(str(inipath), [str(tests_dir)])
1480         assert rootpath == tmp_path
1481         assert found_inipath == inipath
1482 
1483     def test_with_arg_outside_cwd_without_inifile(
1484         self, tmp_path: Path, monkeypatch: MonkeyPatch
1485     ) -> None:
1486         monkeypatch.chdir(tmp_path)
1487         a = tmp_path / "a"
1488         a.mkdir()
1489         b = tmp_path / "b"
1490         b.mkdir()
1491         rootpath, inifile, _ = determine_setup(None, [str(a), str(b)])
1492         assert rootpath == tmp_path
1493         assert inifile is None
1494 
1495     def test_with_arg_outside_cwd_with_inifile(self, tmp_path: Path) -> None:
1496         a = tmp_path / "a"
1497         a.mkdir()
1498         b = tmp_path / "b"
1499         b.mkdir()
1500         inipath = a / "pytest.ini"
1501         inipath.touch()
1502         rootpath, parsed_inipath, _ = determine_setup(None, [str(a), str(b)])
1503         assert rootpath == a
1504         assert inipath == parsed_inipath
1505 
1506     @pytest.mark.parametrize("dirs", ([], ["does-not-exist"], ["a/does-not-exist"]))
1507     def test_with_non_dir_arg(
1508         self, dirs: Sequence[str], tmp_path: Path, monkeypatch: MonkeyPatch
1509     ) -> None:
1510         monkeypatch.chdir(tmp_path)
1511         rootpath, inipath, _ = determine_setup(None, dirs)
1512         assert rootpath == tmp_path
1513         assert inipath is None
1514 
1515     def test_with_existing_file_in_subdir(
1516         self, tmp_path: Path, monkeypatch: MonkeyPatch
1517     ) -> None:
1518         a = tmp_path / "a"
1519         a.mkdir()
1520         (a / "exists").touch()
1521         monkeypatch.chdir(tmp_path)
1522         rootpath, inipath, _ = determine_setup(None, ["a/exist"])
1523         assert rootpath == tmp_path
1524         assert inipath is None
1525 
1526     def test_with_config_also_in_parent_directory(
1527         self, tmp_path: Path, monkeypatch: MonkeyPatch
1528     ) -> None:
1529         """Regression test for #7807."""
1530         (tmp_path / "setup.cfg").write_text("[tool:pytest]\n", "utf-8")
1531         (tmp_path / "myproject").mkdir()
1532         (tmp_path / "myproject" / "setup.cfg").write_text("[tool:pytest]\n", "utf-8")
1533         (tmp_path / "myproject" / "tests").mkdir()
1534         monkeypatch.chdir(tmp_path / "myproject")
1535 
1536         rootpath, inipath, _ = determine_setup(None, ["tests/"])
1537 
1538         assert rootpath == tmp_path / "myproject"
1539         assert inipath == tmp_path / "myproject" / "setup.cfg"
1540 
1541 
1542 class TestOverrideIniArgs:
1543     @pytest.mark.parametrize("name", "setup.cfg tox.ini pytest.ini".split())
1544     def test_override_ini_names(self, pytester: Pytester, name: str) -> None:
1545         section = "[pytest]" if name != "setup.cfg" else "[tool:pytest]"
1546         pytester.path.joinpath(name).write_text(
1547             textwrap.dedent(
1548                 """
1549             {section}
1550             custom = 1.0""".format(
1551                     section=section
1552                 )
1553             ),
1554             encoding="utf-8",
1555         )
1556         pytester.makeconftest(
1557             """
1558             def pytest_addoption(parser):
1559                 parser.addini("custom", "")"""
1560         )
1561         pytester.makepyfile(
1562             """
1563             def test_pass(pytestconfig):
1564                 ini_val = pytestconfig.getini("custom")
1565                 print('\\ncustom_option:%s\\n' % ini_val)"""
1566         )
1567 
1568         result = pytester.runpytest("--override-ini", "custom=2.0", "-s")
1569         assert result.ret == 0
1570         result.stdout.fnmatch_lines(["custom_option:2.0"])
1571 
1572         result = pytester.runpytest(
1573             "--override-ini", "custom=2.0", "--override-ini=custom=3.0", "-s"
1574         )
1575         assert result.ret == 0
1576         result.stdout.fnmatch_lines(["custom_option:3.0"])
1577 
1578     def test_override_ini_paths(self, pytester: Pytester) -> None:
1579         pytester.makeconftest(
1580             """
1581             def pytest_addoption(parser):
1582                 parser.addini("paths", "my new ini value", type="paths")"""
1583         )
1584         pytester.makeini(
1585             """
1586             [pytest]
1587             paths=blah.py"""
1588         )
1589         pytester.makepyfile(
1590             r"""
1591             def test_overriden(pytestconfig):
1592                 config_paths = pytestconfig.getini("paths")
1593                 print(config_paths)
1594                 for cpf in config_paths:
1595                     print('\nuser_path:%s' % cpf.name)
1596             """
1597         )
1598         result = pytester.runpytest(
1599             "--override-ini", "paths=foo/bar1.py foo/bar2.py", "-s"
1600         )
1601         result.stdout.fnmatch_lines(["user_path:bar1.py", "user_path:bar2.py"])
1602 
1603     def test_override_multiple_and_default(self, pytester: Pytester) -> None:
1604         pytester.makeconftest(
1605             """
1606             def pytest_addoption(parser):
1607                 addini = parser.addini
1608                 addini("custom_option_1", "", default="o1")
1609                 addini("custom_option_2", "", default="o2")
1610                 addini("custom_option_3", "", default=False, type="bool")
1611                 addini("custom_option_4", "", default=True, type="bool")"""
1612         )
1613         pytester.makeini(
1614             """
1615             [pytest]
1616             custom_option_1=custom_option_1
1617             custom_option_2=custom_option_2
1618         """
1619         )
1620         pytester.makepyfile(
1621             """
1622             def test_multiple_options(pytestconfig):
1623                 prefix = "custom_option"
1624                 for x in range(1, 5):
1625                     ini_value=pytestconfig.getini("%s_%d" % (prefix, x))
1626                     print('\\nini%d:%s' % (x, ini_value))
1627         """
1628         )
1629         result = pytester.runpytest(
1630             "--override-ini",
1631             "custom_option_1=fulldir=/tmp/user1",
1632             "-o",
1633             "custom_option_2=url=/tmp/user2?a=b&d=e",
1634             "-o",
1635             "custom_option_3=True",
1636             "-o",
1637             "custom_option_4=no",
1638             "-s",
1639         )
1640         result.stdout.fnmatch_lines(
1641             [
1642                 "ini1:fulldir=/tmp/user1",
1643                 "ini2:url=/tmp/user2?a=b&d=e",
1644                 "ini3:True",
1645                 "ini4:False",
1646             ]
1647         )
1648 
1649     def test_override_ini_usage_error_bad_style(self, pytester: Pytester) -> None:
1650         pytester.makeini(
1651             """
1652             [pytest]
1653             xdist_strict=False
1654         """
1655         )
1656         result = pytester.runpytest("--override-ini", "xdist_strict", "True")
1657         result.stderr.fnmatch_lines(
1658             [
1659                 "ERROR: -o/--override-ini expects option=value style (got: 'xdist_strict').",
1660             ]
1661         )
1662 
1663     @pytest.mark.parametrize("with_ini", [True, False])
1664     def test_override_ini_handled_asap(
1665         self, pytester: Pytester, with_ini: bool
1666     ) -> None:
1667         """-o should be handled as soon as possible and always override what's in ini files (#2238)"""
1668         if with_ini:
1669             pytester.makeini(
1670                 """
1671                 [pytest]
1672                 python_files=test_*.py
1673             """
1674             )
1675         pytester.makepyfile(
1676             unittest_ini_handle="""
1677             def test():
1678                 pass
1679         """
1680         )
1681         result = pytester.runpytest("--override-ini", "python_files=unittest_*.py")
1682         result.stdout.fnmatch_lines(["*1 passed in*"])
1683 
1684     def test_addopts_before_initini(
1685         self, monkeypatch: MonkeyPatch, _config_for_test, _sys_snapshot
1686     ) -> None:
1687         cache_dir = ".custom_cache"
1688         monkeypatch.setenv("PYTEST_ADDOPTS", "-o cache_dir=%s" % cache_dir)
1689         config = _config_for_test
1690         config._preparse([], addopts=True)
1691         assert config._override_ini == ["cache_dir=%s" % cache_dir]
1692 
1693     def test_addopts_from_env_not_concatenated(
1694         self, monkeypatch: MonkeyPatch, _config_for_test
1695     ) -> None:
1696         """PYTEST_ADDOPTS should not take values from normal args (#4265)."""
1697         monkeypatch.setenv("PYTEST_ADDOPTS", "-o")
1698         config = _config_for_test
1699         with pytest.raises(UsageError) as excinfo:
1700             config._preparse(["cache_dir=ignored"], addopts=True)
1701         assert (
1702             "error: argument -o/--override-ini: expected one argument (via PYTEST_ADDOPTS)"
1703             in excinfo.value.args[0]
1704         )
1705 
1706     def test_addopts_from_ini_not_concatenated(self, pytester: Pytester) -> None:
1707         """`addopts` from ini should not take values from normal args (#4265)."""
1708         pytester.makeini(
1709             """
1710             [pytest]
1711             addopts=-o
1712         """
1713         )
1714         result = pytester.runpytest("cache_dir=ignored")
1715         result.stderr.fnmatch_lines(
1716             [
1717                 "%s: error: argument -o/--override-ini: expected one argument (via addopts config)"
1718                 % (pytester._request.config._parser.optparser.prog,)
1719             ]
1720         )
1721         assert result.ret == _pytest.config.ExitCode.USAGE_ERROR
1722 
1723     def test_override_ini_does_not_contain_paths(
1724         self, _config_for_test, _sys_snapshot
1725     ) -> None:
1726         """Check that -o no longer swallows all options after it (#3103)"""
1727         config = _config_for_test
1728         config._preparse(["-o", "cache_dir=/cache", "/some/test/path"])
1729         assert config._override_ini == ["cache_dir=/cache"]
1730 
1731     def test_multiple_override_ini_options(self, pytester: Pytester) -> None:
1732         """Ensure a file path following a '-o' option does not generate an error (#3103)"""
1733         pytester.makepyfile(
1734             **{
1735                 "conftest.py": """
1736                 def pytest_addoption(parser):
1737                     parser.addini('foo', default=None, help='some option')
1738                     parser.addini('bar', default=None, help='some option')
1739             """,
1740                 "test_foo.py": """
1741                 def test(pytestconfig):
1742                     assert pytestconfig.getini('foo') == '1'
1743                     assert pytestconfig.getini('bar') == '0'
1744             """,
1745                 "test_bar.py": """
1746                 def test():
1747                     assert False
1748             """,
1749             }
1750         )
1751         result = pytester.runpytest("-o", "foo=1", "-o", "bar=0", "test_foo.py")
1752         assert "ERROR:" not in result.stderr.str()
1753         result.stdout.fnmatch_lines(["collected 1 item", "*= 1 passed in *="])
1754 
1755 
1756 def test_help_via_addopts(pytester: Pytester) -> None:
1757     pytester.makeini(
1758         """
1759         [pytest]
1760         addopts = --unknown-option-should-allow-for-help --help
1761     """
1762     )
1763     result = pytester.runpytest()
1764     assert result.ret == 0
1765     result.stdout.fnmatch_lines(
1766         [
1767             "usage: *",
1768             "positional arguments:",
1769             # Displays full/default help.
1770             "to see available markers type: pytest --markers",
1771         ]
1772     )
1773 
1774 
1775 def test_help_and_version_after_argument_error(pytester: Pytester) -> None:
1776     pytester.makeconftest(
1777         """
1778         def validate(arg):
1779             raise argparse.ArgumentTypeError("argerror")
1780 
1781         def pytest_addoption(parser):
1782             group = parser.getgroup('cov')
1783             group.addoption(
1784                 "--invalid-option-should-allow-for-help",
1785                 type=validate,
1786             )
1787         """
1788     )
1789     pytester.makeini(
1790         """
1791         [pytest]
1792         addopts = --invalid-option-should-allow-for-help
1793     """
1794     )
1795     result = pytester.runpytest("--help")
1796     result.stdout.fnmatch_lines(
1797         [
1798             "usage: *",
1799             "positional arguments:",
1800             "NOTE: displaying only minimal help due to UsageError.",
1801         ]
1802     )
1803     result.stderr.fnmatch_lines(
1804         [
1805             "ERROR: usage: *",
1806             "%s: error: argument --invalid-option-should-allow-for-help: expected one argument"
1807             % (pytester._request.config._parser.optparser.prog,),
1808         ]
1809     )
1810     # Does not display full/default help.
1811     assert "to see available markers type: pytest --markers" not in result.stdout.lines
1812     assert result.ret == ExitCode.USAGE_ERROR
1813 
1814     result = pytester.runpytest("--version")
1815     result.stdout.fnmatch_lines([f"pytest {pytest.__version__}"])
1816     assert result.ret == ExitCode.USAGE_ERROR
1817 
1818 
1819 def test_help_formatter_uses_py_get_terminal_width(monkeypatch: MonkeyPatch) -> None:
1820     from _pytest.config.argparsing import DropShorterLongHelpFormatter
1821 
1822     monkeypatch.setenv("COLUMNS", "90")
1823     formatter = DropShorterLongHelpFormatter("prog")
1824     assert formatter._width == 90
1825 
1826     monkeypatch.setattr("_pytest._io.get_terminal_width", lambda: 160)
1827     formatter = DropShorterLongHelpFormatter("prog")
1828     assert formatter._width == 160
1829 
1830     formatter = DropShorterLongHelpFormatter("prog", width=42)
1831     assert formatter._width == 42
1832 
1833 
1834 def test_config_does_not_load_blocked_plugin_from_args(pytester: Pytester) -> None:
1835     """This tests that pytest's config setup handles "-p no:X"."""
1836     p = pytester.makepyfile("def test(capfd): pass")
1837     result = pytester.runpytest(str(p), "-pno:capture")
1838     result.stdout.fnmatch_lines(["E       fixture 'capfd' not found"])
1839     assert result.ret == ExitCode.TESTS_FAILED
1840 
1841     result = pytester.runpytest(str(p), "-pno:capture", "-s")
1842     result.stderr.fnmatch_lines(["*: error: unrecognized arguments: -s"])
1843     assert result.ret == ExitCode.USAGE_ERROR
1844 
1845     result = pytester.runpytest(str(p), "-p no:capture", "-s")
1846     result.stderr.fnmatch_lines(["*: error: unrecognized arguments: -s"])
1847     assert result.ret == ExitCode.USAGE_ERROR
1848 
1849 
1850 def test_invocation_args(pytester: Pytester) -> None:
1851     """Ensure that Config.invocation_* arguments are correctly defined"""
1852 
1853     class DummyPlugin:
1854         pass
1855 
1856     p = pytester.makepyfile("def test(): pass")
1857     plugin = DummyPlugin()
1858     rec = pytester.inline_run(p, "-v", plugins=[plugin])
1859     calls = rec.getcalls("pytest_runtest_protocol")
1860     assert len(calls) == 1
1861     call = calls[0]
1862     config = call.item.config
1863 
1864     assert config.invocation_params.args == (str(p), "-v")
1865     assert config.invocation_params.dir == pytester.path
1866 
1867     plugins = config.invocation_params.plugins
1868     assert len(plugins) == 2
1869     assert plugins[0] is plugin
1870     assert type(plugins[1]).__name__ == "Collect"  # installed by pytester.inline_run()
1871 
1872     # args cannot be None
1873     with pytest.raises(TypeError):
1874         Config.InvocationParams(args=None, plugins=None, dir=Path())  # type: ignore[arg-type]
1875 
1876 
1877 @pytest.mark.parametrize(
1878     "plugin",
1879     [
1880         x
1881         for x in _pytest.config.default_plugins
1882         if x not in _pytest.config.essential_plugins
1883     ],
1884 )
1885 def test_config_blocked_default_plugins(pytester: Pytester, plugin: str) -> None:
1886     if plugin == "debugging":
1887         # Fixed in xdist (after 1.27.0).
1888         # https://github.com/pytest-dev/pytest-xdist/pull/422
1889         try:
1890             import xdist  # noqa: F401
1891         except ImportError:
1892             pass
1893         else:
1894             pytest.skip("does not work with xdist currently")
1895 
1896     p = pytester.makepyfile("def test(): pass")
1897     result = pytester.runpytest(str(p), "-pno:%s" % plugin)
1898 
1899     if plugin == "python":
1900         assert result.ret == ExitCode.USAGE_ERROR
1901         result.stderr.fnmatch_lines(
1902             [
1903                 "ERROR: found no collectors for */test_config_blocked_default_plugins.py",
1904             ]
1905         )
1906         return
1907 
1908     assert result.ret == ExitCode.OK
1909     if plugin != "terminal":
1910         result.stdout.fnmatch_lines(["* 1 passed in *"])
1911 
1912     p = pytester.makepyfile("def test(): assert 0")
1913     result = pytester.runpytest(str(p), "-pno:%s" % plugin)
1914     assert result.ret == ExitCode.TESTS_FAILED
1915     if plugin != "terminal":
1916         result.stdout.fnmatch_lines(["* 1 failed in *"])
1917     else:
1918         assert result.stdout.lines == []
1919 
1920 
1921 class TestSetupCfg:
1922     def test_pytest_setup_cfg_unsupported(self, pytester: Pytester) -> None:
1923         pytester.makefile(
1924             ".cfg",
1925             setup="""
1926             [pytest]
1927             addopts = --verbose
1928         """,
1929         )
1930         with pytest.raises(pytest.fail.Exception):
1931             pytester.runpytest()
1932 
1933     def test_pytest_custom_cfg_unsupported(self, pytester: Pytester) -> None:
1934         pytester.makefile(
1935             ".cfg",
1936             custom="""
1937             [pytest]
1938             addopts = --verbose
1939         """,
1940         )
1941         with pytest.raises(pytest.fail.Exception):
1942             pytester.runpytest("-c", "custom.cfg")
1943 
1944         with pytest.raises(pytest.fail.Exception):
1945             pytester.runpytest("--config-file", "custom.cfg")
1946 
1947 
1948 class TestPytestPluginsVariable:
1949     def test_pytest_plugins_in_non_top_level_conftest_unsupported(
1950         self, pytester: Pytester
1951     ) -> None:
1952         pytester.makepyfile(
1953             **{
1954                 "subdirectory/conftest.py": """
1955             pytest_plugins=['capture']
1956         """
1957             }
1958         )
1959         pytester.makepyfile(
1960             """
1961             def test_func():
1962                 pass
1963         """
1964         )
1965         res = pytester.runpytest()
1966         assert res.ret == 2
1967         msg = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
1968         res.stdout.fnmatch_lines([f"*{msg}*", f"*subdirectory{os.sep}conftest.py*"])
1969 
1970     @pytest.mark.parametrize("use_pyargs", [True, False])
1971     def test_pytest_plugins_in_non_top_level_conftest_unsupported_pyargs(
1972         self, pytester: Pytester, use_pyargs: bool
1973     ) -> None:
1974         """When using --pyargs, do not emit the warning about non-top-level conftest warnings (#4039, #4044)"""
1975 
1976         files = {
1977             "src/pkg/__init__.py": "",
1978             "src/pkg/conftest.py": "",
1979             "src/pkg/test_root.py": "def test(): pass",
1980             "src/pkg/sub/__init__.py": "",
1981             "src/pkg/sub/conftest.py": "pytest_plugins=['capture']",
1982             "src/pkg/sub/test_bar.py": "def test(): pass",
1983         }
1984         pytester.makepyfile(**files)
1985         pytester.syspathinsert(pytester.path.joinpath("src"))
1986 
1987         args = ("--pyargs", "pkg") if use_pyargs else ()
1988         res = pytester.runpytest(*args)
1989         assert res.ret == (0 if use_pyargs else 2)
1990         msg = (
1991             msg
1992         ) = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
1993         if use_pyargs:
1994             assert msg not in res.stdout.str()
1995         else:
1996             res.stdout.fnmatch_lines([f"*{msg}*"])
1997 
1998     def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_top_level_conftest(
1999         self, pytester: Pytester
2000     ) -> None:
2001         subdirectory = pytester.path.joinpath("subdirectory")
2002         subdirectory.mkdir()
2003         pytester.makeconftest(
2004             """
2005             pytest_plugins=['capture']
2006         """
2007         )
2008         pytester.path.joinpath("conftest.py").rename(
2009             subdirectory.joinpath("conftest.py")
2010         )
2011 
2012         pytester.makepyfile(
2013             """
2014             def test_func():
2015                 pass
2016         """
2017         )
2018 
2019         res = pytester.runpytest_subprocess()
2020         assert res.ret == 2
2021         msg = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
2022         res.stdout.fnmatch_lines([f"*{msg}*", f"*subdirectory{os.sep}conftest.py*"])
2023 
2024     def test_pytest_plugins_in_non_top_level_conftest_unsupported_no_false_positives(
2025         self, pytester: Pytester
2026     ) -> None:
2027         pytester.makepyfile(
2028             "def test_func(): pass",
2029             **{
2030                 "subdirectory/conftest": "pass",
2031                 "conftest": """
2032                     import warnings
2033                     warnings.filterwarnings('always', category=DeprecationWarning)
2034                     pytest_plugins=['capture']
2035                     """,
2036             },
2037         )
2038         res = pytester.runpytest_subprocess()
2039         assert res.ret == 0
2040         msg = "Defining 'pytest_plugins' in a non-top-level conftest is no longer supported"
2041         assert msg not in res.stdout.str()
2042 
2043 
2044 def test_conftest_import_error_repr(tmp_path: Path) -> None:
2045     """`ConftestImportFailure` should use a short error message and readable
2046     path to the failed conftest.py file."""
2047     path = tmp_path.joinpath("foo/conftest.py")
2048     with pytest.raises(
2049         ConftestImportFailure,
2050         match=re.escape(f"RuntimeError: some error (from {path})"),
2051     ):
2052         try:
2053             raise RuntimeError("some error")
2054         except Exception as exc:
2055             assert exc.__traceback__ is not None
2056             exc_info = (type(exc), exc, exc.__traceback__)
2057             raise ConftestImportFailure(path, exc_info) from exc
2058 
2059 
2060 def test_strtobool() -> None:
2061     assert _strtobool("YES")
2062     assert not _strtobool("NO")
2063     with pytest.raises(ValueError):
2064         _strtobool("unknown")
2065 
2066 
2067 @pytest.mark.parametrize(
2068     "arg, escape, expected",
2069     [
2070         ("ignore", False, ("ignore", "", Warning, "", 0)),
2071         (
2072             "ignore::DeprecationWarning",
2073             False,
2074             ("ignore", "", DeprecationWarning, "", 0),
2075         ),
2076         (
2077             "ignore:some msg:DeprecationWarning",
2078             False,
2079             ("ignore", "some msg", DeprecationWarning, "", 0),
2080         ),
2081         (
2082             "ignore::DeprecationWarning:mod",
2083             False,
2084             ("ignore", "", DeprecationWarning, "mod", 0),
2085         ),
2086         (
2087             "ignore::DeprecationWarning:mod:42",
2088             False,
2089             ("ignore", "", DeprecationWarning, "mod", 42),
2090         ),
2091         ("error:some\\msg:::", True, ("error", "some\\\\msg", Warning, "", 0)),
2092         ("error:::mod\\foo:", True, ("error", "", Warning, "mod\\\\foo\\Z", 0)),
2093     ],
2094 )
2095 def test_parse_warning_filter(
2096     arg: str, escape: bool, expected: Tuple[str, str, Type[Warning], str, int]
2097 ) -> None:
2098     assert parse_warning_filter(arg, escape=escape) == expected
2099 
2100 
2101 @pytest.mark.parametrize(
2102     "arg",
2103     [
2104         # Too much parts.
2105         ":" * 5,
2106         # Invalid action.
2107         "FOO::",
2108         # ImportError when importing the warning class.
2109         "::test_parse_warning_filter_failure.NonExistentClass::",
2110         # Class is not a Warning subclass.
2111         "::list::",
2112         # Negative line number.
2113         "::::-1",
2114         # Not a line number.
2115         "::::not-a-number",
2116     ],
2117 )
2118 def test_parse_warning_filter_failure(arg: str) -> None:
2119     with pytest.raises(pytest.UsageError):
2120         parse_warning_filter(arg, escape=True)
2121 
2122 
2123 class TestDebugOptions:
2124     def test_without_debug_does_not_write_log(self, pytester: Pytester) -> None:
2125         result = pytester.runpytest()
2126         result.stderr.no_fnmatch_line(
2127             "*writing pytest debug information to*pytestdebug.log"
2128         )
2129         result.stderr.no_fnmatch_line(
2130             "*wrote pytest debug information to*pytestdebug.log"
2131         )
2132         assert not [f.name for f in pytester.path.glob("**/*.log")]
2133 
2134     def test_with_only_debug_writes_pytestdebug_log(self, pytester: Pytester) -> None:
2135         result = pytester.runpytest("--debug")
2136         result.stderr.fnmatch_lines(
2137             [
2138                 "*writing pytest debug information to*pytestdebug.log",
2139                 "*wrote pytest debug information to*pytestdebug.log",
2140             ]
2141         )
2142         assert "pytestdebug.log" in [f.name for f in pytester.path.glob("**/*.log")]
2143 
2144     def test_multiple_custom_debug_logs(self, pytester: Pytester) -> None:
2145         result = pytester.runpytest("--debug", "bar.log")
2146         result.stderr.fnmatch_lines(
2147             [
2148                 "*writing pytest debug information to*bar.log",
2149                 "*wrote pytest debug information to*bar.log",
2150             ]
2151         )
2152         result = pytester.runpytest("--debug", "foo.log")
2153         result.stderr.fnmatch_lines(
2154             [
2155                 "*writing pytest debug information to*foo.log",
2156                 "*wrote pytest debug information to*foo.log",
2157             ]
2158         )
2159 
2160         assert {"bar.log", "foo.log"} == {
2161             f.name for f in pytester.path.glob("**/*.log")
2162         }
2163 
2164     def test_debug_help(self, pytester: Pytester) -> None:
2165         result = pytester.runpytest("-h")
2166         result.stdout.fnmatch_lines(
2167             [
2168                 "*Store internal tracing debug information in this log*",
2169                 "*file. This file is opened with 'w' and truncated as a*",
2170                 "*Default: pytestdebug.log.",
2171             ]
2172         )

</code><intended_behavior>Test setup code should be carefully reviewed to ensure it does not inadvertently modify sys.modules in a way that could lead to module duplication. This includes avoiding unnecessary re-imports or removal of modules from sys.modules without a subsequent reload. Ensure all test configurations and dynamic imports follow a consistent path resolution and importing approach.</intended_behavior>, <file>src/_pytest/main.py</file>
<class>None</class>
<method>search_pypath</method>
<code>
843 def search_pypath(module_name: str) -> str:
844     """Search sys.path for the given a dotted module name, and return its file system path."""
845     try:
846         spec = importlib.util.find_spec(module_name)
847     # AttributeError: looks like package module, but actually filename
848     # ImportError: module does not exist
849     # ValueError: not a module name
850     except (AttributeError, ImportError, ValueError):
851         return module_name
852     if spec is None or spec.origin is None or spec.origin == "namespace":
853         return module_name
854     elif spec.submodule_search_locations:
855         return os.path.dirname(spec.origin)
856     else:
857         return spec.origin

</code><intended_behavior>The method search_pypath should ensure it respects the project's namespace package structures and does not bypass the standard module loading mechanism. Enhancements should support the uniqueness of module instances, particularly in contexts where the method's result influences dynamic importing decisions. Consider implementing additional checks or logs for module search and loading.</intended_behavior>]
2025-10-17 16:41:08.171 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 16:41:08.171 | INFO     | Search-only: skipping patch selection
2025-10-17 16:41:08.242 | INFO     | Task pytest-dev__pytest-11148 completed successfully.
2025-10-17 16:41:08.243 | INFO     | No patch generated. You can try running ACR again.
