2025-10-17 12:40:10.001 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 12:40:14.684 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=232, output_tokens=12, cost=0.002680
2025-10-17 12:40:14.685 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 12:40:14.688 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:40:24.748 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=537, output_tokens=320, cost=0.014970
2025-10-17 12:40:24.755 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:40:27.974 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=674, output_tokens=66, cost=0.008720
2025-10-17 12:40:27.976 | DEBUG    | Extracted a valid json.
2025-10-17 12:40:27.976 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"SQLite\")",
        "search_code(\"SQLITE_ENABLE_JSON1\")",
        "search_code(\"Indexes on expressions\")",
        "search_method(\"get_sqlite_version\")",
        "search_code(\"sqlite_version\")"
    ],
    "bug_locations": []
}
2025-10-17 12:40:28.139 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 12:40:28.139 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 12:40:44.103 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1500, output_tokens=690, cost=0.035700
2025-10-17 12:40:44.110 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:40:58.182 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2406, output_tokens=543, cost=0.040350
2025-10-17 12:40:58.186 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:41:03.161 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=897, output_tokens=175, cost=0.014220
2025-10-17 12:41:03.162 | DEBUG    | Extracted a valid json.
2025-10-17 12:41:03.162 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/backends/sqlite3/base.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Introduce version checking logic during the initialization phase to ensure the SQLite version is 3.9.0 or higher. If the version is lower, the system should raise a ConfigurationError (or similar) with a message indicating that the SQLite version is unsupported."
        }, 
        {
            "file": "django/db/backends/sqlite3/features.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Update the feature flags related to SQLite capabilities to conditionally enable these based on the SQLite version being 3.9.0 or higher."
        }
    ]
}
2025-10-17 12:41:03.167 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/sqlite3/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 SQLite backend for the sqlite3 module in the standard library.
3 """
4 import datetime
5 import decimal
6 import functools
7 import hashlib
8 import math
9 import operator
10 import random
11 import re
12 import statistics
13 import warnings
14 from itertools import chain
15 from sqlite3 import dbapi2 as Database
16 
17 import pytz
18 
19 from django.core.exceptions import ImproperlyConfigured
20 from django.db import IntegrityError
21 from django.db.backends import utils as backend_utils
22 from django.db.backends.base.base import BaseDatabaseWrapper
23 from django.utils import timezone
24 from django.utils.asyncio import async_unsafe
25 from django.utils.dateparse import parse_datetime, parse_time
26 from django.utils.duration import duration_microseconds
27 from django.utils.regex_helper import _lazy_re_compile
28 from django.utils.version import PY38
29 
30 from .client import DatabaseClient
31 from .creation import DatabaseCreation
32 from .features import DatabaseFeatures
33 from .introspection import DatabaseIntrospection
34 from .operations import DatabaseOperations
35 from .schema import DatabaseSchemaEditor
36 
37 
38 def decoder(conv_func):
39     """
40     Convert bytestrings from Python's sqlite3 interface to a regular string.
41     """
42     return lambda s: conv_func(s.decode())
43 
44 
45 def none_guard(func):
46     """
47     Decorator that returns None if any of the arguments to the decorated
48     function are None. Many SQL functions return NULL if any of their arguments
49     are NULL. This decorator simplifies the implementation of this for the
50     custom functions registered below.
51     """
52     @functools.wraps(func)
53     def wrapper(*args, **kwargs):
54         return None if None in args else func(*args, **kwargs)
55     return wrapper
56 
57 
58 def list_aggregate(function):
59     """
60     Return an aggregate class that accumulates values in a list and applies
61     the provided function to the data.
62     """
63     return type('ListAggregate', (list,), {'finalize': function, 'step': list.append})
64 
65 
66 def check_sqlite_version():
67     if Database.sqlite_version_info < (3, 8, 3):
68         raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)
69 
70 
71 check_sqlite_version()
72 
73 Database.register_converter("bool", b'1'.__eq__)
74 Database.register_converter("time", decoder(parse_time))
75 Database.register_converter("datetime", decoder(parse_datetime))
76 Database.register_converter("timestamp", decoder(parse_datetime))
77 
78 Database.register_adapter(decimal.Decimal, str)
79 
80 
81 class DatabaseWrapper(BaseDatabaseWrapper):
82     vendor = 'sqlite'
83     display_name = 'SQLite'
84     # SQLite doesn't actually support most of these types, but it "does the right
85     # thing" given more verbose field definitions, so leave them as is so that
86     # schema inspection is more useful.
87     data_types = {
88         'AutoField': 'integer',
89         'BigAutoField': 'integer',
90         'BinaryField': 'BLOB',
91         'BooleanField': 'bool',
92         'CharField': 'varchar(%(max_length)s)',
93         'DateField': 'date',
94         'DateTimeField': 'datetime',
95         'DecimalField': 'decimal',
96         'DurationField': 'bigint',
97         'FileField': 'varchar(%(max_length)s)',
98         'FilePathField': 'varchar(%(max_length)s)',
99         'FloatField': 'real',
100         'IntegerField': 'integer',
101         'BigIntegerField': 'bigint',
102         'IPAddressField': 'char(15)',
103         'GenericIPAddressField': 'char(39)',
104         'JSONField': 'text',
105         'NullBooleanField': 'bool',
106         'OneToOneField': 'integer',
107         'PositiveBigIntegerField': 'bigint unsigned',
108         'PositiveIntegerField': 'integer unsigned',
109         'PositiveSmallIntegerField': 'smallint unsigned',
110         'SlugField': 'varchar(%(max_length)s)',
111         'SmallAutoField': 'integer',
112         'SmallIntegerField': 'smallint',
113         'TextField': 'text',
114         'TimeField': 'time',
115         'UUIDField': 'char(32)',
116     }
117     data_type_check_constraints = {
118         'PositiveBigIntegerField': '"%(column)s" >= 0',
119         'JSONField': '(JSON_VALID("%(column)s") OR "%(column)s" IS NULL)',
120         'PositiveIntegerField': '"%(column)s" >= 0',
121         'PositiveSmallIntegerField': '"%(column)s" >= 0',
122     }
123     data_types_suffix = {
124         'AutoField': 'AUTOINCREMENT',
125         'BigAutoField': 'AUTOINCREMENT',
126         'SmallAutoField': 'AUTOINCREMENT',
127     }
128     # SQLite requires LIKE statements to include an ESCAPE clause if the value
129     # being escaped has a percent or underscore in it.
130     # See https://www.sqlite.org/lang_expr.html for an explanation.
131     operators = {
132         'exact': '= %s',
133         'iexact': "LIKE %s ESCAPE '\\'",
134         'contains': "LIKE %s ESCAPE '\\'",
135         'icontains': "LIKE %s ESCAPE '\\'",
136         'regex': 'REGEXP %s',
137         'iregex': "REGEXP '(?i)' || %s",
138         'gt': '> %s',
139         'gte': '>= %s',
140         'lt': '< %s',
141         'lte': '<= %s',
142         'startswith': "LIKE %s ESCAPE '\\'",
143         'endswith': "LIKE %s ESCAPE '\\'",
144         'istartswith': "LIKE %s ESCAPE '\\'",
145         'iendswith': "LIKE %s ESCAPE '\\'",
146     }
147 
148     # The patterns below are used to generate SQL pattern lookup clauses when
149     # the right-hand side of the lookup isn't a raw string (it might be an expression
150     # or the result of a bilateral transformation).
151     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
152     # escaped on database side.
153     #
154     # Note: we use str.format() here for readability as '%' is used as a wildcard for
155     # the LIKE operator.
156     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
157     pattern_ops = {
158         'contains': r"LIKE '%%' || {} || '%%' ESCAPE '\'",
159         'icontains': r"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'",
160         'startswith': r"LIKE {} || '%%' ESCAPE '\'",
161         'istartswith': r"LIKE UPPER({}) || '%%' ESCAPE '\'",
162         'endswith': r"LIKE '%%' || {} ESCAPE '\'",
163         'iendswith': r"LIKE '%%' || UPPER({}) ESCAPE '\'",
164     }
165 
166     Database = Database
167     SchemaEditorClass = DatabaseSchemaEditor
168     # Classes instantiated in __init__().
169     client_class = DatabaseClient
170     creation_class = DatabaseCreation
171     features_class = DatabaseFeatures
172     introspection_class = DatabaseIntrospection
173     ops_class = DatabaseOperations
174 
175     def get_connection_params(self):
176         settings_dict = self.settings_dict
177         if not settings_dict['NAME']:
178             raise ImproperlyConfigured(
179                 "settings.DATABASES is improperly configured. "
180                 "Please supply the NAME value.")
181         kwargs = {
182             # TODO: Remove str() when dropping support for PY36.
183             # https://bugs.python.org/issue33496
184             'database': str(settings_dict['NAME']),
185             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,
186             **settings_dict['OPTIONS'],
187         }
188         # Always allow the underlying SQLite connection to be shareable
189         # between multiple threads. The safe-guarding will be handled at a
190         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`
191         # property. This is necessary as the shareability is disabled by
192         # default in pysqlite and it cannot be changed once a connection is
193         # opened.
194         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:
195             warnings.warn(
196                 'The `check_same_thread` option was provided and set to '
197                 'True. It will be overridden with False. Use the '
198                 '`DatabaseWrapper.allow_thread_sharing` property instead '
199                 'for controlling thread shareability.',
200                 RuntimeWarning
201             )
202         kwargs.update({'check_same_thread': False, 'uri': True})
203         return kwargs
204 
205     @async_unsafe
206     def get_new_connection(self, conn_params):
207         conn = Database.connect(**conn_params)
208         if PY38:
209             create_deterministic_function = functools.partial(
210                 conn.create_function,
211                 deterministic=True,
212             )
213         else:
214             create_deterministic_function = conn.create_function
215         create_deterministic_function('django_date_extract', 2, _sqlite_datetime_extract)
216         create_deterministic_function('django_date_trunc', 4, _sqlite_date_trunc)
217         create_deterministic_function('django_datetime_cast_date', 3, _sqlite_datetime_cast_date)
218         create_deterministic_function('django_datetime_cast_time', 3, _sqlite_datetime_cast_time)
219         create_deterministic_function('django_datetime_extract', 4, _sqlite_datetime_extract)
220         create_deterministic_function('django_datetime_trunc', 4, _sqlite_datetime_trunc)
221         create_deterministic_function('django_time_extract', 2, _sqlite_time_extract)
222         create_deterministic_function('django_time_trunc', 4, _sqlite_time_trunc)
223         create_deterministic_function('django_time_diff', 2, _sqlite_time_diff)
224         create_deterministic_function('django_timestamp_diff', 2, _sqlite_timestamp_diff)
225         create_deterministic_function('django_format_dtdelta', 3, _sqlite_format_dtdelta)
226         create_deterministic_function('regexp', 2, _sqlite_regexp)
227         create_deterministic_function('ACOS', 1, none_guard(math.acos))
228         create_deterministic_function('ASIN', 1, none_guard(math.asin))
229         create_deterministic_function('ATAN', 1, none_guard(math.atan))
230         create_deterministic_function('ATAN2', 2, none_guard(math.atan2))
231         create_deterministic_function('BITXOR', 2, none_guard(operator.xor))
232         create_deterministic_function('CEILING', 1, none_guard(math.ceil))
233         create_deterministic_function('COS', 1, none_guard(math.cos))
234         create_deterministic_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
235         create_deterministic_function('DEGREES', 1, none_guard(math.degrees))
236         create_deterministic_function('EXP', 1, none_guard(math.exp))
237         create_deterministic_function('FLOOR', 1, none_guard(math.floor))
238         create_deterministic_function('LN', 1, none_guard(math.log))
239         create_deterministic_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
240         create_deterministic_function('LPAD', 3, _sqlite_lpad)
241         create_deterministic_function('MD5', 1, none_guard(lambda x: hashlib.md5(x.encode()).hexdigest()))
242         create_deterministic_function('MOD', 2, none_guard(math.fmod))
243         create_deterministic_function('PI', 0, lambda: math.pi)
244         create_deterministic_function('POWER', 2, none_guard(operator.pow))
245         create_deterministic_function('RADIANS', 1, none_guard(math.radians))
246         create_deterministic_function('REPEAT', 2, none_guard(operator.mul))
247         create_deterministic_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
248         create_deterministic_function('RPAD', 3, _sqlite_rpad)
249         create_deterministic_function('SHA1', 1, none_guard(lambda x: hashlib.sha1(x.encode()).hexdigest()))
250         create_deterministic_function('SHA224', 1, none_guard(lambda x: hashlib.sha224(x.encode()).hexdigest()))
251         create_deterministic_function('SHA256', 1, none_guard(lambda x: hashlib.sha256(x.encode()).hexdigest()))
252         create_deterministic_function('SHA384', 1, none_guard(lambda x: hashlib.sha384(x.encode()).hexdigest()))
253         create_deterministic_function('SHA512', 1, none_guard(lambda x: hashlib.sha512(x.encode()).hexdigest()))
254         create_deterministic_function('SIGN', 1, none_guard(lambda x: (x > 0) - (x < 0)))
255         create_deterministic_function('SIN', 1, none_guard(math.sin))
256         create_deterministic_function('SQRT', 1, none_guard(math.sqrt))
257         create_deterministic_function('TAN', 1, none_guard(math.tan))
258         # Don't use the built-in RANDOM() function because it returns a value
259         # in the range [2^63, 2^63 - 1] instead of [0, 1).
260         conn.create_function('RAND', 0, random.random)
261         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
262         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
263         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
264         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
265         conn.execute('PRAGMA foreign_keys = ON')
266         return conn
267 
268     def init_connection_state(self):
269         pass
270 
271     def create_cursor(self, name=None):
272         return self.connection.cursor(factory=SQLiteCursorWrapper)
273 
274     @async_unsafe
275     def close(self):
276         self.validate_thread_sharing()
277         # If database is in memory, closing the connection destroys the
278         # database. To prevent accidental data loss, ignore close requests on
279         # an in-memory db.
280         if not self.is_in_memory_db():
281             BaseDatabaseWrapper.close(self)
282 
283     def _savepoint_allowed(self):
284         # When 'isolation_level' is not None, sqlite3 commits before each
285         # savepoint; it's a bug. When it is None, savepoints don't make sense
286         # because autocommit is enabled. The only exception is inside 'atomic'
287         # blocks. To work around that bug, on SQLite, 'atomic' starts a
288         # transaction explicitly rather than simply disable autocommit.
289         return self.in_atomic_block
290 
291     def _set_autocommit(self, autocommit):
292         if autocommit:
293             level = None
294         else:
295             # sqlite3's internal default is ''. It's different from None.
296             # See Modules/_sqlite/connection.c.
297             level = ''
298         # 'isolation_level' is a misleading API.
299         # SQLite always runs at the SERIALIZABLE isolation level.
300         with self.wrap_database_errors:
301             self.connection.isolation_level = level
302 
303     def disable_constraint_checking(self):
304         with self.cursor() as cursor:
305             cursor.execute('PRAGMA foreign_keys = OFF')
306             # Foreign key constraints cannot be turned off while in a multi-
307             # statement transaction. Fetch the current state of the pragma
308             # to determine if constraints are effectively disabled.
309             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]
310         return not bool(enabled)
311 
312     def enable_constraint_checking(self):
313         with self.cursor() as cursor:
314             cursor.execute('PRAGMA foreign_keys = ON')
315 
316     def check_constraints(self, table_names=None):
317         """
318         Check each table name in `table_names` for rows with invalid foreign
319         key references. This method is intended to be used in conjunction with
320         `disable_constraint_checking()` and `enable_constraint_checking()`, to
321         determine if rows with invalid references were entered while constraint
322         checks were off.
323         """
324         if self.features.supports_pragma_foreign_key_check:
325             with self.cursor() as cursor:
326                 if table_names is None:
327                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()
328                 else:
329                     violations = chain.from_iterable(
330                         cursor.execute(
331                             'PRAGMA foreign_key_check(%s)'
332                             % self.ops.quote_name(table_name)
333                         ).fetchall()
334                         for table_name in table_names
335                     )
336                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
337                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:
338                     foreign_key = cursor.execute(
339                         'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)
340                     ).fetchall()[foreign_key_index]
341                     column_name, referenced_column_name = foreign_key[3:5]
342                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
343                     primary_key_value, bad_value = cursor.execute(
344                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (
345                             self.ops.quote_name(primary_key_column_name),
346                             self.ops.quote_name(column_name),
347                             self.ops.quote_name(table_name),
348                         ),
349                         (rowid,),
350                     ).fetchone()
351                     raise IntegrityError(
352                         "The row in table '%s' with primary key '%s' has an "
353                         "invalid foreign key: %s.%s contains a value '%s' that "
354                         "does not have a corresponding value in %s.%s." % (
355                             table_name, primary_key_value, table_name, column_name,
356                             bad_value, referenced_table_name, referenced_column_name
357                         )
358                     )
359         else:
360             with self.cursor() as cursor:
361                 if table_names is None:
362                     table_names = self.introspection.table_names(cursor)
363                 for table_name in table_names:
364                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
365                     if not primary_key_column_name:
366                         continue
367                     key_columns = self.introspection.get_key_columns(cursor, table_name)
368                     for column_name, referenced_table_name, referenced_column_name in key_columns:
369                         cursor.execute(
370                             """
371                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING
372                             LEFT JOIN `%s` as REFERRED
373                             ON (REFERRING.`%s` = REFERRED.`%s`)
374                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL
375                             """
376                             % (
377                                 primary_key_column_name, column_name, table_name,
378                                 referenced_table_name, column_name, referenced_column_name,
379                                 column_name, referenced_column_name,
380                             )
381                         )
382                         for bad_row in cursor.fetchall():
383                             raise IntegrityError(
384                                 "The row in table '%s' with primary key '%s' has an "
385                                 "invalid foreign key: %s.%s contains a value '%s' that "
386                                 "does not have a corresponding value in %s.%s." % (
387                                     table_name, bad_row[0], table_name, column_name,
388                                     bad_row[1], referenced_table_name, referenced_column_name,
389                                 )
390                             )
391 
392     def is_usable(self):
393         return True
394 
395     def _start_transaction_under_autocommit(self):
396         """
397         Start a transaction explicitly in autocommit mode.
398 
399         Staying in autocommit mode works around a bug of sqlite3 that breaks
400         savepoints when autocommit is disabled.
401         """
402         self.cursor().execute("BEGIN")
403 
404     def is_in_memory_db(self):
405         return self.creation.is_in_memory_db(self.settings_dict['NAME'])
406 
407 
408 FORMAT_QMARK_REGEX = _lazy_re_compile(r'(?<!%)%s')
409 
410 
411 class SQLiteCursorWrapper(Database.Cursor):
412     """
413     Django uses "format" style placeholders, but pysqlite2 uses "qmark" style.
414     This fixes it -- but note that if you want to use a literal "%s" in a query,
415     you'll need to use "%%s".
416     """
417     def execute(self, query, params=None):
418         if params is None:
419             return Database.Cursor.execute(self, query)
420         query = self.convert_query(query)
421         return Database.Cursor.execute(self, query, params)
422 
423     def executemany(self, query, param_list):
424         query = self.convert_query(query)
425         return Database.Cursor.executemany(self, query, param_list)
426 
427     def convert_query(self, query):
428         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')
429 
430 
431 def _sqlite_datetime_parse(dt, tzname=None, conn_tzname=None):
432     if dt is None:
433         return None
434     try:
435         dt = backend_utils.typecast_timestamp(dt)
436     except (TypeError, ValueError):
437         return None
438     if conn_tzname:
439         dt = dt.replace(tzinfo=pytz.timezone(conn_tzname))
440     if tzname is not None and tzname != conn_tzname:
441         sign_index = tzname.find('+') + tzname.find('-') + 1
442         if sign_index > -1:
443             sign = tzname[sign_index]
444             tzname, offset = tzname.split(sign)
445             if offset:
446                 hours, minutes = offset.split(':')
447                 offset_delta = datetime.timedelta(hours=int(hours), minutes=int(minutes))
448                 dt += offset_delta if sign == '+' else -offset_delta
449         dt = timezone.localtime(dt, pytz.timezone(tzname))
450     return dt
451 
452 
453 def _sqlite_date_trunc(lookup_type, dt, tzname, conn_tzname):
454     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
455     if dt is None:
456         return None
457     if lookup_type == 'year':
458         return "%i-01-01" % dt.year
459     elif lookup_type == 'quarter':
460         month_in_quarter = dt.month - (dt.month - 1) % 3
461         return '%i-%02i-01' % (dt.year, month_in_quarter)
462     elif lookup_type == 'month':
463         return "%i-%02i-01" % (dt.year, dt.month)
464     elif lookup_type == 'week':
465         dt = dt - datetime.timedelta(days=dt.weekday())
466         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
467     elif lookup_type == 'day':
468         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
469 
470 
471 def _sqlite_time_trunc(lookup_type, dt, tzname, conn_tzname):
472     if dt is None:
473         return None
474     dt_parsed = _sqlite_datetime_parse(dt, tzname, conn_tzname)
475     if dt_parsed is None:
476         try:
477             dt = backend_utils.typecast_time(dt)
478         except (ValueError, TypeError):
479             return None
480     else:
481         dt = dt_parsed
482     if lookup_type == 'hour':
483         return "%02i:00:00" % dt.hour
484     elif lookup_type == 'minute':
485         return "%02i:%02i:00" % (dt.hour, dt.minute)
486     elif lookup_type == 'second':
487         return "%02i:%02i:%02i" % (dt.hour, dt.minute, dt.second)
488 
489 
490 def _sqlite_datetime_cast_date(dt, tzname, conn_tzname):
491     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
492     if dt is None:
493         return None
494     return dt.date().isoformat()
495 
496 
497 def _sqlite_datetime_cast_time(dt, tzname, conn_tzname):
498     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
499     if dt is None:
500         return None
501     return dt.time().isoformat()
502 
503 
504 def _sqlite_datetime_extract(lookup_type, dt, tzname=None, conn_tzname=None):
505     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
506     if dt is None:
507         return None
508     if lookup_type == 'week_day':
509         return (dt.isoweekday() % 7) + 1
510     elif lookup_type == 'iso_week_day':
511         return dt.isoweekday()
512     elif lookup_type == 'week':
513         return dt.isocalendar()[1]
514     elif lookup_type == 'quarter':
515         return math.ceil(dt.month / 3)
516     elif lookup_type == 'iso_year':
517         return dt.isocalendar()[0]
518     else:
519         return getattr(dt, lookup_type)
520 
521 
522 def _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname):
523     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
524     if dt is None:
525         return None
526     if lookup_type == 'year':
527         return "%i-01-01 00:00:00" % dt.year
528     elif lookup_type == 'quarter':
529         month_in_quarter = dt.month - (dt.month - 1) % 3
530         return '%i-%02i-01 00:00:00' % (dt.year, month_in_quarter)
531     elif lookup_type == 'month':
532         return "%i-%02i-01 00:00:00" % (dt.year, dt.month)
533     elif lookup_type == 'week':
534         dt = dt - datetime.timedelta(days=dt.weekday())
535         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
536     elif lookup_type == 'day':
537         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
538     elif lookup_type == 'hour':
539         return "%i-%02i-%02i %02i:00:00" % (dt.year, dt.month, dt.day, dt.hour)
540     elif lookup_type == 'minute':
541         return "%i-%02i-%02i %02i:%02i:00" % (dt.year, dt.month, dt.day, dt.hour, dt.minute)
542     elif lookup_type == 'second':
543         return "%i-%02i-%02i %02i:%02i:%02i" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
544 
545 
546 def _sqlite_time_extract(lookup_type, dt):
547     if dt is None:
548         return None
549     try:
550         dt = backend_utils.typecast_time(dt)
551     except (ValueError, TypeError):
552         return None
553     return getattr(dt, lookup_type)
554 
555 
556 @none_guard
557 def _sqlite_format_dtdelta(conn, lhs, rhs):
558     """
559     LHS and RHS can be either:
560     - An integer number of microseconds
561     - A string representing a datetime
562     """
563     try:
564         real_lhs = datetime.timedelta(0, 0, lhs) if isinstance(lhs, int) else backend_utils.typecast_timestamp(lhs)
565         real_rhs = datetime.timedelta(0, 0, rhs) if isinstance(rhs, int) else backend_utils.typecast_timestamp(rhs)
566         if conn.strip() == '+':
567             out = real_lhs + real_rhs
568         else:
569             out = real_lhs - real_rhs
570     except (ValueError, TypeError):
571         return None
572     # typecast_timestamp returns a date or a datetime without timezone.
573     # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]"
574     return str(out)
575 
576 
577 @none_guard
578 def _sqlite_time_diff(lhs, rhs):
579     left = backend_utils.typecast_time(lhs)
580     right = backend_utils.typecast_time(rhs)
581     return (
582         (left.hour * 60 * 60 * 1000000) +
583         (left.minute * 60 * 1000000) +
584         (left.second * 1000000) +
585         (left.microsecond) -
586         (right.hour * 60 * 60 * 1000000) -
587         (right.minute * 60 * 1000000) -
588         (right.second * 1000000) -
589         (right.microsecond)
590     )
591 
592 
593 @none_guard
594 def _sqlite_timestamp_diff(lhs, rhs):
595     left = backend_utils.typecast_timestamp(lhs)
596     right = backend_utils.typecast_timestamp(rhs)
597     return duration_microseconds(left - right)
598 
599 
600 @none_guard
601 def _sqlite_regexp(re_pattern, re_string):
602     return bool(re.search(re_pattern, str(re_string)))
603 
604 
605 @none_guard
606 def _sqlite_lpad(text, length, fill_text):
607     if len(text) >= length:
608         return text[:length]
609     return (fill_text * length)[:length - len(text)] + text
610 
611 
612 @none_guard
613 def _sqlite_rpad(text, length, fill_text):
614     return (text + fill_text * length)[:length]

</code><intended_behavior>Introduce version checking logic during the initialization phase to ensure the SQLite version is 3.9.0 or higher. If the version is lower, the system should raise a ConfigurationError (or similar) with a message indicating that the SQLite version is unsupported.</intended_behavior>, <file>django/db/backends/sqlite3/features.py</file>
<class>None</class>
<method>None</method>
<code>
1 import operator
2 import platform
3 
4 from django.db import transaction
5 from django.db.backends.base.features import BaseDatabaseFeatures
6 from django.db.utils import OperationalError
7 from django.utils.functional import cached_property
8 
9 from .base import Database
10 
11 
12 class DatabaseFeatures(BaseDatabaseFeatures):
13     # SQLite can read from a cursor since SQLite 3.6.5, subject to the caveat
14     # that statements within a connection aren't isolated from each other. See
15     # https://sqlite.org/isolation.html.
16     can_use_chunked_reads = True
17     test_db_allows_multiple_connections = False
18     supports_unspecified_pk = True
19     supports_timezones = False
20     max_query_params = 999
21     supports_mixed_date_datetime_comparisons = False
22     supports_transactions = True
23     atomic_transactions = False
24     can_rollback_ddl = True
25     can_create_inline_fk = False
26     supports_paramstyle_pyformat = False
27     can_clone_databases = True
28     supports_temporal_subtraction = True
29     ignores_table_name_case = True
30     supports_cast_with_precision = False
31     time_cast_precision = 3
32     can_release_savepoints = True
33     # Is "ALTER TABLE ... RENAME COLUMN" supported?
34     can_alter_table_rename_column = Database.sqlite_version_info >= (3, 25, 0)
35     supports_parentheses_in_compound = False
36     # Deferred constraint checks can be emulated on SQLite < 3.20 but not in a
37     # reasonably performant way.
38     supports_pragma_foreign_key_check = Database.sqlite_version_info >= (3, 20, 0)
39     can_defer_constraint_checks = supports_pragma_foreign_key_check
40     supports_functions_in_partial_indexes = Database.sqlite_version_info >= (3, 15, 0)
41     supports_over_clause = Database.sqlite_version_info >= (3, 25, 0)
42     supports_frame_range_fixed_distance = Database.sqlite_version_info >= (3, 28, 0)
43     supports_aggregate_filter_clause = Database.sqlite_version_info >= (3, 30, 1)
44     supports_order_by_nulls_modifier = Database.sqlite_version_info >= (3, 30, 0)
45     order_by_nulls_first = True
46     supports_json_field_contains = False
47     test_collations = {
48         'ci': 'nocase',
49         'cs': 'binary',
50         'non_default': 'nocase',
51     }
52 
53     @cached_property
54     def django_test_skips(self):
55         skips = {
56             'SQLite stores values rounded to 15 significant digits.': {
57                 'model_fields.test_decimalfield.DecimalFieldTests.test_fetch_from_db_without_float_rounding',
58             },
59             'SQLite naively remakes the table on field alteration.': {
60                 'schema.tests.SchemaTests.test_unique_no_unnecessary_fk_drops',
61                 'schema.tests.SchemaTests.test_unique_and_reverse_m2m',
62                 'schema.tests.SchemaTests.test_alter_field_default_doesnt_perform_queries',
63                 'schema.tests.SchemaTests.test_rename_column_renames_deferred_sql_references',
64             },
65             "SQLite doesn't have a constraint.": {
66                 'model_fields.test_integerfield.PositiveIntegerFieldTests.test_negative_values',
67             },
68         }
69         if Database.sqlite_version_info < (3, 27):
70             skips.update({
71                 'Nondeterministic failure on SQLite < 3.27.': {
72                     'expressions_window.tests.WindowFunctionTests.test_subquery_row_range_rank',
73                 },
74             })
75         if self.connection.is_in_memory_db():
76             skips.update({
77                 "the sqlite backend's close() method is a no-op when using an "
78                 "in-memory database": {
79                     'servers.test_liveserverthread.LiveServerThreadTest.test_closes_connections',
80                 },
81             })
82         return skips
83 
84     @cached_property
85     def supports_atomic_references_rename(self):
86         # SQLite 3.28.0 bundled with MacOS 10.15 does not support renaming
87         # references atomically.
88         if platform.mac_ver()[0].startswith('10.15.') and Database.sqlite_version_info == (3, 28, 0):
89             return False
90         return Database.sqlite_version_info >= (3, 26, 0)
91 
92     @cached_property
93     def introspected_field_types(self):
94         return{
95             **super().introspected_field_types,
96             'BigAutoField': 'AutoField',
97             'DurationField': 'BigIntegerField',
98             'GenericIPAddressField': 'CharField',
99             'SmallAutoField': 'AutoField',
100         }
101 
102     @cached_property
103     def supports_json_field(self):
104         with self.connection.cursor() as cursor:
105             try:
106                 with transaction.atomic(self.connection.alias):
107                     cursor.execute('SELECT JSON(\'{"a": "b"}\')')
108             except OperationalError:
109                 return False
110         return True
111 
112     can_introspect_json_field = property(operator.attrgetter('supports_json_field'))
113     has_json_object_function = property(operator.attrgetter('supports_json_field'))

</code><intended_behavior>Update the feature flags related to SQLite capabilities to conditionally enable these based on the SQLite version being 3.9.0 or higher.</intended_behavior>]
2025-10-17 12:41:03.167 | INFO     | Search completed. Bug locations: [<file>django/db/backends/sqlite3/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 SQLite backend for the sqlite3 module in the standard library.
3 """
4 import datetime
5 import decimal
6 import functools
7 import hashlib
8 import math
9 import operator
10 import random
11 import re
12 import statistics
13 import warnings
14 from itertools import chain
15 from sqlite3 import dbapi2 as Database
16 
17 import pytz
18 
19 from django.core.exceptions import ImproperlyConfigured
20 from django.db import IntegrityError
21 from django.db.backends import utils as backend_utils
22 from django.db.backends.base.base import BaseDatabaseWrapper
23 from django.utils import timezone
24 from django.utils.asyncio import async_unsafe
25 from django.utils.dateparse import parse_datetime, parse_time
26 from django.utils.duration import duration_microseconds
27 from django.utils.regex_helper import _lazy_re_compile
28 from django.utils.version import PY38
29 
30 from .client import DatabaseClient
31 from .creation import DatabaseCreation
32 from .features import DatabaseFeatures
33 from .introspection import DatabaseIntrospection
34 from .operations import DatabaseOperations
35 from .schema import DatabaseSchemaEditor
36 
37 
38 def decoder(conv_func):
39     """
40     Convert bytestrings from Python's sqlite3 interface to a regular string.
41     """
42     return lambda s: conv_func(s.decode())
43 
44 
45 def none_guard(func):
46     """
47     Decorator that returns None if any of the arguments to the decorated
48     function are None. Many SQL functions return NULL if any of their arguments
49     are NULL. This decorator simplifies the implementation of this for the
50     custom functions registered below.
51     """
52     @functools.wraps(func)
53     def wrapper(*args, **kwargs):
54         return None if None in args else func(*args, **kwargs)
55     return wrapper
56 
57 
58 def list_aggregate(function):
59     """
60     Return an aggregate class that accumulates values in a list and applies
61     the provided function to the data.
62     """
63     return type('ListAggregate', (list,), {'finalize': function, 'step': list.append})
64 
65 
66 def check_sqlite_version():
67     if Database.sqlite_version_info < (3, 8, 3):
68         raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)
69 
70 
71 check_sqlite_version()
72 
73 Database.register_converter("bool", b'1'.__eq__)
74 Database.register_converter("time", decoder(parse_time))
75 Database.register_converter("datetime", decoder(parse_datetime))
76 Database.register_converter("timestamp", decoder(parse_datetime))
77 
78 Database.register_adapter(decimal.Decimal, str)
79 
80 
81 class DatabaseWrapper(BaseDatabaseWrapper):
82     vendor = 'sqlite'
83     display_name = 'SQLite'
84     # SQLite doesn't actually support most of these types, but it "does the right
85     # thing" given more verbose field definitions, so leave them as is so that
86     # schema inspection is more useful.
87     data_types = {
88         'AutoField': 'integer',
89         'BigAutoField': 'integer',
90         'BinaryField': 'BLOB',
91         'BooleanField': 'bool',
92         'CharField': 'varchar(%(max_length)s)',
93         'DateField': 'date',
94         'DateTimeField': 'datetime',
95         'DecimalField': 'decimal',
96         'DurationField': 'bigint',
97         'FileField': 'varchar(%(max_length)s)',
98         'FilePathField': 'varchar(%(max_length)s)',
99         'FloatField': 'real',
100         'IntegerField': 'integer',
101         'BigIntegerField': 'bigint',
102         'IPAddressField': 'char(15)',
103         'GenericIPAddressField': 'char(39)',
104         'JSONField': 'text',
105         'NullBooleanField': 'bool',
106         'OneToOneField': 'integer',
107         'PositiveBigIntegerField': 'bigint unsigned',
108         'PositiveIntegerField': 'integer unsigned',
109         'PositiveSmallIntegerField': 'smallint unsigned',
110         'SlugField': 'varchar(%(max_length)s)',
111         'SmallAutoField': 'integer',
112         'SmallIntegerField': 'smallint',
113         'TextField': 'text',
114         'TimeField': 'time',
115         'UUIDField': 'char(32)',
116     }
117     data_type_check_constraints = {
118         'PositiveBigIntegerField': '"%(column)s" >= 0',
119         'JSONField': '(JSON_VALID("%(column)s") OR "%(column)s" IS NULL)',
120         'PositiveIntegerField': '"%(column)s" >= 0',
121         'PositiveSmallIntegerField': '"%(column)s" >= 0',
122     }
123     data_types_suffix = {
124         'AutoField': 'AUTOINCREMENT',
125         'BigAutoField': 'AUTOINCREMENT',
126         'SmallAutoField': 'AUTOINCREMENT',
127     }
128     # SQLite requires LIKE statements to include an ESCAPE clause if the value
129     # being escaped has a percent or underscore in it.
130     # See https://www.sqlite.org/lang_expr.html for an explanation.
131     operators = {
132         'exact': '= %s',
133         'iexact': "LIKE %s ESCAPE '\\'",
134         'contains': "LIKE %s ESCAPE '\\'",
135         'icontains': "LIKE %s ESCAPE '\\'",
136         'regex': 'REGEXP %s',
137         'iregex': "REGEXP '(?i)' || %s",
138         'gt': '> %s',
139         'gte': '>= %s',
140         'lt': '< %s',
141         'lte': '<= %s',
142         'startswith': "LIKE %s ESCAPE '\\'",
143         'endswith': "LIKE %s ESCAPE '\\'",
144         'istartswith': "LIKE %s ESCAPE '\\'",
145         'iendswith': "LIKE %s ESCAPE '\\'",
146     }
147 
148     # The patterns below are used to generate SQL pattern lookup clauses when
149     # the right-hand side of the lookup isn't a raw string (it might be an expression
150     # or the result of a bilateral transformation).
151     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
152     # escaped on database side.
153     #
154     # Note: we use str.format() here for readability as '%' is used as a wildcard for
155     # the LIKE operator.
156     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
157     pattern_ops = {
158         'contains': r"LIKE '%%' || {} || '%%' ESCAPE '\'",
159         'icontains': r"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'",
160         'startswith': r"LIKE {} || '%%' ESCAPE '\'",
161         'istartswith': r"LIKE UPPER({}) || '%%' ESCAPE '\'",
162         'endswith': r"LIKE '%%' || {} ESCAPE '\'",
163         'iendswith': r"LIKE '%%' || UPPER({}) ESCAPE '\'",
164     }
165 
166     Database = Database
167     SchemaEditorClass = DatabaseSchemaEditor
168     # Classes instantiated in __init__().
169     client_class = DatabaseClient
170     creation_class = DatabaseCreation
171     features_class = DatabaseFeatures
172     introspection_class = DatabaseIntrospection
173     ops_class = DatabaseOperations
174 
175     def get_connection_params(self):
176         settings_dict = self.settings_dict
177         if not settings_dict['NAME']:
178             raise ImproperlyConfigured(
179                 "settings.DATABASES is improperly configured. "
180                 "Please supply the NAME value.")
181         kwargs = {
182             # TODO: Remove str() when dropping support for PY36.
183             # https://bugs.python.org/issue33496
184             'database': str(settings_dict['NAME']),
185             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,
186             **settings_dict['OPTIONS'],
187         }
188         # Always allow the underlying SQLite connection to be shareable
189         # between multiple threads. The safe-guarding will be handled at a
190         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`
191         # property. This is necessary as the shareability is disabled by
192         # default in pysqlite and it cannot be changed once a connection is
193         # opened.
194         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:
195             warnings.warn(
196                 'The `check_same_thread` option was provided and set to '
197                 'True. It will be overridden with False. Use the '
198                 '`DatabaseWrapper.allow_thread_sharing` property instead '
199                 'for controlling thread shareability.',
200                 RuntimeWarning
201             )
202         kwargs.update({'check_same_thread': False, 'uri': True})
203         return kwargs
204 
205     @async_unsafe
206     def get_new_connection(self, conn_params):
207         conn = Database.connect(**conn_params)
208         if PY38:
209             create_deterministic_function = functools.partial(
210                 conn.create_function,
211                 deterministic=True,
212             )
213         else:
214             create_deterministic_function = conn.create_function
215         create_deterministic_function('django_date_extract', 2, _sqlite_datetime_extract)
216         create_deterministic_function('django_date_trunc', 4, _sqlite_date_trunc)
217         create_deterministic_function('django_datetime_cast_date', 3, _sqlite_datetime_cast_date)
218         create_deterministic_function('django_datetime_cast_time', 3, _sqlite_datetime_cast_time)
219         create_deterministic_function('django_datetime_extract', 4, _sqlite_datetime_extract)
220         create_deterministic_function('django_datetime_trunc', 4, _sqlite_datetime_trunc)
221         create_deterministic_function('django_time_extract', 2, _sqlite_time_extract)
222         create_deterministic_function('django_time_trunc', 4, _sqlite_time_trunc)
223         create_deterministic_function('django_time_diff', 2, _sqlite_time_diff)
224         create_deterministic_function('django_timestamp_diff', 2, _sqlite_timestamp_diff)
225         create_deterministic_function('django_format_dtdelta', 3, _sqlite_format_dtdelta)
226         create_deterministic_function('regexp', 2, _sqlite_regexp)
227         create_deterministic_function('ACOS', 1, none_guard(math.acos))
228         create_deterministic_function('ASIN', 1, none_guard(math.asin))
229         create_deterministic_function('ATAN', 1, none_guard(math.atan))
230         create_deterministic_function('ATAN2', 2, none_guard(math.atan2))
231         create_deterministic_function('BITXOR', 2, none_guard(operator.xor))
232         create_deterministic_function('CEILING', 1, none_guard(math.ceil))
233         create_deterministic_function('COS', 1, none_guard(math.cos))
234         create_deterministic_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
235         create_deterministic_function('DEGREES', 1, none_guard(math.degrees))
236         create_deterministic_function('EXP', 1, none_guard(math.exp))
237         create_deterministic_function('FLOOR', 1, none_guard(math.floor))
238         create_deterministic_function('LN', 1, none_guard(math.log))
239         create_deterministic_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
240         create_deterministic_function('LPAD', 3, _sqlite_lpad)
241         create_deterministic_function('MD5', 1, none_guard(lambda x: hashlib.md5(x.encode()).hexdigest()))
242         create_deterministic_function('MOD', 2, none_guard(math.fmod))
243         create_deterministic_function('PI', 0, lambda: math.pi)
244         create_deterministic_function('POWER', 2, none_guard(operator.pow))
245         create_deterministic_function('RADIANS', 1, none_guard(math.radians))
246         create_deterministic_function('REPEAT', 2, none_guard(operator.mul))
247         create_deterministic_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
248         create_deterministic_function('RPAD', 3, _sqlite_rpad)
249         create_deterministic_function('SHA1', 1, none_guard(lambda x: hashlib.sha1(x.encode()).hexdigest()))
250         create_deterministic_function('SHA224', 1, none_guard(lambda x: hashlib.sha224(x.encode()).hexdigest()))
251         create_deterministic_function('SHA256', 1, none_guard(lambda x: hashlib.sha256(x.encode()).hexdigest()))
252         create_deterministic_function('SHA384', 1, none_guard(lambda x: hashlib.sha384(x.encode()).hexdigest()))
253         create_deterministic_function('SHA512', 1, none_guard(lambda x: hashlib.sha512(x.encode()).hexdigest()))
254         create_deterministic_function('SIGN', 1, none_guard(lambda x: (x > 0) - (x < 0)))
255         create_deterministic_function('SIN', 1, none_guard(math.sin))
256         create_deterministic_function('SQRT', 1, none_guard(math.sqrt))
257         create_deterministic_function('TAN', 1, none_guard(math.tan))
258         # Don't use the built-in RANDOM() function because it returns a value
259         # in the range [2^63, 2^63 - 1] instead of [0, 1).
260         conn.create_function('RAND', 0, random.random)
261         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
262         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
263         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
264         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
265         conn.execute('PRAGMA foreign_keys = ON')
266         return conn
267 
268     def init_connection_state(self):
269         pass
270 
271     def create_cursor(self, name=None):
272         return self.connection.cursor(factory=SQLiteCursorWrapper)
273 
274     @async_unsafe
275     def close(self):
276         self.validate_thread_sharing()
277         # If database is in memory, closing the connection destroys the
278         # database. To prevent accidental data loss, ignore close requests on
279         # an in-memory db.
280         if not self.is_in_memory_db():
281             BaseDatabaseWrapper.close(self)
282 
283     def _savepoint_allowed(self):
284         # When 'isolation_level' is not None, sqlite3 commits before each
285         # savepoint; it's a bug. When it is None, savepoints don't make sense
286         # because autocommit is enabled. The only exception is inside 'atomic'
287         # blocks. To work around that bug, on SQLite, 'atomic' starts a
288         # transaction explicitly rather than simply disable autocommit.
289         return self.in_atomic_block
290 
291     def _set_autocommit(self, autocommit):
292         if autocommit:
293             level = None
294         else:
295             # sqlite3's internal default is ''. It's different from None.
296             # See Modules/_sqlite/connection.c.
297             level = ''
298         # 'isolation_level' is a misleading API.
299         # SQLite always runs at the SERIALIZABLE isolation level.
300         with self.wrap_database_errors:
301             self.connection.isolation_level = level
302 
303     def disable_constraint_checking(self):
304         with self.cursor() as cursor:
305             cursor.execute('PRAGMA foreign_keys = OFF')
306             # Foreign key constraints cannot be turned off while in a multi-
307             # statement transaction. Fetch the current state of the pragma
308             # to determine if constraints are effectively disabled.
309             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]
310         return not bool(enabled)
311 
312     def enable_constraint_checking(self):
313         with self.cursor() as cursor:
314             cursor.execute('PRAGMA foreign_keys = ON')
315 
316     def check_constraints(self, table_names=None):
317         """
318         Check each table name in `table_names` for rows with invalid foreign
319         key references. This method is intended to be used in conjunction with
320         `disable_constraint_checking()` and `enable_constraint_checking()`, to
321         determine if rows with invalid references were entered while constraint
322         checks were off.
323         """
324         if self.features.supports_pragma_foreign_key_check:
325             with self.cursor() as cursor:
326                 if table_names is None:
327                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()
328                 else:
329                     violations = chain.from_iterable(
330                         cursor.execute(
331                             'PRAGMA foreign_key_check(%s)'
332                             % self.ops.quote_name(table_name)
333                         ).fetchall()
334                         for table_name in table_names
335                     )
336                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
337                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:
338                     foreign_key = cursor.execute(
339                         'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)
340                     ).fetchall()[foreign_key_index]
341                     column_name, referenced_column_name = foreign_key[3:5]
342                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
343                     primary_key_value, bad_value = cursor.execute(
344                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (
345                             self.ops.quote_name(primary_key_column_name),
346                             self.ops.quote_name(column_name),
347                             self.ops.quote_name(table_name),
348                         ),
349                         (rowid,),
350                     ).fetchone()
351                     raise IntegrityError(
352                         "The row in table '%s' with primary key '%s' has an "
353                         "invalid foreign key: %s.%s contains a value '%s' that "
354                         "does not have a corresponding value in %s.%s." % (
355                             table_name, primary_key_value, table_name, column_name,
356                             bad_value, referenced_table_name, referenced_column_name
357                         )
358                     )
359         else:
360             with self.cursor() as cursor:
361                 if table_names is None:
362                     table_names = self.introspection.table_names(cursor)
363                 for table_name in table_names:
364                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
365                     if not primary_key_column_name:
366                         continue
367                     key_columns = self.introspection.get_key_columns(cursor, table_name)
368                     for column_name, referenced_table_name, referenced_column_name in key_columns:
369                         cursor.execute(
370                             """
371                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING
372                             LEFT JOIN `%s` as REFERRED
373                             ON (REFERRING.`%s` = REFERRED.`%s`)
374                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL
375                             """
376                             % (
377                                 primary_key_column_name, column_name, table_name,
378                                 referenced_table_name, column_name, referenced_column_name,
379                                 column_name, referenced_column_name,
380                             )
381                         )
382                         for bad_row in cursor.fetchall():
383                             raise IntegrityError(
384                                 "The row in table '%s' with primary key '%s' has an "
385                                 "invalid foreign key: %s.%s contains a value '%s' that "
386                                 "does not have a corresponding value in %s.%s." % (
387                                     table_name, bad_row[0], table_name, column_name,
388                                     bad_row[1], referenced_table_name, referenced_column_name,
389                                 )
390                             )
391 
392     def is_usable(self):
393         return True
394 
395     def _start_transaction_under_autocommit(self):
396         """
397         Start a transaction explicitly in autocommit mode.
398 
399         Staying in autocommit mode works around a bug of sqlite3 that breaks
400         savepoints when autocommit is disabled.
401         """
402         self.cursor().execute("BEGIN")
403 
404     def is_in_memory_db(self):
405         return self.creation.is_in_memory_db(self.settings_dict['NAME'])
406 
407 
408 FORMAT_QMARK_REGEX = _lazy_re_compile(r'(?<!%)%s')
409 
410 
411 class SQLiteCursorWrapper(Database.Cursor):
412     """
413     Django uses "format" style placeholders, but pysqlite2 uses "qmark" style.
414     This fixes it -- but note that if you want to use a literal "%s" in a query,
415     you'll need to use "%%s".
416     """
417     def execute(self, query, params=None):
418         if params is None:
419             return Database.Cursor.execute(self, query)
420         query = self.convert_query(query)
421         return Database.Cursor.execute(self, query, params)
422 
423     def executemany(self, query, param_list):
424         query = self.convert_query(query)
425         return Database.Cursor.executemany(self, query, param_list)
426 
427     def convert_query(self, query):
428         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')
429 
430 
431 def _sqlite_datetime_parse(dt, tzname=None, conn_tzname=None):
432     if dt is None:
433         return None
434     try:
435         dt = backend_utils.typecast_timestamp(dt)
436     except (TypeError, ValueError):
437         return None
438     if conn_tzname:
439         dt = dt.replace(tzinfo=pytz.timezone(conn_tzname))
440     if tzname is not None and tzname != conn_tzname:
441         sign_index = tzname.find('+') + tzname.find('-') + 1
442         if sign_index > -1:
443             sign = tzname[sign_index]
444             tzname, offset = tzname.split(sign)
445             if offset:
446                 hours, minutes = offset.split(':')
447                 offset_delta = datetime.timedelta(hours=int(hours), minutes=int(minutes))
448                 dt += offset_delta if sign == '+' else -offset_delta
449         dt = timezone.localtime(dt, pytz.timezone(tzname))
450     return dt
451 
452 
453 def _sqlite_date_trunc(lookup_type, dt, tzname, conn_tzname):
454     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
455     if dt is None:
456         return None
457     if lookup_type == 'year':
458         return "%i-01-01" % dt.year
459     elif lookup_type == 'quarter':
460         month_in_quarter = dt.month - (dt.month - 1) % 3
461         return '%i-%02i-01' % (dt.year, month_in_quarter)
462     elif lookup_type == 'month':
463         return "%i-%02i-01" % (dt.year, dt.month)
464     elif lookup_type == 'week':
465         dt = dt - datetime.timedelta(days=dt.weekday())
466         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
467     elif lookup_type == 'day':
468         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
469 
470 
471 def _sqlite_time_trunc(lookup_type, dt, tzname, conn_tzname):
472     if dt is None:
473         return None
474     dt_parsed = _sqlite_datetime_parse(dt, tzname, conn_tzname)
475     if dt_parsed is None:
476         try:
477             dt = backend_utils.typecast_time(dt)
478         except (ValueError, TypeError):
479             return None
480     else:
481         dt = dt_parsed
482     if lookup_type == 'hour':
483         return "%02i:00:00" % dt.hour
484     elif lookup_type == 'minute':
485         return "%02i:%02i:00" % (dt.hour, dt.minute)
486     elif lookup_type == 'second':
487         return "%02i:%02i:%02i" % (dt.hour, dt.minute, dt.second)
488 
489 
490 def _sqlite_datetime_cast_date(dt, tzname, conn_tzname):
491     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
492     if dt is None:
493         return None
494     return dt.date().isoformat()
495 
496 
497 def _sqlite_datetime_cast_time(dt, tzname, conn_tzname):
498     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
499     if dt is None:
500         return None
501     return dt.time().isoformat()
502 
503 
504 def _sqlite_datetime_extract(lookup_type, dt, tzname=None, conn_tzname=None):
505     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
506     if dt is None:
507         return None
508     if lookup_type == 'week_day':
509         return (dt.isoweekday() % 7) + 1
510     elif lookup_type == 'iso_week_day':
511         return dt.isoweekday()
512     elif lookup_type == 'week':
513         return dt.isocalendar()[1]
514     elif lookup_type == 'quarter':
515         return math.ceil(dt.month / 3)
516     elif lookup_type == 'iso_year':
517         return dt.isocalendar()[0]
518     else:
519         return getattr(dt, lookup_type)
520 
521 
522 def _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname):
523     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
524     if dt is None:
525         return None
526     if lookup_type == 'year':
527         return "%i-01-01 00:00:00" % dt.year
528     elif lookup_type == 'quarter':
529         month_in_quarter = dt.month - (dt.month - 1) % 3
530         return '%i-%02i-01 00:00:00' % (dt.year, month_in_quarter)
531     elif lookup_type == 'month':
532         return "%i-%02i-01 00:00:00" % (dt.year, dt.month)
533     elif lookup_type == 'week':
534         dt = dt - datetime.timedelta(days=dt.weekday())
535         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
536     elif lookup_type == 'day':
537         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
538     elif lookup_type == 'hour':
539         return "%i-%02i-%02i %02i:00:00" % (dt.year, dt.month, dt.day, dt.hour)
540     elif lookup_type == 'minute':
541         return "%i-%02i-%02i %02i:%02i:00" % (dt.year, dt.month, dt.day, dt.hour, dt.minute)
542     elif lookup_type == 'second':
543         return "%i-%02i-%02i %02i:%02i:%02i" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
544 
545 
546 def _sqlite_time_extract(lookup_type, dt):
547     if dt is None:
548         return None
549     try:
550         dt = backend_utils.typecast_time(dt)
551     except (ValueError, TypeError):
552         return None
553     return getattr(dt, lookup_type)
554 
555 
556 @none_guard
557 def _sqlite_format_dtdelta(conn, lhs, rhs):
558     """
559     LHS and RHS can be either:
560     - An integer number of microseconds
561     - A string representing a datetime
562     """
563     try:
564         real_lhs = datetime.timedelta(0, 0, lhs) if isinstance(lhs, int) else backend_utils.typecast_timestamp(lhs)
565         real_rhs = datetime.timedelta(0, 0, rhs) if isinstance(rhs, int) else backend_utils.typecast_timestamp(rhs)
566         if conn.strip() == '+':
567             out = real_lhs + real_rhs
568         else:
569             out = real_lhs - real_rhs
570     except (ValueError, TypeError):
571         return None
572     # typecast_timestamp returns a date or a datetime without timezone.
573     # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]"
574     return str(out)
575 
576 
577 @none_guard
578 def _sqlite_time_diff(lhs, rhs):
579     left = backend_utils.typecast_time(lhs)
580     right = backend_utils.typecast_time(rhs)
581     return (
582         (left.hour * 60 * 60 * 1000000) +
583         (left.minute * 60 * 1000000) +
584         (left.second * 1000000) +
585         (left.microsecond) -
586         (right.hour * 60 * 60 * 1000000) -
587         (right.minute * 60 * 1000000) -
588         (right.second * 1000000) -
589         (right.microsecond)
590     )
591 
592 
593 @none_guard
594 def _sqlite_timestamp_diff(lhs, rhs):
595     left = backend_utils.typecast_timestamp(lhs)
596     right = backend_utils.typecast_timestamp(rhs)
597     return duration_microseconds(left - right)
598 
599 
600 @none_guard
601 def _sqlite_regexp(re_pattern, re_string):
602     return bool(re.search(re_pattern, str(re_string)))
603 
604 
605 @none_guard
606 def _sqlite_lpad(text, length, fill_text):
607     if len(text) >= length:
608         return text[:length]
609     return (fill_text * length)[:length - len(text)] + text
610 
611 
612 @none_guard
613 def _sqlite_rpad(text, length, fill_text):
614     return (text + fill_text * length)[:length]

</code><intended_behavior>Introduce version checking logic during the initialization phase to ensure the SQLite version is 3.9.0 or higher. If the version is lower, the system should raise a ConfigurationError (or similar) with a message indicating that the SQLite version is unsupported.</intended_behavior>, <file>django/db/backends/sqlite3/features.py</file>
<class>None</class>
<method>None</method>
<code>
1 import operator
2 import platform
3 
4 from django.db import transaction
5 from django.db.backends.base.features import BaseDatabaseFeatures
6 from django.db.utils import OperationalError
7 from django.utils.functional import cached_property
8 
9 from .base import Database
10 
11 
12 class DatabaseFeatures(BaseDatabaseFeatures):
13     # SQLite can read from a cursor since SQLite 3.6.5, subject to the caveat
14     # that statements within a connection aren't isolated from each other. See
15     # https://sqlite.org/isolation.html.
16     can_use_chunked_reads = True
17     test_db_allows_multiple_connections = False
18     supports_unspecified_pk = True
19     supports_timezones = False
20     max_query_params = 999
21     supports_mixed_date_datetime_comparisons = False
22     supports_transactions = True
23     atomic_transactions = False
24     can_rollback_ddl = True
25     can_create_inline_fk = False
26     supports_paramstyle_pyformat = False
27     can_clone_databases = True
28     supports_temporal_subtraction = True
29     ignores_table_name_case = True
30     supports_cast_with_precision = False
31     time_cast_precision = 3
32     can_release_savepoints = True
33     # Is "ALTER TABLE ... RENAME COLUMN" supported?
34     can_alter_table_rename_column = Database.sqlite_version_info >= (3, 25, 0)
35     supports_parentheses_in_compound = False
36     # Deferred constraint checks can be emulated on SQLite < 3.20 but not in a
37     # reasonably performant way.
38     supports_pragma_foreign_key_check = Database.sqlite_version_info >= (3, 20, 0)
39     can_defer_constraint_checks = supports_pragma_foreign_key_check
40     supports_functions_in_partial_indexes = Database.sqlite_version_info >= (3, 15, 0)
41     supports_over_clause = Database.sqlite_version_info >= (3, 25, 0)
42     supports_frame_range_fixed_distance = Database.sqlite_version_info >= (3, 28, 0)
43     supports_aggregate_filter_clause = Database.sqlite_version_info >= (3, 30, 1)
44     supports_order_by_nulls_modifier = Database.sqlite_version_info >= (3, 30, 0)
45     order_by_nulls_first = True
46     supports_json_field_contains = False
47     test_collations = {
48         'ci': 'nocase',
49         'cs': 'binary',
50         'non_default': 'nocase',
51     }
52 
53     @cached_property
54     def django_test_skips(self):
55         skips = {
56             'SQLite stores values rounded to 15 significant digits.': {
57                 'model_fields.test_decimalfield.DecimalFieldTests.test_fetch_from_db_without_float_rounding',
58             },
59             'SQLite naively remakes the table on field alteration.': {
60                 'schema.tests.SchemaTests.test_unique_no_unnecessary_fk_drops',
61                 'schema.tests.SchemaTests.test_unique_and_reverse_m2m',
62                 'schema.tests.SchemaTests.test_alter_field_default_doesnt_perform_queries',
63                 'schema.tests.SchemaTests.test_rename_column_renames_deferred_sql_references',
64             },
65             "SQLite doesn't have a constraint.": {
66                 'model_fields.test_integerfield.PositiveIntegerFieldTests.test_negative_values',
67             },
68         }
69         if Database.sqlite_version_info < (3, 27):
70             skips.update({
71                 'Nondeterministic failure on SQLite < 3.27.': {
72                     'expressions_window.tests.WindowFunctionTests.test_subquery_row_range_rank',
73                 },
74             })
75         if self.connection.is_in_memory_db():
76             skips.update({
77                 "the sqlite backend's close() method is a no-op when using an "
78                 "in-memory database": {
79                     'servers.test_liveserverthread.LiveServerThreadTest.test_closes_connections',
80                 },
81             })
82         return skips
83 
84     @cached_property
85     def supports_atomic_references_rename(self):
86         # SQLite 3.28.0 bundled with MacOS 10.15 does not support renaming
87         # references atomically.
88         if platform.mac_ver()[0].startswith('10.15.') and Database.sqlite_version_info == (3, 28, 0):
89             return False
90         return Database.sqlite_version_info >= (3, 26, 0)
91 
92     @cached_property
93     def introspected_field_types(self):
94         return{
95             **super().introspected_field_types,
96             'BigAutoField': 'AutoField',
97             'DurationField': 'BigIntegerField',
98             'GenericIPAddressField': 'CharField',
99             'SmallAutoField': 'AutoField',
100         }
101 
102     @cached_property
103     def supports_json_field(self):
104         with self.connection.cursor() as cursor:
105             try:
106                 with transaction.atomic(self.connection.alias):
107                     cursor.execute('SELECT JSON(\'{"a": "b"}\')')
108             except OperationalError:
109                 return False
110         return True
111 
112     can_introspect_json_field = property(operator.attrgetter('supports_json_field'))
113     has_json_object_function = property(operator.attrgetter('supports_json_field'))

</code><intended_behavior>Update the feature flags related to SQLite capabilities to conditionally enable these based on the SQLite version being 3.9.0 or higher.</intended_behavior>]
2025-10-17 12:41:03.168 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 12:41:03.168 | INFO     | Search-only: skipping patch selection
2025-10-17 12:41:03.312 | INFO     | Task django__django-13821 completed successfully.
2025-10-17 12:41:03.312 | INFO     | No patch generated. You can try running ACR again.
