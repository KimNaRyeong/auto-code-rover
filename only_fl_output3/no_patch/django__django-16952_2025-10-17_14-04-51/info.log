2025-10-17 14:04:51.532 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 14:04:54.801 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=730, output_tokens=12, cost=0.007660
2025-10-17 14:05:10.591 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=910, output_tokens=674, cost=0.029320
2025-10-17 14:05:11.822 | INFO     | registered non reproducing test 0
2025-10-17 14:05:31.693 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2124, output_tokens=721, cost=0.042870
2025-10-17 14:05:32.851 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:05:41.023 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1002, output_tokens=339, cost=0.020190
2025-10-17 14:05:41.030 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:05:46.167 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=693, output_tokens=127, cost=0.010740
2025-10-17 14:05:46.169 | DEBUG    | Extracted a valid json.
2025-10-17 14:05:46.174 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ItalianRestaurantManyParents\")",
        "search_class_in_file(\"ItalianRestaurant\", \"tests/model_inheritance/models.py\")",
        "search_class_in_file(\"Place\", \"tests/model_inheritance/models.py\")",
        "search_method_in_class(\"_save_parents\", \"Model\")",
        "search_method_in_file(\"create\", \"/django/django/db/models/query.py\")",
        "search_code_in_file(\"def test_create_diamond_mti_common_parents(self):\", \"tests/model_inheritance/tests.py\")"
    ],
    "bug_locations": []
}
2025-10-17 14:05:46.193 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:05:46.194 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:06:04.321 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2092, output_tokens=755, cost=0.043570
2025-10-17 14:06:04.336 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:06:13.601 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3063, output_tokens=325, cost=0.040380
2025-10-17 14:06:13.609 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:06:22.413 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=679, output_tokens=322, cost=0.016450
2025-10-17 14:06:22.414 | DEBUG    | Extracted a valid json.
2025-10-17 14:06:22.414 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/base.py",
            "class": "Model",
            "method": "_save_parents",
            "intended_behavior": "The `_save_parents` method should ensure that when saving models with complex multi-table inheritance, including scenarios with multiple parents (diamond inheritance or otherwise), it correctly handles the link fields without throwing an `AttributeError`. Specifically, the method should: Verify the presence of an `attname` attribute for all link fields (`OneToOneField` or otherwise) involved in the inheritance chain. This involves ensuring that the code gracefully handles scenarios where a link field might not exhibit the expected attributes due to the complexity of the MTI structure. Correctly assign or propagate primary key values (and potentially other necessary field values) from parent models to child models, ensuring that database integrity and referential links are maintained without error. Incorporate additional logic or checks, if necessary, to account for the intricate MTI scenarios where a standard handling of link fields and attribute assignments might not suffice. This could involve refining the condition on lines 913-914 or adding supplementary condition statements to manage edge cases more effectively. The resolution should ensure that the creation of objects through Django's ORM can handle any form or complexity of model inheritance without raising exceptions due to handling link fields. This fix should preserve the current functionality for simpler inheritance models while extending support to cover the edge cases introduced by nested, complex, or multiple inheritance paths, ensuring robust, error-free object creation across the board."
        }
    ]
}
2025-10-17 14:06:22.431 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/base.py</file>
<class>Model</class>
<method>_save_parents</method>
<code>
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted

</code><intended_behavior>The `_save_parents` method should ensure that when saving models with complex multi-table inheritance, including scenarios with multiple parents (diamond inheritance or otherwise), it correctly handles the link fields without throwing an `AttributeError`. Specifically, the method should: Verify the presence of an `attname` attribute for all link fields (`OneToOneField` or otherwise) involved in the inheritance chain. This involves ensuring that the code gracefully handles scenarios where a link field might not exhibit the expected attributes due to the complexity of the MTI structure. Correctly assign or propagate primary key values (and potentially other necessary field values) from parent models to child models, ensuring that database integrity and referential links are maintained without error. Incorporate additional logic or checks, if necessary, to account for the intricate MTI scenarios where a standard handling of link fields and attribute assignments might not suffice. This could involve refining the condition on lines 913-914 or adding supplementary condition statements to manage edge cases more effectively. The resolution should ensure that the creation of objects through Django's ORM can handle any form or complexity of model inheritance without raising exceptions due to handling link fields. This fix should preserve the current functionality for simpler inheritance models while extending support to cover the edge cases introduced by nested, complex, or multiple inheritance paths, ensuring robust, error-free object creation across the board.</intended_behavior>, <file>django/db/models/base.py</file>
<class>Model</class>
<method>None</method>
<code>
459 class Model(AltersData, metaclass=ModelBase):
460     def __init__(self, *args, **kwargs):
461         # Alias some things as locals to avoid repeat global lookups
462         cls = self.__class__
463         opts = self._meta
464         _setattr = setattr
465         _DEFERRED = DEFERRED
466         if opts.abstract:
467             raise TypeError("Abstract models cannot be instantiated.")
468 
469         pre_init.send(sender=cls, args=args, kwargs=kwargs)
470 
471         # Set up the storage for instance state
472         self._state = ModelState()
473 
474         # There is a rather weird disparity here; if kwargs, it's set, then args
475         # overrides it. It should be one or the other; don't duplicate the work
476         # The reason for the kwargs check is that standard iterator passes in by
477         # args, and instantiation for iteration is 33% faster.
478         if len(args) > len(opts.concrete_fields):
479             # Daft, but matches old exception sans the err msg.
480             raise IndexError("Number of args exceeds number of fields")
481 
482         if not kwargs:
483             fields_iter = iter(opts.concrete_fields)
484             # The ordering of the zip calls matter - zip throws StopIteration
485             # when an iter throws it. So if the first iter throws it, the second
486             # is *not* consumed. We rely on this, so don't change the order
487             # without changing the logic.
488             for val, field in zip(args, fields_iter):
489                 if val is _DEFERRED:
490                     continue
491                 _setattr(self, field.attname, val)
492         else:
493             # Slower, kwargs-ready version.
494             fields_iter = iter(opts.fields)
495             for val, field in zip(args, fields_iter):
496                 if val is _DEFERRED:
497                     continue
498                 _setattr(self, field.attname, val)
499                 if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
500                     raise TypeError(
501                         f"{cls.__qualname__}() got both positional and "
502                         f"keyword arguments for field '{field.name}'."
503                     )
504 
505         # Now we're left with the unprocessed fields that *must* come from
506         # keywords, or default.
507 
508         for field in fields_iter:
509             is_related_object = False
510             # Virtual field
511             if field.attname not in kwargs and field.column is None:
512                 continue
513             if kwargs:
514                 if isinstance(field.remote_field, ForeignObjectRel):
515                     try:
516                         # Assume object instance was passed in.
517                         rel_obj = kwargs.pop(field.name)
518                         is_related_object = True
519                     except KeyError:
520                         try:
521                             # Object instance wasn't passed in -- must be an ID.
522                             val = kwargs.pop(field.attname)
523                         except KeyError:
524                             val = field.get_default()
525                 else:
526                     try:
527                         val = kwargs.pop(field.attname)
528                     except KeyError:
529                         # This is done with an exception rather than the
530                         # default argument on pop because we don't want
531                         # get_default() to be evaluated, and then not used.
532                         # Refs #12057.
533                         val = field.get_default()
534             else:
535                 val = field.get_default()
536 
537             if is_related_object:
538                 # If we are passed a related instance, set it using the
539                 # field.name instead of field.attname (e.g. "user" instead of
540                 # "user_id") so that the object gets properly cached (and type
541                 # checked) by the RelatedObjectDescriptor.
542                 if rel_obj is not _DEFERRED:
543                     _setattr(self, field.name, rel_obj)
544             else:
545                 if val is not _DEFERRED:
546                     _setattr(self, field.attname, val)
547 
548         if kwargs:
549             property_names = opts._property_names
550             unexpected = ()
551             for prop, value in kwargs.items():
552                 # Any remaining kwargs must correspond to properties or virtual
553                 # fields.
554                 if prop in property_names:
555                     if value is not _DEFERRED:
556                         _setattr(self, prop, value)
557                 else:
558                     try:
559                         opts.get_field(prop)
560                     except FieldDoesNotExist:
561                         unexpected += (prop,)
562                     else:
563                         if value is not _DEFERRED:
564                             _setattr(self, prop, value)
565             if unexpected:
566                 unexpected_names = ", ".join(repr(n) for n in unexpected)
567                 raise TypeError(
568                     f"{cls.__name__}() got unexpected keyword arguments: "
569                     f"{unexpected_names}"
570                 )
571         super().__init__()
572         post_init.send(sender=cls, instance=self)
573 
574     @classmethod
575     def from_db(cls, db, field_names, values):
576         if len(values) != len(cls._meta.concrete_fields):
577             values_iter = iter(values)
578             values = [
579                 next(values_iter) if f.attname in field_names else DEFERRED
580                 for f in cls._meta.concrete_fields
581             ]
582         new = cls(*values)
583         new._state.adding = False
584         new._state.db = db
585         return new
586 
587     def __repr__(self):
588         return "<%s: %s>" % (self.__class__.__name__, self)
589 
590     def __str__(self):
591         return "%s object (%s)" % (self.__class__.__name__, self.pk)
592 
593     def __eq__(self, other):
594         if not isinstance(other, Model):
595             return NotImplemented
596         if self._meta.concrete_model != other._meta.concrete_model:
597             return False
598         my_pk = self.pk
599         if my_pk is None:
600             return self is other
601         return my_pk == other.pk
602 
603     def __hash__(self):
604         if self.pk is None:
605             raise TypeError("Model instances without primary key value are unhashable")
606         return hash(self.pk)
607 
608     def __reduce__(self):
609         data = self.__getstate__()
610         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
611         class_id = self._meta.app_label, self._meta.object_name
612         return model_unpickle, (class_id,), data
613 
614     def __getstate__(self):
615         """Hook to allow choosing the attributes to pickle."""
616         state = self.__dict__.copy()
617         state["_state"] = copy.copy(state["_state"])
618         state["_state"].fields_cache = state["_state"].fields_cache.copy()
619         # memoryview cannot be pickled, so cast it to bytes and store
620         # separately.
621         _memoryview_attrs = []
622         for attr, value in state.items():
623             if isinstance(value, memoryview):
624                 _memoryview_attrs.append((attr, bytes(value)))
625         if _memoryview_attrs:
626             state["_memoryview_attrs"] = _memoryview_attrs
627             for attr, value in _memoryview_attrs:
628                 state.pop(attr)
629         return state
630 
631     def __setstate__(self, state):
632         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
633         if pickled_version:
634             if pickled_version != django.__version__:
635                 warnings.warn(
636                     "Pickled model instance's Django version %s does not "
637                     "match the current version %s."
638                     % (pickled_version, django.__version__),
639                     RuntimeWarning,
640                     stacklevel=2,
641                 )
642         else:
643             warnings.warn(
644                 "Pickled model instance's Django version is not specified.",
645                 RuntimeWarning,
646                 stacklevel=2,
647             )
648         if "_memoryview_attrs" in state:
649             for attr, value in state.pop("_memoryview_attrs"):
650                 state[attr] = memoryview(value)
651         self.__dict__.update(state)
652 
653     def _get_pk_val(self, meta=None):
654         meta = meta or self._meta
655         return getattr(self, meta.pk.attname)
656 
657     def _set_pk_val(self, value):
658         for parent_link in self._meta.parents.values():
659             if parent_link and parent_link != self._meta.pk:
660                 setattr(self, parent_link.target_field.attname, value)
661         return setattr(self, self._meta.pk.attname, value)
662 
663     pk = property(_get_pk_val, _set_pk_val)
664 
665     def get_deferred_fields(self):
666         """
667         Return a set containing names of deferred fields for this instance.
668         """
669         return {
670             f.attname
671             for f in self._meta.concrete_fields
672             if f.attname not in self.__dict__
673         }
674 
675     def refresh_from_db(self, using=None, fields=None):
676         """
677         Reload field values from the database.
678 
679         By default, the reloading happens from the database this instance was
680         loaded from, or by the read router if this instance wasn't loaded from
681         any database. The using parameter will override the default.
682 
683         Fields can be used to specify which fields to reload. The fields
684         should be an iterable of field attnames. If fields is None, then
685         all non-deferred fields are reloaded.
686 
687         When accessing deferred fields of an instance, the deferred loading
688         of the field will call this method.
689         """
690         if fields is None:
691             self._prefetched_objects_cache = {}
692         else:
693             prefetched_objects_cache = getattr(self, "_prefetched_objects_cache", ())
694             for field in fields:
695                 if field in prefetched_objects_cache:
696                     del prefetched_objects_cache[field]
697                     fields.remove(field)
698             if not fields:
699                 return
700             if any(LOOKUP_SEP in f for f in fields):
701                 raise ValueError(
702                     'Found "%s" in fields argument. Relations and transforms '
703                     "are not allowed in fields." % LOOKUP_SEP
704                 )
705 
706         hints = {"instance": self}
707         db_instance_qs = self.__class__._base_manager.db_manager(
708             using, hints=hints
709         ).filter(pk=self.pk)
710 
711         # Use provided fields, if not set then reload all non-deferred fields.
712         deferred_fields = self.get_deferred_fields()
713         if fields is not None:
714             fields = list(fields)
715             db_instance_qs = db_instance_qs.only(*fields)
716         elif deferred_fields:
717             fields = [
718                 f.attname
719                 for f in self._meta.concrete_fields
720                 if f.attname not in deferred_fields
721             ]
722             db_instance_qs = db_instance_qs.only(*fields)
723 
724         db_instance = db_instance_qs.get()
725         non_loaded_fields = db_instance.get_deferred_fields()
726         for field in self._meta.concrete_fields:
727             if field.attname in non_loaded_fields:
728                 # This field wasn't refreshed - skip ahead.
729                 continue
730             setattr(self, field.attname, getattr(db_instance, field.attname))
731             # Clear cached foreign keys.
732             if field.is_relation and field.is_cached(self):
733                 field.delete_cached_value(self)
734 
735         # Clear cached relations.
736         for field in self._meta.related_objects:
737             if field.is_cached(self):
738                 field.delete_cached_value(self)
739 
740         # Clear cached private relations.
741         for field in self._meta.private_fields:
742             if field.is_relation and field.is_cached(self):
743                 field.delete_cached_value(self)
744 
745         self._state.db = db_instance._state.db
746 
747     async def arefresh_from_db(self, using=None, fields=None):
748         return await sync_to_async(self.refresh_from_db)(using=using, fields=fields)
749 
750     def serializable_value(self, field_name):
751         """
752         Return the value of the field name for this instance. If the field is
753         a foreign key, return the id value instead of the object. If there's
754         no Field object with this name on the model, return the model
755         attribute's value.
756 
757         Used to serialize a field's value (in the serializer, or form output,
758         for example). Normally, you would just access the attribute directly
759         and not use this method.
760         """
761         try:
762             field = self._meta.get_field(field_name)
763         except FieldDoesNotExist:
764             return getattr(self, field_name)
765         return getattr(self, field.attname)
766 
767     def save(
768         self, force_insert=False, force_update=False, using=None, update_fields=None
769     ):
770         """
771         Save the current instance. Override this in a subclass if you want to
772         control the saving process.
773 
774         The 'force_insert' and 'force_update' parameters can be used to insist
775         that the "save" must be an SQL insert or update (or equivalent for
776         non-SQL backends), respectively. Normally, they should not be set.
777         """
778         self._prepare_related_fields_for_save(operation_name="save")
779 
780         using = using or router.db_for_write(self.__class__, instance=self)
781         if force_insert and (force_update or update_fields):
782             raise ValueError("Cannot force both insert and updating in model saving.")
783 
784         deferred_fields = self.get_deferred_fields()
785         if update_fields is not None:
786             # If update_fields is empty, skip the save. We do also check for
787             # no-op saves later on for inheritance cases. This bailout is
788             # still needed for skipping signal sending.
789             if not update_fields:
790                 return
791 
792             update_fields = frozenset(update_fields)
793             field_names = self._meta._non_pk_concrete_field_names
794             non_model_fields = update_fields.difference(field_names)
795 
796             if non_model_fields:
797                 raise ValueError(
798                     "The following fields do not exist in this model, are m2m "
799                     "fields, or are non-concrete fields: %s"
800                     % ", ".join(non_model_fields)
801                 )
802 
803         # If saving to the same database, and this model is deferred, then
804         # automatically do an "update_fields" save on the loaded fields.
805         elif not force_insert and deferred_fields and using == self._state.db:
806             field_names = set()
807             for field in self._meta.concrete_fields:
808                 if not field.primary_key and not hasattr(field, "through"):
809                     field_names.add(field.attname)
810             loaded_fields = field_names.difference(deferred_fields)
811             if loaded_fields:
812                 update_fields = frozenset(loaded_fields)
813 
814         self.save_base(
815             using=using,
816             force_insert=force_insert,
817             force_update=force_update,
818             update_fields=update_fields,
819         )
820 
821     save.alters_data = True
822 
823     async def asave(
824         self, force_insert=False, force_update=False, using=None, update_fields=None
825     ):
826         return await sync_to_async(self.save)(
827             force_insert=force_insert,
828             force_update=force_update,
829             using=using,
830             update_fields=update_fields,
831         )
832 
833     asave.alters_data = True
834 
835     def save_base(
836         self,
837         raw=False,
838         force_insert=False,
839         force_update=False,
840         using=None,
841         update_fields=None,
842     ):
843         """
844         Handle the parts of saving which should be done only once per save,
845         yet need to be done in raw saves, too. This includes some sanity
846         checks and signal sending.
847 
848         The 'raw' argument is telling save_base not to save any parent
849         models and not to do any changes to the values before save. This
850         is used by fixture loading.
851         """
852         using = using or router.db_for_write(self.__class__, instance=self)
853         assert not (force_insert and (force_update or update_fields))
854         assert update_fields is None or update_fields
855         cls = origin = self.__class__
856         # Skip proxies, but keep the origin as the proxy model.
857         if cls._meta.proxy:
858             cls = cls._meta.concrete_model
859         meta = cls._meta
860         if not meta.auto_created:
861             pre_save.send(
862                 sender=origin,
863                 instance=self,
864                 raw=raw,
865                 using=using,
866                 update_fields=update_fields,
867             )
868         # A transaction isn't needed if one query is issued.
869         if meta.parents:
870             context_manager = transaction.atomic(using=using, savepoint=False)
871         else:
872             context_manager = transaction.mark_for_rollback_on_error(using=using)
873         with context_manager:
874             parent_inserted = False
875             if not raw:
876                 parent_inserted = self._save_parents(cls, using, update_fields)
877             updated = self._save_table(
878                 raw,
879                 cls,
880                 force_insert or parent_inserted,
881                 force_update,
882                 using,
883                 update_fields,
884             )
885         # Store the database on which the object was saved
886         self._state.db = using
887         # Once saved, this is no longer a to-be-added instance.
888         self._state.adding = False
889 
890         # Signal that the save is complete
891         if not meta.auto_created:
892             post_save.send(
893                 sender=origin,
894                 instance=self,
895                 created=(not updated),
896                 update_fields=update_fields,
897                 raw=raw,
898                 using=using,
899             )
900 
901     save_base.alters_data = True
902 
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted
946 
947     def _save_table(
948         self,
949         raw=False,
950         cls=None,
951         force_insert=False,
952         force_update=False,
953         using=None,
954         update_fields=None,
955     ):
956         """
957         Do the heavy-lifting involved in saving. Update or insert the data
958         for a single table.
959         """
960         meta = cls._meta
961         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
962 
963         if update_fields:
964             non_pks = [
965                 f
966                 for f in non_pks
967                 if f.name in update_fields or f.attname in update_fields
968             ]
969 
970         pk_val = self._get_pk_val(meta)
971         if pk_val is None:
972             pk_val = meta.pk.get_pk_value_on_save(self)
973             setattr(self, meta.pk.attname, pk_val)
974         pk_set = pk_val is not None
975         if not pk_set and (force_update or update_fields):
976             raise ValueError("Cannot force an update in save() with no primary key.")
977         updated = False
978         # Skip an UPDATE when adding an instance and primary key has a default.
979         if (
980             not raw
981             and not force_insert
982             and self._state.adding
983             and (
984                 (meta.pk.default and meta.pk.default is not NOT_PROVIDED)
985                 or (meta.pk.db_default and meta.pk.db_default is not NOT_PROVIDED)
986             )
987         ):
988             force_insert = True
989         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
990         if pk_set and not force_insert:
991             base_qs = cls._base_manager.using(using)
992             values = [
993                 (
994                     f,
995                     None,
996                     (getattr(self, f.attname) if raw else f.pre_save(self, False)),
997                 )
998                 for f in non_pks
999             ]
1000             forced_update = update_fields or force_update
1001             updated = self._do_update(
1002                 base_qs, using, pk_val, values, update_fields, forced_update
1003             )
1004             if force_update and not updated:
1005                 raise DatabaseError("Forced update did not affect any rows.")
1006             if update_fields and not updated:
1007                 raise DatabaseError("Save with update_fields did not affect any rows.")
1008         if not updated:
1009             if meta.order_with_respect_to:
1010                 # If this is a model with an order_with_respect_to
1011                 # autopopulate the _order field
1012                 field = meta.order_with_respect_to
1013                 filter_args = field.get_filter_kwargs_for_object(self)
1014                 self._order = (
1015                     cls._base_manager.using(using)
1016                     .filter(**filter_args)
1017                     .aggregate(
1018                         _order__max=Coalesce(
1019                             ExpressionWrapper(
1020                                 Max("_order") + Value(1), output_field=IntegerField()
1021                             ),
1022                             Value(0),
1023                         ),
1024                     )["_order__max"]
1025                 )
1026             fields = meta.local_concrete_fields
1027             if not pk_set:
1028                 fields = [f for f in fields if f is not meta.auto_field]
1029 
1030             returning_fields = meta.db_returning_fields
1031             results = self._do_insert(
1032                 cls._base_manager, using, fields, returning_fields, raw
1033             )
1034             if results:
1035                 for value, field in zip(results[0], returning_fields):
1036                     setattr(self, field.attname, value)
1037         return updated
1038 
1039     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
1040         """
1041         Try to update the model. Return True if the model was updated (if an
1042         update query was done and a matching row was found in the DB).
1043         """
1044         filtered = base_qs.filter(pk=pk_val)
1045         if not values:
1046             # We can end up here when saving a model in inheritance chain where
1047             # update_fields doesn't target any field in current model. In that
1048             # case we just say the update succeeded. Another case ending up here
1049             # is a model with just PK - in that case check that the PK still
1050             # exists.
1051             return update_fields is not None or filtered.exists()
1052         if self._meta.select_on_save and not forced_update:
1053             return (
1054                 filtered.exists()
1055                 and
1056                 # It may happen that the object is deleted from the DB right after
1057                 # this check, causing the subsequent UPDATE to return zero matching
1058                 # rows. The same result can occur in some rare cases when the
1059                 # database returns zero despite the UPDATE being executed
1060                 # successfully (a row is matched and updated). In order to
1061                 # distinguish these two cases, the object's existence in the
1062                 # database is again checked for if the UPDATE query returns 0.
1063                 (filtered._update(values) > 0 or filtered.exists())
1064             )
1065         return filtered._update(values) > 0
1066 
1067     def _do_insert(self, manager, using, fields, returning_fields, raw):
1068         """
1069         Do an INSERT. If returning_fields is defined then this method should
1070         return the newly created data for the model.
1071         """
1072         return manager._insert(
1073             [self],
1074             fields=fields,
1075             returning_fields=returning_fields,
1076             using=using,
1077             raw=raw,
1078         )
1079 
1080     def _prepare_related_fields_for_save(self, operation_name, fields=None):
1081         # Ensure that a model instance without a PK hasn't been assigned to
1082         # a ForeignKey, GenericForeignKey or OneToOneField on this model. If
1083         # the field is nullable, allowing the save would result in silent data
1084         # loss.
1085         for field in self._meta.concrete_fields:
1086             if fields and field not in fields:
1087                 continue
1088             # If the related field isn't cached, then an instance hasn't been
1089             # assigned and there's no need to worry about this check.
1090             if field.is_relation and field.is_cached(self):
1091                 obj = getattr(self, field.name, None)
1092                 if not obj:
1093                     continue
1094                 # A pk may have been assigned manually to a model instance not
1095                 # saved to the database (or auto-generated in a case like
1096                 # UUIDField), but we allow the save to proceed and rely on the
1097                 # database to raise an IntegrityError if applicable. If
1098                 # constraints aren't supported by the database, there's the
1099                 # unavoidable risk of data corruption.
1100                 if obj.pk is None:
1101                     # Remove the object from a related instance cache.
1102                     if not field.remote_field.multiple:
1103                         field.remote_field.delete_cached_value(obj)
1104                     raise ValueError(
1105                         "%s() prohibited to prevent data loss due to unsaved "
1106                         "related object '%s'." % (operation_name, field.name)
1107                     )
1108                 elif getattr(self, field.attname) in field.empty_values:
1109                     # Set related object if it has been saved after an
1110                     # assignment.
1111                     setattr(self, field.name, obj)
1112                 # If the relationship's pk/to_field was changed, clear the
1113                 # cached relationship.
1114                 if getattr(obj, field.target_field.attname) != getattr(
1115                     self, field.attname
1116                 ):
1117                     field.delete_cached_value(self)
1118         # GenericForeignKeys are private.
1119         for field in self._meta.private_fields:
1120             if fields and field not in fields:
1121                 continue
1122             if (
1123                 field.is_relation
1124                 and field.is_cached(self)
1125                 and hasattr(field, "fk_field")
1126             ):
1127                 obj = field.get_cached_value(self, default=None)
1128                 if obj and obj.pk is None:
1129                     raise ValueError(
1130                         f"{operation_name}() prohibited to prevent data loss due to "
1131                         f"unsaved related object '{field.name}'."
1132                     )
1133 
1134     def delete(self, using=None, keep_parents=False):
1135         if self.pk is None:
1136             raise ValueError(
1137                 "%s object can't be deleted because its %s attribute is set "
1138                 "to None." % (self._meta.object_name, self._meta.pk.attname)
1139             )
1140         using = using or router.db_for_write(self.__class__, instance=self)
1141         collector = Collector(using=using, origin=self)
1142         collector.collect([self], keep_parents=keep_parents)
1143         return collector.delete()
1144 
1145     delete.alters_data = True
1146 
1147     async def adelete(self, using=None, keep_parents=False):
1148         return await sync_to_async(self.delete)(
1149             using=using,
1150             keep_parents=keep_parents,
1151         )
1152 
1153     adelete.alters_data = True
1154 
1155     def _get_FIELD_display(self, field):
1156         value = getattr(self, field.attname)
1157         choices_dict = dict(make_hashable(field.flatchoices))
1158         # force_str() to coerce lazy strings.
1159         return force_str(
1160             choices_dict.get(make_hashable(value), value), strings_only=True
1161         )
1162 
1163     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
1164         if not self.pk:
1165             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
1166         op = "gt" if is_next else "lt"
1167         order = "" if is_next else "-"
1168         param = getattr(self, field.attname)
1169         q = Q.create([(field.name, param), (f"pk__{op}", self.pk)], connector=Q.AND)
1170         q = Q.create([q, (f"{field.name}__{op}", param)], connector=Q.OR)
1171         qs = (
1172             self.__class__._default_manager.using(self._state.db)
1173             .filter(**kwargs)
1174             .filter(q)
1175             .order_by("%s%s" % (order, field.name), "%spk" % order)
1176         )
1177         try:
1178             return qs[0]
1179         except IndexError:
1180             raise self.DoesNotExist(
1181                 "%s matching query does not exist." % self.__class__._meta.object_name
1182             )
1183 
1184     def _get_next_or_previous_in_order(self, is_next):
1185         cachename = "__%s_order_cache" % is_next
1186         if not hasattr(self, cachename):
1187             op = "gt" if is_next else "lt"
1188             order = "_order" if is_next else "-_order"
1189             order_field = self._meta.order_with_respect_to
1190             filter_args = order_field.get_filter_kwargs_for_object(self)
1191             obj = (
1192                 self.__class__._default_manager.filter(**filter_args)
1193                 .filter(
1194                     **{
1195                         "_order__%s"
1196                         % op: self.__class__._default_manager.values("_order").filter(
1197                             **{self._meta.pk.name: self.pk}
1198                         )
1199                     }
1200                 )
1201                 .order_by(order)[:1]
1202                 .get()
1203             )
1204             setattr(self, cachename, obj)
1205         return getattr(self, cachename)
1206 
1207     def _get_field_value_map(self, meta, exclude=None):
1208         if exclude is None:
1209             exclude = set()
1210         meta = meta or self._meta
1211         return {
1212             field.name: Value(getattr(self, field.attname), field)
1213             for field in meta.local_concrete_fields
1214             if field.name not in exclude
1215         }
1216 
1217     def prepare_database_save(self, field):
1218         if self.pk is None:
1219             raise ValueError(
1220                 "Unsaved model instance %r cannot be used in an ORM query." % self
1221             )
1222         return getattr(self, field.remote_field.get_related_field().attname)
1223 
1224     def clean(self):
1225         """
1226         Hook for doing any extra model-wide validation after clean() has been
1227         called on every field by self.clean_fields. Any ValidationError raised
1228         by this method will not be associated with a particular field; it will
1229         have a special-case association with the field defined by NON_FIELD_ERRORS.
1230         """
1231         pass
1232 
1233     def validate_unique(self, exclude=None):
1234         """
1235         Check unique constraints on the model and raise ValidationError if any
1236         failed.
1237         """
1238         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1239 
1240         errors = self._perform_unique_checks(unique_checks)
1241         date_errors = self._perform_date_checks(date_checks)
1242 
1243         for k, v in date_errors.items():
1244             errors.setdefault(k, []).extend(v)
1245 
1246         if errors:
1247             raise ValidationError(errors)
1248 
1249     def _get_unique_checks(self, exclude=None, include_meta_constraints=False):
1250         """
1251         Return a list of checks to perform. Since validate_unique() could be
1252         called from a ModelForm, some fields may have been excluded; we can't
1253         perform a unique check on a model that is missing fields involved
1254         in that check. Fields that did not validate should also be excluded,
1255         but they need to be passed in via the exclude argument.
1256         """
1257         if exclude is None:
1258             exclude = set()
1259         unique_checks = []
1260 
1261         unique_togethers = [(self.__class__, self._meta.unique_together)]
1262         constraints = []
1263         if include_meta_constraints:
1264             constraints = [(self.__class__, self._meta.total_unique_constraints)]
1265         for parent_class in self._meta.get_parent_list():
1266             if parent_class._meta.unique_together:
1267                 unique_togethers.append(
1268                     (parent_class, parent_class._meta.unique_together)
1269                 )
1270             if include_meta_constraints and parent_class._meta.total_unique_constraints:
1271                 constraints.append(
1272                     (parent_class, parent_class._meta.total_unique_constraints)
1273                 )
1274 
1275         for model_class, unique_together in unique_togethers:
1276             for check in unique_together:
1277                 if not any(name in exclude for name in check):
1278                     # Add the check if the field isn't excluded.
1279                     unique_checks.append((model_class, tuple(check)))
1280 
1281         if include_meta_constraints:
1282             for model_class, model_constraints in constraints:
1283                 for constraint in model_constraints:
1284                     if not any(name in exclude for name in constraint.fields):
1285                         unique_checks.append((model_class, constraint.fields))
1286 
1287         # These are checks for the unique_for_<date/year/month>.
1288         date_checks = []
1289 
1290         # Gather a list of checks for fields declared as unique and add them to
1291         # the list of checks.
1292 
1293         fields_with_class = [(self.__class__, self._meta.local_fields)]
1294         for parent_class in self._meta.get_parent_list():
1295             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1296 
1297         for model_class, fields in fields_with_class:
1298             for f in fields:
1299                 name = f.name
1300                 if name in exclude:
1301                     continue
1302                 if f.unique:
1303                     unique_checks.append((model_class, (name,)))
1304                 if f.unique_for_date and f.unique_for_date not in exclude:
1305                     date_checks.append((model_class, "date", name, f.unique_for_date))
1306                 if f.unique_for_year and f.unique_for_year not in exclude:
1307                     date_checks.append((model_class, "year", name, f.unique_for_year))
1308                 if f.unique_for_month and f.unique_for_month not in exclude:
1309                     date_checks.append((model_class, "month", name, f.unique_for_month))
1310         return unique_checks, date_checks
1311 
1312     def _perform_unique_checks(self, unique_checks):
1313         errors = {}
1314 
1315         for model_class, unique_check in unique_checks:
1316             # Try to look up an existing object with the same values as this
1317             # object's values for all the unique field.
1318 
1319             lookup_kwargs = {}
1320             for field_name in unique_check:
1321                 f = self._meta.get_field(field_name)
1322                 lookup_value = getattr(self, f.attname)
1323                 # TODO: Handle multiple backends with different feature flags.
1324                 if lookup_value is None or (
1325                     lookup_value == ""
1326                     and connection.features.interprets_empty_strings_as_nulls
1327                 ):
1328                     # no value, skip the lookup
1329                     continue
1330                 if f.primary_key and not self._state.adding:
1331                     # no need to check for unique primary key when editing
1332                     continue
1333                 lookup_kwargs[str(field_name)] = lookup_value
1334 
1335             # some fields were skipped, no reason to do the check
1336             if len(unique_check) != len(lookup_kwargs):
1337                 continue
1338 
1339             qs = model_class._default_manager.filter(**lookup_kwargs)
1340 
1341             # Exclude the current object from the query if we are editing an
1342             # instance (as opposed to creating a new one)
1343             # Note that we need to use the pk as defined by model_class, not
1344             # self.pk. These can be different fields because model inheritance
1345             # allows single model to have effectively multiple primary keys.
1346             # Refs #17615.
1347             model_class_pk = self._get_pk_val(model_class._meta)
1348             if not self._state.adding and model_class_pk is not None:
1349                 qs = qs.exclude(pk=model_class_pk)
1350             if qs.exists():
1351                 if len(unique_check) == 1:
1352                     key = unique_check[0]
1353                 else:
1354                     key = NON_FIELD_ERRORS
1355                 errors.setdefault(key, []).append(
1356                     self.unique_error_message(model_class, unique_check)
1357                 )
1358 
1359         return errors
1360 
1361     def _perform_date_checks(self, date_checks):
1362         errors = {}
1363         for model_class, lookup_type, field, unique_for in date_checks:
1364             lookup_kwargs = {}
1365             # there's a ticket to add a date lookup, we can remove this special
1366             # case if that makes it's way in
1367             date = getattr(self, unique_for)
1368             if date is None:
1369                 continue
1370             if lookup_type == "date":
1371                 lookup_kwargs["%s__day" % unique_for] = date.day
1372                 lookup_kwargs["%s__month" % unique_for] = date.month
1373                 lookup_kwargs["%s__year" % unique_for] = date.year
1374             else:
1375                 lookup_kwargs["%s__%s" % (unique_for, lookup_type)] = getattr(
1376                     date, lookup_type
1377                 )
1378             lookup_kwargs[field] = getattr(self, field)
1379 
1380             qs = model_class._default_manager.filter(**lookup_kwargs)
1381             # Exclude the current object from the query if we are editing an
1382             # instance (as opposed to creating a new one)
1383             if not self._state.adding and self.pk is not None:
1384                 qs = qs.exclude(pk=self.pk)
1385 
1386             if qs.exists():
1387                 errors.setdefault(field, []).append(
1388                     self.date_error_message(lookup_type, field, unique_for)
1389                 )
1390         return errors
1391 
1392     def date_error_message(self, lookup_type, field_name, unique_for):
1393         opts = self._meta
1394         field = opts.get_field(field_name)
1395         return ValidationError(
1396             message=field.error_messages["unique_for_date"],
1397             code="unique_for_date",
1398             params={
1399                 "model": self,
1400                 "model_name": capfirst(opts.verbose_name),
1401                 "lookup_type": lookup_type,
1402                 "field": field_name,
1403                 "field_label": capfirst(field.verbose_name),
1404                 "date_field": unique_for,
1405                 "date_field_label": capfirst(opts.get_field(unique_for).verbose_name),
1406             },
1407         )
1408 
1409     def unique_error_message(self, model_class, unique_check):
1410         opts = model_class._meta
1411 
1412         params = {
1413             "model": self,
1414             "model_class": model_class,
1415             "model_name": capfirst(opts.verbose_name),
1416             "unique_check": unique_check,
1417         }
1418 
1419         # A unique field
1420         if len(unique_check) == 1:
1421             field = opts.get_field(unique_check[0])
1422             params["field_label"] = capfirst(field.verbose_name)
1423             return ValidationError(
1424                 message=field.error_messages["unique"],
1425                 code="unique",
1426                 params=params,
1427             )
1428 
1429         # unique_together
1430         else:
1431             field_labels = [
1432                 capfirst(opts.get_field(f).verbose_name) for f in unique_check
1433             ]
1434             params["field_labels"] = get_text_list(field_labels, _("and"))
1435             return ValidationError(
1436                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1437                 code="unique_together",
1438                 params=params,
1439             )
1440 
1441     def get_constraints(self):
1442         constraints = [(self.__class__, self._meta.constraints)]
1443         for parent_class in self._meta.get_parent_list():
1444             if parent_class._meta.constraints:
1445                 constraints.append((parent_class, parent_class._meta.constraints))
1446         return constraints
1447 
1448     def validate_constraints(self, exclude=None):
1449         constraints = self.get_constraints()
1450         using = router.db_for_write(self.__class__, instance=self)
1451 
1452         errors = {}
1453         for model_class, model_constraints in constraints:
1454             for constraint in model_constraints:
1455                 try:
1456                     constraint.validate(model_class, self, exclude=exclude, using=using)
1457                 except ValidationError as e:
1458                     if (
1459                         getattr(e, "code", None) == "unique"
1460                         and len(constraint.fields) == 1
1461                     ):
1462                         errors.setdefault(constraint.fields[0], []).append(e)
1463                     else:
1464                         errors = e.update_error_dict(errors)
1465         if errors:
1466             raise ValidationError(errors)
1467 
1468     def full_clean(self, exclude=None, validate_unique=True, validate_constraints=True):
1469         """
1470         Call clean_fields(), clean(), validate_unique(), and
1471         validate_constraints() on the model. Raise a ValidationError for any
1472         errors that occur.
1473         """
1474         errors = {}
1475         if exclude is None:
1476             exclude = set()
1477         else:
1478             exclude = set(exclude)
1479 
1480         try:
1481             self.clean_fields(exclude=exclude)
1482         except ValidationError as e:
1483             errors = e.update_error_dict(errors)
1484 
1485         # Form.clean() is run even if other validation fails, so do the
1486         # same with Model.clean() for consistency.
1487         try:
1488             self.clean()
1489         except ValidationError as e:
1490             errors = e.update_error_dict(errors)
1491 
1492         # Run unique checks, but only for fields that passed validation.
1493         if validate_unique:
1494             for name in errors:
1495                 if name != NON_FIELD_ERRORS and name not in exclude:
1496                     exclude.add(name)
1497             try:
1498                 self.validate_unique(exclude=exclude)
1499             except ValidationError as e:
1500                 errors = e.update_error_dict(errors)
1501 
1502         # Run constraints checks, but only for fields that passed validation.
1503         if validate_constraints:
1504             for name in errors:
1505                 if name != NON_FIELD_ERRORS and name not in exclude:
1506                     exclude.add(name)
1507             try:
1508                 self.validate_constraints(exclude=exclude)
1509             except ValidationError as e:
1510                 errors = e.update_error_dict(errors)
1511 
1512         if errors:
1513             raise ValidationError(errors)
1514 
1515     def clean_fields(self, exclude=None):
1516         """
1517         Clean all fields and raise a ValidationError containing a dict
1518         of all validation errors if any occur.
1519         """
1520         if exclude is None:
1521             exclude = set()
1522 
1523         errors = {}
1524         for f in self._meta.fields:
1525             if f.name in exclude:
1526                 continue
1527             # Skip validation for empty fields with blank=True. The developer
1528             # is responsible for making sure they have a valid value.
1529             raw_value = getattr(self, f.attname)
1530             if f.blank and raw_value in f.empty_values:
1531                 continue
1532             try:
1533                 setattr(self, f.attname, f.clean(raw_value, self))
1534             except ValidationError as e:
1535                 errors[f.name] = e.error_list
1536 
1537         if errors:
1538             raise ValidationError(errors)
1539 
1540     @classmethod
1541     def check(cls, **kwargs):
1542         errors = [
1543             *cls._check_swappable(),
1544             *cls._check_model(),
1545             *cls._check_managers(**kwargs),
1546         ]
1547         if not cls._meta.swapped:
1548             databases = kwargs.get("databases") or []
1549             errors += [
1550                 *cls._check_fields(**kwargs),
1551                 *cls._check_m2m_through_same_relationship(),
1552                 *cls._check_long_column_names(databases),
1553             ]
1554             clash_errors = (
1555                 *cls._check_id_field(),
1556                 *cls._check_field_name_clashes(),
1557                 *cls._check_model_name_db_lookup_clashes(),
1558                 *cls._check_property_name_related_field_accessor_clashes(),
1559                 *cls._check_single_primary_key(),
1560             )
1561             errors.extend(clash_errors)
1562             # If there are field name clashes, hide consequent column name
1563             # clashes.
1564             if not clash_errors:
1565                 errors.extend(cls._check_column_name_clashes())
1566             errors += [
1567                 *cls._check_index_together(),
1568                 *cls._check_unique_together(),
1569                 *cls._check_indexes(databases),
1570                 *cls._check_ordering(),
1571                 *cls._check_constraints(databases),
1572                 *cls._check_default_pk(),
1573                 *cls._check_db_table_comment(databases),
1574             ]
1575 
1576         return errors
1577 
1578     @classmethod
1579     def _check_default_pk(cls):
1580         if (
1581             not cls._meta.abstract
1582             and cls._meta.pk.auto_created
1583             and
1584             # Inherited PKs are checked in parents models.
1585             not (
1586                 isinstance(cls._meta.pk, OneToOneField)
1587                 and cls._meta.pk.remote_field.parent_link
1588             )
1589             and not settings.is_overridden("DEFAULT_AUTO_FIELD")
1590             and cls._meta.app_config
1591             and not cls._meta.app_config._is_default_auto_field_overridden
1592         ):
1593             return [
1594                 checks.Warning(
1595                     f"Auto-created primary key used when not defining a "
1596                     f"primary key type, by default "
1597                     f"'{settings.DEFAULT_AUTO_FIELD}'.",
1598                     hint=(
1599                         f"Configure the DEFAULT_AUTO_FIELD setting or the "
1600                         f"{cls._meta.app_config.__class__.__qualname__}."
1601                         f"default_auto_field attribute to point to a subclass "
1602                         f"of AutoField, e.g. 'django.db.models.BigAutoField'."
1603                     ),
1604                     obj=cls,
1605                     id="models.W042",
1606                 ),
1607             ]
1608         return []
1609 
1610     @classmethod
1611     def _check_db_table_comment(cls, databases):
1612         if not cls._meta.db_table_comment:
1613             return []
1614         errors = []
1615         for db in databases:
1616             if not router.allow_migrate_model(db, cls):
1617                 continue
1618             connection = connections[db]
1619             if not (
1620                 connection.features.supports_comments
1621                 or "supports_comments" in cls._meta.required_db_features
1622             ):
1623                 errors.append(
1624                     checks.Warning(
1625                         f"{connection.display_name} does not support comments on "
1626                         f"tables (db_table_comment).",
1627                         obj=cls,
1628                         id="models.W046",
1629                     )
1630                 )
1631         return errors
1632 
1633     @classmethod
1634     def _check_swappable(cls):
1635         """Check if the swapped model exists."""
1636         errors = []
1637         if cls._meta.swapped:
1638             try:
1639                 apps.get_model(cls._meta.swapped)
1640             except ValueError:
1641                 errors.append(
1642                     checks.Error(
1643                         "'%s' is not of the form 'app_label.app_name'."
1644                         % cls._meta.swappable,
1645                         id="models.E001",
1646                     )
1647                 )
1648             except LookupError:
1649                 app_label, model_name = cls._meta.swapped.split(".")
1650                 errors.append(
1651                     checks.Error(
1652                         "'%s' references '%s.%s', which has not been "
1653                         "installed, or is abstract."
1654                         % (cls._meta.swappable, app_label, model_name),
1655                         id="models.E002",
1656                     )
1657                 )
1658         return errors
1659 
1660     @classmethod
1661     def _check_model(cls):
1662         errors = []
1663         if cls._meta.proxy:
1664             if cls._meta.local_fields or cls._meta.local_many_to_many:
1665                 errors.append(
1666                     checks.Error(
1667                         "Proxy model '%s' contains model fields." % cls.__name__,
1668                         id="models.E017",
1669                     )
1670                 )
1671         return errors
1672 
1673     @classmethod
1674     def _check_managers(cls, **kwargs):
1675         """Perform all manager checks."""
1676         errors = []
1677         for manager in cls._meta.managers:
1678             errors.extend(manager.check(**kwargs))
1679         return errors
1680 
1681     @classmethod
1682     def _check_fields(cls, **kwargs):
1683         """Perform all field checks."""
1684         errors = []
1685         for field in cls._meta.local_fields:
1686             errors.extend(field.check(**kwargs))
1687         for field in cls._meta.local_many_to_many:
1688             errors.extend(field.check(from_model=cls, **kwargs))
1689         return errors
1690 
1691     @classmethod
1692     def _check_m2m_through_same_relationship(cls):
1693         """Check if no relationship model is used by more than one m2m field."""
1694 
1695         errors = []
1696         seen_intermediary_signatures = []
1697 
1698         fields = cls._meta.local_many_to_many
1699 
1700         # Skip when the target model wasn't found.
1701         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1702 
1703         # Skip when the relationship model wasn't found.
1704         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1705 
1706         for f in fields:
1707             signature = (
1708                 f.remote_field.model,
1709                 cls,
1710                 f.remote_field.through,
1711                 f.remote_field.through_fields,
1712             )
1713             if signature in seen_intermediary_signatures:
1714                 errors.append(
1715                     checks.Error(
1716                         "The model has two identical many-to-many relations "
1717                         "through the intermediate model '%s'."
1718                         % f.remote_field.through._meta.label,
1719                         obj=cls,
1720                         id="models.E003",
1721                     )
1722                 )
1723             else:
1724                 seen_intermediary_signatures.append(signature)
1725         return errors
1726 
1727     @classmethod
1728     def _check_id_field(cls):
1729         """Check if `id` field is a primary key."""
1730         fields = [
1731             f for f in cls._meta.local_fields if f.name == "id" and f != cls._meta.pk
1732         ]
1733         # fields is empty or consists of the invalid "id" field
1734         if fields and not fields[0].primary_key and cls._meta.pk.name == "id":
1735             return [
1736                 checks.Error(
1737                     "'id' can only be used as a field name if the field also "
1738                     "sets 'primary_key=True'.",
1739                     obj=cls,
1740                     id="models.E004",
1741                 )
1742             ]
1743         else:
1744             return []
1745 
1746     @classmethod
1747     def _check_field_name_clashes(cls):
1748         """Forbid field shadowing in multi-table inheritance."""
1749         errors = []
1750         used_fields = {}  # name or attname -> field
1751 
1752         # Check that multi-inheritance doesn't cause field name shadowing.
1753         for parent in cls._meta.get_parent_list():
1754             for f in parent._meta.local_fields:
1755                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1756                 if clash:
1757                     errors.append(
1758                         checks.Error(
1759                             "The field '%s' from parent model "
1760                             "'%s' clashes with the field '%s' "
1761                             "from parent model '%s'."
1762                             % (clash.name, clash.model._meta, f.name, f.model._meta),
1763                             obj=cls,
1764                             id="models.E005",
1765                         )
1766                     )
1767                 used_fields[f.name] = f
1768                 used_fields[f.attname] = f
1769 
1770         # Check that fields defined in the model don't clash with fields from
1771         # parents, including auto-generated fields like multi-table inheritance
1772         # child accessors.
1773         for parent in cls._meta.get_parent_list():
1774             for f in parent._meta.get_fields():
1775                 if f not in used_fields:
1776                     used_fields[f.name] = f
1777 
1778         for f in cls._meta.local_fields:
1779             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1780             # Note that we may detect clash between user-defined non-unique
1781             # field "id" and automatically added unique field "id", both
1782             # defined at the same model. This special case is considered in
1783             # _check_id_field and here we ignore it.
1784             id_conflict = (
1785                 f.name == "id" and clash and clash.name == "id" and clash.model == cls
1786             )
1787             if clash and not id_conflict:
1788                 errors.append(
1789                     checks.Error(
1790                         "The field '%s' clashes with the field '%s' "
1791                         "from model '%s'." % (f.name, clash.name, clash.model._meta),
1792                         obj=f,
1793                         id="models.E006",
1794                     )
1795                 )
1796             used_fields[f.name] = f
1797             used_fields[f.attname] = f
1798 
1799         return errors
1800 
1801     @classmethod
1802     def _check_column_name_clashes(cls):
1803         # Store a list of column names which have already been used by other fields.
1804         used_column_names = []
1805         errors = []
1806 
1807         for f in cls._meta.local_fields:
1808             _, column_name = f.get_attname_column()
1809 
1810             # Ensure the column name is not already in use.
1811             if column_name and column_name in used_column_names:
1812                 errors.append(
1813                     checks.Error(
1814                         "Field '%s' has column name '%s' that is used by "
1815                         "another field." % (f.name, column_name),
1816                         hint="Specify a 'db_column' for the field.",
1817                         obj=cls,
1818                         id="models.E007",
1819                     )
1820                 )
1821             else:
1822                 used_column_names.append(column_name)
1823 
1824         return errors
1825 
1826     @classmethod
1827     def _check_model_name_db_lookup_clashes(cls):
1828         errors = []
1829         model_name = cls.__name__
1830         if model_name.startswith("_") or model_name.endswith("_"):
1831             errors.append(
1832                 checks.Error(
1833                     "The model name '%s' cannot start or end with an underscore "
1834                     "as it collides with the query lookup syntax." % model_name,
1835                     obj=cls,
1836                     id="models.E023",
1837                 )
1838             )
1839         elif LOOKUP_SEP in model_name:
1840             errors.append(
1841                 checks.Error(
1842                     "The model name '%s' cannot contain double underscores as "
1843                     "it collides with the query lookup syntax." % model_name,
1844                     obj=cls,
1845                     id="models.E024",
1846                 )
1847             )
1848         return errors
1849 
1850     @classmethod
1851     def _check_property_name_related_field_accessor_clashes(cls):
1852         errors = []
1853         property_names = cls._meta._property_names
1854         related_field_accessors = (
1855             f.get_attname()
1856             for f in cls._meta._get_fields(reverse=False)
1857             if f.is_relation and f.related_model is not None
1858         )
1859         for accessor in related_field_accessors:
1860             if accessor in property_names:
1861                 errors.append(
1862                     checks.Error(
1863                         "The property '%s' clashes with a related field "
1864                         "accessor." % accessor,
1865                         obj=cls,
1866                         id="models.E025",
1867                     )
1868                 )
1869         return errors
1870 
1871     @classmethod
1872     def _check_single_primary_key(cls):
1873         errors = []
1874         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1875             errors.append(
1876                 checks.Error(
1877                     "The model cannot have more than one field with "
1878                     "'primary_key=True'.",
1879                     obj=cls,
1880                     id="models.E026",
1881                 )
1882             )
1883         return errors
1884 
1885     # RemovedInDjango51Warning.
1886     @classmethod
1887     def _check_index_together(cls):
1888         """Check the value of "index_together" option."""
1889         if not isinstance(cls._meta.index_together, (tuple, list)):
1890             return [
1891                 checks.Error(
1892                     "'index_together' must be a list or tuple.",
1893                     obj=cls,
1894                     id="models.E008",
1895                 )
1896             ]
1897 
1898         elif any(
1899             not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together
1900         ):
1901             return [
1902                 checks.Error(
1903                     "All 'index_together' elements must be lists or tuples.",
1904                     obj=cls,
1905                     id="models.E009",
1906                 )
1907             ]
1908 
1909         else:
1910             errors = []
1911             for fields in cls._meta.index_together:
1912                 errors.extend(cls._check_local_fields(fields, "index_together"))
1913             return errors
1914 
1915     @classmethod
1916     def _check_unique_together(cls):
1917         """Check the value of "unique_together" option."""
1918         if not isinstance(cls._meta.unique_together, (tuple, list)):
1919             return [
1920                 checks.Error(
1921                     "'unique_together' must be a list or tuple.",
1922                     obj=cls,
1923                     id="models.E010",
1924                 )
1925             ]
1926 
1927         elif any(
1928             not isinstance(fields, (tuple, list))
1929             for fields in cls._meta.unique_together
1930         ):
1931             return [
1932                 checks.Error(
1933                     "All 'unique_together' elements must be lists or tuples.",
1934                     obj=cls,
1935                     id="models.E011",
1936                 )
1937             ]
1938 
1939         else:
1940             errors = []
1941             for fields in cls._meta.unique_together:
1942                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1943             return errors
1944 
1945     @classmethod
1946     def _check_indexes(cls, databases):
1947         """Check fields, names, and conditions of indexes."""
1948         errors = []
1949         references = set()
1950         for index in cls._meta.indexes:
1951             # Index name can't start with an underscore or a number, restricted
1952             # for cross-database compatibility with Oracle.
1953             if index.name[0] == "_" or index.name[0].isdigit():
1954                 errors.append(
1955                     checks.Error(
1956                         "The index name '%s' cannot start with an underscore "
1957                         "or a number." % index.name,
1958                         obj=cls,
1959                         id="models.E033",
1960                     ),
1961                 )
1962             if len(index.name) > index.max_name_length:
1963                 errors.append(
1964                     checks.Error(
1965                         "The index name '%s' cannot be longer than %d "
1966                         "characters." % (index.name, index.max_name_length),
1967                         obj=cls,
1968                         id="models.E034",
1969                     ),
1970                 )
1971             if index.contains_expressions:
1972                 for expression in index.expressions:
1973                     references.update(
1974                         ref[0] for ref in cls._get_expr_references(expression)
1975                     )
1976         for db in databases:
1977             if not router.allow_migrate_model(db, cls):
1978                 continue
1979             connection = connections[db]
1980             if not (
1981                 connection.features.supports_partial_indexes
1982                 or "supports_partial_indexes" in cls._meta.required_db_features
1983             ) and any(index.condition is not None for index in cls._meta.indexes):
1984                 errors.append(
1985                     checks.Warning(
1986                         "%s does not support indexes with conditions."
1987                         % connection.display_name,
1988                         hint=(
1989                             "Conditions will be ignored. Silence this warning "
1990                             "if you don't care about it."
1991                         ),
1992                         obj=cls,
1993                         id="models.W037",
1994                     )
1995                 )
1996             if not (
1997                 connection.features.supports_covering_indexes
1998                 or "supports_covering_indexes" in cls._meta.required_db_features
1999             ) and any(index.include for index in cls._meta.indexes):
2000                 errors.append(
2001                     checks.Warning(
2002                         "%s does not support indexes with non-key columns."
2003                         % connection.display_name,
2004                         hint=(
2005                             "Non-key columns will be ignored. Silence this "
2006                             "warning if you don't care about it."
2007                         ),
2008                         obj=cls,
2009                         id="models.W040",
2010                     )
2011                 )
2012             if not (
2013                 connection.features.supports_expression_indexes
2014                 or "supports_expression_indexes" in cls._meta.required_db_features
2015             ) and any(index.contains_expressions for index in cls._meta.indexes):
2016                 errors.append(
2017                     checks.Warning(
2018                         "%s does not support indexes on expressions."
2019                         % connection.display_name,
2020                         hint=(
2021                             "An index won't be created. Silence this warning "
2022                             "if you don't care about it."
2023                         ),
2024                         obj=cls,
2025                         id="models.W043",
2026                     )
2027                 )
2028         fields = [
2029             field for index in cls._meta.indexes for field, _ in index.fields_orders
2030         ]
2031         fields += [include for index in cls._meta.indexes for include in index.include]
2032         fields += references
2033         errors.extend(cls._check_local_fields(fields, "indexes"))
2034         return errors
2035 
2036     @classmethod
2037     def _check_local_fields(cls, fields, option):
2038         from django.db import models
2039 
2040         # In order to avoid hitting the relation tree prematurely, we use our
2041         # own fields_map instead of using get_field()
2042         forward_fields_map = {}
2043         for field in cls._meta._get_fields(reverse=False):
2044             forward_fields_map[field.name] = field
2045             if hasattr(field, "attname"):
2046                 forward_fields_map[field.attname] = field
2047 
2048         errors = []
2049         for field_name in fields:
2050             try:
2051                 field = forward_fields_map[field_name]
2052             except KeyError:
2053                 errors.append(
2054                     checks.Error(
2055                         "'%s' refers to the nonexistent field '%s'."
2056                         % (
2057                             option,
2058                             field_name,
2059                         ),
2060                         obj=cls,
2061                         id="models.E012",
2062                     )
2063                 )
2064             else:
2065                 if isinstance(field.remote_field, models.ManyToManyRel):
2066                     errors.append(
2067                         checks.Error(
2068                             "'%s' refers to a ManyToManyField '%s', but "
2069                             "ManyToManyFields are not permitted in '%s'."
2070                             % (
2071                                 option,
2072                                 field_name,
2073                                 option,
2074                             ),
2075                             obj=cls,
2076                             id="models.E013",
2077                         )
2078                     )
2079                 elif field not in cls._meta.local_fields:
2080                     errors.append(
2081                         checks.Error(
2082                             "'%s' refers to field '%s' which is not local to model "
2083                             "'%s'." % (option, field_name, cls._meta.object_name),
2084                             hint="This issue may be caused by multi-table inheritance.",
2085                             obj=cls,
2086                             id="models.E016",
2087                         )
2088                     )
2089         return errors
2090 
2091     @classmethod
2092     def _check_ordering(cls):
2093         """
2094         Check "ordering" option -- is it a list of strings and do all fields
2095         exist?
2096         """
2097         if cls._meta._ordering_clash:
2098             return [
2099                 checks.Error(
2100                     "'ordering' and 'order_with_respect_to' cannot be used together.",
2101                     obj=cls,
2102                     id="models.E021",
2103                 ),
2104             ]
2105 
2106         if cls._meta.order_with_respect_to or not cls._meta.ordering:
2107             return []
2108 
2109         if not isinstance(cls._meta.ordering, (list, tuple)):
2110             return [
2111                 checks.Error(
2112                     "'ordering' must be a tuple or list (even if you want to order by "
2113                     "only one field).",
2114                     obj=cls,
2115                     id="models.E014",
2116                 )
2117             ]
2118 
2119         errors = []
2120         fields = cls._meta.ordering
2121 
2122         # Skip expressions and '?' fields.
2123         fields = (f for f in fields if isinstance(f, str) and f != "?")
2124 
2125         # Convert "-field" to "field".
2126         fields = (f.removeprefix("-") for f in fields)
2127 
2128         # Separate related fields and non-related fields.
2129         _fields = []
2130         related_fields = []
2131         for f in fields:
2132             if LOOKUP_SEP in f:
2133                 related_fields.append(f)
2134             else:
2135                 _fields.append(f)
2136         fields = _fields
2137 
2138         # Check related fields.
2139         for field in related_fields:
2140             _cls = cls
2141             fld = None
2142             for part in field.split(LOOKUP_SEP):
2143                 try:
2144                     # pk is an alias that won't be found by opts.get_field.
2145                     if part == "pk":
2146                         fld = _cls._meta.pk
2147                     else:
2148                         fld = _cls._meta.get_field(part)
2149                     if fld.is_relation:
2150                         _cls = fld.path_infos[-1].to_opts.model
2151                     else:
2152                         _cls = None
2153                 except (FieldDoesNotExist, AttributeError):
2154                     if fld is None or (
2155                         fld.get_transform(part) is None and fld.get_lookup(part) is None
2156                     ):
2157                         errors.append(
2158                             checks.Error(
2159                                 "'ordering' refers to the nonexistent field, "
2160                                 "related field, or lookup '%s'." % field,
2161                                 obj=cls,
2162                                 id="models.E015",
2163                             )
2164                         )
2165 
2166         # Skip ordering on pk. This is always a valid order_by field
2167         # but is an alias and therefore won't be found by opts.get_field.
2168         fields = {f for f in fields if f != "pk"}
2169 
2170         # Check for invalid or nonexistent fields in ordering.
2171         invalid_fields = []
2172 
2173         # Any field name that is not present in field_names does not exist.
2174         # Also, ordering by m2m fields is not allowed.
2175         opts = cls._meta
2176         valid_fields = set(
2177             chain.from_iterable(
2178                 (f.name, f.attname)
2179                 if not (f.auto_created and not f.concrete)
2180                 else (f.field.related_query_name(),)
2181                 for f in chain(opts.fields, opts.related_objects)
2182             )
2183         )
2184 
2185         invalid_fields.extend(fields - valid_fields)
2186 
2187         for invalid_field in invalid_fields:
2188             errors.append(
2189                 checks.Error(
2190                     "'ordering' refers to the nonexistent field, related "
2191                     "field, or lookup '%s'." % invalid_field,
2192                     obj=cls,
2193                     id="models.E015",
2194                 )
2195             )
2196         return errors
2197 
2198     @classmethod
2199     def _check_long_column_names(cls, databases):
2200         """
2201         Check that any auto-generated column names are shorter than the limits
2202         for each database in which the model will be created.
2203         """
2204         if not databases:
2205             return []
2206         errors = []
2207         allowed_len = None
2208         db_alias = None
2209 
2210         # Find the minimum max allowed length among all specified db_aliases.
2211         for db in databases:
2212             # skip databases where the model won't be created
2213             if not router.allow_migrate_model(db, cls):
2214                 continue
2215             connection = connections[db]
2216             max_name_length = connection.ops.max_name_length()
2217             if max_name_length is None or connection.features.truncates_names:
2218                 continue
2219             else:
2220                 if allowed_len is None:
2221                     allowed_len = max_name_length
2222                     db_alias = db
2223                 elif max_name_length < allowed_len:
2224                     allowed_len = max_name_length
2225                     db_alias = db
2226 
2227         if allowed_len is None:
2228             return errors
2229 
2230         for f in cls._meta.local_fields:
2231             _, column_name = f.get_attname_column()
2232 
2233             # Check if auto-generated name for the field is too long
2234             # for the database.
2235             if (
2236                 f.db_column is None
2237                 and column_name is not None
2238                 and len(column_name) > allowed_len
2239             ):
2240                 errors.append(
2241                     checks.Error(
2242                         'Autogenerated column name too long for field "%s". '
2243                         'Maximum length is "%s" for database "%s".'
2244                         % (column_name, allowed_len, db_alias),
2245                         hint="Set the column name manually using 'db_column'.",
2246                         obj=cls,
2247                         id="models.E018",
2248                     )
2249                 )
2250 
2251         for f in cls._meta.local_many_to_many:
2252             # Skip nonexistent models.
2253             if isinstance(f.remote_field.through, str):
2254                 continue
2255 
2256             # Check if auto-generated name for the M2M field is too long
2257             # for the database.
2258             for m2m in f.remote_field.through._meta.local_fields:
2259                 _, rel_name = m2m.get_attname_column()
2260                 if (
2261                     m2m.db_column is None
2262                     and rel_name is not None
2263                     and len(rel_name) > allowed_len
2264                 ):
2265                     errors.append(
2266                         checks.Error(
2267                             "Autogenerated column name too long for M2M field "
2268                             '"%s". Maximum length is "%s" for database "%s".'
2269                             % (rel_name, allowed_len, db_alias),
2270                             hint=(
2271                                 "Use 'through' to create a separate model for "
2272                                 "M2M and then set column_name using 'db_column'."
2273                             ),
2274                             obj=cls,
2275                             id="models.E019",
2276                         )
2277                     )
2278 
2279         return errors
2280 
2281     @classmethod
2282     def _get_expr_references(cls, expr):
2283         if isinstance(expr, Q):
2284             for child in expr.children:
2285                 if isinstance(child, tuple):
2286                     lookup, value = child
2287                     yield tuple(lookup.split(LOOKUP_SEP))
2288                     yield from cls._get_expr_references(value)
2289                 else:
2290                     yield from cls._get_expr_references(child)
2291         elif isinstance(expr, F):
2292             yield tuple(expr.name.split(LOOKUP_SEP))
2293         elif hasattr(expr, "get_source_expressions"):
2294             for src_expr in expr.get_source_expressions():
2295                 yield from cls._get_expr_references(src_expr)
2296 
2297     @classmethod
2298     def _check_constraints(cls, databases):
2299         errors = []
2300         for db in databases:
2301             if not router.allow_migrate_model(db, cls):
2302                 continue
2303             connection = connections[db]
2304             if not (
2305                 connection.features.supports_table_check_constraints
2306                 or "supports_table_check_constraints" in cls._meta.required_db_features
2307             ) and any(
2308                 isinstance(constraint, CheckConstraint)
2309                 for constraint in cls._meta.constraints
2310             ):
2311                 errors.append(
2312                     checks.Warning(
2313                         "%s does not support check constraints."
2314                         % connection.display_name,
2315                         hint=(
2316                             "A constraint won't be created. Silence this "
2317                             "warning if you don't care about it."
2318                         ),
2319                         obj=cls,
2320                         id="models.W027",
2321                     )
2322                 )
2323             if not (
2324                 connection.features.supports_partial_indexes
2325                 or "supports_partial_indexes" in cls._meta.required_db_features
2326             ) and any(
2327                 isinstance(constraint, UniqueConstraint)
2328                 and constraint.condition is not None
2329                 for constraint in cls._meta.constraints
2330             ):
2331                 errors.append(
2332                     checks.Warning(
2333                         "%s does not support unique constraints with "
2334                         "conditions." % connection.display_name,
2335                         hint=(
2336                             "A constraint won't be created. Silence this "
2337                             "warning if you don't care about it."
2338                         ),
2339                         obj=cls,
2340                         id="models.W036",
2341                     )
2342                 )
2343             if not (
2344                 connection.features.supports_deferrable_unique_constraints
2345                 or "supports_deferrable_unique_constraints"
2346                 in cls._meta.required_db_features
2347             ) and any(
2348                 isinstance(constraint, UniqueConstraint)
2349                 and constraint.deferrable is not None
2350                 for constraint in cls._meta.constraints
2351             ):
2352                 errors.append(
2353                     checks.Warning(
2354                         "%s does not support deferrable unique constraints."
2355                         % connection.display_name,
2356                         hint=(
2357                             "A constraint won't be created. Silence this "
2358                             "warning if you don't care about it."
2359                         ),
2360                         obj=cls,
2361                         id="models.W038",
2362                     )
2363                 )
2364             if not (
2365                 connection.features.supports_covering_indexes
2366                 or "supports_covering_indexes" in cls._meta.required_db_features
2367             ) and any(
2368                 isinstance(constraint, UniqueConstraint) and constraint.include
2369                 for constraint in cls._meta.constraints
2370             ):
2371                 errors.append(
2372                     checks.Warning(
2373                         "%s does not support unique constraints with non-key "
2374                         "columns." % connection.display_name,
2375                         hint=(
2376                             "A constraint won't be created. Silence this "
2377                             "warning if you don't care about it."
2378                         ),
2379                         obj=cls,
2380                         id="models.W039",
2381                     )
2382                 )
2383             if not (
2384                 connection.features.supports_expression_indexes
2385                 or "supports_expression_indexes" in cls._meta.required_db_features
2386             ) and any(
2387                 isinstance(constraint, UniqueConstraint)
2388                 and constraint.contains_expressions
2389                 for constraint in cls._meta.constraints
2390             ):
2391                 errors.append(
2392                     checks.Warning(
2393                         "%s does not support unique constraints on "
2394                         "expressions." % connection.display_name,
2395                         hint=(
2396                             "A constraint won't be created. Silence this "
2397                             "warning if you don't care about it."
2398                         ),
2399                         obj=cls,
2400                         id="models.W044",
2401                     )
2402                 )
2403             fields = set(
2404                 chain.from_iterable(
2405                     (*constraint.fields, *constraint.include)
2406                     for constraint in cls._meta.constraints
2407                     if isinstance(constraint, UniqueConstraint)
2408                 )
2409             )
2410             references = set()
2411             for constraint in cls._meta.constraints:
2412                 if isinstance(constraint, UniqueConstraint):
2413                     if (
2414                         connection.features.supports_partial_indexes
2415                         or "supports_partial_indexes"
2416                         not in cls._meta.required_db_features
2417                     ) and isinstance(constraint.condition, Q):
2418                         references.update(
2419                             cls._get_expr_references(constraint.condition)
2420                         )
2421                     if (
2422                         connection.features.supports_expression_indexes
2423                         or "supports_expression_indexes"
2424                         not in cls._meta.required_db_features
2425                     ) and constraint.contains_expressions:
2426                         for expression in constraint.expressions:
2427                             references.update(cls._get_expr_references(expression))
2428                 elif isinstance(constraint, CheckConstraint):
2429                     if (
2430                         connection.features.supports_table_check_constraints
2431                         or "supports_table_check_constraints"
2432                         not in cls._meta.required_db_features
2433                     ):
2434                         if isinstance(constraint.check, Q):
2435                             references.update(
2436                                 cls._get_expr_references(constraint.check)
2437                             )
2438                         if any(
2439                             isinstance(expr, RawSQL)
2440                             for expr in constraint.check.flatten()
2441                         ):
2442                             errors.append(
2443                                 checks.Warning(
2444                                     f"Check constraint {constraint.name!r} contains "
2445                                     f"RawSQL() expression and won't be validated "
2446                                     f"during the model full_clean().",
2447                                     hint=(
2448                                         "Silence this warning if you don't care about "
2449                                         "it."
2450                                     ),
2451                                     obj=cls,
2452                                     id="models.W045",
2453                                 ),
2454                             )
2455             for field_name, *lookups in references:
2456                 # pk is an alias that won't be found by opts.get_field.
2457                 if field_name != "pk":
2458                     fields.add(field_name)
2459                 if not lookups:
2460                     # If it has no lookups it cannot result in a JOIN.
2461                     continue
2462                 try:
2463                     if field_name == "pk":
2464                         field = cls._meta.pk
2465                     else:
2466                         field = cls._meta.get_field(field_name)
2467                     if not field.is_relation or field.many_to_many or field.one_to_many:
2468                         continue
2469                 except FieldDoesNotExist:
2470                     continue
2471                 # JOIN must happen at the first lookup.
2472                 first_lookup = lookups[0]
2473                 if (
2474                     hasattr(field, "get_transform")
2475                     and hasattr(field, "get_lookup")
2476                     and field.get_transform(first_lookup) is None
2477                     and field.get_lookup(first_lookup) is None
2478                 ):
2479                     errors.append(
2480                         checks.Error(
2481                             "'constraints' refers to the joined field '%s'."
2482                             % LOOKUP_SEP.join([field_name] + lookups),
2483                             obj=cls,
2484                             id="models.E041",
2485                         )
2486                     )
2487             errors.extend(cls._check_local_fields(fields, "constraints"))
2488         return errors

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:06:22.431 | INFO     | Search completed. Bug locations: [<file>django/db/models/base.py</file>
<class>Model</class>
<method>_save_parents</method>
<code>
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted

</code><intended_behavior>The `_save_parents` method should ensure that when saving models with complex multi-table inheritance, including scenarios with multiple parents (diamond inheritance or otherwise), it correctly handles the link fields without throwing an `AttributeError`. Specifically, the method should: Verify the presence of an `attname` attribute for all link fields (`OneToOneField` or otherwise) involved in the inheritance chain. This involves ensuring that the code gracefully handles scenarios where a link field might not exhibit the expected attributes due to the complexity of the MTI structure. Correctly assign or propagate primary key values (and potentially other necessary field values) from parent models to child models, ensuring that database integrity and referential links are maintained without error. Incorporate additional logic or checks, if necessary, to account for the intricate MTI scenarios where a standard handling of link fields and attribute assignments might not suffice. This could involve refining the condition on lines 913-914 or adding supplementary condition statements to manage edge cases more effectively. The resolution should ensure that the creation of objects through Django's ORM can handle any form or complexity of model inheritance without raising exceptions due to handling link fields. This fix should preserve the current functionality for simpler inheritance models while extending support to cover the edge cases introduced by nested, complex, or multiple inheritance paths, ensuring robust, error-free object creation across the board.</intended_behavior>, <file>django/db/models/base.py</file>
<class>Model</class>
<method>None</method>
<code>
459 class Model(AltersData, metaclass=ModelBase):
460     def __init__(self, *args, **kwargs):
461         # Alias some things as locals to avoid repeat global lookups
462         cls = self.__class__
463         opts = self._meta
464         _setattr = setattr
465         _DEFERRED = DEFERRED
466         if opts.abstract:
467             raise TypeError("Abstract models cannot be instantiated.")
468 
469         pre_init.send(sender=cls, args=args, kwargs=kwargs)
470 
471         # Set up the storage for instance state
472         self._state = ModelState()
473 
474         # There is a rather weird disparity here; if kwargs, it's set, then args
475         # overrides it. It should be one or the other; don't duplicate the work
476         # The reason for the kwargs check is that standard iterator passes in by
477         # args, and instantiation for iteration is 33% faster.
478         if len(args) > len(opts.concrete_fields):
479             # Daft, but matches old exception sans the err msg.
480             raise IndexError("Number of args exceeds number of fields")
481 
482         if not kwargs:
483             fields_iter = iter(opts.concrete_fields)
484             # The ordering of the zip calls matter - zip throws StopIteration
485             # when an iter throws it. So if the first iter throws it, the second
486             # is *not* consumed. We rely on this, so don't change the order
487             # without changing the logic.
488             for val, field in zip(args, fields_iter):
489                 if val is _DEFERRED:
490                     continue
491                 _setattr(self, field.attname, val)
492         else:
493             # Slower, kwargs-ready version.
494             fields_iter = iter(opts.fields)
495             for val, field in zip(args, fields_iter):
496                 if val is _DEFERRED:
497                     continue
498                 _setattr(self, field.attname, val)
499                 if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
500                     raise TypeError(
501                         f"{cls.__qualname__}() got both positional and "
502                         f"keyword arguments for field '{field.name}'."
503                     )
504 
505         # Now we're left with the unprocessed fields that *must* come from
506         # keywords, or default.
507 
508         for field in fields_iter:
509             is_related_object = False
510             # Virtual field
511             if field.attname not in kwargs and field.column is None:
512                 continue
513             if kwargs:
514                 if isinstance(field.remote_field, ForeignObjectRel):
515                     try:
516                         # Assume object instance was passed in.
517                         rel_obj = kwargs.pop(field.name)
518                         is_related_object = True
519                     except KeyError:
520                         try:
521                             # Object instance wasn't passed in -- must be an ID.
522                             val = kwargs.pop(field.attname)
523                         except KeyError:
524                             val = field.get_default()
525                 else:
526                     try:
527                         val = kwargs.pop(field.attname)
528                     except KeyError:
529                         # This is done with an exception rather than the
530                         # default argument on pop because we don't want
531                         # get_default() to be evaluated, and then not used.
532                         # Refs #12057.
533                         val = field.get_default()
534             else:
535                 val = field.get_default()
536 
537             if is_related_object:
538                 # If we are passed a related instance, set it using the
539                 # field.name instead of field.attname (e.g. "user" instead of
540                 # "user_id") so that the object gets properly cached (and type
541                 # checked) by the RelatedObjectDescriptor.
542                 if rel_obj is not _DEFERRED:
543                     _setattr(self, field.name, rel_obj)
544             else:
545                 if val is not _DEFERRED:
546                     _setattr(self, field.attname, val)
547 
548         if kwargs:
549             property_names = opts._property_names
550             unexpected = ()
551             for prop, value in kwargs.items():
552                 # Any remaining kwargs must correspond to properties or virtual
553                 # fields.
554                 if prop in property_names:
555                     if value is not _DEFERRED:
556                         _setattr(self, prop, value)
557                 else:
558                     try:
559                         opts.get_field(prop)
560                     except FieldDoesNotExist:
561                         unexpected += (prop,)
562                     else:
563                         if value is not _DEFERRED:
564                             _setattr(self, prop, value)
565             if unexpected:
566                 unexpected_names = ", ".join(repr(n) for n in unexpected)
567                 raise TypeError(
568                     f"{cls.__name__}() got unexpected keyword arguments: "
569                     f"{unexpected_names}"
570                 )
571         super().__init__()
572         post_init.send(sender=cls, instance=self)
573 
574     @classmethod
575     def from_db(cls, db, field_names, values):
576         if len(values) != len(cls._meta.concrete_fields):
577             values_iter = iter(values)
578             values = [
579                 next(values_iter) if f.attname in field_names else DEFERRED
580                 for f in cls._meta.concrete_fields
581             ]
582         new = cls(*values)
583         new._state.adding = False
584         new._state.db = db
585         return new
586 
587     def __repr__(self):
588         return "<%s: %s>" % (self.__class__.__name__, self)
589 
590     def __str__(self):
591         return "%s object (%s)" % (self.__class__.__name__, self.pk)
592 
593     def __eq__(self, other):
594         if not isinstance(other, Model):
595             return NotImplemented
596         if self._meta.concrete_model != other._meta.concrete_model:
597             return False
598         my_pk = self.pk
599         if my_pk is None:
600             return self is other
601         return my_pk == other.pk
602 
603     def __hash__(self):
604         if self.pk is None:
605             raise TypeError("Model instances without primary key value are unhashable")
606         return hash(self.pk)
607 
608     def __reduce__(self):
609         data = self.__getstate__()
610         data[DJANGO_VERSION_PICKLE_KEY] = django.__version__
611         class_id = self._meta.app_label, self._meta.object_name
612         return model_unpickle, (class_id,), data
613 
614     def __getstate__(self):
615         """Hook to allow choosing the attributes to pickle."""
616         state = self.__dict__.copy()
617         state["_state"] = copy.copy(state["_state"])
618         state["_state"].fields_cache = state["_state"].fields_cache.copy()
619         # memoryview cannot be pickled, so cast it to bytes and store
620         # separately.
621         _memoryview_attrs = []
622         for attr, value in state.items():
623             if isinstance(value, memoryview):
624                 _memoryview_attrs.append((attr, bytes(value)))
625         if _memoryview_attrs:
626             state["_memoryview_attrs"] = _memoryview_attrs
627             for attr, value in _memoryview_attrs:
628                 state.pop(attr)
629         return state
630 
631     def __setstate__(self, state):
632         pickled_version = state.get(DJANGO_VERSION_PICKLE_KEY)
633         if pickled_version:
634             if pickled_version != django.__version__:
635                 warnings.warn(
636                     "Pickled model instance's Django version %s does not "
637                     "match the current version %s."
638                     % (pickled_version, django.__version__),
639                     RuntimeWarning,
640                     stacklevel=2,
641                 )
642         else:
643             warnings.warn(
644                 "Pickled model instance's Django version is not specified.",
645                 RuntimeWarning,
646                 stacklevel=2,
647             )
648         if "_memoryview_attrs" in state:
649             for attr, value in state.pop("_memoryview_attrs"):
650                 state[attr] = memoryview(value)
651         self.__dict__.update(state)
652 
653     def _get_pk_val(self, meta=None):
654         meta = meta or self._meta
655         return getattr(self, meta.pk.attname)
656 
657     def _set_pk_val(self, value):
658         for parent_link in self._meta.parents.values():
659             if parent_link and parent_link != self._meta.pk:
660                 setattr(self, parent_link.target_field.attname, value)
661         return setattr(self, self._meta.pk.attname, value)
662 
663     pk = property(_get_pk_val, _set_pk_val)
664 
665     def get_deferred_fields(self):
666         """
667         Return a set containing names of deferred fields for this instance.
668         """
669         return {
670             f.attname
671             for f in self._meta.concrete_fields
672             if f.attname not in self.__dict__
673         }
674 
675     def refresh_from_db(self, using=None, fields=None):
676         """
677         Reload field values from the database.
678 
679         By default, the reloading happens from the database this instance was
680         loaded from, or by the read router if this instance wasn't loaded from
681         any database. The using parameter will override the default.
682 
683         Fields can be used to specify which fields to reload. The fields
684         should be an iterable of field attnames. If fields is None, then
685         all non-deferred fields are reloaded.
686 
687         When accessing deferred fields of an instance, the deferred loading
688         of the field will call this method.
689         """
690         if fields is None:
691             self._prefetched_objects_cache = {}
692         else:
693             prefetched_objects_cache = getattr(self, "_prefetched_objects_cache", ())
694             for field in fields:
695                 if field in prefetched_objects_cache:
696                     del prefetched_objects_cache[field]
697                     fields.remove(field)
698             if not fields:
699                 return
700             if any(LOOKUP_SEP in f for f in fields):
701                 raise ValueError(
702                     'Found "%s" in fields argument. Relations and transforms '
703                     "are not allowed in fields." % LOOKUP_SEP
704                 )
705 
706         hints = {"instance": self}
707         db_instance_qs = self.__class__._base_manager.db_manager(
708             using, hints=hints
709         ).filter(pk=self.pk)
710 
711         # Use provided fields, if not set then reload all non-deferred fields.
712         deferred_fields = self.get_deferred_fields()
713         if fields is not None:
714             fields = list(fields)
715             db_instance_qs = db_instance_qs.only(*fields)
716         elif deferred_fields:
717             fields = [
718                 f.attname
719                 for f in self._meta.concrete_fields
720                 if f.attname not in deferred_fields
721             ]
722             db_instance_qs = db_instance_qs.only(*fields)
723 
724         db_instance = db_instance_qs.get()
725         non_loaded_fields = db_instance.get_deferred_fields()
726         for field in self._meta.concrete_fields:
727             if field.attname in non_loaded_fields:
728                 # This field wasn't refreshed - skip ahead.
729                 continue
730             setattr(self, field.attname, getattr(db_instance, field.attname))
731             # Clear cached foreign keys.
732             if field.is_relation and field.is_cached(self):
733                 field.delete_cached_value(self)
734 
735         # Clear cached relations.
736         for field in self._meta.related_objects:
737             if field.is_cached(self):
738                 field.delete_cached_value(self)
739 
740         # Clear cached private relations.
741         for field in self._meta.private_fields:
742             if field.is_relation and field.is_cached(self):
743                 field.delete_cached_value(self)
744 
745         self._state.db = db_instance._state.db
746 
747     async def arefresh_from_db(self, using=None, fields=None):
748         return await sync_to_async(self.refresh_from_db)(using=using, fields=fields)
749 
750     def serializable_value(self, field_name):
751         """
752         Return the value of the field name for this instance. If the field is
753         a foreign key, return the id value instead of the object. If there's
754         no Field object with this name on the model, return the model
755         attribute's value.
756 
757         Used to serialize a field's value (in the serializer, or form output,
758         for example). Normally, you would just access the attribute directly
759         and not use this method.
760         """
761         try:
762             field = self._meta.get_field(field_name)
763         except FieldDoesNotExist:
764             return getattr(self, field_name)
765         return getattr(self, field.attname)
766 
767     def save(
768         self, force_insert=False, force_update=False, using=None, update_fields=None
769     ):
770         """
771         Save the current instance. Override this in a subclass if you want to
772         control the saving process.
773 
774         The 'force_insert' and 'force_update' parameters can be used to insist
775         that the "save" must be an SQL insert or update (or equivalent for
776         non-SQL backends), respectively. Normally, they should not be set.
777         """
778         self._prepare_related_fields_for_save(operation_name="save")
779 
780         using = using or router.db_for_write(self.__class__, instance=self)
781         if force_insert and (force_update or update_fields):
782             raise ValueError("Cannot force both insert and updating in model saving.")
783 
784         deferred_fields = self.get_deferred_fields()
785         if update_fields is not None:
786             # If update_fields is empty, skip the save. We do also check for
787             # no-op saves later on for inheritance cases. This bailout is
788             # still needed for skipping signal sending.
789             if not update_fields:
790                 return
791 
792             update_fields = frozenset(update_fields)
793             field_names = self._meta._non_pk_concrete_field_names
794             non_model_fields = update_fields.difference(field_names)
795 
796             if non_model_fields:
797                 raise ValueError(
798                     "The following fields do not exist in this model, are m2m "
799                     "fields, or are non-concrete fields: %s"
800                     % ", ".join(non_model_fields)
801                 )
802 
803         # If saving to the same database, and this model is deferred, then
804         # automatically do an "update_fields" save on the loaded fields.
805         elif not force_insert and deferred_fields and using == self._state.db:
806             field_names = set()
807             for field in self._meta.concrete_fields:
808                 if not field.primary_key and not hasattr(field, "through"):
809                     field_names.add(field.attname)
810             loaded_fields = field_names.difference(deferred_fields)
811             if loaded_fields:
812                 update_fields = frozenset(loaded_fields)
813 
814         self.save_base(
815             using=using,
816             force_insert=force_insert,
817             force_update=force_update,
818             update_fields=update_fields,
819         )
820 
821     save.alters_data = True
822 
823     async def asave(
824         self, force_insert=False, force_update=False, using=None, update_fields=None
825     ):
826         return await sync_to_async(self.save)(
827             force_insert=force_insert,
828             force_update=force_update,
829             using=using,
830             update_fields=update_fields,
831         )
832 
833     asave.alters_data = True
834 
835     def save_base(
836         self,
837         raw=False,
838         force_insert=False,
839         force_update=False,
840         using=None,
841         update_fields=None,
842     ):
843         """
844         Handle the parts of saving which should be done only once per save,
845         yet need to be done in raw saves, too. This includes some sanity
846         checks and signal sending.
847 
848         The 'raw' argument is telling save_base not to save any parent
849         models and not to do any changes to the values before save. This
850         is used by fixture loading.
851         """
852         using = using or router.db_for_write(self.__class__, instance=self)
853         assert not (force_insert and (force_update or update_fields))
854         assert update_fields is None or update_fields
855         cls = origin = self.__class__
856         # Skip proxies, but keep the origin as the proxy model.
857         if cls._meta.proxy:
858             cls = cls._meta.concrete_model
859         meta = cls._meta
860         if not meta.auto_created:
861             pre_save.send(
862                 sender=origin,
863                 instance=self,
864                 raw=raw,
865                 using=using,
866                 update_fields=update_fields,
867             )
868         # A transaction isn't needed if one query is issued.
869         if meta.parents:
870             context_manager = transaction.atomic(using=using, savepoint=False)
871         else:
872             context_manager = transaction.mark_for_rollback_on_error(using=using)
873         with context_manager:
874             parent_inserted = False
875             if not raw:
876                 parent_inserted = self._save_parents(cls, using, update_fields)
877             updated = self._save_table(
878                 raw,
879                 cls,
880                 force_insert or parent_inserted,
881                 force_update,
882                 using,
883                 update_fields,
884             )
885         # Store the database on which the object was saved
886         self._state.db = using
887         # Once saved, this is no longer a to-be-added instance.
888         self._state.adding = False
889 
890         # Signal that the save is complete
891         if not meta.auto_created:
892             post_save.send(
893                 sender=origin,
894                 instance=self,
895                 created=(not updated),
896                 update_fields=update_fields,
897                 raw=raw,
898                 using=using,
899             )
900 
901     save_base.alters_data = True
902 
903     def _save_parents(self, cls, using, update_fields, updated_parents=None):
904         """Save all the parents of cls using values from self."""
905         meta = cls._meta
906         inserted = False
907         if updated_parents is None:
908             updated_parents = {}
909         for parent, field in meta.parents.items():
910             # Make sure the link fields are synced between parent and self.
911             if (
912                 field
913                 and getattr(self, parent._meta.pk.attname) is None
914                 and getattr(self, field.attname) is not None
915             ):
916                 setattr(self, parent._meta.pk.attname, getattr(self, field.attname))
917             if (parent_updated := updated_parents.get(parent)) is None:
918                 parent_inserted = self._save_parents(
919                     cls=parent,
920                     using=using,
921                     update_fields=update_fields,
922                     updated_parents=updated_parents,
923                 )
924                 updated = self._save_table(
925                     cls=parent,
926                     using=using,
927                     update_fields=update_fields,
928                     force_insert=parent_inserted,
929                 )
930                 if not updated:
931                     inserted = True
932                 updated_parents[parent] = updated
933             elif not parent_updated:
934                 inserted = True
935             # Set the parent's PK value to self.
936             if field:
937                 setattr(self, field.attname, self._get_pk_val(parent._meta))
938                 # Since we didn't have an instance of the parent handy set
939                 # attname directly, bypassing the descriptor. Invalidate
940                 # the related object cache, in case it's been accidentally
941                 # populated. A fresh instance will be re-built from the
942                 # database if necessary.
943                 if field.is_cached(self):
944                     field.delete_cached_value(self)
945         return inserted
946 
947     def _save_table(
948         self,
949         raw=False,
950         cls=None,
951         force_insert=False,
952         force_update=False,
953         using=None,
954         update_fields=None,
955     ):
956         """
957         Do the heavy-lifting involved in saving. Update or insert the data
958         for a single table.
959         """
960         meta = cls._meta
961         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
962 
963         if update_fields:
964             non_pks = [
965                 f
966                 for f in non_pks
967                 if f.name in update_fields or f.attname in update_fields
968             ]
969 
970         pk_val = self._get_pk_val(meta)
971         if pk_val is None:
972             pk_val = meta.pk.get_pk_value_on_save(self)
973             setattr(self, meta.pk.attname, pk_val)
974         pk_set = pk_val is not None
975         if not pk_set and (force_update or update_fields):
976             raise ValueError("Cannot force an update in save() with no primary key.")
977         updated = False
978         # Skip an UPDATE when adding an instance and primary key has a default.
979         if (
980             not raw
981             and not force_insert
982             and self._state.adding
983             and (
984                 (meta.pk.default and meta.pk.default is not NOT_PROVIDED)
985                 or (meta.pk.db_default and meta.pk.db_default is not NOT_PROVIDED)
986             )
987         ):
988             force_insert = True
989         # If possible, try an UPDATE. If that doesn't update anything, do an INSERT.
990         if pk_set and not force_insert:
991             base_qs = cls._base_manager.using(using)
992             values = [
993                 (
994                     f,
995                     None,
996                     (getattr(self, f.attname) if raw else f.pre_save(self, False)),
997                 )
998                 for f in non_pks
999             ]
1000             forced_update = update_fields or force_update
1001             updated = self._do_update(
1002                 base_qs, using, pk_val, values, update_fields, forced_update
1003             )
1004             if force_update and not updated:
1005                 raise DatabaseError("Forced update did not affect any rows.")
1006             if update_fields and not updated:
1007                 raise DatabaseError("Save with update_fields did not affect any rows.")
1008         if not updated:
1009             if meta.order_with_respect_to:
1010                 # If this is a model with an order_with_respect_to
1011                 # autopopulate the _order field
1012                 field = meta.order_with_respect_to
1013                 filter_args = field.get_filter_kwargs_for_object(self)
1014                 self._order = (
1015                     cls._base_manager.using(using)
1016                     .filter(**filter_args)
1017                     .aggregate(
1018                         _order__max=Coalesce(
1019                             ExpressionWrapper(
1020                                 Max("_order") + Value(1), output_field=IntegerField()
1021                             ),
1022                             Value(0),
1023                         ),
1024                     )["_order__max"]
1025                 )
1026             fields = meta.local_concrete_fields
1027             if not pk_set:
1028                 fields = [f for f in fields if f is not meta.auto_field]
1029 
1030             returning_fields = meta.db_returning_fields
1031             results = self._do_insert(
1032                 cls._base_manager, using, fields, returning_fields, raw
1033             )
1034             if results:
1035                 for value, field in zip(results[0], returning_fields):
1036                     setattr(self, field.attname, value)
1037         return updated
1038 
1039     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
1040         """
1041         Try to update the model. Return True if the model was updated (if an
1042         update query was done and a matching row was found in the DB).
1043         """
1044         filtered = base_qs.filter(pk=pk_val)
1045         if not values:
1046             # We can end up here when saving a model in inheritance chain where
1047             # update_fields doesn't target any field in current model. In that
1048             # case we just say the update succeeded. Another case ending up here
1049             # is a model with just PK - in that case check that the PK still
1050             # exists.
1051             return update_fields is not None or filtered.exists()
1052         if self._meta.select_on_save and not forced_update:
1053             return (
1054                 filtered.exists()
1055                 and
1056                 # It may happen that the object is deleted from the DB right after
1057                 # this check, causing the subsequent UPDATE to return zero matching
1058                 # rows. The same result can occur in some rare cases when the
1059                 # database returns zero despite the UPDATE being executed
1060                 # successfully (a row is matched and updated). In order to
1061                 # distinguish these two cases, the object's existence in the
1062                 # database is again checked for if the UPDATE query returns 0.
1063                 (filtered._update(values) > 0 or filtered.exists())
1064             )
1065         return filtered._update(values) > 0
1066 
1067     def _do_insert(self, manager, using, fields, returning_fields, raw):
1068         """
1069         Do an INSERT. If returning_fields is defined then this method should
1070         return the newly created data for the model.
1071         """
1072         return manager._insert(
1073             [self],
1074             fields=fields,
1075             returning_fields=returning_fields,
1076             using=using,
1077             raw=raw,
1078         )
1079 
1080     def _prepare_related_fields_for_save(self, operation_name, fields=None):
1081         # Ensure that a model instance without a PK hasn't been assigned to
1082         # a ForeignKey, GenericForeignKey or OneToOneField on this model. If
1083         # the field is nullable, allowing the save would result in silent data
1084         # loss.
1085         for field in self._meta.concrete_fields:
1086             if fields and field not in fields:
1087                 continue
1088             # If the related field isn't cached, then an instance hasn't been
1089             # assigned and there's no need to worry about this check.
1090             if field.is_relation and field.is_cached(self):
1091                 obj = getattr(self, field.name, None)
1092                 if not obj:
1093                     continue
1094                 # A pk may have been assigned manually to a model instance not
1095                 # saved to the database (or auto-generated in a case like
1096                 # UUIDField), but we allow the save to proceed and rely on the
1097                 # database to raise an IntegrityError if applicable. If
1098                 # constraints aren't supported by the database, there's the
1099                 # unavoidable risk of data corruption.
1100                 if obj.pk is None:
1101                     # Remove the object from a related instance cache.
1102                     if not field.remote_field.multiple:
1103                         field.remote_field.delete_cached_value(obj)
1104                     raise ValueError(
1105                         "%s() prohibited to prevent data loss due to unsaved "
1106                         "related object '%s'." % (operation_name, field.name)
1107                     )
1108                 elif getattr(self, field.attname) in field.empty_values:
1109                     # Set related object if it has been saved after an
1110                     # assignment.
1111                     setattr(self, field.name, obj)
1112                 # If the relationship's pk/to_field was changed, clear the
1113                 # cached relationship.
1114                 if getattr(obj, field.target_field.attname) != getattr(
1115                     self, field.attname
1116                 ):
1117                     field.delete_cached_value(self)
1118         # GenericForeignKeys are private.
1119         for field in self._meta.private_fields:
1120             if fields and field not in fields:
1121                 continue
1122             if (
1123                 field.is_relation
1124                 and field.is_cached(self)
1125                 and hasattr(field, "fk_field")
1126             ):
1127                 obj = field.get_cached_value(self, default=None)
1128                 if obj and obj.pk is None:
1129                     raise ValueError(
1130                         f"{operation_name}() prohibited to prevent data loss due to "
1131                         f"unsaved related object '{field.name}'."
1132                     )
1133 
1134     def delete(self, using=None, keep_parents=False):
1135         if self.pk is None:
1136             raise ValueError(
1137                 "%s object can't be deleted because its %s attribute is set "
1138                 "to None." % (self._meta.object_name, self._meta.pk.attname)
1139             )
1140         using = using or router.db_for_write(self.__class__, instance=self)
1141         collector = Collector(using=using, origin=self)
1142         collector.collect([self], keep_parents=keep_parents)
1143         return collector.delete()
1144 
1145     delete.alters_data = True
1146 
1147     async def adelete(self, using=None, keep_parents=False):
1148         return await sync_to_async(self.delete)(
1149             using=using,
1150             keep_parents=keep_parents,
1151         )
1152 
1153     adelete.alters_data = True
1154 
1155     def _get_FIELD_display(self, field):
1156         value = getattr(self, field.attname)
1157         choices_dict = dict(make_hashable(field.flatchoices))
1158         # force_str() to coerce lazy strings.
1159         return force_str(
1160             choices_dict.get(make_hashable(value), value), strings_only=True
1161         )
1162 
1163     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
1164         if not self.pk:
1165             raise ValueError("get_next/get_previous cannot be used on unsaved objects.")
1166         op = "gt" if is_next else "lt"
1167         order = "" if is_next else "-"
1168         param = getattr(self, field.attname)
1169         q = Q.create([(field.name, param), (f"pk__{op}", self.pk)], connector=Q.AND)
1170         q = Q.create([q, (f"{field.name}__{op}", param)], connector=Q.OR)
1171         qs = (
1172             self.__class__._default_manager.using(self._state.db)
1173             .filter(**kwargs)
1174             .filter(q)
1175             .order_by("%s%s" % (order, field.name), "%spk" % order)
1176         )
1177         try:
1178             return qs[0]
1179         except IndexError:
1180             raise self.DoesNotExist(
1181                 "%s matching query does not exist." % self.__class__._meta.object_name
1182             )
1183 
1184     def _get_next_or_previous_in_order(self, is_next):
1185         cachename = "__%s_order_cache" % is_next
1186         if not hasattr(self, cachename):
1187             op = "gt" if is_next else "lt"
1188             order = "_order" if is_next else "-_order"
1189             order_field = self._meta.order_with_respect_to
1190             filter_args = order_field.get_filter_kwargs_for_object(self)
1191             obj = (
1192                 self.__class__._default_manager.filter(**filter_args)
1193                 .filter(
1194                     **{
1195                         "_order__%s"
1196                         % op: self.__class__._default_manager.values("_order").filter(
1197                             **{self._meta.pk.name: self.pk}
1198                         )
1199                     }
1200                 )
1201                 .order_by(order)[:1]
1202                 .get()
1203             )
1204             setattr(self, cachename, obj)
1205         return getattr(self, cachename)
1206 
1207     def _get_field_value_map(self, meta, exclude=None):
1208         if exclude is None:
1209             exclude = set()
1210         meta = meta or self._meta
1211         return {
1212             field.name: Value(getattr(self, field.attname), field)
1213             for field in meta.local_concrete_fields
1214             if field.name not in exclude
1215         }
1216 
1217     def prepare_database_save(self, field):
1218         if self.pk is None:
1219             raise ValueError(
1220                 "Unsaved model instance %r cannot be used in an ORM query." % self
1221             )
1222         return getattr(self, field.remote_field.get_related_field().attname)
1223 
1224     def clean(self):
1225         """
1226         Hook for doing any extra model-wide validation after clean() has been
1227         called on every field by self.clean_fields. Any ValidationError raised
1228         by this method will not be associated with a particular field; it will
1229         have a special-case association with the field defined by NON_FIELD_ERRORS.
1230         """
1231         pass
1232 
1233     def validate_unique(self, exclude=None):
1234         """
1235         Check unique constraints on the model and raise ValidationError if any
1236         failed.
1237         """
1238         unique_checks, date_checks = self._get_unique_checks(exclude=exclude)
1239 
1240         errors = self._perform_unique_checks(unique_checks)
1241         date_errors = self._perform_date_checks(date_checks)
1242 
1243         for k, v in date_errors.items():
1244             errors.setdefault(k, []).extend(v)
1245 
1246         if errors:
1247             raise ValidationError(errors)
1248 
1249     def _get_unique_checks(self, exclude=None, include_meta_constraints=False):
1250         """
1251         Return a list of checks to perform. Since validate_unique() could be
1252         called from a ModelForm, some fields may have been excluded; we can't
1253         perform a unique check on a model that is missing fields involved
1254         in that check. Fields that did not validate should also be excluded,
1255         but they need to be passed in via the exclude argument.
1256         """
1257         if exclude is None:
1258             exclude = set()
1259         unique_checks = []
1260 
1261         unique_togethers = [(self.__class__, self._meta.unique_together)]
1262         constraints = []
1263         if include_meta_constraints:
1264             constraints = [(self.__class__, self._meta.total_unique_constraints)]
1265         for parent_class in self._meta.get_parent_list():
1266             if parent_class._meta.unique_together:
1267                 unique_togethers.append(
1268                     (parent_class, parent_class._meta.unique_together)
1269                 )
1270             if include_meta_constraints and parent_class._meta.total_unique_constraints:
1271                 constraints.append(
1272                     (parent_class, parent_class._meta.total_unique_constraints)
1273                 )
1274 
1275         for model_class, unique_together in unique_togethers:
1276             for check in unique_together:
1277                 if not any(name in exclude for name in check):
1278                     # Add the check if the field isn't excluded.
1279                     unique_checks.append((model_class, tuple(check)))
1280 
1281         if include_meta_constraints:
1282             for model_class, model_constraints in constraints:
1283                 for constraint in model_constraints:
1284                     if not any(name in exclude for name in constraint.fields):
1285                         unique_checks.append((model_class, constraint.fields))
1286 
1287         # These are checks for the unique_for_<date/year/month>.
1288         date_checks = []
1289 
1290         # Gather a list of checks for fields declared as unique and add them to
1291         # the list of checks.
1292 
1293         fields_with_class = [(self.__class__, self._meta.local_fields)]
1294         for parent_class in self._meta.get_parent_list():
1295             fields_with_class.append((parent_class, parent_class._meta.local_fields))
1296 
1297         for model_class, fields in fields_with_class:
1298             for f in fields:
1299                 name = f.name
1300                 if name in exclude:
1301                     continue
1302                 if f.unique:
1303                     unique_checks.append((model_class, (name,)))
1304                 if f.unique_for_date and f.unique_for_date not in exclude:
1305                     date_checks.append((model_class, "date", name, f.unique_for_date))
1306                 if f.unique_for_year and f.unique_for_year not in exclude:
1307                     date_checks.append((model_class, "year", name, f.unique_for_year))
1308                 if f.unique_for_month and f.unique_for_month not in exclude:
1309                     date_checks.append((model_class, "month", name, f.unique_for_month))
1310         return unique_checks, date_checks
1311 
1312     def _perform_unique_checks(self, unique_checks):
1313         errors = {}
1314 
1315         for model_class, unique_check in unique_checks:
1316             # Try to look up an existing object with the same values as this
1317             # object's values for all the unique field.
1318 
1319             lookup_kwargs = {}
1320             for field_name in unique_check:
1321                 f = self._meta.get_field(field_name)
1322                 lookup_value = getattr(self, f.attname)
1323                 # TODO: Handle multiple backends with different feature flags.
1324                 if lookup_value is None or (
1325                     lookup_value == ""
1326                     and connection.features.interprets_empty_strings_as_nulls
1327                 ):
1328                     # no value, skip the lookup
1329                     continue
1330                 if f.primary_key and not self._state.adding:
1331                     # no need to check for unique primary key when editing
1332                     continue
1333                 lookup_kwargs[str(field_name)] = lookup_value
1334 
1335             # some fields were skipped, no reason to do the check
1336             if len(unique_check) != len(lookup_kwargs):
1337                 continue
1338 
1339             qs = model_class._default_manager.filter(**lookup_kwargs)
1340 
1341             # Exclude the current object from the query if we are editing an
1342             # instance (as opposed to creating a new one)
1343             # Note that we need to use the pk as defined by model_class, not
1344             # self.pk. These can be different fields because model inheritance
1345             # allows single model to have effectively multiple primary keys.
1346             # Refs #17615.
1347             model_class_pk = self._get_pk_val(model_class._meta)
1348             if not self._state.adding and model_class_pk is not None:
1349                 qs = qs.exclude(pk=model_class_pk)
1350             if qs.exists():
1351                 if len(unique_check) == 1:
1352                     key = unique_check[0]
1353                 else:
1354                     key = NON_FIELD_ERRORS
1355                 errors.setdefault(key, []).append(
1356                     self.unique_error_message(model_class, unique_check)
1357                 )
1358 
1359         return errors
1360 
1361     def _perform_date_checks(self, date_checks):
1362         errors = {}
1363         for model_class, lookup_type, field, unique_for in date_checks:
1364             lookup_kwargs = {}
1365             # there's a ticket to add a date lookup, we can remove this special
1366             # case if that makes it's way in
1367             date = getattr(self, unique_for)
1368             if date is None:
1369                 continue
1370             if lookup_type == "date":
1371                 lookup_kwargs["%s__day" % unique_for] = date.day
1372                 lookup_kwargs["%s__month" % unique_for] = date.month
1373                 lookup_kwargs["%s__year" % unique_for] = date.year
1374             else:
1375                 lookup_kwargs["%s__%s" % (unique_for, lookup_type)] = getattr(
1376                     date, lookup_type
1377                 )
1378             lookup_kwargs[field] = getattr(self, field)
1379 
1380             qs = model_class._default_manager.filter(**lookup_kwargs)
1381             # Exclude the current object from the query if we are editing an
1382             # instance (as opposed to creating a new one)
1383             if not self._state.adding and self.pk is not None:
1384                 qs = qs.exclude(pk=self.pk)
1385 
1386             if qs.exists():
1387                 errors.setdefault(field, []).append(
1388                     self.date_error_message(lookup_type, field, unique_for)
1389                 )
1390         return errors
1391 
1392     def date_error_message(self, lookup_type, field_name, unique_for):
1393         opts = self._meta
1394         field = opts.get_field(field_name)
1395         return ValidationError(
1396             message=field.error_messages["unique_for_date"],
1397             code="unique_for_date",
1398             params={
1399                 "model": self,
1400                 "model_name": capfirst(opts.verbose_name),
1401                 "lookup_type": lookup_type,
1402                 "field": field_name,
1403                 "field_label": capfirst(field.verbose_name),
1404                 "date_field": unique_for,
1405                 "date_field_label": capfirst(opts.get_field(unique_for).verbose_name),
1406             },
1407         )
1408 
1409     def unique_error_message(self, model_class, unique_check):
1410         opts = model_class._meta
1411 
1412         params = {
1413             "model": self,
1414             "model_class": model_class,
1415             "model_name": capfirst(opts.verbose_name),
1416             "unique_check": unique_check,
1417         }
1418 
1419         # A unique field
1420         if len(unique_check) == 1:
1421             field = opts.get_field(unique_check[0])
1422             params["field_label"] = capfirst(field.verbose_name)
1423             return ValidationError(
1424                 message=field.error_messages["unique"],
1425                 code="unique",
1426                 params=params,
1427             )
1428 
1429         # unique_together
1430         else:
1431             field_labels = [
1432                 capfirst(opts.get_field(f).verbose_name) for f in unique_check
1433             ]
1434             params["field_labels"] = get_text_list(field_labels, _("and"))
1435             return ValidationError(
1436                 message=_("%(model_name)s with this %(field_labels)s already exists."),
1437                 code="unique_together",
1438                 params=params,
1439             )
1440 
1441     def get_constraints(self):
1442         constraints = [(self.__class__, self._meta.constraints)]
1443         for parent_class in self._meta.get_parent_list():
1444             if parent_class._meta.constraints:
1445                 constraints.append((parent_class, parent_class._meta.constraints))
1446         return constraints
1447 
1448     def validate_constraints(self, exclude=None):
1449         constraints = self.get_constraints()
1450         using = router.db_for_write(self.__class__, instance=self)
1451 
1452         errors = {}
1453         for model_class, model_constraints in constraints:
1454             for constraint in model_constraints:
1455                 try:
1456                     constraint.validate(model_class, self, exclude=exclude, using=using)
1457                 except ValidationError as e:
1458                     if (
1459                         getattr(e, "code", None) == "unique"
1460                         and len(constraint.fields) == 1
1461                     ):
1462                         errors.setdefault(constraint.fields[0], []).append(e)
1463                     else:
1464                         errors = e.update_error_dict(errors)
1465         if errors:
1466             raise ValidationError(errors)
1467 
1468     def full_clean(self, exclude=None, validate_unique=True, validate_constraints=True):
1469         """
1470         Call clean_fields(), clean(), validate_unique(), and
1471         validate_constraints() on the model. Raise a ValidationError for any
1472         errors that occur.
1473         """
1474         errors = {}
1475         if exclude is None:
1476             exclude = set()
1477         else:
1478             exclude = set(exclude)
1479 
1480         try:
1481             self.clean_fields(exclude=exclude)
1482         except ValidationError as e:
1483             errors = e.update_error_dict(errors)
1484 
1485         # Form.clean() is run even if other validation fails, so do the
1486         # same with Model.clean() for consistency.
1487         try:
1488             self.clean()
1489         except ValidationError as e:
1490             errors = e.update_error_dict(errors)
1491 
1492         # Run unique checks, but only for fields that passed validation.
1493         if validate_unique:
1494             for name in errors:
1495                 if name != NON_FIELD_ERRORS and name not in exclude:
1496                     exclude.add(name)
1497             try:
1498                 self.validate_unique(exclude=exclude)
1499             except ValidationError as e:
1500                 errors = e.update_error_dict(errors)
1501 
1502         # Run constraints checks, but only for fields that passed validation.
1503         if validate_constraints:
1504             for name in errors:
1505                 if name != NON_FIELD_ERRORS and name not in exclude:
1506                     exclude.add(name)
1507             try:
1508                 self.validate_constraints(exclude=exclude)
1509             except ValidationError as e:
1510                 errors = e.update_error_dict(errors)
1511 
1512         if errors:
1513             raise ValidationError(errors)
1514 
1515     def clean_fields(self, exclude=None):
1516         """
1517         Clean all fields and raise a ValidationError containing a dict
1518         of all validation errors if any occur.
1519         """
1520         if exclude is None:
1521             exclude = set()
1522 
1523         errors = {}
1524         for f in self._meta.fields:
1525             if f.name in exclude:
1526                 continue
1527             # Skip validation for empty fields with blank=True. The developer
1528             # is responsible for making sure they have a valid value.
1529             raw_value = getattr(self, f.attname)
1530             if f.blank and raw_value in f.empty_values:
1531                 continue
1532             try:
1533                 setattr(self, f.attname, f.clean(raw_value, self))
1534             except ValidationError as e:
1535                 errors[f.name] = e.error_list
1536 
1537         if errors:
1538             raise ValidationError(errors)
1539 
1540     @classmethod
1541     def check(cls, **kwargs):
1542         errors = [
1543             *cls._check_swappable(),
1544             *cls._check_model(),
1545             *cls._check_managers(**kwargs),
1546         ]
1547         if not cls._meta.swapped:
1548             databases = kwargs.get("databases") or []
1549             errors += [
1550                 *cls._check_fields(**kwargs),
1551                 *cls._check_m2m_through_same_relationship(),
1552                 *cls._check_long_column_names(databases),
1553             ]
1554             clash_errors = (
1555                 *cls._check_id_field(),
1556                 *cls._check_field_name_clashes(),
1557                 *cls._check_model_name_db_lookup_clashes(),
1558                 *cls._check_property_name_related_field_accessor_clashes(),
1559                 *cls._check_single_primary_key(),
1560             )
1561             errors.extend(clash_errors)
1562             # If there are field name clashes, hide consequent column name
1563             # clashes.
1564             if not clash_errors:
1565                 errors.extend(cls._check_column_name_clashes())
1566             errors += [
1567                 *cls._check_index_together(),
1568                 *cls._check_unique_together(),
1569                 *cls._check_indexes(databases),
1570                 *cls._check_ordering(),
1571                 *cls._check_constraints(databases),
1572                 *cls._check_default_pk(),
1573                 *cls._check_db_table_comment(databases),
1574             ]
1575 
1576         return errors
1577 
1578     @classmethod
1579     def _check_default_pk(cls):
1580         if (
1581             not cls._meta.abstract
1582             and cls._meta.pk.auto_created
1583             and
1584             # Inherited PKs are checked in parents models.
1585             not (
1586                 isinstance(cls._meta.pk, OneToOneField)
1587                 and cls._meta.pk.remote_field.parent_link
1588             )
1589             and not settings.is_overridden("DEFAULT_AUTO_FIELD")
1590             and cls._meta.app_config
1591             and not cls._meta.app_config._is_default_auto_field_overridden
1592         ):
1593             return [
1594                 checks.Warning(
1595                     f"Auto-created primary key used when not defining a "
1596                     f"primary key type, by default "
1597                     f"'{settings.DEFAULT_AUTO_FIELD}'.",
1598                     hint=(
1599                         f"Configure the DEFAULT_AUTO_FIELD setting or the "
1600                         f"{cls._meta.app_config.__class__.__qualname__}."
1601                         f"default_auto_field attribute to point to a subclass "
1602                         f"of AutoField, e.g. 'django.db.models.BigAutoField'."
1603                     ),
1604                     obj=cls,
1605                     id="models.W042",
1606                 ),
1607             ]
1608         return []
1609 
1610     @classmethod
1611     def _check_db_table_comment(cls, databases):
1612         if not cls._meta.db_table_comment:
1613             return []
1614         errors = []
1615         for db in databases:
1616             if not router.allow_migrate_model(db, cls):
1617                 continue
1618             connection = connections[db]
1619             if not (
1620                 connection.features.supports_comments
1621                 or "supports_comments" in cls._meta.required_db_features
1622             ):
1623                 errors.append(
1624                     checks.Warning(
1625                         f"{connection.display_name} does not support comments on "
1626                         f"tables (db_table_comment).",
1627                         obj=cls,
1628                         id="models.W046",
1629                     )
1630                 )
1631         return errors
1632 
1633     @classmethod
1634     def _check_swappable(cls):
1635         """Check if the swapped model exists."""
1636         errors = []
1637         if cls._meta.swapped:
1638             try:
1639                 apps.get_model(cls._meta.swapped)
1640             except ValueError:
1641                 errors.append(
1642                     checks.Error(
1643                         "'%s' is not of the form 'app_label.app_name'."
1644                         % cls._meta.swappable,
1645                         id="models.E001",
1646                     )
1647                 )
1648             except LookupError:
1649                 app_label, model_name = cls._meta.swapped.split(".")
1650                 errors.append(
1651                     checks.Error(
1652                         "'%s' references '%s.%s', which has not been "
1653                         "installed, or is abstract."
1654                         % (cls._meta.swappable, app_label, model_name),
1655                         id="models.E002",
1656                     )
1657                 )
1658         return errors
1659 
1660     @classmethod
1661     def _check_model(cls):
1662         errors = []
1663         if cls._meta.proxy:
1664             if cls._meta.local_fields or cls._meta.local_many_to_many:
1665                 errors.append(
1666                     checks.Error(
1667                         "Proxy model '%s' contains model fields." % cls.__name__,
1668                         id="models.E017",
1669                     )
1670                 )
1671         return errors
1672 
1673     @classmethod
1674     def _check_managers(cls, **kwargs):
1675         """Perform all manager checks."""
1676         errors = []
1677         for manager in cls._meta.managers:
1678             errors.extend(manager.check(**kwargs))
1679         return errors
1680 
1681     @classmethod
1682     def _check_fields(cls, **kwargs):
1683         """Perform all field checks."""
1684         errors = []
1685         for field in cls._meta.local_fields:
1686             errors.extend(field.check(**kwargs))
1687         for field in cls._meta.local_many_to_many:
1688             errors.extend(field.check(from_model=cls, **kwargs))
1689         return errors
1690 
1691     @classmethod
1692     def _check_m2m_through_same_relationship(cls):
1693         """Check if no relationship model is used by more than one m2m field."""
1694 
1695         errors = []
1696         seen_intermediary_signatures = []
1697 
1698         fields = cls._meta.local_many_to_many
1699 
1700         # Skip when the target model wasn't found.
1701         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1702 
1703         # Skip when the relationship model wasn't found.
1704         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1705 
1706         for f in fields:
1707             signature = (
1708                 f.remote_field.model,
1709                 cls,
1710                 f.remote_field.through,
1711                 f.remote_field.through_fields,
1712             )
1713             if signature in seen_intermediary_signatures:
1714                 errors.append(
1715                     checks.Error(
1716                         "The model has two identical many-to-many relations "
1717                         "through the intermediate model '%s'."
1718                         % f.remote_field.through._meta.label,
1719                         obj=cls,
1720                         id="models.E003",
1721                     )
1722                 )
1723             else:
1724                 seen_intermediary_signatures.append(signature)
1725         return errors
1726 
1727     @classmethod
1728     def _check_id_field(cls):
1729         """Check if `id` field is a primary key."""
1730         fields = [
1731             f for f in cls._meta.local_fields if f.name == "id" and f != cls._meta.pk
1732         ]
1733         # fields is empty or consists of the invalid "id" field
1734         if fields and not fields[0].primary_key and cls._meta.pk.name == "id":
1735             return [
1736                 checks.Error(
1737                     "'id' can only be used as a field name if the field also "
1738                     "sets 'primary_key=True'.",
1739                     obj=cls,
1740                     id="models.E004",
1741                 )
1742             ]
1743         else:
1744             return []
1745 
1746     @classmethod
1747     def _check_field_name_clashes(cls):
1748         """Forbid field shadowing in multi-table inheritance."""
1749         errors = []
1750         used_fields = {}  # name or attname -> field
1751 
1752         # Check that multi-inheritance doesn't cause field name shadowing.
1753         for parent in cls._meta.get_parent_list():
1754             for f in parent._meta.local_fields:
1755                 clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1756                 if clash:
1757                     errors.append(
1758                         checks.Error(
1759                             "The field '%s' from parent model "
1760                             "'%s' clashes with the field '%s' "
1761                             "from parent model '%s'."
1762                             % (clash.name, clash.model._meta, f.name, f.model._meta),
1763                             obj=cls,
1764                             id="models.E005",
1765                         )
1766                     )
1767                 used_fields[f.name] = f
1768                 used_fields[f.attname] = f
1769 
1770         # Check that fields defined in the model don't clash with fields from
1771         # parents, including auto-generated fields like multi-table inheritance
1772         # child accessors.
1773         for parent in cls._meta.get_parent_list():
1774             for f in parent._meta.get_fields():
1775                 if f not in used_fields:
1776                     used_fields[f.name] = f
1777 
1778         for f in cls._meta.local_fields:
1779             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1780             # Note that we may detect clash between user-defined non-unique
1781             # field "id" and automatically added unique field "id", both
1782             # defined at the same model. This special case is considered in
1783             # _check_id_field and here we ignore it.
1784             id_conflict = (
1785                 f.name == "id" and clash and clash.name == "id" and clash.model == cls
1786             )
1787             if clash and not id_conflict:
1788                 errors.append(
1789                     checks.Error(
1790                         "The field '%s' clashes with the field '%s' "
1791                         "from model '%s'." % (f.name, clash.name, clash.model._meta),
1792                         obj=f,
1793                         id="models.E006",
1794                     )
1795                 )
1796             used_fields[f.name] = f
1797             used_fields[f.attname] = f
1798 
1799         return errors
1800 
1801     @classmethod
1802     def _check_column_name_clashes(cls):
1803         # Store a list of column names which have already been used by other fields.
1804         used_column_names = []
1805         errors = []
1806 
1807         for f in cls._meta.local_fields:
1808             _, column_name = f.get_attname_column()
1809 
1810             # Ensure the column name is not already in use.
1811             if column_name and column_name in used_column_names:
1812                 errors.append(
1813                     checks.Error(
1814                         "Field '%s' has column name '%s' that is used by "
1815                         "another field." % (f.name, column_name),
1816                         hint="Specify a 'db_column' for the field.",
1817                         obj=cls,
1818                         id="models.E007",
1819                     )
1820                 )
1821             else:
1822                 used_column_names.append(column_name)
1823 
1824         return errors
1825 
1826     @classmethod
1827     def _check_model_name_db_lookup_clashes(cls):
1828         errors = []
1829         model_name = cls.__name__
1830         if model_name.startswith("_") or model_name.endswith("_"):
1831             errors.append(
1832                 checks.Error(
1833                     "The model name '%s' cannot start or end with an underscore "
1834                     "as it collides with the query lookup syntax." % model_name,
1835                     obj=cls,
1836                     id="models.E023",
1837                 )
1838             )
1839         elif LOOKUP_SEP in model_name:
1840             errors.append(
1841                 checks.Error(
1842                     "The model name '%s' cannot contain double underscores as "
1843                     "it collides with the query lookup syntax." % model_name,
1844                     obj=cls,
1845                     id="models.E024",
1846                 )
1847             )
1848         return errors
1849 
1850     @classmethod
1851     def _check_property_name_related_field_accessor_clashes(cls):
1852         errors = []
1853         property_names = cls._meta._property_names
1854         related_field_accessors = (
1855             f.get_attname()
1856             for f in cls._meta._get_fields(reverse=False)
1857             if f.is_relation and f.related_model is not None
1858         )
1859         for accessor in related_field_accessors:
1860             if accessor in property_names:
1861                 errors.append(
1862                     checks.Error(
1863                         "The property '%s' clashes with a related field "
1864                         "accessor." % accessor,
1865                         obj=cls,
1866                         id="models.E025",
1867                     )
1868                 )
1869         return errors
1870 
1871     @classmethod
1872     def _check_single_primary_key(cls):
1873         errors = []
1874         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1875             errors.append(
1876                 checks.Error(
1877                     "The model cannot have more than one field with "
1878                     "'primary_key=True'.",
1879                     obj=cls,
1880                     id="models.E026",
1881                 )
1882             )
1883         return errors
1884 
1885     # RemovedInDjango51Warning.
1886     @classmethod
1887     def _check_index_together(cls):
1888         """Check the value of "index_together" option."""
1889         if not isinstance(cls._meta.index_together, (tuple, list)):
1890             return [
1891                 checks.Error(
1892                     "'index_together' must be a list or tuple.",
1893                     obj=cls,
1894                     id="models.E008",
1895                 )
1896             ]
1897 
1898         elif any(
1899             not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together
1900         ):
1901             return [
1902                 checks.Error(
1903                     "All 'index_together' elements must be lists or tuples.",
1904                     obj=cls,
1905                     id="models.E009",
1906                 )
1907             ]
1908 
1909         else:
1910             errors = []
1911             for fields in cls._meta.index_together:
1912                 errors.extend(cls._check_local_fields(fields, "index_together"))
1913             return errors
1914 
1915     @classmethod
1916     def _check_unique_together(cls):
1917         """Check the value of "unique_together" option."""
1918         if not isinstance(cls._meta.unique_together, (tuple, list)):
1919             return [
1920                 checks.Error(
1921                     "'unique_together' must be a list or tuple.",
1922                     obj=cls,
1923                     id="models.E010",
1924                 )
1925             ]
1926 
1927         elif any(
1928             not isinstance(fields, (tuple, list))
1929             for fields in cls._meta.unique_together
1930         ):
1931             return [
1932                 checks.Error(
1933                     "All 'unique_together' elements must be lists or tuples.",
1934                     obj=cls,
1935                     id="models.E011",
1936                 )
1937             ]
1938 
1939         else:
1940             errors = []
1941             for fields in cls._meta.unique_together:
1942                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1943             return errors
1944 
1945     @classmethod
1946     def _check_indexes(cls, databases):
1947         """Check fields, names, and conditions of indexes."""
1948         errors = []
1949         references = set()
1950         for index in cls._meta.indexes:
1951             # Index name can't start with an underscore or a number, restricted
1952             # for cross-database compatibility with Oracle.
1953             if index.name[0] == "_" or index.name[0].isdigit():
1954                 errors.append(
1955                     checks.Error(
1956                         "The index name '%s' cannot start with an underscore "
1957                         "or a number." % index.name,
1958                         obj=cls,
1959                         id="models.E033",
1960                     ),
1961                 )
1962             if len(index.name) > index.max_name_length:
1963                 errors.append(
1964                     checks.Error(
1965                         "The index name '%s' cannot be longer than %d "
1966                         "characters." % (index.name, index.max_name_length),
1967                         obj=cls,
1968                         id="models.E034",
1969                     ),
1970                 )
1971             if index.contains_expressions:
1972                 for expression in index.expressions:
1973                     references.update(
1974                         ref[0] for ref in cls._get_expr_references(expression)
1975                     )
1976         for db in databases:
1977             if not router.allow_migrate_model(db, cls):
1978                 continue
1979             connection = connections[db]
1980             if not (
1981                 connection.features.supports_partial_indexes
1982                 or "supports_partial_indexes" in cls._meta.required_db_features
1983             ) and any(index.condition is not None for index in cls._meta.indexes):
1984                 errors.append(
1985                     checks.Warning(
1986                         "%s does not support indexes with conditions."
1987                         % connection.display_name,
1988                         hint=(
1989                             "Conditions will be ignored. Silence this warning "
1990                             "if you don't care about it."
1991                         ),
1992                         obj=cls,
1993                         id="models.W037",
1994                     )
1995                 )
1996             if not (
1997                 connection.features.supports_covering_indexes
1998                 or "supports_covering_indexes" in cls._meta.required_db_features
1999             ) and any(index.include for index in cls._meta.indexes):
2000                 errors.append(
2001                     checks.Warning(
2002                         "%s does not support indexes with non-key columns."
2003                         % connection.display_name,
2004                         hint=(
2005                             "Non-key columns will be ignored. Silence this "
2006                             "warning if you don't care about it."
2007                         ),
2008                         obj=cls,
2009                         id="models.W040",
2010                     )
2011                 )
2012             if not (
2013                 connection.features.supports_expression_indexes
2014                 or "supports_expression_indexes" in cls._meta.required_db_features
2015             ) and any(index.contains_expressions for index in cls._meta.indexes):
2016                 errors.append(
2017                     checks.Warning(
2018                         "%s does not support indexes on expressions."
2019                         % connection.display_name,
2020                         hint=(
2021                             "An index won't be created. Silence this warning "
2022                             "if you don't care about it."
2023                         ),
2024                         obj=cls,
2025                         id="models.W043",
2026                     )
2027                 )
2028         fields = [
2029             field for index in cls._meta.indexes for field, _ in index.fields_orders
2030         ]
2031         fields += [include for index in cls._meta.indexes for include in index.include]
2032         fields += references
2033         errors.extend(cls._check_local_fields(fields, "indexes"))
2034         return errors
2035 
2036     @classmethod
2037     def _check_local_fields(cls, fields, option):
2038         from django.db import models
2039 
2040         # In order to avoid hitting the relation tree prematurely, we use our
2041         # own fields_map instead of using get_field()
2042         forward_fields_map = {}
2043         for field in cls._meta._get_fields(reverse=False):
2044             forward_fields_map[field.name] = field
2045             if hasattr(field, "attname"):
2046                 forward_fields_map[field.attname] = field
2047 
2048         errors = []
2049         for field_name in fields:
2050             try:
2051                 field = forward_fields_map[field_name]
2052             except KeyError:
2053                 errors.append(
2054                     checks.Error(
2055                         "'%s' refers to the nonexistent field '%s'."
2056                         % (
2057                             option,
2058                             field_name,
2059                         ),
2060                         obj=cls,
2061                         id="models.E012",
2062                     )
2063                 )
2064             else:
2065                 if isinstance(field.remote_field, models.ManyToManyRel):
2066                     errors.append(
2067                         checks.Error(
2068                             "'%s' refers to a ManyToManyField '%s', but "
2069                             "ManyToManyFields are not permitted in '%s'."
2070                             % (
2071                                 option,
2072                                 field_name,
2073                                 option,
2074                             ),
2075                             obj=cls,
2076                             id="models.E013",
2077                         )
2078                     )
2079                 elif field not in cls._meta.local_fields:
2080                     errors.append(
2081                         checks.Error(
2082                             "'%s' refers to field '%s' which is not local to model "
2083                             "'%s'." % (option, field_name, cls._meta.object_name),
2084                             hint="This issue may be caused by multi-table inheritance.",
2085                             obj=cls,
2086                             id="models.E016",
2087                         )
2088                     )
2089         return errors
2090 
2091     @classmethod
2092     def _check_ordering(cls):
2093         """
2094         Check "ordering" option -- is it a list of strings and do all fields
2095         exist?
2096         """
2097         if cls._meta._ordering_clash:
2098             return [
2099                 checks.Error(
2100                     "'ordering' and 'order_with_respect_to' cannot be used together.",
2101                     obj=cls,
2102                     id="models.E021",
2103                 ),
2104             ]
2105 
2106         if cls._meta.order_with_respect_to or not cls._meta.ordering:
2107             return []
2108 
2109         if not isinstance(cls._meta.ordering, (list, tuple)):
2110             return [
2111                 checks.Error(
2112                     "'ordering' must be a tuple or list (even if you want to order by "
2113                     "only one field).",
2114                     obj=cls,
2115                     id="models.E014",
2116                 )
2117             ]
2118 
2119         errors = []
2120         fields = cls._meta.ordering
2121 
2122         # Skip expressions and '?' fields.
2123         fields = (f for f in fields if isinstance(f, str) and f != "?")
2124 
2125         # Convert "-field" to "field".
2126         fields = (f.removeprefix("-") for f in fields)
2127 
2128         # Separate related fields and non-related fields.
2129         _fields = []
2130         related_fields = []
2131         for f in fields:
2132             if LOOKUP_SEP in f:
2133                 related_fields.append(f)
2134             else:
2135                 _fields.append(f)
2136         fields = _fields
2137 
2138         # Check related fields.
2139         for field in related_fields:
2140             _cls = cls
2141             fld = None
2142             for part in field.split(LOOKUP_SEP):
2143                 try:
2144                     # pk is an alias that won't be found by opts.get_field.
2145                     if part == "pk":
2146                         fld = _cls._meta.pk
2147                     else:
2148                         fld = _cls._meta.get_field(part)
2149                     if fld.is_relation:
2150                         _cls = fld.path_infos[-1].to_opts.model
2151                     else:
2152                         _cls = None
2153                 except (FieldDoesNotExist, AttributeError):
2154                     if fld is None or (
2155                         fld.get_transform(part) is None and fld.get_lookup(part) is None
2156                     ):
2157                         errors.append(
2158                             checks.Error(
2159                                 "'ordering' refers to the nonexistent field, "
2160                                 "related field, or lookup '%s'." % field,
2161                                 obj=cls,
2162                                 id="models.E015",
2163                             )
2164                         )
2165 
2166         # Skip ordering on pk. This is always a valid order_by field
2167         # but is an alias and therefore won't be found by opts.get_field.
2168         fields = {f for f in fields if f != "pk"}
2169 
2170         # Check for invalid or nonexistent fields in ordering.
2171         invalid_fields = []
2172 
2173         # Any field name that is not present in field_names does not exist.
2174         # Also, ordering by m2m fields is not allowed.
2175         opts = cls._meta
2176         valid_fields = set(
2177             chain.from_iterable(
2178                 (f.name, f.attname)
2179                 if not (f.auto_created and not f.concrete)
2180                 else (f.field.related_query_name(),)
2181                 for f in chain(opts.fields, opts.related_objects)
2182             )
2183         )
2184 
2185         invalid_fields.extend(fields - valid_fields)
2186 
2187         for invalid_field in invalid_fields:
2188             errors.append(
2189                 checks.Error(
2190                     "'ordering' refers to the nonexistent field, related "
2191                     "field, or lookup '%s'." % invalid_field,
2192                     obj=cls,
2193                     id="models.E015",
2194                 )
2195             )
2196         return errors
2197 
2198     @classmethod
2199     def _check_long_column_names(cls, databases):
2200         """
2201         Check that any auto-generated column names are shorter than the limits
2202         for each database in which the model will be created.
2203         """
2204         if not databases:
2205             return []
2206         errors = []
2207         allowed_len = None
2208         db_alias = None
2209 
2210         # Find the minimum max allowed length among all specified db_aliases.
2211         for db in databases:
2212             # skip databases where the model won't be created
2213             if not router.allow_migrate_model(db, cls):
2214                 continue
2215             connection = connections[db]
2216             max_name_length = connection.ops.max_name_length()
2217             if max_name_length is None or connection.features.truncates_names:
2218                 continue
2219             else:
2220                 if allowed_len is None:
2221                     allowed_len = max_name_length
2222                     db_alias = db
2223                 elif max_name_length < allowed_len:
2224                     allowed_len = max_name_length
2225                     db_alias = db
2226 
2227         if allowed_len is None:
2228             return errors
2229 
2230         for f in cls._meta.local_fields:
2231             _, column_name = f.get_attname_column()
2232 
2233             # Check if auto-generated name for the field is too long
2234             # for the database.
2235             if (
2236                 f.db_column is None
2237                 and column_name is not None
2238                 and len(column_name) > allowed_len
2239             ):
2240                 errors.append(
2241                     checks.Error(
2242                         'Autogenerated column name too long for field "%s". '
2243                         'Maximum length is "%s" for database "%s".'
2244                         % (column_name, allowed_len, db_alias),
2245                         hint="Set the column name manually using 'db_column'.",
2246                         obj=cls,
2247                         id="models.E018",
2248                     )
2249                 )
2250 
2251         for f in cls._meta.local_many_to_many:
2252             # Skip nonexistent models.
2253             if isinstance(f.remote_field.through, str):
2254                 continue
2255 
2256             # Check if auto-generated name for the M2M field is too long
2257             # for the database.
2258             for m2m in f.remote_field.through._meta.local_fields:
2259                 _, rel_name = m2m.get_attname_column()
2260                 if (
2261                     m2m.db_column is None
2262                     and rel_name is not None
2263                     and len(rel_name) > allowed_len
2264                 ):
2265                     errors.append(
2266                         checks.Error(
2267                             "Autogenerated column name too long for M2M field "
2268                             '"%s". Maximum length is "%s" for database "%s".'
2269                             % (rel_name, allowed_len, db_alias),
2270                             hint=(
2271                                 "Use 'through' to create a separate model for "
2272                                 "M2M and then set column_name using 'db_column'."
2273                             ),
2274                             obj=cls,
2275                             id="models.E019",
2276                         )
2277                     )
2278 
2279         return errors
2280 
2281     @classmethod
2282     def _get_expr_references(cls, expr):
2283         if isinstance(expr, Q):
2284             for child in expr.children:
2285                 if isinstance(child, tuple):
2286                     lookup, value = child
2287                     yield tuple(lookup.split(LOOKUP_SEP))
2288                     yield from cls._get_expr_references(value)
2289                 else:
2290                     yield from cls._get_expr_references(child)
2291         elif isinstance(expr, F):
2292             yield tuple(expr.name.split(LOOKUP_SEP))
2293         elif hasattr(expr, "get_source_expressions"):
2294             for src_expr in expr.get_source_expressions():
2295                 yield from cls._get_expr_references(src_expr)
2296 
2297     @classmethod
2298     def _check_constraints(cls, databases):
2299         errors = []
2300         for db in databases:
2301             if not router.allow_migrate_model(db, cls):
2302                 continue
2303             connection = connections[db]
2304             if not (
2305                 connection.features.supports_table_check_constraints
2306                 or "supports_table_check_constraints" in cls._meta.required_db_features
2307             ) and any(
2308                 isinstance(constraint, CheckConstraint)
2309                 for constraint in cls._meta.constraints
2310             ):
2311                 errors.append(
2312                     checks.Warning(
2313                         "%s does not support check constraints."
2314                         % connection.display_name,
2315                         hint=(
2316                             "A constraint won't be created. Silence this "
2317                             "warning if you don't care about it."
2318                         ),
2319                         obj=cls,
2320                         id="models.W027",
2321                     )
2322                 )
2323             if not (
2324                 connection.features.supports_partial_indexes
2325                 or "supports_partial_indexes" in cls._meta.required_db_features
2326             ) and any(
2327                 isinstance(constraint, UniqueConstraint)
2328                 and constraint.condition is not None
2329                 for constraint in cls._meta.constraints
2330             ):
2331                 errors.append(
2332                     checks.Warning(
2333                         "%s does not support unique constraints with "
2334                         "conditions." % connection.display_name,
2335                         hint=(
2336                             "A constraint won't be created. Silence this "
2337                             "warning if you don't care about it."
2338                         ),
2339                         obj=cls,
2340                         id="models.W036",
2341                     )
2342                 )
2343             if not (
2344                 connection.features.supports_deferrable_unique_constraints
2345                 or "supports_deferrable_unique_constraints"
2346                 in cls._meta.required_db_features
2347             ) and any(
2348                 isinstance(constraint, UniqueConstraint)
2349                 and constraint.deferrable is not None
2350                 for constraint in cls._meta.constraints
2351             ):
2352                 errors.append(
2353                     checks.Warning(
2354                         "%s does not support deferrable unique constraints."
2355                         % connection.display_name,
2356                         hint=(
2357                             "A constraint won't be created. Silence this "
2358                             "warning if you don't care about it."
2359                         ),
2360                         obj=cls,
2361                         id="models.W038",
2362                     )
2363                 )
2364             if not (
2365                 connection.features.supports_covering_indexes
2366                 or "supports_covering_indexes" in cls._meta.required_db_features
2367             ) and any(
2368                 isinstance(constraint, UniqueConstraint) and constraint.include
2369                 for constraint in cls._meta.constraints
2370             ):
2371                 errors.append(
2372                     checks.Warning(
2373                         "%s does not support unique constraints with non-key "
2374                         "columns." % connection.display_name,
2375                         hint=(
2376                             "A constraint won't be created. Silence this "
2377                             "warning if you don't care about it."
2378                         ),
2379                         obj=cls,
2380                         id="models.W039",
2381                     )
2382                 )
2383             if not (
2384                 connection.features.supports_expression_indexes
2385                 or "supports_expression_indexes" in cls._meta.required_db_features
2386             ) and any(
2387                 isinstance(constraint, UniqueConstraint)
2388                 and constraint.contains_expressions
2389                 for constraint in cls._meta.constraints
2390             ):
2391                 errors.append(
2392                     checks.Warning(
2393                         "%s does not support unique constraints on "
2394                         "expressions." % connection.display_name,
2395                         hint=(
2396                             "A constraint won't be created. Silence this "
2397                             "warning if you don't care about it."
2398                         ),
2399                         obj=cls,
2400                         id="models.W044",
2401                     )
2402                 )
2403             fields = set(
2404                 chain.from_iterable(
2405                     (*constraint.fields, *constraint.include)
2406                     for constraint in cls._meta.constraints
2407                     if isinstance(constraint, UniqueConstraint)
2408                 )
2409             )
2410             references = set()
2411             for constraint in cls._meta.constraints:
2412                 if isinstance(constraint, UniqueConstraint):
2413                     if (
2414                         connection.features.supports_partial_indexes
2415                         or "supports_partial_indexes"
2416                         not in cls._meta.required_db_features
2417                     ) and isinstance(constraint.condition, Q):
2418                         references.update(
2419                             cls._get_expr_references(constraint.condition)
2420                         )
2421                     if (
2422                         connection.features.supports_expression_indexes
2423                         or "supports_expression_indexes"
2424                         not in cls._meta.required_db_features
2425                     ) and constraint.contains_expressions:
2426                         for expression in constraint.expressions:
2427                             references.update(cls._get_expr_references(expression))
2428                 elif isinstance(constraint, CheckConstraint):
2429                     if (
2430                         connection.features.supports_table_check_constraints
2431                         or "supports_table_check_constraints"
2432                         not in cls._meta.required_db_features
2433                     ):
2434                         if isinstance(constraint.check, Q):
2435                             references.update(
2436                                 cls._get_expr_references(constraint.check)
2437                             )
2438                         if any(
2439                             isinstance(expr, RawSQL)
2440                             for expr in constraint.check.flatten()
2441                         ):
2442                             errors.append(
2443                                 checks.Warning(
2444                                     f"Check constraint {constraint.name!r} contains "
2445                                     f"RawSQL() expression and won't be validated "
2446                                     f"during the model full_clean().",
2447                                     hint=(
2448                                         "Silence this warning if you don't care about "
2449                                         "it."
2450                                     ),
2451                                     obj=cls,
2452                                     id="models.W045",
2453                                 ),
2454                             )
2455             for field_name, *lookups in references:
2456                 # pk is an alias that won't be found by opts.get_field.
2457                 if field_name != "pk":
2458                     fields.add(field_name)
2459                 if not lookups:
2460                     # If it has no lookups it cannot result in a JOIN.
2461                     continue
2462                 try:
2463                     if field_name == "pk":
2464                         field = cls._meta.pk
2465                     else:
2466                         field = cls._meta.get_field(field_name)
2467                     if not field.is_relation or field.many_to_many or field.one_to_many:
2468                         continue
2469                 except FieldDoesNotExist:
2470                     continue
2471                 # JOIN must happen at the first lookup.
2472                 first_lookup = lookups[0]
2473                 if (
2474                     hasattr(field, "get_transform")
2475                     and hasattr(field, "get_lookup")
2476                     and field.get_transform(first_lookup) is None
2477                     and field.get_lookup(first_lookup) is None
2478                 ):
2479                     errors.append(
2480                         checks.Error(
2481                             "'constraints' refers to the joined field '%s'."
2482                             % LOOKUP_SEP.join([field_name] + lookups),
2483                             obj=cls,
2484                             id="models.E041",
2485                         )
2486                     )
2487             errors.extend(cls._check_local_fields(fields, "constraints"))
2488         return errors

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:06:22.432 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 14:06:22.432 | INFO     | Search-only: skipping patch selection
2025-10-17 14:06:22.587 | INFO     | Task django__django-16952 completed successfully.
2025-10-17 14:06:22.588 | INFO     | No patch generated. You can try running ACR again.
