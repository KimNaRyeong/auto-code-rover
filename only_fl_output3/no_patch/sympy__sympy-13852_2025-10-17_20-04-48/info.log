2025-10-17 20:04:49.071 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 20:04:59.121 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=662, output_tokens=12, cost=0.006980
2025-10-17 20:05:14.753 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=842, output_tokens=661, cost=0.028250
2025-10-17 20:05:16.446 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:05:23.574 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=965, output_tokens=339, cost=0.019820
2025-10-17 20:05:23.581 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:05:25.661 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=693, output_tokens=50, cost=0.008430
2025-10-17 20:05:25.663 | DEBUG    | Extracted a valid json.
2025-10-17 20:05:25.663 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"polylog\")",
        "search_method(\"expand_func\")",
        "search_method(\"diff\")",
        "search_method(\"log\")"
    ],
    "bug_locations": []
}
2025-10-17 20:05:25.690 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:05:25.690 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:05:40.615 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2092, output_tokens=622, cost=0.039580
2025-10-17 20:05:40.628 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:05:45.249 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2930, output_tokens=176, cost=0.034580
2025-10-17 20:05:45.254 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:05:46.817 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=530, output_tokens=37, cost=0.006410
2025-10-17 20:05:46.819 | DEBUG    | Extracted a valid json.
2025-10-17 20:05:46.819 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"polylog\")", "search_method(\"exp_polar\")", "search_method(\"expand\")"],
    "bug_locations": []
}
2025-10-17 20:05:46.966 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:05:46.966 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:06:10.359 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3574, output_tokens=791, cost=0.059470
2025-10-17 20:06:10.366 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:06:22.276 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4581, output_tokens=459, cost=0.059580
2025-10-17 20:06:22.285 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:06:30.032 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=813, output_tokens=247, cost=0.015540
2025-10-17 20:06:30.033 | DEBUG    | Extracted a valid json.
2025-10-17 20:06:30.033 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/functions/special/zeta_functions.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code responsible for `polylog` should correctly handle special case evaluations and expansions to produce results in line with known mathematical identities. For `polylog(2, Rational(1,2))`, ensuring it simplifies correctly to `-log(2)**2/2 + pi**2/12`. For `polylog(1, z)`, the implementation should reflect the mathematical equivalence to `-log(1-z)` accurately without unnecessary or incorrect use of `exp_polar(-I*pi)`."
        },
        {
            "file": "sympy/core/function.py",
            "class": "",
            "method": "expand_func",
            "intended_behavior": "While this method itself may not be faulty, it's probable that the expansion rules or hints it relies upon (especially those related to `polylog`) may need adjustment. Specifically, `expand_func` should ensure that expansions involving `polylog` adhere to mathematical expectations without introducing inconsistencies."
        }
    ]
}
2025-10-17 20:06:30.040 | DEBUG    | Bug location extracted successfully: [<file>sympy/functions/special/zeta_functions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Riemann zeta and related function. """
2 from __future__ import print_function, division
3 
4 from sympy.core import Function, S, sympify, pi
5 from sympy.core.function import ArgumentIndexError
6 from sympy.core.compatibility import range
7 from sympy.functions.combinatorial.numbers import bernoulli, factorial, harmonic
8 from sympy.functions.elementary.exponential import log
9 
10 
11 ###############################################################################
12 ###################### LERCH TRANSCENDENT #####################################
13 ###############################################################################
14 
15 
16 class lerchphi(Function):
17     r"""
18     Lerch transcendent (Lerch phi function).
19 
20     For :math:`\operatorname{Re}(a) > 0`, `|z| < 1` and `s \in \mathbb{C}`, the
21     Lerch transcendent is defined as
22 
23     .. math :: \Phi(z, s, a) = \sum_{n=0}^\infty \frac{z^n}{(n + a)^s},
24 
25     where the standard branch of the argument is used for :math:`n + a`,
26     and by analytic continuation for other values of the parameters.
27 
28     A commonly used related function is the Lerch zeta function, defined by
29 
30     .. math:: L(q, s, a) = \Phi(e^{2\pi i q}, s, a).
31 
32     **Analytic Continuation and Branching Behavior**
33 
34     It can be shown that
35 
36     .. math:: \Phi(z, s, a) = z\Phi(z, s, a+1) + a^{-s}.
37 
38     This provides the analytic continuation to `\operatorname{Re}(a) \le 0`.
39 
40     Assume now `\operatorname{Re}(a) > 0`. The integral representation
41 
42     .. math:: \Phi_0(z, s, a) = \int_0^\infty \frac{t^{s-1} e^{-at}}{1 - ze^{-t}}
43                                 \frac{\mathrm{d}t}{\Gamma(s)}
44 
45     provides an analytic continuation to :math:`\mathbb{C} - [1, \infty)`.
46     Finally, for :math:`x \in (1, \infty)` we find
47 
48     .. math:: \lim_{\epsilon \to 0^+} \Phi_0(x + i\epsilon, s, a)
49              -\lim_{\epsilon \to 0^+} \Phi_0(x - i\epsilon, s, a)
50              = \frac{2\pi i \log^{s-1}{x}}{x^a \Gamma(s)},
51 
52     using the standard branch for both :math:`\log{x}` and
53     :math:`\log{\log{x}}` (a branch of :math:`\log{\log{x}}` is needed to
54     evaluate :math:`\log{x}^{s-1}`).
55     This concludes the analytic continuation. The Lerch transcendent is thus
56     branched at :math:`z \in \{0, 1, \infty\}` and
57     :math:`a \in \mathbb{Z}_{\le 0}`. For fixed :math:`z, a` outside these
58     branch points, it is an entire function of :math:`s`.
59 
60     See Also
61     ========
62 
63     polylog, zeta
64 
65     References
66     ==========
67 
68     .. [1] Bateman, H.; Erdelyi, A. (1953), Higher Transcendental Functions,
69            Vol. I, New York: McGraw-Hill. Section 1.11.
70     .. [2] http://dlmf.nist.gov/25.14
71     .. [3] http://en.wikipedia.org/wiki/Lerch_transcendent
72 
73     Examples
74     ========
75 
76     The Lerch transcendent is a fairly general function, for this reason it does
77     not automatically evaluate to simpler functions. Use expand_func() to
78     achieve this.
79 
80     If :math:`z=1`, the Lerch transcendent reduces to the Hurwitz zeta function:
81 
82     >>> from sympy import lerchphi, expand_func
83     >>> from sympy.abc import z, s, a
84     >>> expand_func(lerchphi(1, s, a))
85     zeta(s, a)
86 
87     More generally, if :math:`z` is a root of unity, the Lerch transcendent
88     reduces to a sum of Hurwitz zeta functions:
89 
90     >>> expand_func(lerchphi(-1, s, a))
91     2**(-s)*zeta(s, a/2) - 2**(-s)*zeta(s, a/2 + 1/2)
92 
93     If :math:`a=1`, the Lerch transcendent reduces to the polylogarithm:
94 
95     >>> expand_func(lerchphi(z, s, 1))
96     polylog(s, z)/z
97 
98     More generally, if :math:`a` is rational, the Lerch transcendent reduces
99     to a sum of polylogarithms:
100 
101     >>> from sympy import S
102     >>> expand_func(lerchphi(z, s, S(1)/2))
103     2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -
104                 polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))
105     >>> expand_func(lerchphi(z, s, S(3)/2))
106     -2**s/z + 2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -
107                           polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))/z
108 
109     The derivatives with respect to :math:`z` and :math:`a` can be computed in
110     closed form:
111 
112     >>> lerchphi(z, s, a).diff(z)
113     (-a*lerchphi(z, s, a) + lerchphi(z, s - 1, a))/z
114     >>> lerchphi(z, s, a).diff(a)
115     -s*lerchphi(z, s + 1, a)
116     """
117 
118     def _eval_expand_func(self, **hints):
119         from sympy import exp, I, floor, Add, Poly, Dummy, exp_polar, unpolarify
120         z, s, a = self.args
121         if z == 1:
122             return zeta(s, a)
123         if s.is_Integer and s <= 0:
124             t = Dummy('t')
125             p = Poly((t + a)**(-s), t)
126             start = 1/(1 - t)
127             res = S(0)
128             for c in reversed(p.all_coeffs()):
129                 res += c*start
130                 start = t*start.diff(t)
131             return res.subs(t, z)
132 
133         if a.is_Rational:
134             # See section 18 of
135             #   Kelly B. Roach.  Hypergeometric Function Representations.
136             #   In: Proceedings of the 1997 International Symposium on Symbolic and
137             #   Algebraic Computation, pages 205-211, New York, 1997. ACM.
138             # TODO should something be polarified here?
139             add = S(0)
140             mul = S(1)
141             # First reduce a to the interaval (0, 1]
142             if a > 1:
143                 n = floor(a)
144                 if n == a:
145                     n -= 1
146                 a -= n
147                 mul = z**(-n)
148                 add = Add(*[-z**(k - n)/(a + k)**s for k in range(n)])
149             elif a <= 0:
150                 n = floor(-a) + 1
151                 a += n
152                 mul = z**n
153                 add = Add(*[z**(n - 1 - k)/(a - k - 1)**s for k in range(n)])
154 
155             m, n = S([a.p, a.q])
156             zet = exp_polar(2*pi*I/n)
157             root = z**(1/n)
158             return add + mul*n**(s - 1)*Add(
159                 *[polylog(s, zet**k*root)._eval_expand_func(**hints)
160                   / (unpolarify(zet)**k*root)**m for k in range(n)])
161 
162         # TODO use minpoly instead of ad-hoc methods when issue 5888 is fixed
163         if isinstance(z, exp) and (z.args[0]/(pi*I)).is_Rational or z in [-1, I, -I]:
164             # TODO reference?
165             if z == -1:
166                 p, q = S([1, 2])
167             elif z == I:
168                 p, q = S([1, 4])
169             elif z == -I:
170                 p, q = S([-1, 4])
171             else:
172                 arg = z.args[0]/(2*pi*I)
173                 p, q = S([arg.p, arg.q])
174             return Add(*[exp(2*pi*I*k*p/q)/q**s*zeta(s, (k + a)/q)
175                          for k in range(q)])
176 
177         return lerchphi(z, s, a)
178 
179     def fdiff(self, argindex=1):
180         z, s, a = self.args
181         if argindex == 3:
182             return -s*lerchphi(z, s + 1, a)
183         elif argindex == 1:
184             return (lerchphi(z, s - 1, a) - a*lerchphi(z, s, a))/z
185         else:
186             raise ArgumentIndexError
187 
188     def _eval_rewrite_helper(self, z, s, a, target):
189         res = self._eval_expand_func()
190         if res.has(target):
191             return res
192         else:
193             return self
194 
195     def _eval_rewrite_as_zeta(self, z, s, a):
196         return self._eval_rewrite_helper(z, s, a, zeta)
197 
198     def _eval_rewrite_as_polylog(self, z, s, a):
199         return self._eval_rewrite_helper(z, s, a, polylog)
200 
201 ###############################################################################
202 ###################### POLYLOGARITHM ##########################################
203 ###############################################################################
204 
205 
206 class polylog(Function):
207     r"""
208     Polylogarithm function.
209 
210     For :math:`|z| < 1` and :math:`s \in \mathbb{C}`, the polylogarithm is
211     defined by
212 
213     .. math:: \operatorname{Li}_s(z) = \sum_{n=1}^\infty \frac{z^n}{n^s},
214 
215     where the standard branch of the argument is used for :math:`n`. It admits
216     an analytic continuation which is branched at :math:`z=1` (notably not on the
217     sheet of initial definition), :math:`z=0` and :math:`z=\infty`.
218 
219     The name polylogarithm comes from the fact that for :math:`s=1`, the
220     polylogarithm is related to the ordinary logarithm (see examples), and that
221 
222     .. math:: \operatorname{Li}_{s+1}(z) =
223                     \int_0^z \frac{\operatorname{Li}_s(t)}{t} \mathrm{d}t.
224 
225     The polylogarithm is a special case of the Lerch transcendent:
226 
227     .. math:: \operatorname{Li}_{s}(z) = z \Phi(z, s, 1)
228 
229     See Also
230     ========
231 
232     zeta, lerchphi
233 
234     Examples
235     ========
236 
237     For :math:`z \in \{0, 1, -1\}`, the polylogarithm is automatically expressed
238     using other functions:
239 
240     >>> from sympy import polylog
241     >>> from sympy.abc import s
242     >>> polylog(s, 0)
243     0
244     >>> polylog(s, 1)
245     zeta(s)
246     >>> polylog(s, -1)
247     -dirichlet_eta(s)
248 
249     If :math:`s` is a negative integer, :math:`0` or :math:`1`, the
250     polylogarithm can be expressed using elementary functions. This can be
251     done using expand_func():
252 
253     >>> from sympy import expand_func
254     >>> from sympy.abc import z
255     >>> expand_func(polylog(1, z))
256     -log(z*exp_polar(-I*pi) + 1)
257     >>> expand_func(polylog(0, z))
258     z/(-z + 1)
259 
260     The derivative with respect to :math:`z` can be computed in closed form:
261 
262     >>> polylog(s, z).diff(z)
263     polylog(s - 1, z)/z
264 
265     The polylogarithm can be expressed in terms of the lerch transcendent:
266 
267     >>> from sympy import lerchphi
268     >>> polylog(s, z).rewrite(lerchphi)
269     z*lerchphi(z, s, 1)
270     """
271 
272     @classmethod
273     def eval(cls, s, z):
274         if z == 1:
275             return zeta(s)
276         elif z == -1:
277             return -dirichlet_eta(s)
278         elif z == 0:
279             return 0
280 
281     def fdiff(self, argindex=1):
282         s, z = self.args
283         if argindex == 2:
284             return polylog(s - 1, z)/z
285         raise ArgumentIndexError
286 
287     def _eval_rewrite_as_lerchphi(self, s, z):
288         return z*lerchphi(z, s, 1)
289 
290     def _eval_expand_func(self, **hints):
291         from sympy import log, expand_mul, Dummy, exp_polar, I
292         s, z = self.args
293         if s == 1:
294             return -log(1 + exp_polar(-I*pi)*z)
295         if s.is_Integer and s <= 0:
296             u = Dummy('u')
297             start = u/(1 - u)
298             for _ in range(-s):
299                 start = u*start.diff(u)
300             return expand_mul(start).subs(u, z)
301         return polylog(s, z)
302 
303 ###############################################################################
304 ###################### HURWITZ GENERALIZED ZETA FUNCTION ######################
305 ###############################################################################
306 
307 
308 class zeta(Function):
309     r"""
310     Hurwitz zeta function (or Riemann zeta function).
311 
312     For `\operatorname{Re}(a) > 0` and `\operatorname{Re}(s) > 1`, this function is defined as
313 
314     .. math:: \zeta(s, a) = \sum_{n=0}^\infty \frac{1}{(n + a)^s},
315 
316     where the standard choice of argument for :math:`n + a` is used. For fixed
317     :math:`a` with `\operatorname{Re}(a) > 0` the Hurwitz zeta function admits a
318     meromorphic continuation to all of :math:`\mathbb{C}`, it is an unbranched
319     function with a simple pole at :math:`s = 1`.
320 
321     Analytic continuation to other :math:`a` is possible under some circumstances,
322     but this is not typically done.
323 
324     The Hurwitz zeta function is a special case of the Lerch transcendent:
325 
326     .. math:: \zeta(s, a) = \Phi(1, s, a).
327 
328     This formula defines an analytic continuation for all possible values of
329     :math:`s` and :math:`a` (also `\operatorname{Re}(a) < 0`), see the documentation of
330     :class:`lerchphi` for a description of the branching behavior.
331 
332     If no value is passed for :math:`a`, by this function assumes a default value
333     of :math:`a = 1`, yielding the Riemann zeta function.
334 
335     See Also
336     ========
337 
338     dirichlet_eta, lerchphi, polylog
339 
340     References
341     ==========
342 
343     .. [1] http://dlmf.nist.gov/25.11
344     .. [2] http://en.wikipedia.org/wiki/Hurwitz_zeta_function
345 
346     Examples
347     ========
348 
349     For :math:`a = 1` the Hurwitz zeta function reduces to the famous Riemann
350     zeta function:
351 
352     .. math:: \zeta(s, 1) = \zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s}.
353 
354     >>> from sympy import zeta
355     >>> from sympy.abc import s
356     >>> zeta(s, 1)
357     zeta(s)
358     >>> zeta(s)
359     zeta(s)
360 
361     The Riemann zeta function can also be expressed using the Dirichlet eta
362     function:
363 
364     >>> from sympy import dirichlet_eta
365     >>> zeta(s).rewrite(dirichlet_eta)
366     dirichlet_eta(s)/(-2**(-s + 1) + 1)
367 
368     The Riemann zeta function at positive even integer and negative odd integer
369     values is related to the Bernoulli numbers:
370 
371     >>> zeta(2)
372     pi**2/6
373     >>> zeta(4)
374     pi**4/90
375     >>> zeta(-1)
376     -1/12
377 
378     The specific formulae are:
379 
380     .. math:: \zeta(2n) = (-1)^{n+1} \frac{B_{2n} (2\pi)^{2n}}{2(2n)!}
381     .. math:: \zeta(-n) = -\frac{B_{n+1}}{n+1}
382 
383     At negative even integers the Riemann zeta function is zero:
384 
385     >>> zeta(-4)
386     0
387 
388     No closed-form expressions are known at positive odd integers, but
389     numerical evaluation is possible:
390 
391     >>> zeta(3).n()
392     1.20205690315959
393 
394     The derivative of :math:`\zeta(s, a)` with respect to :math:`a` is easily
395     computed:
396 
397     >>> from sympy.abc import a
398     >>> zeta(s, a).diff(a)
399     -s*zeta(s + 1, a)
400 
401     However the derivative with respect to :math:`s` has no useful closed form
402     expression:
403 
404     >>> zeta(s, a).diff(s)
405     Derivative(zeta(s, a), s)
406 
407     The Hurwitz zeta function can be expressed in terms of the Lerch transcendent,
408     :class:`sympy.functions.special.lerchphi`:
409 
410     >>> from sympy import lerchphi
411     >>> zeta(s, a).rewrite(lerchphi)
412     lerchphi(1, s, a)
413 
414     """
415 
416     @classmethod
417     def eval(cls, z, a_=None):
418         if a_ is None:
419             z, a = list(map(sympify, (z, 1)))
420         else:
421             z, a = list(map(sympify, (z, a_)))
422 
423         if a.is_Number:
424             if a is S.NaN:
425                 return S.NaN
426             elif a is S.One and a_ is not None:
427                 return cls(z)
428             # TODO Should a == 0 return S.NaN as well?
429 
430         if z.is_Number:
431             if z is S.NaN:
432                 return S.NaN
433             elif z is S.Infinity:
434                 return S.One
435             elif z is S.Zero:
436                 return S.Half - a
437             elif z is S.One:
438                 return S.ComplexInfinity
439             elif z.is_Integer:
440                 if a.is_Integer:
441                     if z.is_negative:
442                         zeta = (-1)**z * bernoulli(-z + 1)/(-z + 1)
443                     elif z.is_even:
444                         B, F = bernoulli(z), factorial(z)
445                         zeta = 2**(z - 1) * abs(B) * pi**z / F
446                     else:
447                         return
448 
449                     if a.is_negative:
450                         return zeta + harmonic(abs(a), z)
451                     else:
452                         return zeta - harmonic(a - 1, z)
453 
454     def _eval_rewrite_as_dirichlet_eta(self, s, a=1):
455         if a != 1:
456             return self
457         s = self.args[0]
458         return dirichlet_eta(s)/(1 - 2**(1 - s))
459 
460     def _eval_rewrite_as_lerchphi(self, s, a=1):
461         return lerchphi(1, s, a)
462 
463     def _eval_is_finite(self):
464         arg_is_one = (self.args[0] - 1).is_zero
465         if arg_is_one is not None:
466             return not arg_is_one
467 
468     def fdiff(self, argindex=1):
469         if len(self.args) == 2:
470             s, a = self.args
471         else:
472             s, a = self.args + (1,)
473         if argindex == 2:
474             return -s*zeta(s + 1, a)
475         else:
476             raise ArgumentIndexError
477 
478 
479 class dirichlet_eta(Function):
480     r"""
481     Dirichlet eta function.
482 
483     For `\operatorname{Re}(s) > 0`, this function is defined as
484 
485     .. math:: \eta(s) = \sum_{n=1}^\infty \frac{(-1)^n}{n^s}.
486 
487     It admits a unique analytic continuation to all of :math:`\mathbb{C}`.
488     It is an entire, unbranched function.
489 
490     See Also
491     ========
492 
493     zeta
494 
495     References
496     ==========
497 
498     .. [1] http://en.wikipedia.org/wiki/Dirichlet_eta_function
499 
500     Examples
501     ========
502 
503     The Dirichlet eta function is closely related to the Riemann zeta function:
504 
505     >>> from sympy import dirichlet_eta, zeta
506     >>> from sympy.abc import s
507     >>> dirichlet_eta(s).rewrite(zeta)
508     (-2**(-s + 1) + 1)*zeta(s)
509 
510     """
511 
512     @classmethod
513     def eval(cls, s):
514         if s == 1:
515             return log(2)
516         z = zeta(s)
517         if not z.has(zeta):
518             return (1 - 2**(1 - s))*z
519 
520     def _eval_rewrite_as_zeta(self, s):
521         return (1 - 2**(1 - s)) * zeta(s)
522 
523 
524 class stieltjes(Function):
525     r"""Represents Stieltjes constants, :math:`\gamma_{k}` that occur in
526     Laurent Series expansion of the Riemann zeta function.
527 
528     Examples
529     ========
530 
531     >>> from sympy import stieltjes
532     >>> from sympy.abc import n, m
533     >>> stieltjes(n)
534     stieltjes(n)
535 
536     zero'th stieltjes constant
537 
538     >>> stieltjes(0)
539     EulerGamma
540     >>> stieltjes(0, 1)
541     EulerGamma
542 
543     For generalized stieltjes constants
544 
545     >>> stieltjes(n, m)
546     stieltjes(n, m)
547 
548     Constants are only defined for integers >= 0
549 
550     >>> stieltjes(-1)
551     zoo
552 
553     References
554     ==========
555 
556     .. [1] http://en.wikipedia.org/wiki/Stieltjes_constants
557     """
558 
559     @classmethod
560     def eval(cls, n, a=None):
561         n = sympify(n)
562 
563         if a != None:
564             a = sympify(a)
565             if a is S.NaN:
566                 return S.NaN
567             if a.is_Integer and a.is_nonpositive:
568                 return S.ComplexInfinity
569 
570         if n.is_Number:
571             if n is S.NaN:
572                 return S.NaN
573             elif n < 0:
574                 return S.ComplexInfinity
575             elif not n.is_Integer:
576                 return S.ComplexInfinity
577             elif n == 0 and a in [None, 1]:
578                 return S.EulerGamma

</code><intended_behavior>The code responsible for `polylog` should correctly handle special case evaluations and expansions to produce results in line with known mathematical identities. For `polylog(2, Rational(1,2))`, ensuring it simplifies correctly to `-log(2)**2/2 + pi**2/12`. For `polylog(1, z)`, the implementation should reflect the mathematical equivalence to `-log(1-z)` accurately without unnecessary or incorrect use of `exp_polar(-I*pi)`.</intended_behavior>, <file>sympy/core/function.py</file>
<class>None</class>
<method>expand_func</method>
<code>
2383 def expand_func(expr, deep=True):
2384     """
2385     Wrapper around expand that only uses the func hint.  See the expand
2386     docstring for more information.
2387 
2388     Examples
2389     ========
2390 
2391     >>> from sympy import expand_func, gamma
2392     >>> from sympy.abc import x
2393     >>> expand_func(gamma(x + 2))
2394     x*(x + 1)*gamma(x)
2395 
2396     """
2397     return sympify(expr).expand(deep=deep, func=True, basic=False,
2398     log=False, mul=False, power_exp=False, power_base=False, multinomial=False)

</code><intended_behavior>While this method itself may not be faulty, it's probable that the expansion rules or hints it relies upon (especially those related to `polylog`) may need adjustment. Specifically, `expand_func` should ensure that expansions involving `polylog` adhere to mathematical expectations without introducing inconsistencies.</intended_behavior>]
2025-10-17 20:06:30.040 | INFO     | Search completed. Bug locations: [<file>sympy/functions/special/zeta_functions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Riemann zeta and related function. """
2 from __future__ import print_function, division
3 
4 from sympy.core import Function, S, sympify, pi
5 from sympy.core.function import ArgumentIndexError
6 from sympy.core.compatibility import range
7 from sympy.functions.combinatorial.numbers import bernoulli, factorial, harmonic
8 from sympy.functions.elementary.exponential import log
9 
10 
11 ###############################################################################
12 ###################### LERCH TRANSCENDENT #####################################
13 ###############################################################################
14 
15 
16 class lerchphi(Function):
17     r"""
18     Lerch transcendent (Lerch phi function).
19 
20     For :math:`\operatorname{Re}(a) > 0`, `|z| < 1` and `s \in \mathbb{C}`, the
21     Lerch transcendent is defined as
22 
23     .. math :: \Phi(z, s, a) = \sum_{n=0}^\infty \frac{z^n}{(n + a)^s},
24 
25     where the standard branch of the argument is used for :math:`n + a`,
26     and by analytic continuation for other values of the parameters.
27 
28     A commonly used related function is the Lerch zeta function, defined by
29 
30     .. math:: L(q, s, a) = \Phi(e^{2\pi i q}, s, a).
31 
32     **Analytic Continuation and Branching Behavior**
33 
34     It can be shown that
35 
36     .. math:: \Phi(z, s, a) = z\Phi(z, s, a+1) + a^{-s}.
37 
38     This provides the analytic continuation to `\operatorname{Re}(a) \le 0`.
39 
40     Assume now `\operatorname{Re}(a) > 0`. The integral representation
41 
42     .. math:: \Phi_0(z, s, a) = \int_0^\infty \frac{t^{s-1} e^{-at}}{1 - ze^{-t}}
43                                 \frac{\mathrm{d}t}{\Gamma(s)}
44 
45     provides an analytic continuation to :math:`\mathbb{C} - [1, \infty)`.
46     Finally, for :math:`x \in (1, \infty)` we find
47 
48     .. math:: \lim_{\epsilon \to 0^+} \Phi_0(x + i\epsilon, s, a)
49              -\lim_{\epsilon \to 0^+} \Phi_0(x - i\epsilon, s, a)
50              = \frac{2\pi i \log^{s-1}{x}}{x^a \Gamma(s)},
51 
52     using the standard branch for both :math:`\log{x}` and
53     :math:`\log{\log{x}}` (a branch of :math:`\log{\log{x}}` is needed to
54     evaluate :math:`\log{x}^{s-1}`).
55     This concludes the analytic continuation. The Lerch transcendent is thus
56     branched at :math:`z \in \{0, 1, \infty\}` and
57     :math:`a \in \mathbb{Z}_{\le 0}`. For fixed :math:`z, a` outside these
58     branch points, it is an entire function of :math:`s`.
59 
60     See Also
61     ========
62 
63     polylog, zeta
64 
65     References
66     ==========
67 
68     .. [1] Bateman, H.; Erdelyi, A. (1953), Higher Transcendental Functions,
69            Vol. I, New York: McGraw-Hill. Section 1.11.
70     .. [2] http://dlmf.nist.gov/25.14
71     .. [3] http://en.wikipedia.org/wiki/Lerch_transcendent
72 
73     Examples
74     ========
75 
76     The Lerch transcendent is a fairly general function, for this reason it does
77     not automatically evaluate to simpler functions. Use expand_func() to
78     achieve this.
79 
80     If :math:`z=1`, the Lerch transcendent reduces to the Hurwitz zeta function:
81 
82     >>> from sympy import lerchphi, expand_func
83     >>> from sympy.abc import z, s, a
84     >>> expand_func(lerchphi(1, s, a))
85     zeta(s, a)
86 
87     More generally, if :math:`z` is a root of unity, the Lerch transcendent
88     reduces to a sum of Hurwitz zeta functions:
89 
90     >>> expand_func(lerchphi(-1, s, a))
91     2**(-s)*zeta(s, a/2) - 2**(-s)*zeta(s, a/2 + 1/2)
92 
93     If :math:`a=1`, the Lerch transcendent reduces to the polylogarithm:
94 
95     >>> expand_func(lerchphi(z, s, 1))
96     polylog(s, z)/z
97 
98     More generally, if :math:`a` is rational, the Lerch transcendent reduces
99     to a sum of polylogarithms:
100 
101     >>> from sympy import S
102     >>> expand_func(lerchphi(z, s, S(1)/2))
103     2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -
104                 polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))
105     >>> expand_func(lerchphi(z, s, S(3)/2))
106     -2**s/z + 2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -
107                           polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))/z
108 
109     The derivatives with respect to :math:`z` and :math:`a` can be computed in
110     closed form:
111 
112     >>> lerchphi(z, s, a).diff(z)
113     (-a*lerchphi(z, s, a) + lerchphi(z, s - 1, a))/z
114     >>> lerchphi(z, s, a).diff(a)
115     -s*lerchphi(z, s + 1, a)
116     """
117 
118     def _eval_expand_func(self, **hints):
119         from sympy import exp, I, floor, Add, Poly, Dummy, exp_polar, unpolarify
120         z, s, a = self.args
121         if z == 1:
122             return zeta(s, a)
123         if s.is_Integer and s <= 0:
124             t = Dummy('t')
125             p = Poly((t + a)**(-s), t)
126             start = 1/(1 - t)
127             res = S(0)
128             for c in reversed(p.all_coeffs()):
129                 res += c*start
130                 start = t*start.diff(t)
131             return res.subs(t, z)
132 
133         if a.is_Rational:
134             # See section 18 of
135             #   Kelly B. Roach.  Hypergeometric Function Representations.
136             #   In: Proceedings of the 1997 International Symposium on Symbolic and
137             #   Algebraic Computation, pages 205-211, New York, 1997. ACM.
138             # TODO should something be polarified here?
139             add = S(0)
140             mul = S(1)
141             # First reduce a to the interaval (0, 1]
142             if a > 1:
143                 n = floor(a)
144                 if n == a:
145                     n -= 1
146                 a -= n
147                 mul = z**(-n)
148                 add = Add(*[-z**(k - n)/(a + k)**s for k in range(n)])
149             elif a <= 0:
150                 n = floor(-a) + 1
151                 a += n
152                 mul = z**n
153                 add = Add(*[z**(n - 1 - k)/(a - k - 1)**s for k in range(n)])
154 
155             m, n = S([a.p, a.q])
156             zet = exp_polar(2*pi*I/n)
157             root = z**(1/n)
158             return add + mul*n**(s - 1)*Add(
159                 *[polylog(s, zet**k*root)._eval_expand_func(**hints)
160                   / (unpolarify(zet)**k*root)**m for k in range(n)])
161 
162         # TODO use minpoly instead of ad-hoc methods when issue 5888 is fixed
163         if isinstance(z, exp) and (z.args[0]/(pi*I)).is_Rational or z in [-1, I, -I]:
164             # TODO reference?
165             if z == -1:
166                 p, q = S([1, 2])
167             elif z == I:
168                 p, q = S([1, 4])
169             elif z == -I:
170                 p, q = S([-1, 4])
171             else:
172                 arg = z.args[0]/(2*pi*I)
173                 p, q = S([arg.p, arg.q])
174             return Add(*[exp(2*pi*I*k*p/q)/q**s*zeta(s, (k + a)/q)
175                          for k in range(q)])
176 
177         return lerchphi(z, s, a)
178 
179     def fdiff(self, argindex=1):
180         z, s, a = self.args
181         if argindex == 3:
182             return -s*lerchphi(z, s + 1, a)
183         elif argindex == 1:
184             return (lerchphi(z, s - 1, a) - a*lerchphi(z, s, a))/z
185         else:
186             raise ArgumentIndexError
187 
188     def _eval_rewrite_helper(self, z, s, a, target):
189         res = self._eval_expand_func()
190         if res.has(target):
191             return res
192         else:
193             return self
194 
195     def _eval_rewrite_as_zeta(self, z, s, a):
196         return self._eval_rewrite_helper(z, s, a, zeta)
197 
198     def _eval_rewrite_as_polylog(self, z, s, a):
199         return self._eval_rewrite_helper(z, s, a, polylog)
200 
201 ###############################################################################
202 ###################### POLYLOGARITHM ##########################################
203 ###############################################################################
204 
205 
206 class polylog(Function):
207     r"""
208     Polylogarithm function.
209 
210     For :math:`|z| < 1` and :math:`s \in \mathbb{C}`, the polylogarithm is
211     defined by
212 
213     .. math:: \operatorname{Li}_s(z) = \sum_{n=1}^\infty \frac{z^n}{n^s},
214 
215     where the standard branch of the argument is used for :math:`n`. It admits
216     an analytic continuation which is branched at :math:`z=1` (notably not on the
217     sheet of initial definition), :math:`z=0` and :math:`z=\infty`.
218 
219     The name polylogarithm comes from the fact that for :math:`s=1`, the
220     polylogarithm is related to the ordinary logarithm (see examples), and that
221 
222     .. math:: \operatorname{Li}_{s+1}(z) =
223                     \int_0^z \frac{\operatorname{Li}_s(t)}{t} \mathrm{d}t.
224 
225     The polylogarithm is a special case of the Lerch transcendent:
226 
227     .. math:: \operatorname{Li}_{s}(z) = z \Phi(z, s, 1)
228 
229     See Also
230     ========
231 
232     zeta, lerchphi
233 
234     Examples
235     ========
236 
237     For :math:`z \in \{0, 1, -1\}`, the polylogarithm is automatically expressed
238     using other functions:
239 
240     >>> from sympy import polylog
241     >>> from sympy.abc import s
242     >>> polylog(s, 0)
243     0
244     >>> polylog(s, 1)
245     zeta(s)
246     >>> polylog(s, -1)
247     -dirichlet_eta(s)
248 
249     If :math:`s` is a negative integer, :math:`0` or :math:`1`, the
250     polylogarithm can be expressed using elementary functions. This can be
251     done using expand_func():
252 
253     >>> from sympy import expand_func
254     >>> from sympy.abc import z
255     >>> expand_func(polylog(1, z))
256     -log(z*exp_polar(-I*pi) + 1)
257     >>> expand_func(polylog(0, z))
258     z/(-z + 1)
259 
260     The derivative with respect to :math:`z` can be computed in closed form:
261 
262     >>> polylog(s, z).diff(z)
263     polylog(s - 1, z)/z
264 
265     The polylogarithm can be expressed in terms of the lerch transcendent:
266 
267     >>> from sympy import lerchphi
268     >>> polylog(s, z).rewrite(lerchphi)
269     z*lerchphi(z, s, 1)
270     """
271 
272     @classmethod
273     def eval(cls, s, z):
274         if z == 1:
275             return zeta(s)
276         elif z == -1:
277             return -dirichlet_eta(s)
278         elif z == 0:
279             return 0
280 
281     def fdiff(self, argindex=1):
282         s, z = self.args
283         if argindex == 2:
284             return polylog(s - 1, z)/z
285         raise ArgumentIndexError
286 
287     def _eval_rewrite_as_lerchphi(self, s, z):
288         return z*lerchphi(z, s, 1)
289 
290     def _eval_expand_func(self, **hints):
291         from sympy import log, expand_mul, Dummy, exp_polar, I
292         s, z = self.args
293         if s == 1:
294             return -log(1 + exp_polar(-I*pi)*z)
295         if s.is_Integer and s <= 0:
296             u = Dummy('u')
297             start = u/(1 - u)
298             for _ in range(-s):
299                 start = u*start.diff(u)
300             return expand_mul(start).subs(u, z)
301         return polylog(s, z)
302 
303 ###############################################################################
304 ###################### HURWITZ GENERALIZED ZETA FUNCTION ######################
305 ###############################################################################
306 
307 
308 class zeta(Function):
309     r"""
310     Hurwitz zeta function (or Riemann zeta function).
311 
312     For `\operatorname{Re}(a) > 0` and `\operatorname{Re}(s) > 1`, this function is defined as
313 
314     .. math:: \zeta(s, a) = \sum_{n=0}^\infty \frac{1}{(n + a)^s},
315 
316     where the standard choice of argument for :math:`n + a` is used. For fixed
317     :math:`a` with `\operatorname{Re}(a) > 0` the Hurwitz zeta function admits a
318     meromorphic continuation to all of :math:`\mathbb{C}`, it is an unbranched
319     function with a simple pole at :math:`s = 1`.
320 
321     Analytic continuation to other :math:`a` is possible under some circumstances,
322     but this is not typically done.
323 
324     The Hurwitz zeta function is a special case of the Lerch transcendent:
325 
326     .. math:: \zeta(s, a) = \Phi(1, s, a).
327 
328     This formula defines an analytic continuation for all possible values of
329     :math:`s` and :math:`a` (also `\operatorname{Re}(a) < 0`), see the documentation of
330     :class:`lerchphi` for a description of the branching behavior.
331 
332     If no value is passed for :math:`a`, by this function assumes a default value
333     of :math:`a = 1`, yielding the Riemann zeta function.
334 
335     See Also
336     ========
337 
338     dirichlet_eta, lerchphi, polylog
339 
340     References
341     ==========
342 
343     .. [1] http://dlmf.nist.gov/25.11
344     .. [2] http://en.wikipedia.org/wiki/Hurwitz_zeta_function
345 
346     Examples
347     ========
348 
349     For :math:`a = 1` the Hurwitz zeta function reduces to the famous Riemann
350     zeta function:
351 
352     .. math:: \zeta(s, 1) = \zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s}.
353 
354     >>> from sympy import zeta
355     >>> from sympy.abc import s
356     >>> zeta(s, 1)
357     zeta(s)
358     >>> zeta(s)
359     zeta(s)
360 
361     The Riemann zeta function can also be expressed using the Dirichlet eta
362     function:
363 
364     >>> from sympy import dirichlet_eta
365     >>> zeta(s).rewrite(dirichlet_eta)
366     dirichlet_eta(s)/(-2**(-s + 1) + 1)
367 
368     The Riemann zeta function at positive even integer and negative odd integer
369     values is related to the Bernoulli numbers:
370 
371     >>> zeta(2)
372     pi**2/6
373     >>> zeta(4)
374     pi**4/90
375     >>> zeta(-1)
376     -1/12
377 
378     The specific formulae are:
379 
380     .. math:: \zeta(2n) = (-1)^{n+1} \frac{B_{2n} (2\pi)^{2n}}{2(2n)!}
381     .. math:: \zeta(-n) = -\frac{B_{n+1}}{n+1}
382 
383     At negative even integers the Riemann zeta function is zero:
384 
385     >>> zeta(-4)
386     0
387 
388     No closed-form expressions are known at positive odd integers, but
389     numerical evaluation is possible:
390 
391     >>> zeta(3).n()
392     1.20205690315959
393 
394     The derivative of :math:`\zeta(s, a)` with respect to :math:`a` is easily
395     computed:
396 
397     >>> from sympy.abc import a
398     >>> zeta(s, a).diff(a)
399     -s*zeta(s + 1, a)
400 
401     However the derivative with respect to :math:`s` has no useful closed form
402     expression:
403 
404     >>> zeta(s, a).diff(s)
405     Derivative(zeta(s, a), s)
406 
407     The Hurwitz zeta function can be expressed in terms of the Lerch transcendent,
408     :class:`sympy.functions.special.lerchphi`:
409 
410     >>> from sympy import lerchphi
411     >>> zeta(s, a).rewrite(lerchphi)
412     lerchphi(1, s, a)
413 
414     """
415 
416     @classmethod
417     def eval(cls, z, a_=None):
418         if a_ is None:
419             z, a = list(map(sympify, (z, 1)))
420         else:
421             z, a = list(map(sympify, (z, a_)))
422 
423         if a.is_Number:
424             if a is S.NaN:
425                 return S.NaN
426             elif a is S.One and a_ is not None:
427                 return cls(z)
428             # TODO Should a == 0 return S.NaN as well?
429 
430         if z.is_Number:
431             if z is S.NaN:
432                 return S.NaN
433             elif z is S.Infinity:
434                 return S.One
435             elif z is S.Zero:
436                 return S.Half - a
437             elif z is S.One:
438                 return S.ComplexInfinity
439             elif z.is_Integer:
440                 if a.is_Integer:
441                     if z.is_negative:
442                         zeta = (-1)**z * bernoulli(-z + 1)/(-z + 1)
443                     elif z.is_even:
444                         B, F = bernoulli(z), factorial(z)
445                         zeta = 2**(z - 1) * abs(B) * pi**z / F
446                     else:
447                         return
448 
449                     if a.is_negative:
450                         return zeta + harmonic(abs(a), z)
451                     else:
452                         return zeta - harmonic(a - 1, z)
453 
454     def _eval_rewrite_as_dirichlet_eta(self, s, a=1):
455         if a != 1:
456             return self
457         s = self.args[0]
458         return dirichlet_eta(s)/(1 - 2**(1 - s))
459 
460     def _eval_rewrite_as_lerchphi(self, s, a=1):
461         return lerchphi(1, s, a)
462 
463     def _eval_is_finite(self):
464         arg_is_one = (self.args[0] - 1).is_zero
465         if arg_is_one is not None:
466             return not arg_is_one
467 
468     def fdiff(self, argindex=1):
469         if len(self.args) == 2:
470             s, a = self.args
471         else:
472             s, a = self.args + (1,)
473         if argindex == 2:
474             return -s*zeta(s + 1, a)
475         else:
476             raise ArgumentIndexError
477 
478 
479 class dirichlet_eta(Function):
480     r"""
481     Dirichlet eta function.
482 
483     For `\operatorname{Re}(s) > 0`, this function is defined as
484 
485     .. math:: \eta(s) = \sum_{n=1}^\infty \frac{(-1)^n}{n^s}.
486 
487     It admits a unique analytic continuation to all of :math:`\mathbb{C}`.
488     It is an entire, unbranched function.
489 
490     See Also
491     ========
492 
493     zeta
494 
495     References
496     ==========
497 
498     .. [1] http://en.wikipedia.org/wiki/Dirichlet_eta_function
499 
500     Examples
501     ========
502 
503     The Dirichlet eta function is closely related to the Riemann zeta function:
504 
505     >>> from sympy import dirichlet_eta, zeta
506     >>> from sympy.abc import s
507     >>> dirichlet_eta(s).rewrite(zeta)
508     (-2**(-s + 1) + 1)*zeta(s)
509 
510     """
511 
512     @classmethod
513     def eval(cls, s):
514         if s == 1:
515             return log(2)
516         z = zeta(s)
517         if not z.has(zeta):
518             return (1 - 2**(1 - s))*z
519 
520     def _eval_rewrite_as_zeta(self, s):
521         return (1 - 2**(1 - s)) * zeta(s)
522 
523 
524 class stieltjes(Function):
525     r"""Represents Stieltjes constants, :math:`\gamma_{k}` that occur in
526     Laurent Series expansion of the Riemann zeta function.
527 
528     Examples
529     ========
530 
531     >>> from sympy import stieltjes
532     >>> from sympy.abc import n, m
533     >>> stieltjes(n)
534     stieltjes(n)
535 
536     zero'th stieltjes constant
537 
538     >>> stieltjes(0)
539     EulerGamma
540     >>> stieltjes(0, 1)
541     EulerGamma
542 
543     For generalized stieltjes constants
544 
545     >>> stieltjes(n, m)
546     stieltjes(n, m)
547 
548     Constants are only defined for integers >= 0
549 
550     >>> stieltjes(-1)
551     zoo
552 
553     References
554     ==========
555 
556     .. [1] http://en.wikipedia.org/wiki/Stieltjes_constants
557     """
558 
559     @classmethod
560     def eval(cls, n, a=None):
561         n = sympify(n)
562 
563         if a != None:
564             a = sympify(a)
565             if a is S.NaN:
566                 return S.NaN
567             if a.is_Integer and a.is_nonpositive:
568                 return S.ComplexInfinity
569 
570         if n.is_Number:
571             if n is S.NaN:
572                 return S.NaN
573             elif n < 0:
574                 return S.ComplexInfinity
575             elif not n.is_Integer:
576                 return S.ComplexInfinity
577             elif n == 0 and a in [None, 1]:
578                 return S.EulerGamma

</code><intended_behavior>The code responsible for `polylog` should correctly handle special case evaluations and expansions to produce results in line with known mathematical identities. For `polylog(2, Rational(1,2))`, ensuring it simplifies correctly to `-log(2)**2/2 + pi**2/12`. For `polylog(1, z)`, the implementation should reflect the mathematical equivalence to `-log(1-z)` accurately without unnecessary or incorrect use of `exp_polar(-I*pi)`.</intended_behavior>, <file>sympy/core/function.py</file>
<class>None</class>
<method>expand_func</method>
<code>
2383 def expand_func(expr, deep=True):
2384     """
2385     Wrapper around expand that only uses the func hint.  See the expand
2386     docstring for more information.
2387 
2388     Examples
2389     ========
2390 
2391     >>> from sympy import expand_func, gamma
2392     >>> from sympy.abc import x
2393     >>> expand_func(gamma(x + 2))
2394     x*(x + 1)*gamma(x)
2395 
2396     """
2397     return sympify(expr).expand(deep=deep, func=True, basic=False,
2398     log=False, mul=False, power_exp=False, power_base=False, multinomial=False)

</code><intended_behavior>While this method itself may not be faulty, it's probable that the expansion rules or hints it relies upon (especially those related to `polylog`) may need adjustment. Specifically, `expand_func` should ensure that expansions involving `polylog` adhere to mathematical expectations without introducing inconsistencies.</intended_behavior>]
2025-10-17 20:06:30.041 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 20:06:30.041 | INFO     | Search-only: skipping patch selection
2025-10-17 20:06:30.114 | INFO     | Task sympy__sympy-13852 completed successfully.
2025-10-17 20:06:30.115 | INFO     | No patch generated. You can try running ACR again.
