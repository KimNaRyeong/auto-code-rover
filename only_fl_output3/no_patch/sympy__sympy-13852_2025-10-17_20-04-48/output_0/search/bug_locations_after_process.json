[
    {
        "rel_file_path": "sympy/functions/special/zeta_functions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/functions/special/zeta_functions.py",
        "start": 1,
        "end": 578,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Riemann zeta and related function. \"\"\"\n2 from __future__ import print_function, division\n3 \n4 from sympy.core import Function, S, sympify, pi\n5 from sympy.core.function import ArgumentIndexError\n6 from sympy.core.compatibility import range\n7 from sympy.functions.combinatorial.numbers import bernoulli, factorial, harmonic\n8 from sympy.functions.elementary.exponential import log\n9 \n10 \n11 ###############################################################################\n12 ###################### LERCH TRANSCENDENT #####################################\n13 ###############################################################################\n14 \n15 \n16 class lerchphi(Function):\n17     r\"\"\"\n18     Lerch transcendent (Lerch phi function).\n19 \n20     For :math:`\\operatorname{Re}(a) > 0`, `|z| < 1` and `s \\in \\mathbb{C}`, the\n21     Lerch transcendent is defined as\n22 \n23     .. math :: \\Phi(z, s, a) = \\sum_{n=0}^\\infty \\frac{z^n}{(n + a)^s},\n24 \n25     where the standard branch of the argument is used for :math:`n + a`,\n26     and by analytic continuation for other values of the parameters.\n27 \n28     A commonly used related function is the Lerch zeta function, defined by\n29 \n30     .. math:: L(q, s, a) = \\Phi(e^{2\\pi i q}, s, a).\n31 \n32     **Analytic Continuation and Branching Behavior**\n33 \n34     It can be shown that\n35 \n36     .. math:: \\Phi(z, s, a) = z\\Phi(z, s, a+1) + a^{-s}.\n37 \n38     This provides the analytic continuation to `\\operatorname{Re}(a) \\le 0`.\n39 \n40     Assume now `\\operatorname{Re}(a) > 0`. The integral representation\n41 \n42     .. math:: \\Phi_0(z, s, a) = \\int_0^\\infty \\frac{t^{s-1} e^{-at}}{1 - ze^{-t}}\n43                                 \\frac{\\mathrm{d}t}{\\Gamma(s)}\n44 \n45     provides an analytic continuation to :math:`\\mathbb{C} - [1, \\infty)`.\n46     Finally, for :math:`x \\in (1, \\infty)` we find\n47 \n48     .. math:: \\lim_{\\epsilon \\to 0^+} \\Phi_0(x + i\\epsilon, s, a)\n49              -\\lim_{\\epsilon \\to 0^+} \\Phi_0(x - i\\epsilon, s, a)\n50              = \\frac{2\\pi i \\log^{s-1}{x}}{x^a \\Gamma(s)},\n51 \n52     using the standard branch for both :math:`\\log{x}` and\n53     :math:`\\log{\\log{x}}` (a branch of :math:`\\log{\\log{x}}` is needed to\n54     evaluate :math:`\\log{x}^{s-1}`).\n55     This concludes the analytic continuation. The Lerch transcendent is thus\n56     branched at :math:`z \\in \\{0, 1, \\infty\\}` and\n57     :math:`a \\in \\mathbb{Z}_{\\le 0}`. For fixed :math:`z, a` outside these\n58     branch points, it is an entire function of :math:`s`.\n59 \n60     See Also\n61     ========\n62 \n63     polylog, zeta\n64 \n65     References\n66     ==========\n67 \n68     .. [1] Bateman, H.; Erdelyi, A. (1953), Higher Transcendental Functions,\n69            Vol. I, New York: McGraw-Hill. Section 1.11.\n70     .. [2] http://dlmf.nist.gov/25.14\n71     .. [3] http://en.wikipedia.org/wiki/Lerch_transcendent\n72 \n73     Examples\n74     ========\n75 \n76     The Lerch transcendent is a fairly general function, for this reason it does\n77     not automatically evaluate to simpler functions. Use expand_func() to\n78     achieve this.\n79 \n80     If :math:`z=1`, the Lerch transcendent reduces to the Hurwitz zeta function:\n81 \n82     >>> from sympy import lerchphi, expand_func\n83     >>> from sympy.abc import z, s, a\n84     >>> expand_func(lerchphi(1, s, a))\n85     zeta(s, a)\n86 \n87     More generally, if :math:`z` is a root of unity, the Lerch transcendent\n88     reduces to a sum of Hurwitz zeta functions:\n89 \n90     >>> expand_func(lerchphi(-1, s, a))\n91     2**(-s)*zeta(s, a/2) - 2**(-s)*zeta(s, a/2 + 1/2)\n92 \n93     If :math:`a=1`, the Lerch transcendent reduces to the polylogarithm:\n94 \n95     >>> expand_func(lerchphi(z, s, 1))\n96     polylog(s, z)/z\n97 \n98     More generally, if :math:`a` is rational, the Lerch transcendent reduces\n99     to a sum of polylogarithms:\n100 \n101     >>> from sympy import S\n102     >>> expand_func(lerchphi(z, s, S(1)/2))\n103     2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -\n104                 polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))\n105     >>> expand_func(lerchphi(z, s, S(3)/2))\n106     -2**s/z + 2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -\n107                           polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))/z\n108 \n109     The derivatives with respect to :math:`z` and :math:`a` can be computed in\n110     closed form:\n111 \n112     >>> lerchphi(z, s, a).diff(z)\n113     (-a*lerchphi(z, s, a) + lerchphi(z, s - 1, a))/z\n114     >>> lerchphi(z, s, a).diff(a)\n115     -s*lerchphi(z, s + 1, a)\n116     \"\"\"\n117 \n118     def _eval_expand_func(self, **hints):\n119         from sympy import exp, I, floor, Add, Poly, Dummy, exp_polar, unpolarify\n120         z, s, a = self.args\n121         if z == 1:\n122             return zeta(s, a)\n123         if s.is_Integer and s <= 0:\n124             t = Dummy('t')\n125             p = Poly((t + a)**(-s), t)\n126             start = 1/(1 - t)\n127             res = S(0)\n128             for c in reversed(p.all_coeffs()):\n129                 res += c*start\n130                 start = t*start.diff(t)\n131             return res.subs(t, z)\n132 \n133         if a.is_Rational:\n134             # See section 18 of\n135             #   Kelly B. Roach.  Hypergeometric Function Representations.\n136             #   In: Proceedings of the 1997 International Symposium on Symbolic and\n137             #   Algebraic Computation, pages 205-211, New York, 1997. ACM.\n138             # TODO should something be polarified here?\n139             add = S(0)\n140             mul = S(1)\n141             # First reduce a to the interaval (0, 1]\n142             if a > 1:\n143                 n = floor(a)\n144                 if n == a:\n145                     n -= 1\n146                 a -= n\n147                 mul = z**(-n)\n148                 add = Add(*[-z**(k - n)/(a + k)**s for k in range(n)])\n149             elif a <= 0:\n150                 n = floor(-a) + 1\n151                 a += n\n152                 mul = z**n\n153                 add = Add(*[z**(n - 1 - k)/(a - k - 1)**s for k in range(n)])\n154 \n155             m, n = S([a.p, a.q])\n156             zet = exp_polar(2*pi*I/n)\n157             root = z**(1/n)\n158             return add + mul*n**(s - 1)*Add(\n159                 *[polylog(s, zet**k*root)._eval_expand_func(**hints)\n160                   / (unpolarify(zet)**k*root)**m for k in range(n)])\n161 \n162         # TODO use minpoly instead of ad-hoc methods when issue 5888 is fixed\n163         if isinstance(z, exp) and (z.args[0]/(pi*I)).is_Rational or z in [-1, I, -I]:\n164             # TODO reference?\n165             if z == -1:\n166                 p, q = S([1, 2])\n167             elif z == I:\n168                 p, q = S([1, 4])\n169             elif z == -I:\n170                 p, q = S([-1, 4])\n171             else:\n172                 arg = z.args[0]/(2*pi*I)\n173                 p, q = S([arg.p, arg.q])\n174             return Add(*[exp(2*pi*I*k*p/q)/q**s*zeta(s, (k + a)/q)\n175                          for k in range(q)])\n176 \n177         return lerchphi(z, s, a)\n178 \n179     def fdiff(self, argindex=1):\n180         z, s, a = self.args\n181         if argindex == 3:\n182             return -s*lerchphi(z, s + 1, a)\n183         elif argindex == 1:\n184             return (lerchphi(z, s - 1, a) - a*lerchphi(z, s, a))/z\n185         else:\n186             raise ArgumentIndexError\n187 \n188     def _eval_rewrite_helper(self, z, s, a, target):\n189         res = self._eval_expand_func()\n190         if res.has(target):\n191             return res\n192         else:\n193             return self\n194 \n195     def _eval_rewrite_as_zeta(self, z, s, a):\n196         return self._eval_rewrite_helper(z, s, a, zeta)\n197 \n198     def _eval_rewrite_as_polylog(self, z, s, a):\n199         return self._eval_rewrite_helper(z, s, a, polylog)\n200 \n201 ###############################################################################\n202 ###################### POLYLOGARITHM ##########################################\n203 ###############################################################################\n204 \n205 \n206 class polylog(Function):\n207     r\"\"\"\n208     Polylogarithm function.\n209 \n210     For :math:`|z| < 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n211     defined by\n212 \n213     .. math:: \\operatorname{Li}_s(z) = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n214 \n215     where the standard branch of the argument is used for :math:`n`. It admits\n216     an analytic continuation which is branched at :math:`z=1` (notably not on the\n217     sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n218 \n219     The name polylogarithm comes from the fact that for :math:`s=1`, the\n220     polylogarithm is related to the ordinary logarithm (see examples), and that\n221 \n222     .. math:: \\operatorname{Li}_{s+1}(z) =\n223                     \\int_0^z \\frac{\\operatorname{Li}_s(t)}{t} \\mathrm{d}t.\n224 \n225     The polylogarithm is a special case of the Lerch transcendent:\n226 \n227     .. math:: \\operatorname{Li}_{s}(z) = z \\Phi(z, s, 1)\n228 \n229     See Also\n230     ========\n231 \n232     zeta, lerchphi\n233 \n234     Examples\n235     ========\n236 \n237     For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n238     using other functions:\n239 \n240     >>> from sympy import polylog\n241     >>> from sympy.abc import s\n242     >>> polylog(s, 0)\n243     0\n244     >>> polylog(s, 1)\n245     zeta(s)\n246     >>> polylog(s, -1)\n247     -dirichlet_eta(s)\n248 \n249     If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n250     polylogarithm can be expressed using elementary functions. This can be\n251     done using expand_func():\n252 \n253     >>> from sympy import expand_func\n254     >>> from sympy.abc import z\n255     >>> expand_func(polylog(1, z))\n256     -log(z*exp_polar(-I*pi) + 1)\n257     >>> expand_func(polylog(0, z))\n258     z/(-z + 1)\n259 \n260     The derivative with respect to :math:`z` can be computed in closed form:\n261 \n262     >>> polylog(s, z).diff(z)\n263     polylog(s - 1, z)/z\n264 \n265     The polylogarithm can be expressed in terms of the lerch transcendent:\n266 \n267     >>> from sympy import lerchphi\n268     >>> polylog(s, z).rewrite(lerchphi)\n269     z*lerchphi(z, s, 1)\n270     \"\"\"\n271 \n272     @classmethod\n273     def eval(cls, s, z):\n274         if z == 1:\n275             return zeta(s)\n276         elif z == -1:\n277             return -dirichlet_eta(s)\n278         elif z == 0:\n279             return 0\n280 \n281     def fdiff(self, argindex=1):\n282         s, z = self.args\n283         if argindex == 2:\n284             return polylog(s - 1, z)/z\n285         raise ArgumentIndexError\n286 \n287     def _eval_rewrite_as_lerchphi(self, s, z):\n288         return z*lerchphi(z, s, 1)\n289 \n290     def _eval_expand_func(self, **hints):\n291         from sympy import log, expand_mul, Dummy, exp_polar, I\n292         s, z = self.args\n293         if s == 1:\n294             return -log(1 + exp_polar(-I*pi)*z)\n295         if s.is_Integer and s <= 0:\n296             u = Dummy('u')\n297             start = u/(1 - u)\n298             for _ in range(-s):\n299                 start = u*start.diff(u)\n300             return expand_mul(start).subs(u, z)\n301         return polylog(s, z)\n302 \n303 ###############################################################################\n304 ###################### HURWITZ GENERALIZED ZETA FUNCTION ######################\n305 ###############################################################################\n306 \n307 \n308 class zeta(Function):\n309     r\"\"\"\n310     Hurwitz zeta function (or Riemann zeta function).\n311 \n312     For `\\operatorname{Re}(a) > 0` and `\\operatorname{Re}(s) > 1`, this function is defined as\n313 \n314     .. math:: \\zeta(s, a) = \\sum_{n=0}^\\infty \\frac{1}{(n + a)^s},\n315 \n316     where the standard choice of argument for :math:`n + a` is used. For fixed\n317     :math:`a` with `\\operatorname{Re}(a) > 0` the Hurwitz zeta function admits a\n318     meromorphic continuation to all of :math:`\\mathbb{C}`, it is an unbranched\n319     function with a simple pole at :math:`s = 1`.\n320 \n321     Analytic continuation to other :math:`a` is possible under some circumstances,\n322     but this is not typically done.\n323 \n324     The Hurwitz zeta function is a special case of the Lerch transcendent:\n325 \n326     .. math:: \\zeta(s, a) = \\Phi(1, s, a).\n327 \n328     This formula defines an analytic continuation for all possible values of\n329     :math:`s` and :math:`a` (also `\\operatorname{Re}(a) < 0`), see the documentation of\n330     :class:`lerchphi` for a description of the branching behavior.\n331 \n332     If no value is passed for :math:`a`, by this function assumes a default value\n333     of :math:`a = 1`, yielding the Riemann zeta function.\n334 \n335     See Also\n336     ========\n337 \n338     dirichlet_eta, lerchphi, polylog\n339 \n340     References\n341     ==========\n342 \n343     .. [1] http://dlmf.nist.gov/25.11\n344     .. [2] http://en.wikipedia.org/wiki/Hurwitz_zeta_function\n345 \n346     Examples\n347     ========\n348 \n349     For :math:`a = 1` the Hurwitz zeta function reduces to the famous Riemann\n350     zeta function:\n351 \n352     .. math:: \\zeta(s, 1) = \\zeta(s) = \\sum_{n=1}^\\infty \\frac{1}{n^s}.\n353 \n354     >>> from sympy import zeta\n355     >>> from sympy.abc import s\n356     >>> zeta(s, 1)\n357     zeta(s)\n358     >>> zeta(s)\n359     zeta(s)\n360 \n361     The Riemann zeta function can also be expressed using the Dirichlet eta\n362     function:\n363 \n364     >>> from sympy import dirichlet_eta\n365     >>> zeta(s).rewrite(dirichlet_eta)\n366     dirichlet_eta(s)/(-2**(-s + 1) + 1)\n367 \n368     The Riemann zeta function at positive even integer and negative odd integer\n369     values is related to the Bernoulli numbers:\n370 \n371     >>> zeta(2)\n372     pi**2/6\n373     >>> zeta(4)\n374     pi**4/90\n375     >>> zeta(-1)\n376     -1/12\n377 \n378     The specific formulae are:\n379 \n380     .. math:: \\zeta(2n) = (-1)^{n+1} \\frac{B_{2n} (2\\pi)^{2n}}{2(2n)!}\n381     .. math:: \\zeta(-n) = -\\frac{B_{n+1}}{n+1}\n382 \n383     At negative even integers the Riemann zeta function is zero:\n384 \n385     >>> zeta(-4)\n386     0\n387 \n388     No closed-form expressions are known at positive odd integers, but\n389     numerical evaluation is possible:\n390 \n391     >>> zeta(3).n()\n392     1.20205690315959\n393 \n394     The derivative of :math:`\\zeta(s, a)` with respect to :math:`a` is easily\n395     computed:\n396 \n397     >>> from sympy.abc import a\n398     >>> zeta(s, a).diff(a)\n399     -s*zeta(s + 1, a)\n400 \n401     However the derivative with respect to :math:`s` has no useful closed form\n402     expression:\n403 \n404     >>> zeta(s, a).diff(s)\n405     Derivative(zeta(s, a), s)\n406 \n407     The Hurwitz zeta function can be expressed in terms of the Lerch transcendent,\n408     :class:`sympy.functions.special.lerchphi`:\n409 \n410     >>> from sympy import lerchphi\n411     >>> zeta(s, a).rewrite(lerchphi)\n412     lerchphi(1, s, a)\n413 \n414     \"\"\"\n415 \n416     @classmethod\n417     def eval(cls, z, a_=None):\n418         if a_ is None:\n419             z, a = list(map(sympify, (z, 1)))\n420         else:\n421             z, a = list(map(sympify, (z, a_)))\n422 \n423         if a.is_Number:\n424             if a is S.NaN:\n425                 return S.NaN\n426             elif a is S.One and a_ is not None:\n427                 return cls(z)\n428             # TODO Should a == 0 return S.NaN as well?\n429 \n430         if z.is_Number:\n431             if z is S.NaN:\n432                 return S.NaN\n433             elif z is S.Infinity:\n434                 return S.One\n435             elif z is S.Zero:\n436                 return S.Half - a\n437             elif z is S.One:\n438                 return S.ComplexInfinity\n439             elif z.is_Integer:\n440                 if a.is_Integer:\n441                     if z.is_negative:\n442                         zeta = (-1)**z * bernoulli(-z + 1)/(-z + 1)\n443                     elif z.is_even:\n444                         B, F = bernoulli(z), factorial(z)\n445                         zeta = 2**(z - 1) * abs(B) * pi**z / F\n446                     else:\n447                         return\n448 \n449                     if a.is_negative:\n450                         return zeta + harmonic(abs(a), z)\n451                     else:\n452                         return zeta - harmonic(a - 1, z)\n453 \n454     def _eval_rewrite_as_dirichlet_eta(self, s, a=1):\n455         if a != 1:\n456             return self\n457         s = self.args[0]\n458         return dirichlet_eta(s)/(1 - 2**(1 - s))\n459 \n460     def _eval_rewrite_as_lerchphi(self, s, a=1):\n461         return lerchphi(1, s, a)\n462 \n463     def _eval_is_finite(self):\n464         arg_is_one = (self.args[0] - 1).is_zero\n465         if arg_is_one is not None:\n466             return not arg_is_one\n467 \n468     def fdiff(self, argindex=1):\n469         if len(self.args) == 2:\n470             s, a = self.args\n471         else:\n472             s, a = self.args + (1,)\n473         if argindex == 2:\n474             return -s*zeta(s + 1, a)\n475         else:\n476             raise ArgumentIndexError\n477 \n478 \n479 class dirichlet_eta(Function):\n480     r\"\"\"\n481     Dirichlet eta function.\n482 \n483     For `\\operatorname{Re}(s) > 0`, this function is defined as\n484 \n485     .. math:: \\eta(s) = \\sum_{n=1}^\\infty \\frac{(-1)^n}{n^s}.\n486 \n487     It admits a unique analytic continuation to all of :math:`\\mathbb{C}`.\n488     It is an entire, unbranched function.\n489 \n490     See Also\n491     ========\n492 \n493     zeta\n494 \n495     References\n496     ==========\n497 \n498     .. [1] http://en.wikipedia.org/wiki/Dirichlet_eta_function\n499 \n500     Examples\n501     ========\n502 \n503     The Dirichlet eta function is closely related to the Riemann zeta function:\n504 \n505     >>> from sympy import dirichlet_eta, zeta\n506     >>> from sympy.abc import s\n507     >>> dirichlet_eta(s).rewrite(zeta)\n508     (-2**(-s + 1) + 1)*zeta(s)\n509 \n510     \"\"\"\n511 \n512     @classmethod\n513     def eval(cls, s):\n514         if s == 1:\n515             return log(2)\n516         z = zeta(s)\n517         if not z.has(zeta):\n518             return (1 - 2**(1 - s))*z\n519 \n520     def _eval_rewrite_as_zeta(self, s):\n521         return (1 - 2**(1 - s)) * zeta(s)\n522 \n523 \n524 class stieltjes(Function):\n525     r\"\"\"Represents Stieltjes constants, :math:`\\gamma_{k}` that occur in\n526     Laurent Series expansion of the Riemann zeta function.\n527 \n528     Examples\n529     ========\n530 \n531     >>> from sympy import stieltjes\n532     >>> from sympy.abc import n, m\n533     >>> stieltjes(n)\n534     stieltjes(n)\n535 \n536     zero'th stieltjes constant\n537 \n538     >>> stieltjes(0)\n539     EulerGamma\n540     >>> stieltjes(0, 1)\n541     EulerGamma\n542 \n543     For generalized stieltjes constants\n544 \n545     >>> stieltjes(n, m)\n546     stieltjes(n, m)\n547 \n548     Constants are only defined for integers >= 0\n549 \n550     >>> stieltjes(-1)\n551     zoo\n552 \n553     References\n554     ==========\n555 \n556     .. [1] http://en.wikipedia.org/wiki/Stieltjes_constants\n557     \"\"\"\n558 \n559     @classmethod\n560     def eval(cls, n, a=None):\n561         n = sympify(n)\n562 \n563         if a != None:\n564             a = sympify(a)\n565             if a is S.NaN:\n566                 return S.NaN\n567             if a.is_Integer and a.is_nonpositive:\n568                 return S.ComplexInfinity\n569 \n570         if n.is_Number:\n571             if n is S.NaN:\n572                 return S.NaN\n573             elif n < 0:\n574                 return S.ComplexInfinity\n575             elif not n.is_Integer:\n576                 return S.ComplexInfinity\n577             elif n == 0 and a in [None, 1]:\n578                 return S.EulerGamma\n",
        "intended_behavior": "The code responsible for `polylog` should correctly handle special case evaluations and expansions to produce results in line with known mathematical identities. For `polylog(2, Rational(1,2))`, ensuring it simplifies correctly to `-log(2)**2/2 + pi**2/12`. For `polylog(1, z)`, the implementation should reflect the mathematical equivalence to `-log(1-z)` accurately without unnecessary or incorrect use of `exp_polar(-I*pi)`."
    },
    {
        "rel_file_path": "sympy/core/function.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/core/function.py",
        "start": 2383,
        "end": 2398,
        "class_name": null,
        "method_name": "expand_func",
        "code": "2383 def expand_func(expr, deep=True):\n2384     \"\"\"\n2385     Wrapper around expand that only uses the func hint.  See the expand\n2386     docstring for more information.\n2387 \n2388     Examples\n2389     ========\n2390 \n2391     >>> from sympy import expand_func, gamma\n2392     >>> from sympy.abc import x\n2393     >>> expand_func(gamma(x + 2))\n2394     x*(x + 1)*gamma(x)\n2395 \n2396     \"\"\"\n2397     return sympify(expr).expand(deep=deep, func=True, basic=False,\n2398     log=False, mul=False, power_exp=False, power_base=False, multinomial=False)\n",
        "intended_behavior": "While this method itself may not be faulty, it's probable that the expansion rules or hints it relies upon (especially those related to `polylog`) may need adjustment. Specifically, `expand_func` should ensure that expansions involving `polylog` adhere to mathematical expectations without introducing inconsistencies."
    }
]