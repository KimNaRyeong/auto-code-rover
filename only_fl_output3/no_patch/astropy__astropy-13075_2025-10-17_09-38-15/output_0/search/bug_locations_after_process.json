[
    {
        "rel_file_path": "astropy/cosmology/core.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/astropy__astropy/setup_astropy__astropy__5.0/astropy/cosmology/core.py",
        "start": 50,
        "end": 391,
        "class_name": "Cosmology",
        "method_name": null,
        "code": "50 class Cosmology(metaclass=abc.ABCMeta):\n51     \"\"\"Base-class for all Cosmologies.\n52 \n53     Parameters\n54     ----------\n55     *args\n56         Arguments into the cosmology; used by subclasses, not this base class.\n57     name : str or None (optional, keyword-only)\n58         The name of the cosmology.\n59     meta : dict or None (optional, keyword-only)\n60         Metadata for the cosmology, e.g., a reference.\n61     **kwargs\n62         Arguments into the cosmology; used by subclasses, not this base class.\n63 \n64     Notes\n65     -----\n66     Class instances are static -- you cannot (and should not) change the values\n67     of the parameters.  That is, all of the above attributes (except meta) are\n68     read only.\n69 \n70     For details on how to create performant custom subclasses, see the\n71     documentation on :ref:`astropy-cosmology-fast-integrals`.\n72     \"\"\"\n73 \n74     meta = MetaData()\n75 \n76     # Unified I/O object interchange methods\n77     from_format = UnifiedReadWriteMethod(CosmologyFromFormat)\n78     to_format = UnifiedReadWriteMethod(CosmologyToFormat)\n79 \n80     # Unified I/O read and write methods\n81     read = UnifiedReadWriteMethod(CosmologyRead)\n82     write = UnifiedReadWriteMethod(CosmologyWrite)\n83 \n84     # Parameters\n85     __parameters__: tuple[str, ...] = ()\n86     __all_parameters__: tuple[str, ...] = ()\n87 \n88     # ---------------------------------------------------------------\n89 \n90     def __init_subclass__(cls):\n91         super().__init_subclass__()\n92 \n93         # -------------------\n94         # Parameters\n95 \n96         # Get parameters that are still Parameters, either in this class or above.\n97         parameters = []\n98         derived_parameters = []\n99         for n in cls.__parameters__:\n100             p = getattr(cls, n)\n101             if isinstance(p, Parameter):\n102                 derived_parameters.append(n) if p.derived else parameters.append(n)\n103 \n104         # Add new parameter definitions\n105         for n, v in cls.__dict__.items():\n106             if n in parameters or n.startswith(\"_\") or not isinstance(v, Parameter):\n107                 continue\n108             derived_parameters.append(n) if v.derived else parameters.append(n)\n109 \n110         # reorder to match signature\n111         ordered = [parameters.pop(parameters.index(n))\n112                    for n in cls._init_signature.parameters.keys()\n113                    if n in parameters]\n114         parameters = ordered + parameters  # place \"unordered\" at the end\n115         cls.__parameters__ = tuple(parameters)\n116         cls.__all_parameters__ = cls.__parameters__ + tuple(derived_parameters)\n117 \n118         # -------------------\n119         # register as a Cosmology subclass\n120         _COSMOLOGY_CLASSES[cls.__qualname__] = cls\n121 \n122     @classproperty(lazy=True)\n123     def _init_signature(cls):\n124         \"\"\"Initialization signature (without 'self').\"\"\"\n125         # get signature, dropping \"self\" by taking arguments [1:]\n126         sig = inspect.signature(cls.__init__)\n127         sig = sig.replace(parameters=list(sig.parameters.values())[1:])\n128         return sig\n129 \n130     # ---------------------------------------------------------------\n131 \n132     def __init__(self, name=None, meta=None):\n133         self._name = str(name) if name is not None else name\n134         self.meta.update(meta or {})\n135 \n136     @property\n137     def name(self):\n138         \"\"\"The name of the Cosmology instance.\"\"\"\n139         return self._name\n140 \n141     @property\n142     @abc.abstractmethod\n143     def is_flat(self):\n144         \"\"\"\n145         Return bool; `True` if the cosmology is flat.\n146         This is abstract and must be defined in subclasses.\n147         \"\"\"\n148         raise NotImplementedError(\"is_flat is not implemented\")\n149 \n150     def clone(self, *, meta=None, **kwargs):\n151         \"\"\"Returns a copy of this object with updated parameters, as specified.\n152 \n153         This cannot be used to change the type of the cosmology, so ``clone()``\n154         cannot be used to change between flat and non-flat cosmologies.\n155 \n156         Parameters\n157         ----------\n158         meta : mapping or None (optional, keyword-only)\n159             Metadata that will update the current metadata.\n160         **kwargs\n161             Cosmology parameter (and name) modifications. If any parameter is\n162             changed and a new name is not given, the name will be set to \"[old\n163             name] (modified)\".\n164 \n165         Returns\n166         -------\n167         newcosmo : `~astropy.cosmology.Cosmology` subclass instance\n168             A new instance of this class with updated parameters as specified.\n169             If no arguments are given, then a reference to this object is\n170             returned instead of copy.\n171 \n172         Examples\n173         --------\n174         To make a copy of the ``Planck13`` cosmology with a different matter\n175         density (``Om0``), and a new name:\n176 \n177             >>> from astropy.cosmology import Planck13\n178             >>> Planck13.clone(name=\"Modified Planck 2013\", Om0=0.35)\n179             FlatLambdaCDM(name=\"Modified Planck 2013\", H0=67.77 km / (Mpc s),\n180                           Om0=0.35, ...\n181 \n182         If no name is specified, the new name will note the modification.\n183 \n184             >>> Planck13.clone(Om0=0.35).name\n185             'Planck13 (modified)'\n186         \"\"\"\n187         # Quick return check, taking advantage of the Cosmology immutability.\n188         if meta is None and not kwargs:\n189             return self\n190 \n191         # There are changed parameter or metadata values.\n192         # The name needs to be changed accordingly, if it wasn't already.\n193         _modname = self.name + \" (modified)\"\n194         kwargs.setdefault(\"name\", (_modname if self.name is not None else None))\n195 \n196         # mix new meta into existing, preferring the former.\n197         meta = meta if meta is not None else {}\n198         new_meta = {**self.meta, **meta}\n199         # Mix kwargs into initial arguments, preferring the former.\n200         new_init = {**self._init_arguments, \"meta\": new_meta, **kwargs}\n201         # Create BoundArgument to handle args versus kwargs.\n202         # This also handles all errors from mismatched arguments\n203         ba = self._init_signature.bind_partial(**new_init)\n204         # Instantiate, respecting args vs kwargs\n205         cloned = type(self)(*ba.args, **ba.kwargs)\n206 \n207         # Check if nothing has changed.\n208         # TODO! or should return self?\n209         if (cloned.name == _modname) and not meta and cloned.is_equivalent(self):\n210             cloned._name = self.name\n211 \n212         return cloned\n213 \n214     @property\n215     def _init_arguments(self):\n216         # parameters\n217         kw = {n: getattr(self, n) for n in self.__parameters__}\n218 \n219         # other info\n220         kw[\"name\"] = self.name\n221         kw[\"meta\"] = self.meta\n222 \n223         return kw\n224 \n225     # ---------------------------------------------------------------\n226     # comparison methods\n227 \n228     def is_equivalent(self, other: Any, /, *, format: _FormatType = False) -> bool:\n229         r\"\"\"Check equivalence between Cosmologies.\n230 \n231         Two cosmologies may be equivalent even if not the same class.\n232         For example, an instance of ``LambdaCDM`` might have :math:`\\Omega_0=1`\n233         and :math:`\\Omega_k=0` and therefore be flat, like ``FlatLambdaCDM``.\n234 \n235         Parameters\n236         ----------\n237         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only\n238             The object to which to compare.\n239         format : bool or None or str, optional keyword-only\n240             Whether to allow, before equivalence is checked, the object to be\n241             converted to a |Cosmology|. This allows, e.g. a |Table| to be\n242             equivalent to a Cosmology.\n243             `False` (default) will not allow conversion. `True` or `None` will,\n244             and will use the auto-identification to try to infer the correct\n245             format. A `str` is assumed to be the correct format to use when\n246             converting.\n247             ``format`` is broadcast to match the shape of ``other``.\n248             Note that the cosmology arguments are not broadcast against\n249             ``format``, so it cannot determine the output shape.\n250 \n251         Returns\n252         -------\n253         bool\n254             True if cosmologies are equivalent, False otherwise.\n255 \n256         Examples\n257         --------\n258         Two cosmologies may be equivalent even if not of the same class.\n259         In this examples the ``LambdaCDM`` has ``Ode0`` set to the same value\n260         calculated in ``FlatLambdaCDM``.\n261 \n262             >>> import astropy.units as u\n263             >>> from astropy.cosmology import LambdaCDM, FlatLambdaCDM\n264             >>> cosmo1 = LambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, 0.7)\n265             >>> cosmo2 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3)\n266             >>> cosmo1.is_equivalent(cosmo2)\n267             True\n268 \n269         While in this example, the cosmologies are not equivalent.\n270 \n271             >>> cosmo3 = FlatLambdaCDM(70 * (u.km/u.s/u.Mpc), 0.3, Tcmb0=3 * u.K)\n272             >>> cosmo3.is_equivalent(cosmo2)\n273             False\n274 \n275         Also, using the keyword argument, the notion of equivalence is extended\n276         to any Python object that can be converted to a |Cosmology|.\n277 \n278             >>> from astropy.cosmology import Planck18\n279             >>> tbl = Planck18.to_format(\"astropy.table\")\n280             >>> Planck18.is_equivalent(tbl, format=True)\n281             True\n282 \n283         The list of valid formats, e.g. the |Table| in this example, may be\n284         checked with ``Cosmology.from_format.list_formats()``.\n285 \n286         As can be seen in the list of formats, not all formats can be\n287         auto-identified by ``Cosmology.from_format.registry``. Objects of\n288         these kinds can still be checked for equivalence, but the correct\n289         format string must be used.\n290 \n291             >>> tbl = Planck18.to_format(\"yaml\")\n292             >>> Planck18.is_equivalent(tbl, format=\"yaml\")\n293             True\n294         \"\"\"\n295         from .funcs import cosmology_equal\n296 \n297         try:\n298             return cosmology_equal(self, other, format=(None, format), allow_equivalent=True)\n299         except Exception:\n300             # `is_equivalent` allows `other` to be any object and returns False\n301             # if `other` cannot be converted to a Cosmology, rather than\n302             # raising an Exception.\n303             return False\n304 \n305     def __equiv__(self, other: Any, /) -> bool:\n306         \"\"\"Cosmology equivalence. Use ``.is_equivalent()`` for actual check!\n307 \n308         Parameters\n309         ----------\n310         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only\n311             The object in which to compare.\n312 \n313         Returns\n314         -------\n315         bool or `NotImplemented`\n316             `NotImplemented` if ``other`` is from a different class.\n317             `True` if ``other`` is of the same class and has matching parameters\n318             and parameter values.\n319             `False` otherwise.\n320         \"\"\"\n321         if other.__class__ is not self.__class__:\n322             return NotImplemented  # allows other.__equiv__\n323 \n324         # Check all parameters in 'other' match those in 'self' and 'other' has\n325         # no extra parameters (latter part should never happen b/c same class)\n326         params_eq = (set(self.__all_parameters__) == set(other.__all_parameters__)\n327                      and all(np.all(getattr(self, k) == getattr(other, k))\n328                              for k in self.__all_parameters__))\n329         return params_eq\n330 \n331     def __eq__(self, other: Any, /) -> bool:\n332         \"\"\"Check equality between Cosmologies.\n333 \n334         Checks the Parameters and immutable fields (i.e. not \"meta\").\n335 \n336         Parameters\n337         ----------\n338         other : `~astropy.cosmology.Cosmology` subclass instance, positional-only\n339             The object in which to compare.\n340 \n341         Returns\n342         -------\n343         bool\n344             `True` if Parameters and names are the same, `False` otherwise.\n345         \"\"\"\n346         if other.__class__ is not self.__class__:\n347             return NotImplemented  # allows other.__eq__\n348 \n349         eq = (\n350             # non-Parameter checks: name\n351             self.name == other.name\n352             # check all parameters in 'other' match those in 'self' and 'other'\n353             # has no extra parameters (latter part should never happen b/c same\n354             # class) TODO! element-wise when there are array cosmologies\n355             and set(self.__all_parameters__) == set(other.__all_parameters__)\n356             and all(np.all(getattr(self, k) == getattr(other, k))\n357                     for k in self.__all_parameters__)\n358         )\n359 \n360         return eq\n361 \n362     # ---------------------------------------------------------------\n363 \n364     def __repr__(self):\n365         namelead = f\"{self.__class__.__qualname__}(\"\n366         if self.name is not None:\n367             namelead += f\"name=\\\"{self.name}\\\", \"\n368         # nicely formatted parameters\n369         fmtps = (f'{k}={getattr(self, k)}' for k in self.__parameters__)\n370 \n371         return namelead + \", \".join(fmtps) + \")\"\n372 \n373     def __astropy_table__(self, cls, copy, **kwargs):\n374         \"\"\"Return a `~astropy.table.Table` of type ``cls``.\n375 \n376         Parameters\n377         ----------\n378         cls : type\n379             Astropy ``Table`` class or subclass.\n380         copy : bool\n381             Ignored.\n382         **kwargs : dict, optional\n383             Additional keyword arguments. Passed to ``self.to_format()``.\n384             See ``Cosmology.to_format.help(\"astropy.table\")`` for allowed kwargs.\n385 \n386         Returns\n387         -------\n388         `astropy.table.Table` or subclass instance\n389             Instance of type ``cls``.\n390         \"\"\"\n391         return self.to_format(\"astropy.table\", cls=cls, **kwargs)\n",
        "intended_behavior": "To resolve the issue, we don't necessarily need to fix a bug but rather extend functionality. Thus, within the `Cosmology` class, the intended behavior involves adding a new method or modifying the existing `write` mechanism to support exporting Cosmology instances in an HTML format. This might not directly modify the `write` method itself but could involve enhancing the IO infrastructure (`CosmologyIO` might be a relevant context, if existing) to recognize and process a new `'html'` format. The steps would include:\n    - Registering the `'html'` format with the `write` mechanism, possibly by extending `UnifiedReadWriteMethod` or the relevant registry system that handles IO formats.\n    - Implementing a function that converts a cosmology instance to an HTML table, utilizing the `cosmology.io.table.to_table()` method (or creating a suitable alternative if not already available) to first convert the instance to a table format.\n    - Formatting the table data into HTML, ensuring mathematical expressions are correctly represented using MathJax. This might involve integrating or developing functionality to translate Cosmology parameters and their descriptions (including units) into MathJax-enabled HTML snippets.\n    - The method would then utilize `QTable.write(..., format='html')` or a similar mechanism tailored for producing the HTML output, considering the input from the user about integrating MathJax for better mathematical expression representation.\n    - Ensure that this new functionality aligns with existing APIs\u2019 design patterns and usability principles, including error handling, customizability (e.g., allowing users to specify additional HTML formatting options), and documentation.\n    - This addition must preserve the existing functionality and interfaces of the `Cosmology` class, ensuring that any new behavior is complementary and does not disrupt current users' workflows or expectations.\n    - Besides adding this method, it would be necessary to update the documentation to include this new format option, providing examples of its usage and output."
    }
]