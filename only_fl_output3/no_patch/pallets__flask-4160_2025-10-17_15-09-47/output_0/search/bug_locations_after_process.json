[
    {
        "rel_file_path": "src/flask/json/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pallets__flask/setup_pallets__flask__2.0/src/flask/json/__init__.py",
        "start": 42,
        "end": 56,
        "class_name": "JSONEncoder",
        "method_name": "default",
        "code": "42     def default(self, o: t.Any) -> t.Any:\n43         \"\"\"Convert ``o`` to a JSON serializable type. See\n44         :meth:`json.JSONEncoder.default`. Python does not support\n45         overriding how basic types like ``str`` or ``list`` are\n46         serialized, they are handled before this method.\n47         \"\"\"\n48         if isinstance(o, date):\n49             return http_date(o)\n50         if isinstance(o, uuid.UUID):\n51             return str(o)\n52         if dataclasses and dataclasses.is_dataclass(o):\n53             return dataclasses.asdict(o)\n54         if hasattr(o, \"__html__\"):\n55             return str(o.__html__())\n56         return super().default(o)\n",
        "intended_behavior": "Modify the `default` method of the `JSONEncoder` class to include a conditional check that identifies if the object `o` is an instance of `decimal.Decimal`. If it is, the method should return a string representation of the `Decimal` object (`str(o)`) or consider using `float(o)` with a warning or documentation note about potential precision issues. This change will ensure that `Decimal` objects can be serialized to JSON format, thereby addressing the decreased encoding capabilities observed after the removal of `simplejson`. This modification will restore the ability to handle `Decimal` types alongside existing support for `datetime` objects and others, ensuring comprehensive JSON serialization capabilities within Flask."
    },
    {
        "rel_file_path": "src/flask/json/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pallets__flask/setup_pallets__flask__2.0/src/flask/json/__init__.py",
        "start": 25,
        "end": 56,
        "class_name": "JSONEncoder",
        "method_name": null,
        "code": "25 class JSONEncoder(_json.JSONEncoder):\n26     \"\"\"The default JSON encoder. Handles extra types compared to the\n27     built-in :class:`json.JSONEncoder`.\n28 \n29     -   :class:`datetime.datetime` and :class:`datetime.date` are\n30         serialized to :rfc:`822` strings. This is the same as the HTTP\n31         date format.\n32     -   :class:`uuid.UUID` is serialized to a string.\n33     -   :class:`dataclasses.dataclass` is passed to\n34         :func:`dataclasses.asdict`.\n35     -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n36         method) will call the ``__html__`` method to get a string.\n37 \n38     Assign a subclass of this to :attr:`flask.Flask.json_encoder` or\n39     :attr:`flask.Blueprint.json_encoder` to override the default.\n40     \"\"\"\n41 \n42     def default(self, o: t.Any) -> t.Any:\n43         \"\"\"Convert ``o`` to a JSON serializable type. See\n44         :meth:`json.JSONEncoder.default`. Python does not support\n45         overriding how basic types like ``str`` or ``list`` are\n46         serialized, they are handled before this method.\n47         \"\"\"\n48         if isinstance(o, date):\n49             return http_date(o)\n50         if isinstance(o, uuid.UUID):\n51             return str(o)\n52         if dataclasses and dataclasses.is_dataclass(o):\n53             return dataclasses.asdict(o)\n54         if hasattr(o, \"__html__\"):\n55             return str(o.__html__())\n56         return super().default(o)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]