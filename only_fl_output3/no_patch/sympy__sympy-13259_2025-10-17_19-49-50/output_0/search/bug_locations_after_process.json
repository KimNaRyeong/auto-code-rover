[
    {
        "rel_file_path": "sympy/simplify/simplify.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/simplify/simplify.py",
        "start": 1,
        "end": 1420,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from collections import defaultdict\n4 \n5 from sympy.core import (Basic, S, Add, Mul, Pow,\n6     Symbol, sympify, expand_mul, expand_func,\n7     Function, Dummy, Expr, factor_terms,\n8     symbols, expand_power_exp)\n9 from sympy.core.compatibility import (iterable,\n10     ordered, range, as_int)\n11 from sympy.core.numbers import Float, I, pi, Rational, Integer\n12 from sympy.core.function import expand_log, count_ops, _mexpand, _coeff_isneg, nfloat\n13 from sympy.core.rules import Transform\n14 from sympy.core.evaluate import global_evaluate\n15 from sympy.functions import (\n16     gamma, exp, sqrt, log, exp_polar, piecewise_fold)\n17 from sympy.core.sympify import _sympify\n18 from sympy.functions.elementary.exponential import ExpBase\n19 from sympy.functions.elementary.hyperbolic import HyperbolicFunction\n20 from sympy.functions.elementary.integers import ceiling\n21 from sympy.functions.elementary.complexes import unpolarify\n22 from sympy.functions.elementary.trigonometric import TrigonometricFunction\n23 from sympy.functions.combinatorial.factorials import CombinatorialFunction\n24 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely\n25 \n26 from sympy.utilities.iterables import has_variety\n27 \n28 from sympy.simplify.radsimp import radsimp, fraction\n29 from sympy.simplify.trigsimp import trigsimp, exptrigsimp\n30 from sympy.simplify.powsimp import powsimp\n31 from sympy.simplify.cse_opts import sub_pre, sub_post\n32 from sympy.simplify.sqrtdenest import sqrtdenest\n33 from sympy.simplify.combsimp import combsimp\n34 \n35 from sympy.polys import (together, cancel, factor)\n36 \n37 \n38 import mpmath\n39 \n40 \n41 \n42 def separatevars(expr, symbols=[], dict=False, force=False):\n43     \"\"\"\n44     Separates variables in an expression, if possible.  By\n45     default, it separates with respect to all symbols in an\n46     expression and collects constant coefficients that are\n47     independent of symbols.\n48 \n49     If dict=True then the separated terms will be returned\n50     in a dictionary keyed to their corresponding symbols.\n51     By default, all symbols in the expression will appear as\n52     keys; if symbols are provided, then all those symbols will\n53     be used as keys, and any terms in the expression containing\n54     other symbols or non-symbols will be returned keyed to the\n55     string 'coeff'. (Passing None for symbols will return the\n56     expression in a dictionary keyed to 'coeff'.)\n57 \n58     If force=True, then bases of powers will be separated regardless\n59     of assumptions on the symbols involved.\n60 \n61     Notes\n62     =====\n63     The order of the factors is determined by Mul, so that the\n64     separated expressions may not necessarily be grouped together.\n65 \n66     Although factoring is necessary to separate variables in some\n67     expressions, it is not necessary in all cases, so one should not\n68     count on the returned factors being factored.\n69 \n70     Examples\n71     ========\n72 \n73     >>> from sympy.abc import x, y, z, alpha\n74     >>> from sympy import separatevars, sin\n75     >>> separatevars((x*y)**y)\n76     (x*y)**y\n77     >>> separatevars((x*y)**y, force=True)\n78     x**y*y**y\n79 \n80     >>> e = 2*x**2*z*sin(y)+2*z*x**2\n81     >>> separatevars(e)\n82     2*x**2*z*(sin(y) + 1)\n83     >>> separatevars(e, symbols=(x, y), dict=True)\n84     {'coeff': 2*z, x: x**2, y: sin(y) + 1}\n85     >>> separatevars(e, [x, y, alpha], dict=True)\n86     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}\n87 \n88     If the expression is not really separable, or is only partially\n89     separable, separatevars will do the best it can to separate it\n90     by using factoring.\n91 \n92     >>> separatevars(x + x*y - 3*x**2)\n93     -x*(3*x - y - 1)\n94 \n95     If the expression is not separable then expr is returned unchanged\n96     or (if dict=True) then None is returned.\n97 \n98     >>> eq = 2*x + y*sin(x)\n99     >>> separatevars(eq) == eq\n100     True\n101     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None\n102     True\n103 \n104     \"\"\"\n105     expr = sympify(expr)\n106     if dict:\n107         return _separatevars_dict(_separatevars(expr, force), symbols)\n108     else:\n109         return _separatevars(expr, force)\n110 \n111 \n112 def _separatevars(expr, force):\n113     if len(expr.free_symbols) == 1:\n114         return expr\n115     # don't destroy a Mul since much of the work may already be done\n116     if expr.is_Mul:\n117         args = list(expr.args)\n118         changed = False\n119         for i, a in enumerate(args):\n120             args[i] = separatevars(a, force)\n121             changed = changed or args[i] != a\n122         if changed:\n123             expr = expr.func(*args)\n124         return expr\n125 \n126     # get a Pow ready for expansion\n127     if expr.is_Pow:\n128         expr = Pow(separatevars(expr.base, force=force), expr.exp)\n129 \n130     # First try other expansion methods\n131     expr = expr.expand(mul=False, multinomial=False, force=force)\n132 \n133     _expr, reps = posify(expr) if force else (expr, {})\n134     expr = factor(_expr).subs(reps)\n135 \n136     if not expr.is_Add:\n137         return expr\n138 \n139     # Find any common coefficients to pull out\n140     args = list(expr.args)\n141     commonc = args[0].args_cnc(cset=True, warn=False)[0]\n142     for i in args[1:]:\n143         commonc &= i.args_cnc(cset=True, warn=False)[0]\n144     commonc = Mul(*commonc)\n145     commonc = commonc.as_coeff_Mul()[1]  # ignore constants\n146     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]\n147 \n148     # remove them\n149     for i, a in enumerate(args):\n150         c, nc = a.args_cnc(cset=True, warn=False)\n151         c = c - commonc_set\n152         args[i] = Mul(*c)*Mul(*nc)\n153     nonsepar = Add(*args)\n154 \n155     if len(nonsepar.free_symbols) > 1:\n156         _expr = nonsepar\n157         _expr, reps = posify(_expr) if force else (_expr, {})\n158         _expr = (factor(_expr)).subs(reps)\n159 \n160         if not _expr.is_Add:\n161             nonsepar = _expr\n162 \n163     return commonc*nonsepar\n164 \n165 \n166 def _separatevars_dict(expr, symbols):\n167     if symbols:\n168         if not all((t.is_Atom for t in symbols)):\n169             raise ValueError(\"symbols must be Atoms.\")\n170         symbols = list(symbols)\n171     elif symbols is None:\n172         return {'coeff': expr}\n173     else:\n174         symbols = list(expr.free_symbols)\n175         if not symbols:\n176             return None\n177 \n178     ret = dict(((i, []) for i in symbols + ['coeff']))\n179 \n180     for i in Mul.make_args(expr):\n181         expsym = i.free_symbols\n182         intersection = set(symbols).intersection(expsym)\n183         if len(intersection) > 1:\n184             return None\n185         if len(intersection) == 0:\n186             # There are no symbols, so it is part of the coefficient\n187             ret['coeff'].append(i)\n188         else:\n189             ret[intersection.pop()].append(i)\n190 \n191     # rebuild\n192     for k, v in ret.items():\n193         ret[k] = Mul(*v)\n194 \n195     return ret\n196 \n197 \n198 def _is_sum_surds(p):\n199     args = p.args if p.is_Add else [p]\n200     for y in args:\n201         if not ((y**2).is_Rational and y.is_real):\n202             return False\n203     return True\n204 \n205 \n206 def posify(eq):\n207     \"\"\"Return eq (with generic symbols made positive) and a\n208     dictionary containing the mapping between the old and new\n209     symbols.\n210 \n211     Any symbol that has positive=None will be replaced with a positive dummy\n212     symbol having the same name. This replacement will allow more symbolic\n213     processing of expressions, especially those involving powers and\n214     logarithms.\n215 \n216     A dictionary that can be sent to subs to restore eq to its original\n217     symbols is also returned.\n218 \n219     >>> from sympy import posify, Symbol, log, solve\n220     >>> from sympy.abc import x\n221     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))\n222     (_x + n + p, {_x: x})\n223 \n224     >>> eq = 1/x\n225     >>> log(eq).expand()\n226     log(1/x)\n227     >>> log(posify(eq)[0]).expand()\n228     -log(_x)\n229     >>> p, rep = posify(eq)\n230     >>> log(p).expand().subs(rep)\n231     -log(x)\n232 \n233     It is possible to apply the same transformations to an iterable\n234     of expressions:\n235 \n236     >>> eq = x**2 - 4\n237     >>> solve(eq, x)\n238     [-2, 2]\n239     >>> eq_x, reps = posify([eq, x]); eq_x\n240     [_x**2 - 4, _x]\n241     >>> solve(*eq_x)\n242     [2]\n243     \"\"\"\n244     eq = sympify(eq)\n245     if iterable(eq):\n246         f = type(eq)\n247         eq = list(eq)\n248         syms = set()\n249         for e in eq:\n250             syms = syms.union(e.atoms(Symbol))\n251         reps = {}\n252         for s in syms:\n253             reps.update(dict((v, k) for k, v in posify(s)[1].items()))\n254         for i, e in enumerate(eq):\n255             eq[i] = e.subs(reps)\n256         return f(eq), {r: s for s, r in reps.items()}\n257 \n258     reps = dict([(s, Dummy(s.name, positive=True))\n259                  for s in eq.free_symbols if s.is_positive is None])\n260     eq = eq.subs(reps)\n261     return eq, {r: s for s, r in reps.items()}\n262 \n263 \n264 def hypersimp(f, k):\n265     \"\"\"Given combinatorial term f(k) simplify its consecutive term ratio\n266        i.e. f(k+1)/f(k).  The input term can be composed of functions and\n267        integer sequences which have equivalent representation in terms\n268        of gamma special function.\n269 \n270        The algorithm performs three basic steps:\n271 \n272        1. Rewrite all functions in terms of gamma, if possible.\n273 \n274        2. Rewrite all occurrences of gamma in terms of products\n275           of gamma and rising factorial with integer,  absolute\n276           constant exponent.\n277 \n278        3. Perform simplification of nested fractions, powers\n279           and if the resulting expression is a quotient of\n280           polynomials, reduce their total degree.\n281 \n282        If f(k) is hypergeometric then as result we arrive with a\n283        quotient of polynomials of minimal degree. Otherwise None\n284        is returned.\n285 \n286        For more information on the implemented algorithm refer to:\n287 \n288        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,\n289           Journal of Symbolic Computation (1995) 20, 399-417\n290     \"\"\"\n291     f = sympify(f)\n292 \n293     g = f.subs(k, k + 1) / f\n294 \n295     g = g.rewrite(gamma)\n296     g = expand_func(g)\n297     g = powsimp(g, deep=True, combine='exp')\n298 \n299     if g.is_rational_function(k):\n300         return simplify(g, ratio=S.Infinity)\n301     else:\n302         return None\n303 \n304 \n305 def hypersimilar(f, g, k):\n306     \"\"\"Returns True if 'f' and 'g' are hyper-similar.\n307 \n308        Similarity in hypergeometric sense means that a quotient of\n309        f(k) and g(k) is a rational function in k.  This procedure\n310        is useful in solving recurrence relations.\n311 \n312        For more information see hypersimp().\n313 \n314     \"\"\"\n315     f, g = list(map(sympify, (f, g)))\n316 \n317     h = (f/g).rewrite(gamma)\n318     h = h.expand(func=True, basic=False)\n319 \n320     return h.is_rational_function(k)\n321 \n322 \n323 def signsimp(expr, evaluate=None):\n324     \"\"\"Make all Add sub-expressions canonical wrt sign.\n325 \n326     If an Add subexpression, ``a``, can have a sign extracted,\n327     as determined by could_extract_minus_sign, it is replaced\n328     with Mul(-1, a, evaluate=False). This allows signs to be\n329     extracted from powers and products.\n330 \n331     Examples\n332     ========\n333 \n334     >>> from sympy import signsimp, exp, symbols\n335     >>> from sympy.abc import x, y\n336     >>> i = symbols('i', odd=True)\n337     >>> n = -1 + 1/x\n338     >>> n/x/(-n)**2 - 1/n/x\n339     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))\n340     >>> signsimp(_)\n341     0\n342     >>> x*n + x*-n\n343     x*(-1 + 1/x) + x*(1 - 1/x)\n344     >>> signsimp(_)\n345     0\n346 \n347     Since powers automatically handle leading signs\n348 \n349     >>> (-2)**i\n350     -2**i\n351 \n352     signsimp can be used to put the base of a power with an integer\n353     exponent into canonical form:\n354 \n355     >>> n**i\n356     (-1 + 1/x)**i\n357 \n358     By default, signsimp doesn't leave behind any hollow simplification:\n359     if making an Add canonical wrt sign didn't change the expression, the\n360     original Add is restored. If this is not desired then the keyword\n361     ``evaluate`` can be set to False:\n362 \n363     >>> e = exp(y - x)\n364     >>> signsimp(e) == e\n365     True\n366     >>> signsimp(e, evaluate=False)\n367     exp(-(x - y))\n368 \n369     \"\"\"\n370     if evaluate is None:\n371         evaluate = global_evaluate[0]\n372     expr = sympify(expr)\n373     if not isinstance(expr, Expr) or expr.is_Atom:\n374         return expr\n375     e = sub_post(sub_pre(expr))\n376     if not isinstance(e, Expr) or e.is_Atom:\n377         return e\n378     if e.is_Add:\n379         return e.func(*[signsimp(a, evaluate) for a in e.args])\n380     if evaluate:\n381         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n382     return e\n383 \n384 \n385 def simplify(expr, ratio=1.7, measure=count_ops, rational=False):\n386     # type: (object, object, object, object) -> object\n387     \"\"\"\n388     Simplifies the given expression.\n389 \n390     Simplification is not a well defined term and the exact strategies\n391     this function tries can change in the future versions of SymPy. If\n392     your algorithm relies on \"simplification\" (whatever it is), try to\n393     determine what you need exactly  -  is it powsimp()?, radsimp()?,\n394     together()?, logcombine()?, or something else? And use this particular\n395     function directly, because those are well defined and thus your algorithm\n396     will be robust.\n397 \n398     Nonetheless, especially for interactive use, or when you don't know\n399     anything about the structure of the expression, simplify() tries to apply\n400     intelligent heuristics to make the input expression \"simpler\".  For\n401     example:\n402 \n403     >>> from sympy import simplify, cos, sin\n404     >>> from sympy.abc import x, y\n405     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n406     >>> a\n407     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n408     >>> simplify(a)\n409     x + 1\n410 \n411     Note that we could have obtained the same result by using specific\n412     simplification functions:\n413 \n414     >>> from sympy import trigsimp, cancel\n415     >>> trigsimp(a)\n416     (x**2 + x)/x\n417     >>> cancel(_)\n418     x + 1\n419 \n420     In some cases, applying :func:`simplify` may actually result in some more\n421     complicated expression. The default ``ratio=1.7`` prevents more extreme\n422     cases: if (result length)/(input length) > ratio, then input is returned\n423     unmodified.  The ``measure`` parameter lets you specify the function used\n424     to determine how complex an expression is.  The function should take a\n425     single argument as an expression and return a number such that if\n426     expression ``a`` is more complex than expression ``b``, then\n427     ``measure(a) > measure(b)``.  The default measure function is\n428     :func:`count_ops`, which returns the total number of operations in the\n429     expression.\n430 \n431     For example, if ``ratio=1``, ``simplify`` output can't be longer\n432     than input.\n433 \n434     ::\n435 \n436         >>> from sympy import sqrt, simplify, count_ops, oo\n437         >>> root = 1/(sqrt(2)+3)\n438 \n439     Since ``simplify(root)`` would result in a slightly longer expression,\n440     root is returned unchanged instead::\n441 \n442        >>> simplify(root, ratio=1) == root\n443        True\n444 \n445     If ``ratio=oo``, simplify will be applied anyway::\n446 \n447         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n448         True\n449 \n450     Note that the shortest expression is not necessary the simplest, so\n451     setting ``ratio`` to 1 may not be a good idea.\n452     Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n453     choice.\n454 \n455     You can easily define your own measure function based on what you feel\n456     should represent the \"size\" or \"complexity\" of the input expression.  Note\n457     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n458     good metrics, but have other problems (in this case, the measure function\n459     may slow down simplify too much for very large expressions).  If you don't\n460     know what a good metric would be, the default, ``count_ops``, is a good\n461     one.\n462 \n463     For example:\n464 \n465     >>> from sympy import symbols, log\n466     >>> a, b = symbols('a b', positive=True)\n467     >>> g = log(a) + log(b) + log(a)*log(1/b)\n468     >>> h = simplify(g)\n469     >>> h\n470     log(a*b**(-log(a) + 1))\n471     >>> count_ops(g)\n472     8\n473     >>> count_ops(h)\n474     5\n475 \n476     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n477     However, we may not like how ``simplify`` (in this case, using\n478     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n479     to reduce this would be to give more weight to powers as operations in\n480     ``count_ops``.  We can do this by using the ``visual=True`` option:\n481 \n482     >>> print(count_ops(g, visual=True))\n483     2*ADD + DIV + 4*LOG + MUL\n484     >>> print(count_ops(h, visual=True))\n485     2*LOG + MUL + POW + SUB\n486 \n487     >>> from sympy import Symbol, S\n488     >>> def my_measure(expr):\n489     ...     POW = Symbol('POW')\n490     ...     # Discourage powers by giving POW a weight of 10\n491     ...     count = count_ops(expr, visual=True).subs(POW, 10)\n492     ...     # Every other operation gets a weight of 1 (the default)\n493     ...     count = count.replace(Symbol, type(S.One))\n494     ...     return count\n495     >>> my_measure(g)\n496     8\n497     >>> my_measure(h)\n498     14\n499     >>> 15./8 > 1.7 # 1.7 is the default ratio\n500     True\n501     >>> simplify(g, measure=my_measure)\n502     -log(a)*log(b) + log(a) + log(b)\n503 \n504     Note that because ``simplify()`` internally tries many different\n505     simplification strategies and then compares them using the measure\n506     function, we get a completely different result that is still different\n507     from the input expression by doing this.\n508 \n509     If rational=True, Floats will be recast as Rationals before simplification.\n510     If rational=None, Floats will be recast as Rationals but the result will\n511     be recast as Floats. If rational=False(default) then nothing will be done\n512     to the Floats.\n513     \"\"\"\n514     expr = sympify(expr)\n515 \n516     try:\n517         return expr._eval_simplify(ratio=ratio, measure=measure)\n518     except AttributeError:\n519         pass\n520 \n521     original_expr = expr = signsimp(expr)\n522 \n523     from sympy.simplify.hyperexpand import hyperexpand\n524     from sympy.functions.special.bessel import BesselBase\n525     from sympy import Sum, Product\n526 \n527     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n528         return expr\n529 \n530     if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n531         if isinstance(expr, Function) and hasattr(expr, \"inverse\"):\n532             if len(expr.args) == 1 and len(expr.args[0].args) == 1 and \\\n533                isinstance(expr.args[0], expr.inverse(argindex=1)):\n534                 return simplify(expr.args[0].args[0], ratio=ratio,\n535                                 measure=measure, rational=rational)\n536         return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational)\n537                          for x in expr.args])\n538 \n539     # TODO: Apply different strategies, considering expression pattern:\n540     # is it a purely rational function? Is there any trigonometric function?...\n541     # See also https://github.com/sympy/sympy/pull/185.\n542 \n543     def shorter(*choices):\n544         '''Return the choice that has the fewest ops. In case of a tie,\n545         the expression listed first is selected.'''\n546         if not has_variety(choices):\n547             return choices[0]\n548         return min(choices, key=measure)\n549 \n550     # rationalize Floats\n551     floats = False\n552     if rational is not False and expr.has(Float):\n553         floats = True\n554         expr = nsimplify(expr, rational=True)\n555 \n556     expr = bottom_up(expr, lambda w: w.normal())\n557     expr = Mul(*powsimp(expr).as_content_primitive())\n558     _e = cancel(expr)\n559     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n560     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n561 \n562     if ratio is S.Infinity:\n563         expr = expr2\n564     else:\n565         expr = shorter(expr2, expr1, expr)\n566     if not isinstance(expr, Basic):  # XXX: temporary hack\n567         return expr\n568 \n569     expr = factor_terms(expr, sign=False)\n570 \n571     # hyperexpand automatically only works on hypergeometric terms\n572     expr = hyperexpand(expr)\n573 \n574     expr = piecewise_fold(expr)\n575 \n576     if expr.has(BesselBase):\n577         expr = besselsimp(expr)\n578 \n579     if expr.has(TrigonometricFunction, HyperbolicFunction):\n580         expr = trigsimp(expr, deep=True)\n581 \n582     if expr.has(log):\n583         expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n584 \n585     if expr.has(CombinatorialFunction, gamma):\n586         # expression with gamma functions or non-integer arguments is\n587         # automatically passed to gammasimp\n588         expr = combsimp(expr)\n589 \n590     if expr.has(Sum):\n591         expr = sum_simplify(expr)\n592 \n593     if expr.has(Product):\n594         expr = product_simplify(expr)\n595 \n596     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n597     short = shorter(short, cancel(short))\n598     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n599     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n600         short = exptrigsimp(short)\n601 \n602     # get rid of hollow 2-arg Mul factorization\n603     hollow_mul = Transform(\n604         lambda x: Mul(*x.args),\n605         lambda x:\n606         x.is_Mul and\n607         len(x.args) == 2 and\n608         x.args[0].is_Number and\n609         x.args[1].is_Add and\n610         x.is_commutative)\n611     expr = short.xreplace(hollow_mul)\n612 \n613     numer, denom = expr.as_numer_denom()\n614     if denom.is_Add:\n615         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n616         if n is not S.One:\n617             expr = (numer*n).expand()/d\n618 \n619     if expr.could_extract_minus_sign():\n620         n, d = fraction(expr)\n621         if d != 0:\n622             expr = signsimp(-n/(-d))\n623 \n624     if measure(expr) > ratio*measure(original_expr):\n625         expr = original_expr\n626 \n627     # restore floats\n628     if floats and rational is None:\n629         expr = nfloat(expr, exponent=False)\n630 \n631     return expr\n632 \n633 \n634 def sum_simplify(s):\n635     \"\"\"Main function for Sum simplification\"\"\"\n636     from sympy.concrete.summations import Sum\n637     from sympy.core.function import expand\n638 \n639     terms = Add.make_args(expand(s))\n640     s_t = [] # Sum Terms\n641     o_t = [] # Other Terms\n642 \n643     for term in terms:\n644         if isinstance(term, Mul):\n645             other = 1\n646             sum_terms = []\n647 \n648             if not term.has(Sum):\n649                 o_t.append(term)\n650                 continue\n651 \n652             mul_terms = Mul.make_args(term)\n653             for mul_term in mul_terms:\n654                 if isinstance(mul_term, Sum):\n655                     r = mul_term._eval_simplify()\n656                     sum_terms.extend(Add.make_args(r))\n657                 else:\n658                     other = other * mul_term\n659             if len(sum_terms):\n660                 #some simplification may have happened\n661                 #use if so\n662                 s_t.append(Mul(*sum_terms) * other)\n663             else:\n664                 o_t.append(other)\n665         elif isinstance(term, Sum):\n666             #as above, we need to turn this into an add list\n667             r = term._eval_simplify()\n668             s_t.extend(Add.make_args(r))\n669         else:\n670             o_t.append(term)\n671 \n672 \n673     result = Add(sum_combine(s_t), *o_t)\n674 \n675     return result\n676 \n677 def sum_combine(s_t):\n678     \"\"\"Helper function for Sum simplification\n679 \n680        Attempts to simplify a list of sums, by combining limits / sum function's\n681        returns the simplified sum\n682     \"\"\"\n683     from sympy.concrete.summations import Sum\n684 \n685 \n686     used = [False] * len(s_t)\n687 \n688     for method in range(2):\n689         for i, s_term1 in enumerate(s_t):\n690             if not used[i]:\n691                 for j, s_term2 in enumerate(s_t):\n692                     if not used[j] and i != j:\n693                         temp = sum_add(s_term1, s_term2, method)\n694                         if isinstance(temp, Sum) or isinstance(temp, Mul):\n695                             s_t[i] = temp\n696                             s_term1 = s_t[i]\n697                             used[j] = True\n698 \n699     result = S.Zero\n700     for i, s_term in enumerate(s_t):\n701         if not used[i]:\n702             result = Add(result, s_term)\n703 \n704     return result\n705 \n706 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):\n707     \"\"\"Helper function for Sum simplification\n708 \n709        if limits is specified, \"self\" is the inner part of a sum\n710 \n711        Returns the sum with constant factors brought outside\n712     \"\"\"\n713     from sympy.core.exprtools import factor_terms\n714     from sympy.concrete.summations import Sum\n715 \n716     result = self.function if limits is None else self\n717     limits = self.limits if limits is None else limits\n718     #avoid any confusion w/ as_independent\n719     if result == 0:\n720         return S.Zero\n721 \n722     #get the summation variables\n723     sum_vars = set([limit.args[0] for limit in limits])\n724 \n725     #finally we try to factor out any common terms\n726     #and remove the from the sum if independent\n727     retv = factor_terms(result, radical=radical, clear=clear, fraction=fraction, sign=sign)\n728     #avoid doing anything bad\n729     if not result.is_commutative:\n730         return Sum(result, *limits)\n731 \n732     i, d = retv.as_independent(*sum_vars)\n733     if isinstance(retv, Add):\n734         return i * Sum(1, *limits) + Sum(d, *limits)\n735     else:\n736         return i * Sum(d, *limits)\n737 \n738 def sum_add(self, other, method=0):\n739     \"\"\"Helper function for Sum simplification\"\"\"\n740     from sympy.concrete.summations import Sum\n741     from sympy import Mul\n742 \n743     #we know this is something in terms of a constant * a sum\n744     #so we temporarily put the constants inside for simplification\n745     #then simplify the result\n746     def __refactor(val):\n747         args = Mul.make_args(val)\n748         sumv = next(x for x in args if isinstance(x, Sum))\n749         constant = Mul(*[x for x in args if x != sumv])\n750         return Sum(constant * sumv.function, *sumv.limits)\n751 \n752     if isinstance(self, Mul):\n753         rself = __refactor(self)\n754     else:\n755         rself = self\n756 \n757     if isinstance(other, Mul):\n758         rother = __refactor(other)\n759     else:\n760         rother = other\n761 \n762     if type(rself) == type(rother):\n763         if method == 0:\n764             if rself.limits == rother.limits:\n765                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))\n766         elif method == 1:\n767             if simplify(rself.function - rother.function) == 0:\n768                 if len(rself.limits) == len(rother.limits) == 1:\n769                     i = rself.limits[0][0]\n770                     x1 = rself.limits[0][1]\n771                     y1 = rself.limits[0][2]\n772                     j = rother.limits[0][0]\n773                     x2 = rother.limits[0][1]\n774                     y2 = rother.limits[0][2]\n775 \n776                     if i == j:\n777                         if x2 == y1 + 1:\n778                             return factor_sum(Sum(rself.function, (i, x1, y2)))\n779                         elif x1 == y2 + 1:\n780                             return factor_sum(Sum(rself.function, (i, x2, y1)))\n781 \n782     return Add(self, other)\n783 \n784 \n785 def product_simplify(s):\n786     \"\"\"Main function for Product simplification\"\"\"\n787     from sympy.concrete.products import Product\n788 \n789     terms = Mul.make_args(s)\n790     p_t = [] # Product Terms\n791     o_t = [] # Other Terms\n792 \n793     for term in terms:\n794         if isinstance(term, Product):\n795             p_t.append(term)\n796         else:\n797             o_t.append(term)\n798 \n799     used = [False] * len(p_t)\n800 \n801     for method in range(2):\n802         for i, p_term1 in enumerate(p_t):\n803             if not used[i]:\n804                 for j, p_term2 in enumerate(p_t):\n805                     if not used[j] and i != j:\n806                         if isinstance(product_mul(p_term1, p_term2, method), Product):\n807                             p_t[i] = product_mul(p_term1, p_term2, method)\n808                             used[j] = True\n809 \n810     result = Mul(*o_t)\n811 \n812     for i, p_term in enumerate(p_t):\n813         if not used[i]:\n814             result = Mul(result, p_term)\n815 \n816     return result\n817 \n818 \n819 def product_mul(self, other, method=0):\n820     \"\"\"Helper function for Product simplification\"\"\"\n821     from sympy.concrete.products import Product\n822 \n823     if type(self) == type(other):\n824         if method == 0:\n825             if self.limits == other.limits:\n826                 return Product(self.function * other.function, *self.limits)\n827         elif method == 1:\n828             if simplify(self.function - other.function) == 0:\n829                 if len(self.limits) == len(other.limits) == 1:\n830                     i = self.limits[0][0]\n831                     x1 = self.limits[0][1]\n832                     y1 = self.limits[0][2]\n833                     j = other.limits[0][0]\n834                     x2 = other.limits[0][1]\n835                     y2 = other.limits[0][2]\n836 \n837                     if i == j:\n838                         if x2 == y1 + 1:\n839                             return Product(self.function, (i, x1, y2))\n840                         elif x1 == y2 + 1:\n841                             return Product(self.function, (i, x2, y1))\n842 \n843     return Mul(self, other)\n844 \n845 \n846 def _nthroot_solve(p, n, prec):\n847     \"\"\"\n848      helper function for ``nthroot``\n849      It denests ``p**Rational(1, n)`` using its minimal polynomial\n850     \"\"\"\n851     from sympy.polys.numberfields import _minimal_polynomial_sq\n852     from sympy.solvers import solve\n853     while n % 2 == 0:\n854         p = sqrtdenest(sqrt(p))\n855         n = n // 2\n856     if n == 1:\n857         return p\n858     pn = p**Rational(1, n)\n859     x = Symbol('x')\n860     f = _minimal_polynomial_sq(p, n, x)\n861     if f is None:\n862         return None\n863     sols = solve(f, x)\n864     for sol in sols:\n865         if abs(sol - pn).n() < 1./10**prec:\n866             sol = sqrtdenest(sol)\n867             if _mexpand(sol**n) == p:\n868                 return sol\n869 \n870 \n871 def logcombine(expr, force=False):\n872     \"\"\"\n873     Takes logarithms and combines them using the following rules:\n874 \n875     - log(x) + log(y) == log(x*y) if both are not negative\n876     - a*log(x) == log(x**a) if x is positive and a is real\n877 \n878     If ``force`` is True then the assumptions above will be assumed to hold if\n879     there is no assumption already in place on a quantity. For example, if\n880     ``a`` is imaginary or the argument negative, force will not perform a\n881     combination but if ``a`` is a symbol with no assumptions the change will\n882     take place.\n883 \n884     Examples\n885     ========\n886 \n887     >>> from sympy import Symbol, symbols, log, logcombine, I\n888     >>> from sympy.abc import a, x, y, z\n889     >>> logcombine(a*log(x) + log(y) - log(z))\n890     a*log(x) + log(y) - log(z)\n891     >>> logcombine(a*log(x) + log(y) - log(z), force=True)\n892     log(x**a*y/z)\n893     >>> x,y,z = symbols('x,y,z', positive=True)\n894     >>> a = Symbol('a', real=True)\n895     >>> logcombine(a*log(x) + log(y) - log(z))\n896     log(x**a*y/z)\n897 \n898     The transformation is limited to factors and/or terms that\n899     contain logs, so the result depends on the initial state of\n900     expansion:\n901 \n902     >>> eq = (2 + 3*I)*log(x)\n903     >>> logcombine(eq, force=True) == eq\n904     True\n905     >>> logcombine(eq.expand(), force=True)\n906     log(x**2) + I*log(x**3)\n907 \n908     See Also\n909     ========\n910     posify: replace all symbols with symbols having positive assumptions\n911 \n912     \"\"\"\n913 \n914     def f(rv):\n915         if not (rv.is_Add or rv.is_Mul):\n916             return rv\n917 \n918         def gooda(a):\n919             # bool to tell whether the leading ``a`` in ``a*log(x)``\n920             # could appear as log(x**a)\n921             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow\n922                 (a.is_real or force and a.is_real is not False))\n923 \n924         def goodlog(l):\n925             # bool to tell whether log ``l``'s argument can combine with others\n926             a = l.args[0]\n927             return a.is_positive or force and a.is_nonpositive is not False\n928 \n929         other = []\n930         logs = []\n931         log1 = defaultdict(list)\n932         for a in Add.make_args(rv):\n933             if a.func is log and goodlog(a):\n934                 log1[()].append(([], a))\n935             elif not a.is_Mul:\n936                 other.append(a)\n937             else:\n938                 ot = []\n939                 co = []\n940                 lo = []\n941                 for ai in a.args:\n942                     if ai.is_Rational and ai < 0:\n943                         ot.append(S.NegativeOne)\n944                         co.append(-ai)\n945                     elif ai.func is log and goodlog(ai):\n946                         lo.append(ai)\n947                     elif gooda(ai):\n948                         co.append(ai)\n949                     else:\n950                         ot.append(ai)\n951                 if len(lo) > 1:\n952                     logs.append((ot, co, lo))\n953                 elif lo:\n954                     log1[tuple(ot)].append((co, lo[0]))\n955                 else:\n956                     other.append(a)\n957 \n958         # if there is only one log at each coefficient and none have\n959         # an exponent to place inside the log then there is nothing to do\n960         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):\n961             return rv\n962 \n963         # collapse multi-logs as far as possible in a canonical way\n964         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?\n965         # -- in this case, it's unambiguous, but if it were were a log(c) in\n966         # each term then it's arbitrary whether they are grouped by log(a) or\n967         # by log(c). So for now, just leave this alone; it's probably better to\n968         # let the user decide\n969         for o, e, l in logs:\n970             l = list(ordered(l))\n971             e = log(l.pop(0).args[0]**Mul(*e))\n972             while l:\n973                 li = l.pop(0)\n974                 e = log(li.args[0]**e)\n975             c, l = Mul(*o), e\n976             if l.func is log:  # it should be, but check to be sure\n977                 log1[(c,)].append(([], l))\n978             else:\n979                 other.append(c*l)\n980 \n981         # logs that have the same coefficient can multiply\n982         for k in list(log1.keys()):\n983             log1[Mul(*k)] = log(logcombine(Mul(*[\n984                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),\n985                 force=force))\n986 \n987         # logs that have oppositely signed coefficients can divide\n988         for k in ordered(list(log1.keys())):\n989             if not k in log1:  # already popped as -k\n990                 continue\n991             if -k in log1:\n992                 # figure out which has the minus sign; the one with\n993                 # more op counts should be the one\n994                 num, den = k, -k\n995                 if num.count_ops() > den.count_ops():\n996                     num, den = den, num\n997                 other.append(num*log(log1.pop(num).args[0]/log1.pop(den).args[0]))\n998             else:\n999                 other.append(k*log1.pop(k))\n1000 \n1001         return Add(*other)\n1002 \n1003     return bottom_up(expr, f)\n1004 \n1005 \n1006 def bottom_up(rv, F, atoms=False, nonbasic=False):\n1007     \"\"\"Apply ``F`` to all expressions in an expression tree from the\n1008     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\n1009     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.\n1010     \"\"\"\n1011     try:\n1012         if rv.args:\n1013             args = tuple([bottom_up(a, F, atoms, nonbasic)\n1014                 for a in rv.args])\n1015             if args != rv.args:\n1016                 rv = rv.func(*args)\n1017             rv = F(rv)\n1018         elif atoms:\n1019             rv = F(rv)\n1020     except AttributeError:\n1021         if nonbasic:\n1022             try:\n1023                 rv = F(rv)\n1024             except TypeError:\n1025                 pass\n1026 \n1027     return rv\n1028 \n1029 \n1030 def besselsimp(expr):\n1031     \"\"\"\n1032     Simplify bessel-type functions.\n1033 \n1034     This routine tries to simplify bessel-type functions. Currently it only\n1035     works on the Bessel J and I functions, however. It works by looking at all\n1036     such functions in turn, and eliminating factors of \"I\" and \"-1\" (actually\n1037     their polar equivalents) in front of the argument. Then, functions of\n1038     half-integer order are rewritten using strigonometric functions and\n1039     functions of integer order (> 1) are rewritten using functions\n1040     of low order.  Finally, if the expression was changed, compute\n1041     factorization of the result with factor().\n1042 \n1043     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S\n1044     >>> from sympy.abc import z, nu\n1045     >>> besselsimp(besselj(nu, z*polar_lift(-1)))\n1046     exp(I*pi*nu)*besselj(nu, z)\n1047     >>> besselsimp(besseli(nu, z*polar_lift(-I)))\n1048     exp(-I*pi*nu/2)*besselj(nu, z)\n1049     >>> besselsimp(besseli(S(-1)/2, z))\n1050     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))\n1051     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))\n1052     3*z*besseli(0, z)/2\n1053     \"\"\"\n1054     # TODO\n1055     # - better algorithm?\n1056     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...\n1057     # - use contiguity relations?\n1058 \n1059     def replacer(fro, to, factors):\n1060         factors = set(factors)\n1061 \n1062         def repl(nu, z):\n1063             if factors.intersection(Mul.make_args(z)):\n1064                 return to(nu, z)\n1065             return fro(nu, z)\n1066         return repl\n1067 \n1068     def torewrite(fro, to):\n1069         def tofunc(nu, z):\n1070             return fro(nu, z).rewrite(to)\n1071         return tofunc\n1072 \n1073     def tominus(fro):\n1074         def tofunc(nu, z):\n1075             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)\n1076         return tofunc\n1077 \n1078     orig_expr = expr\n1079 \n1080     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]\n1081     expr = expr.replace(\n1082         besselj, replacer(besselj,\n1083         torewrite(besselj, besseli), ifactors))\n1084     expr = expr.replace(\n1085         besseli, replacer(besseli,\n1086         torewrite(besseli, besselj), ifactors))\n1087 \n1088     minusfactors = [-1, exp_polar(I*pi)]\n1089     expr = expr.replace(\n1090         besselj, replacer(besselj, tominus(besselj), minusfactors))\n1091     expr = expr.replace(\n1092         besseli, replacer(besseli, tominus(besseli), minusfactors))\n1093 \n1094     z0 = Dummy('z')\n1095 \n1096     def expander(fro):\n1097         def repl(nu, z):\n1098             if (nu % 1) == S(1)/2:\n1099                 return simplify(trigsimp(unpolarify(\n1100                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(\n1101                             func=True)).subs(z0, z)))\n1102             elif nu.is_Integer and nu > 1:\n1103                 return fro(nu, z).expand(func=True)\n1104             return fro(nu, z)\n1105         return repl\n1106 \n1107     expr = expr.replace(besselj, expander(besselj))\n1108     expr = expr.replace(bessely, expander(bessely))\n1109     expr = expr.replace(besseli, expander(besseli))\n1110     expr = expr.replace(besselk, expander(besselk))\n1111 \n1112     if expr != orig_expr:\n1113         expr = expr.factor()\n1114 \n1115     return expr\n1116 \n1117 \n1118 def nthroot(expr, n, max_len=4, prec=15):\n1119     \"\"\"\n1120     compute a real nth-root of a sum of surds\n1121 \n1122     Parameters\n1123     ==========\n1124 \n1125     expr : sum of surds\n1126     n : integer\n1127     max_len : maximum number of surds passed as constants to ``nsimplify``\n1128 \n1129     Algorithm\n1130     =========\n1131 \n1132     First ``nsimplify`` is used to get a candidate root; if it is not a\n1133     root the minimal polynomial is computed; the answer is one of its\n1134     roots.\n1135 \n1136     Examples\n1137     ========\n1138 \n1139     >>> from sympy.simplify.simplify import nthroot\n1140     >>> from sympy import Rational, sqrt\n1141     >>> nthroot(90 + 34*sqrt(7), 3)\n1142     sqrt(7) + 3\n1143 \n1144     \"\"\"\n1145     expr = sympify(expr)\n1146     n = sympify(n)\n1147     p = expr**Rational(1, n)\n1148     if not n.is_integer:\n1149         return p\n1150     if not _is_sum_surds(expr):\n1151         return p\n1152     surds = []\n1153     coeff_muls = [x.as_coeff_Mul() for x in expr.args]\n1154     for x, y in coeff_muls:\n1155         if not x.is_rational:\n1156             return p\n1157         if y is S.One:\n1158             continue\n1159         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):\n1160             return p\n1161         surds.append(y)\n1162     surds.sort()\n1163     surds = surds[:max_len]\n1164     if expr < 0 and n % 2 == 1:\n1165         p = (-expr)**Rational(1, n)\n1166         a = nsimplify(p, constants=surds)\n1167         res = a if _mexpand(a**n) == _mexpand(-expr) else p\n1168         return -res\n1169     a = nsimplify(p, constants=surds)\n1170     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):\n1171         return _mexpand(a)\n1172     expr = _nthroot_solve(expr, n, prec)\n1173     if expr is None:\n1174         return p\n1175     return expr\n1176 \n1177 \n1178 def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,\n1179     rational_conversion='base10'):\n1180     \"\"\"\n1181     Find a simple representation for a number or, if there are free symbols or\n1182     if rational=True, then replace Floats with their Rational equivalents. If\n1183     no change is made and rational is not False then Floats will at least be\n1184     converted to Rationals.\n1185 \n1186     For numerical expressions, a simple formula that numerically matches the\n1187     given numerical expression is sought (and the input should be possible\n1188     to evalf to a precision of at least 30 digits).\n1189 \n1190     Optionally, a list of (rationally independent) constants to\n1191     include in the formula may be given.\n1192 \n1193     A lower tolerance may be set to find less exact matches. If no tolerance\n1194     is given then the least precise value will set the tolerance (e.g. Floats\n1195     default to 15 digits of precision, so would be tolerance=10**-15).\n1196 \n1197     With full=True, a more extensive search is performed\n1198     (this is useful to find simpler numbers when the tolerance\n1199     is set low).\n1200 \n1201     When converting to rational, if rational_conversion='base10' (the default), then\n1202     convert floats to rationals using their base-10 (string) representation.\n1203     When rational_conversion='exact' it uses the exact, base-2 representation.\n1204 \n1205     Examples\n1206     ========\n1207 \n1208     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi\n1209     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])\n1210     -2 + 2*GoldenRatio\n1211     >>> nsimplify((1/(exp(3*pi*I/5)+1)))\n1212     1/2 - I*sqrt(sqrt(5)/10 + 1/4)\n1213     >>> nsimplify(I**I, [pi])\n1214     exp(-pi/2)\n1215     >>> nsimplify(pi, tolerance=0.01)\n1216     22/7\n1217 \n1218     >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')\n1219     6004799503160655/18014398509481984\n1220     >>> nsimplify(0.333333333333333, rational=True)\n1221     1/3\n1222 \n1223     See Also\n1224     ========\n1225     sympy.core.function.nfloat\n1226 \n1227     \"\"\"\n1228     try:\n1229         return sympify(as_int(expr))\n1230     except (TypeError, ValueError):\n1231         pass\n1232     expr = sympify(expr).xreplace({\n1233         Float('inf'): S.Infinity,\n1234         Float('-inf'): S.NegativeInfinity,\n1235         })\n1236     if expr is S.Infinity or expr is S.NegativeInfinity:\n1237         return expr\n1238     if rational or expr.free_symbols:\n1239         return _real_to_rational(expr, tolerance, rational_conversion)\n1240 \n1241     # SymPy's default tolerance for Rationals is 15; other numbers may have\n1242     # lower tolerances set, so use them to pick the largest tolerance if None\n1243     # was given\n1244     if tolerance is None:\n1245         tolerance = 10**-min([15] +\n1246              [mpmath.libmp.libmpf.prec_to_dps(n._prec)\n1247              for n in expr.atoms(Float)])\n1248     # XXX should prec be set independent of tolerance or should it be computed\n1249     # from tolerance?\n1250     prec = 30\n1251     bprec = int(prec*3.33)\n1252 \n1253     constants_dict = {}\n1254     for constant in constants:\n1255         constant = sympify(constant)\n1256         v = constant.evalf(prec)\n1257         if not v.is_Float:\n1258             raise ValueError(\"constants must be real-valued\")\n1259         constants_dict[str(constant)] = v._to_mpmath(bprec)\n1260 \n1261     exprval = expr.evalf(prec, chop=True)\n1262     re, im = exprval.as_real_imag()\n1263 \n1264     # safety check to make sure that this evaluated to a number\n1265     if not (re.is_Number and im.is_Number):\n1266         return expr\n1267 \n1268     def nsimplify_real(x):\n1269         orig = mpmath.mp.dps\n1270         xv = x._to_mpmath(bprec)\n1271         try:\n1272             # We'll be happy with low precision if a simple fraction\n1273             if not (tolerance or full):\n1274                 mpmath.mp.dps = 15\n1275                 rat = mpmath.pslq([xv, 1])\n1276                 if rat is not None:\n1277                     return Rational(-int(rat[1]), int(rat[0]))\n1278             mpmath.mp.dps = prec\n1279             newexpr = mpmath.identify(xv, constants=constants_dict,\n1280                 tol=tolerance, full=full)\n1281             if not newexpr:\n1282                 raise ValueError\n1283             if full:\n1284                 newexpr = newexpr[0]\n1285             expr = sympify(newexpr)\n1286             if x and not expr:  # don't let x become 0\n1287                 raise ValueError\n1288             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:\n1289                 raise ValueError\n1290             return expr\n1291         finally:\n1292             # even though there are returns above, this is executed\n1293             # before leaving\n1294             mpmath.mp.dps = orig\n1295     try:\n1296         if re:\n1297             re = nsimplify_real(re)\n1298         if im:\n1299             im = nsimplify_real(im)\n1300     except ValueError:\n1301         if rational is None:\n1302             return _real_to_rational(expr, rational_conversion=rational_conversion)\n1303         return expr\n1304 \n1305     rv = re + im*S.ImaginaryUnit\n1306     # if there was a change or rational is explicitly not wanted\n1307     # return the value, else return the Rational representation\n1308     if rv != expr or rational is False:\n1309         return rv\n1310     return _real_to_rational(expr, rational_conversion=rational_conversion)\n1311 \n1312 \n1313 def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):\n1314     \"\"\"\n1315     Replace all reals in expr with rationals.\n1316 \n1317     >>> from sympy import Rational\n1318     >>> from sympy.simplify.simplify import _real_to_rational\n1319     >>> from sympy.abc import x\n1320 \n1321     >>> _real_to_rational(.76 + .1*x**.5)\n1322     sqrt(x)/10 + 19/25\n1323 \n1324     If rational_conversion='base10', this uses the base-10 string. If\n1325     rational_conversion='exact', the exact, base-2 representation is used.\n1326 \n1327     >>> _real_to_rational(0.333333333333333, rational_conversion='exact')\n1328     6004799503160655/18014398509481984\n1329     >>> _real_to_rational(0.333333333333333)\n1330     1/3\n1331 \n1332     \"\"\"\n1333     expr = _sympify(expr)\n1334     inf = Float('inf')\n1335     p = expr\n1336     reps = {}\n1337     reduce_num = None\n1338     if tolerance is not None and tolerance < 1:\n1339         reduce_num = ceiling(1/tolerance)\n1340     for fl in p.atoms(Float):\n1341         key = fl\n1342         if reduce_num is not None:\n1343             r = Rational(fl).limit_denominator(reduce_num)\n1344         elif (tolerance is not None and tolerance >= 1 and\n1345                 fl.is_Integer is False):\n1346             r = Rational(tolerance*round(fl/tolerance)\n1347                 ).limit_denominator(int(tolerance))\n1348         else:\n1349             if rational_conversion == 'exact':\n1350                 r = Rational(fl)\n1351                 reps[key] = r\n1352                 continue\n1353             elif rational_conversion != 'base10':\n1354                 raise ValueError(\"rational_conversion must be 'base10' or 'exact'\")\n1355 \n1356             r = nsimplify(fl, rational=False)\n1357             # e.g. log(3).n() -> log(3) instead of a Rational\n1358             if fl and not r:\n1359                 r = Rational(fl)\n1360             elif not r.is_Rational:\n1361                 if fl == inf or fl == -inf:\n1362                     r = S.ComplexInfinity\n1363                 elif fl < 0:\n1364                     fl = -fl\n1365                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))\n1366                     r = -Rational(str(fl/d))*d\n1367                 elif fl > 0:\n1368                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))\n1369                     r = Rational(str(fl/d))*d\n1370                 else:\n1371                     r = Integer(0)\n1372         reps[key] = r\n1373     return p.subs(reps, simultaneous=True)\n1374 \n1375 \n1376 def clear_coefficients(expr, rhs=S.Zero):\n1377     \"\"\"Return `p, r` where `p` is the expression obtained when Rational\n1378     additive and multiplicative coefficients of `expr` have been stripped\n1379     away in a naive fashion (i.e. without simplification). The operations\n1380     needed to remove the coefficients will be applied to `rhs` and returned\n1381     as `r`.\n1382 \n1383     Examples\n1384     ========\n1385 \n1386     >>> from sympy.simplify.simplify import clear_coefficients\n1387     >>> from sympy.abc import x, y\n1388     >>> from sympy import Dummy\n1389     >>> expr = 4*y*(6*x + 3)\n1390     >>> clear_coefficients(expr - 2)\n1391     (y*(2*x + 1), 1/6)\n1392 \n1393     When solving 2 or more expressions like `expr = a`,\n1394     `expr = b`, etc..., it is advantageous to provide a Dummy symbol\n1395     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.\n1396 \n1397     >>> rhs = Dummy('rhs')\n1398     >>> clear_coefficients(expr, rhs)\n1399     (y*(2*x + 1), _rhs/12)\n1400     >>> _[1].subs(rhs, 2)\n1401     1/6\n1402     \"\"\"\n1403     was = None\n1404     free = expr.free_symbols\n1405     if expr.is_Rational:\n1406         return (S.Zero, rhs - expr)\n1407     while expr and was != expr:\n1408         was = expr\n1409         m, expr = (\n1410             expr.as_content_primitive()\n1411             if free else\n1412             factor_terms(expr).as_coeff_Mul(rational=True))\n1413         rhs /= m\n1414         c, expr = expr.as_coeff_Add(rational=True)\n1415         rhs -= c\n1416     expr = signsimp(expr, evaluate = False)\n1417     if _coeff_isneg(expr):\n1418         expr = -expr\n1419         rhs = -rhs\n1420     return expr, rhs\n",
        "intended_behavior": "This file likely contains the simplification logic that mistakenly converts `cos` with complex arguments into `cosh` in an incorrect manner. The intended behavior here would involve a better handling of trigonometric functions with complex arguments to ensure that the conversion between `cos` and `cosh` (or vice versa) preserves the mathematical accuracy, particularly in recognizing the difference between adding and multiplying complex parts in these functions. Specifically, the simplification process should correctly interpret and simplify `cos(pi/6 - I*asinh())` expressions without altering their fundamental properties or incorrect numerical simplification."
    },
    {
        "rel_file_path": "sympy/core/expr.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/core/expr.py",
        "start": 1,
        "end": 3392,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from .sympify import sympify, _sympify, SympifyError\n4 from .basic import Basic, Atom\n5 from .singleton import S\n6 from .evalf import EvalfMixin, pure_complex\n7 from .decorators import _sympifyit, call_highest_priority\n8 from .cache import cacheit\n9 from .compatibility import reduce, as_int, default_sort_key, range\n10 from mpmath.libmp import mpf_log, prec_to_dps\n11 \n12 from collections import defaultdict\n13 \n14 class Expr(Basic, EvalfMixin):\n15     \"\"\"\n16     Base class for algebraic expressions.\n17 \n18     Everything that requires arithmetic operations to be defined\n19     should subclass this class, instead of Basic (which should be\n20     used only for argument storage and expression manipulation, i.e.\n21     pattern matching, substitutions, etc).\n22 \n23     See Also\n24     ========\n25 \n26     sympy.core.basic.Basic\n27     \"\"\"\n28 \n29     __slots__ = []\n30 \n31     @property\n32     def _diff_wrt(self):\n33         \"\"\"Is it allowed to take derivative wrt to this instance.\n34 \n35         This determines if it is allowed to take derivatives wrt this object.\n36         Subclasses such as Symbol, Function and Derivative should return True\n37         to enable derivatives wrt them. The implementation in Derivative\n38         separates the Symbol and non-Symbol _diff_wrt=True variables and\n39         temporarily converts the non-Symbol vars in Symbols when performing\n40         the differentiation.\n41 \n42         Note, see the docstring of Derivative for how this should work\n43         mathematically. In particular, note that expr.subs(yourclass, Symbol)\n44         should be well-defined on a structural level, or this will lead to\n45         inconsistent results.\n46 \n47         Examples\n48         ========\n49 \n50         >>> from sympy import Expr\n51         >>> e = Expr()\n52         >>> e._diff_wrt\n53         False\n54         >>> class MyClass(Expr):\n55         ...     _diff_wrt = True\n56         ...\n57         >>> (2*MyClass()).diff(MyClass())\n58         2\n59         \"\"\"\n60         return False\n61 \n62     @cacheit\n63     def sort_key(self, order=None):\n64 \n65         coeff, expr = self.as_coeff_Mul()\n66 \n67         if expr.is_Pow:\n68             expr, exp = expr.args\n69         else:\n70             expr, exp = expr, S.One\n71 \n72         if expr.is_Dummy:\n73             args = (expr.sort_key(),)\n74         elif expr.is_Atom:\n75             args = (str(expr),)\n76         else:\n77             if expr.is_Add:\n78                 args = expr.as_ordered_terms(order=order)\n79             elif expr.is_Mul:\n80                 args = expr.as_ordered_factors(order=order)\n81             else:\n82                 args = expr.args\n83 \n84             args = tuple(\n85                 [ default_sort_key(arg, order=order) for arg in args ])\n86 \n87         args = (len(args), tuple(args))\n88         exp = exp.sort_key(order=order)\n89 \n90         return expr.class_key(), args, exp, coeff\n91 \n92     # ***************\n93     # * Arithmetics *\n94     # ***************\n95     # Expr and its sublcasses use _op_priority to determine which object\n96     # passed to a binary special method (__mul__, etc.) will handle the\n97     # operation. In general, the 'call_highest_priority' decorator will choose\n98     # the object with the highest _op_priority to handle the call.\n99     # Custom subclasses that want to define their own binary special methods\n100     # should set an _op_priority value that is higher than the default.\n101     #\n102     # **NOTE**:\n103     # This is a temporary fix, and will eventually be replaced with\n104     # something better and more powerful.  See issue 5510.\n105     _op_priority = 10.0\n106 \n107     def __pos__(self):\n108         return self\n109 \n110     def __neg__(self):\n111         return Mul(S.NegativeOne, self)\n112 \n113     def __abs__(self):\n114         from sympy import Abs\n115         return Abs(self)\n116 \n117     @_sympifyit('other', NotImplemented)\n118     @call_highest_priority('__radd__')\n119     def __add__(self, other):\n120         return Add(self, other)\n121 \n122     @_sympifyit('other', NotImplemented)\n123     @call_highest_priority('__add__')\n124     def __radd__(self, other):\n125         return Add(other, self)\n126 \n127     @_sympifyit('other', NotImplemented)\n128     @call_highest_priority('__rsub__')\n129     def __sub__(self, other):\n130         return Add(self, -other)\n131 \n132     @_sympifyit('other', NotImplemented)\n133     @call_highest_priority('__sub__')\n134     def __rsub__(self, other):\n135         return Add(other, -self)\n136 \n137     @_sympifyit('other', NotImplemented)\n138     @call_highest_priority('__rmul__')\n139     def __mul__(self, other):\n140         return Mul(self, other)\n141 \n142     @_sympifyit('other', NotImplemented)\n143     @call_highest_priority('__mul__')\n144     def __rmul__(self, other):\n145         return Mul(other, self)\n146 \n147     @_sympifyit('other', NotImplemented)\n148     @call_highest_priority('__rpow__')\n149     def __pow__(self, other):\n150         return Pow(self, other)\n151 \n152     @_sympifyit('other', NotImplemented)\n153     @call_highest_priority('__pow__')\n154     def __rpow__(self, other):\n155         return Pow(other, self)\n156 \n157     @_sympifyit('other', NotImplemented)\n158     @call_highest_priority('__rdiv__')\n159     def __div__(self, other):\n160         return Mul(self, Pow(other, S.NegativeOne))\n161 \n162     @_sympifyit('other', NotImplemented)\n163     @call_highest_priority('__div__')\n164     def __rdiv__(self, other):\n165         return Mul(other, Pow(self, S.NegativeOne))\n166 \n167     __truediv__ = __div__\n168     __rtruediv__ = __rdiv__\n169 \n170     @_sympifyit('other', NotImplemented)\n171     @call_highest_priority('__rmod__')\n172     def __mod__(self, other):\n173         return Mod(self, other)\n174 \n175     @_sympifyit('other', NotImplemented)\n176     @call_highest_priority('__mod__')\n177     def __rmod__(self, other):\n178         return Mod(other, self)\n179 \n180     @_sympifyit('other', NotImplemented)\n181     @call_highest_priority('__rfloordiv__')\n182     def __floordiv__(self, other):\n183         from sympy.functions.elementary.integers import floor\n184         return floor(self / other)\n185 \n186     @_sympifyit('other', NotImplemented)\n187     @call_highest_priority('__floordiv__')\n188     def __rfloordiv__(self, other):\n189         from sympy.functions.elementary.integers import floor\n190         return floor(self / other)\n191 \n192     def __int__(self):\n193         # Although we only need to round to the units position, we'll\n194         # get one more digit so the extra testing below can be avoided\n195         # unless the rounded value rounded to an integer, e.g. if an\n196         # expression were equal to 1.9 and we rounded to the unit position\n197         # we would get a 2 and would not know if this rounded up or not\n198         # without doing a test (as done below). But if we keep an extra\n199         # digit we know that 1.9 is not the same as 1 and there is no\n200         # need for further testing: our int value is correct. If the value\n201         # were 1.99, however, this would round to 2.0 and our int value is\n202         # off by one. So...if our round value is the same as the int value\n203         # (regardless of how much extra work we do to calculate extra decimal\n204         # places) we need to test whether we are off by one.\n205         from sympy import Dummy\n206         if not self.is_number:\n207             raise TypeError(\"can't convert symbols to int\")\n208         r = self.round(2)\n209         if not r.is_Number:\n210             raise TypeError(\"can't convert complex to int\")\n211         if r in (S.NaN, S.Infinity, S.NegativeInfinity):\n212             raise TypeError(\"can't convert %s to int\" % r)\n213         i = int(r)\n214         if not i:\n215             return 0\n216         # off-by-one check\n217         if i == r and not (self - i).equals(0):\n218             isign = 1 if i > 0 else -1\n219             x = Dummy()\n220             # in the following (self - i).evalf(2) will not always work while\n221             # (self - r).evalf(2) and the use of subs does; if the test that\n222             # was added when this comment was added passes, it might be safe\n223             # to simply use sign to compute this rather than doing this by hand:\n224             diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1\n225             if diff_sign != isign:\n226                 i -= isign\n227         return i\n228     __long__ = __int__\n229 \n230     def __float__(self):\n231         # Don't bother testing if it's a number; if it's not this is going\n232         # to fail, and if it is we still need to check that it evalf'ed to\n233         # a number.\n234         result = self.evalf()\n235         if result.is_Number:\n236             return float(result)\n237         if result.is_number and result.as_real_imag()[1]:\n238             raise TypeError(\"can't convert complex to float\")\n239         raise TypeError(\"can't convert expression to float\")\n240 \n241     def __complex__(self):\n242         result = self.evalf()\n243         re, im = result.as_real_imag()\n244         return complex(float(re), float(im))\n245 \n246     def __ge__(self, other):\n247         from sympy import GreaterThan\n248         try:\n249             other = _sympify(other)\n250         except SympifyError:\n251             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n252         for me in (self, other):\n253             if (me.is_complex and me.is_real is False) or \\\n254                     me.has(S.ComplexInfinity):\n255                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n256             if me is S.NaN:\n257                 raise TypeError(\"Invalid NaN comparison\")\n258         n2 = _n2(self, other)\n259         if n2 is not None:\n260             return _sympify(n2 >= 0)\n261         if self.is_real or other.is_real:\n262             dif = self - other\n263             if dif.is_nonnegative is not None and \\\n264                     dif.is_nonnegative is not dif.is_negative:\n265                 return sympify(dif.is_nonnegative)\n266         return GreaterThan(self, other, evaluate=False)\n267 \n268     def __le__(self, other):\n269         from sympy import LessThan\n270         try:\n271             other = _sympify(other)\n272         except SympifyError:\n273             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n274         for me in (self, other):\n275             if (me.is_complex and me.is_real is False) or \\\n276                     me.has(S.ComplexInfinity):\n277                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n278             if me is S.NaN:\n279                 raise TypeError(\"Invalid NaN comparison\")\n280         n2 = _n2(self, other)\n281         if n2 is not None:\n282             return _sympify(n2 <= 0)\n283         if self.is_real or other.is_real:\n284             dif = self - other\n285             if dif.is_nonpositive is not None and \\\n286                     dif.is_nonpositive is not dif.is_positive:\n287                 return sympify(dif.is_nonpositive)\n288         return LessThan(self, other, evaluate=False)\n289 \n290     def __gt__(self, other):\n291         from sympy import StrictGreaterThan\n292         try:\n293             other = _sympify(other)\n294         except SympifyError:\n295             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n296         for me in (self, other):\n297             if (me.is_complex and me.is_real is False) or \\\n298                     me.has(S.ComplexInfinity):\n299                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n300             if me is S.NaN:\n301                 raise TypeError(\"Invalid NaN comparison\")\n302         n2 = _n2(self, other)\n303         if n2 is not None:\n304             return _sympify(n2 > 0)\n305         if self.is_real or other.is_real:\n306             dif = self - other\n307             if dif.is_positive is not None and \\\n308                     dif.is_positive is not dif.is_nonpositive:\n309                 return sympify(dif.is_positive)\n310         return StrictGreaterThan(self, other, evaluate=False)\n311 \n312     def __lt__(self, other):\n313         from sympy import StrictLessThan\n314         try:\n315             other = _sympify(other)\n316         except SympifyError:\n317             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n318         for me in (self, other):\n319             if (me.is_complex and me.is_real is False) or \\\n320                     me.has(S.ComplexInfinity):\n321                 raise TypeError(\"Invalid comparison of complex %s\" % me)\n322             if me is S.NaN:\n323                 raise TypeError(\"Invalid NaN comparison\")\n324         n2 = _n2(self, other)\n325         if n2 is not None:\n326             return _sympify(n2 < 0)\n327         if self.is_real or other.is_real:\n328             dif = self - other\n329             if dif.is_negative is not None and \\\n330                     dif.is_negative is not dif.is_nonnegative:\n331                 return sympify(dif.is_negative)\n332         return StrictLessThan(self, other, evaluate=False)\n333 \n334     @staticmethod\n335     def _from_mpmath(x, prec):\n336         from sympy import Float\n337         if hasattr(x, \"_mpf_\"):\n338             return Float._new(x._mpf_, prec)\n339         elif hasattr(x, \"_mpc_\"):\n340             re, im = x._mpc_\n341             re = Float._new(re, prec)\n342             im = Float._new(im, prec)*S.ImaginaryUnit\n343             return re + im\n344         else:\n345             raise TypeError(\"expected mpmath number (mpf or mpc)\")\n346 \n347     @property\n348     def is_number(self):\n349         \"\"\"Returns True if ``self`` has no free symbols.\n350         It will be faster than ``if not self.free_symbols``, however, since\n351         ``is_number`` will fail as soon as it hits a free symbol.\n352 \n353         Examples\n354         ========\n355 \n356         >>> from sympy import log, Integral\n357         >>> from sympy.abc import x\n358 \n359         >>> x.is_number\n360         False\n361         >>> (2*x).is_number\n362         False\n363         >>> (2 + log(2)).is_number\n364         True\n365         >>> (2 + Integral(2, x)).is_number\n366         False\n367         >>> (2 + Integral(2, (x, 1, 2))).is_number\n368         True\n369 \n370         \"\"\"\n371         return all(obj.is_number for obj in self.args)\n372 \n373     def _random(self, n=None, re_min=-1, im_min=-1, re_max=1, im_max=1):\n374         \"\"\"Return self evaluated, if possible, replacing free symbols with\n375         random complex values, if necessary.\n376 \n377         The random complex value for each free symbol is generated\n378         by the random_complex_number routine giving real and imaginary\n379         parts in the range given by the re_min, re_max, im_min, and im_max\n380         values. The returned value is evaluated to a precision of n\n381         (if given) else the maximum of 15 and the precision needed\n382         to get more than 1 digit of precision. If the expression\n383         could not be evaluated to a number, or could not be evaluated\n384         to more than 1 digit of precision, then None is returned.\n385 \n386         Examples\n387         ========\n388 \n389         >>> from sympy import sqrt\n390         >>> from sympy.abc import x, y\n391         >>> x._random()                         # doctest: +SKIP\n392         0.0392918155679172 + 0.916050214307199*I\n393         >>> x._random(2)                        # doctest: +SKIP\n394         -0.77 - 0.87*I\n395         >>> (x + y/2)._random(2)                # doctest: +SKIP\n396         -0.57 + 0.16*I\n397         >>> sqrt(2)._random(2)\n398         1.4\n399 \n400         See Also\n401         ========\n402 \n403         sympy.utilities.randtest.random_complex_number\n404         \"\"\"\n405 \n406         free = self.free_symbols\n407         prec = 1\n408         if free:\n409             from sympy.utilities.randtest import random_complex_number\n410             a, c, b, d = re_min, re_max, im_min, im_max\n411             reps = dict(list(zip(free, [random_complex_number(a, b, c, d, rational=True)\n412                            for zi in free])))\n413             try:\n414                 nmag = abs(self.evalf(2, subs=reps))\n415             except (ValueError, TypeError):\n416                 # if an out of range value resulted in evalf problems\n417                 # then return None -- XXX is there a way to know how to\n418                 # select a good random number for a given expression?\n419                 # e.g. when calculating n! negative values for n should not\n420                 # be used\n421                 return None\n422         else:\n423             reps = {}\n424             nmag = abs(self.evalf(2))\n425 \n426         if not hasattr(nmag, '_prec'):\n427             # e.g. exp_polar(2*I*pi) doesn't evaluate but is_number is True\n428             return None\n429 \n430         if nmag._prec == 1:\n431             # increase the precision up to the default maximum\n432             # precision to see if we can get any significance\n433 \n434             from mpmath.libmp.libintmath import giant_steps\n435             from sympy.core.evalf import DEFAULT_MAXPREC as target\n436 \n437             # evaluate\n438             for prec in giant_steps(2, target):\n439                 nmag = abs(self.evalf(prec, subs=reps))\n440                 if nmag._prec != 1:\n441                     break\n442 \n443         if nmag._prec != 1:\n444             if n is None:\n445                 n = max(prec, 15)\n446             return self.evalf(n, subs=reps)\n447 \n448         # never got any significance\n449         return None\n450 \n451     def is_constant(self, *wrt, **flags):\n452         \"\"\"Return True if self is constant, False if not, or None if\n453         the constancy could not be determined conclusively.\n454 \n455         If an expression has no free symbols then it is a constant. If\n456         there are free symbols it is possible that the expression is a\n457         constant, perhaps (but not necessarily) zero. To test such\n458         expressions, two strategies are tried:\n459 \n460         1) numerical evaluation at two random points. If two such evaluations\n461         give two different values and the values have a precision greater than\n462         1 then self is not constant. If the evaluations agree or could not be\n463         obtained with any precision, no decision is made. The numerical testing\n464         is done only if ``wrt`` is different than the free symbols.\n465 \n466         2) differentiation with respect to variables in 'wrt' (or all free\n467         symbols if omitted) to see if the expression is constant or not. This\n468         will not always lead to an expression that is zero even though an\n469         expression is constant (see added test in test_expr.py). If\n470         all derivatives are zero then self is constant with respect to the\n471         given symbols.\n472 \n473         If neither evaluation nor differentiation can prove the expression is\n474         constant, None is returned unless two numerical values happened to be\n475         the same and the flag ``failing_number`` is True -- in that case the\n476         numerical value will be returned.\n477 \n478         If flag simplify=False is passed, self will not be simplified;\n479         the default is True since self should be simplified before testing.\n480 \n481         Examples\n482         ========\n483 \n484         >>> from sympy import cos, sin, Sum, S, pi\n485         >>> from sympy.abc import a, n, x, y\n486         >>> x.is_constant()\n487         False\n488         >>> S(2).is_constant()\n489         True\n490         >>> Sum(x, (x, 1, 10)).is_constant()\n491         True\n492         >>> Sum(x, (x, 1, n)).is_constant()\n493         False\n494         >>> Sum(x, (x, 1, n)).is_constant(y)\n495         True\n496         >>> Sum(x, (x, 1, n)).is_constant(n)\n497         False\n498         >>> Sum(x, (x, 1, n)).is_constant(x)\n499         True\n500         >>> eq = a*cos(x)**2 + a*sin(x)**2 - a\n501         >>> eq.is_constant()\n502         True\n503         >>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0\n504         True\n505 \n506         >>> (0**x).is_constant()\n507         False\n508         >>> x.is_constant()\n509         False\n510         >>> (x**x).is_constant()\n511         False\n512         >>> one = cos(x)**2 + sin(x)**2\n513         >>> one.is_constant()\n514         True\n515         >>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1\n516         True\n517         \"\"\"\n518 \n519         simplify = flags.get('simplify', True)\n520 \n521         # Except for expressions that contain units, only one of these should\n522         # be necessary since if something is\n523         # known to be a number it should also know that there are no\n524         # free symbols. But is_number quits as soon as it hits a non-number\n525         # whereas free_symbols goes until all free symbols have been collected,\n526         # thus is_number should be faster. But a double check on free symbols\n527         # is made just in case there is a discrepancy between the two.\n528         free = self.free_symbols\n529         if self.is_number or not free:\n530             # if the following assertion fails then that object's free_symbols\n531             # method needs attention: if an expression is a number it cannot\n532             # have free symbols\n533             assert not free\n534             return True\n535 \n536         # if we are only interested in some symbols and they are not in the\n537         # free symbols then this expression is constant wrt those symbols\n538         wrt = set(wrt)\n539         if wrt and not wrt & free:\n540             return True\n541         wrt = wrt or free\n542 \n543         # simplify unless this has already been done\n544         expr = self\n545         if simplify:\n546             expr = expr.simplify()\n547 \n548         # is_zero should be a quick assumptions check; it can be wrong for\n549         # numbers (see test_is_not_constant test), giving False when it\n550         # shouldn't, but hopefully it will never give True unless it is sure.\n551         if expr.is_zero:\n552             return True\n553 \n554         # try numerical evaluation to see if we get two different values\n555         failing_number = None\n556         if wrt == free:\n557             # try 0 (for a) and 1 (for b)\n558             try:\n559                 a = expr.subs(list(zip(free, [0]*len(free))),\n560                     simultaneous=True)\n561                 if a is S.NaN:\n562                     # evaluation may succeed when substitution fails\n563                     a = expr._random(None, 0, 0, 0, 0)\n564             except ZeroDivisionError:\n565                 a = None\n566             if a is not None and a is not S.NaN:\n567                 try:\n568                     b = expr.subs(list(zip(free, [1]*len(free))),\n569                         simultaneous=True)\n570                     if b is S.NaN:\n571                         # evaluation may succeed when substitution fails\n572                         b = expr._random(None, 1, 0, 1, 0)\n573                 except ZeroDivisionError:\n574                     b = None\n575                 if b is not None and b is not S.NaN and b.equals(a) is False:\n576                     return False\n577                 # try random real\n578                 b = expr._random(None, -1, 0, 1, 0)\n579                 if b is not None and b is not S.NaN and b.equals(a) is False:\n580                     return False\n581                 # try random complex\n582                 b = expr._random()\n583                 if b is not None and b is not S.NaN:\n584                     if b.equals(a) is False:\n585                         return False\n586                     failing_number = a if a.is_number else b\n587 \n588         # now we will test each wrt symbol (or all free symbols) to see if the\n589         # expression depends on them or not using differentiation. This is\n590         # not sufficient for all expressions, however, so we don't return\n591         # False if we get a derivative other than 0 with free symbols.\n592         for w in wrt:\n593             deriv = expr.diff(w)\n594             if simplify:\n595                 deriv = deriv.simplify()\n596             if deriv != 0:\n597                 if not (pure_complex(deriv, or_real=True)):\n598                     if flags.get('failing_number', False):\n599                         return failing_number\n600                     elif deriv.free_symbols:\n601                         # dead line provided _random returns None in such cases\n602                         return None\n603                 return False\n604         return True\n605 \n606     def equals(self, other, failing_expression=False):\n607         \"\"\"Return True if self == other, False if it doesn't, or None. If\n608         failing_expression is True then the expression which did not simplify\n609         to a 0 will be returned instead of None.\n610 \n611         If ``self`` is a Number (or complex number) that is not zero, then\n612         the result is False.\n613 \n614         If ``self`` is a number and has not evaluated to zero, evalf will be\n615         used to test whether the expression evaluates to zero. If it does so\n616         and the result has significance (i.e. the precision is either -1, for\n617         a Rational result, or is greater than 1) then the evalf value will be\n618         used to return True or False.\n619 \n620         \"\"\"\n621         from sympy.simplify.simplify import nsimplify, simplify\n622         from sympy.solvers.solveset import solveset\n623         from sympy.polys.polyerrors import NotAlgebraic\n624         from sympy.polys.numberfields import minimal_polynomial\n625 \n626         other = sympify(other)\n627         if self == other:\n628             return True\n629 \n630         # they aren't the same so see if we can make the difference 0;\n631         # don't worry about doing simplification steps one at a time\n632         # because if the expression ever goes to 0 then the subsequent\n633         # simplification steps that are done will be very fast.\n634         diff = factor_terms(simplify(self - other), radical=True)\n635 \n636         if not diff:\n637             return True\n638 \n639         if not diff.has(Add, Mod):\n640             # if there is no expanding to be done after simplifying\n641             # then this can't be a zero\n642             return False\n643 \n644         constant = diff.is_constant(simplify=False, failing_number=True)\n645 \n646         if constant is False:\n647             return False\n648 \n649         if constant is None and (diff.free_symbols or not diff.is_number):\n650             # e.g. unless the right simplification is done, a symbolic\n651             # zero is possible (see expression of issue 6829: without\n652             # simplification constant will be None).\n653             return\n654 \n655         if constant is True:\n656             ndiff = diff._random()\n657             if ndiff:\n658                 return False\n659 \n660         # sometimes we can use a simplified result to give a clue as to\n661         # what the expression should be; if the expression is *not* zero\n662         # then we should have been able to compute that and so now\n663         # we can just consider the cases where the approximation appears\n664         # to be zero -- we try to prove it via minimal_polynomial.\n665         if diff.is_number:\n666             approx = diff.nsimplify()\n667             if not approx:\n668                 # try to prove via self-consistency\n669                 surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n670                 # it seems to work better to try big ones first\n671                 surds.sort(key=lambda x: -x.args[0])\n672                 for s in surds:\n673                     try:\n674                         # simplify is False here -- this expression has already\n675                         # been identified as being hard to identify as zero;\n676                         # we will handle the checking ourselves using nsimplify\n677                         # to see if we are in the right ballpark or not and if so\n678                         # *then* the simplification will be attempted.\n679                         if s.is_Symbol:\n680                             sol = list(solveset(diff, s))\n681                         else:\n682                             sol = [s]\n683                         if sol:\n684                             if s in sol:\n685                                 return True\n686                             if s.is_real:\n687                                 if any(nsimplify(si, [s]) == s and simplify(si) == s\n688                                         for si in sol):\n689                                     return True\n690                     except NotImplementedError:\n691                         pass\n692 \n693                 # try to prove with minimal_polynomial but know when\n694                 # *not* to use this or else it can take a long time. e.g. issue 8354\n695                 if True:  # change True to condition that assures non-hang\n696                     try:\n697                         mp = minimal_polynomial(diff)\n698                         if mp.is_Symbol:\n699                             return True\n700                         return False\n701                     except (NotAlgebraic, NotImplementedError):\n702                         pass\n703 \n704         # diff has not simplified to zero; constant is either None, True\n705         # or the number with significance (prec != 1) that was randomly\n706         # calculated twice as the same value.\n707         if constant not in (True, None) and constant != 0:\n708             return False\n709 \n710         if failing_expression:\n711             return diff\n712         return None\n713 \n714     def _eval_is_positive(self):\n715         from sympy.polys.numberfields import minimal_polynomial\n716         from sympy.polys.polyerrors import NotAlgebraic\n717         if self.is_number:\n718             if self.is_real is False:\n719                 return False\n720             try:\n721                 # check to see that we can get a value\n722                 n2 = self._eval_evalf(2)\n723                 if n2 is None:\n724                     raise AttributeError\n725                 if n2._prec == 1:  # no significance\n726                     raise AttributeError\n727                 if n2 == S.NaN:\n728                     raise AttributeError\n729             except (AttributeError, ValueError):\n730                 return None\n731             n, i = self.evalf(2).as_real_imag()\n732             if not i.is_Number or not n.is_Number:\n733                 return False\n734             if n._prec != 1 and i._prec != 1:\n735                 return bool(not i and n > 0)\n736             elif n._prec == 1 and (not i or i._prec == 1) and \\\n737                     self.is_algebraic and not self.has(Function):\n738                 try:\n739                     if minimal_polynomial(self).is_Symbol:\n740                         return False\n741                 except (NotAlgebraic, NotImplementedError):\n742                     pass\n743 \n744     def _eval_is_negative(self):\n745         from sympy.polys.numberfields import minimal_polynomial\n746         from sympy.polys.polyerrors import NotAlgebraic\n747         if self.is_number:\n748             if self.is_real is False:\n749                 return False\n750             try:\n751                 # check to see that we can get a value\n752                 n2 = self._eval_evalf(2)\n753                 if n2 is None:\n754                     raise AttributeError\n755                 if n2._prec == 1:  # no significance\n756                     raise AttributeError\n757                 if n2 == S.NaN:\n758                     raise AttributeError\n759             except (AttributeError, ValueError):\n760                 return None\n761             n, i = self.evalf(2).as_real_imag()\n762             if not i.is_Number or not n.is_Number:\n763                 return False\n764             if n._prec != 1 and i._prec != 1:\n765                 return bool(not i and n < 0)\n766             elif n._prec == 1 and (not i or i._prec == 1) and \\\n767                     self.is_algebraic and not self.has(Function):\n768                 try:\n769                     if minimal_polynomial(self).is_Symbol:\n770                         return False\n771                 except (NotAlgebraic, NotImplementedError):\n772                     pass\n773 \n774     def _eval_interval(self, x, a, b):\n775         \"\"\"\n776         Returns evaluation over an interval.  For most functions this is:\n777 \n778         self.subs(x, b) - self.subs(x, a),\n779 \n780         possibly using limit() if NaN is returned from subs.\n781 \n782         If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),\n783         respectively.\n784 \n785         \"\"\"\n786         from sympy.series import limit, Limit\n787         from sympy.solvers.solveset import solveset\n788         from sympy.sets.sets import Interval\n789 \n790         if (a is None and b is None):\n791             raise ValueError('Both interval ends cannot be None.')\n792 \n793         if a == b:\n794             return 0\n795 \n796         if a is None:\n797             A = 0\n798         else:\n799             A = self.subs(x, a)\n800             if A.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n801                 if (a < b) != False:\n802                     A = limit(self, x, a,\"+\")\n803                 else:\n804                     A = limit(self, x, a,\"-\")\n805 \n806                 if A is S.NaN:\n807                     return A\n808                 if isinstance(A, Limit):\n809                     raise NotImplementedError(\"Could not compute limit\")\n810 \n811         if b is None:\n812             B = 0\n813         else:\n814             B = self.subs(x, b)\n815             if B.has(S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n816                 if (a < b) != False:\n817                     B = limit(self, x, b,\"-\")\n818                 else:\n819                     B = limit(self, x, b,\"+\")\n820 \n821                 if isinstance(B, Limit):\n822                     raise NotImplementedError(\"Could not compute limit\")\n823 \n824         if (a and b) is None:\n825             return B - A\n826 \n827         value = B - A\n828 \n829         if a.is_comparable and b.is_comparable:\n830             if a < b:\n831                 domain = Interval(a, b)\n832             else:\n833                 domain = Interval(b, a)\n834             singularities = list(solveset(self.cancel().as_numer_denom()[1], x, domain = domain))\n835             for s in singularities:\n836                 if a < s < b:\n837                     value += -limit(self, x, s, \"+\") + limit(self, x, s, \"-\")\n838                 elif b < s < a:\n839                     value += limit(self, x, s, \"+\") - limit(self, x, s, \"-\")\n840 \n841         return value\n842 \n843     def _eval_power(self, other):\n844         # subclass to compute self**other for cases when\n845         # other is not NaN, 0, or 1\n846         return None\n847 \n848     def _eval_conjugate(self):\n849         if self.is_real:\n850             return self\n851         elif self.is_imaginary:\n852             return -self\n853 \n854     def conjugate(self):\n855         from sympy.functions.elementary.complexes import conjugate as c\n856         return c(self)\n857 \n858     def _eval_transpose(self):\n859         from sympy.functions.elementary.complexes import conjugate\n860         if self.is_complex:\n861             return self\n862         elif self.is_hermitian:\n863             return conjugate(self)\n864         elif self.is_antihermitian:\n865             return -conjugate(self)\n866 \n867     def transpose(self):\n868         from sympy.functions.elementary.complexes import transpose\n869         return transpose(self)\n870 \n871     def _eval_adjoint(self):\n872         from sympy.functions.elementary.complexes import conjugate, transpose\n873         if self.is_hermitian:\n874             return self\n875         elif self.is_antihermitian:\n876             return -self\n877         obj = self._eval_conjugate()\n878         if obj is not None:\n879             return transpose(obj)\n880         obj = self._eval_transpose()\n881         if obj is not None:\n882             return conjugate(obj)\n883 \n884     def adjoint(self):\n885         from sympy.functions.elementary.complexes import adjoint\n886         return adjoint(self)\n887 \n888     @classmethod\n889     def _parse_order(cls, order):\n890         \"\"\"Parse and configure the ordering of terms. \"\"\"\n891         from sympy.polys.orderings import monomial_key\n892 \n893         try:\n894             reverse = order.startswith('rev-')\n895         except AttributeError:\n896             reverse = False\n897         else:\n898             if reverse:\n899                 order = order[4:]\n900 \n901         monom_key = monomial_key(order)\n902 \n903         def neg(monom):\n904             result = []\n905 \n906             for m in monom:\n907                 if isinstance(m, tuple):\n908                     result.append(neg(m))\n909                 else:\n910                     result.append(-m)\n911 \n912             return tuple(result)\n913 \n914         def key(term):\n915             _, ((re, im), monom, ncpart) = term\n916 \n917             monom = neg(monom_key(monom))\n918             ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n919             coeff = ((bool(im), im), (re, im))\n920 \n921             return monom, ncpart, coeff\n922 \n923         return key, reverse\n924 \n925     def as_ordered_factors(self, order=None):\n926         \"\"\"Return list of ordered factors (if Mul) else [self].\"\"\"\n927         return [self]\n928 \n929     def as_ordered_terms(self, order=None, data=False):\n930         \"\"\"\n931         Transform an expression to an ordered list of terms.\n932 \n933         Examples\n934         ========\n935 \n936         >>> from sympy import sin, cos\n937         >>> from sympy.abc import x\n938 \n939         >>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()\n940         [sin(x)**2*cos(x), sin(x)**2, 1]\n941 \n942         \"\"\"\n943         key, reverse = self._parse_order(order)\n944         terms, gens = self.as_terms()\n945 \n946         if not any(term.is_Order for term, _ in terms):\n947             ordered = sorted(terms, key=key, reverse=reverse)\n948         else:\n949             _terms, _order = [], []\n950 \n951             for term, repr in terms:\n952                 if not term.is_Order:\n953                     _terms.append((term, repr))\n954                 else:\n955                     _order.append((term, repr))\n956 \n957             ordered = sorted(_terms, key=key, reverse=True) \\\n958                 + sorted(_order, key=key, reverse=True)\n959 \n960         if data:\n961             return ordered, gens\n962         else:\n963             return [term for term, _ in ordered]\n964 \n965     def as_terms(self):\n966         \"\"\"Transform an expression to a list of terms. \"\"\"\n967         from .add import Add\n968         from .mul import Mul\n969         from .exprtools import decompose_power\n970 \n971         gens, terms = set([]), []\n972 \n973         for term in Add.make_args(self):\n974             coeff, _term = term.as_coeff_Mul()\n975 \n976             coeff = complex(coeff)\n977             cpart, ncpart = {}, []\n978 \n979             if _term is not S.One:\n980                 for factor in Mul.make_args(_term):\n981                     if factor.is_number:\n982                         try:\n983                             coeff *= complex(factor)\n984                         except TypeError:\n985                             pass\n986                         else:\n987                             continue\n988 \n989                     if factor.is_commutative:\n990                         base, exp = decompose_power(factor)\n991 \n992                         cpart[base] = exp\n993                         gens.add(base)\n994                     else:\n995                         ncpart.append(factor)\n996 \n997             coeff = coeff.real, coeff.imag\n998             ncpart = tuple(ncpart)\n999 \n1000             terms.append((term, (coeff, cpart, ncpart)))\n1001 \n1002         gens = sorted(gens, key=default_sort_key)\n1003 \n1004         k, indices = len(gens), {}\n1005 \n1006         for i, g in enumerate(gens):\n1007             indices[g] = i\n1008 \n1009         result = []\n1010 \n1011         for term, (coeff, cpart, ncpart) in terms:\n1012             monom = [0]*k\n1013 \n1014             for base, exp in cpart.items():\n1015                 monom[indices[base]] = exp\n1016 \n1017             result.append((term, (coeff, tuple(monom), ncpart)))\n1018 \n1019         return result, gens\n1020 \n1021     def removeO(self):\n1022         \"\"\"Removes the additive O(..) symbol if there is one\"\"\"\n1023         return self\n1024 \n1025     def getO(self):\n1026         \"\"\"Returns the additive O(..) symbol if there is one, else None.\"\"\"\n1027         return None\n1028 \n1029     def getn(self):\n1030         \"\"\"\n1031         Returns the order of the expression.\n1032 \n1033         The order is determined either from the O(...) term. If there\n1034         is no O(...) term, it returns None.\n1035 \n1036         Examples\n1037         ========\n1038 \n1039         >>> from sympy import O\n1040         >>> from sympy.abc import x\n1041         >>> (1 + x + O(x**2)).getn()\n1042         2\n1043         >>> (1 + x).getn()\n1044 \n1045         \"\"\"\n1046         from sympy import Dummy, Symbol\n1047         o = self.getO()\n1048         if o is None:\n1049             return None\n1050         elif o.is_Order:\n1051             o = o.expr\n1052             if o is S.One:\n1053                 return S.Zero\n1054             if o.is_Symbol:\n1055                 return S.One\n1056             if o.is_Pow:\n1057                 return o.args[1]\n1058             if o.is_Mul:  # x**n*log(x)**n or x**n/log(x)**n\n1059                 for oi in o.args:\n1060                     if oi.is_Symbol:\n1061                         return S.One\n1062                     if oi.is_Pow:\n1063                         syms = oi.atoms(Symbol)\n1064                         if len(syms) == 1:\n1065                             x = syms.pop()\n1066                             oi = oi.subs(x, Dummy('x', positive=True))\n1067                             if oi.base.is_Symbol and oi.exp.is_Rational:\n1068                                 return abs(oi.exp)\n1069 \n1070         raise NotImplementedError('not sure of order of %s' % o)\n1071 \n1072     def count_ops(self, visual=None):\n1073         \"\"\"wrapper for count_ops that returns the operation count.\"\"\"\n1074         from .function import count_ops\n1075         return count_ops(self, visual)\n1076 \n1077     def args_cnc(self, cset=False, warn=True, split_1=True):\n1078         \"\"\"Return [commutative factors, non-commutative factors] of self.\n1079 \n1080         self is treated as a Mul and the ordering of the factors is maintained.\n1081         If ``cset`` is True the commutative factors will be returned in a set.\n1082         If there were repeated factors (as may happen with an unevaluated Mul)\n1083         then an error will be raised unless it is explicitly supressed by\n1084         setting ``warn`` to False.\n1085 \n1086         Note: -1 is always separated from a Number unless split_1 is False.\n1087 \n1088         >>> from sympy import symbols, oo\n1089         >>> A, B = symbols('A B', commutative=0)\n1090         >>> x, y = symbols('x y')\n1091         >>> (-2*x*y).args_cnc()\n1092         [[-1, 2, x, y], []]\n1093         >>> (-2.5*x).args_cnc()\n1094         [[-1, 2.5, x], []]\n1095         >>> (-2*x*A*B*y).args_cnc()\n1096         [[-1, 2, x, y], [A, B]]\n1097         >>> (-2*x*A*B*y).args_cnc(split_1=False)\n1098         [[-2, x, y], [A, B]]\n1099         >>> (-2*x*y).args_cnc(cset=True)\n1100         [{-1, 2, x, y}, []]\n1101 \n1102         The arg is always treated as a Mul:\n1103 \n1104         >>> (-2 + x + A).args_cnc()\n1105         [[], [x - 2 + A]]\n1106         >>> (-oo).args_cnc() # -oo is a singleton\n1107         [[-1, oo], []]\n1108         \"\"\"\n1109 \n1110         if self.is_Mul:\n1111             args = list(self.args)\n1112         else:\n1113             args = [self]\n1114         for i, mi in enumerate(args):\n1115             if not mi.is_commutative:\n1116                 c = args[:i]\n1117                 nc = args[i:]\n1118                 break\n1119         else:\n1120             c = args\n1121             nc = []\n1122 \n1123         if c and split_1 and (\n1124             c[0].is_Number and\n1125             c[0].is_negative and\n1126                 c[0] is not S.NegativeOne):\n1127             c[:1] = [S.NegativeOne, -c[0]]\n1128 \n1129         if cset:\n1130             clen = len(c)\n1131             c = set(c)\n1132             if clen and warn and len(c) != clen:\n1133                 raise ValueError('repeated commutative arguments: %s' %\n1134                                  [ci for ci in c if list(self.args).count(ci) > 1])\n1135         return [c, nc]\n1136 \n1137     def coeff(self, x, n=1, right=False):\n1138         \"\"\"\n1139         Returns the coefficient from the term(s) containing ``x**n``. If ``n``\n1140         is zero then all terms independent of ``x`` will be returned.\n1141 \n1142         When ``x`` is noncommutative, the coefficient to the left (default) or\n1143         right of ``x`` can be returned. The keyword 'right' is ignored when\n1144         ``x`` is commutative.\n1145 \n1146         See Also\n1147         ========\n1148 \n1149         as_coefficient: separate the expression into a coefficient and factor\n1150         as_coeff_Add: separate the additive constant from an expression\n1151         as_coeff_Mul: separate the multiplicative constant from an expression\n1152         as_independent: separate x-dependent terms/factors from others\n1153         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1154         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1155 \n1156         Examples\n1157         ========\n1158 \n1159         >>> from sympy import symbols\n1160         >>> from sympy.abc import x, y, z\n1161 \n1162         You can select terms that have an explicit negative in front of them:\n1163 \n1164         >>> (-x + 2*y).coeff(-1)\n1165         x\n1166         >>> (x - 2*y).coeff(-1)\n1167         2*y\n1168 \n1169         You can select terms with no Rational coefficient:\n1170 \n1171         >>> (x + 2*y).coeff(1)\n1172         x\n1173         >>> (3 + 2*x + 4*x**2).coeff(1)\n1174         0\n1175 \n1176         You can select terms independent of x by making n=0; in this case\n1177         expr.as_independent(x)[0] is returned (and 0 will be returned instead\n1178         of None):\n1179 \n1180         >>> (3 + 2*x + 4*x**2).coeff(x, 0)\n1181         3\n1182         >>> eq = ((x + 1)**3).expand() + 1\n1183         >>> eq\n1184         x**3 + 3*x**2 + 3*x + 2\n1185         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1186         [1, 3, 3, 2]\n1187         >>> eq -= 2\n1188         >>> [eq.coeff(x, i) for i in reversed(range(4))]\n1189         [1, 3, 3, 0]\n1190 \n1191         You can select terms that have a numerical term in front of them:\n1192 \n1193         >>> (-x - 2*y).coeff(2)\n1194         -y\n1195         >>> from sympy import sqrt\n1196         >>> (x + sqrt(2)*x).coeff(sqrt(2))\n1197         x\n1198 \n1199         The matching is exact:\n1200 \n1201         >>> (3 + 2*x + 4*x**2).coeff(x)\n1202         2\n1203         >>> (3 + 2*x + 4*x**2).coeff(x**2)\n1204         4\n1205         >>> (3 + 2*x + 4*x**2).coeff(x**3)\n1206         0\n1207         >>> (z*(x + y)**2).coeff((x + y)**2)\n1208         z\n1209         >>> (z*(x + y)**2).coeff(x + y)\n1210         0\n1211 \n1212         In addition, no factoring is done, so 1 + z*(1 + y) is not obtained\n1213         from the following:\n1214 \n1215         >>> (x + z*(x + x*y)).coeff(x)\n1216         1\n1217 \n1218         If such factoring is desired, factor_terms can be used first:\n1219 \n1220         >>> from sympy import factor_terms\n1221         >>> factor_terms(x + z*(x + x*y)).coeff(x)\n1222         z*(y + 1) + 1\n1223 \n1224         >>> n, m, o = symbols('n m o', commutative=False)\n1225         >>> n.coeff(n)\n1226         1\n1227         >>> (3*n).coeff(n)\n1228         3\n1229         >>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n1230         1 + m\n1231         >>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\n1232         m\n1233 \n1234         If there is more than one possible coefficient 0 is returned:\n1235 \n1236         >>> (n*m + m*n).coeff(n)\n1237         0\n1238 \n1239         If there is only one possible coefficient, it is returned:\n1240 \n1241         >>> (n*m + x*m*n).coeff(m*n)\n1242         x\n1243         >>> (n*m + x*m*n).coeff(m*n, right=1)\n1244         1\n1245 \n1246         \"\"\"\n1247         x = sympify(x)\n1248         if not isinstance(x, Basic):\n1249             return S.Zero\n1250 \n1251         n = as_int(n)\n1252 \n1253         if not x:\n1254             return S.Zero\n1255 \n1256         if x == self:\n1257             if n == 1:\n1258                 return S.One\n1259             return S.Zero\n1260 \n1261         if x is S.One:\n1262             co = [a for a in Add.make_args(self)\n1263                   if a.as_coeff_Mul()[0] is S.One]\n1264             if not co:\n1265                 return S.Zero\n1266             return Add(*co)\n1267 \n1268         if n == 0:\n1269             if x.is_Add and self.is_Add:\n1270                 c = self.coeff(x, right=right)\n1271                 if not c:\n1272                     return S.Zero\n1273                 if not right:\n1274                     return self - Add(*[a*x for a in Add.make_args(c)])\n1275                 return self - Add(*[x*a for a in Add.make_args(c)])\n1276             return self.as_independent(x, as_Add=True)[0]\n1277 \n1278         # continue with the full method, looking for this power of x:\n1279         x = x**n\n1280 \n1281         def incommon(l1, l2):\n1282             if not l1 or not l2:\n1283                 return []\n1284             n = min(len(l1), len(l2))\n1285             for i in range(n):\n1286                 if l1[i] != l2[i]:\n1287                     return l1[:i]\n1288             return l1[:]\n1289 \n1290         def find(l, sub, first=True):\n1291             \"\"\" Find where list sub appears in list l. When ``first`` is True\n1292             the first occurance from the left is returned, else the last\n1293             occurance is returned. Return None if sub is not in l.\n1294 \n1295             >> l = range(5)*2\n1296             >> find(l, [2, 3])\n1297             2\n1298             >> find(l, [2, 3], first=0)\n1299             7\n1300             >> find(l, [2, 4])\n1301             None\n1302 \n1303             \"\"\"\n1304             if not sub or not l or len(sub) > len(l):\n1305                 return None\n1306             n = len(sub)\n1307             if not first:\n1308                 l.reverse()\n1309                 sub.reverse()\n1310             for i in range(0, len(l) - n + 1):\n1311                 if all(l[i + j] == sub[j] for j in range(n)):\n1312                     break\n1313             else:\n1314                 i = None\n1315             if not first:\n1316                 l.reverse()\n1317                 sub.reverse()\n1318             if i is not None and not first:\n1319                 i = len(l) - (i + n)\n1320             return i\n1321 \n1322         co = []\n1323         args = Add.make_args(self)\n1324         self_c = self.is_commutative\n1325         x_c = x.is_commutative\n1326         if self_c and not x_c:\n1327             return S.Zero\n1328 \n1329         if self_c:\n1330             xargs = x.args_cnc(cset=True, warn=False)[0]\n1331             for a in args:\n1332                 margs = a.args_cnc(cset=True, warn=False)[0]\n1333                 if len(xargs) > len(margs):\n1334                     continue\n1335                 resid = margs.difference(xargs)\n1336                 if len(resid) + len(xargs) == len(margs):\n1337                     co.append(Mul(*resid))\n1338             if co == []:\n1339                 return S.Zero\n1340             elif co:\n1341                 return Add(*co)\n1342         elif x_c:\n1343             xargs = x.args_cnc(cset=True, warn=False)[0]\n1344             for a in args:\n1345                 margs, nc = a.args_cnc(cset=True)\n1346                 if len(xargs) > len(margs):\n1347                     continue\n1348                 resid = margs.difference(xargs)\n1349                 if len(resid) + len(xargs) == len(margs):\n1350                     co.append(Mul(*(list(resid) + nc)))\n1351             if co == []:\n1352                 return S.Zero\n1353             elif co:\n1354                 return Add(*co)\n1355         else:  # both nc\n1356             xargs, nx = x.args_cnc(cset=True)\n1357             # find the parts that pass the commutative terms\n1358             for a in args:\n1359                 margs, nc = a.args_cnc(cset=True)\n1360                 if len(xargs) > len(margs):\n1361                     continue\n1362                 resid = margs.difference(xargs)\n1363                 if len(resid) + len(xargs) == len(margs):\n1364                     co.append((resid, nc))\n1365             # now check the non-comm parts\n1366             if not co:\n1367                 return S.Zero\n1368             if all(n == co[0][1] for r, n in co):\n1369                 ii = find(co[0][1], nx, right)\n1370                 if ii is not None:\n1371                     if not right:\n1372                         return Mul(Add(*[Mul(*r) for r, c in co]), Mul(*co[0][1][:ii]))\n1373                     else:\n1374                         return Mul(*co[0][1][ii + len(nx):])\n1375             beg = reduce(incommon, (n[1] for n in co))\n1376             if beg:\n1377                 ii = find(beg, nx, right)\n1378                 if ii is not None:\n1379                     if not right:\n1380                         gcdc = co[0][0]\n1381                         for i in range(1, len(co)):\n1382                             gcdc = gcdc.intersection(co[i][0])\n1383                             if not gcdc:\n1384                                 break\n1385                         return Mul(*(list(gcdc) + beg[:ii]))\n1386                     else:\n1387                         m = ii + len(nx)\n1388                         return Add(*[Mul(*(list(r) + n[m:])) for r, n in co])\n1389             end = list(reversed(\n1390                 reduce(incommon, (list(reversed(n[1])) for n in co))))\n1391             if end:\n1392                 ii = find(end, nx, right)\n1393                 if ii is not None:\n1394                     if not right:\n1395                         return Add(*[Mul(*(list(r) + n[:-len(end) + ii])) for r, n in co])\n1396                     else:\n1397                         return Mul(*end[ii + len(nx):])\n1398             # look for single match\n1399             hit = None\n1400             for i, (r, n) in enumerate(co):\n1401                 ii = find(n, nx, right)\n1402                 if ii is not None:\n1403                     if not hit:\n1404                         hit = ii, r, n\n1405                     else:\n1406                         break\n1407             else:\n1408                 if hit:\n1409                     ii, r, n = hit\n1410                     if not right:\n1411                         return Mul(*(list(r) + n[:ii]))\n1412                     else:\n1413                         return Mul(*n[ii + len(nx):])\n1414 \n1415             return S.Zero\n1416 \n1417     def as_expr(self, *gens):\n1418         \"\"\"\n1419         Convert a polynomial to a SymPy expression.\n1420 \n1421         Examples\n1422         ========\n1423 \n1424         >>> from sympy import sin\n1425         >>> from sympy.abc import x, y\n1426 \n1427         >>> f = (x**2 + x*y).as_poly(x, y)\n1428         >>> f.as_expr()\n1429         x**2 + x*y\n1430 \n1431         >>> sin(x).as_expr()\n1432         sin(x)\n1433 \n1434         \"\"\"\n1435         return self\n1436 \n1437     def as_coefficient(self, expr):\n1438         \"\"\"\n1439         Extracts symbolic coefficient at the given expression. In\n1440         other words, this functions separates 'self' into the product\n1441         of 'expr' and 'expr'-free coefficient. If such separation\n1442         is not possible it will return None.\n1443 \n1444         Examples\n1445         ========\n1446 \n1447         >>> from sympy import E, pi, sin, I, Poly\n1448         >>> from sympy.abc import x\n1449 \n1450         >>> E.as_coefficient(E)\n1451         1\n1452         >>> (2*E).as_coefficient(E)\n1453         2\n1454         >>> (2*sin(E)*E).as_coefficient(E)\n1455 \n1456         Two terms have E in them so a sum is returned. (If one were\n1457         desiring the coefficient of the term exactly matching E then\n1458         the constant from the returned expression could be selected.\n1459         Or, for greater precision, a method of Poly can be used to\n1460         indicate the desired term from which the coefficient is\n1461         desired.)\n1462 \n1463         >>> (2*E + x*E).as_coefficient(E)\n1464         x + 2\n1465         >>> _.args[0]  # just want the exact match\n1466         2\n1467         >>> p = Poly(2*E + x*E); p\n1468         Poly(x*E + 2*E, x, E, domain='ZZ')\n1469         >>> p.coeff_monomial(E)\n1470         2\n1471         >>> p.nth(0, 1)\n1472         2\n1473 \n1474         Since the following cannot be written as a product containing\n1475         E as a factor, None is returned. (If the coefficient ``2*x`` is\n1476         desired then the ``coeff`` method should be used.)\n1477 \n1478         >>> (2*E*x + x).as_coefficient(E)\n1479         >>> (2*E*x + x).coeff(E)\n1480         2*x\n1481 \n1482         >>> (E*(x + 1) + x).as_coefficient(E)\n1483 \n1484         >>> (2*pi*I).as_coefficient(pi*I)\n1485         2\n1486         >>> (2*I).as_coefficient(pi*I)\n1487 \n1488         See Also\n1489         ========\n1490 \n1491         coeff: return sum of terms have a given factor\n1492         as_coeff_Add: separate the additive constant from an expression\n1493         as_coeff_Mul: separate the multiplicative constant from an expression\n1494         as_independent: separate x-dependent terms/factors from others\n1495         sympy.polys.polytools.coeff_monomial: efficiently find the single coefficient of a monomial in Poly\n1496         sympy.polys.polytools.nth: like coeff_monomial but powers of monomial terms are used\n1497 \n1498 \n1499         \"\"\"\n1500 \n1501         r = self.extract_multiplicatively(expr)\n1502         if r and not r.has(expr):\n1503             return r\n1504 \n1505     def as_independent(self, *deps, **hint):\n1506         \"\"\"\n1507         A mostly naive separation of a Mul or Add into arguments that are not\n1508         are dependent on deps. To obtain as complete a separation of variables\n1509         as possible, use a separation method first, e.g.:\n1510 \n1511         * separatevars() to change Mul, Add and Pow (including exp) into Mul\n1512         * .expand(mul=True) to change Add or Mul into Add\n1513         * .expand(log=True) to change log expr into an Add\n1514 \n1515         The only non-naive thing that is done here is to respect noncommutative\n1516         ordering of variables and to always return (0, 0) for `self` of zero\n1517         regardless of hints.\n1518 \n1519         For nonzero `self`, the returned tuple (i, d) has the\n1520         following interpretation:\n1521 \n1522         * i will has no variable that appears in deps\n1523         * d will be 1 or else have terms that contain variables that are in deps\n1524         * if self is an Add then self = i + d\n1525         * if self is a Mul then self = i*d\n1526         * otherwise (self, S.One) or (S.One, self) is returned.\n1527 \n1528         To force the expression to be treated as an Add, use the hint as_Add=True\n1529 \n1530         Examples\n1531         ========\n1532 \n1533         -- self is an Add\n1534 \n1535         >>> from sympy import sin, cos, exp\n1536         >>> from sympy.abc import x, y, z\n1537 \n1538         >>> (x + x*y).as_independent(x)\n1539         (0, x*y + x)\n1540         >>> (x + x*y).as_independent(y)\n1541         (x, x*y)\n1542         >>> (2*x*sin(x) + y + x + z).as_independent(x)\n1543         (y + z, 2*x*sin(x) + x)\n1544         >>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n1545         (z, 2*x*sin(x) + x + y)\n1546 \n1547         -- self is a Mul\n1548 \n1549         >>> (x*sin(x)*cos(y)).as_independent(x)\n1550         (cos(y), x*sin(x))\n1551 \n1552         non-commutative terms cannot always be separated out when self is a Mul\n1553 \n1554         >>> from sympy import symbols\n1555         >>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n1556         >>> (n1 + n1*n2).as_independent(n2)\n1557         (n1, n1*n2)\n1558         >>> (n2*n1 + n1*n2).as_independent(n2)\n1559         (0, n1*n2 + n2*n1)\n1560         >>> (n1*n2*n3).as_independent(n1)\n1561         (1, n1*n2*n3)\n1562         >>> (n1*n2*n3).as_independent(n2)\n1563         (n1, n2*n3)\n1564         >>> ((x-n1)*(x-y)).as_independent(x)\n1565         (1, (x - y)*(x - n1))\n1566 \n1567         -- self is anything else:\n1568 \n1569         >>> (sin(x)).as_independent(x)\n1570         (1, sin(x))\n1571         >>> (sin(x)).as_independent(y)\n1572         (sin(x), 1)\n1573         >>> exp(x+y).as_independent(x)\n1574         (1, exp(x + y))\n1575 \n1576         -- force self to be treated as an Add:\n1577 \n1578         >>> (3*x).as_independent(x, as_Add=True)\n1579         (0, 3*x)\n1580 \n1581         -- force self to be treated as a Mul:\n1582 \n1583         >>> (3+x).as_independent(x, as_Add=False)\n1584         (1, x + 3)\n1585         >>> (-3+x).as_independent(x, as_Add=False)\n1586         (1, x - 3)\n1587 \n1588         Note how the below differs from the above in making the\n1589         constant on the dep term positive.\n1590 \n1591         >>> (y*(-3+x)).as_independent(x)\n1592         (y, x - 3)\n1593 \n1594         -- use .as_independent() for true independence testing instead\n1595            of .has(). The former considers only symbols in the free\n1596            symbols while the latter considers all symbols\n1597 \n1598         >>> from sympy import Integral\n1599         >>> I = Integral(x, (x, 1, 2))\n1600         >>> I.has(x)\n1601         True\n1602         >>> x in I.free_symbols\n1603         False\n1604         >>> I.as_independent(x) == (I, 1)\n1605         True\n1606         >>> (I + x).as_independent(x) == (I, x)\n1607         True\n1608 \n1609         Note: when trying to get independent terms, a separation method\n1610         might need to be used first. In this case, it is important to keep\n1611         track of what you send to this routine so you know how to interpret\n1612         the returned values\n1613 \n1614         >>> from sympy import separatevars, log\n1615         >>> separatevars(exp(x+y)).as_independent(x)\n1616         (exp(y), exp(x))\n1617         >>> (x + x*y).as_independent(y)\n1618         (x, x*y)\n1619         >>> separatevars(x + x*y).as_independent(y)\n1620         (x, y + 1)\n1621         >>> (x*(1 + y)).as_independent(y)\n1622         (x, y + 1)\n1623         >>> (x*(1 + y)).expand(mul=True).as_independent(y)\n1624         (x, x*y)\n1625         >>> a, b=symbols('a b', positive=True)\n1626         >>> (log(a*b).expand(log=True)).as_independent(b)\n1627         (log(a), log(b))\n1628 \n1629         See Also\n1630         ========\n1631         .separatevars(), .expand(log=True), Add.as_two_terms(),\n1632         Mul.as_two_terms(), .as_coeff_add(), .as_coeff_mul()\n1633         \"\"\"\n1634         from .symbol import Symbol\n1635         from .add import _unevaluated_Add\n1636         from .mul import _unevaluated_Mul\n1637         from sympy.utilities.iterables import sift\n1638 \n1639         if self.is_zero:\n1640             return S.Zero, S.Zero\n1641 \n1642         func = self.func\n1643         if hint.get('as_Add', func is Add):\n1644             want = Add\n1645         else:\n1646             want = Mul\n1647 \n1648         # sift out deps into symbolic and other and ignore\n1649         # all symbols but those that are in the free symbols\n1650         sym = set()\n1651         other = []\n1652         for d in deps:\n1653             if isinstance(d, Symbol):  # Symbol.is_Symbol is True\n1654                 sym.add(d)\n1655             else:\n1656                 other.append(d)\n1657 \n1658         def has(e):\n1659             \"\"\"return the standard has() if there are no literal symbols, else\n1660             check to see that symbol-deps are in the free symbols.\"\"\"\n1661             has_other = e.has(*other)\n1662             if not sym:\n1663                 return has_other\n1664             return has_other or e.has(*(e.free_symbols & sym))\n1665 \n1666         if (want is not func or\n1667                 func is not Add and func is not Mul):\n1668             if has(self):\n1669                 return (want.identity, self)\n1670             else:\n1671                 return (self, want.identity)\n1672         else:\n1673             if func is Add:\n1674                 args = list(self.args)\n1675             else:\n1676                 args, nc = self.args_cnc()\n1677 \n1678         d = sift(args, lambda x: has(x))\n1679         depend = d[True]\n1680         indep = d[False]\n1681         if func is Add:  # all terms were treated as commutative\n1682             return (Add(*indep), _unevaluated_Add(*depend))\n1683         else:  # handle noncommutative by stopping at first dependent term\n1684             for i, n in enumerate(nc):\n1685                 if has(n):\n1686                     depend.extend(nc[i:])\n1687                     break\n1688                 indep.append(n)\n1689             return Mul(*indep), (\n1690                 Mul(*depend, evaluate=False) if nc else\n1691                 _unevaluated_Mul(*depend))\n1692 \n1693     def as_real_imag(self, deep=True, **hints):\n1694         \"\"\"Performs complex expansion on 'self' and returns a tuple\n1695            containing collected both real and imaginary parts. This\n1696            method can't be confused with re() and im() functions,\n1697            which does not perform complex expansion at evaluation.\n1698 \n1699            However it is possible to expand both re() and im()\n1700            functions and get exactly the same results as with\n1701            a single call to this function.\n1702 \n1703            >>> from sympy import symbols, I\n1704 \n1705            >>> x, y = symbols('x,y', real=True)\n1706 \n1707            >>> (x + y*I).as_real_imag()\n1708            (x, y)\n1709 \n1710            >>> from sympy.abc import z, w\n1711 \n1712            >>> (z + w*I).as_real_imag()\n1713            (re(z) - im(w), re(w) + im(z))\n1714 \n1715         \"\"\"\n1716         from sympy import im, re\n1717         if hints.get('ignore') == self:\n1718             return None\n1719         else:\n1720             return (re(self), im(self))\n1721 \n1722     def as_powers_dict(self):\n1723         \"\"\"Return self as a dictionary of factors with each factor being\n1724         treated as a power. The keys are the bases of the factors and the\n1725         values, the corresponding exponents. The resulting dictionary should\n1726         be used with caution if the expression is a Mul and contains non-\n1727         commutative factors since the order that they appeared will be lost in\n1728         the dictionary.\"\"\"\n1729         d = defaultdict(int)\n1730         d.update(dict([self.as_base_exp()]))\n1731         return d\n1732 \n1733     def as_coefficients_dict(self):\n1734         \"\"\"Return a dictionary mapping terms to their Rational coefficient.\n1735         Since the dictionary is a defaultdict, inquiries about terms which\n1736         were not present will return a coefficient of 0. If an expression is\n1737         not an Add it is considered to have a single term.\n1738 \n1739         Examples\n1740         ========\n1741 \n1742         >>> from sympy.abc import a, x\n1743         >>> (3*x + a*x + 4).as_coefficients_dict()\n1744         {1: 4, x: 3, a*x: 1}\n1745         >>> _[a]\n1746         0\n1747         >>> (3*a*x).as_coefficients_dict()\n1748         {a*x: 3}\n1749 \n1750         \"\"\"\n1751         c, m = self.as_coeff_Mul()\n1752         if not c.is_Rational:\n1753             c = S.One\n1754             m = self\n1755         d = defaultdict(int)\n1756         d.update({m: c})\n1757         return d\n1758 \n1759     def as_base_exp(self):\n1760         # a -> b ** e\n1761         return self, S.One\n1762 \n1763     def as_coeff_mul(self, *deps, **kwargs):\n1764         \"\"\"Return the tuple (c, args) where self is written as a Mul, ``m``.\n1765 \n1766         c should be a Rational multiplied by any factors of the Mul that are\n1767         independent of deps.\n1768 \n1769         args should be a tuple of all other factors of m; args is empty\n1770         if self is a Number or if self is independent of deps (when given).\n1771 \n1772         This should be used when you don't know if self is a Mul or not but\n1773         you want to treat self as a Mul or if you want to process the\n1774         individual arguments of the tail of self as a Mul.\n1775 \n1776         - if you know self is a Mul and want only the head, use self.args[0];\n1777         - if you don't want to process the arguments of the tail but need the\n1778           tail then use self.as_two_terms() which gives the head and tail;\n1779         - if you want to split self into an independent and dependent parts\n1780           use ``self.as_independent(*deps)``\n1781 \n1782         >>> from sympy import S\n1783         >>> from sympy.abc import x, y\n1784         >>> (S(3)).as_coeff_mul()\n1785         (3, ())\n1786         >>> (3*x*y).as_coeff_mul()\n1787         (3, (x, y))\n1788         >>> (3*x*y).as_coeff_mul(x)\n1789         (3*y, (x,))\n1790         >>> (3*y).as_coeff_mul(x)\n1791         (3*y, ())\n1792         \"\"\"\n1793         if deps:\n1794             if not self.has(*deps):\n1795                 return self, tuple()\n1796         return S.One, (self,)\n1797 \n1798     def as_coeff_add(self, *deps):\n1799         \"\"\"Return the tuple (c, args) where self is written as an Add, ``a``.\n1800 \n1801         c should be a Rational added to any terms of the Add that are\n1802         independent of deps.\n1803 \n1804         args should be a tuple of all other terms of ``a``; args is empty\n1805         if self is a Number or if self is independent of deps (when given).\n1806 \n1807         This should be used when you don't know if self is an Add or not but\n1808         you want to treat self as an Add or if you want to process the\n1809         individual arguments of the tail of self as an Add.\n1810 \n1811         - if you know self is an Add and want only the head, use self.args[0];\n1812         - if you don't want to process the arguments of the tail but need the\n1813           tail then use self.as_two_terms() which gives the head and tail.\n1814         - if you want to split self into an independent and dependent parts\n1815           use ``self.as_independent(*deps)``\n1816 \n1817         >>> from sympy import S\n1818         >>> from sympy.abc import x, y\n1819         >>> (S(3)).as_coeff_add()\n1820         (3, ())\n1821         >>> (3 + x).as_coeff_add()\n1822         (3, (x,))\n1823         >>> (3 + x + y).as_coeff_add(x)\n1824         (y + 3, (x,))\n1825         >>> (3 + y).as_coeff_add(x)\n1826         (y + 3, ())\n1827 \n1828         \"\"\"\n1829         if deps:\n1830             if not self.has(*deps):\n1831                 return self, tuple()\n1832         return S.Zero, (self,)\n1833 \n1834     def primitive(self):\n1835         \"\"\"Return the positive Rational that can be extracted non-recursively\n1836         from every term of self (i.e., self is treated like an Add). This is\n1837         like the as_coeff_Mul() method but primitive always extracts a positive\n1838         Rational (never a negative or a Float).\n1839 \n1840         Examples\n1841         ========\n1842 \n1843         >>> from sympy.abc import x\n1844         >>> (3*(x + 1)**2).primitive()\n1845         (3, (x + 1)**2)\n1846         >>> a = (6*x + 2); a.primitive()\n1847         (2, 3*x + 1)\n1848         >>> b = (x/2 + 3); b.primitive()\n1849         (1/2, x + 6)\n1850         >>> (a*b).primitive() == (1, a*b)\n1851         True\n1852         \"\"\"\n1853         if not self:\n1854             return S.One, S.Zero\n1855         c, r = self.as_coeff_Mul(rational=True)\n1856         if c.is_negative:\n1857             c, r = -c, -r\n1858         return c, r\n1859 \n1860     def as_content_primitive(self, radical=False, clear=True):\n1861         \"\"\"This method should recursively remove a Rational from all arguments\n1862         and return that (content) and the new self (primitive). The content\n1863         should always be positive and ``Mul(*foo.as_content_primitive()) == foo``.\n1864         The primitive need not be in canonical form and should try to preserve\n1865         the underlying structure if possible (i.e. expand_mul should not be\n1866         applied to self).\n1867 \n1868         Examples\n1869         ========\n1870 \n1871         >>> from sympy import sqrt\n1872         >>> from sympy.abc import x, y, z\n1873 \n1874         >>> eq = 2 + 2*x + 2*y*(3 + 3*y)\n1875 \n1876         The as_content_primitive function is recursive and retains structure:\n1877 \n1878         >>> eq.as_content_primitive()\n1879         (2, x + 3*y*(y + 1) + 1)\n1880 \n1881         Integer powers will have Rationals extracted from the base:\n1882 \n1883         >>> ((2 + 6*x)**2).as_content_primitive()\n1884         (4, (3*x + 1)**2)\n1885         >>> ((2 + 6*x)**(2*y)).as_content_primitive()\n1886         (1, (2*(3*x + 1))**(2*y))\n1887 \n1888         Terms may end up joining once their as_content_primitives are added:\n1889 \n1890         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n1891         (11, x*(y + 1))\n1892         >>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n1893         (9, x*(y + 1))\n1894         >>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n1895         (1, 6.0*x*(y + 1) + 3*z*(y + 1))\n1896         >>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n1897         (121, x**2*(y + 1)**2)\n1898         >>> ((5*(x*(1 + y)) + 2.0*x*(3 + 3*y))**2).as_content_primitive()\n1899         (1, 121.0*x**2*(y + 1)**2)\n1900 \n1901         Radical content can also be factored out of the primitive:\n1902 \n1903         >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n1904         (2, sqrt(2)*(1 + 2*sqrt(5)))\n1905 \n1906         If clear=False (default is True) then content will not be removed\n1907         from an Add if it can be distributed to leave one or more\n1908         terms with integer coefficients.\n1909 \n1910         >>> (x/2 + y).as_content_primitive()\n1911         (1/2, x + 2*y)\n1912         >>> (x/2 + y).as_content_primitive(clear=False)\n1913         (1, x/2 + y)\n1914         \"\"\"\n1915         return S.One, self\n1916 \n1917     def as_numer_denom(self):\n1918         \"\"\" expression -> a/b -> a, b\n1919 \n1920         This is just a stub that should be defined by\n1921         an object's class methods to get anything else.\n1922 \n1923         See Also\n1924         ========\n1925         normal: return a/b instead of a, b\n1926         \"\"\"\n1927 \n1928         return self, S.One\n1929 \n1930     def normal(self):\n1931         from .mul import _unevaluated_Mul\n1932         n, d = self.as_numer_denom()\n1933         if d is S.One:\n1934             return n\n1935         if d.is_Number:\n1936             if d is S.One:\n1937                 return n\n1938             else:\n1939                 return _unevaluated_Mul(n, 1/d)\n1940         else:\n1941             return n/d\n1942 \n1943     def extract_multiplicatively(self, c):\n1944         \"\"\"Return None if it's not possible to make self in the form\n1945            c * something in a nice way, i.e. preserving the properties\n1946            of arguments of self.\n1947 \n1948            >>> from sympy import symbols, Rational\n1949 \n1950            >>> x, y = symbols('x,y', real=True)\n1951 \n1952            >>> ((x*y)**3).extract_multiplicatively(x**2 * y)\n1953            x*y**2\n1954 \n1955            >>> ((x*y)**3).extract_multiplicatively(x**4 * y)\n1956 \n1957            >>> (2*x).extract_multiplicatively(2)\n1958            x\n1959 \n1960            >>> (2*x).extract_multiplicatively(3)\n1961 \n1962            >>> (Rational(1, 2)*x).extract_multiplicatively(3)\n1963            x/6\n1964 \n1965         \"\"\"\n1966         from .function import _coeff_isneg\n1967 \n1968         c = sympify(c)\n1969         if self is S.NaN:\n1970             return None\n1971         if c is S.One:\n1972             return self\n1973         elif c == self:\n1974             return S.One\n1975 \n1976         if c.is_Add:\n1977             cc, pc = c.primitive()\n1978             if cc is not S.One:\n1979                 c = Mul(cc, pc, evaluate=False)\n1980 \n1981         if c.is_Mul:\n1982             a, b = c.as_two_terms()\n1983             x = self.extract_multiplicatively(a)\n1984             if x is not None:\n1985                 return x.extract_multiplicatively(b)\n1986 \n1987         quotient = self / c\n1988         if self.is_Number:\n1989             if self is S.Infinity:\n1990                 if c.is_positive:\n1991                     return S.Infinity\n1992             elif self is S.NegativeInfinity:\n1993                 if c.is_negative:\n1994                     return S.Infinity\n1995                 elif c.is_positive:\n1996                     return S.NegativeInfinity\n1997             elif self is S.ComplexInfinity:\n1998                 if not c.is_zero:\n1999                     return S.ComplexInfinity\n2000             elif self.is_Integer:\n2001                 if not quotient.is_Integer:\n2002                     return None\n2003                 elif self.is_positive and quotient.is_negative:\n2004                     return None\n2005                 else:\n2006                     return quotient\n2007             elif self.is_Rational:\n2008                 if not quotient.is_Rational:\n2009                     return None\n2010                 elif self.is_positive and quotient.is_negative:\n2011                     return None\n2012                 else:\n2013                     return quotient\n2014             elif self.is_Float:\n2015                 if not quotient.is_Float:\n2016                     return None\n2017                 elif self.is_positive and quotient.is_negative:\n2018                     return None\n2019                 else:\n2020                     return quotient\n2021         elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n2022             if quotient.is_Mul and len(quotient.args) == 2:\n2023                 if quotient.args[0].is_Integer and quotient.args[0].is_positive and quotient.args[1] == self:\n2024                     return quotient\n2025             elif quotient.is_Integer and c.is_Number:\n2026                 return quotient\n2027         elif self.is_Add:\n2028             cs, ps = self.primitive()\n2029             # assert cs >= 1\n2030             if c.is_Number and c is not S.NegativeOne:\n2031                 # assert c != 1 (handled at top)\n2032                 if cs is not S.One:\n2033                     if c.is_negative:\n2034                         xc = -(cs.extract_multiplicatively(-c))\n2035                     else:\n2036                         xc = cs.extract_multiplicatively(c)\n2037                     if xc is not None:\n2038                         return xc*ps  # rely on 2-arg Mul to restore Add\n2039                 return  # |c| != 1 can only be extracted from cs\n2040             if c == ps:\n2041                 return cs\n2042             # check args of ps\n2043             newargs = []\n2044             for arg in ps.args:\n2045                 newarg = arg.extract_multiplicatively(c)\n2046                 if newarg is None:\n2047                     return  # all or nothing\n2048                 newargs.append(newarg)\n2049             # args should be in same order so use unevaluated return\n2050             if cs is not S.One:\n2051                 return Add._from_args([cs*t for t in newargs])\n2052             else:\n2053                 return Add._from_args(newargs)\n2054         elif self.is_Mul:\n2055             args = list(self.args)\n2056             for i, arg in enumerate(args):\n2057                 newarg = arg.extract_multiplicatively(c)\n2058                 if newarg is not None:\n2059                     args[i] = newarg\n2060                     return Mul(*args)\n2061         elif self.is_Pow:\n2062             if c.is_Pow and c.base == self.base:\n2063                 new_exp = self.exp.extract_additively(c.exp)\n2064                 if new_exp is not None:\n2065                     return self.base ** (new_exp)\n2066             elif c == self.base:\n2067                 new_exp = self.exp.extract_additively(1)\n2068                 if new_exp is not None:\n2069                     return self.base ** (new_exp)\n2070 \n2071     def extract_additively(self, c):\n2072         \"\"\"Return self - c if it's possible to subtract c from self and\n2073         make all matching coefficients move towards zero, else return None.\n2074 \n2075         Examples\n2076         ========\n2077 \n2078         >>> from sympy.abc import x, y\n2079         >>> e = 2*x + 3\n2080         >>> e.extract_additively(x + 1)\n2081         x + 2\n2082         >>> e.extract_additively(3*x)\n2083         >>> e.extract_additively(4)\n2084         >>> (y*(x + 1)).extract_additively(x + 1)\n2085         >>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)\n2086         (x + 1)*(x + 2*y) + 3\n2087 \n2088         Sometimes auto-expansion will return a less simplified result\n2089         than desired; gcd_terms might be used in such cases:\n2090 \n2091         >>> from sympy import gcd_terms\n2092         >>> (4*x*(y + 1) + y).extract_additively(x)\n2093         4*x*(y + 1) + x*(4*y + 3) - x*(4*y + 4) + y\n2094         >>> gcd_terms(_)\n2095         x*(4*y + 3) + y\n2096 \n2097         See Also\n2098         ========\n2099         extract_multiplicatively\n2100         coeff\n2101         as_coefficient\n2102 \n2103         \"\"\"\n2104 \n2105         c = sympify(c)\n2106         if self is S.NaN:\n2107             return None\n2108         if c is S.Zero:\n2109             return self\n2110         elif c == self:\n2111             return S.Zero\n2112         elif self is S.Zero:\n2113             return None\n2114 \n2115         if self.is_Number:\n2116             if not c.is_Number:\n2117                 return None\n2118             co = self\n2119             diff = co - c\n2120             # XXX should we match types? i.e should 3 - .1 succeed?\n2121             if (co > 0 and diff > 0 and diff < co or\n2122                     co < 0 and diff < 0 and diff > co):\n2123                 return diff\n2124             return None\n2125 \n2126         if c.is_Number:\n2127             co, t = self.as_coeff_Add()\n2128             xa = co.extract_additively(c)\n2129             if xa is None:\n2130                 return None\n2131             return xa + t\n2132 \n2133         # handle the args[0].is_Number case separately\n2134         # since we will have trouble looking for the coeff of\n2135         # a number.\n2136         if c.is_Add and c.args[0].is_Number:\n2137             # whole term as a term factor\n2138             co = self.coeff(c)\n2139             xa0 = (co.extract_additively(1) or 0)*c\n2140             if xa0:\n2141                 diff = self - co*c\n2142                 return (xa0 + (diff.extract_additively(c) or diff)) or None\n2143             # term-wise\n2144             h, t = c.as_coeff_Add()\n2145             sh, st = self.as_coeff_Add()\n2146             xa = sh.extract_additively(h)\n2147             if xa is None:\n2148                 return None\n2149             xa2 = st.extract_additively(t)\n2150             if xa2 is None:\n2151                 return None\n2152             return xa + xa2\n2153 \n2154         # whole term as a term factor\n2155         co = self.coeff(c)\n2156         xa0 = (co.extract_additively(1) or 0)*c\n2157         if xa0:\n2158             diff = self - co*c\n2159             return (xa0 + (diff.extract_additively(c) or diff)) or None\n2160         # term-wise\n2161         coeffs = []\n2162         for a in Add.make_args(c):\n2163             ac, at = a.as_coeff_Mul()\n2164             co = self.coeff(at)\n2165             if not co:\n2166                 return None\n2167             coc, cot = co.as_coeff_Add()\n2168             xa = coc.extract_additively(ac)\n2169             if xa is None:\n2170                 return None\n2171             self -= co*at\n2172             coeffs.append((cot + xa)*at)\n2173         coeffs.append(self)\n2174         return Add(*coeffs)\n2175 \n2176     def could_extract_minus_sign(self):\n2177         \"\"\"Return True if self is not in a canonical form with respect\n2178         to its sign.\n2179 \n2180         For most expressions, e, there will be a difference in e and -e.\n2181         When there is, True will be returned for one and False for the\n2182         other; False will be returned if there is no difference.\n2183 \n2184         Examples\n2185         ========\n2186 \n2187         >>> from sympy.abc import x, y\n2188         >>> e = x - y\n2189         >>> {i.could_extract_minus_sign() for i in (e, -e)}\n2190         {False, True}\n2191 \n2192         \"\"\"\n2193         negative_self = -self\n2194         if self == negative_self:\n2195             return False  # e.g. zoo*x == -zoo*x\n2196         self_has_minus = (self.extract_multiplicatively(-1) is not None)\n2197         negative_self_has_minus = (\n2198             (negative_self).extract_multiplicatively(-1) is not None)\n2199         if self_has_minus != negative_self_has_minus:\n2200             return self_has_minus\n2201         else:\n2202             if self.is_Add:\n2203                 # We choose the one with less arguments with minus signs\n2204                 all_args = len(self.args)\n2205                 negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])\n2206                 positive_args = all_args - negative_args\n2207                 if positive_args > negative_args:\n2208                     return False\n2209                 elif positive_args < negative_args:\n2210                     return True\n2211             elif self.is_Mul:\n2212                 # We choose the one with an odd number of minus signs\n2213                 num, den = self.as_numer_denom()\n2214                 args = Mul.make_args(num) + Mul.make_args(den)\n2215                 arg_signs = [arg.could_extract_minus_sign() for arg in args]\n2216                 negative_args = list(filter(None, arg_signs))\n2217                 return len(negative_args) % 2 == 1\n2218 \n2219             # As a last resort, we choose the one with greater value of .sort_key()\n2220             return bool(self.sort_key() < negative_self.sort_key())\n2221 \n2222     def extract_branch_factor(self, allow_half=False):\n2223         \"\"\"\n2224         Try to write self as ``exp_polar(2*pi*I*n)*z`` in a nice way.\n2225         Return (z, n).\n2226 \n2227         >>> from sympy import exp_polar, I, pi\n2228         >>> from sympy.abc import x, y\n2229         >>> exp_polar(I*pi).extract_branch_factor()\n2230         (exp_polar(I*pi), 0)\n2231         >>> exp_polar(2*I*pi).extract_branch_factor()\n2232         (1, 1)\n2233         >>> exp_polar(-pi*I).extract_branch_factor()\n2234         (exp_polar(I*pi), -1)\n2235         >>> exp_polar(3*pi*I + x).extract_branch_factor()\n2236         (exp_polar(x + I*pi), 1)\n2237         >>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()\n2238         (y*exp_polar(2*pi*x), -1)\n2239         >>> exp_polar(-I*pi/2).extract_branch_factor()\n2240         (exp_polar(-I*pi/2), 0)\n2241 \n2242         If allow_half is True, also extract exp_polar(I*pi):\n2243 \n2244         >>> exp_polar(I*pi).extract_branch_factor(allow_half=True)\n2245         (1, 1/2)\n2246         >>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)\n2247         (1, 1)\n2248         >>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)\n2249         (1, 3/2)\n2250         >>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)\n2251         (1, -1/2)\n2252         \"\"\"\n2253         from sympy import exp_polar, pi, I, ceiling, Add\n2254         n = S(0)\n2255         res = S(1)\n2256         args = Mul.make_args(self)\n2257         exps = []\n2258         for arg in args:\n2259             if arg.func is exp_polar:\n2260                 exps += [arg.exp]\n2261             else:\n2262                 res *= arg\n2263         piimult = S(0)\n2264         extras = []\n2265         while exps:\n2266             exp = exps.pop()\n2267             if exp.is_Add:\n2268                 exps += exp.args\n2269                 continue\n2270             if exp.is_Mul:\n2271                 coeff = exp.as_coefficient(pi*I)\n2272                 if coeff is not None:\n2273                     piimult += coeff\n2274                     continue\n2275             extras += [exp]\n2276         if not piimult.free_symbols:\n2277             coeff = piimult\n2278             tail = ()\n2279         else:\n2280             coeff, tail = piimult.as_coeff_add(*piimult.free_symbols)\n2281         # round down to nearest multiple of 2\n2282         branchfact = ceiling(coeff/2 - S(1)/2)*2\n2283         n += branchfact/2\n2284         c = coeff - branchfact\n2285         if allow_half:\n2286             nc = c.extract_additively(1)\n2287             if nc is not None:\n2288                 n += S(1)/2\n2289                 c = nc\n2290         newexp = pi*I*Add(*((c, ) + tail)) + Add(*extras)\n2291         if newexp != 0:\n2292             res *= exp_polar(newexp)\n2293         return res, n\n2294 \n2295     def _eval_is_polynomial(self, syms):\n2296         if self.free_symbols.intersection(syms) == set([]):\n2297             return True\n2298         return False\n2299 \n2300     def is_polynomial(self, *syms):\n2301         r\"\"\"\n2302         Return True if self is a polynomial in syms and False otherwise.\n2303 \n2304         This checks if self is an exact polynomial in syms.  This function\n2305         returns False for expressions that are \"polynomials\" with symbolic\n2306         exponents.  Thus, you should be able to apply polynomial algorithms to\n2307         expressions for which this returns True, and Poly(expr, \\*syms) should\n2308         work if and only if expr.is_polynomial(\\*syms) returns True. The\n2309         polynomial does not have to be in expanded form.  If no symbols are\n2310         given, all free symbols in the expression will be used.\n2311 \n2312         This is not part of the assumptions system.  You cannot do\n2313         Symbol('z', polynomial=True).\n2314 \n2315         Examples\n2316         ========\n2317 \n2318         >>> from sympy import Symbol\n2319         >>> x = Symbol('x')\n2320         >>> ((x**2 + 1)**4).is_polynomial(x)\n2321         True\n2322         >>> ((x**2 + 1)**4).is_polynomial()\n2323         True\n2324         >>> (2**x + 1).is_polynomial(x)\n2325         False\n2326 \n2327 \n2328         >>> n = Symbol('n', nonnegative=True, integer=True)\n2329         >>> (x**n + 1).is_polynomial(x)\n2330         False\n2331 \n2332         This function does not attempt any nontrivial simplifications that may\n2333         result in an expression that does not appear to be a polynomial to\n2334         become one.\n2335 \n2336         >>> from sympy import sqrt, factor, cancel\n2337         >>> y = Symbol('y', positive=True)\n2338         >>> a = sqrt(y**2 + 2*y + 1)\n2339         >>> a.is_polynomial(y)\n2340         False\n2341         >>> factor(a)\n2342         y + 1\n2343         >>> factor(a).is_polynomial(y)\n2344         True\n2345 \n2346         >>> b = (y**2 + 2*y + 1)/(y + 1)\n2347         >>> b.is_polynomial(y)\n2348         False\n2349         >>> cancel(b)\n2350         y + 1\n2351         >>> cancel(b).is_polynomial(y)\n2352         True\n2353 \n2354         See also .is_rational_function()\n2355 \n2356         \"\"\"\n2357         if syms:\n2358             syms = set(map(sympify, syms))\n2359         else:\n2360             syms = self.free_symbols\n2361 \n2362         if syms.intersection(self.free_symbols) == set([]):\n2363             # constant polynomial\n2364             return True\n2365         else:\n2366             return self._eval_is_polynomial(syms)\n2367 \n2368     def _eval_is_rational_function(self, syms):\n2369         if self.free_symbols.intersection(syms) == set([]):\n2370             return True\n2371         return False\n2372 \n2373     def is_rational_function(self, *syms):\n2374         \"\"\"\n2375         Test whether function is a ratio of two polynomials in the given\n2376         symbols, syms. When syms is not given, all free symbols will be used.\n2377         The rational function does not have to be in expanded or in any kind of\n2378         canonical form.\n2379 \n2380         This function returns False for expressions that are \"rational\n2381         functions\" with symbolic exponents.  Thus, you should be able to call\n2382         .as_numer_denom() and apply polynomial algorithms to the result for\n2383         expressions for which this returns True.\n2384 \n2385         This is not part of the assumptions system.  You cannot do\n2386         Symbol('z', rational_function=True).\n2387 \n2388         Examples\n2389         ========\n2390 \n2391         >>> from sympy import Symbol, sin\n2392         >>> from sympy.abc import x, y\n2393 \n2394         >>> (x/y).is_rational_function()\n2395         True\n2396 \n2397         >>> (x**2).is_rational_function()\n2398         True\n2399 \n2400         >>> (x/sin(y)).is_rational_function(y)\n2401         False\n2402 \n2403         >>> n = Symbol('n', integer=True)\n2404         >>> (x**n + 1).is_rational_function(x)\n2405         False\n2406 \n2407         This function does not attempt any nontrivial simplifications that may\n2408         result in an expression that does not appear to be a rational function\n2409         to become one.\n2410 \n2411         >>> from sympy import sqrt, factor\n2412         >>> y = Symbol('y', positive=True)\n2413         >>> a = sqrt(y**2 + 2*y + 1)/y\n2414         >>> a.is_rational_function(y)\n2415         False\n2416         >>> factor(a)\n2417         (y + 1)/y\n2418         >>> factor(a).is_rational_function(y)\n2419         True\n2420 \n2421         See also is_algebraic_expr().\n2422 \n2423         \"\"\"\n2424         if self in [S.NaN, S.Infinity, -S.Infinity, S.ComplexInfinity]:\n2425             return False\n2426 \n2427         if syms:\n2428             syms = set(map(sympify, syms))\n2429         else:\n2430             syms = self.free_symbols\n2431 \n2432         if syms.intersection(self.free_symbols) == set([]):\n2433             # constant rational function\n2434             return True\n2435         else:\n2436             return self._eval_is_rational_function(syms)\n2437 \n2438     def _eval_is_algebraic_expr(self, syms):\n2439         if self.free_symbols.intersection(syms) == set([]):\n2440             return True\n2441         return False\n2442 \n2443     def is_algebraic_expr(self, *syms):\n2444         \"\"\"\n2445         This tests whether a given expression is algebraic or not, in the\n2446         given symbols, syms. When syms is not given, all free symbols\n2447         will be used. The rational function does not have to be in expanded\n2448         or in any kind of canonical form.\n2449 \n2450         This function returns False for expressions that are \"algebraic\n2451         expressions\" with symbolic exponents. This is a simple extension to the\n2452         is_rational_function, including rational exponentiation.\n2453 \n2454         Examples\n2455         ========\n2456 \n2457         >>> from sympy import Symbol, sqrt\n2458         >>> x = Symbol('x', real=True)\n2459         >>> sqrt(1 + x).is_rational_function()\n2460         False\n2461         >>> sqrt(1 + x).is_algebraic_expr()\n2462         True\n2463 \n2464         This function does not attempt any nontrivial simplifications that may\n2465         result in an expression that does not appear to be an algebraic\n2466         expression to become one.\n2467 \n2468         >>> from sympy import exp, factor\n2469         >>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)\n2470         >>> a.is_algebraic_expr(x)\n2471         False\n2472         >>> factor(a).is_algebraic_expr()\n2473         True\n2474 \n2475         See Also\n2476         ========\n2477         is_rational_function()\n2478 \n2479         References\n2480         ==========\n2481 \n2482         - http://en.wikipedia.org/wiki/Algebraic_expression\n2483 \n2484         \"\"\"\n2485         if syms:\n2486             syms = set(map(sympify, syms))\n2487         else:\n2488             syms = self.free_symbols\n2489 \n2490         if syms.intersection(self.free_symbols) == set([]):\n2491             # constant algebraic expression\n2492             return True\n2493         else:\n2494             return self._eval_is_algebraic_expr(syms)\n2495 \n2496     ###################################################################################\n2497     ##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################\n2498     ###################################################################################\n2499 \n2500     def series(self, x=None, x0=0, n=6, dir=\"+\", logx=None):\n2501         \"\"\"\n2502         Series expansion of \"self\" around ``x = x0`` yielding either terms of\n2503         the series one by one (the lazy series given when n=None), else\n2504         all the terms at once when n != None.\n2505 \n2506         Returns the series expansion of \"self\" around the point ``x = x0``\n2507         with respect to ``x`` up to ``O((x - x0)**n, x, x0)`` (default n is 6).\n2508 \n2509         If ``x=None`` and ``self`` is univariate, the univariate symbol will\n2510         be supplied, otherwise an error will be raised.\n2511 \n2512         >>> from sympy import cos, exp\n2513         >>> from sympy.abc import x, y\n2514         >>> cos(x).series()\n2515         1 - x**2/2 + x**4/24 + O(x**6)\n2516         >>> cos(x).series(n=4)\n2517         1 - x**2/2 + O(x**4)\n2518         >>> cos(x).series(x, x0=1, n=2)\n2519         cos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))\n2520         >>> e = cos(x + exp(y))\n2521         >>> e.series(y, n=2)\n2522         cos(x + 1) - y*sin(x + 1) + O(y**2)\n2523         >>> e.series(x, n=2)\n2524         cos(exp(y)) - x*sin(exp(y)) + O(x**2)\n2525 \n2526         If ``n=None`` then a generator of the series terms will be returned.\n2527 \n2528         >>> term=cos(x).series(n=None)\n2529         >>> [next(term) for i in range(2)]\n2530         [1, -x**2/2]\n2531 \n2532         For ``dir=+`` (default) the series is calculated from the right and\n2533         for ``dir=-`` the series from the left. For smooth functions this\n2534         flag will not alter the results.\n2535 \n2536         >>> abs(x).series(dir=\"+\")\n2537         x\n2538         >>> abs(x).series(dir=\"-\")\n2539         -x\n2540 \n2541         \"\"\"\n2542         from sympy import collect, Dummy, Order, Rational, Symbol\n2543         if x is None:\n2544             syms = self.atoms(Symbol)\n2545             if not syms:\n2546                 return self\n2547             elif len(syms) > 1:\n2548                 raise ValueError('x must be given for multivariate functions.')\n2549             x = syms.pop()\n2550 \n2551         if not self.has(x):\n2552             if n is None:\n2553                 return (s for s in [self])\n2554             else:\n2555                 return self\n2556 \n2557         if len(dir) != 1 or dir not in '+-':\n2558             raise ValueError(\"Dir must be '+' or '-'\")\n2559 \n2560         if x0 in [S.Infinity, S.NegativeInfinity]:\n2561             dir = {S.Infinity: '+', S.NegativeInfinity: '-'}[x0]\n2562             s = self.subs(x, 1/x).series(x, n=n, dir=dir)\n2563             if n is None:\n2564                 return (si.subs(x, 1/x) for si in s)\n2565             return s.subs(x, 1/x)\n2566 \n2567         # use rep to shift origin to x0 and change sign (if dir is negative)\n2568         # and undo the process with rep2\n2569         if x0 or dir == '-':\n2570             if dir == '-':\n2571                 rep = -x + x0\n2572                 rep2 = -x\n2573                 rep2b = x0\n2574             else:\n2575                 rep = x + x0\n2576                 rep2 = x\n2577                 rep2b = -x0\n2578             s = self.subs(x, rep).series(x, x0=0, n=n, dir='+', logx=logx)\n2579             if n is None:  # lseries...\n2580                 return (si.subs(x, rep2 + rep2b) for si in s)\n2581             return s.subs(x, rep2 + rep2b)\n2582 \n2583         # from here on it's x0=0 and dir='+' handling\n2584 \n2585         if x.is_positive is x.is_negative is None or x.is_Symbol is not True:\n2586             # replace x with an x that has a positive assumption\n2587             xpos = Dummy('x', positive=True, finite=True)\n2588             rv = self.subs(x, xpos).series(xpos, x0, n, dir, logx=logx)\n2589             if n is None:\n2590                 return (s.subs(xpos, x) for s in rv)\n2591             else:\n2592                 return rv.subs(xpos, x)\n2593 \n2594         if n is not None:  # nseries handling\n2595             s1 = self._eval_nseries(x, n=n, logx=logx)\n2596             o = s1.getO() or S.Zero\n2597             if o:\n2598                 # make sure the requested order is returned\n2599                 ngot = o.getn()\n2600                 if ngot > n:\n2601                     # leave o in its current form (e.g. with x*log(x)) so\n2602                     # it eats terms properly, then replace it below\n2603                     if n != 0:\n2604                         s1 += o.subs(x, x**Rational(n, ngot))\n2605                     else:\n2606                         s1 += Order(1, x)\n2607                 elif ngot < n:\n2608                     # increase the requested number of terms to get the desired\n2609                     # number keep increasing (up to 9) until the received order\n2610                     # is different than the original order and then predict how\n2611                     # many additional terms are needed\n2612                     for more in range(1, 9):\n2613                         s1 = self._eval_nseries(x, n=n + more, logx=logx)\n2614                         newn = s1.getn()\n2615                         if newn != ngot:\n2616                             ndo = n + (n - ngot)*more/(newn - ngot)\n2617                             s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2618                             while s1.getn() < n:\n2619                                 s1 = self._eval_nseries(x, n=ndo, logx=logx)\n2620                                 ndo += 1\n2621                             break\n2622                     else:\n2623                         raise ValueError('Could not calculate %s terms for %s'\n2624                                          % (str(n), self))\n2625                     s1 += Order(x**n, x)\n2626                 o = s1.getO()\n2627                 s1 = s1.removeO()\n2628             else:\n2629                 o = Order(x**n, x)\n2630                 s1done = s1.doit()\n2631                 if (s1done + o).removeO() == s1done:\n2632                     o = S.Zero\n2633 \n2634             try:\n2635                 return collect(s1, x) + o\n2636             except NotImplementedError:\n2637                 return s1 + o\n2638 \n2639         else:  # lseries handling\n2640             def yield_lseries(s):\n2641                 \"\"\"Return terms of lseries one at a time.\"\"\"\n2642                 for si in s:\n2643                     if not si.is_Add:\n2644                         yield si\n2645                         continue\n2646                     # yield terms 1 at a time if possible\n2647                     # by increasing order until all the\n2648                     # terms have been returned\n2649                     yielded = 0\n2650                     o = Order(si, x)*x\n2651                     ndid = 0\n2652                     ndo = len(si.args)\n2653                     while 1:\n2654                         do = (si - yielded + o).removeO()\n2655                         o *= x\n2656                         if not do or do.is_Order:\n2657                             continue\n2658                         if do.is_Add:\n2659                             ndid += len(do.args)\n2660                         else:\n2661                             ndid += 1\n2662                         yield do\n2663                         if ndid == ndo:\n2664                             break\n2665                         yielded += do\n2666 \n2667             return yield_lseries(self.removeO()._eval_lseries(x, logx=logx))\n2668 \n2669     def taylor_term(self, n, x, *previous_terms):\n2670         \"\"\"General method for the taylor term.\n2671 \n2672         This method is slow, because it differentiates n-times. Subclasses can\n2673         redefine it to make it faster by using the \"previous_terms\".\n2674         \"\"\"\n2675         from sympy import Dummy, factorial\n2676         x = sympify(x)\n2677         _x = Dummy('x')\n2678         return self.subs(x, _x).diff(_x, n).subs(_x, x).subs(x, 0) * x**n / factorial(n)\n2679 \n2680     def lseries(self, x=None, x0=0, dir='+', logx=None):\n2681         \"\"\"\n2682         Wrapper for series yielding an iterator of the terms of the series.\n2683 \n2684         Note: an infinite series will yield an infinite iterator. The following,\n2685         for exaxmple, will never terminate. It will just keep printing terms\n2686         of the sin(x) series::\n2687 \n2688           for term in sin(x).lseries(x):\n2689               print term\n2690 \n2691         The advantage of lseries() over nseries() is that many times you are\n2692         just interested in the next term in the series (i.e. the first term for\n2693         example), but you don't know how many you should ask for in nseries()\n2694         using the \"n\" parameter.\n2695 \n2696         See also nseries().\n2697         \"\"\"\n2698         return self.series(x, x0, n=None, dir=dir, logx=logx)\n2699 \n2700     def _eval_lseries(self, x, logx=None):\n2701         # default implementation of lseries is using nseries(), and adaptively\n2702         # increasing the \"n\". As you can see, it is not very efficient, because\n2703         # we are calculating the series over and over again. Subclasses should\n2704         # override this method and implement much more efficient yielding of\n2705         # terms.\n2706         n = 0\n2707         series = self._eval_nseries(x, n=n, logx=logx)\n2708         if not series.is_Order:\n2709             if series.is_Add:\n2710                 yield series.removeO()\n2711             else:\n2712                 yield series\n2713             return\n2714 \n2715         while series.is_Order:\n2716             n += 1\n2717             series = self._eval_nseries(x, n=n, logx=logx)\n2718         e = series.removeO()\n2719         yield e\n2720         while 1:\n2721             while 1:\n2722                 n += 1\n2723                 series = self._eval_nseries(x, n=n, logx=logx).removeO()\n2724                 if e != series:\n2725                     break\n2726             yield series - e\n2727             e = series\n2728 \n2729     def nseries(self, x=None, x0=0, n=6, dir='+', logx=None):\n2730         \"\"\"\n2731         Wrapper to _eval_nseries if assumptions allow, else to series.\n2732 \n2733         If x is given, x0 is 0, dir='+', and self has x, then _eval_nseries is\n2734         called. This calculates \"n\" terms in the innermost expressions and\n2735         then builds up the final series just by \"cross-multiplying\" everything\n2736         out.\n2737 \n2738         The optional ``logx`` parameter can be used to replace any log(x) in the\n2739         returned series with a symbolic value to avoid evaluating log(x) at 0. A\n2740         symbol to use in place of log(x) should be provided.\n2741 \n2742         Advantage -- it's fast, because we don't have to determine how many\n2743         terms we need to calculate in advance.\n2744 \n2745         Disadvantage -- you may end up with less terms than you may have\n2746         expected, but the O(x**n) term appended will always be correct and\n2747         so the result, though perhaps shorter, will also be correct.\n2748 \n2749         If any of those assumptions is not met, this is treated like a\n2750         wrapper to series which will try harder to return the correct\n2751         number of terms.\n2752 \n2753         See also lseries().\n2754 \n2755         Examples\n2756         ========\n2757 \n2758         >>> from sympy import sin, log, Symbol\n2759         >>> from sympy.abc import x, y\n2760         >>> sin(x).nseries(x, 0, 6)\n2761         x - x**3/6 + x**5/120 + O(x**6)\n2762         >>> log(x+1).nseries(x, 0, 5)\n2763         x - x**2/2 + x**3/3 - x**4/4 + O(x**5)\n2764 \n2765         Handling of the ``logx`` parameter --- in the following example the\n2766         expansion fails since ``sin`` does not have an asymptotic expansion\n2767         at -oo (the limit of log(x) as x approaches 0):\n2768 \n2769         >>> e = sin(log(x))\n2770         >>> e.nseries(x, 0, 6)\n2771         Traceback (most recent call last):\n2772         ...\n2773         PoleError: ...\n2774         ...\n2775         >>> logx = Symbol('logx')\n2776         >>> e.nseries(x, 0, 6, logx=logx)\n2777         sin(logx)\n2778 \n2779         In the following example, the expansion works but gives only an Order term\n2780         unless the ``logx`` parameter is used:\n2781 \n2782         >>> e = x**y\n2783         >>> e.nseries(x, 0, 2)\n2784         O(log(x)**2)\n2785         >>> e.nseries(x, 0, 2, logx=logx)\n2786         exp(logx*y)\n2787 \n2788         \"\"\"\n2789         if x and not x in self.free_symbols:\n2790             return self\n2791         if x is None or x0 or dir != '+':  # {see XPOS above} or (x.is_positive == x.is_negative == None):\n2792             return self.series(x, x0, n, dir)\n2793         else:\n2794             return self._eval_nseries(x, n=n, logx=logx)\n2795 \n2796     def _eval_nseries(self, x, n, logx):\n2797         \"\"\"\n2798         Return terms of series for self up to O(x**n) at x=0\n2799         from the positive direction.\n2800 \n2801         This is a method that should be overridden in subclasses. Users should\n2802         never call this method directly (use .nseries() instead), so you don't\n2803         have to write docstrings for _eval_nseries().\n2804         \"\"\"\n2805         from sympy.utilities.misc import filldedent\n2806         raise NotImplementedError(filldedent(\"\"\"\n2807                      The _eval_nseries method should be added to\n2808                      %s to give terms up to O(x**n) at x=0\n2809                      from the positive direction so it is available when\n2810                      nseries calls it.\"\"\" % self.func)\n2811                      )\n2812 \n2813     def limit(self, x, xlim, dir='+'):\n2814         \"\"\" Compute limit x->xlim.\n2815         \"\"\"\n2816         from sympy.series.limits import limit\n2817         return limit(self, x, xlim, dir)\n2818 \n2819     def compute_leading_term(self, x, logx=None):\n2820         \"\"\"\n2821         as_leading_term is only allowed for results of .series()\n2822         This is a wrapper to compute a series first.\n2823         \"\"\"\n2824         from sympy import Dummy, log\n2825         from sympy.series.gruntz import calculate_series\n2826 \n2827         if self.removeO() == 0:\n2828             return self\n2829 \n2830         if logx is None:\n2831             d = Dummy('logx')\n2832             s = calculate_series(self, x, d).subs(d, log(x))\n2833         else:\n2834             s = calculate_series(self, x, logx)\n2835 \n2836         return s.as_leading_term(x)\n2837 \n2838     @cacheit\n2839     def as_leading_term(self, *symbols):\n2840         \"\"\"\n2841         Returns the leading (nonzero) term of the series expansion of self.\n2842 \n2843         The _eval_as_leading_term routines are used to do this, and they must\n2844         always return a non-zero value.\n2845 \n2846         Examples\n2847         ========\n2848 \n2849         >>> from sympy.abc import x\n2850         >>> (1 + x + x**2).as_leading_term(x)\n2851         1\n2852         >>> (1/x**2 + x + x**2).as_leading_term(x)\n2853         x**(-2)\n2854 \n2855         \"\"\"\n2856         from sympy import powsimp\n2857         if len(symbols) > 1:\n2858             c = self\n2859             for x in symbols:\n2860                 c = c.as_leading_term(x)\n2861             return c\n2862         elif not symbols:\n2863             return self\n2864         x = sympify(symbols[0])\n2865         if not x.is_Symbol:\n2866             raise ValueError('expecting a Symbol but got %s' % x)\n2867         if x not in self.free_symbols:\n2868             return self\n2869         obj = self._eval_as_leading_term(x)\n2870         if obj is not None:\n2871             return powsimp(obj, deep=True, combine='exp')\n2872         raise NotImplementedError('as_leading_term(%s, %s)' % (self, x))\n2873 \n2874     def _eval_as_leading_term(self, x):\n2875         return self\n2876 \n2877     def as_coeff_exponent(self, x):\n2878         \"\"\" ``c*x**e -> c,e`` where x can be any symbolic expression.\n2879         \"\"\"\n2880         from sympy import collect\n2881         s = collect(self, x)\n2882         c, p = s.as_coeff_mul(x)\n2883         if len(p) == 1:\n2884             b, e = p[0].as_base_exp()\n2885             if b == x:\n2886                 return c, e\n2887         return s, S.Zero\n2888 \n2889     def leadterm(self, x):\n2890         \"\"\"\n2891         Returns the leading term a*x**b as a tuple (a, b).\n2892 \n2893         Examples\n2894         ========\n2895 \n2896         >>> from sympy.abc import x\n2897         >>> (1+x+x**2).leadterm(x)\n2898         (1, 0)\n2899         >>> (1/x**2+x+x**2).leadterm(x)\n2900         (1, -2)\n2901 \n2902         \"\"\"\n2903         from sympy import Dummy, log\n2904         l = self.as_leading_term(x)\n2905         d = Dummy('logx')\n2906         if l.has(log(x)):\n2907             l = l.subs(log(x), d)\n2908         c, e = l.as_coeff_exponent(x)\n2909         if x in c.free_symbols:\n2910             from sympy.utilities.misc import filldedent\n2911             raise ValueError(filldedent(\"\"\"\n2912                 cannot compute leadterm(%s, %s). The coefficient\n2913                 should have been free of x but got %s\"\"\" % (self, x, c)))\n2914         c = c.subs(d, log(x))\n2915         return c, e\n2916 \n2917     def as_coeff_Mul(self, rational=False):\n2918         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n2919         return S.One, self\n2920 \n2921     def as_coeff_Add(self, rational=False):\n2922         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2923         return S.Zero, self\n2924 \n2925     def fps(self, x=None, x0=0, dir=1, hyper=True, order=4, rational=True,\n2926             full=False):\n2927         \"\"\"\n2928         Compute formal power power series of self.\n2929 \n2930         See the docstring of the :func:`fps` function in sympy.series.formal for\n2931         more information.\n2932         \"\"\"\n2933         from sympy.series.formal import fps\n2934 \n2935         return fps(self, x, x0, dir, hyper, order, rational, full)\n2936 \n2937     def fourier_series(self, limits=None):\n2938         \"\"\"Compute fourier sine/cosine series of self.\n2939 \n2940         See the docstring of the :func:`fourier_series` in sympy.series.fourier\n2941         for more information.\n2942         \"\"\"\n2943         from sympy.series.fourier import fourier_series\n2944 \n2945         return fourier_series(self, limits)\n2946 \n2947     ###################################################################################\n2948     ##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################\n2949     ###################################################################################\n2950 \n2951     def diff(self, *symbols, **assumptions):\n2952         new_symbols = list(map(sympify, symbols))  # e.g. x, 2, y, z\n2953         assumptions.setdefault(\"evaluate\", True)\n2954         return Derivative(self, *new_symbols, **assumptions)\n2955 \n2956     ###########################################################################\n2957     ###################### EXPRESSION EXPANSION METHODS #######################\n2958     ###########################################################################\n2959 \n2960     # Relevant subclasses should override _eval_expand_hint() methods.  See\n2961     # the docstring of expand() for more info.\n2962 \n2963     def _eval_expand_complex(self, **hints):\n2964         real, imag = self.as_real_imag(**hints)\n2965         return real + S.ImaginaryUnit*imag\n2966 \n2967     @staticmethod\n2968     def _expand_hint(expr, hint, deep=True, **hints):\n2969         \"\"\"\n2970         Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.\n2971 \n2972         Returns ``(expr, hit)``, where expr is the (possibly) expanded\n2973         ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and\n2974         ``False`` otherwise.\n2975         \"\"\"\n2976         hit = False\n2977         # XXX: Hack to support non-Basic args\n2978         #              |\n2979         #              V\n2980         if deep and getattr(expr, 'args', ()) and not expr.is_Atom:\n2981             sargs = []\n2982             for arg in expr.args:\n2983                 arg, arghit = Expr._expand_hint(arg, hint, **hints)\n2984                 hit |= arghit\n2985                 sargs.append(arg)\n2986 \n2987             if hit:\n2988                 expr = expr.func(*sargs)\n2989 \n2990         if hasattr(expr, hint):\n2991             newexpr = getattr(expr, hint)(**hints)\n2992             if newexpr != expr:\n2993                 return (newexpr, True)\n2994 \n2995         return (expr, hit)\n2996 \n2997     @cacheit\n2998     def expand(self, deep=True, modulus=None, power_base=True, power_exp=True,\n2999             mul=True, log=True, multinomial=True, basic=True, **hints):\n3000         \"\"\"\n3001         Expand an expression using hints.\n3002 \n3003         See the docstring of the expand() function in sympy.core.function for\n3004         more information.\n3005 \n3006         \"\"\"\n3007         from sympy.simplify.radsimp import fraction\n3008 \n3009         hints.update(power_base=power_base, power_exp=power_exp, mul=mul,\n3010            log=log, multinomial=multinomial, basic=basic)\n3011 \n3012         expr = self\n3013         if hints.pop('frac', False):\n3014             n, d = [a.expand(deep=deep, modulus=modulus, **hints)\n3015                     for a in fraction(self)]\n3016             return n/d\n3017         elif hints.pop('denom', False):\n3018             n, d = fraction(self)\n3019             return n/d.expand(deep=deep, modulus=modulus, **hints)\n3020         elif hints.pop('numer', False):\n3021             n, d = fraction(self)\n3022             return n.expand(deep=deep, modulus=modulus, **hints)/d\n3023 \n3024         # Although the hints are sorted here, an earlier hint may get applied\n3025         # at a given node in the expression tree before another because of how\n3026         # the hints are applied.  e.g. expand(log(x*(y + z))) -> log(x*y +\n3027         # x*z) because while applying log at the top level, log and mul are\n3028         # applied at the deeper level in the tree so that when the log at the\n3029         # upper level gets applied, the mul has already been applied at the\n3030         # lower level.\n3031 \n3032         # Additionally, because hints are only applied once, the expression\n3033         # may not be expanded all the way.   For example, if mul is applied\n3034         # before multinomial, x*(x + 1)**2 won't be expanded all the way.  For\n3035         # now, we just use a special case to make multinomial run before mul,\n3036         # so that at least polynomials will be expanded all the way.  In the\n3037         # future, smarter heuristics should be applied.\n3038         # TODO: Smarter heuristics\n3039 \n3040         def _expand_hint_key(hint):\n3041             \"\"\"Make multinomial come before mul\"\"\"\n3042             if hint == 'mul':\n3043                 return 'mulz'\n3044             return hint\n3045 \n3046         for hint in sorted(hints.keys(), key=_expand_hint_key):\n3047             use_hint = hints[hint]\n3048             if use_hint:\n3049                 hint = '_eval_expand_' + hint\n3050                 expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n3051 \n3052         while True:\n3053             was = expr\n3054             if hints.get('multinomial', False):\n3055                 expr, _ = Expr._expand_hint(\n3056                     expr, '_eval_expand_multinomial', deep=deep, **hints)\n3057             if hints.get('mul', False):\n3058                 expr, _ = Expr._expand_hint(\n3059                     expr, '_eval_expand_mul', deep=deep, **hints)\n3060             if hints.get('log', False):\n3061                 expr, _ = Expr._expand_hint(\n3062                     expr, '_eval_expand_log', deep=deep, **hints)\n3063             if expr == was:\n3064                 break\n3065 \n3066         if modulus is not None:\n3067             modulus = sympify(modulus)\n3068 \n3069             if not modulus.is_Integer or modulus <= 0:\n3070                 raise ValueError(\n3071                     \"modulus must be a positive integer, got %s\" % modulus)\n3072 \n3073             terms = []\n3074 \n3075             for term in Add.make_args(expr):\n3076                 coeff, tail = term.as_coeff_Mul(rational=True)\n3077 \n3078                 coeff %= modulus\n3079 \n3080                 if coeff:\n3081                     terms.append(coeff*tail)\n3082 \n3083             expr = Add(*terms)\n3084 \n3085         return expr\n3086 \n3087     ###########################################################################\n3088     ################### GLOBAL ACTION VERB WRAPPER METHODS ####################\n3089     ###########################################################################\n3090 \n3091     def integrate(self, *args, **kwargs):\n3092         \"\"\"See the integrate function in sympy.integrals\"\"\"\n3093         from sympy.integrals import integrate\n3094         return integrate(self, *args, **kwargs)\n3095 \n3096     def simplify(self, ratio=1.7, measure=None):\n3097         \"\"\"See the simplify function in sympy.simplify\"\"\"\n3098         from sympy.simplify import simplify\n3099         from sympy.core.function import count_ops\n3100         measure = measure or count_ops\n3101         return simplify(self, ratio, measure)\n3102 \n3103     def nsimplify(self, constants=[], tolerance=None, full=False):\n3104         \"\"\"See the nsimplify function in sympy.simplify\"\"\"\n3105         from sympy.simplify import nsimplify\n3106         return nsimplify(self, constants, tolerance, full)\n3107 \n3108     def separate(self, deep=False, force=False):\n3109         \"\"\"See the separate function in sympy.simplify\"\"\"\n3110         from sympy.core.function import expand_power_base\n3111         return expand_power_base(self, deep=deep, force=force)\n3112 \n3113     def collect(self, syms, func=None, evaluate=True, exact=False, distribute_order_term=True):\n3114         \"\"\"See the collect function in sympy.simplify\"\"\"\n3115         from sympy.simplify import collect\n3116         return collect(self, syms, func, evaluate, exact, distribute_order_term)\n3117 \n3118     def together(self, *args, **kwargs):\n3119         \"\"\"See the together function in sympy.polys\"\"\"\n3120         from sympy.polys import together\n3121         return together(self, *args, **kwargs)\n3122 \n3123     def apart(self, x=None, **args):\n3124         \"\"\"See the apart function in sympy.polys\"\"\"\n3125         from sympy.polys import apart\n3126         return apart(self, x, **args)\n3127 \n3128     def ratsimp(self):\n3129         \"\"\"See the ratsimp function in sympy.simplify\"\"\"\n3130         from sympy.simplify import ratsimp\n3131         return ratsimp(self)\n3132 \n3133     def trigsimp(self, **args):\n3134         \"\"\"See the trigsimp function in sympy.simplify\"\"\"\n3135         from sympy.simplify import trigsimp\n3136         return trigsimp(self, **args)\n3137 \n3138     def radsimp(self, **kwargs):\n3139         \"\"\"See the radsimp function in sympy.simplify\"\"\"\n3140         from sympy.simplify import radsimp\n3141         return radsimp(self, **kwargs)\n3142 \n3143     def powsimp(self, *args, **kwargs):\n3144         \"\"\"See the powsimp function in sympy.simplify\"\"\"\n3145         from sympy.simplify import powsimp\n3146         return powsimp(self, *args, **kwargs)\n3147 \n3148     def combsimp(self):\n3149         \"\"\"See the combsimp function in sympy.simplify\"\"\"\n3150         from sympy.simplify import combsimp\n3151         return combsimp(self)\n3152 \n3153     def gammasimp(self):\n3154         \"\"\"See the gammasimp function in sympy.simplify\"\"\"\n3155         from sympy.simplify import gammasimp\n3156         return gammasimp(self)\n3157 \n3158     def factor(self, *gens, **args):\n3159         \"\"\"See the factor() function in sympy.polys.polytools\"\"\"\n3160         from sympy.polys import factor\n3161         return factor(self, *gens, **args)\n3162 \n3163     def refine(self, assumption=True):\n3164         \"\"\"See the refine function in sympy.assumptions\"\"\"\n3165         from sympy.assumptions import refine\n3166         return refine(self, assumption)\n3167 \n3168     def cancel(self, *gens, **args):\n3169         \"\"\"See the cancel function in sympy.polys\"\"\"\n3170         from sympy.polys import cancel\n3171         return cancel(self, *gens, **args)\n3172 \n3173     def invert(self, g, *gens, **args):\n3174         \"\"\"Return the multiplicative inverse of ``self`` mod ``g``\n3175         where ``self`` (and ``g``) may be symbolic expressions).\n3176 \n3177         See Also\n3178         ========\n3179         sympy.core.numbers.mod_inverse, sympy.polys.polytools.invert\n3180         \"\"\"\n3181         from sympy.polys.polytools import invert\n3182         from sympy.core.numbers import mod_inverse\n3183         if self.is_number and getattr(g, 'is_number', True):\n3184             return mod_inverse(self, g)\n3185         return invert(self, g, *gens, **args)\n3186 \n3187     def round(self, p=0):\n3188         \"\"\"Return x rounded to the given decimal place.\n3189 \n3190         If a complex number would results, apply round to the real\n3191         and imaginary components of the number.\n3192 \n3193         Examples\n3194         ========\n3195 \n3196         >>> from sympy import pi, E, I, S, Add, Mul, Number\n3197         >>> S(10.5).round()\n3198         11.\n3199         >>> pi.round()\n3200         3.\n3201         >>> pi.round(2)\n3202         3.14\n3203         >>> (2*pi + E*I).round()\n3204         6. + 3.*I\n3205 \n3206         The round method has a chopping effect:\n3207 \n3208         >>> (2*pi + I/10).round()\n3209         6.\n3210         >>> (pi/10 + 2*I).round()\n3211         2.*I\n3212         >>> (pi/10 + E*I).round(2)\n3213         0.31 + 2.72*I\n3214 \n3215         Notes\n3216         =====\n3217 \n3218         Do not confuse the Python builtin function, round, with the\n3219         SymPy method of the same name. The former always returns a float\n3220         (or raises an error if applied to a complex value) while the\n3221         latter returns either a Number or a complex number:\n3222 \n3223         >>> isinstance(round(S(123), -2), Number)\n3224         False\n3225         >>> isinstance(S(123).round(-2), Number)\n3226         True\n3227         >>> isinstance((3*I).round(), Mul)\n3228         True\n3229         >>> isinstance((1 + 3*I).round(), Add)\n3230         True\n3231 \n3232         \"\"\"\n3233         from sympy import Float\n3234         x = self\n3235         if not x.is_number:\n3236             raise TypeError(\"can't round symbolic expression\")\n3237         if not x.is_Atom:\n3238             xn = x.n(2)\n3239             if not pure_complex(xn, or_real=True):\n3240                 raise TypeError('Expected a number but got %s:' %\n3241                     getattr(getattr(x,'func', x), '__name__', type(x)))\n3242         elif x in (S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity):\n3243             return x\n3244         if not x.is_real:\n3245             i, r = x.as_real_imag()\n3246             return i.round(p) + S.ImaginaryUnit*r.round(p)\n3247         if not x:\n3248             return x\n3249         p = int(p)\n3250 \n3251         precs = [f._prec for f in x.atoms(Float)]\n3252         dps = prec_to_dps(max(precs)) if precs else None\n3253 \n3254         mag_first_dig = _mag(x)\n3255         allow = digits_needed = mag_first_dig + p\n3256         if dps is not None and allow > dps:\n3257             allow = dps\n3258         mag = Pow(10, p)  # magnitude needed to bring digit p to units place\n3259         xwas = x\n3260         x += 1/(2*mag)  # add the half for rounding\n3261         i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)\n3262         if i10.is_negative:\n3263             x = xwas - 1/(2*mag)  # should have gone the other way\n3264             i10 = 10*mag*x.n((dps if dps is not None else digits_needed) + 1)\n3265             rv = -(Integer(-i10)//10)\n3266         else:\n3267             rv = Integer(i10)//10\n3268         q = 1\n3269         if p > 0:\n3270             q = mag\n3271         elif p < 0:\n3272             rv /= mag\n3273         rv = Rational(rv, q)\n3274         if rv.is_Integer:\n3275             # use str or else it won't be a float\n3276             return Float(str(rv), digits_needed)\n3277         else:\n3278             if not allow and rv > self:\n3279                 allow += 1\n3280             return Float(rv, allow)\n3281 \n3282 \n3283 class AtomicExpr(Atom, Expr):\n3284     \"\"\"\n3285     A parent class for object which are both atoms and Exprs.\n3286 \n3287     For example: Symbol, Number, Rational, Integer, ...\n3288     But not: Add, Mul, Pow, ...\n3289     \"\"\"\n3290     is_number = False\n3291     is_Atom = True\n3292 \n3293     __slots__ = []\n3294 \n3295     def _eval_derivative(self, s):\n3296         if self == s:\n3297             return S.One\n3298         return S.Zero\n3299 \n3300     def _eval_is_polynomial(self, syms):\n3301         return True\n3302 \n3303     def _eval_is_rational_function(self, syms):\n3304         return True\n3305 \n3306     def _eval_is_algebraic_expr(self, syms):\n3307         return True\n3308 \n3309     def _eval_nseries(self, x, n, logx):\n3310         return self\n3311 \n3312 \n3313 def _mag(x):\n3314     \"\"\"Return integer ``i`` such that .1 <= x/10**i < 1\n3315 \n3316     Examples\n3317     ========\n3318 \n3319     >>> from sympy.core.expr import _mag\n3320     >>> from sympy import Float\n3321     >>> _mag(Float(.1))\n3322     0\n3323     >>> _mag(Float(.01))\n3324     -1\n3325     >>> _mag(Float(1234))\n3326     4\n3327     \"\"\"\n3328     from math import log10, ceil, log\n3329     from sympy import Float\n3330     xpos = abs(x.n())\n3331     if not xpos:\n3332         return S.Zero\n3333     try:\n3334         mag_first_dig = int(ceil(log10(xpos)))\n3335     except (ValueError, OverflowError):\n3336         mag_first_dig = int(ceil(Float(mpf_log(xpos._mpf_, 53))/log(10)))\n3337     # check that we aren't off by 1\n3338     if (xpos/10**mag_first_dig) >= 1:\n3339         assert 1 <= (xpos/10**mag_first_dig) < 10\n3340         mag_first_dig += 1\n3341     return mag_first_dig\n3342 \n3343 \n3344 class UnevaluatedExpr(Expr):\n3345     \"\"\"\n3346     Expression that is not evaluated unless released.\n3347 \n3348     Examples\n3349     ========\n3350 \n3351     >>> from sympy import UnevaluatedExpr\n3352     >>> from sympy.abc import a, b, x, y\n3353     >>> x*(1/x)\n3354     1\n3355     >>> x*UnevaluatedExpr(1/x)\n3356     x*1/x\n3357 \n3358     \"\"\"\n3359 \n3360     def __new__(cls, arg, **kwargs):\n3361         arg = _sympify(arg)\n3362         obj = Expr.__new__(cls, arg, **kwargs)\n3363         return obj\n3364 \n3365     def doit(self, *args, **kwargs):\n3366         if kwargs.get(\"deep\", True):\n3367             return self.args[0].doit(*args, **kwargs)\n3368         else:\n3369             return self.args[0]\n3370 \n3371 \n3372 def _n2(a, b):\n3373     \"\"\"Return (a - b).evalf(2) if it, a and b are comparable, else None.\n3374     This should only be used when a and b are already sympified.\n3375     \"\"\"\n3376     if not all(i.is_number for i in (a, b)):\n3377         return\n3378     # /!\\ if is very important (see issue 8245) not to\n3379     # use a re-evaluated number in the calculation of dif\n3380     if a.is_comparable and b.is_comparable:\n3381         dif = (a - b).evalf(2)\n3382         if dif.is_comparable:\n3383             return dif\n3384 \n3385 \n3386 from .mul import Mul\n3387 from .add import Add\n3388 from .power import Pow\n3389 from .function import Derivative, Function\n3390 from .mod import Mod\n3391 from .exprtools import factor_terms\n3392 from .numbers import Integer, Rational\n",
        "intended_behavior": "Given that `expr.py` likely handles the expression tree at a more fundamental level, any simplification logic here that pertains to trigonometric functions should ensure that operations involving complex numbers are accurately represented within the symbolic manipulation. If `simplify` methods within this file contribute to the incorrect simplification behavior as described, they would need to accurately maintain the distinction between operations that should result in trigonometric conversions among `cos` and `cosh` with the correct handling of complex arguments. This may involve either fixing the rules used for such conversions or ensuring that the existing rules are applied correctly in the context of complex numbers."
    }
]