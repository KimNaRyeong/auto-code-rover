2025-10-17 11:11:28.653 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 11:11:31.799 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=652, output_tokens=12, cost=0.006880
2025-10-17 11:11:50.238 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=832, output_tokens=749, cost=0.030790
2025-10-17 11:11:51.509 | INFO     | registered non reproducing test 0
2025-10-17 11:12:04.545 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2600, output_tokens=605, cost=0.044150
2025-10-17 11:12:05.521 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:12:15.359 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=952, output_tokens=416, cost=0.022000
2025-10-17 11:12:15.368 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:12:19.203 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=770, output_tokens=75, cost=0.009950
2025-10-17 11:12:19.204 | DEBUG    | Extracted a valid json.
2025-10-17 11:12:19.204 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Account\")",
        "search_class(\"Address\")",
        "search_class(\"Profile\")",
        "search_code(\"db_collation='utf8_bin'\")",
        "search_method(\"makemigrations\")",
        "search_code(\"ShortUUIDField\")"
    ],
    "bug_locations": []
}
2025-10-17 11:12:19.263 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 11:12:19.264 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 11:12:35.900 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1609, output_tokens=651, cost=0.035620
2025-10-17 11:12:35.907 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:12:45.357 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2476, output_tokens=409, cost=0.037030
2025-10-17 11:12:45.363 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:12:52.108 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=763, output_tokens=243, cost=0.014920
2025-10-17 11:12:52.110 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 11:12:52.110 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 11:12:58.128 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=763, output_tokens=199, cost=0.013600
2025-10-17 11:12:58.129 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 11:12:58.129 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 11:13:07.788 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=763, output_tokens=243, cost=0.014920
2025-10-17 11:13:07.789 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 11:13:07.789 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 11:13:15.616 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=763, output_tokens=243, cost=0.014920
2025-10-17 11:13:15.617 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 11:13:15.617 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 11:13:21.778 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=763, output_tokens=235, cost=0.014680
2025-10-17 11:13:21.779 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 11:13:21.779 | DEBUG    | Agent proxy return the following json: None
2025-10-17 11:13:21.780 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 11:13:21.781 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 11:13:21.781 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:13:29.081 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2912, output_tokens=268, cost=0.037160
2025-10-17 11:13:29.086 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:13:33.842 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=622, output_tokens=185, cost=0.011770
2025-10-17 11:13:33.843 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 11:13:33.843 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 11:13:39.563 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=622, output_tokens=148, cost=0.010660
2025-10-17 11:13:39.564 | DEBUG    | Extracted a valid json.
2025-10-17 11:13:39.565 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "",
            "class": "Account",
            "method": "",
            "intended_behavior": "Review model definitions for db_collation settings and ensure integrity and consistency during migrations."
        },
        {
            "file": "",
            "class": "Address",
            "method": "",
            "intended_behavior": "Review model definitions for db_collation settings and ensure integrity and consistency during migrations."
        },
        {
            "file": "",
            "class": "Profile",
            "method": "",
            "intended_behavior": "Review model definitions for db_collation settings and ensure integrity and consistency during migrations."
        }
    ]
}
2025-10-17 11:13:39.568 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-17 11:13:39.569 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 11:13:39.569 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:13:50.788 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3214, output_tokens=422, cost=0.044800
2025-10-17 11:13:50.796 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:13:54.312 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=776, output_tokens=52, cost=0.009320
2025-10-17 11:13:54.313 | DEBUG    | Extracted a valid json.
2025-10-17 11:13:54.314 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"models.Model\")",
        "search_code(\"models.ForeignKey\")",
        "search_code(\"class Meta\")",
        "search_code(\"DATABASES\")"
    ],
    "bug_locations": []
}
2025-10-17 11:13:54.529 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 11:13:54.530 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 11:14:14.528 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5160, output_tokens=800, cost=0.075600
2025-10-17 11:14:14.536 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:14:29.195 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6176, output_tokens=548, cost=0.078200
2025-10-17 11:14:29.204 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:14:38.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=902, output_tokens=388, cost=0.020660
2025-10-17 11:14:38.307 | DEBUG    | Extracted a valid json.
2025-10-17 11:14:38.308 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/related.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify the definition of ForeignKey fields (and related fields) to respect or optionally inherit `db_collation` from the referenced primary key field. This could involve adjusting the field's creation or alteration logic within Django's migration framework to include collation settings explicitly where necessary."
        },
        {
            "file": "django/db/migrations/operations/models.py",
            "class": "",
            "method": "",
            "intended_behavior": "Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key."
        },
        {
            "file": "django/db/migrations/state.py",
            "class": "",
            "method": "",
            "intended_behavior": "Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key."
        },
        {
            "file": "settings.py or models.py",
            "class": "",
            "method": "",
            "intended_behavior": "Although not a direct cause of the issue, ensuring that global settings for database connections, especially for MySQL, include prudent defaults for collation that are compatible with the application's requirements. Providing documentation or utility functions to facilitate proper `db_collation` settings during project setup could mitigate related issues."
        }
    ]
}
2025-10-17 11:14:38.324 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name = related_name % {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_filter = (
411             (rh_field.attname, getattr(obj, lh_field.attname))
412             for lh_field, rh_field in self.related_fields
413         )
414         descriptor_filter = self.get_extra_descriptor_filter(obj)
415         base_q = Q(*base_filter)
416         if isinstance(descriptor_filter, dict):
417             return base_q & Q(**descriptor_filter)
418         elif descriptor_filter:
419             return base_q & descriptor_filter
420         return base_q
421 
422     @property
423     def swappable_setting(self):
424         """
425         Get the setting that this is powered from for swapping, or None
426         if it's not swapped in / marked with swappable=False.
427         """
428         if self.swappable:
429             # Work out string form of "to"
430             if isinstance(self.remote_field.model, str):
431                 to_string = self.remote_field.model
432             else:
433                 to_string = self.remote_field.model._meta.label
434             return apps.get_swappable_settings_name(to_string)
435         return None
436 
437     def set_attributes_from_rel(self):
438         self.name = self.name or (
439             self.remote_field.model._meta.model_name
440             + "_"
441             + self.remote_field.model._meta.pk.name
442         )
443         if self.verbose_name is None:
444             self.verbose_name = self.remote_field.model._meta.verbose_name
445         self.remote_field.set_field_name()
446 
447     def do_related_class(self, other, cls):
448         self.set_attributes_from_rel()
449         self.contribute_to_related_class(other, self.remote_field)
450 
451     def get_limit_choices_to(self):
452         """
453         Return ``limit_choices_to`` for this model field.
454 
455         If it is a callable, it will be invoked and the result will be
456         returned.
457         """
458         if callable(self.remote_field.limit_choices_to):
459             return self.remote_field.limit_choices_to()
460         return self.remote_field.limit_choices_to
461 
462     def formfield(self, **kwargs):
463         """
464         Pass ``limit_choices_to`` to the field being constructed.
465 
466         Only passes it if there is a type that supports related fields.
467         This is a similar strategy used to pass the ``queryset`` to the field
468         being constructed.
469         """
470         defaults = {}
471         if hasattr(self.remote_field, "get_related_field"):
472             # If this is a callable, do not invoke it here. Just pass
473             # it in the defaults for when the form class will later be
474             # instantiated.
475             limit_choices_to = self.remote_field.limit_choices_to
476             defaults.update(
477                 {
478                     "limit_choices_to": limit_choices_to,
479                 }
480             )
481         defaults.update(kwargs)
482         return super().formfield(**defaults)
483 
484     def related_query_name(self):
485         """
486         Define the name that can be used to identify this related object in a
487         table-spanning query.
488         """
489         return (
490             self.remote_field.related_query_name
491             or self.remote_field.related_name
492             or self.opts.model_name
493         )
494 
495     @property
496     def target_field(self):
497         """
498         When filtering against this relation, return the field on the remote
499         model against which the filtering should happen.
500         """
501         target_fields = self.path_infos[-1].target_fields
502         if len(target_fields) > 1:
503             raise exceptions.FieldError(
504                 "The relation has multiple target fields, but only single target field "
505                 "was asked for"
506             )
507         return target_fields[0]
508 
509     def get_cache_name(self):
510         return self.name
511 
512 
513 class ForeignObject(RelatedField):
514     """
515     Abstraction of the ForeignKey relation to support multi-column relations.
516     """
517 
518     # Field flags
519     many_to_many = False
520     many_to_one = True
521     one_to_many = False
522     one_to_one = False
523 
524     requires_unique_target = True
525     related_accessor_class = ReverseManyToOneDescriptor
526     forward_related_accessor_class = ForwardManyToOneDescriptor
527     rel_class = ForeignObjectRel
528 
529     def __init__(
530         self,
531         to,
532         on_delete,
533         from_fields,
534         to_fields,
535         rel=None,
536         related_name=None,
537         related_query_name=None,
538         limit_choices_to=None,
539         parent_link=False,
540         swappable=True,
541         **kwargs,
542     ):
543 
544         if rel is None:
545             rel = self.rel_class(
546                 self,
547                 to,
548                 related_name=related_name,
549                 related_query_name=related_query_name,
550                 limit_choices_to=limit_choices_to,
551                 parent_link=parent_link,
552                 on_delete=on_delete,
553             )
554 
555         super().__init__(
556             rel=rel,
557             related_name=related_name,
558             related_query_name=related_query_name,
559             limit_choices_to=limit_choices_to,
560             **kwargs,
561         )
562 
563         self.from_fields = from_fields
564         self.to_fields = to_fields
565         self.swappable = swappable
566 
567     def __copy__(self):
568         obj = super().__copy__()
569         # Remove any cached PathInfo values.
570         obj.__dict__.pop("path_infos", None)
571         obj.__dict__.pop("reverse_path_infos", None)
572         return obj
573 
574     def check(self, **kwargs):
575         return [
576             *super().check(**kwargs),
577             *self._check_to_fields_exist(),
578             *self._check_unique_target(),
579         ]
580 
581     def _check_to_fields_exist(self):
582         # Skip nonexistent models.
583         if isinstance(self.remote_field.model, str):
584             return []
585 
586         errors = []
587         for to_field in self.to_fields:
588             if to_field:
589                 try:
590                     self.remote_field.model._meta.get_field(to_field)
591                 except exceptions.FieldDoesNotExist:
592                     errors.append(
593                         checks.Error(
594                             "The to_field '%s' doesn't exist on the related "
595                             "model '%s'."
596                             % (to_field, self.remote_field.model._meta.label),
597                             obj=self,
598                             id="fields.E312",
599                         )
600                     )
601         return errors
602 
603     def _check_unique_target(self):
604         rel_is_string = isinstance(self.remote_field.model, str)
605         if rel_is_string or not self.requires_unique_target:
606             return []
607 
608         try:
609             self.foreign_related_fields
610         except exceptions.FieldDoesNotExist:
611             return []
612 
613         if not self.foreign_related_fields:
614             return []
615 
616         unique_foreign_fields = {
617             frozenset([f.name])
618             for f in self.remote_field.model._meta.get_fields()
619             if getattr(f, "unique", False)
620         }
621         unique_foreign_fields.update(
622             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
623         )
624         unique_foreign_fields.update(
625             {
626                 frozenset(uc.fields)
627                 for uc in self.remote_field.model._meta.total_unique_constraints
628             }
629         )
630         foreign_fields = {f.name for f in self.foreign_related_fields}
631         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
632 
633         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
634             field_combination = ", ".join(
635                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
636             )
637             model_name = self.remote_field.model.__name__
638             return [
639                 checks.Error(
640                     "No subset of the fields %s on model '%s' is unique."
641                     % (field_combination, model_name),
642                     hint=(
643                         "Mark a single field as unique=True or add a set of "
644                         "fields to a unique constraint (via unique_together "
645                         "or a UniqueConstraint (without condition) in the "
646                         "model Meta.constraints)."
647                     ),
648                     obj=self,
649                     id="fields.E310",
650                 )
651             ]
652         elif not has_unique_constraint:
653             field_name = self.foreign_related_fields[0].name
654             model_name = self.remote_field.model.__name__
655             return [
656                 checks.Error(
657                     "'%s.%s' must be unique because it is referenced by "
658                     "a foreign key." % (model_name, field_name),
659                     hint=(
660                         "Add unique=True to this field or add a "
661                         "UniqueConstraint (without condition) in the model "
662                         "Meta.constraints."
663                     ),
664                     obj=self,
665                     id="fields.E311",
666                 )
667             ]
668         else:
669             return []
670 
671     def deconstruct(self):
672         name, path, args, kwargs = super().deconstruct()
673         kwargs["on_delete"] = self.remote_field.on_delete
674         kwargs["from_fields"] = self.from_fields
675         kwargs["to_fields"] = self.to_fields
676 
677         if self.remote_field.parent_link:
678             kwargs["parent_link"] = self.remote_field.parent_link
679         if isinstance(self.remote_field.model, str):
680             if "." in self.remote_field.model:
681                 app_label, model_name = self.remote_field.model.split(".")
682                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
683             else:
684                 kwargs["to"] = self.remote_field.model.lower()
685         else:
686             kwargs["to"] = self.remote_field.model._meta.label_lower
687         # If swappable is True, then see if we're actually pointing to the target
688         # of a swap.
689         swappable_setting = self.swappable_setting
690         if swappable_setting is not None:
691             # If it's already a settings reference, error
692             if hasattr(kwargs["to"], "setting_name"):
693                 if kwargs["to"].setting_name != swappable_setting:
694                     raise ValueError(
695                         "Cannot deconstruct a ForeignKey pointing to a model "
696                         "that is swapped in place of more than one model (%s and %s)"
697                         % (kwargs["to"].setting_name, swappable_setting)
698                     )
699             # Set it
700             kwargs["to"] = SettingsReference(
701                 kwargs["to"],
702                 swappable_setting,
703             )
704         return name, path, args, kwargs
705 
706     def resolve_related_fields(self):
707         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
708             raise ValueError(
709                 "Foreign Object from and to fields must be the same non-zero length"
710             )
711         if isinstance(self.remote_field.model, str):
712             raise ValueError(
713                 "Related model %r cannot be resolved" % self.remote_field.model
714             )
715         related_fields = []
716         for index in range(len(self.from_fields)):
717             from_field_name = self.from_fields[index]
718             to_field_name = self.to_fields[index]
719             from_field = (
720                 self
721                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
722                 else self.opts.get_field(from_field_name)
723             )
724             to_field = (
725                 self.remote_field.model._meta.pk
726                 if to_field_name is None
727                 else self.remote_field.model._meta.get_field(to_field_name)
728             )
729             related_fields.append((from_field, to_field))
730         return related_fields
731 
732     @cached_property
733     def related_fields(self):
734         return self.resolve_related_fields()
735 
736     @cached_property
737     def reverse_related_fields(self):
738         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
739 
740     @cached_property
741     def local_related_fields(self):
742         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
743 
744     @cached_property
745     def foreign_related_fields(self):
746         return tuple(
747             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
748         )
749 
750     def get_local_related_value(self, instance):
751         return self.get_instance_value_for_fields(instance, self.local_related_fields)
752 
753     def get_foreign_related_value(self, instance):
754         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
755 
756     @staticmethod
757     def get_instance_value_for_fields(instance, fields):
758         ret = []
759         opts = instance._meta
760         for field in fields:
761             # Gotcha: in some cases (like fixture loading) a model can have
762             # different values in parent_ptr_id and parent's id. So, use
763             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
764             if field.primary_key:
765                 possible_parent_link = opts.get_ancestor_link(field.model)
766                 if (
767                     not possible_parent_link
768                     or possible_parent_link.primary_key
769                     or possible_parent_link.model._meta.abstract
770                 ):
771                     ret.append(instance.pk)
772                     continue
773             ret.append(getattr(instance, field.attname))
774         return tuple(ret)
775 
776     def get_attname_column(self):
777         attname, column = super().get_attname_column()
778         return attname, None
779 
780     def get_joining_columns(self, reverse_join=False):
781         source = self.reverse_related_fields if reverse_join else self.related_fields
782         return tuple(
783             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
784         )
785 
786     def get_reverse_joining_columns(self):
787         return self.get_joining_columns(reverse_join=True)
788 
789     def get_extra_descriptor_filter(self, instance):
790         """
791         Return an extra filter condition for related object fetching when
792         user does 'instance.fieldname', that is the extra filter is used in
793         the descriptor of the field.
794 
795         The filter should be either a dict usable in .filter(**kwargs) call or
796         a Q-object. The condition will be ANDed together with the relation's
797         joining columns.
798 
799         A parallel method is get_extra_restriction() which is used in
800         JOIN and subquery conditions.
801         """
802         return {}
803 
804     def get_extra_restriction(self, alias, related_alias):
805         """
806         Return a pair condition used for joining and subquery pushdown. The
807         condition is something that responds to as_sql(compiler, connection)
808         method.
809 
810         Note that currently referring both the 'alias' and 'related_alias'
811         will not work in some conditions, like subquery pushdown.
812 
813         A parallel method is get_extra_descriptor_filter() which is used in
814         instance.fieldname related object fetching.
815         """
816         return None
817 
818     def get_path_info(self, filtered_relation=None):
819         """Get path from this field to the related model."""
820         opts = self.remote_field.model._meta
821         from_opts = self.model._meta
822         return [
823             PathInfo(
824                 from_opts=from_opts,
825                 to_opts=opts,
826                 target_fields=self.foreign_related_fields,
827                 join_field=self,
828                 m2m=False,
829                 direct=True,
830                 filtered_relation=filtered_relation,
831             )
832         ]
833 
834     @cached_property
835     def path_infos(self):
836         return self.get_path_info()
837 
838     def get_reverse_path_info(self, filtered_relation=None):
839         """Get path from the related model to this field's model."""
840         opts = self.model._meta
841         from_opts = self.remote_field.model._meta
842         return [
843             PathInfo(
844                 from_opts=from_opts,
845                 to_opts=opts,
846                 target_fields=(opts.pk,),
847                 join_field=self.remote_field,
848                 m2m=not self.unique,
849                 direct=False,
850                 filtered_relation=filtered_relation,
851             )
852         ]
853 
854     @cached_property
855     def reverse_path_infos(self):
856         return self.get_reverse_path_info()
857 
858     @classmethod
859     @functools.lru_cache(maxsize=None)
860     def get_lookups(cls):
861         bases = inspect.getmro(cls)
862         bases = bases[: bases.index(ForeignObject) + 1]
863         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
864         return cls.merge_dicts(class_lookups)
865 
866     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
867         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
868         setattr(cls, self.name, self.forward_related_accessor_class(self))
869 
870     def contribute_to_related_class(self, cls, related):
871         # Internal FK's - i.e., those with a related name ending with '+' -
872         # and swapped models don't get a related descriptor.
873         if (
874             not self.remote_field.is_hidden()
875             and not related.related_model._meta.swapped
876         ):
877             setattr(
878                 cls._meta.concrete_model,
879                 related.get_accessor_name(),
880                 self.related_accessor_class(related),
881             )
882             # While 'limit_choices_to' might be a callable, simply pass
883             # it along for later - this is too early because it's still
884             # model load time.
885             if self.remote_field.limit_choices_to:
886                 cls._meta.related_fkey_lookups.append(
887                     self.remote_field.limit_choices_to
888                 )
889 
890 
891 ForeignObject.register_lookup(RelatedIn)
892 ForeignObject.register_lookup(RelatedExact)
893 ForeignObject.register_lookup(RelatedLessThan)
894 ForeignObject.register_lookup(RelatedGreaterThan)
895 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
896 ForeignObject.register_lookup(RelatedLessThanOrEqual)
897 ForeignObject.register_lookup(RelatedIsNull)
898 
899 
900 class ForeignKey(ForeignObject):
901     """
902     Provide a many-to-one relation by adding a column to the local model
903     to hold the remote value.
904 
905     By default ForeignKey will target the pk of the remote model but this
906     behavior can be changed by using the ``to_field`` argument.
907     """
908 
909     descriptor_class = ForeignKeyDeferredAttribute
910     # Field flags
911     many_to_many = False
912     many_to_one = True
913     one_to_many = False
914     one_to_one = False
915 
916     rel_class = ManyToOneRel
917 
918     empty_strings_allowed = False
919     default_error_messages = {
920         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
921     }
922     description = _("Foreign Key (type determined by related field)")
923 
924     def __init__(
925         self,
926         to,
927         on_delete,
928         related_name=None,
929         related_query_name=None,
930         limit_choices_to=None,
931         parent_link=False,
932         to_field=None,
933         db_constraint=True,
934         **kwargs,
935     ):
936         try:
937             to._meta.model_name
938         except AttributeError:
939             if not isinstance(to, str):
940                 raise TypeError(
941                     "%s(%r) is invalid. First parameter to ForeignKey must be "
942                     "either a model, a model name, or the string %r"
943                     % (
944                         self.__class__.__name__,
945                         to,
946                         RECURSIVE_RELATIONSHIP_CONSTANT,
947                     )
948                 )
949         else:
950             # For backwards compatibility purposes, we need to *try* and set
951             # the to_field during FK construction. It won't be guaranteed to
952             # be correct until contribute_to_class is called. Refs #12190.
953             to_field = to_field or (to._meta.pk and to._meta.pk.name)
954         if not callable(on_delete):
955             raise TypeError("on_delete must be callable.")
956 
957         kwargs["rel"] = self.rel_class(
958             self,
959             to,
960             to_field,
961             related_name=related_name,
962             related_query_name=related_query_name,
963             limit_choices_to=limit_choices_to,
964             parent_link=parent_link,
965             on_delete=on_delete,
966         )
967         kwargs.setdefault("db_index", True)
968 
969         super().__init__(
970             to,
971             on_delete,
972             related_name=related_name,
973             related_query_name=related_query_name,
974             limit_choices_to=limit_choices_to,
975             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
976             to_fields=[to_field],
977             **kwargs,
978         )
979         self.db_constraint = db_constraint
980 
981     def __class_getitem__(cls, *args, **kwargs):
982         return cls
983 
984     def check(self, **kwargs):
985         return [
986             *super().check(**kwargs),
987             *self._check_on_delete(),
988             *self._check_unique(),
989         ]
990 
991     def _check_on_delete(self):
992         on_delete = getattr(self.remote_field, "on_delete", None)
993         if on_delete == SET_NULL and not self.null:
994             return [
995                 checks.Error(
996                     "Field specifies on_delete=SET_NULL, but cannot be null.",
997                     hint=(
998                         "Set null=True argument on the field, or change the on_delete "
999                         "rule."
1000                     ),
1001                     obj=self,
1002                     id="fields.E320",
1003                 )
1004             ]
1005         elif on_delete == SET_DEFAULT and not self.has_default():
1006             return [
1007                 checks.Error(
1008                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1009                     hint="Set a default value, or change the on_delete rule.",
1010                     obj=self,
1011                     id="fields.E321",
1012                 )
1013             ]
1014         else:
1015             return []
1016 
1017     def _check_unique(self, **kwargs):
1018         return (
1019             [
1020                 checks.Warning(
1021                     "Setting unique=True on a ForeignKey has the same effect as using "
1022                     "a OneToOneField.",
1023                     hint=(
1024                         "ForeignKey(unique=True) is usually better served by a "
1025                         "OneToOneField."
1026                     ),
1027                     obj=self,
1028                     id="fields.W342",
1029                 )
1030             ]
1031             if self.unique
1032             else []
1033         )
1034 
1035     def deconstruct(self):
1036         name, path, args, kwargs = super().deconstruct()
1037         del kwargs["to_fields"]
1038         del kwargs["from_fields"]
1039         # Handle the simpler arguments
1040         if self.db_index:
1041             del kwargs["db_index"]
1042         else:
1043             kwargs["db_index"] = False
1044         if self.db_constraint is not True:
1045             kwargs["db_constraint"] = self.db_constraint
1046         # Rel needs more work.
1047         to_meta = getattr(self.remote_field.model, "_meta", None)
1048         if self.remote_field.field_name and (
1049             not to_meta
1050             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1051         ):
1052             kwargs["to_field"] = self.remote_field.field_name
1053         return name, path, args, kwargs
1054 
1055     def to_python(self, value):
1056         return self.target_field.to_python(value)
1057 
1058     @property
1059     def target_field(self):
1060         return self.foreign_related_fields[0]
1061 
1062     def get_reverse_path_info(self, filtered_relation=None):
1063         """Get path from the related model to this field's model."""
1064         opts = self.model._meta
1065         from_opts = self.remote_field.model._meta
1066         return [
1067             PathInfo(
1068                 from_opts=from_opts,
1069                 to_opts=opts,
1070                 target_fields=(opts.pk,),
1071                 join_field=self.remote_field,
1072                 m2m=not self.unique,
1073                 direct=False,
1074                 filtered_relation=filtered_relation,
1075             )
1076         ]
1077 
1078     def validate(self, value, model_instance):
1079         if self.remote_field.parent_link:
1080             return
1081         super().validate(value, model_instance)
1082         if value is None:
1083             return
1084 
1085         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1086         qs = self.remote_field.model._base_manager.using(using).filter(
1087             **{self.remote_field.field_name: value}
1088         )
1089         qs = qs.complex_filter(self.get_limit_choices_to())
1090         if not qs.exists():
1091             raise exceptions.ValidationError(
1092                 self.error_messages["invalid"],
1093                 code="invalid",
1094                 params={
1095                     "model": self.remote_field.model._meta.verbose_name,
1096                     "pk": value,
1097                     "field": self.remote_field.field_name,
1098                     "value": value,
1099                 },  # 'pk' is included for backwards compatibility
1100             )
1101 
1102     def resolve_related_fields(self):
1103         related_fields = super().resolve_related_fields()
1104         for from_field, to_field in related_fields:
1105             if (
1106                 to_field
1107                 and to_field.model != self.remote_field.model._meta.concrete_model
1108             ):
1109                 raise exceptions.FieldError(
1110                     "'%s.%s' refers to field '%s' which is not local to model "
1111                     "'%s'."
1112                     % (
1113                         self.model._meta.label,
1114                         self.name,
1115                         to_field.name,
1116                         self.remote_field.model._meta.concrete_model._meta.label,
1117                     )
1118                 )
1119         return related_fields
1120 
1121     def get_attname(self):
1122         return "%s_id" % self.name
1123 
1124     def get_attname_column(self):
1125         attname = self.get_attname()
1126         column = self.db_column or attname
1127         return attname, column
1128 
1129     def get_default(self):
1130         """Return the to_field if the default value is an object."""
1131         field_default = super().get_default()
1132         if isinstance(field_default, self.remote_field.model):
1133             return getattr(field_default, self.target_field.attname)
1134         return field_default
1135 
1136     def get_db_prep_save(self, value, connection):
1137         if value is None or (
1138             value == ""
1139             and (
1140                 not self.target_field.empty_strings_allowed
1141                 or connection.features.interprets_empty_strings_as_nulls
1142             )
1143         ):
1144             return None
1145         else:
1146             return self.target_field.get_db_prep_save(value, connection=connection)
1147 
1148     def get_db_prep_value(self, value, connection, prepared=False):
1149         return self.target_field.get_db_prep_value(value, connection, prepared)
1150 
1151     def get_prep_value(self, value):
1152         return self.target_field.get_prep_value(value)
1153 
1154     def contribute_to_related_class(self, cls, related):
1155         super().contribute_to_related_class(cls, related)
1156         if self.remote_field.field_name is None:
1157             self.remote_field.field_name = cls._meta.pk.name
1158 
1159     def formfield(self, *, using=None, **kwargs):
1160         if isinstance(self.remote_field.model, str):
1161             raise ValueError(
1162                 "Cannot create form field for %r yet, because "
1163                 "its related model %r has not been loaded yet"
1164                 % (self.name, self.remote_field.model)
1165             )
1166         return super().formfield(
1167             **{
1168                 "form_class": forms.ModelChoiceField,
1169                 "queryset": self.remote_field.model._default_manager.using(using),
1170                 "to_field_name": self.remote_field.field_name,
1171                 **kwargs,
1172                 "blank": self.blank,
1173             }
1174         )
1175 
1176     def db_check(self, connection):
1177         return None
1178 
1179     def db_type(self, connection):
1180         return self.target_field.rel_db_type(connection=connection)
1181 
1182     def db_parameters(self, connection):
1183         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1184 
1185     def convert_empty_strings(self, value, expression, connection):
1186         if (not value) and isinstance(value, str):
1187             return None
1188         return value
1189 
1190     def get_db_converters(self, connection):
1191         converters = super().get_db_converters(connection)
1192         if connection.features.interprets_empty_strings_as_nulls:
1193             converters += [self.convert_empty_strings]
1194         return converters
1195 
1196     def get_col(self, alias, output_field=None):
1197         if output_field is None:
1198             output_field = self.target_field
1199             while isinstance(output_field, ForeignKey):
1200                 output_field = output_field.target_field
1201                 if output_field is self:
1202                     raise ValueError("Cannot resolve output_field.")
1203         return super().get_col(alias, output_field)
1204 
1205 
1206 class OneToOneField(ForeignKey):
1207     """
1208     A OneToOneField is essentially the same as a ForeignKey, with the exception
1209     that it always carries a "unique" constraint with it and the reverse
1210     relation always returns the object pointed to (since there will only ever
1211     be one), rather than returning a list.
1212     """
1213 
1214     # Field flags
1215     many_to_many = False
1216     many_to_one = False
1217     one_to_many = False
1218     one_to_one = True
1219 
1220     related_accessor_class = ReverseOneToOneDescriptor
1221     forward_related_accessor_class = ForwardOneToOneDescriptor
1222     rel_class = OneToOneRel
1223 
1224     description = _("One-to-one relationship")
1225 
1226     def __init__(self, to, on_delete, to_field=None, **kwargs):
1227         kwargs["unique"] = True
1228         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1229 
1230     def deconstruct(self):
1231         name, path, args, kwargs = super().deconstruct()
1232         if "unique" in kwargs:
1233             del kwargs["unique"]
1234         return name, path, args, kwargs
1235 
1236     def formfield(self, **kwargs):
1237         if self.remote_field.parent_link:
1238             return None
1239         return super().formfield(**kwargs)
1240 
1241     def save_form_data(self, instance, data):
1242         if isinstance(data, self.remote_field.model):
1243             setattr(instance, self.name, data)
1244         else:
1245             setattr(instance, self.attname, data)
1246             # Remote field object must be cleared otherwise Model.save()
1247             # will reassign attname using the related object pk.
1248             if data is None:
1249                 setattr(instance, self.name, data)
1250 
1251     def _check_unique(self, **kwargs):
1252         # Override ForeignKey since check isn't applicable here.
1253         return []
1254 
1255 
1256 def create_many_to_many_intermediary_model(field, klass):
1257     from django.db import models
1258 
1259     def set_managed(model, related, through):
1260         through._meta.managed = model._meta.managed or related._meta.managed
1261 
1262     to_model = resolve_relation(klass, field.remote_field.model)
1263     name = "%s_%s" % (klass._meta.object_name, field.name)
1264     lazy_related_operation(set_managed, klass, to_model, name)
1265 
1266     to = make_model_tuple(to_model)[1]
1267     from_ = klass._meta.model_name
1268     if to == from_:
1269         to = "to_%s" % to
1270         from_ = "from_%s" % from_
1271 
1272     meta = type(
1273         "Meta",
1274         (),
1275         {
1276             "db_table": field._get_m2m_db_table(klass._meta),
1277             "auto_created": klass,
1278             "app_label": klass._meta.app_label,
1279             "db_tablespace": klass._meta.db_tablespace,
1280             "unique_together": (from_, to),
1281             "verbose_name": _("%(from)s-%(to)s relationship")
1282             % {"from": from_, "to": to},
1283             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1284             % {"from": from_, "to": to},
1285             "apps": field.model._meta.apps,
1286         },
1287     )
1288     # Construct and return the new class.
1289     return type(
1290         name,
1291         (models.Model,),
1292         {
1293             "Meta": meta,
1294             "__module__": klass.__module__,
1295             from_: models.ForeignKey(
1296                 klass,
1297                 related_name="%s+" % name,
1298                 db_tablespace=field.db_tablespace,
1299                 db_constraint=field.remote_field.db_constraint,
1300                 on_delete=CASCADE,
1301             ),
1302             to: models.ForeignKey(
1303                 to_model,
1304                 related_name="%s+" % name,
1305                 db_tablespace=field.db_tablespace,
1306                 db_constraint=field.remote_field.db_constraint,
1307                 on_delete=CASCADE,
1308             ),
1309         },
1310     )
1311 
1312 
1313 class ManyToManyField(RelatedField):
1314     """
1315     Provide a many-to-many relation by using an intermediary model that
1316     holds two ForeignKey fields pointed at the two sides of the relation.
1317 
1318     Unless a ``through`` model was provided, ManyToManyField will use the
1319     create_many_to_many_intermediary_model factory to automatically generate
1320     the intermediary model.
1321     """
1322 
1323     # Field flags
1324     many_to_many = True
1325     many_to_one = False
1326     one_to_many = False
1327     one_to_one = False
1328 
1329     rel_class = ManyToManyRel
1330 
1331     description = _("Many-to-many relationship")
1332 
1333     def __init__(
1334         self,
1335         to,
1336         related_name=None,
1337         related_query_name=None,
1338         limit_choices_to=None,
1339         symmetrical=None,
1340         through=None,
1341         through_fields=None,
1342         db_constraint=True,
1343         db_table=None,
1344         swappable=True,
1345         **kwargs,
1346     ):
1347         try:
1348             to._meta
1349         except AttributeError:
1350             if not isinstance(to, str):
1351                 raise TypeError(
1352                     "%s(%r) is invalid. First parameter to ManyToManyField "
1353                     "must be either a model, a model name, or the string %r"
1354                     % (
1355                         self.__class__.__name__,
1356                         to,
1357                         RECURSIVE_RELATIONSHIP_CONSTANT,
1358                     )
1359                 )
1360 
1361         if symmetrical is None:
1362             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1363 
1364         if through is not None and db_table is not None:
1365             raise ValueError(
1366                 "Cannot specify a db_table if an intermediary model is used."
1367             )
1368 
1369         kwargs["rel"] = self.rel_class(
1370             self,
1371             to,
1372             related_name=related_name,
1373             related_query_name=related_query_name,
1374             limit_choices_to=limit_choices_to,
1375             symmetrical=symmetrical,
1376             through=through,
1377             through_fields=through_fields,
1378             db_constraint=db_constraint,
1379         )
1380         self.has_null_arg = "null" in kwargs
1381 
1382         super().__init__(
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             **kwargs,
1387         )
1388 
1389         self.db_table = db_table
1390         self.swappable = swappable
1391 
1392     def check(self, **kwargs):
1393         return [
1394             *super().check(**kwargs),
1395             *self._check_unique(**kwargs),
1396             *self._check_relationship_model(**kwargs),
1397             *self._check_ignored_options(**kwargs),
1398             *self._check_table_uniqueness(**kwargs),
1399         ]
1400 
1401     def _check_unique(self, **kwargs):
1402         if self.unique:
1403             return [
1404                 checks.Error(
1405                     "ManyToManyFields cannot be unique.",
1406                     obj=self,
1407                     id="fields.E330",
1408                 )
1409             ]
1410         return []
1411 
1412     def _check_ignored_options(self, **kwargs):
1413         warnings = []
1414 
1415         if self.has_null_arg:
1416             warnings.append(
1417                 checks.Warning(
1418                     "null has no effect on ManyToManyField.",
1419                     obj=self,
1420                     id="fields.W340",
1421                 )
1422             )
1423 
1424         if self._validators:
1425             warnings.append(
1426                 checks.Warning(
1427                     "ManyToManyField does not support validators.",
1428                     obj=self,
1429                     id="fields.W341",
1430                 )
1431             )
1432         if self.remote_field.symmetrical and self._related_name:
1433             warnings.append(
1434                 checks.Warning(
1435                     "related_name has no effect on ManyToManyField "
1436                     'with a symmetrical relationship, e.g. to "self".',
1437                     obj=self,
1438                     id="fields.W345",
1439                 )
1440             )
1441 
1442         return warnings
1443 
1444     def _check_relationship_model(self, from_model=None, **kwargs):
1445         if hasattr(self.remote_field.through, "_meta"):
1446             qualified_model_name = "%s.%s" % (
1447                 self.remote_field.through._meta.app_label,
1448                 self.remote_field.through.__name__,
1449             )
1450         else:
1451             qualified_model_name = self.remote_field.through
1452 
1453         errors = []
1454 
1455         if self.remote_field.through not in self.opts.apps.get_models(
1456             include_auto_created=True
1457         ):
1458             # The relationship model is not installed.
1459             errors.append(
1460                 checks.Error(
1461                     "Field specifies a many-to-many relation through model "
1462                     "'%s', which has not been installed." % qualified_model_name,
1463                     obj=self,
1464                     id="fields.E331",
1465                 )
1466             )
1467 
1468         else:
1469             assert from_model is not None, (
1470                 "ManyToManyField with intermediate "
1471                 "tables cannot be checked if you don't pass the model "
1472                 "where the field is attached to."
1473             )
1474             # Set some useful local variables
1475             to_model = resolve_relation(from_model, self.remote_field.model)
1476             from_model_name = from_model._meta.object_name
1477             if isinstance(to_model, str):
1478                 to_model_name = to_model
1479             else:
1480                 to_model_name = to_model._meta.object_name
1481             relationship_model_name = self.remote_field.through._meta.object_name
1482             self_referential = from_model == to_model
1483             # Count foreign keys in intermediate model
1484             if self_referential:
1485                 seen_self = sum(
1486                     from_model == getattr(field.remote_field, "model", None)
1487                     for field in self.remote_field.through._meta.fields
1488                 )
1489 
1490                 if seen_self > 2 and not self.remote_field.through_fields:
1491                     errors.append(
1492                         checks.Error(
1493                             "The model is used as an intermediate model by "
1494                             "'%s', but it has more than two foreign keys "
1495                             "to '%s', which is ambiguous. You must specify "
1496                             "which two foreign keys Django should use via the "
1497                             "through_fields keyword argument."
1498                             % (self, from_model_name),
1499                             hint=(
1500                                 "Use through_fields to specify which two foreign keys "
1501                                 "Django should use."
1502                             ),
1503                             obj=self.remote_field.through,
1504                             id="fields.E333",
1505                         )
1506                     )
1507 
1508             else:
1509                 # Count foreign keys in relationship model
1510                 seen_from = sum(
1511                     from_model == getattr(field.remote_field, "model", None)
1512                     for field in self.remote_field.through._meta.fields
1513                 )
1514                 seen_to = sum(
1515                     to_model == getattr(field.remote_field, "model", None)
1516                     for field in self.remote_field.through._meta.fields
1517                 )
1518 
1519                 if seen_from > 1 and not self.remote_field.through_fields:
1520                     errors.append(
1521                         checks.Error(
1522                             (
1523                                 "The model is used as an intermediate model by "
1524                                 "'%s', but it has more than one foreign key "
1525                                 "from '%s', which is ambiguous. You must specify "
1526                                 "which foreign key Django should use via the "
1527                                 "through_fields keyword argument."
1528                             )
1529                             % (self, from_model_name),
1530                             hint=(
1531                                 "If you want to create a recursive relationship, "
1532                                 'use ManyToManyField("%s", through="%s").'
1533                             )
1534                             % (
1535                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1536                                 relationship_model_name,
1537                             ),
1538                             obj=self,
1539                             id="fields.E334",
1540                         )
1541                     )
1542 
1543                 if seen_to > 1 and not self.remote_field.through_fields:
1544                     errors.append(
1545                         checks.Error(
1546                             "The model is used as an intermediate model by "
1547                             "'%s', but it has more than one foreign key "
1548                             "to '%s', which is ambiguous. You must specify "
1549                             "which foreign key Django should use via the "
1550                             "through_fields keyword argument." % (self, to_model_name),
1551                             hint=(
1552                                 "If you want to create a recursive relationship, "
1553                                 'use ManyToManyField("%s", through="%s").'
1554                             )
1555                             % (
1556                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1557                                 relationship_model_name,
1558                             ),
1559                             obj=self,
1560                             id="fields.E335",
1561                         )
1562                     )
1563 
1564                 if seen_from == 0 or seen_to == 0:
1565                     errors.append(
1566                         checks.Error(
1567                             "The model is used as an intermediate model by "
1568                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1569                             % (self, from_model_name, to_model_name),
1570                             obj=self.remote_field.through,
1571                             id="fields.E336",
1572                         )
1573                     )
1574 
1575         # Validate `through_fields`.
1576         if self.remote_field.through_fields is not None:
1577             # Validate that we're given an iterable of at least two items
1578             # and that none of them is "falsy".
1579             if not (
1580                 len(self.remote_field.through_fields) >= 2
1581                 and self.remote_field.through_fields[0]
1582                 and self.remote_field.through_fields[1]
1583             ):
1584                 errors.append(
1585                     checks.Error(
1586                         "Field specifies 'through_fields' but does not provide "
1587                         "the names of the two link fields that should be used "
1588                         "for the relation through model '%s'." % qualified_model_name,
1589                         hint=(
1590                             "Make sure you specify 'through_fields' as "
1591                             "through_fields=('field1', 'field2')"
1592                         ),
1593                         obj=self,
1594                         id="fields.E337",
1595                     )
1596                 )
1597 
1598             # Validate the given through fields -- they should be actual
1599             # fields on the through model, and also be foreign keys to the
1600             # expected models.
1601             else:
1602                 assert from_model is not None, (
1603                     "ManyToManyField with intermediate "
1604                     "tables cannot be checked if you don't pass the model "
1605                     "where the field is attached to."
1606                 )
1607 
1608                 source, through, target = (
1609                     from_model,
1610                     self.remote_field.through,
1611                     self.remote_field.model,
1612                 )
1613                 source_field_name, target_field_name = self.remote_field.through_fields[
1614                     :2
1615                 ]
1616 
1617                 for field_name, related_model in (
1618                     (source_field_name, source),
1619                     (target_field_name, target),
1620                 ):
1621 
1622                     possible_field_names = []
1623                     for f in through._meta.fields:
1624                         if (
1625                             hasattr(f, "remote_field")
1626                             and getattr(f.remote_field, "model", None) == related_model
1627                         ):
1628                             possible_field_names.append(f.name)
1629                     if possible_field_names:
1630                         hint = (
1631                             "Did you mean one of the following foreign keys to '%s': "
1632                             "%s?"
1633                             % (
1634                                 related_model._meta.object_name,
1635                                 ", ".join(possible_field_names),
1636                             )
1637                         )
1638                     else:
1639                         hint = None
1640 
1641                     try:
1642                         field = through._meta.get_field(field_name)
1643                     except exceptions.FieldDoesNotExist:
1644                         errors.append(
1645                             checks.Error(
1646                                 "The intermediary model '%s' has no field '%s'."
1647                                 % (qualified_model_name, field_name),
1648                                 hint=hint,
1649                                 obj=self,
1650                                 id="fields.E338",
1651                             )
1652                         )
1653                     else:
1654                         if not (
1655                             hasattr(field, "remote_field")
1656                             and getattr(field.remote_field, "model", None)
1657                             == related_model
1658                         ):
1659                             errors.append(
1660                                 checks.Error(
1661                                     "'%s.%s' is not a foreign key to '%s'."
1662                                     % (
1663                                         through._meta.object_name,
1664                                         field_name,
1665                                         related_model._meta.object_name,
1666                                     ),
1667                                     hint=hint,
1668                                     obj=self,
1669                                     id="fields.E339",
1670                                 )
1671                             )
1672 
1673         return errors
1674 
1675     def _check_table_uniqueness(self, **kwargs):
1676         if (
1677             isinstance(self.remote_field.through, str)
1678             or not self.remote_field.through._meta.managed
1679         ):
1680             return []
1681         registered_tables = {
1682             model._meta.db_table: model
1683             for model in self.opts.apps.get_models(include_auto_created=True)
1684             if model != self.remote_field.through and model._meta.managed
1685         }
1686         m2m_db_table = self.m2m_db_table()
1687         model = registered_tables.get(m2m_db_table)
1688         # The second condition allows multiple m2m relations on a model if
1689         # some point to a through model that proxies another through model.
1690         if (
1691             model
1692             and model._meta.concrete_model
1693             != self.remote_field.through._meta.concrete_model
1694         ):
1695             if model._meta.auto_created:
1696 
1697                 def _get_field_name(model):
1698                     for field in model._meta.auto_created._meta.many_to_many:
1699                         if field.remote_field.through is model:
1700                             return field.name
1701 
1702                 opts = model._meta.auto_created._meta
1703                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1704             else:
1705                 clashing_obj = model._meta.label
1706             if settings.DATABASE_ROUTERS:
1707                 error_class, error_id = checks.Warning, "fields.W344"
1708                 error_hint = (
1709                     "You have configured settings.DATABASE_ROUTERS. Verify "
1710                     "that the table of %r is correctly routed to a separate "
1711                     "database." % clashing_obj
1712                 )
1713             else:
1714                 error_class, error_id = checks.Error, "fields.E340"
1715                 error_hint = None
1716             return [
1717                 error_class(
1718                     "The field's intermediary table '%s' clashes with the "
1719                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1720                     obj=self,
1721                     hint=error_hint,
1722                     id=error_id,
1723                 )
1724             ]
1725         return []
1726 
1727     def deconstruct(self):
1728         name, path, args, kwargs = super().deconstruct()
1729         # Handle the simpler arguments.
1730         if self.db_table is not None:
1731             kwargs["db_table"] = self.db_table
1732         if self.remote_field.db_constraint is not True:
1733             kwargs["db_constraint"] = self.remote_field.db_constraint
1734         # Lowercase model names as they should be treated as case-insensitive.
1735         if isinstance(self.remote_field.model, str):
1736             if "." in self.remote_field.model:
1737                 app_label, model_name = self.remote_field.model.split(".")
1738                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1739             else:
1740                 kwargs["to"] = self.remote_field.model.lower()
1741         else:
1742             kwargs["to"] = self.remote_field.model._meta.label_lower
1743         if getattr(self.remote_field, "through", None) is not None:
1744             if isinstance(self.remote_field.through, str):
1745                 kwargs["through"] = self.remote_field.through
1746             elif not self.remote_field.through._meta.auto_created:
1747                 kwargs["through"] = self.remote_field.through._meta.label
1748         # If swappable is True, then see if we're actually pointing to the target
1749         # of a swap.
1750         swappable_setting = self.swappable_setting
1751         if swappable_setting is not None:
1752             # If it's already a settings reference, error.
1753             if hasattr(kwargs["to"], "setting_name"):
1754                 if kwargs["to"].setting_name != swappable_setting:
1755                     raise ValueError(
1756                         "Cannot deconstruct a ManyToManyField pointing to a "
1757                         "model that is swapped in place of more than one model "
1758                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1759                     )
1760 
1761             kwargs["to"] = SettingsReference(
1762                 kwargs["to"],
1763                 swappable_setting,
1764             )
1765         return name, path, args, kwargs
1766 
1767     def _get_path_info(self, direct=False, filtered_relation=None):
1768         """Called by both direct and indirect m2m traversal."""
1769         int_model = self.remote_field.through
1770         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1771         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1772         if direct:
1773             join1infos = linkfield1.reverse_path_infos
1774             if filtered_relation:
1775                 join2infos = linkfield2.get_path_info(filtered_relation)
1776             else:
1777                 join2infos = linkfield2.path_infos
1778         else:
1779             join1infos = linkfield2.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield1.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield1.path_infos
1784         # Get join infos between the last model of join 1 and the first model
1785         # of join 2. Assume the only reason these may differ is due to model
1786         # inheritance.
1787         join1_final = join1infos[-1].to_opts
1788         join2_initial = join2infos[0].from_opts
1789         if join1_final is join2_initial:
1790             intermediate_infos = []
1791         elif issubclass(join1_final.model, join2_initial.model):
1792             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1793         else:
1794             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1795 
1796         return [*join1infos, *intermediate_infos, *join2infos]
1797 
1798     def get_path_info(self, filtered_relation=None):
1799         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1800 
1801     @cached_property
1802     def path_infos(self):
1803         return self.get_path_info()
1804 
1805     def get_reverse_path_info(self, filtered_relation=None):
1806         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1807 
1808     @cached_property
1809     def reverse_path_infos(self):
1810         return self.get_reverse_path_info()
1811 
1812     def _get_m2m_db_table(self, opts):
1813         """
1814         Function that can be curried to provide the m2m table name for this
1815         relation.
1816         """
1817         if self.remote_field.through is not None:
1818             return self.remote_field.through._meta.db_table
1819         elif self.db_table:
1820             return self.db_table
1821         else:
1822             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1823             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1824 
1825     def _get_m2m_attr(self, related, attr):
1826         """
1827         Function that can be curried to provide the source accessor or DB
1828         column name for the m2m table.
1829         """
1830         cache_attr = "_m2m_%s_cache" % attr
1831         if hasattr(self, cache_attr):
1832             return getattr(self, cache_attr)
1833         if self.remote_field.through_fields is not None:
1834             link_field_name = self.remote_field.through_fields[0]
1835         else:
1836             link_field_name = None
1837         for f in self.remote_field.through._meta.fields:
1838             if (
1839                 f.is_relation
1840                 and f.remote_field.model == related.related_model
1841                 and (link_field_name is None or link_field_name == f.name)
1842             ):
1843                 setattr(self, cache_attr, getattr(f, attr))
1844                 return getattr(self, cache_attr)
1845 
1846     def _get_m2m_reverse_attr(self, related, attr):
1847         """
1848         Function that can be curried to provide the related accessor or DB
1849         column name for the m2m table.
1850         """
1851         cache_attr = "_m2m_reverse_%s_cache" % attr
1852         if hasattr(self, cache_attr):
1853             return getattr(self, cache_attr)
1854         found = False
1855         if self.remote_field.through_fields is not None:
1856             link_field_name = self.remote_field.through_fields[1]
1857         else:
1858             link_field_name = None
1859         for f in self.remote_field.through._meta.fields:
1860             if f.is_relation and f.remote_field.model == related.model:
1861                 if link_field_name is None and related.related_model == related.model:
1862                     # If this is an m2m-intermediate to self,
1863                     # the first foreign key you find will be
1864                     # the source column. Keep searching for
1865                     # the second foreign key.
1866                     if found:
1867                         setattr(self, cache_attr, getattr(f, attr))
1868                         break
1869                     else:
1870                         found = True
1871                 elif link_field_name is None or link_field_name == f.name:
1872                     setattr(self, cache_attr, getattr(f, attr))
1873                     break
1874         return getattr(self, cache_attr)
1875 
1876     def contribute_to_class(self, cls, name, **kwargs):
1877         # To support multiple relations to self, it's useful to have a non-None
1878         # related name on symmetrical relations for internal reasons. The
1879         # concept doesn't make a lot of sense externally ("you want me to
1880         # specify *what* on my non-reversible relation?!"), so we set it up
1881         # automatically. The funky name reduces the chance of an accidental
1882         # clash.
1883         if self.remote_field.symmetrical and (
1884             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1885             or self.remote_field.model == cls._meta.object_name
1886         ):
1887             self.remote_field.related_name = "%s_rel_+" % name
1888         elif self.remote_field.is_hidden():
1889             # If the backwards relation is disabled, replace the original
1890             # related_name with one generated from the m2m field name. Django
1891             # still uses backwards relations internally and we need to avoid
1892             # clashes between multiple m2m fields with related_name == '+'.
1893             self.remote_field.related_name = "_%s_%s_%s_+" % (
1894                 cls._meta.app_label,
1895                 cls.__name__.lower(),
1896                 name,
1897             )
1898 
1899         super().contribute_to_class(cls, name, **kwargs)
1900 
1901         # The intermediate m2m model is not auto created if:
1902         #  1) There is a manually specified intermediate, or
1903         #  2) The class owning the m2m field is abstract.
1904         #  3) The class owning the m2m field has been swapped out.
1905         if not cls._meta.abstract:
1906             if self.remote_field.through:
1907 
1908                 def resolve_through_model(_, model, field):
1909                     field.remote_field.through = model
1910 
1911                 lazy_related_operation(
1912                     resolve_through_model, cls, self.remote_field.through, field=self
1913                 )
1914             elif not cls._meta.swapped:
1915                 self.remote_field.through = create_many_to_many_intermediary_model(
1916                     self, cls
1917                 )
1918 
1919         # Add the descriptor for the m2m relation.
1920         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1921 
1922         # Set up the accessor for the m2m table name for the relation.
1923         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1924 
1925     def contribute_to_related_class(self, cls, related):
1926         # Internal M2Ms (i.e., those with a related name ending with '+')
1927         # and swapped models don't get a related descriptor.
1928         if (
1929             not self.remote_field.is_hidden()
1930             and not related.related_model._meta.swapped
1931         ):
1932             setattr(
1933                 cls,
1934                 related.get_accessor_name(),
1935                 ManyToManyDescriptor(self.remote_field, reverse=True),
1936             )
1937 
1938         # Set up the accessors for the column names on the m2m table.
1939         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1940         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1941 
1942         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1943         self.m2m_reverse_field_name = partial(
1944             self._get_m2m_reverse_attr, related, "name"
1945         )
1946 
1947         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1948         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1949         get_m2m_reverse_rel = partial(
1950             self._get_m2m_reverse_attr, related, "remote_field"
1951         )
1952         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1953 
1954     def set_attributes_from_rel(self):
1955         pass
1956 
1957     def value_from_object(self, obj):
1958         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1959 
1960     def save_form_data(self, instance, data):
1961         getattr(instance, self.attname).set(data)
1962 
1963     def formfield(self, *, using=None, **kwargs):
1964         defaults = {
1965             "form_class": forms.ModelMultipleChoiceField,
1966             "queryset": self.remote_field.model._default_manager.using(using),
1967             **kwargs,
1968         }
1969         # If initial is passed in, it's a list of related objects, but the
1970         # MultipleChoiceField takes a list of IDs.
1971         if defaults.get("initial") is not None:
1972             initial = defaults["initial"]
1973             if callable(initial):
1974                 initial = initial()
1975             defaults["initial"] = [i.pk for i in initial]
1976         return super().formfield(**defaults)
1977 
1978     def db_check(self, connection):
1979         return None
1980 
1981     def db_type(self, connection):
1982         # A ManyToManyField is not represented by a single column,
1983         # so return None.
1984         return None
1985 
1986     def db_parameters(self, connection):
1987         return {"type": None, "check": None}

</code><intended_behavior>Modify the definition of ForeignKey fields (and related fields) to respect or optionally inherit `db_collation` from the referenced primary key field. This could involve adjusting the field's creation or alteration logic within Django's migration framework to include collation settings explicitly where necessary.</intended_behavior>, <file>django/db/migrations/operations/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db import models
2 from django.db.migrations.operations.base import Operation
3 from django.db.migrations.state import ModelState
4 from django.db.migrations.utils import field_references, resolve_relation
5 from django.db.models.options import normalize_together
6 from django.utils.functional import cached_property
7 
8 from .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField
9 
10 
11 def _check_for_duplicates(arg_name, objs):
12     used_vals = set()
13     for val in objs:
14         if val in used_vals:
15             raise ValueError(
16                 "Found duplicate value %s in CreateModel %s argument." % (val, arg_name)
17             )
18         used_vals.add(val)
19 
20 
21 class ModelOperation(Operation):
22     def __init__(self, name):
23         self.name = name
24 
25     @cached_property
26     def name_lower(self):
27         return self.name.lower()
28 
29     def references_model(self, name, app_label):
30         return name.lower() == self.name_lower
31 
32     def reduce(self, operation, app_label):
33         return super().reduce(operation, app_label) or self.can_reduce_through(
34             operation, app_label
35         )
36 
37     def can_reduce_through(self, operation, app_label):
38         return not operation.references_model(self.name, app_label)
39 
40 
41 class CreateModel(ModelOperation):
42     """Create a model's table."""
43 
44     serialization_expand_args = ["fields", "options", "managers"]
45 
46     def __init__(self, name, fields, options=None, bases=None, managers=None):
47         self.fields = fields
48         self.options = options or {}
49         self.bases = bases or (models.Model,)
50         self.managers = managers or []
51         super().__init__(name)
52         # Sanity-check that there are no duplicated field names, bases, or
53         # manager names
54         _check_for_duplicates("fields", (name for name, _ in self.fields))
55         _check_for_duplicates(
56             "bases",
57             (
58                 base._meta.label_lower
59                 if hasattr(base, "_meta")
60                 else base.lower()
61                 if isinstance(base, str)
62                 else base
63                 for base in self.bases
64             ),
65         )
66         _check_for_duplicates("managers", (name for name, _ in self.managers))
67 
68     def deconstruct(self):
69         kwargs = {
70             "name": self.name,
71             "fields": self.fields,
72         }
73         if self.options:
74             kwargs["options"] = self.options
75         if self.bases and self.bases != (models.Model,):
76             kwargs["bases"] = self.bases
77         if self.managers and self.managers != [("objects", models.Manager())]:
78             kwargs["managers"] = self.managers
79         return (self.__class__.__qualname__, [], kwargs)
80 
81     def state_forwards(self, app_label, state):
82         state.add_model(
83             ModelState(
84                 app_label,
85                 self.name,
86                 list(self.fields),
87                 dict(self.options),
88                 tuple(self.bases),
89                 list(self.managers),
90             )
91         )
92 
93     def database_forwards(self, app_label, schema_editor, from_state, to_state):
94         model = to_state.apps.get_model(app_label, self.name)
95         if self.allow_migrate_model(schema_editor.connection.alias, model):
96             schema_editor.create_model(model)
97 
98     def database_backwards(self, app_label, schema_editor, from_state, to_state):
99         model = from_state.apps.get_model(app_label, self.name)
100         if self.allow_migrate_model(schema_editor.connection.alias, model):
101             schema_editor.delete_model(model)
102 
103     def describe(self):
104         return "Create %smodel %s" % (
105             "proxy " if self.options.get("proxy", False) else "",
106             self.name,
107         )
108 
109     @property
110     def migration_name_fragment(self):
111         return self.name_lower
112 
113     def references_model(self, name, app_label):
114         name_lower = name.lower()
115         if name_lower == self.name_lower:
116             return True
117 
118         # Check we didn't inherit from the model
119         reference_model_tuple = (app_label, name_lower)
120         for base in self.bases:
121             if (
122                 base is not models.Model
123                 and isinstance(base, (models.base.ModelBase, str))
124                 and resolve_relation(base, app_label) == reference_model_tuple
125             ):
126                 return True
127 
128         # Check we have no FKs/M2Ms with it
129         for _name, field in self.fields:
130             if field_references(
131                 (app_label, self.name_lower), field, reference_model_tuple
132             ):
133                 return True
134         return False
135 
136     def reduce(self, operation, app_label):
137         if (
138             isinstance(operation, DeleteModel)
139             and self.name_lower == operation.name_lower
140             and not self.options.get("proxy", False)
141         ):
142             return []
143         elif (
144             isinstance(operation, RenameModel)
145             and self.name_lower == operation.old_name_lower
146         ):
147             return [
148                 CreateModel(
149                     operation.new_name,
150                     fields=self.fields,
151                     options=self.options,
152                     bases=self.bases,
153                     managers=self.managers,
154                 ),
155             ]
156         elif (
157             isinstance(operation, AlterModelOptions)
158             and self.name_lower == operation.name_lower
159         ):
160             options = {**self.options, **operation.options}
161             for key in operation.ALTER_OPTION_KEYS:
162                 if key not in operation.options:
163                     options.pop(key, None)
164             return [
165                 CreateModel(
166                     self.name,
167                     fields=self.fields,
168                     options=options,
169                     bases=self.bases,
170                     managers=self.managers,
171                 ),
172             ]
173         elif (
174             isinstance(operation, AlterModelManagers)
175             and self.name_lower == operation.name_lower
176         ):
177             return [
178                 CreateModel(
179                     self.name,
180                     fields=self.fields,
181                     options=self.options,
182                     bases=self.bases,
183                     managers=operation.managers,
184                 ),
185             ]
186         elif (
187             isinstance(operation, AlterTogetherOptionOperation)
188             and self.name_lower == operation.name_lower
189         ):
190             return [
191                 CreateModel(
192                     self.name,
193                     fields=self.fields,
194                     options={
195                         **self.options,
196                         **{operation.option_name: operation.option_value},
197                     },
198                     bases=self.bases,
199                     managers=self.managers,
200                 ),
201             ]
202         elif (
203             isinstance(operation, AlterOrderWithRespectTo)
204             and self.name_lower == operation.name_lower
205         ):
206             return [
207                 CreateModel(
208                     self.name,
209                     fields=self.fields,
210                     options={
211                         **self.options,
212                         "order_with_respect_to": operation.order_with_respect_to,
213                     },
214                     bases=self.bases,
215                     managers=self.managers,
216                 ),
217             ]
218         elif (
219             isinstance(operation, FieldOperation)
220             and self.name_lower == operation.model_name_lower
221         ):
222             if isinstance(operation, AddField):
223                 return [
224                     CreateModel(
225                         self.name,
226                         fields=self.fields + [(operation.name, operation.field)],
227                         options=self.options,
228                         bases=self.bases,
229                         managers=self.managers,
230                     ),
231                 ]
232             elif isinstance(operation, AlterField):
233                 return [
234                     CreateModel(
235                         self.name,
236                         fields=[
237                             (n, operation.field if n == operation.name else v)
238                             for n, v in self.fields
239                         ],
240                         options=self.options,
241                         bases=self.bases,
242                         managers=self.managers,
243                     ),
244                 ]
245             elif isinstance(operation, RemoveField):
246                 options = self.options.copy()
247                 for option_name in ("unique_together", "index_together"):
248                     option = options.pop(option_name, None)
249                     if option:
250                         option = set(
251                             filter(
252                                 bool,
253                                 (
254                                     tuple(
255                                         f for f in fields if f != operation.name_lower
256                                     )
257                                     for fields in option
258                                 ),
259                             )
260                         )
261                         if option:
262                             options[option_name] = option
263                 order_with_respect_to = options.get("order_with_respect_to")
264                 if order_with_respect_to == operation.name_lower:
265                     del options["order_with_respect_to"]
266                 return [
267                     CreateModel(
268                         self.name,
269                         fields=[
270                             (n, v)
271                             for n, v in self.fields
272                             if n.lower() != operation.name_lower
273                         ],
274                         options=options,
275                         bases=self.bases,
276                         managers=self.managers,
277                     ),
278                 ]
279             elif isinstance(operation, RenameField):
280                 options = self.options.copy()
281                 for option_name in ("unique_together", "index_together"):
282                     option = options.get(option_name)
283                     if option:
284                         options[option_name] = {
285                             tuple(
286                                 operation.new_name if f == operation.old_name else f
287                                 for f in fields
288                             )
289                             for fields in option
290                         }
291                 order_with_respect_to = options.get("order_with_respect_to")
292                 if order_with_respect_to == operation.old_name:
293                     options["order_with_respect_to"] = operation.new_name
294                 return [
295                     CreateModel(
296                         self.name,
297                         fields=[
298                             (operation.new_name if n == operation.old_name else n, v)
299                             for n, v in self.fields
300                         ],
301                         options=options,
302                         bases=self.bases,
303                         managers=self.managers,
304                     ),
305                 ]
306         return super().reduce(operation, app_label)
307 
308 
309 class DeleteModel(ModelOperation):
310     """Drop a model's table."""
311 
312     def deconstruct(self):
313         kwargs = {
314             "name": self.name,
315         }
316         return (self.__class__.__qualname__, [], kwargs)
317 
318     def state_forwards(self, app_label, state):
319         state.remove_model(app_label, self.name_lower)
320 
321     def database_forwards(self, app_label, schema_editor, from_state, to_state):
322         model = from_state.apps.get_model(app_label, self.name)
323         if self.allow_migrate_model(schema_editor.connection.alias, model):
324             schema_editor.delete_model(model)
325 
326     def database_backwards(self, app_label, schema_editor, from_state, to_state):
327         model = to_state.apps.get_model(app_label, self.name)
328         if self.allow_migrate_model(schema_editor.connection.alias, model):
329             schema_editor.create_model(model)
330 
331     def references_model(self, name, app_label):
332         # The deleted model could be referencing the specified model through
333         # related fields.
334         return True
335 
336     def describe(self):
337         return "Delete model %s" % self.name
338 
339     @property
340     def migration_name_fragment(self):
341         return "delete_%s" % self.name_lower
342 
343 
344 class RenameModel(ModelOperation):
345     """Rename a model."""
346 
347     def __init__(self, old_name, new_name):
348         self.old_name = old_name
349         self.new_name = new_name
350         super().__init__(old_name)
351 
352     @cached_property
353     def old_name_lower(self):
354         return self.old_name.lower()
355 
356     @cached_property
357     def new_name_lower(self):
358         return self.new_name.lower()
359 
360     def deconstruct(self):
361         kwargs = {
362             "old_name": self.old_name,
363             "new_name": self.new_name,
364         }
365         return (self.__class__.__qualname__, [], kwargs)
366 
367     def state_forwards(self, app_label, state):
368         state.rename_model(app_label, self.old_name, self.new_name)
369 
370     def database_forwards(self, app_label, schema_editor, from_state, to_state):
371         new_model = to_state.apps.get_model(app_label, self.new_name)
372         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
373             old_model = from_state.apps.get_model(app_label, self.old_name)
374             old_db_table = old_model._meta.db_table
375             new_db_table = new_model._meta.db_table
376             # Don't alter when a table name is not changed.
377             if old_db_table == new_db_table:
378                 return
379             # Move the main table
380             schema_editor.alter_db_table(new_model, old_db_table, new_db_table)
381             # Alter the fields pointing to us
382             for related_object in old_model._meta.related_objects:
383                 if related_object.related_model == old_model:
384                     model = new_model
385                     related_key = (app_label, self.new_name_lower)
386                 else:
387                     model = related_object.related_model
388                     related_key = (
389                         related_object.related_model._meta.app_label,
390                         related_object.related_model._meta.model_name,
391                     )
392                 to_field = to_state.apps.get_model(*related_key)._meta.get_field(
393                     related_object.field.name
394                 )
395                 schema_editor.alter_field(
396                     model,
397                     related_object.field,
398                     to_field,
399                 )
400             # Rename M2M fields whose name is based on this model's name.
401             fields = zip(
402                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
403             )
404             for (old_field, new_field) in fields:
405                 # Skip self-referential fields as these are renamed above.
406                 if (
407                     new_field.model == new_field.related_model
408                     or not new_field.remote_field.through._meta.auto_created
409                 ):
410                     continue
411                 # Rename the M2M table that's based on this model's name.
412                 old_m2m_model = old_field.remote_field.through
413                 new_m2m_model = new_field.remote_field.through
414                 schema_editor.alter_db_table(
415                     new_m2m_model,
416                     old_m2m_model._meta.db_table,
417                     new_m2m_model._meta.db_table,
418                 )
419                 # Rename the column in the M2M table that's based on this
420                 # model's name.
421                 schema_editor.alter_field(
422                     new_m2m_model,
423                     old_m2m_model._meta.get_field(old_model._meta.model_name),
424                     new_m2m_model._meta.get_field(new_model._meta.model_name),
425                 )
426 
427     def database_backwards(self, app_label, schema_editor, from_state, to_state):
428         self.new_name_lower, self.old_name_lower = (
429             self.old_name_lower,
430             self.new_name_lower,
431         )
432         self.new_name, self.old_name = self.old_name, self.new_name
433 
434         self.database_forwards(app_label, schema_editor, from_state, to_state)
435 
436         self.new_name_lower, self.old_name_lower = (
437             self.old_name_lower,
438             self.new_name_lower,
439         )
440         self.new_name, self.old_name = self.old_name, self.new_name
441 
442     def references_model(self, name, app_label):
443         return (
444             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
445         )
446 
447     def describe(self):
448         return "Rename model %s to %s" % (self.old_name, self.new_name)
449 
450     @property
451     def migration_name_fragment(self):
452         return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
453 
454     def reduce(self, operation, app_label):
455         if (
456             isinstance(operation, RenameModel)
457             and self.new_name_lower == operation.old_name_lower
458         ):
459             return [
460                 RenameModel(
461                     self.old_name,
462                     operation.new_name,
463                 ),
464             ]
465         # Skip `ModelOperation.reduce` as we want to run `references_model`
466         # against self.new_name.
467         return super(ModelOperation, self).reduce(
468             operation, app_label
469         ) or not operation.references_model(self.new_name, app_label)
470 
471 
472 class ModelOptionOperation(ModelOperation):
473     def reduce(self, operation, app_label):
474         if (
475             isinstance(operation, (self.__class__, DeleteModel))
476             and self.name_lower == operation.name_lower
477         ):
478             return [operation]
479         return super().reduce(operation, app_label)
480 
481 
482 class AlterModelTable(ModelOptionOperation):
483     """Rename a model's table."""
484 
485     def __init__(self, name, table):
486         self.table = table
487         super().__init__(name)
488 
489     def deconstruct(self):
490         kwargs = {
491             "name": self.name,
492             "table": self.table,
493         }
494         return (self.__class__.__qualname__, [], kwargs)
495 
496     def state_forwards(self, app_label, state):
497         state.alter_model_options(app_label, self.name_lower, {"db_table": self.table})
498 
499     def database_forwards(self, app_label, schema_editor, from_state, to_state):
500         new_model = to_state.apps.get_model(app_label, self.name)
501         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
502             old_model = from_state.apps.get_model(app_label, self.name)
503             schema_editor.alter_db_table(
504                 new_model,
505                 old_model._meta.db_table,
506                 new_model._meta.db_table,
507             )
508             # Rename M2M fields whose name is based on this model's db_table
509             for (old_field, new_field) in zip(
510                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
511             ):
512                 if new_field.remote_field.through._meta.auto_created:
513                     schema_editor.alter_db_table(
514                         new_field.remote_field.through,
515                         old_field.remote_field.through._meta.db_table,
516                         new_field.remote_field.through._meta.db_table,
517                     )
518 
519     def database_backwards(self, app_label, schema_editor, from_state, to_state):
520         return self.database_forwards(app_label, schema_editor, from_state, to_state)
521 
522     def describe(self):
523         return "Rename table for %s to %s" % (
524             self.name,
525             self.table if self.table is not None else "(default)",
526         )
527 
528     @property
529     def migration_name_fragment(self):
530         return "alter_%s_table" % self.name_lower
531 
532 
533 class AlterTogetherOptionOperation(ModelOptionOperation):
534     option_name = None
535 
536     def __init__(self, name, option_value):
537         if option_value:
538             option_value = set(normalize_together(option_value))
539         setattr(self, self.option_name, option_value)
540         super().__init__(name)
541 
542     @cached_property
543     def option_value(self):
544         return getattr(self, self.option_name)
545 
546     def deconstruct(self):
547         kwargs = {
548             "name": self.name,
549             self.option_name: self.option_value,
550         }
551         return (self.__class__.__qualname__, [], kwargs)
552 
553     def state_forwards(self, app_label, state):
554         state.alter_model_options(
555             app_label,
556             self.name_lower,
557             {self.option_name: self.option_value},
558         )
559 
560     def database_forwards(self, app_label, schema_editor, from_state, to_state):
561         new_model = to_state.apps.get_model(app_label, self.name)
562         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
563             old_model = from_state.apps.get_model(app_label, self.name)
564             alter_together = getattr(schema_editor, "alter_%s" % self.option_name)
565             alter_together(
566                 new_model,
567                 getattr(old_model._meta, self.option_name, set()),
568                 getattr(new_model._meta, self.option_name, set()),
569             )
570 
571     def database_backwards(self, app_label, schema_editor, from_state, to_state):
572         return self.database_forwards(app_label, schema_editor, from_state, to_state)
573 
574     def references_field(self, model_name, name, app_label):
575         return self.references_model(model_name, app_label) and (
576             not self.option_value
577             or any((name in fields) for fields in self.option_value)
578         )
579 
580     def describe(self):
581         return "Alter %s for %s (%s constraint(s))" % (
582             self.option_name,
583             self.name,
584             len(self.option_value or ""),
585         )
586 
587     @property
588     def migration_name_fragment(self):
589         return "alter_%s_%s" % (self.name_lower, self.option_name)
590 
591     def can_reduce_through(self, operation, app_label):
592         return super().can_reduce_through(operation, app_label) or (
593             isinstance(operation, AlterTogetherOptionOperation)
594             and type(operation) is not type(self)
595         )
596 
597 
598 class AlterUniqueTogether(AlterTogetherOptionOperation):
599     """
600     Change the value of unique_together to the target one.
601     Input value of unique_together must be a set of tuples.
602     """
603 
604     option_name = "unique_together"
605 
606     def __init__(self, name, unique_together):
607         super().__init__(name, unique_together)
608 
609 
610 class AlterIndexTogether(AlterTogetherOptionOperation):
611     """
612     Change the value of index_together to the target one.
613     Input value of index_together must be a set of tuples.
614     """
615 
616     option_name = "index_together"
617 
618     def __init__(self, name, index_together):
619         super().__init__(name, index_together)
620 
621 
622 class AlterOrderWithRespectTo(ModelOptionOperation):
623     """Represent a change with the order_with_respect_to option."""
624 
625     option_name = "order_with_respect_to"
626 
627     def __init__(self, name, order_with_respect_to):
628         self.order_with_respect_to = order_with_respect_to
629         super().__init__(name)
630 
631     def deconstruct(self):
632         kwargs = {
633             "name": self.name,
634             "order_with_respect_to": self.order_with_respect_to,
635         }
636         return (self.__class__.__qualname__, [], kwargs)
637 
638     def state_forwards(self, app_label, state):
639         state.alter_model_options(
640             app_label,
641             self.name_lower,
642             {self.option_name: self.order_with_respect_to},
643         )
644 
645     def database_forwards(self, app_label, schema_editor, from_state, to_state):
646         to_model = to_state.apps.get_model(app_label, self.name)
647         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
648             from_model = from_state.apps.get_model(app_label, self.name)
649             # Remove a field if we need to
650             if (
651                 from_model._meta.order_with_respect_to
652                 and not to_model._meta.order_with_respect_to
653             ):
654                 schema_editor.remove_field(
655                     from_model, from_model._meta.get_field("_order")
656                 )
657             # Add a field if we need to (altering the column is untouched as
658             # it's likely a rename)
659             elif (
660                 to_model._meta.order_with_respect_to
661                 and not from_model._meta.order_with_respect_to
662             ):
663                 field = to_model._meta.get_field("_order")
664                 if not field.has_default():
665                     field.default = 0
666                 schema_editor.add_field(
667                     from_model,
668                     field,
669                 )
670 
671     def database_backwards(self, app_label, schema_editor, from_state, to_state):
672         self.database_forwards(app_label, schema_editor, from_state, to_state)
673 
674     def references_field(self, model_name, name, app_label):
675         return self.references_model(model_name, app_label) and (
676             self.order_with_respect_to is None or name == self.order_with_respect_to
677         )
678 
679     def describe(self):
680         return "Set order_with_respect_to on %s to %s" % (
681             self.name,
682             self.order_with_respect_to,
683         )
684 
685     @property
686     def migration_name_fragment(self):
687         return "alter_%s_order_with_respect_to" % self.name_lower
688 
689 
690 class AlterModelOptions(ModelOptionOperation):
691     """
692     Set new model options that don't directly affect the database schema
693     (like verbose_name, permissions, ordering). Python code in migrations
694     may still need them.
695     """
696 
697     # Model options we want to compare and preserve in an AlterModelOptions op
698     ALTER_OPTION_KEYS = [
699         "base_manager_name",
700         "default_manager_name",
701         "default_related_name",
702         "get_latest_by",
703         "managed",
704         "ordering",
705         "permissions",
706         "default_permissions",
707         "select_on_save",
708         "verbose_name",
709         "verbose_name_plural",
710     ]
711 
712     def __init__(self, name, options):
713         self.options = options
714         super().__init__(name)
715 
716     def deconstruct(self):
717         kwargs = {
718             "name": self.name,
719             "options": self.options,
720         }
721         return (self.__class__.__qualname__, [], kwargs)
722 
723     def state_forwards(self, app_label, state):
724         state.alter_model_options(
725             app_label,
726             self.name_lower,
727             self.options,
728             self.ALTER_OPTION_KEYS,
729         )
730 
731     def database_forwards(self, app_label, schema_editor, from_state, to_state):
732         pass
733 
734     def database_backwards(self, app_label, schema_editor, from_state, to_state):
735         pass
736 
737     def describe(self):
738         return "Change Meta options on %s" % self.name
739 
740     @property
741     def migration_name_fragment(self):
742         return "alter_%s_options" % self.name_lower
743 
744 
745 class AlterModelManagers(ModelOptionOperation):
746     """Alter the model's managers."""
747 
748     serialization_expand_args = ["managers"]
749 
750     def __init__(self, name, managers):
751         self.managers = managers
752         super().__init__(name)
753 
754     def deconstruct(self):
755         return (self.__class__.__qualname__, [self.name, self.managers], {})
756 
757     def state_forwards(self, app_label, state):
758         state.alter_model_managers(app_label, self.name_lower, self.managers)
759 
760     def database_forwards(self, app_label, schema_editor, from_state, to_state):
761         pass
762 
763     def database_backwards(self, app_label, schema_editor, from_state, to_state):
764         pass
765 
766     def describe(self):
767         return "Change managers on %s" % self.name
768 
769     @property
770     def migration_name_fragment(self):
771         return "alter_%s_managers" % self.name_lower
772 
773 
774 class IndexOperation(Operation):
775     option_name = "indexes"
776 
777     @cached_property
778     def model_name_lower(self):
779         return self.model_name.lower()
780 
781 
782 class AddIndex(IndexOperation):
783     """Add an index on a model."""
784 
785     def __init__(self, model_name, index):
786         self.model_name = model_name
787         if not index.name:
788             raise ValueError(
789                 "Indexes passed to AddIndex operations require a name "
790                 "argument. %r doesn't have one." % index
791             )
792         self.index = index
793 
794     def state_forwards(self, app_label, state):
795         state.add_index(app_label, self.model_name_lower, self.index)
796 
797     def database_forwards(self, app_label, schema_editor, from_state, to_state):
798         model = to_state.apps.get_model(app_label, self.model_name)
799         if self.allow_migrate_model(schema_editor.connection.alias, model):
800             schema_editor.add_index(model, self.index)
801 
802     def database_backwards(self, app_label, schema_editor, from_state, to_state):
803         model = from_state.apps.get_model(app_label, self.model_name)
804         if self.allow_migrate_model(schema_editor.connection.alias, model):
805             schema_editor.remove_index(model, self.index)
806 
807     def deconstruct(self):
808         kwargs = {
809             "model_name": self.model_name,
810             "index": self.index,
811         }
812         return (
813             self.__class__.__qualname__,
814             [],
815             kwargs,
816         )
817 
818     def describe(self):
819         if self.index.expressions:
820             return "Create index %s on %s on model %s" % (
821                 self.index.name,
822                 ", ".join([str(expression) for expression in self.index.expressions]),
823                 self.model_name,
824             )
825         return "Create index %s on field(s) %s of model %s" % (
826             self.index.name,
827             ", ".join(self.index.fields),
828             self.model_name,
829         )
830 
831     @property
832     def migration_name_fragment(self):
833         return "%s_%s" % (self.model_name_lower, self.index.name.lower())
834 
835 
836 class RemoveIndex(IndexOperation):
837     """Remove an index from a model."""
838 
839     def __init__(self, model_name, name):
840         self.model_name = model_name
841         self.name = name
842 
843     def state_forwards(self, app_label, state):
844         state.remove_index(app_label, self.model_name_lower, self.name)
845 
846     def database_forwards(self, app_label, schema_editor, from_state, to_state):
847         model = from_state.apps.get_model(app_label, self.model_name)
848         if self.allow_migrate_model(schema_editor.connection.alias, model):
849             from_model_state = from_state.models[app_label, self.model_name_lower]
850             index = from_model_state.get_index_by_name(self.name)
851             schema_editor.remove_index(model, index)
852 
853     def database_backwards(self, app_label, schema_editor, from_state, to_state):
854         model = to_state.apps.get_model(app_label, self.model_name)
855         if self.allow_migrate_model(schema_editor.connection.alias, model):
856             to_model_state = to_state.models[app_label, self.model_name_lower]
857             index = to_model_state.get_index_by_name(self.name)
858             schema_editor.add_index(model, index)
859 
860     def deconstruct(self):
861         kwargs = {
862             "model_name": self.model_name,
863             "name": self.name,
864         }
865         return (
866             self.__class__.__qualname__,
867             [],
868             kwargs,
869         )
870 
871     def describe(self):
872         return "Remove index %s from %s" % (self.name, self.model_name)
873 
874     @property
875     def migration_name_fragment(self):
876         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())
877 
878 
879 class AddConstraint(IndexOperation):
880     option_name = "constraints"
881 
882     def __init__(self, model_name, constraint):
883         self.model_name = model_name
884         self.constraint = constraint
885 
886     def state_forwards(self, app_label, state):
887         state.add_constraint(app_label, self.model_name_lower, self.constraint)
888 
889     def database_forwards(self, app_label, schema_editor, from_state, to_state):
890         model = to_state.apps.get_model(app_label, self.model_name)
891         if self.allow_migrate_model(schema_editor.connection.alias, model):
892             schema_editor.add_constraint(model, self.constraint)
893 
894     def database_backwards(self, app_label, schema_editor, from_state, to_state):
895         model = to_state.apps.get_model(app_label, self.model_name)
896         if self.allow_migrate_model(schema_editor.connection.alias, model):
897             schema_editor.remove_constraint(model, self.constraint)
898 
899     def deconstruct(self):
900         return (
901             self.__class__.__name__,
902             [],
903             {
904                 "model_name": self.model_name,
905                 "constraint": self.constraint,
906             },
907         )
908 
909     def describe(self):
910         return "Create constraint %s on model %s" % (
911             self.constraint.name,
912             self.model_name,
913         )
914 
915     @property
916     def migration_name_fragment(self):
917         return "%s_%s" % (self.model_name_lower, self.constraint.name.lower())
918 
919 
920 class RemoveConstraint(IndexOperation):
921     option_name = "constraints"
922 
923     def __init__(self, model_name, name):
924         self.model_name = model_name
925         self.name = name
926 
927     def state_forwards(self, app_label, state):
928         state.remove_constraint(app_label, self.model_name_lower, self.name)
929 
930     def database_forwards(self, app_label, schema_editor, from_state, to_state):
931         model = to_state.apps.get_model(app_label, self.model_name)
932         if self.allow_migrate_model(schema_editor.connection.alias, model):
933             from_model_state = from_state.models[app_label, self.model_name_lower]
934             constraint = from_model_state.get_constraint_by_name(self.name)
935             schema_editor.remove_constraint(model, constraint)
936 
937     def database_backwards(self, app_label, schema_editor, from_state, to_state):
938         model = to_state.apps.get_model(app_label, self.model_name)
939         if self.allow_migrate_model(schema_editor.connection.alias, model):
940             to_model_state = to_state.models[app_label, self.model_name_lower]
941             constraint = to_model_state.get_constraint_by_name(self.name)
942             schema_editor.add_constraint(model, constraint)
943 
944     def deconstruct(self):
945         return (
946             self.__class__.__name__,
947             [],
948             {
949                 "model_name": self.model_name,
950                 "name": self.name,
951             },
952         )
953 
954     def describe(self):
955         return "Remove constraint %s from model %s" % (self.name, self.model_name)
956 
957     @property
958     def migration_name_fragment(self):
959         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())

</code><intended_behavior>Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key.</intended_behavior>, <file>django/db/migrations/state.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from collections import defaultdict
3 from contextlib import contextmanager
4 from functools import partial
5 
6 from django.apps import AppConfig
7 from django.apps.registry import Apps
8 from django.apps.registry import apps as global_apps
9 from django.conf import settings
10 from django.core.exceptions import FieldDoesNotExist
11 from django.db import models
12 from django.db.migrations.utils import field_is_referenced, get_references
13 from django.db.models import NOT_PROVIDED
14 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT
15 from django.db.models.options import DEFAULT_NAMES, normalize_together
16 from django.db.models.utils import make_model_tuple
17 from django.utils.functional import cached_property
18 from django.utils.module_loading import import_string
19 from django.utils.version import get_docs_version
20 
21 from .exceptions import InvalidBasesError
22 from .utils import resolve_relation
23 
24 
25 def _get_app_label_and_model_name(model, app_label=""):
26     if isinstance(model, str):
27         split = model.split(".", 1)
28         return tuple(split) if len(split) == 2 else (app_label, split[0])
29     else:
30         return model._meta.app_label, model._meta.model_name
31 
32 
33 def _get_related_models(m):
34     """Return all models that have a direct relationship to the given model."""
35     related_models = [
36         subclass
37         for subclass in m.__subclasses__()
38         if issubclass(subclass, models.Model)
39     ]
40     related_fields_models = set()
41     for f in m._meta.get_fields(include_parents=True, include_hidden=True):
42         if (
43             f.is_relation
44             and f.related_model is not None
45             and not isinstance(f.related_model, str)
46         ):
47             related_fields_models.add(f.model)
48             related_models.append(f.related_model)
49     # Reverse accessors of foreign keys to proxy models are attached to their
50     # concrete proxied model.
51     opts = m._meta
52     if opts.proxy and m in related_fields_models:
53         related_models.append(opts.concrete_model)
54     return related_models
55 
56 
57 def get_related_models_tuples(model):
58     """
59     Return a list of typical (app_label, model_name) tuples for all related
60     models for the given model.
61     """
62     return {
63         (rel_mod._meta.app_label, rel_mod._meta.model_name)
64         for rel_mod in _get_related_models(model)
65     }
66 
67 
68 def get_related_models_recursive(model):
69     """
70     Return all models that have a direct or indirect relationship
71     to the given model.
72 
73     Relationships are either defined by explicit relational fields, like
74     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
75     model (a superclass is related to its subclasses, but not vice versa). Note,
76     however, that a model inheriting from a concrete model is also related to
77     its superclass through the implicit *_ptr OneToOneField on the subclass.
78     """
79     seen = set()
80     queue = _get_related_models(model)
81     for rel_mod in queue:
82         rel_app_label, rel_model_name = (
83             rel_mod._meta.app_label,
84             rel_mod._meta.model_name,
85         )
86         if (rel_app_label, rel_model_name) in seen:
87             continue
88         seen.add((rel_app_label, rel_model_name))
89         queue.extend(_get_related_models(rel_mod))
90     return seen - {(model._meta.app_label, model._meta.model_name)}
91 
92 
93 class ProjectState:
94     """
95     Represent the entire project's overall state. This is the item that is
96     passed around - do it here rather than at the app level so that cross-app
97     FKs/etc. resolve properly.
98     """
99 
100     def __init__(self, models=None, real_apps=None):
101         self.models = models or {}
102         # Apps to include from main registry, usually unmigrated ones
103         if real_apps is None:
104             real_apps = set()
105         else:
106             assert isinstance(real_apps, set)
107         self.real_apps = real_apps
108         self.is_delayed = False
109         # {remote_model_key: {model_key: {field_name: field}}}
110         self._relations = None
111 
112     @property
113     def relations(self):
114         if self._relations is None:
115             self.resolve_fields_and_relations()
116         return self._relations
117 
118     def add_model(self, model_state):
119         model_key = model_state.app_label, model_state.name_lower
120         self.models[model_key] = model_state
121         if self._relations is not None:
122             self.resolve_model_relations(model_key)
123         if "apps" in self.__dict__:  # hasattr would cache the property
124             self.reload_model(*model_key)
125 
126     def remove_model(self, app_label, model_name):
127         model_key = app_label, model_name
128         del self.models[model_key]
129         if self._relations is not None:
130             self._relations.pop(model_key, None)
131             # Call list() since _relations can change size during iteration.
132             for related_model_key, model_relations in list(self._relations.items()):
133                 model_relations.pop(model_key, None)
134                 if not model_relations:
135                     del self._relations[related_model_key]
136         if "apps" in self.__dict__:  # hasattr would cache the property
137             self.apps.unregister_model(*model_key)
138             # Need to do this explicitly since unregister_model() doesn't clear
139             # the cache automatically (#24513)
140             self.apps.clear_cache()
141 
142     def rename_model(self, app_label, old_name, new_name):
143         # Add a new model.
144         old_name_lower = old_name.lower()
145         new_name_lower = new_name.lower()
146         renamed_model = self.models[app_label, old_name_lower].clone()
147         renamed_model.name = new_name
148         self.models[app_label, new_name_lower] = renamed_model
149         # Repoint all fields pointing to the old model to the new one.
150         old_model_tuple = (app_label, old_name_lower)
151         new_remote_model = f"{app_label}.{new_name}"
152         to_reload = set()
153         for model_state, name, field, reference in get_references(
154             self, old_model_tuple
155         ):
156             changed_field = None
157             if reference.to:
158                 changed_field = field.clone()
159                 changed_field.remote_field.model = new_remote_model
160             if reference.through:
161                 if changed_field is None:
162                     changed_field = field.clone()
163                 changed_field.remote_field.through = new_remote_model
164             if changed_field:
165                 model_state.fields[name] = changed_field
166                 to_reload.add((model_state.app_label, model_state.name_lower))
167         if self._relations is not None:
168             old_name_key = app_label, old_name_lower
169             new_name_key = app_label, new_name_lower
170             if old_name_key in self._relations:
171                 self._relations[new_name_key] = self._relations.pop(old_name_key)
172             for model_relations in self._relations.values():
173                 if old_name_key in model_relations:
174                     model_relations[new_name_key] = model_relations.pop(old_name_key)
175         # Reload models related to old model before removing the old model.
176         self.reload_models(to_reload, delay=True)
177         # Remove the old model.
178         self.remove_model(app_label, old_name_lower)
179         self.reload_model(app_label, new_name_lower, delay=True)
180 
181     def alter_model_options(self, app_label, model_name, options, option_keys=None):
182         model_state = self.models[app_label, model_name]
183         model_state.options = {**model_state.options, **options}
184         if option_keys:
185             for key in option_keys:
186                 if key not in options:
187                     model_state.options.pop(key, False)
188         self.reload_model(app_label, model_name, delay=True)
189 
190     def alter_model_managers(self, app_label, model_name, managers):
191         model_state = self.models[app_label, model_name]
192         model_state.managers = list(managers)
193         self.reload_model(app_label, model_name, delay=True)
194 
195     def _append_option(self, app_label, model_name, option_name, obj):
196         model_state = self.models[app_label, model_name]
197         model_state.options[option_name] = [*model_state.options[option_name], obj]
198         self.reload_model(app_label, model_name, delay=True)
199 
200     def _remove_option(self, app_label, model_name, option_name, obj_name):
201         model_state = self.models[app_label, model_name]
202         objs = model_state.options[option_name]
203         model_state.options[option_name] = [obj for obj in objs if obj.name != obj_name]
204         self.reload_model(app_label, model_name, delay=True)
205 
206     def add_index(self, app_label, model_name, index):
207         self._append_option(app_label, model_name, "indexes", index)
208 
209     def remove_index(self, app_label, model_name, index_name):
210         self._remove_option(app_label, model_name, "indexes", index_name)
211 
212     def add_constraint(self, app_label, model_name, constraint):
213         self._append_option(app_label, model_name, "constraints", constraint)
214 
215     def remove_constraint(self, app_label, model_name, constraint_name):
216         self._remove_option(app_label, model_name, "constraints", constraint_name)
217 
218     def add_field(self, app_label, model_name, name, field, preserve_default):
219         # If preserve default is off, don't use the default for future state.
220         if not preserve_default:
221             field = field.clone()
222             field.default = NOT_PROVIDED
223         else:
224             field = field
225         model_key = app_label, model_name
226         self.models[model_key].fields[name] = field
227         if self._relations is not None:
228             self.resolve_model_field_relations(model_key, name, field)
229         # Delay rendering of relationships if it's not a relational field.
230         delay = not field.is_relation
231         self.reload_model(*model_key, delay=delay)
232 
233     def remove_field(self, app_label, model_name, name):
234         model_key = app_label, model_name
235         model_state = self.models[model_key]
236         old_field = model_state.fields.pop(name)
237         if self._relations is not None:
238             self.resolve_model_field_relations(model_key, name, old_field)
239         # Delay rendering of relationships if it's not a relational field.
240         delay = not old_field.is_relation
241         self.reload_model(*model_key, delay=delay)
242 
243     def alter_field(self, app_label, model_name, name, field, preserve_default):
244         if not preserve_default:
245             field = field.clone()
246             field.default = NOT_PROVIDED
247         else:
248             field = field
249         model_key = app_label, model_name
250         fields = self.models[model_key].fields
251         if self._relations is not None:
252             old_field = fields.pop(name)
253             if old_field.is_relation:
254                 self.resolve_model_field_relations(model_key, name, old_field)
255             fields[name] = field
256             if field.is_relation:
257                 self.resolve_model_field_relations(model_key, name, field)
258         else:
259             fields[name] = field
260         # TODO: investigate if old relational fields must be reloaded or if
261         # it's sufficient if the new field is (#27737).
262         # Delay rendering of relationships if it's not a relational field and
263         # not referenced by a foreign key.
264         delay = not field.is_relation and not field_is_referenced(
265             self, model_key, (name, field)
266         )
267         self.reload_model(*model_key, delay=delay)
268 
269     def rename_field(self, app_label, model_name, old_name, new_name):
270         model_key = app_label, model_name
271         model_state = self.models[model_key]
272         # Rename the field.
273         fields = model_state.fields
274         try:
275             found = fields.pop(old_name)
276         except KeyError:
277             raise FieldDoesNotExist(
278                 f"{app_label}.{model_name} has no field named '{old_name}'"
279             )
280         fields[new_name] = found
281         for field in fields.values():
282             # Fix from_fields to refer to the new field.
283             from_fields = getattr(field, "from_fields", None)
284             if from_fields:
285                 field.from_fields = tuple(
286                     [
287                         new_name if from_field_name == old_name else from_field_name
288                         for from_field_name in from_fields
289                     ]
290                 )
291         # Fix index/unique_together to refer to the new field.
292         options = model_state.options
293         for option in ("index_together", "unique_together"):
294             if option in options:
295                 options[option] = [
296                     [new_name if n == old_name else n for n in together]
297                     for together in options[option]
298                 ]
299         # Fix to_fields to refer to the new field.
300         delay = True
301         references = get_references(self, model_key, (old_name, found))
302         for *_, field, reference in references:
303             delay = False
304             if reference.to:
305                 remote_field, to_fields = reference.to
306                 if getattr(remote_field, "field_name", None) == old_name:
307                     remote_field.field_name = new_name
308                 if to_fields:
309                     field.to_fields = tuple(
310                         [
311                             new_name if to_field_name == old_name else to_field_name
312                             for to_field_name in to_fields
313                         ]
314                     )
315         if self._relations is not None:
316             old_name_lower = old_name.lower()
317             new_name_lower = new_name.lower()
318             for to_model in self._relations.values():
319                 if old_name_lower in to_model[model_key]:
320                     field = to_model[model_key].pop(old_name_lower)
321                     field.name = new_name_lower
322                     to_model[model_key][new_name_lower] = field
323         self.reload_model(*model_key, delay=delay)
324 
325     def _find_reload_model(self, app_label, model_name, delay=False):
326         if delay:
327             self.is_delayed = True
328 
329         related_models = set()
330 
331         try:
332             old_model = self.apps.get_model(app_label, model_name)
333         except LookupError:
334             pass
335         else:
336             # Get all relations to and from the old model before reloading,
337             # as _meta.apps may change
338             if delay:
339                 related_models = get_related_models_tuples(old_model)
340             else:
341                 related_models = get_related_models_recursive(old_model)
342 
343         # Get all outgoing references from the model to be rendered
344         model_state = self.models[(app_label, model_name)]
345         # Directly related models are the models pointed to by ForeignKeys,
346         # OneToOneFields, and ManyToManyFields.
347         direct_related_models = set()
348         for field in model_state.fields.values():
349             if field.is_relation:
350                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:
351                     continue
352                 rel_app_label, rel_model_name = _get_app_label_and_model_name(
353                     field.related_model, app_label
354                 )
355                 direct_related_models.add((rel_app_label, rel_model_name.lower()))
356 
357         # For all direct related models recursively get all related models.
358         related_models.update(direct_related_models)
359         for rel_app_label, rel_model_name in direct_related_models:
360             try:
361                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)
362             except LookupError:
363                 pass
364             else:
365                 if delay:
366                     related_models.update(get_related_models_tuples(rel_model))
367                 else:
368                     related_models.update(get_related_models_recursive(rel_model))
369 
370         # Include the model itself
371         related_models.add((app_label, model_name))
372 
373         return related_models
374 
375     def reload_model(self, app_label, model_name, delay=False):
376         if "apps" in self.__dict__:  # hasattr would cache the property
377             related_models = self._find_reload_model(app_label, model_name, delay)
378             self._reload(related_models)
379 
380     def reload_models(self, models, delay=True):
381         if "apps" in self.__dict__:  # hasattr would cache the property
382             related_models = set()
383             for app_label, model_name in models:
384                 related_models.update(
385                     self._find_reload_model(app_label, model_name, delay)
386                 )
387             self._reload(related_models)
388 
389     def _reload(self, related_models):
390         # Unregister all related models
391         with self.apps.bulk_update():
392             for rel_app_label, rel_model_name in related_models:
393                 self.apps.unregister_model(rel_app_label, rel_model_name)
394 
395         states_to_be_rendered = []
396         # Gather all models states of those models that will be rerendered.
397         # This includes:
398         # 1. All related models of unmigrated apps
399         for model_state in self.apps.real_models:
400             if (model_state.app_label, model_state.name_lower) in related_models:
401                 states_to_be_rendered.append(model_state)
402 
403         # 2. All related models of migrated apps
404         for rel_app_label, rel_model_name in related_models:
405             try:
406                 model_state = self.models[rel_app_label, rel_model_name]
407             except KeyError:
408                 pass
409             else:
410                 states_to_be_rendered.append(model_state)
411 
412         # Render all models
413         self.apps.render_multiple(states_to_be_rendered)
414 
415     def update_model_field_relation(
416         self,
417         model,
418         model_key,
419         field_name,
420         field,
421         concretes,
422     ):
423         remote_model_key = resolve_relation(model, *model_key)
424         if remote_model_key[0] not in self.real_apps and remote_model_key in concretes:
425             remote_model_key = concretes[remote_model_key]
426         relations_to_remote_model = self._relations[remote_model_key]
427         if field_name in self.models[model_key].fields:
428             # The assert holds because it's a new relation, or an altered
429             # relation, in which case references have been removed by
430             # alter_field().
431             assert field_name not in relations_to_remote_model[model_key]
432             relations_to_remote_model[model_key][field_name] = field
433         else:
434             del relations_to_remote_model[model_key][field_name]
435             if not relations_to_remote_model[model_key]:
436                 del relations_to_remote_model[model_key]
437 
438     def resolve_model_field_relations(
439         self,
440         model_key,
441         field_name,
442         field,
443         concretes=None,
444     ):
445         remote_field = field.remote_field
446         if not remote_field:
447             return
448         if concretes is None:
449             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()
450 
451         self.update_model_field_relation(
452             remote_field.model,
453             model_key,
454             field_name,
455             field,
456             concretes,
457         )
458 
459         through = getattr(remote_field, "through", None)
460         if not through:
461             return
462         self.update_model_field_relation(
463             through, model_key, field_name, field, concretes
464         )
465 
466     def resolve_model_relations(self, model_key, concretes=None):
467         if concretes is None:
468             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()
469 
470         model_state = self.models[model_key]
471         for field_name, field in model_state.fields.items():
472             self.resolve_model_field_relations(model_key, field_name, field, concretes)
473 
474     def resolve_fields_and_relations(self):
475         # Resolve fields.
476         for model_state in self.models.values():
477             for field_name, field in model_state.fields.items():
478                 field.name = field_name
479         # Resolve relations.
480         # {remote_model_key: {model_key: {field_name: field}}}
481         self._relations = defaultdict(partial(defaultdict, dict))
482         concretes, proxies = self._get_concrete_models_mapping_and_proxy_models()
483 
484         for model_key in concretes:
485             self.resolve_model_relations(model_key, concretes)
486 
487         for model_key in proxies:
488             self._relations[model_key] = self._relations[concretes[model_key]]
489 
490     def get_concrete_model_key(self, model):
491         (
492             concrete_models_mapping,
493             _,
494         ) = self._get_concrete_models_mapping_and_proxy_models()
495         model_key = make_model_tuple(model)
496         return concrete_models_mapping[model_key]
497 
498     def _get_concrete_models_mapping_and_proxy_models(self):
499         concrete_models_mapping = {}
500         proxy_models = {}
501         # Split models to proxy and concrete models.
502         for model_key, model_state in self.models.items():
503             if model_state.options.get("proxy"):
504                 proxy_models[model_key] = model_state
505                 # Find a concrete model for the proxy.
506                 concrete_models_mapping[
507                     model_key
508                 ] = self._find_concrete_model_from_proxy(
509                     proxy_models,
510                     model_state,
511                 )
512             else:
513                 concrete_models_mapping[model_key] = model_key
514         return concrete_models_mapping, proxy_models
515 
516     def _find_concrete_model_from_proxy(self, proxy_models, model_state):
517         for base in model_state.bases:
518             if not (isinstance(base, str) or issubclass(base, models.Model)):
519                 continue
520             base_key = make_model_tuple(base)
521             base_state = proxy_models.get(base_key)
522             if not base_state:
523                 # Concrete model found, stop looking at bases.
524                 return base_key
525             return self._find_concrete_model_from_proxy(proxy_models, base_state)
526 
527     def clone(self):
528         """Return an exact copy of this ProjectState."""
529         new_state = ProjectState(
530             models={k: v.clone() for k, v in self.models.items()},
531             real_apps=self.real_apps,
532         )
533         if "apps" in self.__dict__:
534             new_state.apps = self.apps.clone()
535         new_state.is_delayed = self.is_delayed
536         return new_state
537 
538     def clear_delayed_apps_cache(self):
539         if self.is_delayed and "apps" in self.__dict__:
540             del self.__dict__["apps"]
541 
542     @cached_property
543     def apps(self):
544         return StateApps(self.real_apps, self.models)
545 
546     @classmethod
547     def from_apps(cls, apps):
548         """Take an Apps and return a ProjectState matching it."""
549         app_models = {}
550         for model in apps.get_models(include_swapped=True):
551             model_state = ModelState.from_model(model)
552             app_models[(model_state.app_label, model_state.name_lower)] = model_state
553         return cls(app_models)
554 
555     def __eq__(self, other):
556         return self.models == other.models and self.real_apps == other.real_apps
557 
558 
559 class AppConfigStub(AppConfig):
560     """Stub of an AppConfig. Only provides a label and a dict of models."""
561 
562     def __init__(self, label):
563         self.apps = None
564         self.models = {}
565         # App-label and app-name are not the same thing, so technically passing
566         # in the label here is wrong. In practice, migrations don't care about
567         # the app name, but we need something unique, and the label works fine.
568         self.label = label
569         self.name = label
570 
571     def import_models(self):
572         self.models = self.apps.all_models[self.label]
573 
574 
575 class StateApps(Apps):
576     """
577     Subclass of the global Apps registry class to better handle dynamic model
578     additions and removals.
579     """
580 
581     def __init__(self, real_apps, models, ignore_swappable=False):
582         # Any apps in self.real_apps should have all their models included
583         # in the render. We don't use the original model instances as there
584         # are some variables that refer to the Apps object.
585         # FKs/M2Ms from real apps are also not included as they just
586         # mess things up with partial states (due to lack of dependencies)
587         self.real_models = []
588         for app_label in real_apps:
589             app = global_apps.get_app_config(app_label)
590             for model in app.get_models():
591                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))
592         # Populate the app registry with a stub for each application.
593         app_labels = {model_state.app_label for model_state in models.values()}
594         app_configs = [
595             AppConfigStub(label) for label in sorted([*real_apps, *app_labels])
596         ]
597         super().__init__(app_configs)
598 
599         # These locks get in the way of copying as implemented in clone(),
600         # which is called whenever Django duplicates a StateApps before
601         # updating it.
602         self._lock = None
603         self.ready_event = None
604 
605         self.render_multiple([*models.values(), *self.real_models])
606 
607         # There shouldn't be any operations pending at this point.
608         from django.core.checks.model_checks import _check_lazy_references
609 
610         ignore = (
611             {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()
612         )
613         errors = _check_lazy_references(self, ignore=ignore)
614         if errors:
615             raise ValueError("\n".join(error.msg for error in errors))
616 
617     @contextmanager
618     def bulk_update(self):
619         # Avoid clearing each model's cache for each change. Instead, clear
620         # all caches when we're finished updating the model instances.
621         ready = self.ready
622         self.ready = False
623         try:
624             yield
625         finally:
626             self.ready = ready
627             self.clear_cache()
628 
629     def render_multiple(self, model_states):
630         # We keep trying to render the models in a loop, ignoring invalid
631         # base errors, until the size of the unrendered models doesn't
632         # decrease by at least one, meaning there's a base dependency loop/
633         # missing base.
634         if not model_states:
635             return
636         # Prevent that all model caches are expired for each render.
637         with self.bulk_update():
638             unrendered_models = model_states
639             while unrendered_models:
640                 new_unrendered_models = []
641                 for model in unrendered_models:
642                     try:
643                         model.render(self)
644                     except InvalidBasesError:
645                         new_unrendered_models.append(model)
646                 if len(new_unrendered_models) == len(unrendered_models):
647                     raise InvalidBasesError(
648                         "Cannot resolve bases for %r\nThis can happen if you are "
649                         "inheriting models from an app with migrations (e.g. "
650                         "contrib.auth)\n in an app with no migrations; see "
651                         "https://docs.djangoproject.com/en/%s/topics/migrations/"
652                         "#dependencies for more"
653                         % (new_unrendered_models, get_docs_version())
654                     )
655                 unrendered_models = new_unrendered_models
656 
657     def clone(self):
658         """Return a clone of this registry."""
659         clone = StateApps([], {})
660         clone.all_models = copy.deepcopy(self.all_models)
661         clone.app_configs = copy.deepcopy(self.app_configs)
662         # Set the pointer to the correct app registry.
663         for app_config in clone.app_configs.values():
664             app_config.apps = clone
665         # No need to actually clone them, they'll never change
666         clone.real_models = self.real_models
667         return clone
668 
669     def register_model(self, app_label, model):
670         self.all_models[app_label][model._meta.model_name] = model
671         if app_label not in self.app_configs:
672             self.app_configs[app_label] = AppConfigStub(app_label)
673             self.app_configs[app_label].apps = self
674         self.app_configs[app_label].models[model._meta.model_name] = model
675         self.do_pending_operations(model)
676         self.clear_cache()
677 
678     def unregister_model(self, app_label, model_name):
679         try:
680             del self.all_models[app_label][model_name]
681             del self.app_configs[app_label].models[model_name]
682         except KeyError:
683             pass
684 
685 
686 class ModelState:
687     """
688     Represent a Django Model. Don't use the actual Model class as it's not
689     designed to have its options changed - instead, mutate this one and then
690     render it into a Model as required.
691 
692     Note that while you are allowed to mutate .fields, you are not allowed
693     to mutate the Field instances inside there themselves - you must instead
694     assign new ones, as these are not detached during a clone.
695     """
696 
697     def __init__(
698         self, app_label, name, fields, options=None, bases=None, managers=None
699     ):
700         self.app_label = app_label
701         self.name = name
702         self.fields = dict(fields)
703         self.options = options or {}
704         self.options.setdefault("indexes", [])
705         self.options.setdefault("constraints", [])
706         self.bases = bases or (models.Model,)
707         self.managers = managers or []
708         for name, field in self.fields.items():
709             # Sanity-check that fields are NOT already bound to a model.
710             if hasattr(field, "model"):
711                 raise ValueError(
712                     'ModelState.fields cannot be bound to a model - "%s" is.' % name
713                 )
714             # Sanity-check that relation fields are NOT referring to a model class.
715             if field.is_relation and hasattr(field.related_model, "_meta"):
716                 raise ValueError(
717                     'ModelState.fields cannot refer to a model class - "%s.to" does. '
718                     "Use a string reference instead." % name
719                 )
720             if field.many_to_many and hasattr(field.remote_field.through, "_meta"):
721                 raise ValueError(
722                     'ModelState.fields cannot refer to a model class - "%s.through" '
723                     "does. Use a string reference instead." % name
724                 )
725         # Sanity-check that indexes have their name set.
726         for index in self.options["indexes"]:
727             if not index.name:
728                 raise ValueError(
729                     "Indexes passed to ModelState require a name attribute. "
730                     "%r doesn't have one." % index
731                 )
732 
733     @cached_property
734     def name_lower(self):
735         return self.name.lower()
736 
737     def get_field(self, field_name):
738         if field_name == "_order":
739             field_name = self.options.get("order_with_respect_to", field_name)
740         return self.fields[field_name]
741 
742     @classmethod
743     def from_model(cls, model, exclude_rels=False):
744         """Given a model, return a ModelState representing it."""
745         # Deconstruct the fields
746         fields = []
747         for field in model._meta.local_fields:
748             if getattr(field, "remote_field", None) and exclude_rels:
749                 continue
750             if isinstance(field, models.OrderWrt):
751                 continue
752             name = field.name
753             try:
754                 fields.append((name, field.clone()))
755             except TypeError as e:
756                 raise TypeError(
757                     "Couldn't reconstruct field %s on %s: %s"
758                     % (
759                         name,
760                         model._meta.label,
761                         e,
762                     )
763                 )
764         if not exclude_rels:
765             for field in model._meta.local_many_to_many:
766                 name = field.name
767                 try:
768                     fields.append((name, field.clone()))
769                 except TypeError as e:
770                     raise TypeError(
771                         "Couldn't reconstruct m2m field %s on %s: %s"
772                         % (
773                             name,
774                             model._meta.object_name,
775                             e,
776                         )
777                     )
778         # Extract the options
779         options = {}
780         for name in DEFAULT_NAMES:
781             # Ignore some special options
782             if name in ["apps", "app_label"]:
783                 continue
784             elif name in model._meta.original_attrs:
785                 if name == "unique_together":
786                     ut = model._meta.original_attrs["unique_together"]
787                     options[name] = set(normalize_together(ut))
788                 elif name == "index_together":
789                     it = model._meta.original_attrs["index_together"]
790                     options[name] = set(normalize_together(it))
791                 elif name == "indexes":
792                     indexes = [idx.clone() for idx in model._meta.indexes]
793                     for index in indexes:
794                         if not index.name:
795                             index.set_name_with_model(model)
796                     options["indexes"] = indexes
797                 elif name == "constraints":
798                     options["constraints"] = [
799                         con.clone() for con in model._meta.constraints
800                     ]
801                 else:
802                     options[name] = model._meta.original_attrs[name]
803         # If we're ignoring relationships, remove all field-listing model
804         # options (that option basically just means "make a stub model")
805         if exclude_rels:
806             for key in ["unique_together", "index_together", "order_with_respect_to"]:
807                 if key in options:
808                     del options[key]
809         # Private fields are ignored, so remove options that refer to them.
810         elif options.get("order_with_respect_to") in {
811             field.name for field in model._meta.private_fields
812         }:
813             del options["order_with_respect_to"]
814 
815         def flatten_bases(model):
816             bases = []
817             for base in model.__bases__:
818                 if hasattr(base, "_meta") and base._meta.abstract:
819                     bases.extend(flatten_bases(base))
820                 else:
821                     bases.append(base)
822             return bases
823 
824         # We can't rely on __mro__ directly because we only want to flatten
825         # abstract models and not the whole tree. However by recursing on
826         # __bases__ we may end up with duplicates and ordering issues, we
827         # therefore discard any duplicates and reorder the bases according
828         # to their index in the MRO.
829         flattened_bases = sorted(
830             set(flatten_bases(model)), key=lambda x: model.__mro__.index(x)
831         )
832 
833         # Make our record
834         bases = tuple(
835             (base._meta.label_lower if hasattr(base, "_meta") else base)
836             for base in flattened_bases
837         )
838         # Ensure at least one base inherits from models.Model
839         if not any(
840             (isinstance(base, str) or issubclass(base, models.Model)) for base in bases
841         ):
842             bases = (models.Model,)
843 
844         managers = []
845         manager_names = set()
846         default_manager_shim = None
847         for manager in model._meta.managers:
848             if manager.name in manager_names:
849                 # Skip overridden managers.
850                 continue
851             elif manager.use_in_migrations:
852                 # Copy managers usable in migrations.
853                 new_manager = copy.copy(manager)
854                 new_manager._set_creation_counter()
855             elif manager is model._base_manager or manager is model._default_manager:
856                 # Shim custom managers used as default and base managers.
857                 new_manager = models.Manager()
858                 new_manager.model = manager.model
859                 new_manager.name = manager.name
860                 if manager is model._default_manager:
861                     default_manager_shim = new_manager
862             else:
863                 continue
864             manager_names.add(manager.name)
865             managers.append((manager.name, new_manager))
866 
867         # Ignore a shimmed default manager called objects if it's the only one.
868         if managers == [("objects", default_manager_shim)]:
869             managers = []
870 
871         # Construct the new ModelState
872         return cls(
873             model._meta.app_label,
874             model._meta.object_name,
875             fields,
876             options,
877             bases,
878             managers,
879         )
880 
881     def construct_managers(self):
882         """Deep-clone the managers using deconstruction."""
883         # Sort all managers by their creation counter
884         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)
885         for mgr_name, manager in sorted_managers:
886             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()
887             if as_manager:
888                 qs_class = import_string(qs_path)
889                 yield mgr_name, qs_class.as_manager()
890             else:
891                 manager_class = import_string(manager_path)
892                 yield mgr_name, manager_class(*args, **kwargs)
893 
894     def clone(self):
895         """Return an exact copy of this ModelState."""
896         return self.__class__(
897             app_label=self.app_label,
898             name=self.name,
899             fields=dict(self.fields),
900             # Since options are shallow-copied here, operations such as
901             # AddIndex must replace their option (e.g 'indexes') rather
902             # than mutating it.
903             options=dict(self.options),
904             bases=self.bases,
905             managers=list(self.managers),
906         )
907 
908     def render(self, apps):
909         """Create a Model object from our current state into the given apps."""
910         # First, make a Meta object
911         meta_contents = {"app_label": self.app_label, "apps": apps, **self.options}
912         meta = type("Meta", (), meta_contents)
913         # Then, work out our bases
914         try:
915             bases = tuple(
916                 (apps.get_model(base) if isinstance(base, str) else base)
917                 for base in self.bases
918             )
919         except LookupError:
920             raise InvalidBasesError(
921                 "Cannot resolve one or more bases from %r" % (self.bases,)
922             )
923         # Clone fields for the body, add other bits.
924         body = {name: field.clone() for name, field in self.fields.items()}
925         body["Meta"] = meta
926         body["__module__"] = "__fake__"
927 
928         # Restore managers
929         body.update(self.construct_managers())
930         # Then, make a Model object (apps.register_model is called in __new__)
931         return type(self.name, bases, body)
932 
933     def get_index_by_name(self, name):
934         for index in self.options["indexes"]:
935             if index.name == name:
936                 return index
937         raise ValueError("No index named %s on model %s" % (name, self.name))
938 
939     def get_constraint_by_name(self, name):
940         for constraint in self.options["constraints"]:
941             if constraint.name == name:
942                 return constraint
943         raise ValueError("No constraint named %s on model %s" % (name, self.name))
944 
945     def __repr__(self):
946         return "<%s: '%s.%s'>" % (self.__class__.__name__, self.app_label, self.name)
947 
948     def __eq__(self, other):
949         return (
950             (self.app_label == other.app_label)
951             and (self.name == other.name)
952             and (len(self.fields) == len(other.fields))
953             and all(
954                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]
955                 for (k1, f1), (k2, f2) in zip(
956                     sorted(self.fields.items()),
957                     sorted(other.fields.items()),
958                 )
959             )
960             and (self.options == other.options)
961             and (self.bases == other.bases)
962             and (self.managers == other.managers)
963         )

</code><intended_behavior>Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key.</intended_behavior>]
2025-10-17 11:14:38.325 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute,
23     ForwardManyToOneDescriptor,
24     ForwardOneToOneDescriptor,
25     ManyToManyDescriptor,
26     ReverseManyToOneDescriptor,
27     ReverseOneToOneDescriptor,
28 )
29 from .related_lookups import (
30     RelatedExact,
31     RelatedGreaterThan,
32     RelatedGreaterThanOrEqual,
33     RelatedIn,
34     RelatedIsNull,
35     RelatedLessThan,
36     RelatedLessThanOrEqual,
37 )
38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
39 
40 RECURSIVE_RELATIONSHIP_CONSTANT = "self"
41 
42 
43 def resolve_relation(scope_model, relation):
44     """
45     Transform relation into a model or fully-qualified model string of the form
46     "app_label.ModelName", relative to scope_model.
47 
48     The relation argument can be:
49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
50         the model argument will be returned.
51       * A bare model name without an app_label, in which case scope_model's
52         app_label will be prepended.
53       * An "app_label.ModelName" string.
54       * A model class, which will be returned unchanged.
55     """
56     # Check for recursive relations
57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
58         relation = scope_model
59 
60     # Look for an "app.Model" relation
61     if isinstance(relation, str):
62         if "." not in relation:
63             relation = "%s.%s" % (scope_model._meta.app_label, relation)
64 
65     return relation
66 
67 
68 def lazy_related_operation(function, model, *related_models, **kwargs):
69     """
70     Schedule `function` to be called once `model` and all `related_models`
71     have been imported and registered with the app registry. `function` will
72     be called with the newly-loaded model classes as its positional arguments,
73     plus any optional keyword arguments.
74 
75     The `model` argument must be a model class. Each subsequent positional
76     argument is another model, or a reference to another model - see
77     `resolve_relation()` for the various forms these may take. Any relative
78     references will be resolved relative to `model`.
79 
80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
81     registry model used is the one found in `model._meta.apps`.
82     """
83     models = [model] + [resolve_relation(model, rel) for rel in related_models]
84     model_keys = (make_model_tuple(m) for m in models)
85     apps = model._meta.apps
86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
87 
88 
89 class RelatedField(FieldCacheMixin, Field):
90     """Base class that all relational fields inherit from."""
91 
92     # Field flags
93     one_to_many = False
94     one_to_one = False
95     many_to_many = False
96     many_to_one = False
97 
98     def __init__(
99         self,
100         related_name=None,
101         related_query_name=None,
102         limit_choices_to=None,
103         **kwargs,
104     ):
105         self._related_name = related_name
106         self._related_query_name = related_query_name
107         self._limit_choices_to = limit_choices_to
108         super().__init__(**kwargs)
109 
110     @cached_property
111     def related_model(self):
112         # Can't cache this property until all the models are loaded.
113         apps.check_models_ready()
114         return self.remote_field.model
115 
116     def check(self, **kwargs):
117         return [
118             *super().check(**kwargs),
119             *self._check_related_name_is_valid(),
120             *self._check_related_query_name_is_valid(),
121             *self._check_relation_model_exists(),
122             *self._check_referencing_to_swapped_model(),
123             *self._check_clashes(),
124         ]
125 
126     def _check_related_name_is_valid(self):
127         import keyword
128 
129         related_name = self.remote_field.related_name
130         if related_name is None:
131             return []
132         is_valid_id = (
133             not keyword.iskeyword(related_name) and related_name.isidentifier()
134         )
135         if not (is_valid_id or related_name.endswith("+")):
136             return [
137                 checks.Error(
138                     "The name '%s' is invalid related_name for field %s.%s"
139                     % (
140                         self.remote_field.related_name,
141                         self.model._meta.object_name,
142                         self.name,
143                     ),
144                     hint=(
145                         "Related name must be a valid Python identifier or end with a "
146                         "'+'"
147                     ),
148                     obj=self,
149                     id="fields.E306",
150                 )
151             ]
152         return []
153 
154     def _check_related_query_name_is_valid(self):
155         if self.remote_field.is_hidden():
156             return []
157         rel_query_name = self.related_query_name()
158         errors = []
159         if rel_query_name.endswith("_"):
160             errors.append(
161                 checks.Error(
162                     "Reverse query name '%s' must not end with an underscore."
163                     % rel_query_name,
164                     hint=(
165                         "Add or change a related_name or related_query_name "
166                         "argument for this field."
167                     ),
168                     obj=self,
169                     id="fields.E308",
170                 )
171             )
172         if LOOKUP_SEP in rel_query_name:
173             errors.append(
174                 checks.Error(
175                     "Reverse query name '%s' must not contain '%s'."
176                     % (rel_query_name, LOOKUP_SEP),
177                     hint=(
178                         "Add or change a related_name or related_query_name "
179                         "argument for this field."
180                     ),
181                     obj=self,
182                     id="fields.E309",
183                 )
184             )
185         return errors
186 
187     def _check_relation_model_exists(self):
188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
189         rel_is_string = isinstance(self.remote_field.model, str)
190         model_name = (
191             self.remote_field.model
192             if rel_is_string
193             else self.remote_field.model._meta.object_name
194         )
195         if rel_is_missing and (
196             rel_is_string or not self.remote_field.model._meta.swapped
197         ):
198             return [
199                 checks.Error(
200                     "Field defines a relation with model '%s', which is either "
201                     "not installed, or is abstract." % model_name,
202                     obj=self,
203                     id="fields.E300",
204                 )
205             ]
206         return []
207 
208     def _check_referencing_to_swapped_model(self):
209         if (
210             self.remote_field.model not in self.opts.apps.get_models()
211             and not isinstance(self.remote_field.model, str)
212             and self.remote_field.model._meta.swapped
213         ):
214             return [
215                 checks.Error(
216                     "Field defines a relation with the model '%s', which has "
217                     "been swapped out." % self.remote_field.model._meta.label,
218                     hint="Update the relation to point at 'settings.%s'."
219                     % self.remote_field.model._meta.swappable,
220                     obj=self,
221                     id="fields.E301",
222                 )
223             ]
224         return []
225 
226     def _check_clashes(self):
227         """Check accessor and reverse query name clashes."""
228         from django.db.models.base import ModelBase
229 
230         errors = []
231         opts = self.model._meta
232 
233         # f.remote_field.model may be a string instead of a model. Skip if
234         # model name is not resolved.
235         if not isinstance(self.remote_field.model, ModelBase):
236             return []
237 
238         # Consider that we are checking field `Model.foreign` and the models
239         # are:
240         #
241         #     class Target(models.Model):
242         #         model = models.IntegerField()
243         #         model_set = models.IntegerField()
244         #
245         #     class Model(models.Model):
246         #         foreign = models.ForeignKey(Target)
247         #         m2m = models.ManyToManyField(Target)
248 
249         # rel_opts.object_name == "Target"
250         rel_opts = self.remote_field.model._meta
251         # If the field doesn't install a backward relation on the target model
252         # (so `is_hidden` returns True), then there are no clashes to check
253         # and we can skip these fields.
254         rel_is_hidden = self.remote_field.is_hidden()
255         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
256         rel_query_name = self.related_query_name()  # i. e. "model"
257         # i.e. "app_label.Model.field".
258         field_name = "%s.%s" % (opts.label, self.name)
259 
260         # Check clashes between accessor or reverse query name of `field`
261         # and any other field name -- i.e. accessor for Model.foreign is
262         # model_set and it clashes with Target.model_set.
263         potential_clashes = rel_opts.fields + rel_opts.many_to_many
264         for clash_field in potential_clashes:
265             # i.e. "app_label.Target.model_set".
266             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
267             if not rel_is_hidden and clash_field.name == rel_name:
268                 errors.append(
269                     checks.Error(
270                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
271                         f"for '{field_name}' clashes with field name "
272                         f"'{clash_name}'.",
273                         hint=(
274                             "Rename field '%s', or add/change a related_name "
275                             "argument to the definition for field '%s'."
276                         )
277                         % (clash_name, field_name),
278                         obj=self,
279                         id="fields.E302",
280                     )
281                 )
282 
283             if clash_field.name == rel_query_name:
284                 errors.append(
285                     checks.Error(
286                         "Reverse query name for '%s' clashes with field name '%s'."
287                         % (field_name, clash_name),
288                         hint=(
289                             "Rename field '%s', or add/change a related_name "
290                             "argument to the definition for field '%s'."
291                         )
292                         % (clash_name, field_name),
293                         obj=self,
294                         id="fields.E303",
295                     )
296                 )
297 
298         # Check clashes between accessors/reverse query names of `field` and
299         # any other field accessor -- i. e. Model.foreign accessor clashes with
300         # Model.m2m accessor.
301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
302         for clash_field in potential_clashes:
303             # i.e. "app_label.Model.m2m".
304             clash_name = "%s.%s" % (
305                 clash_field.related_model._meta.label,
306                 clash_field.field.name,
307             )
308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
309                 errors.append(
310                     checks.Error(
311                         f"Reverse accessor '{rel_opts.object_name}.{rel_name}' "
312                         f"for '{field_name}' clashes with reverse accessor for "
313                         f"'{clash_name}'.",
314                         hint=(
315                             "Add or change a related_name argument "
316                             "to the definition for '%s' or '%s'."
317                         )
318                         % (field_name, clash_name),
319                         obj=self,
320                         id="fields.E304",
321                     )
322                 )
323 
324             if clash_field.get_accessor_name() == rel_query_name:
325                 errors.append(
326                     checks.Error(
327                         "Reverse query name for '%s' clashes with reverse query name "
328                         "for '%s'." % (field_name, clash_name),
329                         hint=(
330                             "Add or change a related_name argument "
331                             "to the definition for '%s' or '%s'."
332                         )
333                         % (field_name, clash_name),
334                         obj=self,
335                         id="fields.E305",
336                     )
337                 )
338 
339         return errors
340 
341     def db_type(self, connection):
342         # By default related field will not have a column as it relates to
343         # columns from another table.
344         return None
345 
346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
347 
348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
349 
350         self.opts = cls._meta
351 
352         if not cls._meta.abstract:
353             if self.remote_field.related_name:
354                 related_name = self.remote_field.related_name
355             else:
356                 related_name = self.opts.default_related_name
357             if related_name:
358                 related_name = related_name % {
359                     "class": cls.__name__.lower(),
360                     "model_name": cls._meta.model_name.lower(),
361                     "app_label": cls._meta.app_label.lower(),
362                 }
363                 self.remote_field.related_name = related_name
364 
365             if self.remote_field.related_query_name:
366                 related_query_name = self.remote_field.related_query_name % {
367                     "class": cls.__name__.lower(),
368                     "app_label": cls._meta.app_label.lower(),
369                 }
370                 self.remote_field.related_query_name = related_query_name
371 
372             def resolve_related_class(model, related, field):
373                 field.remote_field.model = related
374                 field.do_related_class(related, model)
375 
376             lazy_related_operation(
377                 resolve_related_class, cls, self.remote_field.model, field=self
378             )
379 
380     def deconstruct(self):
381         name, path, args, kwargs = super().deconstruct()
382         if self._limit_choices_to:
383             kwargs["limit_choices_to"] = self._limit_choices_to
384         if self._related_name is not None:
385             kwargs["related_name"] = self._related_name
386         if self._related_query_name is not None:
387             kwargs["related_query_name"] = self._related_query_name
388         return name, path, args, kwargs
389 
390     def get_forward_related_filter(self, obj):
391         """
392         Return the keyword arguments that when supplied to
393         self.model.object.filter(), would select all instances related through
394         this field to the remote obj. This is used to build the querysets
395         returned by related descriptors. obj is an instance of
396         self.related_field.model.
397         """
398         return {
399             "%s__%s" % (self.name, rh_field.name): getattr(obj, rh_field.attname)
400             for _, rh_field in self.related_fields
401         }
402 
403     def get_reverse_related_filter(self, obj):
404         """
405         Complement to get_forward_related_filter(). Return the keyword
406         arguments that when passed to self.related_field.model.object.filter()
407         select all instances of self.related_field.model related through
408         this field to obj. obj is an instance of self.model.
409         """
410         base_filter = (
411             (rh_field.attname, getattr(obj, lh_field.attname))
412             for lh_field, rh_field in self.related_fields
413         )
414         descriptor_filter = self.get_extra_descriptor_filter(obj)
415         base_q = Q(*base_filter)
416         if isinstance(descriptor_filter, dict):
417             return base_q & Q(**descriptor_filter)
418         elif descriptor_filter:
419             return base_q & descriptor_filter
420         return base_q
421 
422     @property
423     def swappable_setting(self):
424         """
425         Get the setting that this is powered from for swapping, or None
426         if it's not swapped in / marked with swappable=False.
427         """
428         if self.swappable:
429             # Work out string form of "to"
430             if isinstance(self.remote_field.model, str):
431                 to_string = self.remote_field.model
432             else:
433                 to_string = self.remote_field.model._meta.label
434             return apps.get_swappable_settings_name(to_string)
435         return None
436 
437     def set_attributes_from_rel(self):
438         self.name = self.name or (
439             self.remote_field.model._meta.model_name
440             + "_"
441             + self.remote_field.model._meta.pk.name
442         )
443         if self.verbose_name is None:
444             self.verbose_name = self.remote_field.model._meta.verbose_name
445         self.remote_field.set_field_name()
446 
447     def do_related_class(self, other, cls):
448         self.set_attributes_from_rel()
449         self.contribute_to_related_class(other, self.remote_field)
450 
451     def get_limit_choices_to(self):
452         """
453         Return ``limit_choices_to`` for this model field.
454 
455         If it is a callable, it will be invoked and the result will be
456         returned.
457         """
458         if callable(self.remote_field.limit_choices_to):
459             return self.remote_field.limit_choices_to()
460         return self.remote_field.limit_choices_to
461 
462     def formfield(self, **kwargs):
463         """
464         Pass ``limit_choices_to`` to the field being constructed.
465 
466         Only passes it if there is a type that supports related fields.
467         This is a similar strategy used to pass the ``queryset`` to the field
468         being constructed.
469         """
470         defaults = {}
471         if hasattr(self.remote_field, "get_related_field"):
472             # If this is a callable, do not invoke it here. Just pass
473             # it in the defaults for when the form class will later be
474             # instantiated.
475             limit_choices_to = self.remote_field.limit_choices_to
476             defaults.update(
477                 {
478                     "limit_choices_to": limit_choices_to,
479                 }
480             )
481         defaults.update(kwargs)
482         return super().formfield(**defaults)
483 
484     def related_query_name(self):
485         """
486         Define the name that can be used to identify this related object in a
487         table-spanning query.
488         """
489         return (
490             self.remote_field.related_query_name
491             or self.remote_field.related_name
492             or self.opts.model_name
493         )
494 
495     @property
496     def target_field(self):
497         """
498         When filtering against this relation, return the field on the remote
499         model against which the filtering should happen.
500         """
501         target_fields = self.path_infos[-1].target_fields
502         if len(target_fields) > 1:
503             raise exceptions.FieldError(
504                 "The relation has multiple target fields, but only single target field "
505                 "was asked for"
506             )
507         return target_fields[0]
508 
509     def get_cache_name(self):
510         return self.name
511 
512 
513 class ForeignObject(RelatedField):
514     """
515     Abstraction of the ForeignKey relation to support multi-column relations.
516     """
517 
518     # Field flags
519     many_to_many = False
520     many_to_one = True
521     one_to_many = False
522     one_to_one = False
523 
524     requires_unique_target = True
525     related_accessor_class = ReverseManyToOneDescriptor
526     forward_related_accessor_class = ForwardManyToOneDescriptor
527     rel_class = ForeignObjectRel
528 
529     def __init__(
530         self,
531         to,
532         on_delete,
533         from_fields,
534         to_fields,
535         rel=None,
536         related_name=None,
537         related_query_name=None,
538         limit_choices_to=None,
539         parent_link=False,
540         swappable=True,
541         **kwargs,
542     ):
543 
544         if rel is None:
545             rel = self.rel_class(
546                 self,
547                 to,
548                 related_name=related_name,
549                 related_query_name=related_query_name,
550                 limit_choices_to=limit_choices_to,
551                 parent_link=parent_link,
552                 on_delete=on_delete,
553             )
554 
555         super().__init__(
556             rel=rel,
557             related_name=related_name,
558             related_query_name=related_query_name,
559             limit_choices_to=limit_choices_to,
560             **kwargs,
561         )
562 
563         self.from_fields = from_fields
564         self.to_fields = to_fields
565         self.swappable = swappable
566 
567     def __copy__(self):
568         obj = super().__copy__()
569         # Remove any cached PathInfo values.
570         obj.__dict__.pop("path_infos", None)
571         obj.__dict__.pop("reverse_path_infos", None)
572         return obj
573 
574     def check(self, **kwargs):
575         return [
576             *super().check(**kwargs),
577             *self._check_to_fields_exist(),
578             *self._check_unique_target(),
579         ]
580 
581     def _check_to_fields_exist(self):
582         # Skip nonexistent models.
583         if isinstance(self.remote_field.model, str):
584             return []
585 
586         errors = []
587         for to_field in self.to_fields:
588             if to_field:
589                 try:
590                     self.remote_field.model._meta.get_field(to_field)
591                 except exceptions.FieldDoesNotExist:
592                     errors.append(
593                         checks.Error(
594                             "The to_field '%s' doesn't exist on the related "
595                             "model '%s'."
596                             % (to_field, self.remote_field.model._meta.label),
597                             obj=self,
598                             id="fields.E312",
599                         )
600                     )
601         return errors
602 
603     def _check_unique_target(self):
604         rel_is_string = isinstance(self.remote_field.model, str)
605         if rel_is_string or not self.requires_unique_target:
606             return []
607 
608         try:
609             self.foreign_related_fields
610         except exceptions.FieldDoesNotExist:
611             return []
612 
613         if not self.foreign_related_fields:
614             return []
615 
616         unique_foreign_fields = {
617             frozenset([f.name])
618             for f in self.remote_field.model._meta.get_fields()
619             if getattr(f, "unique", False)
620         }
621         unique_foreign_fields.update(
622             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
623         )
624         unique_foreign_fields.update(
625             {
626                 frozenset(uc.fields)
627                 for uc in self.remote_field.model._meta.total_unique_constraints
628             }
629         )
630         foreign_fields = {f.name for f in self.foreign_related_fields}
631         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
632 
633         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
634             field_combination = ", ".join(
635                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
636             )
637             model_name = self.remote_field.model.__name__
638             return [
639                 checks.Error(
640                     "No subset of the fields %s on model '%s' is unique."
641                     % (field_combination, model_name),
642                     hint=(
643                         "Mark a single field as unique=True or add a set of "
644                         "fields to a unique constraint (via unique_together "
645                         "or a UniqueConstraint (without condition) in the "
646                         "model Meta.constraints)."
647                     ),
648                     obj=self,
649                     id="fields.E310",
650                 )
651             ]
652         elif not has_unique_constraint:
653             field_name = self.foreign_related_fields[0].name
654             model_name = self.remote_field.model.__name__
655             return [
656                 checks.Error(
657                     "'%s.%s' must be unique because it is referenced by "
658                     "a foreign key." % (model_name, field_name),
659                     hint=(
660                         "Add unique=True to this field or add a "
661                         "UniqueConstraint (without condition) in the model "
662                         "Meta.constraints."
663                     ),
664                     obj=self,
665                     id="fields.E311",
666                 )
667             ]
668         else:
669             return []
670 
671     def deconstruct(self):
672         name, path, args, kwargs = super().deconstruct()
673         kwargs["on_delete"] = self.remote_field.on_delete
674         kwargs["from_fields"] = self.from_fields
675         kwargs["to_fields"] = self.to_fields
676 
677         if self.remote_field.parent_link:
678             kwargs["parent_link"] = self.remote_field.parent_link
679         if isinstance(self.remote_field.model, str):
680             if "." in self.remote_field.model:
681                 app_label, model_name = self.remote_field.model.split(".")
682                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
683             else:
684                 kwargs["to"] = self.remote_field.model.lower()
685         else:
686             kwargs["to"] = self.remote_field.model._meta.label_lower
687         # If swappable is True, then see if we're actually pointing to the target
688         # of a swap.
689         swappable_setting = self.swappable_setting
690         if swappable_setting is not None:
691             # If it's already a settings reference, error
692             if hasattr(kwargs["to"], "setting_name"):
693                 if kwargs["to"].setting_name != swappable_setting:
694                     raise ValueError(
695                         "Cannot deconstruct a ForeignKey pointing to a model "
696                         "that is swapped in place of more than one model (%s and %s)"
697                         % (kwargs["to"].setting_name, swappable_setting)
698                     )
699             # Set it
700             kwargs["to"] = SettingsReference(
701                 kwargs["to"],
702                 swappable_setting,
703             )
704         return name, path, args, kwargs
705 
706     def resolve_related_fields(self):
707         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
708             raise ValueError(
709                 "Foreign Object from and to fields must be the same non-zero length"
710             )
711         if isinstance(self.remote_field.model, str):
712             raise ValueError(
713                 "Related model %r cannot be resolved" % self.remote_field.model
714             )
715         related_fields = []
716         for index in range(len(self.from_fields)):
717             from_field_name = self.from_fields[index]
718             to_field_name = self.to_fields[index]
719             from_field = (
720                 self
721                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
722                 else self.opts.get_field(from_field_name)
723             )
724             to_field = (
725                 self.remote_field.model._meta.pk
726                 if to_field_name is None
727                 else self.remote_field.model._meta.get_field(to_field_name)
728             )
729             related_fields.append((from_field, to_field))
730         return related_fields
731 
732     @cached_property
733     def related_fields(self):
734         return self.resolve_related_fields()
735 
736     @cached_property
737     def reverse_related_fields(self):
738         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
739 
740     @cached_property
741     def local_related_fields(self):
742         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
743 
744     @cached_property
745     def foreign_related_fields(self):
746         return tuple(
747             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
748         )
749 
750     def get_local_related_value(self, instance):
751         return self.get_instance_value_for_fields(instance, self.local_related_fields)
752 
753     def get_foreign_related_value(self, instance):
754         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
755 
756     @staticmethod
757     def get_instance_value_for_fields(instance, fields):
758         ret = []
759         opts = instance._meta
760         for field in fields:
761             # Gotcha: in some cases (like fixture loading) a model can have
762             # different values in parent_ptr_id and parent's id. So, use
763             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
764             if field.primary_key:
765                 possible_parent_link = opts.get_ancestor_link(field.model)
766                 if (
767                     not possible_parent_link
768                     or possible_parent_link.primary_key
769                     or possible_parent_link.model._meta.abstract
770                 ):
771                     ret.append(instance.pk)
772                     continue
773             ret.append(getattr(instance, field.attname))
774         return tuple(ret)
775 
776     def get_attname_column(self):
777         attname, column = super().get_attname_column()
778         return attname, None
779 
780     def get_joining_columns(self, reverse_join=False):
781         source = self.reverse_related_fields if reverse_join else self.related_fields
782         return tuple(
783             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
784         )
785 
786     def get_reverse_joining_columns(self):
787         return self.get_joining_columns(reverse_join=True)
788 
789     def get_extra_descriptor_filter(self, instance):
790         """
791         Return an extra filter condition for related object fetching when
792         user does 'instance.fieldname', that is the extra filter is used in
793         the descriptor of the field.
794 
795         The filter should be either a dict usable in .filter(**kwargs) call or
796         a Q-object. The condition will be ANDed together with the relation's
797         joining columns.
798 
799         A parallel method is get_extra_restriction() which is used in
800         JOIN and subquery conditions.
801         """
802         return {}
803 
804     def get_extra_restriction(self, alias, related_alias):
805         """
806         Return a pair condition used for joining and subquery pushdown. The
807         condition is something that responds to as_sql(compiler, connection)
808         method.
809 
810         Note that currently referring both the 'alias' and 'related_alias'
811         will not work in some conditions, like subquery pushdown.
812 
813         A parallel method is get_extra_descriptor_filter() which is used in
814         instance.fieldname related object fetching.
815         """
816         return None
817 
818     def get_path_info(self, filtered_relation=None):
819         """Get path from this field to the related model."""
820         opts = self.remote_field.model._meta
821         from_opts = self.model._meta
822         return [
823             PathInfo(
824                 from_opts=from_opts,
825                 to_opts=opts,
826                 target_fields=self.foreign_related_fields,
827                 join_field=self,
828                 m2m=False,
829                 direct=True,
830                 filtered_relation=filtered_relation,
831             )
832         ]
833 
834     @cached_property
835     def path_infos(self):
836         return self.get_path_info()
837 
838     def get_reverse_path_info(self, filtered_relation=None):
839         """Get path from the related model to this field's model."""
840         opts = self.model._meta
841         from_opts = self.remote_field.model._meta
842         return [
843             PathInfo(
844                 from_opts=from_opts,
845                 to_opts=opts,
846                 target_fields=(opts.pk,),
847                 join_field=self.remote_field,
848                 m2m=not self.unique,
849                 direct=False,
850                 filtered_relation=filtered_relation,
851             )
852         ]
853 
854     @cached_property
855     def reverse_path_infos(self):
856         return self.get_reverse_path_info()
857 
858     @classmethod
859     @functools.lru_cache(maxsize=None)
860     def get_lookups(cls):
861         bases = inspect.getmro(cls)
862         bases = bases[: bases.index(ForeignObject) + 1]
863         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
864         return cls.merge_dicts(class_lookups)
865 
866     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
867         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
868         setattr(cls, self.name, self.forward_related_accessor_class(self))
869 
870     def contribute_to_related_class(self, cls, related):
871         # Internal FK's - i.e., those with a related name ending with '+' -
872         # and swapped models don't get a related descriptor.
873         if (
874             not self.remote_field.is_hidden()
875             and not related.related_model._meta.swapped
876         ):
877             setattr(
878                 cls._meta.concrete_model,
879                 related.get_accessor_name(),
880                 self.related_accessor_class(related),
881             )
882             # While 'limit_choices_to' might be a callable, simply pass
883             # it along for later - this is too early because it's still
884             # model load time.
885             if self.remote_field.limit_choices_to:
886                 cls._meta.related_fkey_lookups.append(
887                     self.remote_field.limit_choices_to
888                 )
889 
890 
891 ForeignObject.register_lookup(RelatedIn)
892 ForeignObject.register_lookup(RelatedExact)
893 ForeignObject.register_lookup(RelatedLessThan)
894 ForeignObject.register_lookup(RelatedGreaterThan)
895 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
896 ForeignObject.register_lookup(RelatedLessThanOrEqual)
897 ForeignObject.register_lookup(RelatedIsNull)
898 
899 
900 class ForeignKey(ForeignObject):
901     """
902     Provide a many-to-one relation by adding a column to the local model
903     to hold the remote value.
904 
905     By default ForeignKey will target the pk of the remote model but this
906     behavior can be changed by using the ``to_field`` argument.
907     """
908 
909     descriptor_class = ForeignKeyDeferredAttribute
910     # Field flags
911     many_to_many = False
912     many_to_one = True
913     one_to_many = False
914     one_to_one = False
915 
916     rel_class = ManyToOneRel
917 
918     empty_strings_allowed = False
919     default_error_messages = {
920         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
921     }
922     description = _("Foreign Key (type determined by related field)")
923 
924     def __init__(
925         self,
926         to,
927         on_delete,
928         related_name=None,
929         related_query_name=None,
930         limit_choices_to=None,
931         parent_link=False,
932         to_field=None,
933         db_constraint=True,
934         **kwargs,
935     ):
936         try:
937             to._meta.model_name
938         except AttributeError:
939             if not isinstance(to, str):
940                 raise TypeError(
941                     "%s(%r) is invalid. First parameter to ForeignKey must be "
942                     "either a model, a model name, or the string %r"
943                     % (
944                         self.__class__.__name__,
945                         to,
946                         RECURSIVE_RELATIONSHIP_CONSTANT,
947                     )
948                 )
949         else:
950             # For backwards compatibility purposes, we need to *try* and set
951             # the to_field during FK construction. It won't be guaranteed to
952             # be correct until contribute_to_class is called. Refs #12190.
953             to_field = to_field or (to._meta.pk and to._meta.pk.name)
954         if not callable(on_delete):
955             raise TypeError("on_delete must be callable.")
956 
957         kwargs["rel"] = self.rel_class(
958             self,
959             to,
960             to_field,
961             related_name=related_name,
962             related_query_name=related_query_name,
963             limit_choices_to=limit_choices_to,
964             parent_link=parent_link,
965             on_delete=on_delete,
966         )
967         kwargs.setdefault("db_index", True)
968 
969         super().__init__(
970             to,
971             on_delete,
972             related_name=related_name,
973             related_query_name=related_query_name,
974             limit_choices_to=limit_choices_to,
975             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
976             to_fields=[to_field],
977             **kwargs,
978         )
979         self.db_constraint = db_constraint
980 
981     def __class_getitem__(cls, *args, **kwargs):
982         return cls
983 
984     def check(self, **kwargs):
985         return [
986             *super().check(**kwargs),
987             *self._check_on_delete(),
988             *self._check_unique(),
989         ]
990 
991     def _check_on_delete(self):
992         on_delete = getattr(self.remote_field, "on_delete", None)
993         if on_delete == SET_NULL and not self.null:
994             return [
995                 checks.Error(
996                     "Field specifies on_delete=SET_NULL, but cannot be null.",
997                     hint=(
998                         "Set null=True argument on the field, or change the on_delete "
999                         "rule."
1000                     ),
1001                     obj=self,
1002                     id="fields.E320",
1003                 )
1004             ]
1005         elif on_delete == SET_DEFAULT and not self.has_default():
1006             return [
1007                 checks.Error(
1008                     "Field specifies on_delete=SET_DEFAULT, but has no default value.",
1009                     hint="Set a default value, or change the on_delete rule.",
1010                     obj=self,
1011                     id="fields.E321",
1012                 )
1013             ]
1014         else:
1015             return []
1016 
1017     def _check_unique(self, **kwargs):
1018         return (
1019             [
1020                 checks.Warning(
1021                     "Setting unique=True on a ForeignKey has the same effect as using "
1022                     "a OneToOneField.",
1023                     hint=(
1024                         "ForeignKey(unique=True) is usually better served by a "
1025                         "OneToOneField."
1026                     ),
1027                     obj=self,
1028                     id="fields.W342",
1029                 )
1030             ]
1031             if self.unique
1032             else []
1033         )
1034 
1035     def deconstruct(self):
1036         name, path, args, kwargs = super().deconstruct()
1037         del kwargs["to_fields"]
1038         del kwargs["from_fields"]
1039         # Handle the simpler arguments
1040         if self.db_index:
1041             del kwargs["db_index"]
1042         else:
1043             kwargs["db_index"] = False
1044         if self.db_constraint is not True:
1045             kwargs["db_constraint"] = self.db_constraint
1046         # Rel needs more work.
1047         to_meta = getattr(self.remote_field.model, "_meta", None)
1048         if self.remote_field.field_name and (
1049             not to_meta
1050             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
1051         ):
1052             kwargs["to_field"] = self.remote_field.field_name
1053         return name, path, args, kwargs
1054 
1055     def to_python(self, value):
1056         return self.target_field.to_python(value)
1057 
1058     @property
1059     def target_field(self):
1060         return self.foreign_related_fields[0]
1061 
1062     def get_reverse_path_info(self, filtered_relation=None):
1063         """Get path from the related model to this field's model."""
1064         opts = self.model._meta
1065         from_opts = self.remote_field.model._meta
1066         return [
1067             PathInfo(
1068                 from_opts=from_opts,
1069                 to_opts=opts,
1070                 target_fields=(opts.pk,),
1071                 join_field=self.remote_field,
1072                 m2m=not self.unique,
1073                 direct=False,
1074                 filtered_relation=filtered_relation,
1075             )
1076         ]
1077 
1078     def validate(self, value, model_instance):
1079         if self.remote_field.parent_link:
1080             return
1081         super().validate(value, model_instance)
1082         if value is None:
1083             return
1084 
1085         using = router.db_for_read(self.remote_field.model, instance=model_instance)
1086         qs = self.remote_field.model._base_manager.using(using).filter(
1087             **{self.remote_field.field_name: value}
1088         )
1089         qs = qs.complex_filter(self.get_limit_choices_to())
1090         if not qs.exists():
1091             raise exceptions.ValidationError(
1092                 self.error_messages["invalid"],
1093                 code="invalid",
1094                 params={
1095                     "model": self.remote_field.model._meta.verbose_name,
1096                     "pk": value,
1097                     "field": self.remote_field.field_name,
1098                     "value": value,
1099                 },  # 'pk' is included for backwards compatibility
1100             )
1101 
1102     def resolve_related_fields(self):
1103         related_fields = super().resolve_related_fields()
1104         for from_field, to_field in related_fields:
1105             if (
1106                 to_field
1107                 and to_field.model != self.remote_field.model._meta.concrete_model
1108             ):
1109                 raise exceptions.FieldError(
1110                     "'%s.%s' refers to field '%s' which is not local to model "
1111                     "'%s'."
1112                     % (
1113                         self.model._meta.label,
1114                         self.name,
1115                         to_field.name,
1116                         self.remote_field.model._meta.concrete_model._meta.label,
1117                     )
1118                 )
1119         return related_fields
1120 
1121     def get_attname(self):
1122         return "%s_id" % self.name
1123 
1124     def get_attname_column(self):
1125         attname = self.get_attname()
1126         column = self.db_column or attname
1127         return attname, column
1128 
1129     def get_default(self):
1130         """Return the to_field if the default value is an object."""
1131         field_default = super().get_default()
1132         if isinstance(field_default, self.remote_field.model):
1133             return getattr(field_default, self.target_field.attname)
1134         return field_default
1135 
1136     def get_db_prep_save(self, value, connection):
1137         if value is None or (
1138             value == ""
1139             and (
1140                 not self.target_field.empty_strings_allowed
1141                 or connection.features.interprets_empty_strings_as_nulls
1142             )
1143         ):
1144             return None
1145         else:
1146             return self.target_field.get_db_prep_save(value, connection=connection)
1147 
1148     def get_db_prep_value(self, value, connection, prepared=False):
1149         return self.target_field.get_db_prep_value(value, connection, prepared)
1150 
1151     def get_prep_value(self, value):
1152         return self.target_field.get_prep_value(value)
1153 
1154     def contribute_to_related_class(self, cls, related):
1155         super().contribute_to_related_class(cls, related)
1156         if self.remote_field.field_name is None:
1157             self.remote_field.field_name = cls._meta.pk.name
1158 
1159     def formfield(self, *, using=None, **kwargs):
1160         if isinstance(self.remote_field.model, str):
1161             raise ValueError(
1162                 "Cannot create form field for %r yet, because "
1163                 "its related model %r has not been loaded yet"
1164                 % (self.name, self.remote_field.model)
1165             )
1166         return super().formfield(
1167             **{
1168                 "form_class": forms.ModelChoiceField,
1169                 "queryset": self.remote_field.model._default_manager.using(using),
1170                 "to_field_name": self.remote_field.field_name,
1171                 **kwargs,
1172                 "blank": self.blank,
1173             }
1174         )
1175 
1176     def db_check(self, connection):
1177         return None
1178 
1179     def db_type(self, connection):
1180         return self.target_field.rel_db_type(connection=connection)
1181 
1182     def db_parameters(self, connection):
1183         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1184 
1185     def convert_empty_strings(self, value, expression, connection):
1186         if (not value) and isinstance(value, str):
1187             return None
1188         return value
1189 
1190     def get_db_converters(self, connection):
1191         converters = super().get_db_converters(connection)
1192         if connection.features.interprets_empty_strings_as_nulls:
1193             converters += [self.convert_empty_strings]
1194         return converters
1195 
1196     def get_col(self, alias, output_field=None):
1197         if output_field is None:
1198             output_field = self.target_field
1199             while isinstance(output_field, ForeignKey):
1200                 output_field = output_field.target_field
1201                 if output_field is self:
1202                     raise ValueError("Cannot resolve output_field.")
1203         return super().get_col(alias, output_field)
1204 
1205 
1206 class OneToOneField(ForeignKey):
1207     """
1208     A OneToOneField is essentially the same as a ForeignKey, with the exception
1209     that it always carries a "unique" constraint with it and the reverse
1210     relation always returns the object pointed to (since there will only ever
1211     be one), rather than returning a list.
1212     """
1213 
1214     # Field flags
1215     many_to_many = False
1216     many_to_one = False
1217     one_to_many = False
1218     one_to_one = True
1219 
1220     related_accessor_class = ReverseOneToOneDescriptor
1221     forward_related_accessor_class = ForwardOneToOneDescriptor
1222     rel_class = OneToOneRel
1223 
1224     description = _("One-to-one relationship")
1225 
1226     def __init__(self, to, on_delete, to_field=None, **kwargs):
1227         kwargs["unique"] = True
1228         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1229 
1230     def deconstruct(self):
1231         name, path, args, kwargs = super().deconstruct()
1232         if "unique" in kwargs:
1233             del kwargs["unique"]
1234         return name, path, args, kwargs
1235 
1236     def formfield(self, **kwargs):
1237         if self.remote_field.parent_link:
1238             return None
1239         return super().formfield(**kwargs)
1240 
1241     def save_form_data(self, instance, data):
1242         if isinstance(data, self.remote_field.model):
1243             setattr(instance, self.name, data)
1244         else:
1245             setattr(instance, self.attname, data)
1246             # Remote field object must be cleared otherwise Model.save()
1247             # will reassign attname using the related object pk.
1248             if data is None:
1249                 setattr(instance, self.name, data)
1250 
1251     def _check_unique(self, **kwargs):
1252         # Override ForeignKey since check isn't applicable here.
1253         return []
1254 
1255 
1256 def create_many_to_many_intermediary_model(field, klass):
1257     from django.db import models
1258 
1259     def set_managed(model, related, through):
1260         through._meta.managed = model._meta.managed or related._meta.managed
1261 
1262     to_model = resolve_relation(klass, field.remote_field.model)
1263     name = "%s_%s" % (klass._meta.object_name, field.name)
1264     lazy_related_operation(set_managed, klass, to_model, name)
1265 
1266     to = make_model_tuple(to_model)[1]
1267     from_ = klass._meta.model_name
1268     if to == from_:
1269         to = "to_%s" % to
1270         from_ = "from_%s" % from_
1271 
1272     meta = type(
1273         "Meta",
1274         (),
1275         {
1276             "db_table": field._get_m2m_db_table(klass._meta),
1277             "auto_created": klass,
1278             "app_label": klass._meta.app_label,
1279             "db_tablespace": klass._meta.db_tablespace,
1280             "unique_together": (from_, to),
1281             "verbose_name": _("%(from)s-%(to)s relationship")
1282             % {"from": from_, "to": to},
1283             "verbose_name_plural": _("%(from)s-%(to)s relationships")
1284             % {"from": from_, "to": to},
1285             "apps": field.model._meta.apps,
1286         },
1287     )
1288     # Construct and return the new class.
1289     return type(
1290         name,
1291         (models.Model,),
1292         {
1293             "Meta": meta,
1294             "__module__": klass.__module__,
1295             from_: models.ForeignKey(
1296                 klass,
1297                 related_name="%s+" % name,
1298                 db_tablespace=field.db_tablespace,
1299                 db_constraint=field.remote_field.db_constraint,
1300                 on_delete=CASCADE,
1301             ),
1302             to: models.ForeignKey(
1303                 to_model,
1304                 related_name="%s+" % name,
1305                 db_tablespace=field.db_tablespace,
1306                 db_constraint=field.remote_field.db_constraint,
1307                 on_delete=CASCADE,
1308             ),
1309         },
1310     )
1311 
1312 
1313 class ManyToManyField(RelatedField):
1314     """
1315     Provide a many-to-many relation by using an intermediary model that
1316     holds two ForeignKey fields pointed at the two sides of the relation.
1317 
1318     Unless a ``through`` model was provided, ManyToManyField will use the
1319     create_many_to_many_intermediary_model factory to automatically generate
1320     the intermediary model.
1321     """
1322 
1323     # Field flags
1324     many_to_many = True
1325     many_to_one = False
1326     one_to_many = False
1327     one_to_one = False
1328 
1329     rel_class = ManyToManyRel
1330 
1331     description = _("Many-to-many relationship")
1332 
1333     def __init__(
1334         self,
1335         to,
1336         related_name=None,
1337         related_query_name=None,
1338         limit_choices_to=None,
1339         symmetrical=None,
1340         through=None,
1341         through_fields=None,
1342         db_constraint=True,
1343         db_table=None,
1344         swappable=True,
1345         **kwargs,
1346     ):
1347         try:
1348             to._meta
1349         except AttributeError:
1350             if not isinstance(to, str):
1351                 raise TypeError(
1352                     "%s(%r) is invalid. First parameter to ManyToManyField "
1353                     "must be either a model, a model name, or the string %r"
1354                     % (
1355                         self.__class__.__name__,
1356                         to,
1357                         RECURSIVE_RELATIONSHIP_CONSTANT,
1358                     )
1359                 )
1360 
1361         if symmetrical is None:
1362             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
1363 
1364         if through is not None and db_table is not None:
1365             raise ValueError(
1366                 "Cannot specify a db_table if an intermediary model is used."
1367             )
1368 
1369         kwargs["rel"] = self.rel_class(
1370             self,
1371             to,
1372             related_name=related_name,
1373             related_query_name=related_query_name,
1374             limit_choices_to=limit_choices_to,
1375             symmetrical=symmetrical,
1376             through=through,
1377             through_fields=through_fields,
1378             db_constraint=db_constraint,
1379         )
1380         self.has_null_arg = "null" in kwargs
1381 
1382         super().__init__(
1383             related_name=related_name,
1384             related_query_name=related_query_name,
1385             limit_choices_to=limit_choices_to,
1386             **kwargs,
1387         )
1388 
1389         self.db_table = db_table
1390         self.swappable = swappable
1391 
1392     def check(self, **kwargs):
1393         return [
1394             *super().check(**kwargs),
1395             *self._check_unique(**kwargs),
1396             *self._check_relationship_model(**kwargs),
1397             *self._check_ignored_options(**kwargs),
1398             *self._check_table_uniqueness(**kwargs),
1399         ]
1400 
1401     def _check_unique(self, **kwargs):
1402         if self.unique:
1403             return [
1404                 checks.Error(
1405                     "ManyToManyFields cannot be unique.",
1406                     obj=self,
1407                     id="fields.E330",
1408                 )
1409             ]
1410         return []
1411 
1412     def _check_ignored_options(self, **kwargs):
1413         warnings = []
1414 
1415         if self.has_null_arg:
1416             warnings.append(
1417                 checks.Warning(
1418                     "null has no effect on ManyToManyField.",
1419                     obj=self,
1420                     id="fields.W340",
1421                 )
1422             )
1423 
1424         if self._validators:
1425             warnings.append(
1426                 checks.Warning(
1427                     "ManyToManyField does not support validators.",
1428                     obj=self,
1429                     id="fields.W341",
1430                 )
1431             )
1432         if self.remote_field.symmetrical and self._related_name:
1433             warnings.append(
1434                 checks.Warning(
1435                     "related_name has no effect on ManyToManyField "
1436                     'with a symmetrical relationship, e.g. to "self".',
1437                     obj=self,
1438                     id="fields.W345",
1439                 )
1440             )
1441 
1442         return warnings
1443 
1444     def _check_relationship_model(self, from_model=None, **kwargs):
1445         if hasattr(self.remote_field.through, "_meta"):
1446             qualified_model_name = "%s.%s" % (
1447                 self.remote_field.through._meta.app_label,
1448                 self.remote_field.through.__name__,
1449             )
1450         else:
1451             qualified_model_name = self.remote_field.through
1452 
1453         errors = []
1454 
1455         if self.remote_field.through not in self.opts.apps.get_models(
1456             include_auto_created=True
1457         ):
1458             # The relationship model is not installed.
1459             errors.append(
1460                 checks.Error(
1461                     "Field specifies a many-to-many relation through model "
1462                     "'%s', which has not been installed." % qualified_model_name,
1463                     obj=self,
1464                     id="fields.E331",
1465                 )
1466             )
1467 
1468         else:
1469             assert from_model is not None, (
1470                 "ManyToManyField with intermediate "
1471                 "tables cannot be checked if you don't pass the model "
1472                 "where the field is attached to."
1473             )
1474             # Set some useful local variables
1475             to_model = resolve_relation(from_model, self.remote_field.model)
1476             from_model_name = from_model._meta.object_name
1477             if isinstance(to_model, str):
1478                 to_model_name = to_model
1479             else:
1480                 to_model_name = to_model._meta.object_name
1481             relationship_model_name = self.remote_field.through._meta.object_name
1482             self_referential = from_model == to_model
1483             # Count foreign keys in intermediate model
1484             if self_referential:
1485                 seen_self = sum(
1486                     from_model == getattr(field.remote_field, "model", None)
1487                     for field in self.remote_field.through._meta.fields
1488                 )
1489 
1490                 if seen_self > 2 and not self.remote_field.through_fields:
1491                     errors.append(
1492                         checks.Error(
1493                             "The model is used as an intermediate model by "
1494                             "'%s', but it has more than two foreign keys "
1495                             "to '%s', which is ambiguous. You must specify "
1496                             "which two foreign keys Django should use via the "
1497                             "through_fields keyword argument."
1498                             % (self, from_model_name),
1499                             hint=(
1500                                 "Use through_fields to specify which two foreign keys "
1501                                 "Django should use."
1502                             ),
1503                             obj=self.remote_field.through,
1504                             id="fields.E333",
1505                         )
1506                     )
1507 
1508             else:
1509                 # Count foreign keys in relationship model
1510                 seen_from = sum(
1511                     from_model == getattr(field.remote_field, "model", None)
1512                     for field in self.remote_field.through._meta.fields
1513                 )
1514                 seen_to = sum(
1515                     to_model == getattr(field.remote_field, "model", None)
1516                     for field in self.remote_field.through._meta.fields
1517                 )
1518 
1519                 if seen_from > 1 and not self.remote_field.through_fields:
1520                     errors.append(
1521                         checks.Error(
1522                             (
1523                                 "The model is used as an intermediate model by "
1524                                 "'%s', but it has more than one foreign key "
1525                                 "from '%s', which is ambiguous. You must specify "
1526                                 "which foreign key Django should use via the "
1527                                 "through_fields keyword argument."
1528                             )
1529                             % (self, from_model_name),
1530                             hint=(
1531                                 "If you want to create a recursive relationship, "
1532                                 'use ManyToManyField("%s", through="%s").'
1533                             )
1534                             % (
1535                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1536                                 relationship_model_name,
1537                             ),
1538                             obj=self,
1539                             id="fields.E334",
1540                         )
1541                     )
1542 
1543                 if seen_to > 1 and not self.remote_field.through_fields:
1544                     errors.append(
1545                         checks.Error(
1546                             "The model is used as an intermediate model by "
1547                             "'%s', but it has more than one foreign key "
1548                             "to '%s', which is ambiguous. You must specify "
1549                             "which foreign key Django should use via the "
1550                             "through_fields keyword argument." % (self, to_model_name),
1551                             hint=(
1552                                 "If you want to create a recursive relationship, "
1553                                 'use ManyToManyField("%s", through="%s").'
1554                             )
1555                             % (
1556                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1557                                 relationship_model_name,
1558                             ),
1559                             obj=self,
1560                             id="fields.E335",
1561                         )
1562                     )
1563 
1564                 if seen_from == 0 or seen_to == 0:
1565                     errors.append(
1566                         checks.Error(
1567                             "The model is used as an intermediate model by "
1568                             "'%s', but it does not have a foreign key to '%s' or '%s'."
1569                             % (self, from_model_name, to_model_name),
1570                             obj=self.remote_field.through,
1571                             id="fields.E336",
1572                         )
1573                     )
1574 
1575         # Validate `through_fields`.
1576         if self.remote_field.through_fields is not None:
1577             # Validate that we're given an iterable of at least two items
1578             # and that none of them is "falsy".
1579             if not (
1580                 len(self.remote_field.through_fields) >= 2
1581                 and self.remote_field.through_fields[0]
1582                 and self.remote_field.through_fields[1]
1583             ):
1584                 errors.append(
1585                     checks.Error(
1586                         "Field specifies 'through_fields' but does not provide "
1587                         "the names of the two link fields that should be used "
1588                         "for the relation through model '%s'." % qualified_model_name,
1589                         hint=(
1590                             "Make sure you specify 'through_fields' as "
1591                             "through_fields=('field1', 'field2')"
1592                         ),
1593                         obj=self,
1594                         id="fields.E337",
1595                     )
1596                 )
1597 
1598             # Validate the given through fields -- they should be actual
1599             # fields on the through model, and also be foreign keys to the
1600             # expected models.
1601             else:
1602                 assert from_model is not None, (
1603                     "ManyToManyField with intermediate "
1604                     "tables cannot be checked if you don't pass the model "
1605                     "where the field is attached to."
1606                 )
1607 
1608                 source, through, target = (
1609                     from_model,
1610                     self.remote_field.through,
1611                     self.remote_field.model,
1612                 )
1613                 source_field_name, target_field_name = self.remote_field.through_fields[
1614                     :2
1615                 ]
1616 
1617                 for field_name, related_model in (
1618                     (source_field_name, source),
1619                     (target_field_name, target),
1620                 ):
1621 
1622                     possible_field_names = []
1623                     for f in through._meta.fields:
1624                         if (
1625                             hasattr(f, "remote_field")
1626                             and getattr(f.remote_field, "model", None) == related_model
1627                         ):
1628                             possible_field_names.append(f.name)
1629                     if possible_field_names:
1630                         hint = (
1631                             "Did you mean one of the following foreign keys to '%s': "
1632                             "%s?"
1633                             % (
1634                                 related_model._meta.object_name,
1635                                 ", ".join(possible_field_names),
1636                             )
1637                         )
1638                     else:
1639                         hint = None
1640 
1641                     try:
1642                         field = through._meta.get_field(field_name)
1643                     except exceptions.FieldDoesNotExist:
1644                         errors.append(
1645                             checks.Error(
1646                                 "The intermediary model '%s' has no field '%s'."
1647                                 % (qualified_model_name, field_name),
1648                                 hint=hint,
1649                                 obj=self,
1650                                 id="fields.E338",
1651                             )
1652                         )
1653                     else:
1654                         if not (
1655                             hasattr(field, "remote_field")
1656                             and getattr(field.remote_field, "model", None)
1657                             == related_model
1658                         ):
1659                             errors.append(
1660                                 checks.Error(
1661                                     "'%s.%s' is not a foreign key to '%s'."
1662                                     % (
1663                                         through._meta.object_name,
1664                                         field_name,
1665                                         related_model._meta.object_name,
1666                                     ),
1667                                     hint=hint,
1668                                     obj=self,
1669                                     id="fields.E339",
1670                                 )
1671                             )
1672 
1673         return errors
1674 
1675     def _check_table_uniqueness(self, **kwargs):
1676         if (
1677             isinstance(self.remote_field.through, str)
1678             or not self.remote_field.through._meta.managed
1679         ):
1680             return []
1681         registered_tables = {
1682             model._meta.db_table: model
1683             for model in self.opts.apps.get_models(include_auto_created=True)
1684             if model != self.remote_field.through and model._meta.managed
1685         }
1686         m2m_db_table = self.m2m_db_table()
1687         model = registered_tables.get(m2m_db_table)
1688         # The second condition allows multiple m2m relations on a model if
1689         # some point to a through model that proxies another through model.
1690         if (
1691             model
1692             and model._meta.concrete_model
1693             != self.remote_field.through._meta.concrete_model
1694         ):
1695             if model._meta.auto_created:
1696 
1697                 def _get_field_name(model):
1698                     for field in model._meta.auto_created._meta.many_to_many:
1699                         if field.remote_field.through is model:
1700                             return field.name
1701 
1702                 opts = model._meta.auto_created._meta
1703                 clashing_obj = "%s.%s" % (opts.label, _get_field_name(model))
1704             else:
1705                 clashing_obj = model._meta.label
1706             if settings.DATABASE_ROUTERS:
1707                 error_class, error_id = checks.Warning, "fields.W344"
1708                 error_hint = (
1709                     "You have configured settings.DATABASE_ROUTERS. Verify "
1710                     "that the table of %r is correctly routed to a separate "
1711                     "database." % clashing_obj
1712                 )
1713             else:
1714                 error_class, error_id = checks.Error, "fields.E340"
1715                 error_hint = None
1716             return [
1717                 error_class(
1718                     "The field's intermediary table '%s' clashes with the "
1719                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1720                     obj=self,
1721                     hint=error_hint,
1722                     id=error_id,
1723                 )
1724             ]
1725         return []
1726 
1727     def deconstruct(self):
1728         name, path, args, kwargs = super().deconstruct()
1729         # Handle the simpler arguments.
1730         if self.db_table is not None:
1731             kwargs["db_table"] = self.db_table
1732         if self.remote_field.db_constraint is not True:
1733             kwargs["db_constraint"] = self.remote_field.db_constraint
1734         # Lowercase model names as they should be treated as case-insensitive.
1735         if isinstance(self.remote_field.model, str):
1736             if "." in self.remote_field.model:
1737                 app_label, model_name = self.remote_field.model.split(".")
1738                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
1739             else:
1740                 kwargs["to"] = self.remote_field.model.lower()
1741         else:
1742             kwargs["to"] = self.remote_field.model._meta.label_lower
1743         if getattr(self.remote_field, "through", None) is not None:
1744             if isinstance(self.remote_field.through, str):
1745                 kwargs["through"] = self.remote_field.through
1746             elif not self.remote_field.through._meta.auto_created:
1747                 kwargs["through"] = self.remote_field.through._meta.label
1748         # If swappable is True, then see if we're actually pointing to the target
1749         # of a swap.
1750         swappable_setting = self.swappable_setting
1751         if swappable_setting is not None:
1752             # If it's already a settings reference, error.
1753             if hasattr(kwargs["to"], "setting_name"):
1754                 if kwargs["to"].setting_name != swappable_setting:
1755                     raise ValueError(
1756                         "Cannot deconstruct a ManyToManyField pointing to a "
1757                         "model that is swapped in place of more than one model "
1758                         "(%s and %s)" % (kwargs["to"].setting_name, swappable_setting)
1759                     )
1760 
1761             kwargs["to"] = SettingsReference(
1762                 kwargs["to"],
1763                 swappable_setting,
1764             )
1765         return name, path, args, kwargs
1766 
1767     def _get_path_info(self, direct=False, filtered_relation=None):
1768         """Called by both direct and indirect m2m traversal."""
1769         int_model = self.remote_field.through
1770         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1771         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1772         if direct:
1773             join1infos = linkfield1.reverse_path_infos
1774             if filtered_relation:
1775                 join2infos = linkfield2.get_path_info(filtered_relation)
1776             else:
1777                 join2infos = linkfield2.path_infos
1778         else:
1779             join1infos = linkfield2.reverse_path_infos
1780             if filtered_relation:
1781                 join2infos = linkfield1.get_path_info(filtered_relation)
1782             else:
1783                 join2infos = linkfield1.path_infos
1784         # Get join infos between the last model of join 1 and the first model
1785         # of join 2. Assume the only reason these may differ is due to model
1786         # inheritance.
1787         join1_final = join1infos[-1].to_opts
1788         join2_initial = join2infos[0].from_opts
1789         if join1_final is join2_initial:
1790             intermediate_infos = []
1791         elif issubclass(join1_final.model, join2_initial.model):
1792             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1793         else:
1794             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1795 
1796         return [*join1infos, *intermediate_infos, *join2infos]
1797 
1798     def get_path_info(self, filtered_relation=None):
1799         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1800 
1801     @cached_property
1802     def path_infos(self):
1803         return self.get_path_info()
1804 
1805     def get_reverse_path_info(self, filtered_relation=None):
1806         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1807 
1808     @cached_property
1809     def reverse_path_infos(self):
1810         return self.get_reverse_path_info()
1811 
1812     def _get_m2m_db_table(self, opts):
1813         """
1814         Function that can be curried to provide the m2m table name for this
1815         relation.
1816         """
1817         if self.remote_field.through is not None:
1818             return self.remote_field.through._meta.db_table
1819         elif self.db_table:
1820             return self.db_table
1821         else:
1822             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
1823             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1824 
1825     def _get_m2m_attr(self, related, attr):
1826         """
1827         Function that can be curried to provide the source accessor or DB
1828         column name for the m2m table.
1829         """
1830         cache_attr = "_m2m_%s_cache" % attr
1831         if hasattr(self, cache_attr):
1832             return getattr(self, cache_attr)
1833         if self.remote_field.through_fields is not None:
1834             link_field_name = self.remote_field.through_fields[0]
1835         else:
1836             link_field_name = None
1837         for f in self.remote_field.through._meta.fields:
1838             if (
1839                 f.is_relation
1840                 and f.remote_field.model == related.related_model
1841                 and (link_field_name is None or link_field_name == f.name)
1842             ):
1843                 setattr(self, cache_attr, getattr(f, attr))
1844                 return getattr(self, cache_attr)
1845 
1846     def _get_m2m_reverse_attr(self, related, attr):
1847         """
1848         Function that can be curried to provide the related accessor or DB
1849         column name for the m2m table.
1850         """
1851         cache_attr = "_m2m_reverse_%s_cache" % attr
1852         if hasattr(self, cache_attr):
1853             return getattr(self, cache_attr)
1854         found = False
1855         if self.remote_field.through_fields is not None:
1856             link_field_name = self.remote_field.through_fields[1]
1857         else:
1858             link_field_name = None
1859         for f in self.remote_field.through._meta.fields:
1860             if f.is_relation and f.remote_field.model == related.model:
1861                 if link_field_name is None and related.related_model == related.model:
1862                     # If this is an m2m-intermediate to self,
1863                     # the first foreign key you find will be
1864                     # the source column. Keep searching for
1865                     # the second foreign key.
1866                     if found:
1867                         setattr(self, cache_attr, getattr(f, attr))
1868                         break
1869                     else:
1870                         found = True
1871                 elif link_field_name is None or link_field_name == f.name:
1872                     setattr(self, cache_attr, getattr(f, attr))
1873                     break
1874         return getattr(self, cache_attr)
1875 
1876     def contribute_to_class(self, cls, name, **kwargs):
1877         # To support multiple relations to self, it's useful to have a non-None
1878         # related name on symmetrical relations for internal reasons. The
1879         # concept doesn't make a lot of sense externally ("you want me to
1880         # specify *what* on my non-reversible relation?!"), so we set it up
1881         # automatically. The funky name reduces the chance of an accidental
1882         # clash.
1883         if self.remote_field.symmetrical and (
1884             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT
1885             or self.remote_field.model == cls._meta.object_name
1886         ):
1887             self.remote_field.related_name = "%s_rel_+" % name
1888         elif self.remote_field.is_hidden():
1889             # If the backwards relation is disabled, replace the original
1890             # related_name with one generated from the m2m field name. Django
1891             # still uses backwards relations internally and we need to avoid
1892             # clashes between multiple m2m fields with related_name == '+'.
1893             self.remote_field.related_name = "_%s_%s_%s_+" % (
1894                 cls._meta.app_label,
1895                 cls.__name__.lower(),
1896                 name,
1897             )
1898 
1899         super().contribute_to_class(cls, name, **kwargs)
1900 
1901         # The intermediate m2m model is not auto created if:
1902         #  1) There is a manually specified intermediate, or
1903         #  2) The class owning the m2m field is abstract.
1904         #  3) The class owning the m2m field has been swapped out.
1905         if not cls._meta.abstract:
1906             if self.remote_field.through:
1907 
1908                 def resolve_through_model(_, model, field):
1909                     field.remote_field.through = model
1910 
1911                 lazy_related_operation(
1912                     resolve_through_model, cls, self.remote_field.through, field=self
1913                 )
1914             elif not cls._meta.swapped:
1915                 self.remote_field.through = create_many_to_many_intermediary_model(
1916                     self, cls
1917                 )
1918 
1919         # Add the descriptor for the m2m relation.
1920         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1921 
1922         # Set up the accessor for the m2m table name for the relation.
1923         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1924 
1925     def contribute_to_related_class(self, cls, related):
1926         # Internal M2Ms (i.e., those with a related name ending with '+')
1927         # and swapped models don't get a related descriptor.
1928         if (
1929             not self.remote_field.is_hidden()
1930             and not related.related_model._meta.swapped
1931         ):
1932             setattr(
1933                 cls,
1934                 related.get_accessor_name(),
1935                 ManyToManyDescriptor(self.remote_field, reverse=True),
1936             )
1937 
1938         # Set up the accessors for the column names on the m2m table.
1939         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
1940         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
1941 
1942         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
1943         self.m2m_reverse_field_name = partial(
1944             self._get_m2m_reverse_attr, related, "name"
1945         )
1946 
1947         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
1948         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1949         get_m2m_reverse_rel = partial(
1950             self._get_m2m_reverse_attr, related, "remote_field"
1951         )
1952         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1953 
1954     def set_attributes_from_rel(self):
1955         pass
1956 
1957     def value_from_object(self, obj):
1958         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1959 
1960     def save_form_data(self, instance, data):
1961         getattr(instance, self.attname).set(data)
1962 
1963     def formfield(self, *, using=None, **kwargs):
1964         defaults = {
1965             "form_class": forms.ModelMultipleChoiceField,
1966             "queryset": self.remote_field.model._default_manager.using(using),
1967             **kwargs,
1968         }
1969         # If initial is passed in, it's a list of related objects, but the
1970         # MultipleChoiceField takes a list of IDs.
1971         if defaults.get("initial") is not None:
1972             initial = defaults["initial"]
1973             if callable(initial):
1974                 initial = initial()
1975             defaults["initial"] = [i.pk for i in initial]
1976         return super().formfield(**defaults)
1977 
1978     def db_check(self, connection):
1979         return None
1980 
1981     def db_type(self, connection):
1982         # A ManyToManyField is not represented by a single column,
1983         # so return None.
1984         return None
1985 
1986     def db_parameters(self, connection):
1987         return {"type": None, "check": None}

</code><intended_behavior>Modify the definition of ForeignKey fields (and related fields) to respect or optionally inherit `db_collation` from the referenced primary key field. This could involve adjusting the field's creation or alteration logic within Django's migration framework to include collation settings explicitly where necessary.</intended_behavior>, <file>django/db/migrations/operations/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db import models
2 from django.db.migrations.operations.base import Operation
3 from django.db.migrations.state import ModelState
4 from django.db.migrations.utils import field_references, resolve_relation
5 from django.db.models.options import normalize_together
6 from django.utils.functional import cached_property
7 
8 from .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField
9 
10 
11 def _check_for_duplicates(arg_name, objs):
12     used_vals = set()
13     for val in objs:
14         if val in used_vals:
15             raise ValueError(
16                 "Found duplicate value %s in CreateModel %s argument." % (val, arg_name)
17             )
18         used_vals.add(val)
19 
20 
21 class ModelOperation(Operation):
22     def __init__(self, name):
23         self.name = name
24 
25     @cached_property
26     def name_lower(self):
27         return self.name.lower()
28 
29     def references_model(self, name, app_label):
30         return name.lower() == self.name_lower
31 
32     def reduce(self, operation, app_label):
33         return super().reduce(operation, app_label) or self.can_reduce_through(
34             operation, app_label
35         )
36 
37     def can_reduce_through(self, operation, app_label):
38         return not operation.references_model(self.name, app_label)
39 
40 
41 class CreateModel(ModelOperation):
42     """Create a model's table."""
43 
44     serialization_expand_args = ["fields", "options", "managers"]
45 
46     def __init__(self, name, fields, options=None, bases=None, managers=None):
47         self.fields = fields
48         self.options = options or {}
49         self.bases = bases or (models.Model,)
50         self.managers = managers or []
51         super().__init__(name)
52         # Sanity-check that there are no duplicated field names, bases, or
53         # manager names
54         _check_for_duplicates("fields", (name for name, _ in self.fields))
55         _check_for_duplicates(
56             "bases",
57             (
58                 base._meta.label_lower
59                 if hasattr(base, "_meta")
60                 else base.lower()
61                 if isinstance(base, str)
62                 else base
63                 for base in self.bases
64             ),
65         )
66         _check_for_duplicates("managers", (name for name, _ in self.managers))
67 
68     def deconstruct(self):
69         kwargs = {
70             "name": self.name,
71             "fields": self.fields,
72         }
73         if self.options:
74             kwargs["options"] = self.options
75         if self.bases and self.bases != (models.Model,):
76             kwargs["bases"] = self.bases
77         if self.managers and self.managers != [("objects", models.Manager())]:
78             kwargs["managers"] = self.managers
79         return (self.__class__.__qualname__, [], kwargs)
80 
81     def state_forwards(self, app_label, state):
82         state.add_model(
83             ModelState(
84                 app_label,
85                 self.name,
86                 list(self.fields),
87                 dict(self.options),
88                 tuple(self.bases),
89                 list(self.managers),
90             )
91         )
92 
93     def database_forwards(self, app_label, schema_editor, from_state, to_state):
94         model = to_state.apps.get_model(app_label, self.name)
95         if self.allow_migrate_model(schema_editor.connection.alias, model):
96             schema_editor.create_model(model)
97 
98     def database_backwards(self, app_label, schema_editor, from_state, to_state):
99         model = from_state.apps.get_model(app_label, self.name)
100         if self.allow_migrate_model(schema_editor.connection.alias, model):
101             schema_editor.delete_model(model)
102 
103     def describe(self):
104         return "Create %smodel %s" % (
105             "proxy " if self.options.get("proxy", False) else "",
106             self.name,
107         )
108 
109     @property
110     def migration_name_fragment(self):
111         return self.name_lower
112 
113     def references_model(self, name, app_label):
114         name_lower = name.lower()
115         if name_lower == self.name_lower:
116             return True
117 
118         # Check we didn't inherit from the model
119         reference_model_tuple = (app_label, name_lower)
120         for base in self.bases:
121             if (
122                 base is not models.Model
123                 and isinstance(base, (models.base.ModelBase, str))
124                 and resolve_relation(base, app_label) == reference_model_tuple
125             ):
126                 return True
127 
128         # Check we have no FKs/M2Ms with it
129         for _name, field in self.fields:
130             if field_references(
131                 (app_label, self.name_lower), field, reference_model_tuple
132             ):
133                 return True
134         return False
135 
136     def reduce(self, operation, app_label):
137         if (
138             isinstance(operation, DeleteModel)
139             and self.name_lower == operation.name_lower
140             and not self.options.get("proxy", False)
141         ):
142             return []
143         elif (
144             isinstance(operation, RenameModel)
145             and self.name_lower == operation.old_name_lower
146         ):
147             return [
148                 CreateModel(
149                     operation.new_name,
150                     fields=self.fields,
151                     options=self.options,
152                     bases=self.bases,
153                     managers=self.managers,
154                 ),
155             ]
156         elif (
157             isinstance(operation, AlterModelOptions)
158             and self.name_lower == operation.name_lower
159         ):
160             options = {**self.options, **operation.options}
161             for key in operation.ALTER_OPTION_KEYS:
162                 if key not in operation.options:
163                     options.pop(key, None)
164             return [
165                 CreateModel(
166                     self.name,
167                     fields=self.fields,
168                     options=options,
169                     bases=self.bases,
170                     managers=self.managers,
171                 ),
172             ]
173         elif (
174             isinstance(operation, AlterModelManagers)
175             and self.name_lower == operation.name_lower
176         ):
177             return [
178                 CreateModel(
179                     self.name,
180                     fields=self.fields,
181                     options=self.options,
182                     bases=self.bases,
183                     managers=operation.managers,
184                 ),
185             ]
186         elif (
187             isinstance(operation, AlterTogetherOptionOperation)
188             and self.name_lower == operation.name_lower
189         ):
190             return [
191                 CreateModel(
192                     self.name,
193                     fields=self.fields,
194                     options={
195                         **self.options,
196                         **{operation.option_name: operation.option_value},
197                     },
198                     bases=self.bases,
199                     managers=self.managers,
200                 ),
201             ]
202         elif (
203             isinstance(operation, AlterOrderWithRespectTo)
204             and self.name_lower == operation.name_lower
205         ):
206             return [
207                 CreateModel(
208                     self.name,
209                     fields=self.fields,
210                     options={
211                         **self.options,
212                         "order_with_respect_to": operation.order_with_respect_to,
213                     },
214                     bases=self.bases,
215                     managers=self.managers,
216                 ),
217             ]
218         elif (
219             isinstance(operation, FieldOperation)
220             and self.name_lower == operation.model_name_lower
221         ):
222             if isinstance(operation, AddField):
223                 return [
224                     CreateModel(
225                         self.name,
226                         fields=self.fields + [(operation.name, operation.field)],
227                         options=self.options,
228                         bases=self.bases,
229                         managers=self.managers,
230                     ),
231                 ]
232             elif isinstance(operation, AlterField):
233                 return [
234                     CreateModel(
235                         self.name,
236                         fields=[
237                             (n, operation.field if n == operation.name else v)
238                             for n, v in self.fields
239                         ],
240                         options=self.options,
241                         bases=self.bases,
242                         managers=self.managers,
243                     ),
244                 ]
245             elif isinstance(operation, RemoveField):
246                 options = self.options.copy()
247                 for option_name in ("unique_together", "index_together"):
248                     option = options.pop(option_name, None)
249                     if option:
250                         option = set(
251                             filter(
252                                 bool,
253                                 (
254                                     tuple(
255                                         f for f in fields if f != operation.name_lower
256                                     )
257                                     for fields in option
258                                 ),
259                             )
260                         )
261                         if option:
262                             options[option_name] = option
263                 order_with_respect_to = options.get("order_with_respect_to")
264                 if order_with_respect_to == operation.name_lower:
265                     del options["order_with_respect_to"]
266                 return [
267                     CreateModel(
268                         self.name,
269                         fields=[
270                             (n, v)
271                             for n, v in self.fields
272                             if n.lower() != operation.name_lower
273                         ],
274                         options=options,
275                         bases=self.bases,
276                         managers=self.managers,
277                     ),
278                 ]
279             elif isinstance(operation, RenameField):
280                 options = self.options.copy()
281                 for option_name in ("unique_together", "index_together"):
282                     option = options.get(option_name)
283                     if option:
284                         options[option_name] = {
285                             tuple(
286                                 operation.new_name if f == operation.old_name else f
287                                 for f in fields
288                             )
289                             for fields in option
290                         }
291                 order_with_respect_to = options.get("order_with_respect_to")
292                 if order_with_respect_to == operation.old_name:
293                     options["order_with_respect_to"] = operation.new_name
294                 return [
295                     CreateModel(
296                         self.name,
297                         fields=[
298                             (operation.new_name if n == operation.old_name else n, v)
299                             for n, v in self.fields
300                         ],
301                         options=options,
302                         bases=self.bases,
303                         managers=self.managers,
304                     ),
305                 ]
306         return super().reduce(operation, app_label)
307 
308 
309 class DeleteModel(ModelOperation):
310     """Drop a model's table."""
311 
312     def deconstruct(self):
313         kwargs = {
314             "name": self.name,
315         }
316         return (self.__class__.__qualname__, [], kwargs)
317 
318     def state_forwards(self, app_label, state):
319         state.remove_model(app_label, self.name_lower)
320 
321     def database_forwards(self, app_label, schema_editor, from_state, to_state):
322         model = from_state.apps.get_model(app_label, self.name)
323         if self.allow_migrate_model(schema_editor.connection.alias, model):
324             schema_editor.delete_model(model)
325 
326     def database_backwards(self, app_label, schema_editor, from_state, to_state):
327         model = to_state.apps.get_model(app_label, self.name)
328         if self.allow_migrate_model(schema_editor.connection.alias, model):
329             schema_editor.create_model(model)
330 
331     def references_model(self, name, app_label):
332         # The deleted model could be referencing the specified model through
333         # related fields.
334         return True
335 
336     def describe(self):
337         return "Delete model %s" % self.name
338 
339     @property
340     def migration_name_fragment(self):
341         return "delete_%s" % self.name_lower
342 
343 
344 class RenameModel(ModelOperation):
345     """Rename a model."""
346 
347     def __init__(self, old_name, new_name):
348         self.old_name = old_name
349         self.new_name = new_name
350         super().__init__(old_name)
351 
352     @cached_property
353     def old_name_lower(self):
354         return self.old_name.lower()
355 
356     @cached_property
357     def new_name_lower(self):
358         return self.new_name.lower()
359 
360     def deconstruct(self):
361         kwargs = {
362             "old_name": self.old_name,
363             "new_name": self.new_name,
364         }
365         return (self.__class__.__qualname__, [], kwargs)
366 
367     def state_forwards(self, app_label, state):
368         state.rename_model(app_label, self.old_name, self.new_name)
369 
370     def database_forwards(self, app_label, schema_editor, from_state, to_state):
371         new_model = to_state.apps.get_model(app_label, self.new_name)
372         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
373             old_model = from_state.apps.get_model(app_label, self.old_name)
374             old_db_table = old_model._meta.db_table
375             new_db_table = new_model._meta.db_table
376             # Don't alter when a table name is not changed.
377             if old_db_table == new_db_table:
378                 return
379             # Move the main table
380             schema_editor.alter_db_table(new_model, old_db_table, new_db_table)
381             # Alter the fields pointing to us
382             for related_object in old_model._meta.related_objects:
383                 if related_object.related_model == old_model:
384                     model = new_model
385                     related_key = (app_label, self.new_name_lower)
386                 else:
387                     model = related_object.related_model
388                     related_key = (
389                         related_object.related_model._meta.app_label,
390                         related_object.related_model._meta.model_name,
391                     )
392                 to_field = to_state.apps.get_model(*related_key)._meta.get_field(
393                     related_object.field.name
394                 )
395                 schema_editor.alter_field(
396                     model,
397                     related_object.field,
398                     to_field,
399                 )
400             # Rename M2M fields whose name is based on this model's name.
401             fields = zip(
402                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
403             )
404             for (old_field, new_field) in fields:
405                 # Skip self-referential fields as these are renamed above.
406                 if (
407                     new_field.model == new_field.related_model
408                     or not new_field.remote_field.through._meta.auto_created
409                 ):
410                     continue
411                 # Rename the M2M table that's based on this model's name.
412                 old_m2m_model = old_field.remote_field.through
413                 new_m2m_model = new_field.remote_field.through
414                 schema_editor.alter_db_table(
415                     new_m2m_model,
416                     old_m2m_model._meta.db_table,
417                     new_m2m_model._meta.db_table,
418                 )
419                 # Rename the column in the M2M table that's based on this
420                 # model's name.
421                 schema_editor.alter_field(
422                     new_m2m_model,
423                     old_m2m_model._meta.get_field(old_model._meta.model_name),
424                     new_m2m_model._meta.get_field(new_model._meta.model_name),
425                 )
426 
427     def database_backwards(self, app_label, schema_editor, from_state, to_state):
428         self.new_name_lower, self.old_name_lower = (
429             self.old_name_lower,
430             self.new_name_lower,
431         )
432         self.new_name, self.old_name = self.old_name, self.new_name
433 
434         self.database_forwards(app_label, schema_editor, from_state, to_state)
435 
436         self.new_name_lower, self.old_name_lower = (
437             self.old_name_lower,
438             self.new_name_lower,
439         )
440         self.new_name, self.old_name = self.old_name, self.new_name
441 
442     def references_model(self, name, app_label):
443         return (
444             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower
445         )
446 
447     def describe(self):
448         return "Rename model %s to %s" % (self.old_name, self.new_name)
449 
450     @property
451     def migration_name_fragment(self):
452         return "rename_%s_%s" % (self.old_name_lower, self.new_name_lower)
453 
454     def reduce(self, operation, app_label):
455         if (
456             isinstance(operation, RenameModel)
457             and self.new_name_lower == operation.old_name_lower
458         ):
459             return [
460                 RenameModel(
461                     self.old_name,
462                     operation.new_name,
463                 ),
464             ]
465         # Skip `ModelOperation.reduce` as we want to run `references_model`
466         # against self.new_name.
467         return super(ModelOperation, self).reduce(
468             operation, app_label
469         ) or not operation.references_model(self.new_name, app_label)
470 
471 
472 class ModelOptionOperation(ModelOperation):
473     def reduce(self, operation, app_label):
474         if (
475             isinstance(operation, (self.__class__, DeleteModel))
476             and self.name_lower == operation.name_lower
477         ):
478             return [operation]
479         return super().reduce(operation, app_label)
480 
481 
482 class AlterModelTable(ModelOptionOperation):
483     """Rename a model's table."""
484 
485     def __init__(self, name, table):
486         self.table = table
487         super().__init__(name)
488 
489     def deconstruct(self):
490         kwargs = {
491             "name": self.name,
492             "table": self.table,
493         }
494         return (self.__class__.__qualname__, [], kwargs)
495 
496     def state_forwards(self, app_label, state):
497         state.alter_model_options(app_label, self.name_lower, {"db_table": self.table})
498 
499     def database_forwards(self, app_label, schema_editor, from_state, to_state):
500         new_model = to_state.apps.get_model(app_label, self.name)
501         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
502             old_model = from_state.apps.get_model(app_label, self.name)
503             schema_editor.alter_db_table(
504                 new_model,
505                 old_model._meta.db_table,
506                 new_model._meta.db_table,
507             )
508             # Rename M2M fields whose name is based on this model's db_table
509             for (old_field, new_field) in zip(
510                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many
511             ):
512                 if new_field.remote_field.through._meta.auto_created:
513                     schema_editor.alter_db_table(
514                         new_field.remote_field.through,
515                         old_field.remote_field.through._meta.db_table,
516                         new_field.remote_field.through._meta.db_table,
517                     )
518 
519     def database_backwards(self, app_label, schema_editor, from_state, to_state):
520         return self.database_forwards(app_label, schema_editor, from_state, to_state)
521 
522     def describe(self):
523         return "Rename table for %s to %s" % (
524             self.name,
525             self.table if self.table is not None else "(default)",
526         )
527 
528     @property
529     def migration_name_fragment(self):
530         return "alter_%s_table" % self.name_lower
531 
532 
533 class AlterTogetherOptionOperation(ModelOptionOperation):
534     option_name = None
535 
536     def __init__(self, name, option_value):
537         if option_value:
538             option_value = set(normalize_together(option_value))
539         setattr(self, self.option_name, option_value)
540         super().__init__(name)
541 
542     @cached_property
543     def option_value(self):
544         return getattr(self, self.option_name)
545 
546     def deconstruct(self):
547         kwargs = {
548             "name": self.name,
549             self.option_name: self.option_value,
550         }
551         return (self.__class__.__qualname__, [], kwargs)
552 
553     def state_forwards(self, app_label, state):
554         state.alter_model_options(
555             app_label,
556             self.name_lower,
557             {self.option_name: self.option_value},
558         )
559 
560     def database_forwards(self, app_label, schema_editor, from_state, to_state):
561         new_model = to_state.apps.get_model(app_label, self.name)
562         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
563             old_model = from_state.apps.get_model(app_label, self.name)
564             alter_together = getattr(schema_editor, "alter_%s" % self.option_name)
565             alter_together(
566                 new_model,
567                 getattr(old_model._meta, self.option_name, set()),
568                 getattr(new_model._meta, self.option_name, set()),
569             )
570 
571     def database_backwards(self, app_label, schema_editor, from_state, to_state):
572         return self.database_forwards(app_label, schema_editor, from_state, to_state)
573 
574     def references_field(self, model_name, name, app_label):
575         return self.references_model(model_name, app_label) and (
576             not self.option_value
577             or any((name in fields) for fields in self.option_value)
578         )
579 
580     def describe(self):
581         return "Alter %s for %s (%s constraint(s))" % (
582             self.option_name,
583             self.name,
584             len(self.option_value or ""),
585         )
586 
587     @property
588     def migration_name_fragment(self):
589         return "alter_%s_%s" % (self.name_lower, self.option_name)
590 
591     def can_reduce_through(self, operation, app_label):
592         return super().can_reduce_through(operation, app_label) or (
593             isinstance(operation, AlterTogetherOptionOperation)
594             and type(operation) is not type(self)
595         )
596 
597 
598 class AlterUniqueTogether(AlterTogetherOptionOperation):
599     """
600     Change the value of unique_together to the target one.
601     Input value of unique_together must be a set of tuples.
602     """
603 
604     option_name = "unique_together"
605 
606     def __init__(self, name, unique_together):
607         super().__init__(name, unique_together)
608 
609 
610 class AlterIndexTogether(AlterTogetherOptionOperation):
611     """
612     Change the value of index_together to the target one.
613     Input value of index_together must be a set of tuples.
614     """
615 
616     option_name = "index_together"
617 
618     def __init__(self, name, index_together):
619         super().__init__(name, index_together)
620 
621 
622 class AlterOrderWithRespectTo(ModelOptionOperation):
623     """Represent a change with the order_with_respect_to option."""
624 
625     option_name = "order_with_respect_to"
626 
627     def __init__(self, name, order_with_respect_to):
628         self.order_with_respect_to = order_with_respect_to
629         super().__init__(name)
630 
631     def deconstruct(self):
632         kwargs = {
633             "name": self.name,
634             "order_with_respect_to": self.order_with_respect_to,
635         }
636         return (self.__class__.__qualname__, [], kwargs)
637 
638     def state_forwards(self, app_label, state):
639         state.alter_model_options(
640             app_label,
641             self.name_lower,
642             {self.option_name: self.order_with_respect_to},
643         )
644 
645     def database_forwards(self, app_label, schema_editor, from_state, to_state):
646         to_model = to_state.apps.get_model(app_label, self.name)
647         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
648             from_model = from_state.apps.get_model(app_label, self.name)
649             # Remove a field if we need to
650             if (
651                 from_model._meta.order_with_respect_to
652                 and not to_model._meta.order_with_respect_to
653             ):
654                 schema_editor.remove_field(
655                     from_model, from_model._meta.get_field("_order")
656                 )
657             # Add a field if we need to (altering the column is untouched as
658             # it's likely a rename)
659             elif (
660                 to_model._meta.order_with_respect_to
661                 and not from_model._meta.order_with_respect_to
662             ):
663                 field = to_model._meta.get_field("_order")
664                 if not field.has_default():
665                     field.default = 0
666                 schema_editor.add_field(
667                     from_model,
668                     field,
669                 )
670 
671     def database_backwards(self, app_label, schema_editor, from_state, to_state):
672         self.database_forwards(app_label, schema_editor, from_state, to_state)
673 
674     def references_field(self, model_name, name, app_label):
675         return self.references_model(model_name, app_label) and (
676             self.order_with_respect_to is None or name == self.order_with_respect_to
677         )
678 
679     def describe(self):
680         return "Set order_with_respect_to on %s to %s" % (
681             self.name,
682             self.order_with_respect_to,
683         )
684 
685     @property
686     def migration_name_fragment(self):
687         return "alter_%s_order_with_respect_to" % self.name_lower
688 
689 
690 class AlterModelOptions(ModelOptionOperation):
691     """
692     Set new model options that don't directly affect the database schema
693     (like verbose_name, permissions, ordering). Python code in migrations
694     may still need them.
695     """
696 
697     # Model options we want to compare and preserve in an AlterModelOptions op
698     ALTER_OPTION_KEYS = [
699         "base_manager_name",
700         "default_manager_name",
701         "default_related_name",
702         "get_latest_by",
703         "managed",
704         "ordering",
705         "permissions",
706         "default_permissions",
707         "select_on_save",
708         "verbose_name",
709         "verbose_name_plural",
710     ]
711 
712     def __init__(self, name, options):
713         self.options = options
714         super().__init__(name)
715 
716     def deconstruct(self):
717         kwargs = {
718             "name": self.name,
719             "options": self.options,
720         }
721         return (self.__class__.__qualname__, [], kwargs)
722 
723     def state_forwards(self, app_label, state):
724         state.alter_model_options(
725             app_label,
726             self.name_lower,
727             self.options,
728             self.ALTER_OPTION_KEYS,
729         )
730 
731     def database_forwards(self, app_label, schema_editor, from_state, to_state):
732         pass
733 
734     def database_backwards(self, app_label, schema_editor, from_state, to_state):
735         pass
736 
737     def describe(self):
738         return "Change Meta options on %s" % self.name
739 
740     @property
741     def migration_name_fragment(self):
742         return "alter_%s_options" % self.name_lower
743 
744 
745 class AlterModelManagers(ModelOptionOperation):
746     """Alter the model's managers."""
747 
748     serialization_expand_args = ["managers"]
749 
750     def __init__(self, name, managers):
751         self.managers = managers
752         super().__init__(name)
753 
754     def deconstruct(self):
755         return (self.__class__.__qualname__, [self.name, self.managers], {})
756 
757     def state_forwards(self, app_label, state):
758         state.alter_model_managers(app_label, self.name_lower, self.managers)
759 
760     def database_forwards(self, app_label, schema_editor, from_state, to_state):
761         pass
762 
763     def database_backwards(self, app_label, schema_editor, from_state, to_state):
764         pass
765 
766     def describe(self):
767         return "Change managers on %s" % self.name
768 
769     @property
770     def migration_name_fragment(self):
771         return "alter_%s_managers" % self.name_lower
772 
773 
774 class IndexOperation(Operation):
775     option_name = "indexes"
776 
777     @cached_property
778     def model_name_lower(self):
779         return self.model_name.lower()
780 
781 
782 class AddIndex(IndexOperation):
783     """Add an index on a model."""
784 
785     def __init__(self, model_name, index):
786         self.model_name = model_name
787         if not index.name:
788             raise ValueError(
789                 "Indexes passed to AddIndex operations require a name "
790                 "argument. %r doesn't have one." % index
791             )
792         self.index = index
793 
794     def state_forwards(self, app_label, state):
795         state.add_index(app_label, self.model_name_lower, self.index)
796 
797     def database_forwards(self, app_label, schema_editor, from_state, to_state):
798         model = to_state.apps.get_model(app_label, self.model_name)
799         if self.allow_migrate_model(schema_editor.connection.alias, model):
800             schema_editor.add_index(model, self.index)
801 
802     def database_backwards(self, app_label, schema_editor, from_state, to_state):
803         model = from_state.apps.get_model(app_label, self.model_name)
804         if self.allow_migrate_model(schema_editor.connection.alias, model):
805             schema_editor.remove_index(model, self.index)
806 
807     def deconstruct(self):
808         kwargs = {
809             "model_name": self.model_name,
810             "index": self.index,
811         }
812         return (
813             self.__class__.__qualname__,
814             [],
815             kwargs,
816         )
817 
818     def describe(self):
819         if self.index.expressions:
820             return "Create index %s on %s on model %s" % (
821                 self.index.name,
822                 ", ".join([str(expression) for expression in self.index.expressions]),
823                 self.model_name,
824             )
825         return "Create index %s on field(s) %s of model %s" % (
826             self.index.name,
827             ", ".join(self.index.fields),
828             self.model_name,
829         )
830 
831     @property
832     def migration_name_fragment(self):
833         return "%s_%s" % (self.model_name_lower, self.index.name.lower())
834 
835 
836 class RemoveIndex(IndexOperation):
837     """Remove an index from a model."""
838 
839     def __init__(self, model_name, name):
840         self.model_name = model_name
841         self.name = name
842 
843     def state_forwards(self, app_label, state):
844         state.remove_index(app_label, self.model_name_lower, self.name)
845 
846     def database_forwards(self, app_label, schema_editor, from_state, to_state):
847         model = from_state.apps.get_model(app_label, self.model_name)
848         if self.allow_migrate_model(schema_editor.connection.alias, model):
849             from_model_state = from_state.models[app_label, self.model_name_lower]
850             index = from_model_state.get_index_by_name(self.name)
851             schema_editor.remove_index(model, index)
852 
853     def database_backwards(self, app_label, schema_editor, from_state, to_state):
854         model = to_state.apps.get_model(app_label, self.model_name)
855         if self.allow_migrate_model(schema_editor.connection.alias, model):
856             to_model_state = to_state.models[app_label, self.model_name_lower]
857             index = to_model_state.get_index_by_name(self.name)
858             schema_editor.add_index(model, index)
859 
860     def deconstruct(self):
861         kwargs = {
862             "model_name": self.model_name,
863             "name": self.name,
864         }
865         return (
866             self.__class__.__qualname__,
867             [],
868             kwargs,
869         )
870 
871     def describe(self):
872         return "Remove index %s from %s" % (self.name, self.model_name)
873 
874     @property
875     def migration_name_fragment(self):
876         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())
877 
878 
879 class AddConstraint(IndexOperation):
880     option_name = "constraints"
881 
882     def __init__(self, model_name, constraint):
883         self.model_name = model_name
884         self.constraint = constraint
885 
886     def state_forwards(self, app_label, state):
887         state.add_constraint(app_label, self.model_name_lower, self.constraint)
888 
889     def database_forwards(self, app_label, schema_editor, from_state, to_state):
890         model = to_state.apps.get_model(app_label, self.model_name)
891         if self.allow_migrate_model(schema_editor.connection.alias, model):
892             schema_editor.add_constraint(model, self.constraint)
893 
894     def database_backwards(self, app_label, schema_editor, from_state, to_state):
895         model = to_state.apps.get_model(app_label, self.model_name)
896         if self.allow_migrate_model(schema_editor.connection.alias, model):
897             schema_editor.remove_constraint(model, self.constraint)
898 
899     def deconstruct(self):
900         return (
901             self.__class__.__name__,
902             [],
903             {
904                 "model_name": self.model_name,
905                 "constraint": self.constraint,
906             },
907         )
908 
909     def describe(self):
910         return "Create constraint %s on model %s" % (
911             self.constraint.name,
912             self.model_name,
913         )
914 
915     @property
916     def migration_name_fragment(self):
917         return "%s_%s" % (self.model_name_lower, self.constraint.name.lower())
918 
919 
920 class RemoveConstraint(IndexOperation):
921     option_name = "constraints"
922 
923     def __init__(self, model_name, name):
924         self.model_name = model_name
925         self.name = name
926 
927     def state_forwards(self, app_label, state):
928         state.remove_constraint(app_label, self.model_name_lower, self.name)
929 
930     def database_forwards(self, app_label, schema_editor, from_state, to_state):
931         model = to_state.apps.get_model(app_label, self.model_name)
932         if self.allow_migrate_model(schema_editor.connection.alias, model):
933             from_model_state = from_state.models[app_label, self.model_name_lower]
934             constraint = from_model_state.get_constraint_by_name(self.name)
935             schema_editor.remove_constraint(model, constraint)
936 
937     def database_backwards(self, app_label, schema_editor, from_state, to_state):
938         model = to_state.apps.get_model(app_label, self.model_name)
939         if self.allow_migrate_model(schema_editor.connection.alias, model):
940             to_model_state = to_state.models[app_label, self.model_name_lower]
941             constraint = to_model_state.get_constraint_by_name(self.name)
942             schema_editor.add_constraint(model, constraint)
943 
944     def deconstruct(self):
945         return (
946             self.__class__.__name__,
947             [],
948             {
949                 "model_name": self.model_name,
950                 "name": self.name,
951             },
952         )
953 
954     def describe(self):
955         return "Remove constraint %s from model %s" % (self.name, self.model_name)
956 
957     @property
958     def migration_name_fragment(self):
959         return "remove_%s_%s" % (self.model_name_lower, self.name.lower())

</code><intended_behavior>Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key.</intended_behavior>, <file>django/db/migrations/state.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from collections import defaultdict
3 from contextlib import contextmanager
4 from functools import partial
5 
6 from django.apps import AppConfig
7 from django.apps.registry import Apps
8 from django.apps.registry import apps as global_apps
9 from django.conf import settings
10 from django.core.exceptions import FieldDoesNotExist
11 from django.db import models
12 from django.db.migrations.utils import field_is_referenced, get_references
13 from django.db.models import NOT_PROVIDED
14 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT
15 from django.db.models.options import DEFAULT_NAMES, normalize_together
16 from django.db.models.utils import make_model_tuple
17 from django.utils.functional import cached_property
18 from django.utils.module_loading import import_string
19 from django.utils.version import get_docs_version
20 
21 from .exceptions import InvalidBasesError
22 from .utils import resolve_relation
23 
24 
25 def _get_app_label_and_model_name(model, app_label=""):
26     if isinstance(model, str):
27         split = model.split(".", 1)
28         return tuple(split) if len(split) == 2 else (app_label, split[0])
29     else:
30         return model._meta.app_label, model._meta.model_name
31 
32 
33 def _get_related_models(m):
34     """Return all models that have a direct relationship to the given model."""
35     related_models = [
36         subclass
37         for subclass in m.__subclasses__()
38         if issubclass(subclass, models.Model)
39     ]
40     related_fields_models = set()
41     for f in m._meta.get_fields(include_parents=True, include_hidden=True):
42         if (
43             f.is_relation
44             and f.related_model is not None
45             and not isinstance(f.related_model, str)
46         ):
47             related_fields_models.add(f.model)
48             related_models.append(f.related_model)
49     # Reverse accessors of foreign keys to proxy models are attached to their
50     # concrete proxied model.
51     opts = m._meta
52     if opts.proxy and m in related_fields_models:
53         related_models.append(opts.concrete_model)
54     return related_models
55 
56 
57 def get_related_models_tuples(model):
58     """
59     Return a list of typical (app_label, model_name) tuples for all related
60     models for the given model.
61     """
62     return {
63         (rel_mod._meta.app_label, rel_mod._meta.model_name)
64         for rel_mod in _get_related_models(model)
65     }
66 
67 
68 def get_related_models_recursive(model):
69     """
70     Return all models that have a direct or indirect relationship
71     to the given model.
72 
73     Relationships are either defined by explicit relational fields, like
74     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
75     model (a superclass is related to its subclasses, but not vice versa). Note,
76     however, that a model inheriting from a concrete model is also related to
77     its superclass through the implicit *_ptr OneToOneField on the subclass.
78     """
79     seen = set()
80     queue = _get_related_models(model)
81     for rel_mod in queue:
82         rel_app_label, rel_model_name = (
83             rel_mod._meta.app_label,
84             rel_mod._meta.model_name,
85         )
86         if (rel_app_label, rel_model_name) in seen:
87             continue
88         seen.add((rel_app_label, rel_model_name))
89         queue.extend(_get_related_models(rel_mod))
90     return seen - {(model._meta.app_label, model._meta.model_name)}
91 
92 
93 class ProjectState:
94     """
95     Represent the entire project's overall state. This is the item that is
96     passed around - do it here rather than at the app level so that cross-app
97     FKs/etc. resolve properly.
98     """
99 
100     def __init__(self, models=None, real_apps=None):
101         self.models = models or {}
102         # Apps to include from main registry, usually unmigrated ones
103         if real_apps is None:
104             real_apps = set()
105         else:
106             assert isinstance(real_apps, set)
107         self.real_apps = real_apps
108         self.is_delayed = False
109         # {remote_model_key: {model_key: {field_name: field}}}
110         self._relations = None
111 
112     @property
113     def relations(self):
114         if self._relations is None:
115             self.resolve_fields_and_relations()
116         return self._relations
117 
118     def add_model(self, model_state):
119         model_key = model_state.app_label, model_state.name_lower
120         self.models[model_key] = model_state
121         if self._relations is not None:
122             self.resolve_model_relations(model_key)
123         if "apps" in self.__dict__:  # hasattr would cache the property
124             self.reload_model(*model_key)
125 
126     def remove_model(self, app_label, model_name):
127         model_key = app_label, model_name
128         del self.models[model_key]
129         if self._relations is not None:
130             self._relations.pop(model_key, None)
131             # Call list() since _relations can change size during iteration.
132             for related_model_key, model_relations in list(self._relations.items()):
133                 model_relations.pop(model_key, None)
134                 if not model_relations:
135                     del self._relations[related_model_key]
136         if "apps" in self.__dict__:  # hasattr would cache the property
137             self.apps.unregister_model(*model_key)
138             # Need to do this explicitly since unregister_model() doesn't clear
139             # the cache automatically (#24513)
140             self.apps.clear_cache()
141 
142     def rename_model(self, app_label, old_name, new_name):
143         # Add a new model.
144         old_name_lower = old_name.lower()
145         new_name_lower = new_name.lower()
146         renamed_model = self.models[app_label, old_name_lower].clone()
147         renamed_model.name = new_name
148         self.models[app_label, new_name_lower] = renamed_model
149         # Repoint all fields pointing to the old model to the new one.
150         old_model_tuple = (app_label, old_name_lower)
151         new_remote_model = f"{app_label}.{new_name}"
152         to_reload = set()
153         for model_state, name, field, reference in get_references(
154             self, old_model_tuple
155         ):
156             changed_field = None
157             if reference.to:
158                 changed_field = field.clone()
159                 changed_field.remote_field.model = new_remote_model
160             if reference.through:
161                 if changed_field is None:
162                     changed_field = field.clone()
163                 changed_field.remote_field.through = new_remote_model
164             if changed_field:
165                 model_state.fields[name] = changed_field
166                 to_reload.add((model_state.app_label, model_state.name_lower))
167         if self._relations is not None:
168             old_name_key = app_label, old_name_lower
169             new_name_key = app_label, new_name_lower
170             if old_name_key in self._relations:
171                 self._relations[new_name_key] = self._relations.pop(old_name_key)
172             for model_relations in self._relations.values():
173                 if old_name_key in model_relations:
174                     model_relations[new_name_key] = model_relations.pop(old_name_key)
175         # Reload models related to old model before removing the old model.
176         self.reload_models(to_reload, delay=True)
177         # Remove the old model.
178         self.remove_model(app_label, old_name_lower)
179         self.reload_model(app_label, new_name_lower, delay=True)
180 
181     def alter_model_options(self, app_label, model_name, options, option_keys=None):
182         model_state = self.models[app_label, model_name]
183         model_state.options = {**model_state.options, **options}
184         if option_keys:
185             for key in option_keys:
186                 if key not in options:
187                     model_state.options.pop(key, False)
188         self.reload_model(app_label, model_name, delay=True)
189 
190     def alter_model_managers(self, app_label, model_name, managers):
191         model_state = self.models[app_label, model_name]
192         model_state.managers = list(managers)
193         self.reload_model(app_label, model_name, delay=True)
194 
195     def _append_option(self, app_label, model_name, option_name, obj):
196         model_state = self.models[app_label, model_name]
197         model_state.options[option_name] = [*model_state.options[option_name], obj]
198         self.reload_model(app_label, model_name, delay=True)
199 
200     def _remove_option(self, app_label, model_name, option_name, obj_name):
201         model_state = self.models[app_label, model_name]
202         objs = model_state.options[option_name]
203         model_state.options[option_name] = [obj for obj in objs if obj.name != obj_name]
204         self.reload_model(app_label, model_name, delay=True)
205 
206     def add_index(self, app_label, model_name, index):
207         self._append_option(app_label, model_name, "indexes", index)
208 
209     def remove_index(self, app_label, model_name, index_name):
210         self._remove_option(app_label, model_name, "indexes", index_name)
211 
212     def add_constraint(self, app_label, model_name, constraint):
213         self._append_option(app_label, model_name, "constraints", constraint)
214 
215     def remove_constraint(self, app_label, model_name, constraint_name):
216         self._remove_option(app_label, model_name, "constraints", constraint_name)
217 
218     def add_field(self, app_label, model_name, name, field, preserve_default):
219         # If preserve default is off, don't use the default for future state.
220         if not preserve_default:
221             field = field.clone()
222             field.default = NOT_PROVIDED
223         else:
224             field = field
225         model_key = app_label, model_name
226         self.models[model_key].fields[name] = field
227         if self._relations is not None:
228             self.resolve_model_field_relations(model_key, name, field)
229         # Delay rendering of relationships if it's not a relational field.
230         delay = not field.is_relation
231         self.reload_model(*model_key, delay=delay)
232 
233     def remove_field(self, app_label, model_name, name):
234         model_key = app_label, model_name
235         model_state = self.models[model_key]
236         old_field = model_state.fields.pop(name)
237         if self._relations is not None:
238             self.resolve_model_field_relations(model_key, name, old_field)
239         # Delay rendering of relationships if it's not a relational field.
240         delay = not old_field.is_relation
241         self.reload_model(*model_key, delay=delay)
242 
243     def alter_field(self, app_label, model_name, name, field, preserve_default):
244         if not preserve_default:
245             field = field.clone()
246             field.default = NOT_PROVIDED
247         else:
248             field = field
249         model_key = app_label, model_name
250         fields = self.models[model_key].fields
251         if self._relations is not None:
252             old_field = fields.pop(name)
253             if old_field.is_relation:
254                 self.resolve_model_field_relations(model_key, name, old_field)
255             fields[name] = field
256             if field.is_relation:
257                 self.resolve_model_field_relations(model_key, name, field)
258         else:
259             fields[name] = field
260         # TODO: investigate if old relational fields must be reloaded or if
261         # it's sufficient if the new field is (#27737).
262         # Delay rendering of relationships if it's not a relational field and
263         # not referenced by a foreign key.
264         delay = not field.is_relation and not field_is_referenced(
265             self, model_key, (name, field)
266         )
267         self.reload_model(*model_key, delay=delay)
268 
269     def rename_field(self, app_label, model_name, old_name, new_name):
270         model_key = app_label, model_name
271         model_state = self.models[model_key]
272         # Rename the field.
273         fields = model_state.fields
274         try:
275             found = fields.pop(old_name)
276         except KeyError:
277             raise FieldDoesNotExist(
278                 f"{app_label}.{model_name} has no field named '{old_name}'"
279             )
280         fields[new_name] = found
281         for field in fields.values():
282             # Fix from_fields to refer to the new field.
283             from_fields = getattr(field, "from_fields", None)
284             if from_fields:
285                 field.from_fields = tuple(
286                     [
287                         new_name if from_field_name == old_name else from_field_name
288                         for from_field_name in from_fields
289                     ]
290                 )
291         # Fix index/unique_together to refer to the new field.
292         options = model_state.options
293         for option in ("index_together", "unique_together"):
294             if option in options:
295                 options[option] = [
296                     [new_name if n == old_name else n for n in together]
297                     for together in options[option]
298                 ]
299         # Fix to_fields to refer to the new field.
300         delay = True
301         references = get_references(self, model_key, (old_name, found))
302         for *_, field, reference in references:
303             delay = False
304             if reference.to:
305                 remote_field, to_fields = reference.to
306                 if getattr(remote_field, "field_name", None) == old_name:
307                     remote_field.field_name = new_name
308                 if to_fields:
309                     field.to_fields = tuple(
310                         [
311                             new_name if to_field_name == old_name else to_field_name
312                             for to_field_name in to_fields
313                         ]
314                     )
315         if self._relations is not None:
316             old_name_lower = old_name.lower()
317             new_name_lower = new_name.lower()
318             for to_model in self._relations.values():
319                 if old_name_lower in to_model[model_key]:
320                     field = to_model[model_key].pop(old_name_lower)
321                     field.name = new_name_lower
322                     to_model[model_key][new_name_lower] = field
323         self.reload_model(*model_key, delay=delay)
324 
325     def _find_reload_model(self, app_label, model_name, delay=False):
326         if delay:
327             self.is_delayed = True
328 
329         related_models = set()
330 
331         try:
332             old_model = self.apps.get_model(app_label, model_name)
333         except LookupError:
334             pass
335         else:
336             # Get all relations to and from the old model before reloading,
337             # as _meta.apps may change
338             if delay:
339                 related_models = get_related_models_tuples(old_model)
340             else:
341                 related_models = get_related_models_recursive(old_model)
342 
343         # Get all outgoing references from the model to be rendered
344         model_state = self.models[(app_label, model_name)]
345         # Directly related models are the models pointed to by ForeignKeys,
346         # OneToOneFields, and ManyToManyFields.
347         direct_related_models = set()
348         for field in model_state.fields.values():
349             if field.is_relation:
350                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:
351                     continue
352                 rel_app_label, rel_model_name = _get_app_label_and_model_name(
353                     field.related_model, app_label
354                 )
355                 direct_related_models.add((rel_app_label, rel_model_name.lower()))
356 
357         # For all direct related models recursively get all related models.
358         related_models.update(direct_related_models)
359         for rel_app_label, rel_model_name in direct_related_models:
360             try:
361                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)
362             except LookupError:
363                 pass
364             else:
365                 if delay:
366                     related_models.update(get_related_models_tuples(rel_model))
367                 else:
368                     related_models.update(get_related_models_recursive(rel_model))
369 
370         # Include the model itself
371         related_models.add((app_label, model_name))
372 
373         return related_models
374 
375     def reload_model(self, app_label, model_name, delay=False):
376         if "apps" in self.__dict__:  # hasattr would cache the property
377             related_models = self._find_reload_model(app_label, model_name, delay)
378             self._reload(related_models)
379 
380     def reload_models(self, models, delay=True):
381         if "apps" in self.__dict__:  # hasattr would cache the property
382             related_models = set()
383             for app_label, model_name in models:
384                 related_models.update(
385                     self._find_reload_model(app_label, model_name, delay)
386                 )
387             self._reload(related_models)
388 
389     def _reload(self, related_models):
390         # Unregister all related models
391         with self.apps.bulk_update():
392             for rel_app_label, rel_model_name in related_models:
393                 self.apps.unregister_model(rel_app_label, rel_model_name)
394 
395         states_to_be_rendered = []
396         # Gather all models states of those models that will be rerendered.
397         # This includes:
398         # 1. All related models of unmigrated apps
399         for model_state in self.apps.real_models:
400             if (model_state.app_label, model_state.name_lower) in related_models:
401                 states_to_be_rendered.append(model_state)
402 
403         # 2. All related models of migrated apps
404         for rel_app_label, rel_model_name in related_models:
405             try:
406                 model_state = self.models[rel_app_label, rel_model_name]
407             except KeyError:
408                 pass
409             else:
410                 states_to_be_rendered.append(model_state)
411 
412         # Render all models
413         self.apps.render_multiple(states_to_be_rendered)
414 
415     def update_model_field_relation(
416         self,
417         model,
418         model_key,
419         field_name,
420         field,
421         concretes,
422     ):
423         remote_model_key = resolve_relation(model, *model_key)
424         if remote_model_key[0] not in self.real_apps and remote_model_key in concretes:
425             remote_model_key = concretes[remote_model_key]
426         relations_to_remote_model = self._relations[remote_model_key]
427         if field_name in self.models[model_key].fields:
428             # The assert holds because it's a new relation, or an altered
429             # relation, in which case references have been removed by
430             # alter_field().
431             assert field_name not in relations_to_remote_model[model_key]
432             relations_to_remote_model[model_key][field_name] = field
433         else:
434             del relations_to_remote_model[model_key][field_name]
435             if not relations_to_remote_model[model_key]:
436                 del relations_to_remote_model[model_key]
437 
438     def resolve_model_field_relations(
439         self,
440         model_key,
441         field_name,
442         field,
443         concretes=None,
444     ):
445         remote_field = field.remote_field
446         if not remote_field:
447             return
448         if concretes is None:
449             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()
450 
451         self.update_model_field_relation(
452             remote_field.model,
453             model_key,
454             field_name,
455             field,
456             concretes,
457         )
458 
459         through = getattr(remote_field, "through", None)
460         if not through:
461             return
462         self.update_model_field_relation(
463             through, model_key, field_name, field, concretes
464         )
465 
466     def resolve_model_relations(self, model_key, concretes=None):
467         if concretes is None:
468             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()
469 
470         model_state = self.models[model_key]
471         for field_name, field in model_state.fields.items():
472             self.resolve_model_field_relations(model_key, field_name, field, concretes)
473 
474     def resolve_fields_and_relations(self):
475         # Resolve fields.
476         for model_state in self.models.values():
477             for field_name, field in model_state.fields.items():
478                 field.name = field_name
479         # Resolve relations.
480         # {remote_model_key: {model_key: {field_name: field}}}
481         self._relations = defaultdict(partial(defaultdict, dict))
482         concretes, proxies = self._get_concrete_models_mapping_and_proxy_models()
483 
484         for model_key in concretes:
485             self.resolve_model_relations(model_key, concretes)
486 
487         for model_key in proxies:
488             self._relations[model_key] = self._relations[concretes[model_key]]
489 
490     def get_concrete_model_key(self, model):
491         (
492             concrete_models_mapping,
493             _,
494         ) = self._get_concrete_models_mapping_and_proxy_models()
495         model_key = make_model_tuple(model)
496         return concrete_models_mapping[model_key]
497 
498     def _get_concrete_models_mapping_and_proxy_models(self):
499         concrete_models_mapping = {}
500         proxy_models = {}
501         # Split models to proxy and concrete models.
502         for model_key, model_state in self.models.items():
503             if model_state.options.get("proxy"):
504                 proxy_models[model_key] = model_state
505                 # Find a concrete model for the proxy.
506                 concrete_models_mapping[
507                     model_key
508                 ] = self._find_concrete_model_from_proxy(
509                     proxy_models,
510                     model_state,
511                 )
512             else:
513                 concrete_models_mapping[model_key] = model_key
514         return concrete_models_mapping, proxy_models
515 
516     def _find_concrete_model_from_proxy(self, proxy_models, model_state):
517         for base in model_state.bases:
518             if not (isinstance(base, str) or issubclass(base, models.Model)):
519                 continue
520             base_key = make_model_tuple(base)
521             base_state = proxy_models.get(base_key)
522             if not base_state:
523                 # Concrete model found, stop looking at bases.
524                 return base_key
525             return self._find_concrete_model_from_proxy(proxy_models, base_state)
526 
527     def clone(self):
528         """Return an exact copy of this ProjectState."""
529         new_state = ProjectState(
530             models={k: v.clone() for k, v in self.models.items()},
531             real_apps=self.real_apps,
532         )
533         if "apps" in self.__dict__:
534             new_state.apps = self.apps.clone()
535         new_state.is_delayed = self.is_delayed
536         return new_state
537 
538     def clear_delayed_apps_cache(self):
539         if self.is_delayed and "apps" in self.__dict__:
540             del self.__dict__["apps"]
541 
542     @cached_property
543     def apps(self):
544         return StateApps(self.real_apps, self.models)
545 
546     @classmethod
547     def from_apps(cls, apps):
548         """Take an Apps and return a ProjectState matching it."""
549         app_models = {}
550         for model in apps.get_models(include_swapped=True):
551             model_state = ModelState.from_model(model)
552             app_models[(model_state.app_label, model_state.name_lower)] = model_state
553         return cls(app_models)
554 
555     def __eq__(self, other):
556         return self.models == other.models and self.real_apps == other.real_apps
557 
558 
559 class AppConfigStub(AppConfig):
560     """Stub of an AppConfig. Only provides a label and a dict of models."""
561 
562     def __init__(self, label):
563         self.apps = None
564         self.models = {}
565         # App-label and app-name are not the same thing, so technically passing
566         # in the label here is wrong. In practice, migrations don't care about
567         # the app name, but we need something unique, and the label works fine.
568         self.label = label
569         self.name = label
570 
571     def import_models(self):
572         self.models = self.apps.all_models[self.label]
573 
574 
575 class StateApps(Apps):
576     """
577     Subclass of the global Apps registry class to better handle dynamic model
578     additions and removals.
579     """
580 
581     def __init__(self, real_apps, models, ignore_swappable=False):
582         # Any apps in self.real_apps should have all their models included
583         # in the render. We don't use the original model instances as there
584         # are some variables that refer to the Apps object.
585         # FKs/M2Ms from real apps are also not included as they just
586         # mess things up with partial states (due to lack of dependencies)
587         self.real_models = []
588         for app_label in real_apps:
589             app = global_apps.get_app_config(app_label)
590             for model in app.get_models():
591                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))
592         # Populate the app registry with a stub for each application.
593         app_labels = {model_state.app_label for model_state in models.values()}
594         app_configs = [
595             AppConfigStub(label) for label in sorted([*real_apps, *app_labels])
596         ]
597         super().__init__(app_configs)
598 
599         # These locks get in the way of copying as implemented in clone(),
600         # which is called whenever Django duplicates a StateApps before
601         # updating it.
602         self._lock = None
603         self.ready_event = None
604 
605         self.render_multiple([*models.values(), *self.real_models])
606 
607         # There shouldn't be any operations pending at this point.
608         from django.core.checks.model_checks import _check_lazy_references
609 
610         ignore = (
611             {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()
612         )
613         errors = _check_lazy_references(self, ignore=ignore)
614         if errors:
615             raise ValueError("\n".join(error.msg for error in errors))
616 
617     @contextmanager
618     def bulk_update(self):
619         # Avoid clearing each model's cache for each change. Instead, clear
620         # all caches when we're finished updating the model instances.
621         ready = self.ready
622         self.ready = False
623         try:
624             yield
625         finally:
626             self.ready = ready
627             self.clear_cache()
628 
629     def render_multiple(self, model_states):
630         # We keep trying to render the models in a loop, ignoring invalid
631         # base errors, until the size of the unrendered models doesn't
632         # decrease by at least one, meaning there's a base dependency loop/
633         # missing base.
634         if not model_states:
635             return
636         # Prevent that all model caches are expired for each render.
637         with self.bulk_update():
638             unrendered_models = model_states
639             while unrendered_models:
640                 new_unrendered_models = []
641                 for model in unrendered_models:
642                     try:
643                         model.render(self)
644                     except InvalidBasesError:
645                         new_unrendered_models.append(model)
646                 if len(new_unrendered_models) == len(unrendered_models):
647                     raise InvalidBasesError(
648                         "Cannot resolve bases for %r\nThis can happen if you are "
649                         "inheriting models from an app with migrations (e.g. "
650                         "contrib.auth)\n in an app with no migrations; see "
651                         "https://docs.djangoproject.com/en/%s/topics/migrations/"
652                         "#dependencies for more"
653                         % (new_unrendered_models, get_docs_version())
654                     )
655                 unrendered_models = new_unrendered_models
656 
657     def clone(self):
658         """Return a clone of this registry."""
659         clone = StateApps([], {})
660         clone.all_models = copy.deepcopy(self.all_models)
661         clone.app_configs = copy.deepcopy(self.app_configs)
662         # Set the pointer to the correct app registry.
663         for app_config in clone.app_configs.values():
664             app_config.apps = clone
665         # No need to actually clone them, they'll never change
666         clone.real_models = self.real_models
667         return clone
668 
669     def register_model(self, app_label, model):
670         self.all_models[app_label][model._meta.model_name] = model
671         if app_label not in self.app_configs:
672             self.app_configs[app_label] = AppConfigStub(app_label)
673             self.app_configs[app_label].apps = self
674         self.app_configs[app_label].models[model._meta.model_name] = model
675         self.do_pending_operations(model)
676         self.clear_cache()
677 
678     def unregister_model(self, app_label, model_name):
679         try:
680             del self.all_models[app_label][model_name]
681             del self.app_configs[app_label].models[model_name]
682         except KeyError:
683             pass
684 
685 
686 class ModelState:
687     """
688     Represent a Django Model. Don't use the actual Model class as it's not
689     designed to have its options changed - instead, mutate this one and then
690     render it into a Model as required.
691 
692     Note that while you are allowed to mutate .fields, you are not allowed
693     to mutate the Field instances inside there themselves - you must instead
694     assign new ones, as these are not detached during a clone.
695     """
696 
697     def __init__(
698         self, app_label, name, fields, options=None, bases=None, managers=None
699     ):
700         self.app_label = app_label
701         self.name = name
702         self.fields = dict(fields)
703         self.options = options or {}
704         self.options.setdefault("indexes", [])
705         self.options.setdefault("constraints", [])
706         self.bases = bases or (models.Model,)
707         self.managers = managers or []
708         for name, field in self.fields.items():
709             # Sanity-check that fields are NOT already bound to a model.
710             if hasattr(field, "model"):
711                 raise ValueError(
712                     'ModelState.fields cannot be bound to a model - "%s" is.' % name
713                 )
714             # Sanity-check that relation fields are NOT referring to a model class.
715             if field.is_relation and hasattr(field.related_model, "_meta"):
716                 raise ValueError(
717                     'ModelState.fields cannot refer to a model class - "%s.to" does. '
718                     "Use a string reference instead." % name
719                 )
720             if field.many_to_many and hasattr(field.remote_field.through, "_meta"):
721                 raise ValueError(
722                     'ModelState.fields cannot refer to a model class - "%s.through" '
723                     "does. Use a string reference instead." % name
724                 )
725         # Sanity-check that indexes have their name set.
726         for index in self.options["indexes"]:
727             if not index.name:
728                 raise ValueError(
729                     "Indexes passed to ModelState require a name attribute. "
730                     "%r doesn't have one." % index
731                 )
732 
733     @cached_property
734     def name_lower(self):
735         return self.name.lower()
736 
737     def get_field(self, field_name):
738         if field_name == "_order":
739             field_name = self.options.get("order_with_respect_to", field_name)
740         return self.fields[field_name]
741 
742     @classmethod
743     def from_model(cls, model, exclude_rels=False):
744         """Given a model, return a ModelState representing it."""
745         # Deconstruct the fields
746         fields = []
747         for field in model._meta.local_fields:
748             if getattr(field, "remote_field", None) and exclude_rels:
749                 continue
750             if isinstance(field, models.OrderWrt):
751                 continue
752             name = field.name
753             try:
754                 fields.append((name, field.clone()))
755             except TypeError as e:
756                 raise TypeError(
757                     "Couldn't reconstruct field %s on %s: %s"
758                     % (
759                         name,
760                         model._meta.label,
761                         e,
762                     )
763                 )
764         if not exclude_rels:
765             for field in model._meta.local_many_to_many:
766                 name = field.name
767                 try:
768                     fields.append((name, field.clone()))
769                 except TypeError as e:
770                     raise TypeError(
771                         "Couldn't reconstruct m2m field %s on %s: %s"
772                         % (
773                             name,
774                             model._meta.object_name,
775                             e,
776                         )
777                     )
778         # Extract the options
779         options = {}
780         for name in DEFAULT_NAMES:
781             # Ignore some special options
782             if name in ["apps", "app_label"]:
783                 continue
784             elif name in model._meta.original_attrs:
785                 if name == "unique_together":
786                     ut = model._meta.original_attrs["unique_together"]
787                     options[name] = set(normalize_together(ut))
788                 elif name == "index_together":
789                     it = model._meta.original_attrs["index_together"]
790                     options[name] = set(normalize_together(it))
791                 elif name == "indexes":
792                     indexes = [idx.clone() for idx in model._meta.indexes]
793                     for index in indexes:
794                         if not index.name:
795                             index.set_name_with_model(model)
796                     options["indexes"] = indexes
797                 elif name == "constraints":
798                     options["constraints"] = [
799                         con.clone() for con in model._meta.constraints
800                     ]
801                 else:
802                     options[name] = model._meta.original_attrs[name]
803         # If we're ignoring relationships, remove all field-listing model
804         # options (that option basically just means "make a stub model")
805         if exclude_rels:
806             for key in ["unique_together", "index_together", "order_with_respect_to"]:
807                 if key in options:
808                     del options[key]
809         # Private fields are ignored, so remove options that refer to them.
810         elif options.get("order_with_respect_to") in {
811             field.name for field in model._meta.private_fields
812         }:
813             del options["order_with_respect_to"]
814 
815         def flatten_bases(model):
816             bases = []
817             for base in model.__bases__:
818                 if hasattr(base, "_meta") and base._meta.abstract:
819                     bases.extend(flatten_bases(base))
820                 else:
821                     bases.append(base)
822             return bases
823 
824         # We can't rely on __mro__ directly because we only want to flatten
825         # abstract models and not the whole tree. However by recursing on
826         # __bases__ we may end up with duplicates and ordering issues, we
827         # therefore discard any duplicates and reorder the bases according
828         # to their index in the MRO.
829         flattened_bases = sorted(
830             set(flatten_bases(model)), key=lambda x: model.__mro__.index(x)
831         )
832 
833         # Make our record
834         bases = tuple(
835             (base._meta.label_lower if hasattr(base, "_meta") else base)
836             for base in flattened_bases
837         )
838         # Ensure at least one base inherits from models.Model
839         if not any(
840             (isinstance(base, str) or issubclass(base, models.Model)) for base in bases
841         ):
842             bases = (models.Model,)
843 
844         managers = []
845         manager_names = set()
846         default_manager_shim = None
847         for manager in model._meta.managers:
848             if manager.name in manager_names:
849                 # Skip overridden managers.
850                 continue
851             elif manager.use_in_migrations:
852                 # Copy managers usable in migrations.
853                 new_manager = copy.copy(manager)
854                 new_manager._set_creation_counter()
855             elif manager is model._base_manager or manager is model._default_manager:
856                 # Shim custom managers used as default and base managers.
857                 new_manager = models.Manager()
858                 new_manager.model = manager.model
859                 new_manager.name = manager.name
860                 if manager is model._default_manager:
861                     default_manager_shim = new_manager
862             else:
863                 continue
864             manager_names.add(manager.name)
865             managers.append((manager.name, new_manager))
866 
867         # Ignore a shimmed default manager called objects if it's the only one.
868         if managers == [("objects", default_manager_shim)]:
869             managers = []
870 
871         # Construct the new ModelState
872         return cls(
873             model._meta.app_label,
874             model._meta.object_name,
875             fields,
876             options,
877             bases,
878             managers,
879         )
880 
881     def construct_managers(self):
882         """Deep-clone the managers using deconstruction."""
883         # Sort all managers by their creation counter
884         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)
885         for mgr_name, manager in sorted_managers:
886             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()
887             if as_manager:
888                 qs_class = import_string(qs_path)
889                 yield mgr_name, qs_class.as_manager()
890             else:
891                 manager_class = import_string(manager_path)
892                 yield mgr_name, manager_class(*args, **kwargs)
893 
894     def clone(self):
895         """Return an exact copy of this ModelState."""
896         return self.__class__(
897             app_label=self.app_label,
898             name=self.name,
899             fields=dict(self.fields),
900             # Since options are shallow-copied here, operations such as
901             # AddIndex must replace their option (e.g 'indexes') rather
902             # than mutating it.
903             options=dict(self.options),
904             bases=self.bases,
905             managers=list(self.managers),
906         )
907 
908     def render(self, apps):
909         """Create a Model object from our current state into the given apps."""
910         # First, make a Meta object
911         meta_contents = {"app_label": self.app_label, "apps": apps, **self.options}
912         meta = type("Meta", (), meta_contents)
913         # Then, work out our bases
914         try:
915             bases = tuple(
916                 (apps.get_model(base) if isinstance(base, str) else base)
917                 for base in self.bases
918             )
919         except LookupError:
920             raise InvalidBasesError(
921                 "Cannot resolve one or more bases from %r" % (self.bases,)
922             )
923         # Clone fields for the body, add other bits.
924         body = {name: field.clone() for name, field in self.fields.items()}
925         body["Meta"] = meta
926         body["__module__"] = "__fake__"
927 
928         # Restore managers
929         body.update(self.construct_managers())
930         # Then, make a Model object (apps.register_model is called in __new__)
931         return type(self.name, bases, body)
932 
933     def get_index_by_name(self, name):
934         for index in self.options["indexes"]:
935             if index.name == name:
936                 return index
937         raise ValueError("No index named %s on model %s" % (name, self.name))
938 
939     def get_constraint_by_name(self, name):
940         for constraint in self.options["constraints"]:
941             if constraint.name == name:
942                 return constraint
943         raise ValueError("No constraint named %s on model %s" % (name, self.name))
944 
945     def __repr__(self):
946         return "<%s: '%s.%s'>" % (self.__class__.__name__, self.app_label, self.name)
947 
948     def __eq__(self, other):
949         return (
950             (self.app_label == other.app_label)
951             and (self.name == other.name)
952             and (len(self.fields) == len(other.fields))
953             and all(
954                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]
955                 for (k1, f1), (k2, f2) in zip(
956                     sorted(self.fields.items()),
957                     sorted(other.fields.items()),
958                 )
959             )
960             and (self.options == other.options)
961             and (self.bases == other.bases)
962             and (self.managers == other.managers)
963         )

</code><intended_behavior>Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key.</intended_behavior>]
2025-10-17 11:14:38.326 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 11:14:38.326 | INFO     | Search-only: skipping patch selection
2025-10-17 11:14:38.487 | INFO     | Task django__django-15629 completed successfully.
2025-10-17 11:14:38.488 | INFO     | No patch generated. You can try running ACR again.
