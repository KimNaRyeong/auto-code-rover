[
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/models/fields/related.py",
        "start": 1,
        "end": 1987,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 from functools import partial\n4 \n5 from django import forms\n6 from django.apps import apps\n7 from django.conf import SettingsReference, settings\n8 from django.core import checks, exceptions\n9 from django.db import connection, router\n10 from django.db.backends import utils\n11 from django.db.models import Q\n12 from django.db.models.constants import LOOKUP_SEP\n13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14 from django.db.models.query_utils import PathInfo\n15 from django.db.models.utils import make_model_tuple\n16 from django.utils.functional import cached_property\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 from . import Field\n20 from .mixins import FieldCacheMixin\n21 from .related_descriptors import (\n22     ForeignKeyDeferredAttribute,\n23     ForwardManyToOneDescriptor,\n24     ForwardOneToOneDescriptor,\n25     ManyToManyDescriptor,\n26     ReverseManyToOneDescriptor,\n27     ReverseOneToOneDescriptor,\n28 )\n29 from .related_lookups import (\n30     RelatedExact,\n31     RelatedGreaterThan,\n32     RelatedGreaterThanOrEqual,\n33     RelatedIn,\n34     RelatedIsNull,\n35     RelatedLessThan,\n36     RelatedLessThanOrEqual,\n37 )\n38 from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel\n39 \n40 RECURSIVE_RELATIONSHIP_CONSTANT = \"self\"\n41 \n42 \n43 def resolve_relation(scope_model, relation):\n44     \"\"\"\n45     Transform relation into a model or fully-qualified model string of the form\n46     \"app_label.ModelName\", relative to scope_model.\n47 \n48     The relation argument can be:\n49       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n50         the model argument will be returned.\n51       * A bare model name without an app_label, in which case scope_model's\n52         app_label will be prepended.\n53       * An \"app_label.ModelName\" string.\n54       * A model class, which will be returned unchanged.\n55     \"\"\"\n56     # Check for recursive relations\n57     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n58         relation = scope_model\n59 \n60     # Look for an \"app.Model\" relation\n61     if isinstance(relation, str):\n62         if \".\" not in relation:\n63             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n64 \n65     return relation\n66 \n67 \n68 def lazy_related_operation(function, model, *related_models, **kwargs):\n69     \"\"\"\n70     Schedule `function` to be called once `model` and all `related_models`\n71     have been imported and registered with the app registry. `function` will\n72     be called with the newly-loaded model classes as its positional arguments,\n73     plus any optional keyword arguments.\n74 \n75     The `model` argument must be a model class. Each subsequent positional\n76     argument is another model, or a reference to another model - see\n77     `resolve_relation()` for the various forms these may take. Any relative\n78     references will be resolved relative to `model`.\n79 \n80     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n81     registry model used is the one found in `model._meta.apps`.\n82     \"\"\"\n83     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n84     model_keys = (make_model_tuple(m) for m in models)\n85     apps = model._meta.apps\n86     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n87 \n88 \n89 class RelatedField(FieldCacheMixin, Field):\n90     \"\"\"Base class that all relational fields inherit from.\"\"\"\n91 \n92     # Field flags\n93     one_to_many = False\n94     one_to_one = False\n95     many_to_many = False\n96     many_to_one = False\n97 \n98     def __init__(\n99         self,\n100         related_name=None,\n101         related_query_name=None,\n102         limit_choices_to=None,\n103         **kwargs,\n104     ):\n105         self._related_name = related_name\n106         self._related_query_name = related_query_name\n107         self._limit_choices_to = limit_choices_to\n108         super().__init__(**kwargs)\n109 \n110     @cached_property\n111     def related_model(self):\n112         # Can't cache this property until all the models are loaded.\n113         apps.check_models_ready()\n114         return self.remote_field.model\n115 \n116     def check(self, **kwargs):\n117         return [\n118             *super().check(**kwargs),\n119             *self._check_related_name_is_valid(),\n120             *self._check_related_query_name_is_valid(),\n121             *self._check_relation_model_exists(),\n122             *self._check_referencing_to_swapped_model(),\n123             *self._check_clashes(),\n124         ]\n125 \n126     def _check_related_name_is_valid(self):\n127         import keyword\n128 \n129         related_name = self.remote_field.related_name\n130         if related_name is None:\n131             return []\n132         is_valid_id = (\n133             not keyword.iskeyword(related_name) and related_name.isidentifier()\n134         )\n135         if not (is_valid_id or related_name.endswith(\"+\")):\n136             return [\n137                 checks.Error(\n138                     \"The name '%s' is invalid related_name for field %s.%s\"\n139                     % (\n140                         self.remote_field.related_name,\n141                         self.model._meta.object_name,\n142                         self.name,\n143                     ),\n144                     hint=(\n145                         \"Related name must be a valid Python identifier or end with a \"\n146                         \"'+'\"\n147                     ),\n148                     obj=self,\n149                     id=\"fields.E306\",\n150                 )\n151             ]\n152         return []\n153 \n154     def _check_related_query_name_is_valid(self):\n155         if self.remote_field.is_hidden():\n156             return []\n157         rel_query_name = self.related_query_name()\n158         errors = []\n159         if rel_query_name.endswith(\"_\"):\n160             errors.append(\n161                 checks.Error(\n162                     \"Reverse query name '%s' must not end with an underscore.\"\n163                     % rel_query_name,\n164                     hint=(\n165                         \"Add or change a related_name or related_query_name \"\n166                         \"argument for this field.\"\n167                     ),\n168                     obj=self,\n169                     id=\"fields.E308\",\n170                 )\n171             )\n172         if LOOKUP_SEP in rel_query_name:\n173             errors.append(\n174                 checks.Error(\n175                     \"Reverse query name '%s' must not contain '%s'.\"\n176                     % (rel_query_name, LOOKUP_SEP),\n177                     hint=(\n178                         \"Add or change a related_name or related_query_name \"\n179                         \"argument for this field.\"\n180                     ),\n181                     obj=self,\n182                     id=\"fields.E309\",\n183                 )\n184             )\n185         return errors\n186 \n187     def _check_relation_model_exists(self):\n188         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n189         rel_is_string = isinstance(self.remote_field.model, str)\n190         model_name = (\n191             self.remote_field.model\n192             if rel_is_string\n193             else self.remote_field.model._meta.object_name\n194         )\n195         if rel_is_missing and (\n196             rel_is_string or not self.remote_field.model._meta.swapped\n197         ):\n198             return [\n199                 checks.Error(\n200                     \"Field defines a relation with model '%s', which is either \"\n201                     \"not installed, or is abstract.\" % model_name,\n202                     obj=self,\n203                     id=\"fields.E300\",\n204                 )\n205             ]\n206         return []\n207 \n208     def _check_referencing_to_swapped_model(self):\n209         if (\n210             self.remote_field.model not in self.opts.apps.get_models()\n211             and not isinstance(self.remote_field.model, str)\n212             and self.remote_field.model._meta.swapped\n213         ):\n214             return [\n215                 checks.Error(\n216                     \"Field defines a relation with the model '%s', which has \"\n217                     \"been swapped out.\" % self.remote_field.model._meta.label,\n218                     hint=\"Update the relation to point at 'settings.%s'.\"\n219                     % self.remote_field.model._meta.swappable,\n220                     obj=self,\n221                     id=\"fields.E301\",\n222                 )\n223             ]\n224         return []\n225 \n226     def _check_clashes(self):\n227         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n228         from django.db.models.base import ModelBase\n229 \n230         errors = []\n231         opts = self.model._meta\n232 \n233         # f.remote_field.model may be a string instead of a model. Skip if\n234         # model name is not resolved.\n235         if not isinstance(self.remote_field.model, ModelBase):\n236             return []\n237 \n238         # Consider that we are checking field `Model.foreign` and the models\n239         # are:\n240         #\n241         #     class Target(models.Model):\n242         #         model = models.IntegerField()\n243         #         model_set = models.IntegerField()\n244         #\n245         #     class Model(models.Model):\n246         #         foreign = models.ForeignKey(Target)\n247         #         m2m = models.ManyToManyField(Target)\n248 \n249         # rel_opts.object_name == \"Target\"\n250         rel_opts = self.remote_field.model._meta\n251         # If the field doesn't install a backward relation on the target model\n252         # (so `is_hidden` returns True), then there are no clashes to check\n253         # and we can skip these fields.\n254         rel_is_hidden = self.remote_field.is_hidden()\n255         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n256         rel_query_name = self.related_query_name()  # i. e. \"model\"\n257         # i.e. \"app_label.Model.field\".\n258         field_name = \"%s.%s\" % (opts.label, self.name)\n259 \n260         # Check clashes between accessor or reverse query name of `field`\n261         # and any other field name -- i.e. accessor for Model.foreign is\n262         # model_set and it clashes with Target.model_set.\n263         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n264         for clash_field in potential_clashes:\n265             # i.e. \"app_label.Target.model_set\".\n266             clash_name = \"%s.%s\" % (rel_opts.label, clash_field.name)\n267             if not rel_is_hidden and clash_field.name == rel_name:\n268                 errors.append(\n269                     checks.Error(\n270                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n271                         f\"for '{field_name}' clashes with field name \"\n272                         f\"'{clash_name}'.\",\n273                         hint=(\n274                             \"Rename field '%s', or add/change a related_name \"\n275                             \"argument to the definition for field '%s'.\"\n276                         )\n277                         % (clash_name, field_name),\n278                         obj=self,\n279                         id=\"fields.E302\",\n280                     )\n281                 )\n282 \n283             if clash_field.name == rel_query_name:\n284                 errors.append(\n285                     checks.Error(\n286                         \"Reverse query name for '%s' clashes with field name '%s'.\"\n287                         % (field_name, clash_name),\n288                         hint=(\n289                             \"Rename field '%s', or add/change a related_name \"\n290                             \"argument to the definition for field '%s'.\"\n291                         )\n292                         % (clash_name, field_name),\n293                         obj=self,\n294                         id=\"fields.E303\",\n295                     )\n296                 )\n297 \n298         # Check clashes between accessors/reverse query names of `field` and\n299         # any other field accessor -- i. e. Model.foreign accessor clashes with\n300         # Model.m2m accessor.\n301         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n302         for clash_field in potential_clashes:\n303             # i.e. \"app_label.Model.m2m\".\n304             clash_name = \"%s.%s\" % (\n305                 clash_field.related_model._meta.label,\n306                 clash_field.field.name,\n307             )\n308             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n309                 errors.append(\n310                     checks.Error(\n311                         f\"Reverse accessor '{rel_opts.object_name}.{rel_name}' \"\n312                         f\"for '{field_name}' clashes with reverse accessor for \"\n313                         f\"'{clash_name}'.\",\n314                         hint=(\n315                             \"Add or change a related_name argument \"\n316                             \"to the definition for '%s' or '%s'.\"\n317                         )\n318                         % (field_name, clash_name),\n319                         obj=self,\n320                         id=\"fields.E304\",\n321                     )\n322                 )\n323 \n324             if clash_field.get_accessor_name() == rel_query_name:\n325                 errors.append(\n326                     checks.Error(\n327                         \"Reverse query name for '%s' clashes with reverse query name \"\n328                         \"for '%s'.\" % (field_name, clash_name),\n329                         hint=(\n330                             \"Add or change a related_name argument \"\n331                             \"to the definition for '%s' or '%s'.\"\n332                         )\n333                         % (field_name, clash_name),\n334                         obj=self,\n335                         id=\"fields.E305\",\n336                     )\n337                 )\n338 \n339         return errors\n340 \n341     def db_type(self, connection):\n342         # By default related field will not have a column as it relates to\n343         # columns from another table.\n344         return None\n345 \n346     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n347 \n348         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n349 \n350         self.opts = cls._meta\n351 \n352         if not cls._meta.abstract:\n353             if self.remote_field.related_name:\n354                 related_name = self.remote_field.related_name\n355             else:\n356                 related_name = self.opts.default_related_name\n357             if related_name:\n358                 related_name = related_name % {\n359                     \"class\": cls.__name__.lower(),\n360                     \"model_name\": cls._meta.model_name.lower(),\n361                     \"app_label\": cls._meta.app_label.lower(),\n362                 }\n363                 self.remote_field.related_name = related_name\n364 \n365             if self.remote_field.related_query_name:\n366                 related_query_name = self.remote_field.related_query_name % {\n367                     \"class\": cls.__name__.lower(),\n368                     \"app_label\": cls._meta.app_label.lower(),\n369                 }\n370                 self.remote_field.related_query_name = related_query_name\n371 \n372             def resolve_related_class(model, related, field):\n373                 field.remote_field.model = related\n374                 field.do_related_class(related, model)\n375 \n376             lazy_related_operation(\n377                 resolve_related_class, cls, self.remote_field.model, field=self\n378             )\n379 \n380     def deconstruct(self):\n381         name, path, args, kwargs = super().deconstruct()\n382         if self._limit_choices_to:\n383             kwargs[\"limit_choices_to\"] = self._limit_choices_to\n384         if self._related_name is not None:\n385             kwargs[\"related_name\"] = self._related_name\n386         if self._related_query_name is not None:\n387             kwargs[\"related_query_name\"] = self._related_query_name\n388         return name, path, args, kwargs\n389 \n390     def get_forward_related_filter(self, obj):\n391         \"\"\"\n392         Return the keyword arguments that when supplied to\n393         self.model.object.filter(), would select all instances related through\n394         this field to the remote obj. This is used to build the querysets\n395         returned by related descriptors. obj is an instance of\n396         self.related_field.model.\n397         \"\"\"\n398         return {\n399             \"%s__%s\" % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n400             for _, rh_field in self.related_fields\n401         }\n402 \n403     def get_reverse_related_filter(self, obj):\n404         \"\"\"\n405         Complement to get_forward_related_filter(). Return the keyword\n406         arguments that when passed to self.related_field.model.object.filter()\n407         select all instances of self.related_field.model related through\n408         this field to obj. obj is an instance of self.model.\n409         \"\"\"\n410         base_filter = (\n411             (rh_field.attname, getattr(obj, lh_field.attname))\n412             for lh_field, rh_field in self.related_fields\n413         )\n414         descriptor_filter = self.get_extra_descriptor_filter(obj)\n415         base_q = Q(*base_filter)\n416         if isinstance(descriptor_filter, dict):\n417             return base_q & Q(**descriptor_filter)\n418         elif descriptor_filter:\n419             return base_q & descriptor_filter\n420         return base_q\n421 \n422     @property\n423     def swappable_setting(self):\n424         \"\"\"\n425         Get the setting that this is powered from for swapping, or None\n426         if it's not swapped in / marked with swappable=False.\n427         \"\"\"\n428         if self.swappable:\n429             # Work out string form of \"to\"\n430             if isinstance(self.remote_field.model, str):\n431                 to_string = self.remote_field.model\n432             else:\n433                 to_string = self.remote_field.model._meta.label\n434             return apps.get_swappable_settings_name(to_string)\n435         return None\n436 \n437     def set_attributes_from_rel(self):\n438         self.name = self.name or (\n439             self.remote_field.model._meta.model_name\n440             + \"_\"\n441             + self.remote_field.model._meta.pk.name\n442         )\n443         if self.verbose_name is None:\n444             self.verbose_name = self.remote_field.model._meta.verbose_name\n445         self.remote_field.set_field_name()\n446 \n447     def do_related_class(self, other, cls):\n448         self.set_attributes_from_rel()\n449         self.contribute_to_related_class(other, self.remote_field)\n450 \n451     def get_limit_choices_to(self):\n452         \"\"\"\n453         Return ``limit_choices_to`` for this model field.\n454 \n455         If it is a callable, it will be invoked and the result will be\n456         returned.\n457         \"\"\"\n458         if callable(self.remote_field.limit_choices_to):\n459             return self.remote_field.limit_choices_to()\n460         return self.remote_field.limit_choices_to\n461 \n462     def formfield(self, **kwargs):\n463         \"\"\"\n464         Pass ``limit_choices_to`` to the field being constructed.\n465 \n466         Only passes it if there is a type that supports related fields.\n467         This is a similar strategy used to pass the ``queryset`` to the field\n468         being constructed.\n469         \"\"\"\n470         defaults = {}\n471         if hasattr(self.remote_field, \"get_related_field\"):\n472             # If this is a callable, do not invoke it here. Just pass\n473             # it in the defaults for when the form class will later be\n474             # instantiated.\n475             limit_choices_to = self.remote_field.limit_choices_to\n476             defaults.update(\n477                 {\n478                     \"limit_choices_to\": limit_choices_to,\n479                 }\n480             )\n481         defaults.update(kwargs)\n482         return super().formfield(**defaults)\n483 \n484     def related_query_name(self):\n485         \"\"\"\n486         Define the name that can be used to identify this related object in a\n487         table-spanning query.\n488         \"\"\"\n489         return (\n490             self.remote_field.related_query_name\n491             or self.remote_field.related_name\n492             or self.opts.model_name\n493         )\n494 \n495     @property\n496     def target_field(self):\n497         \"\"\"\n498         When filtering against this relation, return the field on the remote\n499         model against which the filtering should happen.\n500         \"\"\"\n501         target_fields = self.path_infos[-1].target_fields\n502         if len(target_fields) > 1:\n503             raise exceptions.FieldError(\n504                 \"The relation has multiple target fields, but only single target field \"\n505                 \"was asked for\"\n506             )\n507         return target_fields[0]\n508 \n509     def get_cache_name(self):\n510         return self.name\n511 \n512 \n513 class ForeignObject(RelatedField):\n514     \"\"\"\n515     Abstraction of the ForeignKey relation to support multi-column relations.\n516     \"\"\"\n517 \n518     # Field flags\n519     many_to_many = False\n520     many_to_one = True\n521     one_to_many = False\n522     one_to_one = False\n523 \n524     requires_unique_target = True\n525     related_accessor_class = ReverseManyToOneDescriptor\n526     forward_related_accessor_class = ForwardManyToOneDescriptor\n527     rel_class = ForeignObjectRel\n528 \n529     def __init__(\n530         self,\n531         to,\n532         on_delete,\n533         from_fields,\n534         to_fields,\n535         rel=None,\n536         related_name=None,\n537         related_query_name=None,\n538         limit_choices_to=None,\n539         parent_link=False,\n540         swappable=True,\n541         **kwargs,\n542     ):\n543 \n544         if rel is None:\n545             rel = self.rel_class(\n546                 self,\n547                 to,\n548                 related_name=related_name,\n549                 related_query_name=related_query_name,\n550                 limit_choices_to=limit_choices_to,\n551                 parent_link=parent_link,\n552                 on_delete=on_delete,\n553             )\n554 \n555         super().__init__(\n556             rel=rel,\n557             related_name=related_name,\n558             related_query_name=related_query_name,\n559             limit_choices_to=limit_choices_to,\n560             **kwargs,\n561         )\n562 \n563         self.from_fields = from_fields\n564         self.to_fields = to_fields\n565         self.swappable = swappable\n566 \n567     def __copy__(self):\n568         obj = super().__copy__()\n569         # Remove any cached PathInfo values.\n570         obj.__dict__.pop(\"path_infos\", None)\n571         obj.__dict__.pop(\"reverse_path_infos\", None)\n572         return obj\n573 \n574     def check(self, **kwargs):\n575         return [\n576             *super().check(**kwargs),\n577             *self._check_to_fields_exist(),\n578             *self._check_unique_target(),\n579         ]\n580 \n581     def _check_to_fields_exist(self):\n582         # Skip nonexistent models.\n583         if isinstance(self.remote_field.model, str):\n584             return []\n585 \n586         errors = []\n587         for to_field in self.to_fields:\n588             if to_field:\n589                 try:\n590                     self.remote_field.model._meta.get_field(to_field)\n591                 except exceptions.FieldDoesNotExist:\n592                     errors.append(\n593                         checks.Error(\n594                             \"The to_field '%s' doesn't exist on the related \"\n595                             \"model '%s'.\"\n596                             % (to_field, self.remote_field.model._meta.label),\n597                             obj=self,\n598                             id=\"fields.E312\",\n599                         )\n600                     )\n601         return errors\n602 \n603     def _check_unique_target(self):\n604         rel_is_string = isinstance(self.remote_field.model, str)\n605         if rel_is_string or not self.requires_unique_target:\n606             return []\n607 \n608         try:\n609             self.foreign_related_fields\n610         except exceptions.FieldDoesNotExist:\n611             return []\n612 \n613         if not self.foreign_related_fields:\n614             return []\n615 \n616         unique_foreign_fields = {\n617             frozenset([f.name])\n618             for f in self.remote_field.model._meta.get_fields()\n619             if getattr(f, \"unique\", False)\n620         }\n621         unique_foreign_fields.update(\n622             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}\n623         )\n624         unique_foreign_fields.update(\n625             {\n626                 frozenset(uc.fields)\n627                 for uc in self.remote_field.model._meta.total_unique_constraints\n628             }\n629         )\n630         foreign_fields = {f.name for f in self.foreign_related_fields}\n631         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n632 \n633         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n634             field_combination = \", \".join(\n635                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n636             )\n637             model_name = self.remote_field.model.__name__\n638             return [\n639                 checks.Error(\n640                     \"No subset of the fields %s on model '%s' is unique.\"\n641                     % (field_combination, model_name),\n642                     hint=(\n643                         \"Mark a single field as unique=True or add a set of \"\n644                         \"fields to a unique constraint (via unique_together \"\n645                         \"or a UniqueConstraint (without condition) in the \"\n646                         \"model Meta.constraints).\"\n647                     ),\n648                     obj=self,\n649                     id=\"fields.E310\",\n650                 )\n651             ]\n652         elif not has_unique_constraint:\n653             field_name = self.foreign_related_fields[0].name\n654             model_name = self.remote_field.model.__name__\n655             return [\n656                 checks.Error(\n657                     \"'%s.%s' must be unique because it is referenced by \"\n658                     \"a foreign key.\" % (model_name, field_name),\n659                     hint=(\n660                         \"Add unique=True to this field or add a \"\n661                         \"UniqueConstraint (without condition) in the model \"\n662                         \"Meta.constraints.\"\n663                     ),\n664                     obj=self,\n665                     id=\"fields.E311\",\n666                 )\n667             ]\n668         else:\n669             return []\n670 \n671     def deconstruct(self):\n672         name, path, args, kwargs = super().deconstruct()\n673         kwargs[\"on_delete\"] = self.remote_field.on_delete\n674         kwargs[\"from_fields\"] = self.from_fields\n675         kwargs[\"to_fields\"] = self.to_fields\n676 \n677         if self.remote_field.parent_link:\n678             kwargs[\"parent_link\"] = self.remote_field.parent_link\n679         if isinstance(self.remote_field.model, str):\n680             if \".\" in self.remote_field.model:\n681                 app_label, model_name = self.remote_field.model.split(\".\")\n682                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n683             else:\n684                 kwargs[\"to\"] = self.remote_field.model.lower()\n685         else:\n686             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n687         # If swappable is True, then see if we're actually pointing to the target\n688         # of a swap.\n689         swappable_setting = self.swappable_setting\n690         if swappable_setting is not None:\n691             # If it's already a settings reference, error\n692             if hasattr(kwargs[\"to\"], \"setting_name\"):\n693                 if kwargs[\"to\"].setting_name != swappable_setting:\n694                     raise ValueError(\n695                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n696                         \"that is swapped in place of more than one model (%s and %s)\"\n697                         % (kwargs[\"to\"].setting_name, swappable_setting)\n698                     )\n699             # Set it\n700             kwargs[\"to\"] = SettingsReference(\n701                 kwargs[\"to\"],\n702                 swappable_setting,\n703             )\n704         return name, path, args, kwargs\n705 \n706     def resolve_related_fields(self):\n707         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n708             raise ValueError(\n709                 \"Foreign Object from and to fields must be the same non-zero length\"\n710             )\n711         if isinstance(self.remote_field.model, str):\n712             raise ValueError(\n713                 \"Related model %r cannot be resolved\" % self.remote_field.model\n714             )\n715         related_fields = []\n716         for index in range(len(self.from_fields)):\n717             from_field_name = self.from_fields[index]\n718             to_field_name = self.to_fields[index]\n719             from_field = (\n720                 self\n721                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n722                 else self.opts.get_field(from_field_name)\n723             )\n724             to_field = (\n725                 self.remote_field.model._meta.pk\n726                 if to_field_name is None\n727                 else self.remote_field.model._meta.get_field(to_field_name)\n728             )\n729             related_fields.append((from_field, to_field))\n730         return related_fields\n731 \n732     @cached_property\n733     def related_fields(self):\n734         return self.resolve_related_fields()\n735 \n736     @cached_property\n737     def reverse_related_fields(self):\n738         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n739 \n740     @cached_property\n741     def local_related_fields(self):\n742         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n743 \n744     @cached_property\n745     def foreign_related_fields(self):\n746         return tuple(\n747             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field\n748         )\n749 \n750     def get_local_related_value(self, instance):\n751         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n752 \n753     def get_foreign_related_value(self, instance):\n754         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n755 \n756     @staticmethod\n757     def get_instance_value_for_fields(instance, fields):\n758         ret = []\n759         opts = instance._meta\n760         for field in fields:\n761             # Gotcha: in some cases (like fixture loading) a model can have\n762             # different values in parent_ptr_id and parent's id. So, use\n763             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n764             if field.primary_key:\n765                 possible_parent_link = opts.get_ancestor_link(field.model)\n766                 if (\n767                     not possible_parent_link\n768                     or possible_parent_link.primary_key\n769                     or possible_parent_link.model._meta.abstract\n770                 ):\n771                     ret.append(instance.pk)\n772                     continue\n773             ret.append(getattr(instance, field.attname))\n774         return tuple(ret)\n775 \n776     def get_attname_column(self):\n777         attname, column = super().get_attname_column()\n778         return attname, None\n779 \n780     def get_joining_columns(self, reverse_join=False):\n781         source = self.reverse_related_fields if reverse_join else self.related_fields\n782         return tuple(\n783             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source\n784         )\n785 \n786     def get_reverse_joining_columns(self):\n787         return self.get_joining_columns(reverse_join=True)\n788 \n789     def get_extra_descriptor_filter(self, instance):\n790         \"\"\"\n791         Return an extra filter condition for related object fetching when\n792         user does 'instance.fieldname', that is the extra filter is used in\n793         the descriptor of the field.\n794 \n795         The filter should be either a dict usable in .filter(**kwargs) call or\n796         a Q-object. The condition will be ANDed together with the relation's\n797         joining columns.\n798 \n799         A parallel method is get_extra_restriction() which is used in\n800         JOIN and subquery conditions.\n801         \"\"\"\n802         return {}\n803 \n804     def get_extra_restriction(self, alias, related_alias):\n805         \"\"\"\n806         Return a pair condition used for joining and subquery pushdown. The\n807         condition is something that responds to as_sql(compiler, connection)\n808         method.\n809 \n810         Note that currently referring both the 'alias' and 'related_alias'\n811         will not work in some conditions, like subquery pushdown.\n812 \n813         A parallel method is get_extra_descriptor_filter() which is used in\n814         instance.fieldname related object fetching.\n815         \"\"\"\n816         return None\n817 \n818     def get_path_info(self, filtered_relation=None):\n819         \"\"\"Get path from this field to the related model.\"\"\"\n820         opts = self.remote_field.model._meta\n821         from_opts = self.model._meta\n822         return [\n823             PathInfo(\n824                 from_opts=from_opts,\n825                 to_opts=opts,\n826                 target_fields=self.foreign_related_fields,\n827                 join_field=self,\n828                 m2m=False,\n829                 direct=True,\n830                 filtered_relation=filtered_relation,\n831             )\n832         ]\n833 \n834     @cached_property\n835     def path_infos(self):\n836         return self.get_path_info()\n837 \n838     def get_reverse_path_info(self, filtered_relation=None):\n839         \"\"\"Get path from the related model to this field's model.\"\"\"\n840         opts = self.model._meta\n841         from_opts = self.remote_field.model._meta\n842         return [\n843             PathInfo(\n844                 from_opts=from_opts,\n845                 to_opts=opts,\n846                 target_fields=(opts.pk,),\n847                 join_field=self.remote_field,\n848                 m2m=not self.unique,\n849                 direct=False,\n850                 filtered_relation=filtered_relation,\n851             )\n852         ]\n853 \n854     @cached_property\n855     def reverse_path_infos(self):\n856         return self.get_reverse_path_info()\n857 \n858     @classmethod\n859     @functools.lru_cache(maxsize=None)\n860     def get_lookups(cls):\n861         bases = inspect.getmro(cls)\n862         bases = bases[: bases.index(ForeignObject) + 1]\n863         class_lookups = [parent.__dict__.get(\"class_lookups\", {}) for parent in bases]\n864         return cls.merge_dicts(class_lookups)\n865 \n866     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n867         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n868         setattr(cls, self.name, self.forward_related_accessor_class(self))\n869 \n870     def contribute_to_related_class(self, cls, related):\n871         # Internal FK's - i.e., those with a related name ending with '+' -\n872         # and swapped models don't get a related descriptor.\n873         if (\n874             not self.remote_field.is_hidden()\n875             and not related.related_model._meta.swapped\n876         ):\n877             setattr(\n878                 cls._meta.concrete_model,\n879                 related.get_accessor_name(),\n880                 self.related_accessor_class(related),\n881             )\n882             # While 'limit_choices_to' might be a callable, simply pass\n883             # it along for later - this is too early because it's still\n884             # model load time.\n885             if self.remote_field.limit_choices_to:\n886                 cls._meta.related_fkey_lookups.append(\n887                     self.remote_field.limit_choices_to\n888                 )\n889 \n890 \n891 ForeignObject.register_lookup(RelatedIn)\n892 ForeignObject.register_lookup(RelatedExact)\n893 ForeignObject.register_lookup(RelatedLessThan)\n894 ForeignObject.register_lookup(RelatedGreaterThan)\n895 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n896 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n897 ForeignObject.register_lookup(RelatedIsNull)\n898 \n899 \n900 class ForeignKey(ForeignObject):\n901     \"\"\"\n902     Provide a many-to-one relation by adding a column to the local model\n903     to hold the remote value.\n904 \n905     By default ForeignKey will target the pk of the remote model but this\n906     behavior can be changed by using the ``to_field`` argument.\n907     \"\"\"\n908 \n909     descriptor_class = ForeignKeyDeferredAttribute\n910     # Field flags\n911     many_to_many = False\n912     many_to_one = True\n913     one_to_many = False\n914     one_to_one = False\n915 \n916     rel_class = ManyToOneRel\n917 \n918     empty_strings_allowed = False\n919     default_error_messages = {\n920         \"invalid\": _(\"%(model)s instance with %(field)s %(value)r does not exist.\")\n921     }\n922     description = _(\"Foreign Key (type determined by related field)\")\n923 \n924     def __init__(\n925         self,\n926         to,\n927         on_delete,\n928         related_name=None,\n929         related_query_name=None,\n930         limit_choices_to=None,\n931         parent_link=False,\n932         to_field=None,\n933         db_constraint=True,\n934         **kwargs,\n935     ):\n936         try:\n937             to._meta.model_name\n938         except AttributeError:\n939             if not isinstance(to, str):\n940                 raise TypeError(\n941                     \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n942                     \"either a model, a model name, or the string %r\"\n943                     % (\n944                         self.__class__.__name__,\n945                         to,\n946                         RECURSIVE_RELATIONSHIP_CONSTANT,\n947                     )\n948                 )\n949         else:\n950             # For backwards compatibility purposes, we need to *try* and set\n951             # the to_field during FK construction. It won't be guaranteed to\n952             # be correct until contribute_to_class is called. Refs #12190.\n953             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n954         if not callable(on_delete):\n955             raise TypeError(\"on_delete must be callable.\")\n956 \n957         kwargs[\"rel\"] = self.rel_class(\n958             self,\n959             to,\n960             to_field,\n961             related_name=related_name,\n962             related_query_name=related_query_name,\n963             limit_choices_to=limit_choices_to,\n964             parent_link=parent_link,\n965             on_delete=on_delete,\n966         )\n967         kwargs.setdefault(\"db_index\", True)\n968 \n969         super().__init__(\n970             to,\n971             on_delete,\n972             related_name=related_name,\n973             related_query_name=related_query_name,\n974             limit_choices_to=limit_choices_to,\n975             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n976             to_fields=[to_field],\n977             **kwargs,\n978         )\n979         self.db_constraint = db_constraint\n980 \n981     def __class_getitem__(cls, *args, **kwargs):\n982         return cls\n983 \n984     def check(self, **kwargs):\n985         return [\n986             *super().check(**kwargs),\n987             *self._check_on_delete(),\n988             *self._check_unique(),\n989         ]\n990 \n991     def _check_on_delete(self):\n992         on_delete = getattr(self.remote_field, \"on_delete\", None)\n993         if on_delete == SET_NULL and not self.null:\n994             return [\n995                 checks.Error(\n996                     \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n997                     hint=(\n998                         \"Set null=True argument on the field, or change the on_delete \"\n999                         \"rule.\"\n1000                     ),\n1001                     obj=self,\n1002                     id=\"fields.E320\",\n1003                 )\n1004             ]\n1005         elif on_delete == SET_DEFAULT and not self.has_default():\n1006             return [\n1007                 checks.Error(\n1008                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n1009                     hint=\"Set a default value, or change the on_delete rule.\",\n1010                     obj=self,\n1011                     id=\"fields.E321\",\n1012                 )\n1013             ]\n1014         else:\n1015             return []\n1016 \n1017     def _check_unique(self, **kwargs):\n1018         return (\n1019             [\n1020                 checks.Warning(\n1021                     \"Setting unique=True on a ForeignKey has the same effect as using \"\n1022                     \"a OneToOneField.\",\n1023                     hint=(\n1024                         \"ForeignKey(unique=True) is usually better served by a \"\n1025                         \"OneToOneField.\"\n1026                     ),\n1027                     obj=self,\n1028                     id=\"fields.W342\",\n1029                 )\n1030             ]\n1031             if self.unique\n1032             else []\n1033         )\n1034 \n1035     def deconstruct(self):\n1036         name, path, args, kwargs = super().deconstruct()\n1037         del kwargs[\"to_fields\"]\n1038         del kwargs[\"from_fields\"]\n1039         # Handle the simpler arguments\n1040         if self.db_index:\n1041             del kwargs[\"db_index\"]\n1042         else:\n1043             kwargs[\"db_index\"] = False\n1044         if self.db_constraint is not True:\n1045             kwargs[\"db_constraint\"] = self.db_constraint\n1046         # Rel needs more work.\n1047         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n1048         if self.remote_field.field_name and (\n1049             not to_meta\n1050             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)\n1051         ):\n1052             kwargs[\"to_field\"] = self.remote_field.field_name\n1053         return name, path, args, kwargs\n1054 \n1055     def to_python(self, value):\n1056         return self.target_field.to_python(value)\n1057 \n1058     @property\n1059     def target_field(self):\n1060         return self.foreign_related_fields[0]\n1061 \n1062     def get_reverse_path_info(self, filtered_relation=None):\n1063         \"\"\"Get path from the related model to this field's model.\"\"\"\n1064         opts = self.model._meta\n1065         from_opts = self.remote_field.model._meta\n1066         return [\n1067             PathInfo(\n1068                 from_opts=from_opts,\n1069                 to_opts=opts,\n1070                 target_fields=(opts.pk,),\n1071                 join_field=self.remote_field,\n1072                 m2m=not self.unique,\n1073                 direct=False,\n1074                 filtered_relation=filtered_relation,\n1075             )\n1076         ]\n1077 \n1078     def validate(self, value, model_instance):\n1079         if self.remote_field.parent_link:\n1080             return\n1081         super().validate(value, model_instance)\n1082         if value is None:\n1083             return\n1084 \n1085         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n1086         qs = self.remote_field.model._base_manager.using(using).filter(\n1087             **{self.remote_field.field_name: value}\n1088         )\n1089         qs = qs.complex_filter(self.get_limit_choices_to())\n1090         if not qs.exists():\n1091             raise exceptions.ValidationError(\n1092                 self.error_messages[\"invalid\"],\n1093                 code=\"invalid\",\n1094                 params={\n1095                     \"model\": self.remote_field.model._meta.verbose_name,\n1096                     \"pk\": value,\n1097                     \"field\": self.remote_field.field_name,\n1098                     \"value\": value,\n1099                 },  # 'pk' is included for backwards compatibility\n1100             )\n1101 \n1102     def resolve_related_fields(self):\n1103         related_fields = super().resolve_related_fields()\n1104         for from_field, to_field in related_fields:\n1105             if (\n1106                 to_field\n1107                 and to_field.model != self.remote_field.model._meta.concrete_model\n1108             ):\n1109                 raise exceptions.FieldError(\n1110                     \"'%s.%s' refers to field '%s' which is not local to model \"\n1111                     \"'%s'.\"\n1112                     % (\n1113                         self.model._meta.label,\n1114                         self.name,\n1115                         to_field.name,\n1116                         self.remote_field.model._meta.concrete_model._meta.label,\n1117                     )\n1118                 )\n1119         return related_fields\n1120 \n1121     def get_attname(self):\n1122         return \"%s_id\" % self.name\n1123 \n1124     def get_attname_column(self):\n1125         attname = self.get_attname()\n1126         column = self.db_column or attname\n1127         return attname, column\n1128 \n1129     def get_default(self):\n1130         \"\"\"Return the to_field if the default value is an object.\"\"\"\n1131         field_default = super().get_default()\n1132         if isinstance(field_default, self.remote_field.model):\n1133             return getattr(field_default, self.target_field.attname)\n1134         return field_default\n1135 \n1136     def get_db_prep_save(self, value, connection):\n1137         if value is None or (\n1138             value == \"\"\n1139             and (\n1140                 not self.target_field.empty_strings_allowed\n1141                 or connection.features.interprets_empty_strings_as_nulls\n1142             )\n1143         ):\n1144             return None\n1145         else:\n1146             return self.target_field.get_db_prep_save(value, connection=connection)\n1147 \n1148     def get_db_prep_value(self, value, connection, prepared=False):\n1149         return self.target_field.get_db_prep_value(value, connection, prepared)\n1150 \n1151     def get_prep_value(self, value):\n1152         return self.target_field.get_prep_value(value)\n1153 \n1154     def contribute_to_related_class(self, cls, related):\n1155         super().contribute_to_related_class(cls, related)\n1156         if self.remote_field.field_name is None:\n1157             self.remote_field.field_name = cls._meta.pk.name\n1158 \n1159     def formfield(self, *, using=None, **kwargs):\n1160         if isinstance(self.remote_field.model, str):\n1161             raise ValueError(\n1162                 \"Cannot create form field for %r yet, because \"\n1163                 \"its related model %r has not been loaded yet\"\n1164                 % (self.name, self.remote_field.model)\n1165             )\n1166         return super().formfield(\n1167             **{\n1168                 \"form_class\": forms.ModelChoiceField,\n1169                 \"queryset\": self.remote_field.model._default_manager.using(using),\n1170                 \"to_field_name\": self.remote_field.field_name,\n1171                 **kwargs,\n1172                 \"blank\": self.blank,\n1173             }\n1174         )\n1175 \n1176     def db_check(self, connection):\n1177         return None\n1178 \n1179     def db_type(self, connection):\n1180         return self.target_field.rel_db_type(connection=connection)\n1181 \n1182     def db_parameters(self, connection):\n1183         return {\"type\": self.db_type(connection), \"check\": self.db_check(connection)}\n1184 \n1185     def convert_empty_strings(self, value, expression, connection):\n1186         if (not value) and isinstance(value, str):\n1187             return None\n1188         return value\n1189 \n1190     def get_db_converters(self, connection):\n1191         converters = super().get_db_converters(connection)\n1192         if connection.features.interprets_empty_strings_as_nulls:\n1193             converters += [self.convert_empty_strings]\n1194         return converters\n1195 \n1196     def get_col(self, alias, output_field=None):\n1197         if output_field is None:\n1198             output_field = self.target_field\n1199             while isinstance(output_field, ForeignKey):\n1200                 output_field = output_field.target_field\n1201                 if output_field is self:\n1202                     raise ValueError(\"Cannot resolve output_field.\")\n1203         return super().get_col(alias, output_field)\n1204 \n1205 \n1206 class OneToOneField(ForeignKey):\n1207     \"\"\"\n1208     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1209     that it always carries a \"unique\" constraint with it and the reverse\n1210     relation always returns the object pointed to (since there will only ever\n1211     be one), rather than returning a list.\n1212     \"\"\"\n1213 \n1214     # Field flags\n1215     many_to_many = False\n1216     many_to_one = False\n1217     one_to_many = False\n1218     one_to_one = True\n1219 \n1220     related_accessor_class = ReverseOneToOneDescriptor\n1221     forward_related_accessor_class = ForwardOneToOneDescriptor\n1222     rel_class = OneToOneRel\n1223 \n1224     description = _(\"One-to-one relationship\")\n1225 \n1226     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1227         kwargs[\"unique\"] = True\n1228         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1229 \n1230     def deconstruct(self):\n1231         name, path, args, kwargs = super().deconstruct()\n1232         if \"unique\" in kwargs:\n1233             del kwargs[\"unique\"]\n1234         return name, path, args, kwargs\n1235 \n1236     def formfield(self, **kwargs):\n1237         if self.remote_field.parent_link:\n1238             return None\n1239         return super().formfield(**kwargs)\n1240 \n1241     def save_form_data(self, instance, data):\n1242         if isinstance(data, self.remote_field.model):\n1243             setattr(instance, self.name, data)\n1244         else:\n1245             setattr(instance, self.attname, data)\n1246             # Remote field object must be cleared otherwise Model.save()\n1247             # will reassign attname using the related object pk.\n1248             if data is None:\n1249                 setattr(instance, self.name, data)\n1250 \n1251     def _check_unique(self, **kwargs):\n1252         # Override ForeignKey since check isn't applicable here.\n1253         return []\n1254 \n1255 \n1256 def create_many_to_many_intermediary_model(field, klass):\n1257     from django.db import models\n1258 \n1259     def set_managed(model, related, through):\n1260         through._meta.managed = model._meta.managed or related._meta.managed\n1261 \n1262     to_model = resolve_relation(klass, field.remote_field.model)\n1263     name = \"%s_%s\" % (klass._meta.object_name, field.name)\n1264     lazy_related_operation(set_managed, klass, to_model, name)\n1265 \n1266     to = make_model_tuple(to_model)[1]\n1267     from_ = klass._meta.model_name\n1268     if to == from_:\n1269         to = \"to_%s\" % to\n1270         from_ = \"from_%s\" % from_\n1271 \n1272     meta = type(\n1273         \"Meta\",\n1274         (),\n1275         {\n1276             \"db_table\": field._get_m2m_db_table(klass._meta),\n1277             \"auto_created\": klass,\n1278             \"app_label\": klass._meta.app_label,\n1279             \"db_tablespace\": klass._meta.db_tablespace,\n1280             \"unique_together\": (from_, to),\n1281             \"verbose_name\": _(\"%(from)s-%(to)s relationship\")\n1282             % {\"from\": from_, \"to\": to},\n1283             \"verbose_name_plural\": _(\"%(from)s-%(to)s relationships\")\n1284             % {\"from\": from_, \"to\": to},\n1285             \"apps\": field.model._meta.apps,\n1286         },\n1287     )\n1288     # Construct and return the new class.\n1289     return type(\n1290         name,\n1291         (models.Model,),\n1292         {\n1293             \"Meta\": meta,\n1294             \"__module__\": klass.__module__,\n1295             from_: models.ForeignKey(\n1296                 klass,\n1297                 related_name=\"%s+\" % name,\n1298                 db_tablespace=field.db_tablespace,\n1299                 db_constraint=field.remote_field.db_constraint,\n1300                 on_delete=CASCADE,\n1301             ),\n1302             to: models.ForeignKey(\n1303                 to_model,\n1304                 related_name=\"%s+\" % name,\n1305                 db_tablespace=field.db_tablespace,\n1306                 db_constraint=field.remote_field.db_constraint,\n1307                 on_delete=CASCADE,\n1308             ),\n1309         },\n1310     )\n1311 \n1312 \n1313 class ManyToManyField(RelatedField):\n1314     \"\"\"\n1315     Provide a many-to-many relation by using an intermediary model that\n1316     holds two ForeignKey fields pointed at the two sides of the relation.\n1317 \n1318     Unless a ``through`` model was provided, ManyToManyField will use the\n1319     create_many_to_many_intermediary_model factory to automatically generate\n1320     the intermediary model.\n1321     \"\"\"\n1322 \n1323     # Field flags\n1324     many_to_many = True\n1325     many_to_one = False\n1326     one_to_many = False\n1327     one_to_one = False\n1328 \n1329     rel_class = ManyToManyRel\n1330 \n1331     description = _(\"Many-to-many relationship\")\n1332 \n1333     def __init__(\n1334         self,\n1335         to,\n1336         related_name=None,\n1337         related_query_name=None,\n1338         limit_choices_to=None,\n1339         symmetrical=None,\n1340         through=None,\n1341         through_fields=None,\n1342         db_constraint=True,\n1343         db_table=None,\n1344         swappable=True,\n1345         **kwargs,\n1346     ):\n1347         try:\n1348             to._meta\n1349         except AttributeError:\n1350             if not isinstance(to, str):\n1351                 raise TypeError(\n1352                     \"%s(%r) is invalid. First parameter to ManyToManyField \"\n1353                     \"must be either a model, a model name, or the string %r\"\n1354                     % (\n1355                         self.__class__.__name__,\n1356                         to,\n1357                         RECURSIVE_RELATIONSHIP_CONSTANT,\n1358                     )\n1359                 )\n1360 \n1361         if symmetrical is None:\n1362             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT\n1363 \n1364         if through is not None and db_table is not None:\n1365             raise ValueError(\n1366                 \"Cannot specify a db_table if an intermediary model is used.\"\n1367             )\n1368 \n1369         kwargs[\"rel\"] = self.rel_class(\n1370             self,\n1371             to,\n1372             related_name=related_name,\n1373             related_query_name=related_query_name,\n1374             limit_choices_to=limit_choices_to,\n1375             symmetrical=symmetrical,\n1376             through=through,\n1377             through_fields=through_fields,\n1378             db_constraint=db_constraint,\n1379         )\n1380         self.has_null_arg = \"null\" in kwargs\n1381 \n1382         super().__init__(\n1383             related_name=related_name,\n1384             related_query_name=related_query_name,\n1385             limit_choices_to=limit_choices_to,\n1386             **kwargs,\n1387         )\n1388 \n1389         self.db_table = db_table\n1390         self.swappable = swappable\n1391 \n1392     def check(self, **kwargs):\n1393         return [\n1394             *super().check(**kwargs),\n1395             *self._check_unique(**kwargs),\n1396             *self._check_relationship_model(**kwargs),\n1397             *self._check_ignored_options(**kwargs),\n1398             *self._check_table_uniqueness(**kwargs),\n1399         ]\n1400 \n1401     def _check_unique(self, **kwargs):\n1402         if self.unique:\n1403             return [\n1404                 checks.Error(\n1405                     \"ManyToManyFields cannot be unique.\",\n1406                     obj=self,\n1407                     id=\"fields.E330\",\n1408                 )\n1409             ]\n1410         return []\n1411 \n1412     def _check_ignored_options(self, **kwargs):\n1413         warnings = []\n1414 \n1415         if self.has_null_arg:\n1416             warnings.append(\n1417                 checks.Warning(\n1418                     \"null has no effect on ManyToManyField.\",\n1419                     obj=self,\n1420                     id=\"fields.W340\",\n1421                 )\n1422             )\n1423 \n1424         if self._validators:\n1425             warnings.append(\n1426                 checks.Warning(\n1427                     \"ManyToManyField does not support validators.\",\n1428                     obj=self,\n1429                     id=\"fields.W341\",\n1430                 )\n1431             )\n1432         if self.remote_field.symmetrical and self._related_name:\n1433             warnings.append(\n1434                 checks.Warning(\n1435                     \"related_name has no effect on ManyToManyField \"\n1436                     'with a symmetrical relationship, e.g. to \"self\".',\n1437                     obj=self,\n1438                     id=\"fields.W345\",\n1439                 )\n1440             )\n1441 \n1442         return warnings\n1443 \n1444     def _check_relationship_model(self, from_model=None, **kwargs):\n1445         if hasattr(self.remote_field.through, \"_meta\"):\n1446             qualified_model_name = \"%s.%s\" % (\n1447                 self.remote_field.through._meta.app_label,\n1448                 self.remote_field.through.__name__,\n1449             )\n1450         else:\n1451             qualified_model_name = self.remote_field.through\n1452 \n1453         errors = []\n1454 \n1455         if self.remote_field.through not in self.opts.apps.get_models(\n1456             include_auto_created=True\n1457         ):\n1458             # The relationship model is not installed.\n1459             errors.append(\n1460                 checks.Error(\n1461                     \"Field specifies a many-to-many relation through model \"\n1462                     \"'%s', which has not been installed.\" % qualified_model_name,\n1463                     obj=self,\n1464                     id=\"fields.E331\",\n1465                 )\n1466             )\n1467 \n1468         else:\n1469             assert from_model is not None, (\n1470                 \"ManyToManyField with intermediate \"\n1471                 \"tables cannot be checked if you don't pass the model \"\n1472                 \"where the field is attached to.\"\n1473             )\n1474             # Set some useful local variables\n1475             to_model = resolve_relation(from_model, self.remote_field.model)\n1476             from_model_name = from_model._meta.object_name\n1477             if isinstance(to_model, str):\n1478                 to_model_name = to_model\n1479             else:\n1480                 to_model_name = to_model._meta.object_name\n1481             relationship_model_name = self.remote_field.through._meta.object_name\n1482             self_referential = from_model == to_model\n1483             # Count foreign keys in intermediate model\n1484             if self_referential:\n1485                 seen_self = sum(\n1486                     from_model == getattr(field.remote_field, \"model\", None)\n1487                     for field in self.remote_field.through._meta.fields\n1488                 )\n1489 \n1490                 if seen_self > 2 and not self.remote_field.through_fields:\n1491                     errors.append(\n1492                         checks.Error(\n1493                             \"The model is used as an intermediate model by \"\n1494                             \"'%s', but it has more than two foreign keys \"\n1495                             \"to '%s', which is ambiguous. You must specify \"\n1496                             \"which two foreign keys Django should use via the \"\n1497                             \"through_fields keyword argument.\"\n1498                             % (self, from_model_name),\n1499                             hint=(\n1500                                 \"Use through_fields to specify which two foreign keys \"\n1501                                 \"Django should use.\"\n1502                             ),\n1503                             obj=self.remote_field.through,\n1504                             id=\"fields.E333\",\n1505                         )\n1506                     )\n1507 \n1508             else:\n1509                 # Count foreign keys in relationship model\n1510                 seen_from = sum(\n1511                     from_model == getattr(field.remote_field, \"model\", None)\n1512                     for field in self.remote_field.through._meta.fields\n1513                 )\n1514                 seen_to = sum(\n1515                     to_model == getattr(field.remote_field, \"model\", None)\n1516                     for field in self.remote_field.through._meta.fields\n1517                 )\n1518 \n1519                 if seen_from > 1 and not self.remote_field.through_fields:\n1520                     errors.append(\n1521                         checks.Error(\n1522                             (\n1523                                 \"The model is used as an intermediate model by \"\n1524                                 \"'%s', but it has more than one foreign key \"\n1525                                 \"from '%s', which is ambiguous. You must specify \"\n1526                                 \"which foreign key Django should use via the \"\n1527                                 \"through_fields keyword argument.\"\n1528                             )\n1529                             % (self, from_model_name),\n1530                             hint=(\n1531                                 \"If you want to create a recursive relationship, \"\n1532                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1533                             )\n1534                             % (\n1535                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1536                                 relationship_model_name,\n1537                             ),\n1538                             obj=self,\n1539                             id=\"fields.E334\",\n1540                         )\n1541                     )\n1542 \n1543                 if seen_to > 1 and not self.remote_field.through_fields:\n1544                     errors.append(\n1545                         checks.Error(\n1546                             \"The model is used as an intermediate model by \"\n1547                             \"'%s', but it has more than one foreign key \"\n1548                             \"to '%s', which is ambiguous. You must specify \"\n1549                             \"which foreign key Django should use via the \"\n1550                             \"through_fields keyword argument.\" % (self, to_model_name),\n1551                             hint=(\n1552                                 \"If you want to create a recursive relationship, \"\n1553                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1554                             )\n1555                             % (\n1556                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1557                                 relationship_model_name,\n1558                             ),\n1559                             obj=self,\n1560                             id=\"fields.E335\",\n1561                         )\n1562                     )\n1563 \n1564                 if seen_from == 0 or seen_to == 0:\n1565                     errors.append(\n1566                         checks.Error(\n1567                             \"The model is used as an intermediate model by \"\n1568                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\"\n1569                             % (self, from_model_name, to_model_name),\n1570                             obj=self.remote_field.through,\n1571                             id=\"fields.E336\",\n1572                         )\n1573                     )\n1574 \n1575         # Validate `through_fields`.\n1576         if self.remote_field.through_fields is not None:\n1577             # Validate that we're given an iterable of at least two items\n1578             # and that none of them is \"falsy\".\n1579             if not (\n1580                 len(self.remote_field.through_fields) >= 2\n1581                 and self.remote_field.through_fields[0]\n1582                 and self.remote_field.through_fields[1]\n1583             ):\n1584                 errors.append(\n1585                     checks.Error(\n1586                         \"Field specifies 'through_fields' but does not provide \"\n1587                         \"the names of the two link fields that should be used \"\n1588                         \"for the relation through model '%s'.\" % qualified_model_name,\n1589                         hint=(\n1590                             \"Make sure you specify 'through_fields' as \"\n1591                             \"through_fields=('field1', 'field2')\"\n1592                         ),\n1593                         obj=self,\n1594                         id=\"fields.E337\",\n1595                     )\n1596                 )\n1597 \n1598             # Validate the given through fields -- they should be actual\n1599             # fields on the through model, and also be foreign keys to the\n1600             # expected models.\n1601             else:\n1602                 assert from_model is not None, (\n1603                     \"ManyToManyField with intermediate \"\n1604                     \"tables cannot be checked if you don't pass the model \"\n1605                     \"where the field is attached to.\"\n1606                 )\n1607 \n1608                 source, through, target = (\n1609                     from_model,\n1610                     self.remote_field.through,\n1611                     self.remote_field.model,\n1612                 )\n1613                 source_field_name, target_field_name = self.remote_field.through_fields[\n1614                     :2\n1615                 ]\n1616 \n1617                 for field_name, related_model in (\n1618                     (source_field_name, source),\n1619                     (target_field_name, target),\n1620                 ):\n1621 \n1622                     possible_field_names = []\n1623                     for f in through._meta.fields:\n1624                         if (\n1625                             hasattr(f, \"remote_field\")\n1626                             and getattr(f.remote_field, \"model\", None) == related_model\n1627                         ):\n1628                             possible_field_names.append(f.name)\n1629                     if possible_field_names:\n1630                         hint = (\n1631                             \"Did you mean one of the following foreign keys to '%s': \"\n1632                             \"%s?\"\n1633                             % (\n1634                                 related_model._meta.object_name,\n1635                                 \", \".join(possible_field_names),\n1636                             )\n1637                         )\n1638                     else:\n1639                         hint = None\n1640 \n1641                     try:\n1642                         field = through._meta.get_field(field_name)\n1643                     except exceptions.FieldDoesNotExist:\n1644                         errors.append(\n1645                             checks.Error(\n1646                                 \"The intermediary model '%s' has no field '%s'.\"\n1647                                 % (qualified_model_name, field_name),\n1648                                 hint=hint,\n1649                                 obj=self,\n1650                                 id=\"fields.E338\",\n1651                             )\n1652                         )\n1653                     else:\n1654                         if not (\n1655                             hasattr(field, \"remote_field\")\n1656                             and getattr(field.remote_field, \"model\", None)\n1657                             == related_model\n1658                         ):\n1659                             errors.append(\n1660                                 checks.Error(\n1661                                     \"'%s.%s' is not a foreign key to '%s'.\"\n1662                                     % (\n1663                                         through._meta.object_name,\n1664                                         field_name,\n1665                                         related_model._meta.object_name,\n1666                                     ),\n1667                                     hint=hint,\n1668                                     obj=self,\n1669                                     id=\"fields.E339\",\n1670                                 )\n1671                             )\n1672 \n1673         return errors\n1674 \n1675     def _check_table_uniqueness(self, **kwargs):\n1676         if (\n1677             isinstance(self.remote_field.through, str)\n1678             or not self.remote_field.through._meta.managed\n1679         ):\n1680             return []\n1681         registered_tables = {\n1682             model._meta.db_table: model\n1683             for model in self.opts.apps.get_models(include_auto_created=True)\n1684             if model != self.remote_field.through and model._meta.managed\n1685         }\n1686         m2m_db_table = self.m2m_db_table()\n1687         model = registered_tables.get(m2m_db_table)\n1688         # The second condition allows multiple m2m relations on a model if\n1689         # some point to a through model that proxies another through model.\n1690         if (\n1691             model\n1692             and model._meta.concrete_model\n1693             != self.remote_field.through._meta.concrete_model\n1694         ):\n1695             if model._meta.auto_created:\n1696 \n1697                 def _get_field_name(model):\n1698                     for field in model._meta.auto_created._meta.many_to_many:\n1699                         if field.remote_field.through is model:\n1700                             return field.name\n1701 \n1702                 opts = model._meta.auto_created._meta\n1703                 clashing_obj = \"%s.%s\" % (opts.label, _get_field_name(model))\n1704             else:\n1705                 clashing_obj = model._meta.label\n1706             if settings.DATABASE_ROUTERS:\n1707                 error_class, error_id = checks.Warning, \"fields.W344\"\n1708                 error_hint = (\n1709                     \"You have configured settings.DATABASE_ROUTERS. Verify \"\n1710                     \"that the table of %r is correctly routed to a separate \"\n1711                     \"database.\" % clashing_obj\n1712                 )\n1713             else:\n1714                 error_class, error_id = checks.Error, \"fields.E340\"\n1715                 error_hint = None\n1716             return [\n1717                 error_class(\n1718                     \"The field's intermediary table '%s' clashes with the \"\n1719                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1720                     obj=self,\n1721                     hint=error_hint,\n1722                     id=error_id,\n1723                 )\n1724             ]\n1725         return []\n1726 \n1727     def deconstruct(self):\n1728         name, path, args, kwargs = super().deconstruct()\n1729         # Handle the simpler arguments.\n1730         if self.db_table is not None:\n1731             kwargs[\"db_table\"] = self.db_table\n1732         if self.remote_field.db_constraint is not True:\n1733             kwargs[\"db_constraint\"] = self.remote_field.db_constraint\n1734         # Lowercase model names as they should be treated as case-insensitive.\n1735         if isinstance(self.remote_field.model, str):\n1736             if \".\" in self.remote_field.model:\n1737                 app_label, model_name = self.remote_field.model.split(\".\")\n1738                 kwargs[\"to\"] = \"%s.%s\" % (app_label, model_name.lower())\n1739             else:\n1740                 kwargs[\"to\"] = self.remote_field.model.lower()\n1741         else:\n1742             kwargs[\"to\"] = self.remote_field.model._meta.label_lower\n1743         if getattr(self.remote_field, \"through\", None) is not None:\n1744             if isinstance(self.remote_field.through, str):\n1745                 kwargs[\"through\"] = self.remote_field.through\n1746             elif not self.remote_field.through._meta.auto_created:\n1747                 kwargs[\"through\"] = self.remote_field.through._meta.label\n1748         # If swappable is True, then see if we're actually pointing to the target\n1749         # of a swap.\n1750         swappable_setting = self.swappable_setting\n1751         if swappable_setting is not None:\n1752             # If it's already a settings reference, error.\n1753             if hasattr(kwargs[\"to\"], \"setting_name\"):\n1754                 if kwargs[\"to\"].setting_name != swappable_setting:\n1755                     raise ValueError(\n1756                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1757                         \"model that is swapped in place of more than one model \"\n1758                         \"(%s and %s)\" % (kwargs[\"to\"].setting_name, swappable_setting)\n1759                     )\n1760 \n1761             kwargs[\"to\"] = SettingsReference(\n1762                 kwargs[\"to\"],\n1763                 swappable_setting,\n1764             )\n1765         return name, path, args, kwargs\n1766 \n1767     def _get_path_info(self, direct=False, filtered_relation=None):\n1768         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1769         int_model = self.remote_field.through\n1770         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1771         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1772         if direct:\n1773             join1infos = linkfield1.reverse_path_infos\n1774             if filtered_relation:\n1775                 join2infos = linkfield2.get_path_info(filtered_relation)\n1776             else:\n1777                 join2infos = linkfield2.path_infos\n1778         else:\n1779             join1infos = linkfield2.reverse_path_infos\n1780             if filtered_relation:\n1781                 join2infos = linkfield1.get_path_info(filtered_relation)\n1782             else:\n1783                 join2infos = linkfield1.path_infos\n1784         # Get join infos between the last model of join 1 and the first model\n1785         # of join 2. Assume the only reason these may differ is due to model\n1786         # inheritance.\n1787         join1_final = join1infos[-1].to_opts\n1788         join2_initial = join2infos[0].from_opts\n1789         if join1_final is join2_initial:\n1790             intermediate_infos = []\n1791         elif issubclass(join1_final.model, join2_initial.model):\n1792             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1793         else:\n1794             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1795 \n1796         return [*join1infos, *intermediate_infos, *join2infos]\n1797 \n1798     def get_path_info(self, filtered_relation=None):\n1799         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1800 \n1801     @cached_property\n1802     def path_infos(self):\n1803         return self.get_path_info()\n1804 \n1805     def get_reverse_path_info(self, filtered_relation=None):\n1806         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1807 \n1808     @cached_property\n1809     def reverse_path_infos(self):\n1810         return self.get_reverse_path_info()\n1811 \n1812     def _get_m2m_db_table(self, opts):\n1813         \"\"\"\n1814         Function that can be curried to provide the m2m table name for this\n1815         relation.\n1816         \"\"\"\n1817         if self.remote_field.through is not None:\n1818             return self.remote_field.through._meta.db_table\n1819         elif self.db_table:\n1820             return self.db_table\n1821         else:\n1822             m2m_table_name = \"%s_%s\" % (utils.strip_quotes(opts.db_table), self.name)\n1823             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1824 \n1825     def _get_m2m_attr(self, related, attr):\n1826         \"\"\"\n1827         Function that can be curried to provide the source accessor or DB\n1828         column name for the m2m table.\n1829         \"\"\"\n1830         cache_attr = \"_m2m_%s_cache\" % attr\n1831         if hasattr(self, cache_attr):\n1832             return getattr(self, cache_attr)\n1833         if self.remote_field.through_fields is not None:\n1834             link_field_name = self.remote_field.through_fields[0]\n1835         else:\n1836             link_field_name = None\n1837         for f in self.remote_field.through._meta.fields:\n1838             if (\n1839                 f.is_relation\n1840                 and f.remote_field.model == related.related_model\n1841                 and (link_field_name is None or link_field_name == f.name)\n1842             ):\n1843                 setattr(self, cache_attr, getattr(f, attr))\n1844                 return getattr(self, cache_attr)\n1845 \n1846     def _get_m2m_reverse_attr(self, related, attr):\n1847         \"\"\"\n1848         Function that can be curried to provide the related accessor or DB\n1849         column name for the m2m table.\n1850         \"\"\"\n1851         cache_attr = \"_m2m_reverse_%s_cache\" % attr\n1852         if hasattr(self, cache_attr):\n1853             return getattr(self, cache_attr)\n1854         found = False\n1855         if self.remote_field.through_fields is not None:\n1856             link_field_name = self.remote_field.through_fields[1]\n1857         else:\n1858             link_field_name = None\n1859         for f in self.remote_field.through._meta.fields:\n1860             if f.is_relation and f.remote_field.model == related.model:\n1861                 if link_field_name is None and related.related_model == related.model:\n1862                     # If this is an m2m-intermediate to self,\n1863                     # the first foreign key you find will be\n1864                     # the source column. Keep searching for\n1865                     # the second foreign key.\n1866                     if found:\n1867                         setattr(self, cache_attr, getattr(f, attr))\n1868                         break\n1869                     else:\n1870                         found = True\n1871                 elif link_field_name is None or link_field_name == f.name:\n1872                     setattr(self, cache_attr, getattr(f, attr))\n1873                     break\n1874         return getattr(self, cache_attr)\n1875 \n1876     def contribute_to_class(self, cls, name, **kwargs):\n1877         # To support multiple relations to self, it's useful to have a non-None\n1878         # related name on symmetrical relations for internal reasons. The\n1879         # concept doesn't make a lot of sense externally (\"you want me to\n1880         # specify *what* on my non-reversible relation?!\"), so we set it up\n1881         # automatically. The funky name reduces the chance of an accidental\n1882         # clash.\n1883         if self.remote_field.symmetrical and (\n1884             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT\n1885             or self.remote_field.model == cls._meta.object_name\n1886         ):\n1887             self.remote_field.related_name = \"%s_rel_+\" % name\n1888         elif self.remote_field.is_hidden():\n1889             # If the backwards relation is disabled, replace the original\n1890             # related_name with one generated from the m2m field name. Django\n1891             # still uses backwards relations internally and we need to avoid\n1892             # clashes between multiple m2m fields with related_name == '+'.\n1893             self.remote_field.related_name = \"_%s_%s_%s_+\" % (\n1894                 cls._meta.app_label,\n1895                 cls.__name__.lower(),\n1896                 name,\n1897             )\n1898 \n1899         super().contribute_to_class(cls, name, **kwargs)\n1900 \n1901         # The intermediate m2m model is not auto created if:\n1902         #  1) There is a manually specified intermediate, or\n1903         #  2) The class owning the m2m field is abstract.\n1904         #  3) The class owning the m2m field has been swapped out.\n1905         if not cls._meta.abstract:\n1906             if self.remote_field.through:\n1907 \n1908                 def resolve_through_model(_, model, field):\n1909                     field.remote_field.through = model\n1910 \n1911                 lazy_related_operation(\n1912                     resolve_through_model, cls, self.remote_field.through, field=self\n1913                 )\n1914             elif not cls._meta.swapped:\n1915                 self.remote_field.through = create_many_to_many_intermediary_model(\n1916                     self, cls\n1917                 )\n1918 \n1919         # Add the descriptor for the m2m relation.\n1920         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1921 \n1922         # Set up the accessor for the m2m table name for the relation.\n1923         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1924 \n1925     def contribute_to_related_class(self, cls, related):\n1926         # Internal M2Ms (i.e., those with a related name ending with '+')\n1927         # and swapped models don't get a related descriptor.\n1928         if (\n1929             not self.remote_field.is_hidden()\n1930             and not related.related_model._meta.swapped\n1931         ):\n1932             setattr(\n1933                 cls,\n1934                 related.get_accessor_name(),\n1935                 ManyToManyDescriptor(self.remote_field, reverse=True),\n1936             )\n1937 \n1938         # Set up the accessors for the column names on the m2m table.\n1939         self.m2m_column_name = partial(self._get_m2m_attr, related, \"column\")\n1940         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, \"column\")\n1941 \n1942         self.m2m_field_name = partial(self._get_m2m_attr, related, \"name\")\n1943         self.m2m_reverse_field_name = partial(\n1944             self._get_m2m_reverse_attr, related, \"name\"\n1945         )\n1946 \n1947         get_m2m_rel = partial(self._get_m2m_attr, related, \"remote_field\")\n1948         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1949         get_m2m_reverse_rel = partial(\n1950             self._get_m2m_reverse_attr, related, \"remote_field\"\n1951         )\n1952         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1953 \n1954     def set_attributes_from_rel(self):\n1955         pass\n1956 \n1957     def value_from_object(self, obj):\n1958         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1959 \n1960     def save_form_data(self, instance, data):\n1961         getattr(instance, self.attname).set(data)\n1962 \n1963     def formfield(self, *, using=None, **kwargs):\n1964         defaults = {\n1965             \"form_class\": forms.ModelMultipleChoiceField,\n1966             \"queryset\": self.remote_field.model._default_manager.using(using),\n1967             **kwargs,\n1968         }\n1969         # If initial is passed in, it's a list of related objects, but the\n1970         # MultipleChoiceField takes a list of IDs.\n1971         if defaults.get(\"initial\") is not None:\n1972             initial = defaults[\"initial\"]\n1973             if callable(initial):\n1974                 initial = initial()\n1975             defaults[\"initial\"] = [i.pk for i in initial]\n1976         return super().formfield(**defaults)\n1977 \n1978     def db_check(self, connection):\n1979         return None\n1980 \n1981     def db_type(self, connection):\n1982         # A ManyToManyField is not represented by a single column,\n1983         # so return None.\n1984         return None\n1985 \n1986     def db_parameters(self, connection):\n1987         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "Modify the definition of ForeignKey fields (and related fields) to respect or optionally inherit `db_collation` from the referenced primary key field. This could involve adjusting the field's creation or alteration logic within Django's migration framework to include collation settings explicitly where necessary."
    },
    {
        "rel_file_path": "django/db/migrations/operations/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/migrations/operations/models.py",
        "start": 1,
        "end": 959,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db import models\n2 from django.db.migrations.operations.base import Operation\n3 from django.db.migrations.state import ModelState\n4 from django.db.migrations.utils import field_references, resolve_relation\n5 from django.db.models.options import normalize_together\n6 from django.utils.functional import cached_property\n7 \n8 from .fields import AddField, AlterField, FieldOperation, RemoveField, RenameField\n9 \n10 \n11 def _check_for_duplicates(arg_name, objs):\n12     used_vals = set()\n13     for val in objs:\n14         if val in used_vals:\n15             raise ValueError(\n16                 \"Found duplicate value %s in CreateModel %s argument.\" % (val, arg_name)\n17             )\n18         used_vals.add(val)\n19 \n20 \n21 class ModelOperation(Operation):\n22     def __init__(self, name):\n23         self.name = name\n24 \n25     @cached_property\n26     def name_lower(self):\n27         return self.name.lower()\n28 \n29     def references_model(self, name, app_label):\n30         return name.lower() == self.name_lower\n31 \n32     def reduce(self, operation, app_label):\n33         return super().reduce(operation, app_label) or self.can_reduce_through(\n34             operation, app_label\n35         )\n36 \n37     def can_reduce_through(self, operation, app_label):\n38         return not operation.references_model(self.name, app_label)\n39 \n40 \n41 class CreateModel(ModelOperation):\n42     \"\"\"Create a model's table.\"\"\"\n43 \n44     serialization_expand_args = [\"fields\", \"options\", \"managers\"]\n45 \n46     def __init__(self, name, fields, options=None, bases=None, managers=None):\n47         self.fields = fields\n48         self.options = options or {}\n49         self.bases = bases or (models.Model,)\n50         self.managers = managers or []\n51         super().__init__(name)\n52         # Sanity-check that there are no duplicated field names, bases, or\n53         # manager names\n54         _check_for_duplicates(\"fields\", (name for name, _ in self.fields))\n55         _check_for_duplicates(\n56             \"bases\",\n57             (\n58                 base._meta.label_lower\n59                 if hasattr(base, \"_meta\")\n60                 else base.lower()\n61                 if isinstance(base, str)\n62                 else base\n63                 for base in self.bases\n64             ),\n65         )\n66         _check_for_duplicates(\"managers\", (name for name, _ in self.managers))\n67 \n68     def deconstruct(self):\n69         kwargs = {\n70             \"name\": self.name,\n71             \"fields\": self.fields,\n72         }\n73         if self.options:\n74             kwargs[\"options\"] = self.options\n75         if self.bases and self.bases != (models.Model,):\n76             kwargs[\"bases\"] = self.bases\n77         if self.managers and self.managers != [(\"objects\", models.Manager())]:\n78             kwargs[\"managers\"] = self.managers\n79         return (self.__class__.__qualname__, [], kwargs)\n80 \n81     def state_forwards(self, app_label, state):\n82         state.add_model(\n83             ModelState(\n84                 app_label,\n85                 self.name,\n86                 list(self.fields),\n87                 dict(self.options),\n88                 tuple(self.bases),\n89                 list(self.managers),\n90             )\n91         )\n92 \n93     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n94         model = to_state.apps.get_model(app_label, self.name)\n95         if self.allow_migrate_model(schema_editor.connection.alias, model):\n96             schema_editor.create_model(model)\n97 \n98     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n99         model = from_state.apps.get_model(app_label, self.name)\n100         if self.allow_migrate_model(schema_editor.connection.alias, model):\n101             schema_editor.delete_model(model)\n102 \n103     def describe(self):\n104         return \"Create %smodel %s\" % (\n105             \"proxy \" if self.options.get(\"proxy\", False) else \"\",\n106             self.name,\n107         )\n108 \n109     @property\n110     def migration_name_fragment(self):\n111         return self.name_lower\n112 \n113     def references_model(self, name, app_label):\n114         name_lower = name.lower()\n115         if name_lower == self.name_lower:\n116             return True\n117 \n118         # Check we didn't inherit from the model\n119         reference_model_tuple = (app_label, name_lower)\n120         for base in self.bases:\n121             if (\n122                 base is not models.Model\n123                 and isinstance(base, (models.base.ModelBase, str))\n124                 and resolve_relation(base, app_label) == reference_model_tuple\n125             ):\n126                 return True\n127 \n128         # Check we have no FKs/M2Ms with it\n129         for _name, field in self.fields:\n130             if field_references(\n131                 (app_label, self.name_lower), field, reference_model_tuple\n132             ):\n133                 return True\n134         return False\n135 \n136     def reduce(self, operation, app_label):\n137         if (\n138             isinstance(operation, DeleteModel)\n139             and self.name_lower == operation.name_lower\n140             and not self.options.get(\"proxy\", False)\n141         ):\n142             return []\n143         elif (\n144             isinstance(operation, RenameModel)\n145             and self.name_lower == operation.old_name_lower\n146         ):\n147             return [\n148                 CreateModel(\n149                     operation.new_name,\n150                     fields=self.fields,\n151                     options=self.options,\n152                     bases=self.bases,\n153                     managers=self.managers,\n154                 ),\n155             ]\n156         elif (\n157             isinstance(operation, AlterModelOptions)\n158             and self.name_lower == operation.name_lower\n159         ):\n160             options = {**self.options, **operation.options}\n161             for key in operation.ALTER_OPTION_KEYS:\n162                 if key not in operation.options:\n163                     options.pop(key, None)\n164             return [\n165                 CreateModel(\n166                     self.name,\n167                     fields=self.fields,\n168                     options=options,\n169                     bases=self.bases,\n170                     managers=self.managers,\n171                 ),\n172             ]\n173         elif (\n174             isinstance(operation, AlterModelManagers)\n175             and self.name_lower == operation.name_lower\n176         ):\n177             return [\n178                 CreateModel(\n179                     self.name,\n180                     fields=self.fields,\n181                     options=self.options,\n182                     bases=self.bases,\n183                     managers=operation.managers,\n184                 ),\n185             ]\n186         elif (\n187             isinstance(operation, AlterTogetherOptionOperation)\n188             and self.name_lower == operation.name_lower\n189         ):\n190             return [\n191                 CreateModel(\n192                     self.name,\n193                     fields=self.fields,\n194                     options={\n195                         **self.options,\n196                         **{operation.option_name: operation.option_value},\n197                     },\n198                     bases=self.bases,\n199                     managers=self.managers,\n200                 ),\n201             ]\n202         elif (\n203             isinstance(operation, AlterOrderWithRespectTo)\n204             and self.name_lower == operation.name_lower\n205         ):\n206             return [\n207                 CreateModel(\n208                     self.name,\n209                     fields=self.fields,\n210                     options={\n211                         **self.options,\n212                         \"order_with_respect_to\": operation.order_with_respect_to,\n213                     },\n214                     bases=self.bases,\n215                     managers=self.managers,\n216                 ),\n217             ]\n218         elif (\n219             isinstance(operation, FieldOperation)\n220             and self.name_lower == operation.model_name_lower\n221         ):\n222             if isinstance(operation, AddField):\n223                 return [\n224                     CreateModel(\n225                         self.name,\n226                         fields=self.fields + [(operation.name, operation.field)],\n227                         options=self.options,\n228                         bases=self.bases,\n229                         managers=self.managers,\n230                     ),\n231                 ]\n232             elif isinstance(operation, AlterField):\n233                 return [\n234                     CreateModel(\n235                         self.name,\n236                         fields=[\n237                             (n, operation.field if n == operation.name else v)\n238                             for n, v in self.fields\n239                         ],\n240                         options=self.options,\n241                         bases=self.bases,\n242                         managers=self.managers,\n243                     ),\n244                 ]\n245             elif isinstance(operation, RemoveField):\n246                 options = self.options.copy()\n247                 for option_name in (\"unique_together\", \"index_together\"):\n248                     option = options.pop(option_name, None)\n249                     if option:\n250                         option = set(\n251                             filter(\n252                                 bool,\n253                                 (\n254                                     tuple(\n255                                         f for f in fields if f != operation.name_lower\n256                                     )\n257                                     for fields in option\n258                                 ),\n259                             )\n260                         )\n261                         if option:\n262                             options[option_name] = option\n263                 order_with_respect_to = options.get(\"order_with_respect_to\")\n264                 if order_with_respect_to == operation.name_lower:\n265                     del options[\"order_with_respect_to\"]\n266                 return [\n267                     CreateModel(\n268                         self.name,\n269                         fields=[\n270                             (n, v)\n271                             for n, v in self.fields\n272                             if n.lower() != operation.name_lower\n273                         ],\n274                         options=options,\n275                         bases=self.bases,\n276                         managers=self.managers,\n277                     ),\n278                 ]\n279             elif isinstance(operation, RenameField):\n280                 options = self.options.copy()\n281                 for option_name in (\"unique_together\", \"index_together\"):\n282                     option = options.get(option_name)\n283                     if option:\n284                         options[option_name] = {\n285                             tuple(\n286                                 operation.new_name if f == operation.old_name else f\n287                                 for f in fields\n288                             )\n289                             for fields in option\n290                         }\n291                 order_with_respect_to = options.get(\"order_with_respect_to\")\n292                 if order_with_respect_to == operation.old_name:\n293                     options[\"order_with_respect_to\"] = operation.new_name\n294                 return [\n295                     CreateModel(\n296                         self.name,\n297                         fields=[\n298                             (operation.new_name if n == operation.old_name else n, v)\n299                             for n, v in self.fields\n300                         ],\n301                         options=options,\n302                         bases=self.bases,\n303                         managers=self.managers,\n304                     ),\n305                 ]\n306         return super().reduce(operation, app_label)\n307 \n308 \n309 class DeleteModel(ModelOperation):\n310     \"\"\"Drop a model's table.\"\"\"\n311 \n312     def deconstruct(self):\n313         kwargs = {\n314             \"name\": self.name,\n315         }\n316         return (self.__class__.__qualname__, [], kwargs)\n317 \n318     def state_forwards(self, app_label, state):\n319         state.remove_model(app_label, self.name_lower)\n320 \n321     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n322         model = from_state.apps.get_model(app_label, self.name)\n323         if self.allow_migrate_model(schema_editor.connection.alias, model):\n324             schema_editor.delete_model(model)\n325 \n326     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n327         model = to_state.apps.get_model(app_label, self.name)\n328         if self.allow_migrate_model(schema_editor.connection.alias, model):\n329             schema_editor.create_model(model)\n330 \n331     def references_model(self, name, app_label):\n332         # The deleted model could be referencing the specified model through\n333         # related fields.\n334         return True\n335 \n336     def describe(self):\n337         return \"Delete model %s\" % self.name\n338 \n339     @property\n340     def migration_name_fragment(self):\n341         return \"delete_%s\" % self.name_lower\n342 \n343 \n344 class RenameModel(ModelOperation):\n345     \"\"\"Rename a model.\"\"\"\n346 \n347     def __init__(self, old_name, new_name):\n348         self.old_name = old_name\n349         self.new_name = new_name\n350         super().__init__(old_name)\n351 \n352     @cached_property\n353     def old_name_lower(self):\n354         return self.old_name.lower()\n355 \n356     @cached_property\n357     def new_name_lower(self):\n358         return self.new_name.lower()\n359 \n360     def deconstruct(self):\n361         kwargs = {\n362             \"old_name\": self.old_name,\n363             \"new_name\": self.new_name,\n364         }\n365         return (self.__class__.__qualname__, [], kwargs)\n366 \n367     def state_forwards(self, app_label, state):\n368         state.rename_model(app_label, self.old_name, self.new_name)\n369 \n370     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n371         new_model = to_state.apps.get_model(app_label, self.new_name)\n372         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n373             old_model = from_state.apps.get_model(app_label, self.old_name)\n374             old_db_table = old_model._meta.db_table\n375             new_db_table = new_model._meta.db_table\n376             # Don't alter when a table name is not changed.\n377             if old_db_table == new_db_table:\n378                 return\n379             # Move the main table\n380             schema_editor.alter_db_table(new_model, old_db_table, new_db_table)\n381             # Alter the fields pointing to us\n382             for related_object in old_model._meta.related_objects:\n383                 if related_object.related_model == old_model:\n384                     model = new_model\n385                     related_key = (app_label, self.new_name_lower)\n386                 else:\n387                     model = related_object.related_model\n388                     related_key = (\n389                         related_object.related_model._meta.app_label,\n390                         related_object.related_model._meta.model_name,\n391                     )\n392                 to_field = to_state.apps.get_model(*related_key)._meta.get_field(\n393                     related_object.field.name\n394                 )\n395                 schema_editor.alter_field(\n396                     model,\n397                     related_object.field,\n398                     to_field,\n399                 )\n400             # Rename M2M fields whose name is based on this model's name.\n401             fields = zip(\n402                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many\n403             )\n404             for (old_field, new_field) in fields:\n405                 # Skip self-referential fields as these are renamed above.\n406                 if (\n407                     new_field.model == new_field.related_model\n408                     or not new_field.remote_field.through._meta.auto_created\n409                 ):\n410                     continue\n411                 # Rename the M2M table that's based on this model's name.\n412                 old_m2m_model = old_field.remote_field.through\n413                 new_m2m_model = new_field.remote_field.through\n414                 schema_editor.alter_db_table(\n415                     new_m2m_model,\n416                     old_m2m_model._meta.db_table,\n417                     new_m2m_model._meta.db_table,\n418                 )\n419                 # Rename the column in the M2M table that's based on this\n420                 # model's name.\n421                 schema_editor.alter_field(\n422                     new_m2m_model,\n423                     old_m2m_model._meta.get_field(old_model._meta.model_name),\n424                     new_m2m_model._meta.get_field(new_model._meta.model_name),\n425                 )\n426 \n427     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n428         self.new_name_lower, self.old_name_lower = (\n429             self.old_name_lower,\n430             self.new_name_lower,\n431         )\n432         self.new_name, self.old_name = self.old_name, self.new_name\n433 \n434         self.database_forwards(app_label, schema_editor, from_state, to_state)\n435 \n436         self.new_name_lower, self.old_name_lower = (\n437             self.old_name_lower,\n438             self.new_name_lower,\n439         )\n440         self.new_name, self.old_name = self.old_name, self.new_name\n441 \n442     def references_model(self, name, app_label):\n443         return (\n444             name.lower() == self.old_name_lower or name.lower() == self.new_name_lower\n445         )\n446 \n447     def describe(self):\n448         return \"Rename model %s to %s\" % (self.old_name, self.new_name)\n449 \n450     @property\n451     def migration_name_fragment(self):\n452         return \"rename_%s_%s\" % (self.old_name_lower, self.new_name_lower)\n453 \n454     def reduce(self, operation, app_label):\n455         if (\n456             isinstance(operation, RenameModel)\n457             and self.new_name_lower == operation.old_name_lower\n458         ):\n459             return [\n460                 RenameModel(\n461                     self.old_name,\n462                     operation.new_name,\n463                 ),\n464             ]\n465         # Skip `ModelOperation.reduce` as we want to run `references_model`\n466         # against self.new_name.\n467         return super(ModelOperation, self).reduce(\n468             operation, app_label\n469         ) or not operation.references_model(self.new_name, app_label)\n470 \n471 \n472 class ModelOptionOperation(ModelOperation):\n473     def reduce(self, operation, app_label):\n474         if (\n475             isinstance(operation, (self.__class__, DeleteModel))\n476             and self.name_lower == operation.name_lower\n477         ):\n478             return [operation]\n479         return super().reduce(operation, app_label)\n480 \n481 \n482 class AlterModelTable(ModelOptionOperation):\n483     \"\"\"Rename a model's table.\"\"\"\n484 \n485     def __init__(self, name, table):\n486         self.table = table\n487         super().__init__(name)\n488 \n489     def deconstruct(self):\n490         kwargs = {\n491             \"name\": self.name,\n492             \"table\": self.table,\n493         }\n494         return (self.__class__.__qualname__, [], kwargs)\n495 \n496     def state_forwards(self, app_label, state):\n497         state.alter_model_options(app_label, self.name_lower, {\"db_table\": self.table})\n498 \n499     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n500         new_model = to_state.apps.get_model(app_label, self.name)\n501         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n502             old_model = from_state.apps.get_model(app_label, self.name)\n503             schema_editor.alter_db_table(\n504                 new_model,\n505                 old_model._meta.db_table,\n506                 new_model._meta.db_table,\n507             )\n508             # Rename M2M fields whose name is based on this model's db_table\n509             for (old_field, new_field) in zip(\n510                 old_model._meta.local_many_to_many, new_model._meta.local_many_to_many\n511             ):\n512                 if new_field.remote_field.through._meta.auto_created:\n513                     schema_editor.alter_db_table(\n514                         new_field.remote_field.through,\n515                         old_field.remote_field.through._meta.db_table,\n516                         new_field.remote_field.through._meta.db_table,\n517                     )\n518 \n519     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n520         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n521 \n522     def describe(self):\n523         return \"Rename table for %s to %s\" % (\n524             self.name,\n525             self.table if self.table is not None else \"(default)\",\n526         )\n527 \n528     @property\n529     def migration_name_fragment(self):\n530         return \"alter_%s_table\" % self.name_lower\n531 \n532 \n533 class AlterTogetherOptionOperation(ModelOptionOperation):\n534     option_name = None\n535 \n536     def __init__(self, name, option_value):\n537         if option_value:\n538             option_value = set(normalize_together(option_value))\n539         setattr(self, self.option_name, option_value)\n540         super().__init__(name)\n541 \n542     @cached_property\n543     def option_value(self):\n544         return getattr(self, self.option_name)\n545 \n546     def deconstruct(self):\n547         kwargs = {\n548             \"name\": self.name,\n549             self.option_name: self.option_value,\n550         }\n551         return (self.__class__.__qualname__, [], kwargs)\n552 \n553     def state_forwards(self, app_label, state):\n554         state.alter_model_options(\n555             app_label,\n556             self.name_lower,\n557             {self.option_name: self.option_value},\n558         )\n559 \n560     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n561         new_model = to_state.apps.get_model(app_label, self.name)\n562         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n563             old_model = from_state.apps.get_model(app_label, self.name)\n564             alter_together = getattr(schema_editor, \"alter_%s\" % self.option_name)\n565             alter_together(\n566                 new_model,\n567                 getattr(old_model._meta, self.option_name, set()),\n568                 getattr(new_model._meta, self.option_name, set()),\n569             )\n570 \n571     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n572         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n573 \n574     def references_field(self, model_name, name, app_label):\n575         return self.references_model(model_name, app_label) and (\n576             not self.option_value\n577             or any((name in fields) for fields in self.option_value)\n578         )\n579 \n580     def describe(self):\n581         return \"Alter %s for %s (%s constraint(s))\" % (\n582             self.option_name,\n583             self.name,\n584             len(self.option_value or \"\"),\n585         )\n586 \n587     @property\n588     def migration_name_fragment(self):\n589         return \"alter_%s_%s\" % (self.name_lower, self.option_name)\n590 \n591     def can_reduce_through(self, operation, app_label):\n592         return super().can_reduce_through(operation, app_label) or (\n593             isinstance(operation, AlterTogetherOptionOperation)\n594             and type(operation) is not type(self)\n595         )\n596 \n597 \n598 class AlterUniqueTogether(AlterTogetherOptionOperation):\n599     \"\"\"\n600     Change the value of unique_together to the target one.\n601     Input value of unique_together must be a set of tuples.\n602     \"\"\"\n603 \n604     option_name = \"unique_together\"\n605 \n606     def __init__(self, name, unique_together):\n607         super().__init__(name, unique_together)\n608 \n609 \n610 class AlterIndexTogether(AlterTogetherOptionOperation):\n611     \"\"\"\n612     Change the value of index_together to the target one.\n613     Input value of index_together must be a set of tuples.\n614     \"\"\"\n615 \n616     option_name = \"index_together\"\n617 \n618     def __init__(self, name, index_together):\n619         super().__init__(name, index_together)\n620 \n621 \n622 class AlterOrderWithRespectTo(ModelOptionOperation):\n623     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n624 \n625     option_name = \"order_with_respect_to\"\n626 \n627     def __init__(self, name, order_with_respect_to):\n628         self.order_with_respect_to = order_with_respect_to\n629         super().__init__(name)\n630 \n631     def deconstruct(self):\n632         kwargs = {\n633             \"name\": self.name,\n634             \"order_with_respect_to\": self.order_with_respect_to,\n635         }\n636         return (self.__class__.__qualname__, [], kwargs)\n637 \n638     def state_forwards(self, app_label, state):\n639         state.alter_model_options(\n640             app_label,\n641             self.name_lower,\n642             {self.option_name: self.order_with_respect_to},\n643         )\n644 \n645     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n646         to_model = to_state.apps.get_model(app_label, self.name)\n647         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n648             from_model = from_state.apps.get_model(app_label, self.name)\n649             # Remove a field if we need to\n650             if (\n651                 from_model._meta.order_with_respect_to\n652                 and not to_model._meta.order_with_respect_to\n653             ):\n654                 schema_editor.remove_field(\n655                     from_model, from_model._meta.get_field(\"_order\")\n656                 )\n657             # Add a field if we need to (altering the column is untouched as\n658             # it's likely a rename)\n659             elif (\n660                 to_model._meta.order_with_respect_to\n661                 and not from_model._meta.order_with_respect_to\n662             ):\n663                 field = to_model._meta.get_field(\"_order\")\n664                 if not field.has_default():\n665                     field.default = 0\n666                 schema_editor.add_field(\n667                     from_model,\n668                     field,\n669                 )\n670 \n671     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n672         self.database_forwards(app_label, schema_editor, from_state, to_state)\n673 \n674     def references_field(self, model_name, name, app_label):\n675         return self.references_model(model_name, app_label) and (\n676             self.order_with_respect_to is None or name == self.order_with_respect_to\n677         )\n678 \n679     def describe(self):\n680         return \"Set order_with_respect_to on %s to %s\" % (\n681             self.name,\n682             self.order_with_respect_to,\n683         )\n684 \n685     @property\n686     def migration_name_fragment(self):\n687         return \"alter_%s_order_with_respect_to\" % self.name_lower\n688 \n689 \n690 class AlterModelOptions(ModelOptionOperation):\n691     \"\"\"\n692     Set new model options that don't directly affect the database schema\n693     (like verbose_name, permissions, ordering). Python code in migrations\n694     may still need them.\n695     \"\"\"\n696 \n697     # Model options we want to compare and preserve in an AlterModelOptions op\n698     ALTER_OPTION_KEYS = [\n699         \"base_manager_name\",\n700         \"default_manager_name\",\n701         \"default_related_name\",\n702         \"get_latest_by\",\n703         \"managed\",\n704         \"ordering\",\n705         \"permissions\",\n706         \"default_permissions\",\n707         \"select_on_save\",\n708         \"verbose_name\",\n709         \"verbose_name_plural\",\n710     ]\n711 \n712     def __init__(self, name, options):\n713         self.options = options\n714         super().__init__(name)\n715 \n716     def deconstruct(self):\n717         kwargs = {\n718             \"name\": self.name,\n719             \"options\": self.options,\n720         }\n721         return (self.__class__.__qualname__, [], kwargs)\n722 \n723     def state_forwards(self, app_label, state):\n724         state.alter_model_options(\n725             app_label,\n726             self.name_lower,\n727             self.options,\n728             self.ALTER_OPTION_KEYS,\n729         )\n730 \n731     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n732         pass\n733 \n734     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n735         pass\n736 \n737     def describe(self):\n738         return \"Change Meta options on %s\" % self.name\n739 \n740     @property\n741     def migration_name_fragment(self):\n742         return \"alter_%s_options\" % self.name_lower\n743 \n744 \n745 class AlterModelManagers(ModelOptionOperation):\n746     \"\"\"Alter the model's managers.\"\"\"\n747 \n748     serialization_expand_args = [\"managers\"]\n749 \n750     def __init__(self, name, managers):\n751         self.managers = managers\n752         super().__init__(name)\n753 \n754     def deconstruct(self):\n755         return (self.__class__.__qualname__, [self.name, self.managers], {})\n756 \n757     def state_forwards(self, app_label, state):\n758         state.alter_model_managers(app_label, self.name_lower, self.managers)\n759 \n760     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n761         pass\n762 \n763     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n764         pass\n765 \n766     def describe(self):\n767         return \"Change managers on %s\" % self.name\n768 \n769     @property\n770     def migration_name_fragment(self):\n771         return \"alter_%s_managers\" % self.name_lower\n772 \n773 \n774 class IndexOperation(Operation):\n775     option_name = \"indexes\"\n776 \n777     @cached_property\n778     def model_name_lower(self):\n779         return self.model_name.lower()\n780 \n781 \n782 class AddIndex(IndexOperation):\n783     \"\"\"Add an index on a model.\"\"\"\n784 \n785     def __init__(self, model_name, index):\n786         self.model_name = model_name\n787         if not index.name:\n788             raise ValueError(\n789                 \"Indexes passed to AddIndex operations require a name \"\n790                 \"argument. %r doesn't have one.\" % index\n791             )\n792         self.index = index\n793 \n794     def state_forwards(self, app_label, state):\n795         state.add_index(app_label, self.model_name_lower, self.index)\n796 \n797     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n798         model = to_state.apps.get_model(app_label, self.model_name)\n799         if self.allow_migrate_model(schema_editor.connection.alias, model):\n800             schema_editor.add_index(model, self.index)\n801 \n802     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n803         model = from_state.apps.get_model(app_label, self.model_name)\n804         if self.allow_migrate_model(schema_editor.connection.alias, model):\n805             schema_editor.remove_index(model, self.index)\n806 \n807     def deconstruct(self):\n808         kwargs = {\n809             \"model_name\": self.model_name,\n810             \"index\": self.index,\n811         }\n812         return (\n813             self.__class__.__qualname__,\n814             [],\n815             kwargs,\n816         )\n817 \n818     def describe(self):\n819         if self.index.expressions:\n820             return \"Create index %s on %s on model %s\" % (\n821                 self.index.name,\n822                 \", \".join([str(expression) for expression in self.index.expressions]),\n823                 self.model_name,\n824             )\n825         return \"Create index %s on field(s) %s of model %s\" % (\n826             self.index.name,\n827             \", \".join(self.index.fields),\n828             self.model_name,\n829         )\n830 \n831     @property\n832     def migration_name_fragment(self):\n833         return \"%s_%s\" % (self.model_name_lower, self.index.name.lower())\n834 \n835 \n836 class RemoveIndex(IndexOperation):\n837     \"\"\"Remove an index from a model.\"\"\"\n838 \n839     def __init__(self, model_name, name):\n840         self.model_name = model_name\n841         self.name = name\n842 \n843     def state_forwards(self, app_label, state):\n844         state.remove_index(app_label, self.model_name_lower, self.name)\n845 \n846     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n847         model = from_state.apps.get_model(app_label, self.model_name)\n848         if self.allow_migrate_model(schema_editor.connection.alias, model):\n849             from_model_state = from_state.models[app_label, self.model_name_lower]\n850             index = from_model_state.get_index_by_name(self.name)\n851             schema_editor.remove_index(model, index)\n852 \n853     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n854         model = to_state.apps.get_model(app_label, self.model_name)\n855         if self.allow_migrate_model(schema_editor.connection.alias, model):\n856             to_model_state = to_state.models[app_label, self.model_name_lower]\n857             index = to_model_state.get_index_by_name(self.name)\n858             schema_editor.add_index(model, index)\n859 \n860     def deconstruct(self):\n861         kwargs = {\n862             \"model_name\": self.model_name,\n863             \"name\": self.name,\n864         }\n865         return (\n866             self.__class__.__qualname__,\n867             [],\n868             kwargs,\n869         )\n870 \n871     def describe(self):\n872         return \"Remove index %s from %s\" % (self.name, self.model_name)\n873 \n874     @property\n875     def migration_name_fragment(self):\n876         return \"remove_%s_%s\" % (self.model_name_lower, self.name.lower())\n877 \n878 \n879 class AddConstraint(IndexOperation):\n880     option_name = \"constraints\"\n881 \n882     def __init__(self, model_name, constraint):\n883         self.model_name = model_name\n884         self.constraint = constraint\n885 \n886     def state_forwards(self, app_label, state):\n887         state.add_constraint(app_label, self.model_name_lower, self.constraint)\n888 \n889     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n890         model = to_state.apps.get_model(app_label, self.model_name)\n891         if self.allow_migrate_model(schema_editor.connection.alias, model):\n892             schema_editor.add_constraint(model, self.constraint)\n893 \n894     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n895         model = to_state.apps.get_model(app_label, self.model_name)\n896         if self.allow_migrate_model(schema_editor.connection.alias, model):\n897             schema_editor.remove_constraint(model, self.constraint)\n898 \n899     def deconstruct(self):\n900         return (\n901             self.__class__.__name__,\n902             [],\n903             {\n904                 \"model_name\": self.model_name,\n905                 \"constraint\": self.constraint,\n906             },\n907         )\n908 \n909     def describe(self):\n910         return \"Create constraint %s on model %s\" % (\n911             self.constraint.name,\n912             self.model_name,\n913         )\n914 \n915     @property\n916     def migration_name_fragment(self):\n917         return \"%s_%s\" % (self.model_name_lower, self.constraint.name.lower())\n918 \n919 \n920 class RemoveConstraint(IndexOperation):\n921     option_name = \"constraints\"\n922 \n923     def __init__(self, model_name, name):\n924         self.model_name = model_name\n925         self.name = name\n926 \n927     def state_forwards(self, app_label, state):\n928         state.remove_constraint(app_label, self.model_name_lower, self.name)\n929 \n930     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n931         model = to_state.apps.get_model(app_label, self.model_name)\n932         if self.allow_migrate_model(schema_editor.connection.alias, model):\n933             from_model_state = from_state.models[app_label, self.model_name_lower]\n934             constraint = from_model_state.get_constraint_by_name(self.name)\n935             schema_editor.remove_constraint(model, constraint)\n936 \n937     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n938         model = to_state.apps.get_model(app_label, self.model_name)\n939         if self.allow_migrate_model(schema_editor.connection.alias, model):\n940             to_model_state = to_state.models[app_label, self.model_name_lower]\n941             constraint = to_model_state.get_constraint_by_name(self.name)\n942             schema_editor.add_constraint(model, constraint)\n943 \n944     def deconstruct(self):\n945         return (\n946             self.__class__.__name__,\n947             [],\n948             {\n949                 \"model_name\": self.model_name,\n950                 \"name\": self.name,\n951             },\n952         )\n953 \n954     def describe(self):\n955         return \"Remove constraint %s from model %s\" % (self.name, self.model_name)\n956 \n957     @property\n958     def migration_name_fragment(self):\n959         return \"remove_%s_%s\" % (self.model_name_lower, self.name.lower())\n",
        "intended_behavior": "Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key."
    },
    {
        "rel_file_path": "django/db/migrations/state.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/migrations/state.py",
        "start": 1,
        "end": 963,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 from collections import defaultdict\n3 from contextlib import contextmanager\n4 from functools import partial\n5 \n6 from django.apps import AppConfig\n7 from django.apps.registry import Apps\n8 from django.apps.registry import apps as global_apps\n9 from django.conf import settings\n10 from django.core.exceptions import FieldDoesNotExist\n11 from django.db import models\n12 from django.db.migrations.utils import field_is_referenced, get_references\n13 from django.db.models import NOT_PROVIDED\n14 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n15 from django.db.models.options import DEFAULT_NAMES, normalize_together\n16 from django.db.models.utils import make_model_tuple\n17 from django.utils.functional import cached_property\n18 from django.utils.module_loading import import_string\n19 from django.utils.version import get_docs_version\n20 \n21 from .exceptions import InvalidBasesError\n22 from .utils import resolve_relation\n23 \n24 \n25 def _get_app_label_and_model_name(model, app_label=\"\"):\n26     if isinstance(model, str):\n27         split = model.split(\".\", 1)\n28         return tuple(split) if len(split) == 2 else (app_label, split[0])\n29     else:\n30         return model._meta.app_label, model._meta.model_name\n31 \n32 \n33 def _get_related_models(m):\n34     \"\"\"Return all models that have a direct relationship to the given model.\"\"\"\n35     related_models = [\n36         subclass\n37         for subclass in m.__subclasses__()\n38         if issubclass(subclass, models.Model)\n39     ]\n40     related_fields_models = set()\n41     for f in m._meta.get_fields(include_parents=True, include_hidden=True):\n42         if (\n43             f.is_relation\n44             and f.related_model is not None\n45             and not isinstance(f.related_model, str)\n46         ):\n47             related_fields_models.add(f.model)\n48             related_models.append(f.related_model)\n49     # Reverse accessors of foreign keys to proxy models are attached to their\n50     # concrete proxied model.\n51     opts = m._meta\n52     if opts.proxy and m in related_fields_models:\n53         related_models.append(opts.concrete_model)\n54     return related_models\n55 \n56 \n57 def get_related_models_tuples(model):\n58     \"\"\"\n59     Return a list of typical (app_label, model_name) tuples for all related\n60     models for the given model.\n61     \"\"\"\n62     return {\n63         (rel_mod._meta.app_label, rel_mod._meta.model_name)\n64         for rel_mod in _get_related_models(model)\n65     }\n66 \n67 \n68 def get_related_models_recursive(model):\n69     \"\"\"\n70     Return all models that have a direct or indirect relationship\n71     to the given model.\n72 \n73     Relationships are either defined by explicit relational fields, like\n74     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another\n75     model (a superclass is related to its subclasses, but not vice versa). Note,\n76     however, that a model inheriting from a concrete model is also related to\n77     its superclass through the implicit *_ptr OneToOneField on the subclass.\n78     \"\"\"\n79     seen = set()\n80     queue = _get_related_models(model)\n81     for rel_mod in queue:\n82         rel_app_label, rel_model_name = (\n83             rel_mod._meta.app_label,\n84             rel_mod._meta.model_name,\n85         )\n86         if (rel_app_label, rel_model_name) in seen:\n87             continue\n88         seen.add((rel_app_label, rel_model_name))\n89         queue.extend(_get_related_models(rel_mod))\n90     return seen - {(model._meta.app_label, model._meta.model_name)}\n91 \n92 \n93 class ProjectState:\n94     \"\"\"\n95     Represent the entire project's overall state. This is the item that is\n96     passed around - do it here rather than at the app level so that cross-app\n97     FKs/etc. resolve properly.\n98     \"\"\"\n99 \n100     def __init__(self, models=None, real_apps=None):\n101         self.models = models or {}\n102         # Apps to include from main registry, usually unmigrated ones\n103         if real_apps is None:\n104             real_apps = set()\n105         else:\n106             assert isinstance(real_apps, set)\n107         self.real_apps = real_apps\n108         self.is_delayed = False\n109         # {remote_model_key: {model_key: {field_name: field}}}\n110         self._relations = None\n111 \n112     @property\n113     def relations(self):\n114         if self._relations is None:\n115             self.resolve_fields_and_relations()\n116         return self._relations\n117 \n118     def add_model(self, model_state):\n119         model_key = model_state.app_label, model_state.name_lower\n120         self.models[model_key] = model_state\n121         if self._relations is not None:\n122             self.resolve_model_relations(model_key)\n123         if \"apps\" in self.__dict__:  # hasattr would cache the property\n124             self.reload_model(*model_key)\n125 \n126     def remove_model(self, app_label, model_name):\n127         model_key = app_label, model_name\n128         del self.models[model_key]\n129         if self._relations is not None:\n130             self._relations.pop(model_key, None)\n131             # Call list() since _relations can change size during iteration.\n132             for related_model_key, model_relations in list(self._relations.items()):\n133                 model_relations.pop(model_key, None)\n134                 if not model_relations:\n135                     del self._relations[related_model_key]\n136         if \"apps\" in self.__dict__:  # hasattr would cache the property\n137             self.apps.unregister_model(*model_key)\n138             # Need to do this explicitly since unregister_model() doesn't clear\n139             # the cache automatically (#24513)\n140             self.apps.clear_cache()\n141 \n142     def rename_model(self, app_label, old_name, new_name):\n143         # Add a new model.\n144         old_name_lower = old_name.lower()\n145         new_name_lower = new_name.lower()\n146         renamed_model = self.models[app_label, old_name_lower].clone()\n147         renamed_model.name = new_name\n148         self.models[app_label, new_name_lower] = renamed_model\n149         # Repoint all fields pointing to the old model to the new one.\n150         old_model_tuple = (app_label, old_name_lower)\n151         new_remote_model = f\"{app_label}.{new_name}\"\n152         to_reload = set()\n153         for model_state, name, field, reference in get_references(\n154             self, old_model_tuple\n155         ):\n156             changed_field = None\n157             if reference.to:\n158                 changed_field = field.clone()\n159                 changed_field.remote_field.model = new_remote_model\n160             if reference.through:\n161                 if changed_field is None:\n162                     changed_field = field.clone()\n163                 changed_field.remote_field.through = new_remote_model\n164             if changed_field:\n165                 model_state.fields[name] = changed_field\n166                 to_reload.add((model_state.app_label, model_state.name_lower))\n167         if self._relations is not None:\n168             old_name_key = app_label, old_name_lower\n169             new_name_key = app_label, new_name_lower\n170             if old_name_key in self._relations:\n171                 self._relations[new_name_key] = self._relations.pop(old_name_key)\n172             for model_relations in self._relations.values():\n173                 if old_name_key in model_relations:\n174                     model_relations[new_name_key] = model_relations.pop(old_name_key)\n175         # Reload models related to old model before removing the old model.\n176         self.reload_models(to_reload, delay=True)\n177         # Remove the old model.\n178         self.remove_model(app_label, old_name_lower)\n179         self.reload_model(app_label, new_name_lower, delay=True)\n180 \n181     def alter_model_options(self, app_label, model_name, options, option_keys=None):\n182         model_state = self.models[app_label, model_name]\n183         model_state.options = {**model_state.options, **options}\n184         if option_keys:\n185             for key in option_keys:\n186                 if key not in options:\n187                     model_state.options.pop(key, False)\n188         self.reload_model(app_label, model_name, delay=True)\n189 \n190     def alter_model_managers(self, app_label, model_name, managers):\n191         model_state = self.models[app_label, model_name]\n192         model_state.managers = list(managers)\n193         self.reload_model(app_label, model_name, delay=True)\n194 \n195     def _append_option(self, app_label, model_name, option_name, obj):\n196         model_state = self.models[app_label, model_name]\n197         model_state.options[option_name] = [*model_state.options[option_name], obj]\n198         self.reload_model(app_label, model_name, delay=True)\n199 \n200     def _remove_option(self, app_label, model_name, option_name, obj_name):\n201         model_state = self.models[app_label, model_name]\n202         objs = model_state.options[option_name]\n203         model_state.options[option_name] = [obj for obj in objs if obj.name != obj_name]\n204         self.reload_model(app_label, model_name, delay=True)\n205 \n206     def add_index(self, app_label, model_name, index):\n207         self._append_option(app_label, model_name, \"indexes\", index)\n208 \n209     def remove_index(self, app_label, model_name, index_name):\n210         self._remove_option(app_label, model_name, \"indexes\", index_name)\n211 \n212     def add_constraint(self, app_label, model_name, constraint):\n213         self._append_option(app_label, model_name, \"constraints\", constraint)\n214 \n215     def remove_constraint(self, app_label, model_name, constraint_name):\n216         self._remove_option(app_label, model_name, \"constraints\", constraint_name)\n217 \n218     def add_field(self, app_label, model_name, name, field, preserve_default):\n219         # If preserve default is off, don't use the default for future state.\n220         if not preserve_default:\n221             field = field.clone()\n222             field.default = NOT_PROVIDED\n223         else:\n224             field = field\n225         model_key = app_label, model_name\n226         self.models[model_key].fields[name] = field\n227         if self._relations is not None:\n228             self.resolve_model_field_relations(model_key, name, field)\n229         # Delay rendering of relationships if it's not a relational field.\n230         delay = not field.is_relation\n231         self.reload_model(*model_key, delay=delay)\n232 \n233     def remove_field(self, app_label, model_name, name):\n234         model_key = app_label, model_name\n235         model_state = self.models[model_key]\n236         old_field = model_state.fields.pop(name)\n237         if self._relations is not None:\n238             self.resolve_model_field_relations(model_key, name, old_field)\n239         # Delay rendering of relationships if it's not a relational field.\n240         delay = not old_field.is_relation\n241         self.reload_model(*model_key, delay=delay)\n242 \n243     def alter_field(self, app_label, model_name, name, field, preserve_default):\n244         if not preserve_default:\n245             field = field.clone()\n246             field.default = NOT_PROVIDED\n247         else:\n248             field = field\n249         model_key = app_label, model_name\n250         fields = self.models[model_key].fields\n251         if self._relations is not None:\n252             old_field = fields.pop(name)\n253             if old_field.is_relation:\n254                 self.resolve_model_field_relations(model_key, name, old_field)\n255             fields[name] = field\n256             if field.is_relation:\n257                 self.resolve_model_field_relations(model_key, name, field)\n258         else:\n259             fields[name] = field\n260         # TODO: investigate if old relational fields must be reloaded or if\n261         # it's sufficient if the new field is (#27737).\n262         # Delay rendering of relationships if it's not a relational field and\n263         # not referenced by a foreign key.\n264         delay = not field.is_relation and not field_is_referenced(\n265             self, model_key, (name, field)\n266         )\n267         self.reload_model(*model_key, delay=delay)\n268 \n269     def rename_field(self, app_label, model_name, old_name, new_name):\n270         model_key = app_label, model_name\n271         model_state = self.models[model_key]\n272         # Rename the field.\n273         fields = model_state.fields\n274         try:\n275             found = fields.pop(old_name)\n276         except KeyError:\n277             raise FieldDoesNotExist(\n278                 f\"{app_label}.{model_name} has no field named '{old_name}'\"\n279             )\n280         fields[new_name] = found\n281         for field in fields.values():\n282             # Fix from_fields to refer to the new field.\n283             from_fields = getattr(field, \"from_fields\", None)\n284             if from_fields:\n285                 field.from_fields = tuple(\n286                     [\n287                         new_name if from_field_name == old_name else from_field_name\n288                         for from_field_name in from_fields\n289                     ]\n290                 )\n291         # Fix index/unique_together to refer to the new field.\n292         options = model_state.options\n293         for option in (\"index_together\", \"unique_together\"):\n294             if option in options:\n295                 options[option] = [\n296                     [new_name if n == old_name else n for n in together]\n297                     for together in options[option]\n298                 ]\n299         # Fix to_fields to refer to the new field.\n300         delay = True\n301         references = get_references(self, model_key, (old_name, found))\n302         for *_, field, reference in references:\n303             delay = False\n304             if reference.to:\n305                 remote_field, to_fields = reference.to\n306                 if getattr(remote_field, \"field_name\", None) == old_name:\n307                     remote_field.field_name = new_name\n308                 if to_fields:\n309                     field.to_fields = tuple(\n310                         [\n311                             new_name if to_field_name == old_name else to_field_name\n312                             for to_field_name in to_fields\n313                         ]\n314                     )\n315         if self._relations is not None:\n316             old_name_lower = old_name.lower()\n317             new_name_lower = new_name.lower()\n318             for to_model in self._relations.values():\n319                 if old_name_lower in to_model[model_key]:\n320                     field = to_model[model_key].pop(old_name_lower)\n321                     field.name = new_name_lower\n322                     to_model[model_key][new_name_lower] = field\n323         self.reload_model(*model_key, delay=delay)\n324 \n325     def _find_reload_model(self, app_label, model_name, delay=False):\n326         if delay:\n327             self.is_delayed = True\n328 \n329         related_models = set()\n330 \n331         try:\n332             old_model = self.apps.get_model(app_label, model_name)\n333         except LookupError:\n334             pass\n335         else:\n336             # Get all relations to and from the old model before reloading,\n337             # as _meta.apps may change\n338             if delay:\n339                 related_models = get_related_models_tuples(old_model)\n340             else:\n341                 related_models = get_related_models_recursive(old_model)\n342 \n343         # Get all outgoing references from the model to be rendered\n344         model_state = self.models[(app_label, model_name)]\n345         # Directly related models are the models pointed to by ForeignKeys,\n346         # OneToOneFields, and ManyToManyFields.\n347         direct_related_models = set()\n348         for field in model_state.fields.values():\n349             if field.is_relation:\n350                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:\n351                     continue\n352                 rel_app_label, rel_model_name = _get_app_label_and_model_name(\n353                     field.related_model, app_label\n354                 )\n355                 direct_related_models.add((rel_app_label, rel_model_name.lower()))\n356 \n357         # For all direct related models recursively get all related models.\n358         related_models.update(direct_related_models)\n359         for rel_app_label, rel_model_name in direct_related_models:\n360             try:\n361                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)\n362             except LookupError:\n363                 pass\n364             else:\n365                 if delay:\n366                     related_models.update(get_related_models_tuples(rel_model))\n367                 else:\n368                     related_models.update(get_related_models_recursive(rel_model))\n369 \n370         # Include the model itself\n371         related_models.add((app_label, model_name))\n372 \n373         return related_models\n374 \n375     def reload_model(self, app_label, model_name, delay=False):\n376         if \"apps\" in self.__dict__:  # hasattr would cache the property\n377             related_models = self._find_reload_model(app_label, model_name, delay)\n378             self._reload(related_models)\n379 \n380     def reload_models(self, models, delay=True):\n381         if \"apps\" in self.__dict__:  # hasattr would cache the property\n382             related_models = set()\n383             for app_label, model_name in models:\n384                 related_models.update(\n385                     self._find_reload_model(app_label, model_name, delay)\n386                 )\n387             self._reload(related_models)\n388 \n389     def _reload(self, related_models):\n390         # Unregister all related models\n391         with self.apps.bulk_update():\n392             for rel_app_label, rel_model_name in related_models:\n393                 self.apps.unregister_model(rel_app_label, rel_model_name)\n394 \n395         states_to_be_rendered = []\n396         # Gather all models states of those models that will be rerendered.\n397         # This includes:\n398         # 1. All related models of unmigrated apps\n399         for model_state in self.apps.real_models:\n400             if (model_state.app_label, model_state.name_lower) in related_models:\n401                 states_to_be_rendered.append(model_state)\n402 \n403         # 2. All related models of migrated apps\n404         for rel_app_label, rel_model_name in related_models:\n405             try:\n406                 model_state = self.models[rel_app_label, rel_model_name]\n407             except KeyError:\n408                 pass\n409             else:\n410                 states_to_be_rendered.append(model_state)\n411 \n412         # Render all models\n413         self.apps.render_multiple(states_to_be_rendered)\n414 \n415     def update_model_field_relation(\n416         self,\n417         model,\n418         model_key,\n419         field_name,\n420         field,\n421         concretes,\n422     ):\n423         remote_model_key = resolve_relation(model, *model_key)\n424         if remote_model_key[0] not in self.real_apps and remote_model_key in concretes:\n425             remote_model_key = concretes[remote_model_key]\n426         relations_to_remote_model = self._relations[remote_model_key]\n427         if field_name in self.models[model_key].fields:\n428             # The assert holds because it's a new relation, or an altered\n429             # relation, in which case references have been removed by\n430             # alter_field().\n431             assert field_name not in relations_to_remote_model[model_key]\n432             relations_to_remote_model[model_key][field_name] = field\n433         else:\n434             del relations_to_remote_model[model_key][field_name]\n435             if not relations_to_remote_model[model_key]:\n436                 del relations_to_remote_model[model_key]\n437 \n438     def resolve_model_field_relations(\n439         self,\n440         model_key,\n441         field_name,\n442         field,\n443         concretes=None,\n444     ):\n445         remote_field = field.remote_field\n446         if not remote_field:\n447             return\n448         if concretes is None:\n449             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()\n450 \n451         self.update_model_field_relation(\n452             remote_field.model,\n453             model_key,\n454             field_name,\n455             field,\n456             concretes,\n457         )\n458 \n459         through = getattr(remote_field, \"through\", None)\n460         if not through:\n461             return\n462         self.update_model_field_relation(\n463             through, model_key, field_name, field, concretes\n464         )\n465 \n466     def resolve_model_relations(self, model_key, concretes=None):\n467         if concretes is None:\n468             concretes, _ = self._get_concrete_models_mapping_and_proxy_models()\n469 \n470         model_state = self.models[model_key]\n471         for field_name, field in model_state.fields.items():\n472             self.resolve_model_field_relations(model_key, field_name, field, concretes)\n473 \n474     def resolve_fields_and_relations(self):\n475         # Resolve fields.\n476         for model_state in self.models.values():\n477             for field_name, field in model_state.fields.items():\n478                 field.name = field_name\n479         # Resolve relations.\n480         # {remote_model_key: {model_key: {field_name: field}}}\n481         self._relations = defaultdict(partial(defaultdict, dict))\n482         concretes, proxies = self._get_concrete_models_mapping_and_proxy_models()\n483 \n484         for model_key in concretes:\n485             self.resolve_model_relations(model_key, concretes)\n486 \n487         for model_key in proxies:\n488             self._relations[model_key] = self._relations[concretes[model_key]]\n489 \n490     def get_concrete_model_key(self, model):\n491         (\n492             concrete_models_mapping,\n493             _,\n494         ) = self._get_concrete_models_mapping_and_proxy_models()\n495         model_key = make_model_tuple(model)\n496         return concrete_models_mapping[model_key]\n497 \n498     def _get_concrete_models_mapping_and_proxy_models(self):\n499         concrete_models_mapping = {}\n500         proxy_models = {}\n501         # Split models to proxy and concrete models.\n502         for model_key, model_state in self.models.items():\n503             if model_state.options.get(\"proxy\"):\n504                 proxy_models[model_key] = model_state\n505                 # Find a concrete model for the proxy.\n506                 concrete_models_mapping[\n507                     model_key\n508                 ] = self._find_concrete_model_from_proxy(\n509                     proxy_models,\n510                     model_state,\n511                 )\n512             else:\n513                 concrete_models_mapping[model_key] = model_key\n514         return concrete_models_mapping, proxy_models\n515 \n516     def _find_concrete_model_from_proxy(self, proxy_models, model_state):\n517         for base in model_state.bases:\n518             if not (isinstance(base, str) or issubclass(base, models.Model)):\n519                 continue\n520             base_key = make_model_tuple(base)\n521             base_state = proxy_models.get(base_key)\n522             if not base_state:\n523                 # Concrete model found, stop looking at bases.\n524                 return base_key\n525             return self._find_concrete_model_from_proxy(proxy_models, base_state)\n526 \n527     def clone(self):\n528         \"\"\"Return an exact copy of this ProjectState.\"\"\"\n529         new_state = ProjectState(\n530             models={k: v.clone() for k, v in self.models.items()},\n531             real_apps=self.real_apps,\n532         )\n533         if \"apps\" in self.__dict__:\n534             new_state.apps = self.apps.clone()\n535         new_state.is_delayed = self.is_delayed\n536         return new_state\n537 \n538     def clear_delayed_apps_cache(self):\n539         if self.is_delayed and \"apps\" in self.__dict__:\n540             del self.__dict__[\"apps\"]\n541 \n542     @cached_property\n543     def apps(self):\n544         return StateApps(self.real_apps, self.models)\n545 \n546     @classmethod\n547     def from_apps(cls, apps):\n548         \"\"\"Take an Apps and return a ProjectState matching it.\"\"\"\n549         app_models = {}\n550         for model in apps.get_models(include_swapped=True):\n551             model_state = ModelState.from_model(model)\n552             app_models[(model_state.app_label, model_state.name_lower)] = model_state\n553         return cls(app_models)\n554 \n555     def __eq__(self, other):\n556         return self.models == other.models and self.real_apps == other.real_apps\n557 \n558 \n559 class AppConfigStub(AppConfig):\n560     \"\"\"Stub of an AppConfig. Only provides a label and a dict of models.\"\"\"\n561 \n562     def __init__(self, label):\n563         self.apps = None\n564         self.models = {}\n565         # App-label and app-name are not the same thing, so technically passing\n566         # in the label here is wrong. In practice, migrations don't care about\n567         # the app name, but we need something unique, and the label works fine.\n568         self.label = label\n569         self.name = label\n570 \n571     def import_models(self):\n572         self.models = self.apps.all_models[self.label]\n573 \n574 \n575 class StateApps(Apps):\n576     \"\"\"\n577     Subclass of the global Apps registry class to better handle dynamic model\n578     additions and removals.\n579     \"\"\"\n580 \n581     def __init__(self, real_apps, models, ignore_swappable=False):\n582         # Any apps in self.real_apps should have all their models included\n583         # in the render. We don't use the original model instances as there\n584         # are some variables that refer to the Apps object.\n585         # FKs/M2Ms from real apps are also not included as they just\n586         # mess things up with partial states (due to lack of dependencies)\n587         self.real_models = []\n588         for app_label in real_apps:\n589             app = global_apps.get_app_config(app_label)\n590             for model in app.get_models():\n591                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))\n592         # Populate the app registry with a stub for each application.\n593         app_labels = {model_state.app_label for model_state in models.values()}\n594         app_configs = [\n595             AppConfigStub(label) for label in sorted([*real_apps, *app_labels])\n596         ]\n597         super().__init__(app_configs)\n598 \n599         # These locks get in the way of copying as implemented in clone(),\n600         # which is called whenever Django duplicates a StateApps before\n601         # updating it.\n602         self._lock = None\n603         self.ready_event = None\n604 \n605         self.render_multiple([*models.values(), *self.real_models])\n606 \n607         # There shouldn't be any operations pending at this point.\n608         from django.core.checks.model_checks import _check_lazy_references\n609 \n610         ignore = (\n611             {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()\n612         )\n613         errors = _check_lazy_references(self, ignore=ignore)\n614         if errors:\n615             raise ValueError(\"\\n\".join(error.msg for error in errors))\n616 \n617     @contextmanager\n618     def bulk_update(self):\n619         # Avoid clearing each model's cache for each change. Instead, clear\n620         # all caches when we're finished updating the model instances.\n621         ready = self.ready\n622         self.ready = False\n623         try:\n624             yield\n625         finally:\n626             self.ready = ready\n627             self.clear_cache()\n628 \n629     def render_multiple(self, model_states):\n630         # We keep trying to render the models in a loop, ignoring invalid\n631         # base errors, until the size of the unrendered models doesn't\n632         # decrease by at least one, meaning there's a base dependency loop/\n633         # missing base.\n634         if not model_states:\n635             return\n636         # Prevent that all model caches are expired for each render.\n637         with self.bulk_update():\n638             unrendered_models = model_states\n639             while unrendered_models:\n640                 new_unrendered_models = []\n641                 for model in unrendered_models:\n642                     try:\n643                         model.render(self)\n644                     except InvalidBasesError:\n645                         new_unrendered_models.append(model)\n646                 if len(new_unrendered_models) == len(unrendered_models):\n647                     raise InvalidBasesError(\n648                         \"Cannot resolve bases for %r\\nThis can happen if you are \"\n649                         \"inheriting models from an app with migrations (e.g. \"\n650                         \"contrib.auth)\\n in an app with no migrations; see \"\n651                         \"https://docs.djangoproject.com/en/%s/topics/migrations/\"\n652                         \"#dependencies for more\"\n653                         % (new_unrendered_models, get_docs_version())\n654                     )\n655                 unrendered_models = new_unrendered_models\n656 \n657     def clone(self):\n658         \"\"\"Return a clone of this registry.\"\"\"\n659         clone = StateApps([], {})\n660         clone.all_models = copy.deepcopy(self.all_models)\n661         clone.app_configs = copy.deepcopy(self.app_configs)\n662         # Set the pointer to the correct app registry.\n663         for app_config in clone.app_configs.values():\n664             app_config.apps = clone\n665         # No need to actually clone them, they'll never change\n666         clone.real_models = self.real_models\n667         return clone\n668 \n669     def register_model(self, app_label, model):\n670         self.all_models[app_label][model._meta.model_name] = model\n671         if app_label not in self.app_configs:\n672             self.app_configs[app_label] = AppConfigStub(app_label)\n673             self.app_configs[app_label].apps = self\n674         self.app_configs[app_label].models[model._meta.model_name] = model\n675         self.do_pending_operations(model)\n676         self.clear_cache()\n677 \n678     def unregister_model(self, app_label, model_name):\n679         try:\n680             del self.all_models[app_label][model_name]\n681             del self.app_configs[app_label].models[model_name]\n682         except KeyError:\n683             pass\n684 \n685 \n686 class ModelState:\n687     \"\"\"\n688     Represent a Django Model. Don't use the actual Model class as it's not\n689     designed to have its options changed - instead, mutate this one and then\n690     render it into a Model as required.\n691 \n692     Note that while you are allowed to mutate .fields, you are not allowed\n693     to mutate the Field instances inside there themselves - you must instead\n694     assign new ones, as these are not detached during a clone.\n695     \"\"\"\n696 \n697     def __init__(\n698         self, app_label, name, fields, options=None, bases=None, managers=None\n699     ):\n700         self.app_label = app_label\n701         self.name = name\n702         self.fields = dict(fields)\n703         self.options = options or {}\n704         self.options.setdefault(\"indexes\", [])\n705         self.options.setdefault(\"constraints\", [])\n706         self.bases = bases or (models.Model,)\n707         self.managers = managers or []\n708         for name, field in self.fields.items():\n709             # Sanity-check that fields are NOT already bound to a model.\n710             if hasattr(field, \"model\"):\n711                 raise ValueError(\n712                     'ModelState.fields cannot be bound to a model - \"%s\" is.' % name\n713                 )\n714             # Sanity-check that relation fields are NOT referring to a model class.\n715             if field.is_relation and hasattr(field.related_model, \"_meta\"):\n716                 raise ValueError(\n717                     'ModelState.fields cannot refer to a model class - \"%s.to\" does. '\n718                     \"Use a string reference instead.\" % name\n719                 )\n720             if field.many_to_many and hasattr(field.remote_field.through, \"_meta\"):\n721                 raise ValueError(\n722                     'ModelState.fields cannot refer to a model class - \"%s.through\" '\n723                     \"does. Use a string reference instead.\" % name\n724                 )\n725         # Sanity-check that indexes have their name set.\n726         for index in self.options[\"indexes\"]:\n727             if not index.name:\n728                 raise ValueError(\n729                     \"Indexes passed to ModelState require a name attribute. \"\n730                     \"%r doesn't have one.\" % index\n731                 )\n732 \n733     @cached_property\n734     def name_lower(self):\n735         return self.name.lower()\n736 \n737     def get_field(self, field_name):\n738         if field_name == \"_order\":\n739             field_name = self.options.get(\"order_with_respect_to\", field_name)\n740         return self.fields[field_name]\n741 \n742     @classmethod\n743     def from_model(cls, model, exclude_rels=False):\n744         \"\"\"Given a model, return a ModelState representing it.\"\"\"\n745         # Deconstruct the fields\n746         fields = []\n747         for field in model._meta.local_fields:\n748             if getattr(field, \"remote_field\", None) and exclude_rels:\n749                 continue\n750             if isinstance(field, models.OrderWrt):\n751                 continue\n752             name = field.name\n753             try:\n754                 fields.append((name, field.clone()))\n755             except TypeError as e:\n756                 raise TypeError(\n757                     \"Couldn't reconstruct field %s on %s: %s\"\n758                     % (\n759                         name,\n760                         model._meta.label,\n761                         e,\n762                     )\n763                 )\n764         if not exclude_rels:\n765             for field in model._meta.local_many_to_many:\n766                 name = field.name\n767                 try:\n768                     fields.append((name, field.clone()))\n769                 except TypeError as e:\n770                     raise TypeError(\n771                         \"Couldn't reconstruct m2m field %s on %s: %s\"\n772                         % (\n773                             name,\n774                             model._meta.object_name,\n775                             e,\n776                         )\n777                     )\n778         # Extract the options\n779         options = {}\n780         for name in DEFAULT_NAMES:\n781             # Ignore some special options\n782             if name in [\"apps\", \"app_label\"]:\n783                 continue\n784             elif name in model._meta.original_attrs:\n785                 if name == \"unique_together\":\n786                     ut = model._meta.original_attrs[\"unique_together\"]\n787                     options[name] = set(normalize_together(ut))\n788                 elif name == \"index_together\":\n789                     it = model._meta.original_attrs[\"index_together\"]\n790                     options[name] = set(normalize_together(it))\n791                 elif name == \"indexes\":\n792                     indexes = [idx.clone() for idx in model._meta.indexes]\n793                     for index in indexes:\n794                         if not index.name:\n795                             index.set_name_with_model(model)\n796                     options[\"indexes\"] = indexes\n797                 elif name == \"constraints\":\n798                     options[\"constraints\"] = [\n799                         con.clone() for con in model._meta.constraints\n800                     ]\n801                 else:\n802                     options[name] = model._meta.original_attrs[name]\n803         # If we're ignoring relationships, remove all field-listing model\n804         # options (that option basically just means \"make a stub model\")\n805         if exclude_rels:\n806             for key in [\"unique_together\", \"index_together\", \"order_with_respect_to\"]:\n807                 if key in options:\n808                     del options[key]\n809         # Private fields are ignored, so remove options that refer to them.\n810         elif options.get(\"order_with_respect_to\") in {\n811             field.name for field in model._meta.private_fields\n812         }:\n813             del options[\"order_with_respect_to\"]\n814 \n815         def flatten_bases(model):\n816             bases = []\n817             for base in model.__bases__:\n818                 if hasattr(base, \"_meta\") and base._meta.abstract:\n819                     bases.extend(flatten_bases(base))\n820                 else:\n821                     bases.append(base)\n822             return bases\n823 \n824         # We can't rely on __mro__ directly because we only want to flatten\n825         # abstract models and not the whole tree. However by recursing on\n826         # __bases__ we may end up with duplicates and ordering issues, we\n827         # therefore discard any duplicates and reorder the bases according\n828         # to their index in the MRO.\n829         flattened_bases = sorted(\n830             set(flatten_bases(model)), key=lambda x: model.__mro__.index(x)\n831         )\n832 \n833         # Make our record\n834         bases = tuple(\n835             (base._meta.label_lower if hasattr(base, \"_meta\") else base)\n836             for base in flattened_bases\n837         )\n838         # Ensure at least one base inherits from models.Model\n839         if not any(\n840             (isinstance(base, str) or issubclass(base, models.Model)) for base in bases\n841         ):\n842             bases = (models.Model,)\n843 \n844         managers = []\n845         manager_names = set()\n846         default_manager_shim = None\n847         for manager in model._meta.managers:\n848             if manager.name in manager_names:\n849                 # Skip overridden managers.\n850                 continue\n851             elif manager.use_in_migrations:\n852                 # Copy managers usable in migrations.\n853                 new_manager = copy.copy(manager)\n854                 new_manager._set_creation_counter()\n855             elif manager is model._base_manager or manager is model._default_manager:\n856                 # Shim custom managers used as default and base managers.\n857                 new_manager = models.Manager()\n858                 new_manager.model = manager.model\n859                 new_manager.name = manager.name\n860                 if manager is model._default_manager:\n861                     default_manager_shim = new_manager\n862             else:\n863                 continue\n864             manager_names.add(manager.name)\n865             managers.append((manager.name, new_manager))\n866 \n867         # Ignore a shimmed default manager called objects if it's the only one.\n868         if managers == [(\"objects\", default_manager_shim)]:\n869             managers = []\n870 \n871         # Construct the new ModelState\n872         return cls(\n873             model._meta.app_label,\n874             model._meta.object_name,\n875             fields,\n876             options,\n877             bases,\n878             managers,\n879         )\n880 \n881     def construct_managers(self):\n882         \"\"\"Deep-clone the managers using deconstruction.\"\"\"\n883         # Sort all managers by their creation counter\n884         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)\n885         for mgr_name, manager in sorted_managers:\n886             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()\n887             if as_manager:\n888                 qs_class = import_string(qs_path)\n889                 yield mgr_name, qs_class.as_manager()\n890             else:\n891                 manager_class = import_string(manager_path)\n892                 yield mgr_name, manager_class(*args, **kwargs)\n893 \n894     def clone(self):\n895         \"\"\"Return an exact copy of this ModelState.\"\"\"\n896         return self.__class__(\n897             app_label=self.app_label,\n898             name=self.name,\n899             fields=dict(self.fields),\n900             # Since options are shallow-copied here, operations such as\n901             # AddIndex must replace their option (e.g 'indexes') rather\n902             # than mutating it.\n903             options=dict(self.options),\n904             bases=self.bases,\n905             managers=list(self.managers),\n906         )\n907 \n908     def render(self, apps):\n909         \"\"\"Create a Model object from our current state into the given apps.\"\"\"\n910         # First, make a Meta object\n911         meta_contents = {\"app_label\": self.app_label, \"apps\": apps, **self.options}\n912         meta = type(\"Meta\", (), meta_contents)\n913         # Then, work out our bases\n914         try:\n915             bases = tuple(\n916                 (apps.get_model(base) if isinstance(base, str) else base)\n917                 for base in self.bases\n918             )\n919         except LookupError:\n920             raise InvalidBasesError(\n921                 \"Cannot resolve one or more bases from %r\" % (self.bases,)\n922             )\n923         # Clone fields for the body, add other bits.\n924         body = {name: field.clone() for name, field in self.fields.items()}\n925         body[\"Meta\"] = meta\n926         body[\"__module__\"] = \"__fake__\"\n927 \n928         # Restore managers\n929         body.update(self.construct_managers())\n930         # Then, make a Model object (apps.register_model is called in __new__)\n931         return type(self.name, bases, body)\n932 \n933     def get_index_by_name(self, name):\n934         for index in self.options[\"indexes\"]:\n935             if index.name == name:\n936                 return index\n937         raise ValueError(\"No index named %s on model %s\" % (name, self.name))\n938 \n939     def get_constraint_by_name(self, name):\n940         for constraint in self.options[\"constraints\"]:\n941             if constraint.name == name:\n942                 return constraint\n943         raise ValueError(\"No constraint named %s on model %s\" % (name, self.name))\n944 \n945     def __repr__(self):\n946         return \"<%s: '%s.%s'>\" % (self.__class__.__name__, self.app_label, self.name)\n947 \n948     def __eq__(self, other):\n949         return (\n950             (self.app_label == other.app_label)\n951             and (self.name == other.name)\n952             and (len(self.fields) == len(other.fields))\n953             and all(\n954                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]\n955                 for (k1, f1), (k2, f2) in zip(\n956                     sorted(self.fields.items()),\n957                     sorted(other.fields.items()),\n958                 )\n959             )\n960             and (self.options == other.options)\n961             and (self.bases == other.bases)\n962             and (self.managers == other.managers)\n963         )\n",
        "intended_behavior": "Introduce or modify migration operations to check and enforce collation consistency between foreign keys and their referenced primary keys during migration planning and application. Specifically, when altering field types or creating new foreign key constraints, the migration logic should include steps to apply the `db_collation` of the primary key to the foreign key."
    }
]