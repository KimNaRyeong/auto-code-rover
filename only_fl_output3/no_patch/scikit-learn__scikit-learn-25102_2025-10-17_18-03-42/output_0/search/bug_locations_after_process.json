[
    {
        "rel_file_path": "sklearn/utils/_set_output.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__1.3/sklearn/utils/_set_output.py",
        "start": 168,
        "end": 238,
        "class_name": "_SetOutputMixin",
        "method_name": null,
        "code": "168 class _SetOutputMixin:\n169     \"\"\"Mixin that dynamically wraps methods to return container based on config.\n170 \n171     Currently `_SetOutputMixin` wraps `transform` and `fit_transform` and configures\n172     it based on `set_output` of the global configuration.\n173 \n174     `set_output` is only defined if `get_feature_names_out` is defined and\n175     `auto_wrap_output_keys` is the default value.\n176     \"\"\"\n177 \n178     def __init_subclass__(cls, auto_wrap_output_keys=(\"transform\",), **kwargs):\n179         super().__init_subclass__(**kwargs)\n180 \n181         # Dynamically wraps `transform` and `fit_transform` and configure it's\n182         # output based on `set_output`.\n183         if not (\n184             isinstance(auto_wrap_output_keys, tuple) or auto_wrap_output_keys is None\n185         ):\n186             raise ValueError(\"auto_wrap_output_keys must be None or a tuple of keys.\")\n187 \n188         if auto_wrap_output_keys is None:\n189             cls._sklearn_auto_wrap_output_keys = set()\n190             return\n191 \n192         # Mapping from method to key in configurations\n193         method_to_key = {\n194             \"transform\": \"transform\",\n195             \"fit_transform\": \"transform\",\n196         }\n197         cls._sklearn_auto_wrap_output_keys = set()\n198 \n199         for method, key in method_to_key.items():\n200             if not hasattr(cls, method) or key not in auto_wrap_output_keys:\n201                 continue\n202             cls._sklearn_auto_wrap_output_keys.add(key)\n203 \n204             # Only wrap methods defined by cls itself\n205             if method not in cls.__dict__:\n206                 continue\n207             wrapped_method = _wrap_method_output(getattr(cls, method), key)\n208             setattr(cls, method, wrapped_method)\n209 \n210     @available_if(_auto_wrap_is_configured)\n211     def set_output(self, *, transform=None):\n212         \"\"\"Set output container.\n213 \n214         See :ref:`sphx_glr_auto_examples_miscellaneous_plot_set_output.py`\n215         for an example on how to use the API.\n216 \n217         Parameters\n218         ----------\n219         transform : {\"default\", \"pandas\"}, default=None\n220             Configure output of `transform` and `fit_transform`.\n221 \n222             - `\"default\"`: Default output format of a transformer\n223             - `\"pandas\"`: DataFrame output\n224             - `None`: Transform configuration is unchanged\n225 \n226         Returns\n227         -------\n228         self : estimator instance\n229             Estimator instance.\n230         \"\"\"\n231         if transform is None:\n232             return self\n233 \n234         if not hasattr(self, \"_sklearn_output_config\"):\n235             self._sklearn_output_config = {}\n236 \n237         self._sklearn_output_config[\"transform\"] = transform\n238         return self\n",
        "intended_behavior": "A new method or an enhancement to an existing method within the '_SetOutputMixin' class should be implemented to accept an additional configuration for preserving dtypes of the input DataFrame when converting outputs. This might involve adding a new argument to the class initializer or to specific methods like 'set_output' to allow specifying that dtypes should be preserved. This configuration should then be utilized by other parts of the sklearn framework to maintain the original dtypes in the output DataFrame wherever applicable."
    },
    {
        "rel_file_path": "sklearn/utils/_set_output.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__1.3/sklearn/utils/_set_output.py",
        "start": 10,
        "end": 62,
        "class_name": null,
        "method_name": "_wrap_in_pandas_container",
        "code": "10 def _wrap_in_pandas_container(\n11     data_to_wrap,\n12     *,\n13     columns,\n14     index=None,\n15 ):\n16     \"\"\"Create a Pandas DataFrame.\n17 \n18     If `data_to_wrap` is a DataFrame, then the `columns` and `index` will be changed\n19     inplace. If `data_to_wrap` is a ndarray, then a new DataFrame is created with\n20     `columns` and `index`.\n21 \n22     Parameters\n23     ----------\n24     data_to_wrap : {ndarray, dataframe}\n25         Data to be wrapped as pandas dataframe.\n26 \n27     columns : callable, ndarray, or None\n28         The column names or a callable that returns the column names. The\n29         callable is useful if the column names require some computation.\n30         If `columns` is a callable that raises an error, `columns` will have\n31         the same semantics as `None`. If `None` and `data_to_wrap` is already a\n32         dataframe, then the column names are not changed. If `None` and\n33         `data_to_wrap` is **not** a dataframe, then columns are\n34         `range(n_features)`.\n35 \n36     index : array-like, default=None\n37         Index for data.\n38 \n39     Returns\n40     -------\n41     dataframe : DataFrame\n42         Container with column names or unchanged `output`.\n43     \"\"\"\n44     if issparse(data_to_wrap):\n45         raise ValueError(\"Pandas output does not support sparse data.\")\n46 \n47     if callable(columns):\n48         try:\n49             columns = columns()\n50         except Exception:\n51             columns = None\n52 \n53     pd = check_pandas_support(\"Setting output container to 'pandas'\")\n54 \n55     if isinstance(data_to_wrap, pd.DataFrame):\n56         if columns is not None:\n57             data_to_wrap.columns = columns\n58         if index is not None:\n59             data_to_wrap.index = index\n60         return data_to_wrap\n61 \n62     return pd.DataFrame(data_to_wrap, index=index, columns=columns)\n",
        "intended_behavior": "Modify the '_wrap_in_pandas_container' function to include logic for preserving original dtypes of the input DataFrame. This could involve additional parameter(s) that specify the dtypes to be preserved and applying these dtypes to the output DataFrame before it is returned. The function should ensure that, if dtype preservation is enabled, each column in the output DataFrame maintains the original dtype from the input DataFrame, except where the operation inherently changes the dtype (e.g., operations that result in a change of column contents)."
    },
    {
        "rel_file_path": "sklearn/utils/_set_output.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/scikit-learn__scikit-learn/setup_scikit-learn__scikit-learn__1.3/sklearn/utils/_set_output.py",
        "start": 99,
        "end": 134,
        "class_name": null,
        "method_name": "_wrap_data_with_container",
        "code": "99 def _wrap_data_with_container(method, data_to_wrap, original_input, estimator):\n100     \"\"\"Wrap output with container based on an estimator's or global config.\n101 \n102     Parameters\n103     ----------\n104     method : {\"transform\"}\n105         Estimator's method to get container output for.\n106 \n107     data_to_wrap : {ndarray, dataframe}\n108         Data to wrap with container.\n109 \n110     original_input : {ndarray, dataframe}\n111         Original input of function.\n112 \n113     estimator : estimator instance\n114         Estimator with to get the output configuration from.\n115 \n116     Returns\n117     -------\n118     output : {ndarray, dataframe}\n119         If the output config is \"default\" or the estimator is not configured\n120         for wrapping return `data_to_wrap` unchanged.\n121         If the output config is \"pandas\", return `data_to_wrap` as a pandas\n122         DataFrame.\n123     \"\"\"\n124     output_config = _get_output_config(method, estimator)\n125 \n126     if output_config[\"dense\"] == \"default\" or not _auto_wrap_is_configured(estimator):\n127         return data_to_wrap\n128 \n129     # dense_config == \"pandas\"\n130     return _wrap_in_pandas_container(\n131         data_to_wrap=data_to_wrap,\n132         index=getattr(original_input, \"index\", None),\n133         columns=estimator.get_feature_names_out,\n134     )\n",
        "intended_behavior": "Adjust '_wrap_data_with_container' to pass through dtype information (if available and applicable) to '_wrap_in_pandas_container'. This requires modifying this method to not only decide based on the configuration whether to wrap the data into a DataFrame but also to consider the dtypes of the original input for preservation. If dtype preservation is specified, the method should collect the dtypes of 'original_input' and ensure these are passed to '_wrap_in_pandas_container', enabling it to preserve these dtypes in the final output."
    }
]