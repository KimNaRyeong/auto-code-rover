[
    {
        "rel_file_path": "sphinx/util/i18n.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.3/sphinx/util/i18n.py",
        "start": 62,
        "end": 74,
        "class_name": "CatalogInfo",
        "method_name": "write_mo",
        "code": "62     def write_mo(self, locale: str) -> None:\n63         with open(self.po_path, encoding=self.charset) as file_po:\n64             try:\n65                 po = read_po(file_po, locale)\n66             except Exception as exc:\n67                 logger.warning(__('reading error: %s, %s'), self.po_path, exc)\n68                 return\n69 \n70         with open(self.mo_path, 'wb') as file_mo:\n71             try:\n72                 write_mo(file_mo, po)\n73             except Exception as exc:\n74                 logger.warning(__('writing error: %s, %s'), self.mo_path, exc)\n",
        "intended_behavior": "The purpose of modifying this method is to include an additional parameter that dictates whether fuzzy translations should be incorporated into the `.mo` files. The `write_mo` method will need to be enhanced to accept a `use_fuzzy_translations` boolean flag. This flag will then be utilized to determine if fuzzy translations are to be written into the `.mo` files. This requires a modification to how the `write_mo` function is called and potentially how the Babel library's `write_mo` function is invoked, given it supports handling fuzzy translations. The existing functionality, which excludes fuzzy translations by default, should be preserved if the `use_fuzzy_translations` flag is not set to `True`, ensuring backward compatibility."
    },
    {
        "rel_file_path": "sphinx/util/i18n.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.3/sphinx/util/i18n.py",
        "start": 39,
        "end": 74,
        "class_name": "CatalogInfo",
        "method_name": null,
        "code": "39 class CatalogInfo(LocaleFileInfoBase):\n40 \n41     @property\n42     def po_file(self) -> str:\n43         return self.domain + '.po'\n44 \n45     @property\n46     def mo_file(self) -> str:\n47         return self.domain + '.mo'\n48 \n49     @property\n50     def po_path(self) -> str:\n51         return path.join(self.base_dir, self.po_file)\n52 \n53     @property\n54     def mo_path(self) -> str:\n55         return path.join(self.base_dir, self.mo_file)\n56 \n57     def is_outdated(self) -> bool:\n58         return (\n59             not path.exists(self.mo_path) or\n60             path.getmtime(self.mo_path) < path.getmtime(self.po_path))\n61 \n62     def write_mo(self, locale: str) -> None:\n63         with open(self.po_path, encoding=self.charset) as file_po:\n64             try:\n65                 po = read_po(file_po, locale)\n66             except Exception as exc:\n67                 logger.warning(__('reading error: %s, %s'), self.po_path, exc)\n68                 return\n69 \n70         with open(self.mo_path, 'wb') as file_mo:\n71             try:\n72                 write_mo(file_mo, po)\n73             except Exception as exc:\n74                 logger.warning(__('writing error: %s, %s'), self.mo_path, exc)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]