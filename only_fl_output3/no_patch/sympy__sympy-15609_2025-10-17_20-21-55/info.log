2025-10-17 20:21:55.230 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 20:22:04.311 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=211, output_tokens=12, cost=0.002470
2025-10-17 20:22:12.934 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=391, output_tokens=322, cost=0.013570
2025-10-17 20:22:14.396 | INFO     | registered non reproducing test 0
2025-10-17 20:22:25.349 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=992, output_tokens=530, cost=0.025820
2025-10-17 20:22:26.759 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:22:36.582 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=520, output_tokens=383, cost=0.016690
2025-10-17 20:22:36.589 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:22:38.675 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=737, output_tokens=28, cost=0.008210
2025-10-17 20:22:38.677 | DEBUG    | Extracted a valid json.
2025-10-17 20:22:38.677 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"MatrixSymbol\")", "search_method(\"latex\")"],
    "bug_locations": []
}
2025-10-17 20:22:38.736 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:22:38.737 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:22:57.778 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3973, output_tokens=817, cost=0.064240
2025-10-17 20:22:57.792 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:23:09.359 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5006, output_tokens=349, cost=0.060530
2025-10-17 20:23:09.366 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:23:19.688 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=703, output_tokens=332, cost=0.016990
2025-10-17 20:23:19.690 | DEBUG    | Extracted a valid json.
2025-10-17 20:23:19.695 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LatexPrinter\")",
        "search_method_in_class(\"doprint\", \"LatexPrinter\")"
    ],
    "bug_locations": [
        {
            "file": "sympy/printing/latex.py",
            "class": "",
            "method": "latex",
            "intended_behavior": "The `latex` method needs to be robust in handling matrix expressions, especially when dealing with the products of indexed matrices. The intended behavior here would be to correctly format indexed expressions, ensuring no LaTeX syntax errors like double subscripts are produced. This might involve adding or modifying logic that handles the naming or structuring of subscripts in the LaTeX output to ensure they are unique and adhere to LaTeX syntax rules."
        },
        {
            "file": "sympy/matrices/expressions/matexpr.py",
            "class": "MatrixSymbol",
            "method": "_entry",
            "intended_behavior": "Although `_entry` method is not directly mentioned to be faulty, it's closely tied to how elements of a matrix are accessed, which subsequently affects their representation in LaTeX. The method should ensure that any symbolic representation it contributes to, which will be translated into LaTeX by `latex` or part of the `LatexPrinter` class, is formatted in a way that avoids syntax pitfalls like double subscripts. While `_entry` may not directly handle LaTeX printing, ensuring that it provides unambiguous and correctly structured information for LaTeX conversion could potentially mitigate the issue. This might involve standardizing how indices are represented or flagged for LaTeX formatting."
        }
    ]
}
2025-10-17 20:23:19.777 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:23:19.778 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:23:38.662 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8821, output_tokens=698, cost=0.109150
2025-10-17 20:23:38.676 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:23:48.206 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9735, output_tokens=348, cost=0.107790
2025-10-17 20:23:48.212 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:23:56.856 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=702, output_tokens=308, cost=0.016260
2025-10-17 20:23:56.857 | DEBUG    | Extracted a valid json.
2025-10-17 20:23:56.858 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_MatrixElement",
            "intended_behavior": "This method should ensure that when printing the elements of a matrix (especially when they are part of an indexed operation or product of matrices), the subscript notation is generated in a way that is valid LaTeX syntax. The specific fix here should address the issue of double subscripts by perhaps introducing an intermediate representation or formatting step for subscript expressions to ensure they are unique and do not violate LaTeX syntax rules. The method must preserve the accuracy of mathematical expressions while ensuring the generated LaTeX code is compilable."
        },
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Sum",
            "intended_behavior": "Given that the issue involves a summation representation (\\sum) as part of the matrix product indexing, this method should correctly handle the generation of summation symbols along with their indices in LaTeX format. The _print_Sum method needs to ensure that indices and their bounds are formatted so that they do not result in syntax errors like double subscripts. It may require adjusting how indexed variables are named or displayed in the summation context. The goal is to maintain mathematical integrity and notational clarity while providing LaTeX that renders correctly in all supported environments."
        }
    ]
}
2025-10-17 20:23:56.874 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_MatrixElement</method>
<code>
1439     def _print_MatrixElement(self, expr):
1440         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1441             + '_{%s, %s}' % (expr.i, expr.j)

</code><intended_behavior>This method should ensure that when printing the elements of a matrix (especially when they are part of an indexed operation or product of matrices), the subscript notation is generated in a way that is valid LaTeX syntax. The specific fix here should address the issue of double subscripts by perhaps introducing an intermediate representation or formatting step for subscript expressions to ensure they are unique and do not violate LaTeX syntax rules. The method must preserve the accuracy of mathematical expressions while ensuring the generated LaTeX code is compilable.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": None,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137         "ln_notation": False,
138     }
139 
140     def __init__(self, settings=None):
141         Printer.__init__(self, settings)
142 
143         if 'mode' in self._settings:
144             valid_modes = ['inline', 'plain', 'equation',
145                            'equation*']
146             if self._settings['mode'] not in valid_modes:
147                 raise ValueError("'mode' must be one of 'inline', 'plain', "
148                     "'equation' or 'equation*'")
149 
150         if self._settings['fold_short_frac'] is None and \
151                 self._settings['mode'] == 'inline':
152             self._settings['fold_short_frac'] = True
153 
154         mul_symbol_table = {
155             None: r" ",
156             "ldot": r" \,.\, ",
157             "dot": r" \cdot ",
158             "times": r" \times "
159         }
160         try:
161             self._settings['mul_symbol_latex'] = \
162                 mul_symbol_table[self._settings['mul_symbol']]
163         except KeyError:
164             self._settings['mul_symbol_latex'] = \
165                 self._settings['mul_symbol']
166         try:
167             self._settings['mul_symbol_latex_numbers'] = \
168                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
169         except KeyError:
170             if (self._settings['mul_symbol'].strip() in
171                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
172                 self._settings['mul_symbol_latex_numbers'] = \
173                     mul_symbol_table['dot']
174             else:
175                 self._settings['mul_symbol_latex_numbers'] = \
176                     self._settings['mul_symbol']
177 
178         self._delim_dict = {'(': ')', '[': ']'}
179 
180     def parenthesize(self, item, level, strict=False):
181         prec_val = precedence_traditional(item)
182         if (prec_val < level) or ((not strict) and prec_val <= level):
183             return r"\left(%s\right)" % self._print(item)
184         else:
185             return self._print(item)
186 
187     def doprint(self, expr):
188         tex = Printer.doprint(self, expr)
189 
190         if self._settings['mode'] == 'plain':
191             return tex
192         elif self._settings['mode'] == 'inline':
193             return r"$%s$" % tex
194         elif self._settings['itex']:
195             return r"$$%s$$" % tex
196         else:
197             env_str = self._settings['mode']
198             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
199 
200     def _needs_brackets(self, expr):
201         """
202         Returns True if the expression needs to be wrapped in brackets when
203         printed, False otherwise. For example: a + b => True; a => False;
204         10 => False; -10 => True.
205         """
206         return not ((expr.is_Integer and expr.is_nonnegative)
207                     or (expr.is_Atom and (expr is not S.NegativeOne
208                                           and expr.is_Rational is False)))
209 
210     def _needs_function_brackets(self, expr):
211         """
212         Returns True if the expression needs to be wrapped in brackets when
213         passed as an argument to a function, False otherwise. This is a more
214         liberal version of _needs_brackets, in that many expressions which need
215         to be wrapped in brackets when added/subtracted/raised to a power do
216         not need them when passed to a function. Such an example is a*b.
217         """
218         if not self._needs_brackets(expr):
219             return False
220         else:
221             # Muls of the form a*b*c... can be folded
222             if expr.is_Mul and not self._mul_is_clean(expr):
223                 return True
224             # Pows which don't need brackets can be folded
225             elif expr.is_Pow and not self._pow_is_clean(expr):
226                 return True
227             # Add and Function always need brackets
228             elif expr.is_Add or expr.is_Function:
229                 return True
230             else:
231                 return False
232 
233     def _needs_mul_brackets(self, expr, first=False, last=False):
234         """
235         Returns True if the expression needs to be wrapped in brackets when
236         printed as part of a Mul, False otherwise. This is True for Add,
237         but also for some container objects that would not need brackets
238         when appearing last in a Mul, e.g. an Integral. ``last=True``
239         specifies that this expr is the last to appear in a Mul.
240         ``first=True`` specifies that this expr is the first to appear in a Mul.
241         """
242         from sympy import Integral, Piecewise, Product, Sum
243 
244         if expr.is_Mul:
245             if not first and _coeff_isneg(expr):
246                 return True
247         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
248             return True
249         elif expr.is_Relational:
250             return True
251         if expr.is_Piecewise:
252             return True
253         if any([expr.has(x) for x in (Mod,)]):
254             return True
255         if (not last and
256             any([expr.has(x) for x in (Integral, Product, Sum)])):
257             return True
258 
259         return False
260 
261 
262     def _needs_add_brackets(self, expr):
263         """
264         Returns True if the expression needs to be wrapped in brackets when
265         printed as part of an Add, False otherwise.  This is False for most
266         things.
267         """
268         if expr.is_Relational:
269             return True
270         if any([expr.has(x) for x in (Mod,)]):
271             return True
272         if expr.is_Add:
273             return True
274         return False
275 
276 
277     def _mul_is_clean(self, expr):
278         for arg in expr.args:
279             if arg.is_Function:
280                 return False
281         return True
282 
283     def _pow_is_clean(self, expr):
284         return not self._needs_brackets(expr.base)
285 
286     def _do_exponent(self, expr, exp):
287         if exp is not None:
288             return r"\left(%s\right)^{%s}" % (expr, exp)
289         else:
290             return expr
291 
292     def _print_Basic(self, expr):
293         l = [self._print(o) for o in expr.args]
294         return self._deal_with_super_sub(expr.__class__.__name__) + r"\left(%s\right)" % ", ".join(l)
295 
296     def _print_bool(self, e):
297         return r"\mathrm{%s}" % e
298 
299     _print_BooleanTrue = _print_bool
300     _print_BooleanFalse = _print_bool
301 
302     def _print_NoneType(self, e):
303         return r"\mathrm{%s}" % e
304 
305     def _print_Add(self, expr, order=None):
306         if self.order == 'none':
307             terms = list(expr.args)
308         else:
309             terms = self._as_ordered_terms(expr, order=order)
310 
311         tex = ""
312         for i, term in enumerate(terms):
313             if i == 0:
314                 pass
315             elif _coeff_isneg(term):
316                 tex += " - "
317                 term = -term
318             else:
319                 tex += " + "
320             term_tex = self._print(term)
321             if self._needs_add_brackets(term):
322                 term_tex = r"\left(%s\right)" % term_tex
323             tex += term_tex
324 
325         return tex
326 
327     def _print_Cycle(self, expr):
328         from sympy.combinatorics.permutations import Permutation
329         if expr.size == 0:
330             return r"\left( \right)"
331         expr = Permutation(expr)
332         expr_perm = expr.cyclic_form
333         siz = expr.size
334         if expr.array_form[-1] == siz - 1:
335             expr_perm = expr_perm + [[siz - 1]]
336         term_tex = ''
337         for i in expr_perm:
338             term_tex += str(i).replace(',', r"\;")
339         term_tex = term_tex.replace('[', r"\left( ")
340         term_tex = term_tex.replace(']', r"\right)")
341         return term_tex
342 
343     _print_Permutation = _print_Cycle
344 
345     def _print_Float(self, expr):
346         # Based off of that in StrPrinter
347         dps = prec_to_dps(expr._prec)
348         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
349 
350         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
351         # thus we use the number separator
352         separator = self._settings['mul_symbol_latex_numbers']
353 
354         if 'e' in str_real:
355             (mant, exp) = str_real.split('e')
356 
357             if exp[0] == '+':
358                 exp = exp[1:]
359 
360             return r"%s%s10^{%s}" % (mant, separator, exp)
361         elif str_real == "+inf":
362             return r"\infty"
363         elif str_real == "-inf":
364             return r"- \infty"
365         else:
366             return str_real
367 
368     def _print_Cross(self, expr):
369         vec1 = expr._expr1
370         vec2 = expr._expr2
371         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
372                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
373 
374     def _print_Curl(self, expr):
375         vec = expr._expr
376         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
377 
378     def _print_Divergence(self, expr):
379         vec = expr._expr
380         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
381 
382     def _print_Dot(self, expr):
383         vec1 = expr._expr1
384         vec2 = expr._expr2
385         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
386                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
387 
388     def _print_Gradient(self, expr):
389         func = expr._expr
390         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
391 
392     def _print_Mul(self, expr):
393         from sympy.core.power import Pow
394         from sympy.physics.units import Quantity
395         include_parens = False
396         if _coeff_isneg(expr):
397             expr = -expr
398             tex = "- "
399             if expr.is_Add:
400                 tex += "("
401                 include_parens = True
402         else:
403             tex = ""
404 
405         from sympy.simplify import fraction
406         numer, denom = fraction(expr, exact=True)
407         separator = self._settings['mul_symbol_latex']
408         numbersep = self._settings['mul_symbol_latex_numbers']
409 
410         def convert(expr):
411             if not expr.is_Mul:
412                 return str(self._print(expr))
413             else:
414                 _tex = last_term_tex = ""
415 
416                 if self.order not in ('old', 'none'):
417                     args = expr.as_ordered_factors()
418                 else:
419                     args = list(expr.args)
420 
421                 # If quantities are present append them at the back
422                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
423                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
424 
425                 for i, term in enumerate(args):
426                     term_tex = self._print(term)
427 
428                     if self._needs_mul_brackets(term, first=(i == 0),
429                                                 last=(i == len(args) - 1)):
430                         term_tex = r"\left(%s\right)" % term_tex
431 
432                     if _between_two_numbers_p[0].search(last_term_tex) and \
433                             _between_two_numbers_p[1].match(term_tex):
434                         # between two numbers
435                         _tex += numbersep
436                     elif _tex:
437                         _tex += separator
438 
439                     _tex += term_tex
440                     last_term_tex = term_tex
441                 return _tex
442 
443         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
444             # use the original expression here, since fraction() may have
445             # altered it when producing numer and denom
446             tex += convert(expr)
447 
448         else:
449             snumer = convert(numer)
450             sdenom = convert(denom)
451             ldenom = len(sdenom.split())
452             ratio = self._settings['long_frac_ratio']
453             if self._settings['fold_short_frac'] \
454                    and ldenom <= 2 and not "^" in sdenom:
455                 # handle short fractions
456                 if self._needs_mul_brackets(numer, last=False):
457                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
458                 else:
459                     tex += r"%s / %s" % (snumer, sdenom)
460             elif ratio is not None and \
461                     len(snumer.split()) > ratio*ldenom:
462                 # handle long fractions
463                 if self._needs_mul_brackets(numer, last=True):
464                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
465                         % (sdenom, separator, snumer)
466                 elif numer.is_Mul:
467                     # split a long numerator
468                     a = S.One
469                     b = S.One
470                     for x in numer.args:
471                         if self._needs_mul_brackets(x, last=False) or \
472                                 len(convert(a*x).split()) > ratio*ldenom or \
473                                 (b.is_commutative is x.is_commutative is False):
474                             b *= x
475                         else:
476                             a *= x
477                     if self._needs_mul_brackets(b, last=True):
478                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
479                             % (convert(a), sdenom, separator, convert(b))
480                     else:
481                         tex += r"\frac{%s}{%s}%s%s" \
482                             % (convert(a), sdenom, separator, convert(b))
483                 else:
484                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
485             else:
486                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
487 
488         if include_parens:
489             tex += ")"
490         return tex
491 
492     def _print_Pow(self, expr):
493         # Treat x**Rational(1,n) as special case
494         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
495             base = self._print(expr.base)
496             expq = expr.exp.q
497 
498             if expq == 2:
499                 tex = r"\sqrt{%s}" % base
500             elif self._settings['itex']:
501                 tex = r"\root{%d}{%s}" % (expq, base)
502             else:
503                 tex = r"\sqrt[%d]{%s}" % (expq, base)
504 
505             if expr.exp.is_negative:
506                 return r"\frac{1}{%s}" % tex
507             else:
508                 return tex
509         elif self._settings['fold_frac_powers'] \
510             and expr.exp.is_Rational \
511                 and expr.exp.q != 1:
512             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
513             # issue #12886: add parentheses for superscripts raised to powers
514             if '^' in base and expr.base.is_Symbol:
515                 base = r"\left(%s\right)" % base
516             if expr.base.is_Function:
517                 return self._print(expr.base, exp="%s/%s" % (p, q))
518             return r"%s^{%s/%s}" % (base, p, q)
519         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
520             # special case for 1^(-x), issue 9216
521             if expr.base == 1:
522                 return r"%s^{%s}" % (expr.base, expr.exp)
523             # things like 1/x
524             return self._print_Mul(expr)
525         else:
526             if expr.base.is_Function:
527                 return self._print(expr.base, exp=self._print(expr.exp))
528             else:
529                 tex = r"%s^{%s}"
530                 exp = self._print(expr.exp)
531                 # issue #12886: add parentheses around superscripts raised to powers
532                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
533                 if '^' in base and expr.base.is_Symbol:
534                     base = r"\left(%s\right)" % base
535                 elif isinstance(expr.base, Derivative
536                         ) and base.startswith(r'\left('
537                         ) and re.match(r'\\left\(\\d?d?dot', base
538                         ) and base.endswith(r'\right)'):
539                     # don't use parentheses around dotted derivative
540                     base = base[6: -7]  # remove outermost added parens
541 
542                 return tex % (base, exp)
543 
544     def _print_UnevaluatedExpr(self, expr):
545         return self._print(expr.args[0])
546 
547     def _print_Sum(self, expr):
548         if len(expr.limits) == 1:
549             tex = r"\sum_{%s=%s}^{%s} " % \
550                 tuple([ self._print(i) for i in expr.limits[0] ])
551         else:
552             def _format_ineq(l):
553                 return r"%s \leq %s \leq %s" % \
554                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
555 
556             tex = r"\sum_{\substack{%s}} " % \
557                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
558 
559         if isinstance(expr.function, Add):
560             tex += r"\left(%s\right)" % self._print(expr.function)
561         else:
562             tex += self._print(expr.function)
563 
564         return tex
565 
566     def _print_Product(self, expr):
567         if len(expr.limits) == 1:
568             tex = r"\prod_{%s=%s}^{%s} " % \
569                 tuple([ self._print(i) for i in expr.limits[0] ])
570         else:
571             def _format_ineq(l):
572                 return r"%s \leq %s \leq %s" % \
573                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
574 
575             tex = r"\prod_{\substack{%s}} " % \
576                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
577 
578         if isinstance(expr.function, Add):
579             tex += r"\left(%s\right)" % self._print(expr.function)
580         else:
581             tex += self._print(expr.function)
582 
583         return tex
584 
585     def _print_BasisDependent(self, expr):
586         from sympy.vector import Vector
587 
588         o1 = []
589         if expr == expr.zero:
590             return expr.zero._latex_form
591         if isinstance(expr, Vector):
592             items = expr.separate().items()
593         else:
594             items = [(0, expr)]
595 
596         for system, vect in items:
597             inneritems = list(vect.components.items())
598             inneritems.sort(key = lambda x:x[0].__str__())
599             for k, v in inneritems:
600                 if v == 1:
601                     o1.append(' + ' + k._latex_form)
602                 elif v == -1:
603                     o1.append(' - ' + k._latex_form)
604                 else:
605                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
606                     o1.append(' + ' + arg_str + k._latex_form)
607 
608         outstr = (''.join(o1))
609         if outstr[1] != '-':
610             outstr = outstr[3:]
611         else:
612             outstr = outstr[1:]
613         return outstr
614 
615     def _print_Indexed(self, expr):
616         tex_base = self._print(expr.base)
617         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
618             map(self._print, expr.indices))
619         return tex
620 
621     def _print_IndexedBase(self, expr):
622         return self._print(expr.label)
623 
624     def _print_Derivative(self, expr):
625         if requires_partial(expr):
626             diff_symbol = r'\partial'
627         else:
628             diff_symbol = r'd'
629 
630         tex = ""
631         dim = 0
632         for x, num in reversed(expr.variable_count):
633             dim += num
634             if num == 1:
635                 tex += r"%s %s" % (diff_symbol, self._print(x))
636             else:
637                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
638 
639         if dim == 1:
640             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
641         else:
642             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
643 
644         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
645 
646     def _print_Subs(self, subs):
647         expr, old, new = subs.args
648         latex_expr = self._print(expr)
649         latex_old = (self._print(e) for e in old)
650         latex_new = (self._print(e) for e in new)
651         latex_subs = r'\\ '.join(
652             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
653         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
654 
655     def _print_Integral(self, expr):
656         tex, symbols = "", []
657 
658         # Only up to \iiiint exists
659         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
660             # Use len(expr.limits)-1 so that syntax highlighters don't think
661             # \" is an escaped quote
662             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
663             symbols = [r"\, d%s" % self._print(symbol[0])
664                        for symbol in expr.limits]
665 
666         else:
667             for lim in reversed(expr.limits):
668                 symbol = lim[0]
669                 tex += r"\int"
670 
671                 if len(lim) > 1:
672                     if self._settings['mode'] in ['equation', 'equation*'] \
673                             and not self._settings['itex']:
674                         tex += r"\limits"
675 
676                     if len(lim) == 3:
677                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
678                                                self._print(lim[2]))
679                     if len(lim) == 2:
680                         tex += "^{%s}" % (self._print(lim[1]))
681 
682                 symbols.insert(0, r"\, d%s" % self._print(symbol))
683 
684         return r"%s %s%s" % (tex,
685             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
686 
687     def _print_Limit(self, expr):
688         e, z, z0, dir = expr.args
689 
690         tex = r"\lim_{%s \to " % self._print(z)
691         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
692             tex += r"%s}" % self._print(z0)
693         else:
694             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
695 
696         if isinstance(e, AssocOp):
697             return r"%s\left(%s\right)" % (tex, self._print(e))
698         else:
699             return r"%s %s" % (tex, self._print(e))
700 
701     def _hprint_Function(self, func):
702         r'''
703         Logic to decide how to render a function to latex
704           - if it is a recognized latex name, use the appropriate latex command
705           - if it is a single letter, just use that letter
706           - if it is a longer name, then put \operatorname{} around it and be
707             mindful of undercores in the name
708         '''
709         func = self._deal_with_super_sub(func)
710         if func in accepted_latex_functions:
711             name = r"\%s" % func
712         elif len(func) == 1 or func.startswith('\\'):
713             name = func
714         else:
715             name = r"\operatorname{%s}" % func
716         return name
717 
718     def _print_Function(self, expr, exp=None):
719         r'''
720         Render functions to LaTeX, handling functions that LaTeX knows about
721         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
722         For single-letter function names, render them as regular LaTeX math
723         symbols. For multi-letter function names that LaTeX does not know
724         about, (e.g., Li, sech) use \operatorname{} so that the function name
725         is rendered in Roman font and LaTeX handles spacing properly.
726 
727         expr is the expression involving the function
728         exp is an exponent
729         '''
730         func = expr.func.__name__
731         if hasattr(self, '_print_' + func) and \
732             not isinstance(expr, AppliedUndef):
733             return getattr(self, '_print_' + func)(expr, exp)
734         else:
735             args = [ str(self._print(arg)) for arg in expr.args ]
736             # How inverse trig functions should be displayed, formats are:
737             # abbreviated: asin, full: arcsin, power: sin^-1
738             inv_trig_style = self._settings['inv_trig_style']
739             # If we are dealing with a power-style inverse trig function
740             inv_trig_power_case = False
741             # If it is applicable to fold the argument brackets
742             can_fold_brackets = self._settings['fold_func_brackets'] and \
743                 len(args) == 1 and \
744                 not self._needs_function_brackets(expr.args[0])
745 
746             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
747 
748             # If the function is an inverse trig function, handle the style
749             if func in inv_trig_table:
750                 if inv_trig_style == "abbreviated":
751                     func = func
752                 elif inv_trig_style == "full":
753                     func = "arc" + func[1:]
754                 elif inv_trig_style == "power":
755                     func = func[1:]
756                     inv_trig_power_case = True
757 
758                     # Can never fold brackets if we're raised to a power
759                     if exp is not None:
760                         can_fold_brackets = False
761 
762             if inv_trig_power_case:
763                 if func in accepted_latex_functions:
764                     name = r"\%s^{-1}" % func
765                 else:
766                     name = r"\operatorname{%s}^{-1}" % func
767             elif exp is not None:
768                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
769             else:
770                 name = self._hprint_Function(func)
771 
772             if can_fold_brackets:
773                 if func in accepted_latex_functions:
774                     # Wrap argument safely to avoid parse-time conflicts
775                     # with the function name itself
776                     name += r" {%s}"
777                 else:
778                     name += r"%s"
779             else:
780                 name += r"{\left (%s \right )}"
781 
782             if inv_trig_power_case and exp is not None:
783                 name += r"^{%s}" % exp
784 
785             return name % ",".join(args)
786 
787     def _print_UndefinedFunction(self, expr):
788         return self._hprint_Function(str(expr))
789 
790     @property
791     def _special_function_classes(self):
792         from sympy.functions.special.tensor_functions import KroneckerDelta
793         from sympy.functions.special.gamma_functions import gamma, lowergamma
794         from sympy.functions.special.beta_functions import beta
795         from sympy.functions.special.delta_functions import DiracDelta
796         from sympy.functions.special.error_functions import Chi
797         return {KroneckerDelta: r'\delta',
798                 gamma:  r'\Gamma',
799                 lowergamma: r'\gamma',
800                 beta: r'\operatorname{B}',
801                 DiracDelta: r'\delta',
802                 Chi: r'\operatorname{Chi}'}
803 
804     def _print_FunctionClass(self, expr):
805         for cls in self._special_function_classes:
806             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
807                 return self._special_function_classes[cls]
808         return self._hprint_Function(str(expr))
809 
810     def _print_Lambda(self, expr):
811         symbols, expr = expr.args
812 
813         if len(symbols) == 1:
814             symbols = self._print(symbols[0])
815         else:
816             symbols = self._print(tuple(symbols))
817 
818         args = (symbols, self._print(expr))
819         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
820 
821         return tex
822 
823     def _hprint_variadic_function(self, expr, exp=None):
824         args = sorted(expr.args, key=default_sort_key)
825         texargs = [r"%s" % self._print(symbol) for symbol in args]
826         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()), ", ".join(texargs))
827         if exp is not None:
828             return r"%s^{%s}" % (tex, exp)
829         else:
830             return tex
831 
832     _print_Min = _print_Max = _hprint_variadic_function
833 
834     def _print_floor(self, expr, exp=None):
835         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
836 
837         if exp is not None:
838             return r"%s^{%s}" % (tex, exp)
839         else:
840             return tex
841 
842     def _print_ceiling(self, expr, exp=None):
843         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
844 
845         if exp is not None:
846             return r"%s^{%s}" % (tex, exp)
847         else:
848             return tex
849 
850     def _print_log(self, expr, exp=None):
851         if not self._settings["ln_notation"]:
852             tex = r"\log{\left (%s \right )}" % self._print(expr.args[0])
853         else:
854             tex = r"\ln{\left (%s \right )}" % self._print(expr.args[0])
855 
856         if exp is not None:
857             return r"%s^{%s}" % (tex, exp)
858         else:
859             return tex
860 
861     def _print_Abs(self, expr, exp=None):
862         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
863 
864         if exp is not None:
865             return r"%s^{%s}" % (tex, exp)
866         else:
867             return tex
868     _print_Determinant = _print_Abs
869 
870     def _print_re(self, expr, exp=None):
871         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
872 
873         return self._do_exponent(tex, exp)
874 
875     def _print_im(self, expr, exp=None):
876         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
877 
878         return self._do_exponent(tex, exp)
879 
880     def _print_Not(self, e):
881         from sympy import Equivalent, Implies
882         if isinstance(e.args[0], Equivalent):
883             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
884         if isinstance(e.args[0], Implies):
885             return self._print_Implies(e.args[0], r"\not\Rightarrow")
886         if (e.args[0].is_Boolean):
887             return r"\neg (%s)" % self._print(e.args[0])
888         else:
889             return r"\neg %s" % self._print(e.args[0])
890 
891     def _print_LogOp(self, args, char):
892         arg = args[0]
893         if arg.is_Boolean and not arg.is_Not:
894             tex = r"\left(%s\right)" % self._print(arg)
895         else:
896             tex = r"%s" % self._print(arg)
897 
898         for arg in args[1:]:
899             if arg.is_Boolean and not arg.is_Not:
900                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
901             else:
902                 tex += r" %s %s" % (char, self._print(arg))
903 
904         return tex
905 
906     def _print_And(self, e):
907         args = sorted(e.args, key=default_sort_key)
908         return self._print_LogOp(args, r"\wedge")
909 
910     def _print_Or(self, e):
911         args = sorted(e.args, key=default_sort_key)
912         return self._print_LogOp(args, r"\vee")
913 
914     def _print_Xor(self, e):
915         args = sorted(e.args, key=default_sort_key)
916         return self._print_LogOp(args, r"\veebar")
917 
918     def _print_Implies(self, e, altchar=None):
919         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
920 
921     def _print_Equivalent(self, e, altchar=None):
922         args = sorted(e.args, key=default_sort_key)
923         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
924 
925     def _print_conjugate(self, expr, exp=None):
926         tex = r"\overline{%s}" % self._print(expr.args[0])
927 
928         if exp is not None:
929             return r"%s^{%s}" % (tex, exp)
930         else:
931             return tex
932 
933     def _print_polar_lift(self, expr, exp=None):
934         func = r"\operatorname{polar\_lift}"
935         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
936 
937         if exp is not None:
938             return r"%s^{%s}%s" % (func, exp, arg)
939         else:
940             return r"%s%s" % (func, arg)
941 
942     def _print_ExpBase(self, expr, exp=None):
943         # TODO should exp_polar be printed differently?
944         #      what about exp_polar(0), exp_polar(1)?
945         tex = r"e^{%s}" % self._print(expr.args[0])
946         return self._do_exponent(tex, exp)
947 
948     def _print_elliptic_k(self, expr, exp=None):
949         tex = r"\left(%s\right)" % self._print(expr.args[0])
950         if exp is not None:
951             return r"K^{%s}%s" % (exp, tex)
952         else:
953             return r"K%s" % tex
954 
955     def _print_elliptic_f(self, expr, exp=None):
956         tex = r"\left(%s\middle| %s\right)" % \
957             (self._print(expr.args[0]), self._print(expr.args[1]))
958         if exp is not None:
959             return r"F^{%s}%s" % (exp, tex)
960         else:
961             return r"F%s" % tex
962 
963     def _print_elliptic_e(self, expr, exp=None):
964         if len(expr.args) == 2:
965             tex = r"\left(%s\middle| %s\right)" % \
966                 (self._print(expr.args[0]), self._print(expr.args[1]))
967         else:
968             tex = r"\left(%s\right)" % self._print(expr.args[0])
969         if exp is not None:
970             return r"E^{%s}%s" % (exp, tex)
971         else:
972             return r"E%s" % tex
973 
974     def _print_elliptic_pi(self, expr, exp=None):
975         if len(expr.args) == 3:
976             tex = r"\left(%s; %s\middle| %s\right)" % \
977                 (self._print(expr.args[0]), self._print(expr.args[1]), \
978                  self._print(expr.args[2]))
979         else:
980             tex = r"\left(%s\middle| %s\right)" % \
981                 (self._print(expr.args[0]), self._print(expr.args[1]))
982         if exp is not None:
983             return r"\Pi^{%s}%s" % (exp, tex)
984         else:
985             return r"\Pi%s" % tex
986 
987     def _print_beta(self, expr, exp=None):
988         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
989                                         self._print(expr.args[1]))
990 
991         if exp is not None:
992             return r"\operatorname{B}^{%s}%s" % (exp, tex)
993         else:
994             return r"\operatorname{B}%s" % tex
995 
996     def _print_uppergamma(self, expr, exp=None):
997         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
998                                         self._print(expr.args[1]))
999 
1000         if exp is not None:
1001             return r"\Gamma^{%s}%s" % (exp, tex)
1002         else:
1003             return r"\Gamma%s" % tex
1004 
1005     def _print_lowergamma(self, expr, exp=None):
1006         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1007                                         self._print(expr.args[1]))
1008 
1009         if exp is not None:
1010             return r"\gamma^{%s}%s" % (exp, tex)
1011         else:
1012             return r"\gamma%s" % tex
1013 
1014     def _hprint_one_arg_func(self, expr, exp=None):
1015         tex = r"\left(%s\right)" % self._print(expr.args[0])
1016 
1017         if exp is not None:
1018             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1019         else:
1020             return r"%s%s" % (self._print(expr.func), tex)
1021 
1022     _print_gamma = _hprint_one_arg_func
1023 
1024     def _print_Chi(self, expr, exp=None):
1025         tex = r"\left(%s\right)" % self._print(expr.args[0])
1026 
1027         if exp is not None:
1028             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1029         else:
1030             return r"\operatorname{Chi}%s" % tex
1031 
1032     def _print_expint(self, expr, exp=None):
1033         tex = r"\left(%s\right)" % self._print(expr.args[1])
1034         nu = self._print(expr.args[0])
1035 
1036         if exp is not None:
1037             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1038         else:
1039             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1040 
1041     def _print_fresnels(self, expr, exp=None):
1042         tex = r"\left(%s\right)" % self._print(expr.args[0])
1043 
1044         if exp is not None:
1045             return r"S^{%s}%s" % (exp, tex)
1046         else:
1047             return r"S%s" % tex
1048 
1049     def _print_fresnelc(self, expr, exp=None):
1050         tex = r"\left(%s\right)" % self._print(expr.args[0])
1051 
1052         if exp is not None:
1053             return r"C^{%s}%s" % (exp, tex)
1054         else:
1055             return r"C%s" % tex
1056 
1057     def _print_subfactorial(self, expr, exp=None):
1058         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1059 
1060         if exp is not None:
1061             return r"%s^{%s}" % (tex, exp)
1062         else:
1063             return tex
1064 
1065     def _print_factorial(self, expr, exp=None):
1066         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1067 
1068         if exp is not None:
1069             return r"%s^{%s}" % (tex, exp)
1070         else:
1071             return tex
1072 
1073     def _print_factorial2(self, expr, exp=None):
1074         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1075 
1076         if exp is not None:
1077             return r"%s^{%s}" % (tex, exp)
1078         else:
1079             return tex
1080 
1081     def _print_binomial(self, expr, exp=None):
1082         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1083                                      self._print(expr.args[1]))
1084 
1085         if exp is not None:
1086             return r"%s^{%s}" % (tex, exp)
1087         else:
1088             return tex
1089 
1090     def _print_RisingFactorial(self, expr, exp=None):
1091         n, k = expr.args
1092         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1093 
1094         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1095 
1096         return self._do_exponent(tex, exp)
1097 
1098     def _print_FallingFactorial(self, expr, exp=None):
1099         n, k = expr.args
1100         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1101 
1102         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1103 
1104         return self._do_exponent(tex, exp)
1105 
1106     def _hprint_BesselBase(self, expr, exp, sym):
1107         tex = r"%s" % (sym)
1108 
1109         need_exp = False
1110         if exp is not None:
1111             if tex.find('^') == -1:
1112                 tex = r"%s^{%s}" % (tex, self._print(exp))
1113             else:
1114                 need_exp = True
1115 
1116         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1117                                            self._print(expr.argument))
1118 
1119         if need_exp:
1120             tex = self._do_exponent(tex, exp)
1121         return tex
1122 
1123     def _hprint_vec(self, vec):
1124         if len(vec) == 0:
1125             return ""
1126         s = ""
1127         for i in vec[:-1]:
1128             s += "%s, " % self._print(i)
1129         s += self._print(vec[-1])
1130         return s
1131 
1132     def _print_besselj(self, expr, exp=None):
1133         return self._hprint_BesselBase(expr, exp, 'J')
1134 
1135     def _print_besseli(self, expr, exp=None):
1136         return self._hprint_BesselBase(expr, exp, 'I')
1137 
1138     def _print_besselk(self, expr, exp=None):
1139         return self._hprint_BesselBase(expr, exp, 'K')
1140 
1141     def _print_bessely(self, expr, exp=None):
1142         return self._hprint_BesselBase(expr, exp, 'Y')
1143 
1144     def _print_yn(self, expr, exp=None):
1145         return self._hprint_BesselBase(expr, exp, 'y')
1146 
1147     def _print_jn(self, expr, exp=None):
1148         return self._hprint_BesselBase(expr, exp, 'j')
1149 
1150     def _print_hankel1(self, expr, exp=None):
1151         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1152 
1153     def _print_hankel2(self, expr, exp=None):
1154         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1155 
1156     def _print_hn1(self, expr, exp=None):
1157         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1158 
1159     def _print_hn2(self, expr, exp=None):
1160         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1161 
1162     def _hprint_airy(self, expr, exp=None, notation=""):
1163         tex = r"\left(%s\right)" % self._print(expr.args[0])
1164 
1165         if exp is not None:
1166             return r"%s^{%s}%s" % (notation, exp, tex)
1167         else:
1168             return r"%s%s" % (notation, tex)
1169 
1170     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1171         tex = r"\left(%s\right)" % self._print(expr.args[0])
1172 
1173         if exp is not None:
1174             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1175         else:
1176             return r"%s^\prime%s" % (notation, tex)
1177 
1178     def _print_airyai(self, expr, exp=None):
1179         return self._hprint_airy(expr, exp, 'Ai')
1180 
1181     def _print_airybi(self, expr, exp=None):
1182         return self._hprint_airy(expr, exp, 'Bi')
1183 
1184     def _print_airyaiprime(self, expr, exp=None):
1185         return self._hprint_airy_prime(expr, exp, 'Ai')
1186 
1187     def _print_airybiprime(self, expr, exp=None):
1188         return self._hprint_airy_prime(expr, exp, 'Bi')
1189 
1190     def _print_hyper(self, expr, exp=None):
1191         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1192               r"\middle| {%s} \right)}" % \
1193             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1194               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1195               self._print(expr.argument))
1196 
1197         if exp is not None:
1198             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1199         return tex
1200 
1201     def _print_meijerg(self, expr, exp=None):
1202         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1203               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1204             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1205               self._print(len(expr.bm)), self._print(len(expr.an)),
1206               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1207               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1208               self._print(expr.argument))
1209 
1210         if exp is not None:
1211             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1212         return tex
1213 
1214     def _print_dirichlet_eta(self, expr, exp=None):
1215         tex = r"\left(%s\right)" % self._print(expr.args[0])
1216         if exp is not None:
1217             return r"\eta^{%s}%s" % (self._print(exp), tex)
1218         return r"\eta%s" % tex
1219 
1220     def _print_zeta(self, expr, exp=None):
1221         if len(expr.args) == 2:
1222             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1223         else:
1224             tex = r"\left(%s\right)" % self._print(expr.args[0])
1225         if exp is not None:
1226             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1227         return r"\zeta%s" % tex
1228 
1229     def _print_lerchphi(self, expr, exp=None):
1230         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1231         if exp is None:
1232             return r"\Phi%s" % tex
1233         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1234 
1235     def _print_polylog(self, expr, exp=None):
1236         s, z = map(self._print, expr.args)
1237         tex = r"\left(%s\right)" % z
1238         if exp is None:
1239             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1240         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1241 
1242     def _print_jacobi(self, expr, exp=None):
1243         n, a, b, x = map(self._print, expr.args)
1244         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1245         if exp is not None:
1246             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1247         return tex
1248 
1249     def _print_gegenbauer(self, expr, exp=None):
1250         n, a, x = map(self._print, expr.args)
1251         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1252         if exp is not None:
1253             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1254         return tex
1255 
1256     def _print_chebyshevt(self, expr, exp=None):
1257         n, x = map(self._print, expr.args)
1258         tex = r"T_{%s}\left(%s\right)" % (n, x)
1259         if exp is not None:
1260             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1261         return tex
1262 
1263     def _print_chebyshevu(self, expr, exp=None):
1264         n, x = map(self._print, expr.args)
1265         tex = r"U_{%s}\left(%s\right)" % (n, x)
1266         if exp is not None:
1267             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1268         return tex
1269 
1270     def _print_legendre(self, expr, exp=None):
1271         n, x = map(self._print, expr.args)
1272         tex = r"P_{%s}\left(%s\right)" % (n, x)
1273         if exp is not None:
1274             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1275         return tex
1276 
1277     def _print_assoc_legendre(self, expr, exp=None):
1278         n, a, x = map(self._print, expr.args)
1279         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1280         if exp is not None:
1281             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1282         return tex
1283 
1284     def _print_hermite(self, expr, exp=None):
1285         n, x = map(self._print, expr.args)
1286         tex = r"H_{%s}\left(%s\right)" % (n, x)
1287         if exp is not None:
1288             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1289         return tex
1290 
1291     def _print_laguerre(self, expr, exp=None):
1292         n, x = map(self._print, expr.args)
1293         tex = r"L_{%s}\left(%s\right)" % (n, x)
1294         if exp is not None:
1295             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1296         return tex
1297 
1298     def _print_assoc_laguerre(self, expr, exp=None):
1299         n, a, x = map(self._print, expr.args)
1300         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1301         if exp is not None:
1302             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1303         return tex
1304 
1305     def _print_Ynm(self, expr, exp=None):
1306         n, m, theta, phi = map(self._print, expr.args)
1307         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1308         if exp is not None:
1309             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1310         return tex
1311 
1312     def _print_Znm(self, expr, exp=None):
1313         n, m, theta, phi = map(self._print, expr.args)
1314         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1315         if exp is not None:
1316             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1317         return tex
1318 
1319     def _print_Rational(self, expr):
1320         if expr.q != 1:
1321             sign = ""
1322             p = expr.p
1323             if expr.p < 0:
1324                 sign = "- "
1325                 p = -p
1326             if self._settings['fold_short_frac']:
1327                 return r"%s%d / %d" % (sign, p, expr.q)
1328             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1329         else:
1330             return self._print(expr.p)
1331 
1332     def _print_Order(self, expr):
1333         s = self._print(expr.expr)
1334         if expr.point and any(p != S.Zero for p in expr.point) or \
1335            len(expr.variables) > 1:
1336             s += '; '
1337             if len(expr.variables) > 1:
1338                 s += self._print(expr.variables)
1339             elif len(expr.variables):
1340                 s += self._print(expr.variables[0])
1341             s += r'\rightarrow '
1342             if len(expr.point) > 1:
1343                 s += self._print(expr.point)
1344             else:
1345                 s += self._print(expr.point[0])
1346         return r"O\left(%s\right)" % s
1347 
1348     def _print_Symbol(self, expr):
1349         if expr in self._settings['symbol_names']:
1350             return self._settings['symbol_names'][expr]
1351 
1352         return self._deal_with_super_sub(expr.name) if \
1353             '\\' not in expr.name else expr.name
1354 
1355     _print_RandomSymbol = _print_Symbol
1356     _print_MatrixSymbol = _print_Symbol
1357 
1358     def _deal_with_super_sub(self, string):
1359         if '{' in string:
1360             return string
1361 
1362         name, supers, subs = split_super_sub(string)
1363 
1364         name = translate(name)
1365         supers = [translate(sup) for sup in supers]
1366         subs = [translate(sub) for sub in subs]
1367 
1368         # glue all items together:
1369         if len(supers) > 0:
1370             name += "^{%s}" % " ".join(supers)
1371         if len(subs) > 0:
1372             name += "_{%s}" % " ".join(subs)
1373 
1374         return name
1375 
1376     def _print_Relational(self, expr):
1377         if self._settings['itex']:
1378             gt = r"\gt"
1379             lt = r"\lt"
1380         else:
1381             gt = ">"
1382             lt = "<"
1383 
1384         charmap = {
1385             "==": "=",
1386             ">": gt,
1387             "<": lt,
1388             ">=": r"\geq",
1389             "<=": r"\leq",
1390             "!=": r"\neq",
1391         }
1392 
1393         return "%s %s %s" % (self._print(expr.lhs),
1394             charmap[expr.rel_op], self._print(expr.rhs))
1395 
1396     def _print_Piecewise(self, expr):
1397         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1398                    for e, c in expr.args[:-1]]
1399         if expr.args[-1].cond == true:
1400             ecpairs.append(r"%s & \text{otherwise}" %
1401                            self._print(expr.args[-1].expr))
1402         else:
1403             ecpairs.append(r"%s & \text{for}\: %s" %
1404                            (self._print(expr.args[-1].expr),
1405                             self._print(expr.args[-1].cond)))
1406         tex = r"\begin{cases} %s \end{cases}"
1407         return tex % r" \\".join(ecpairs)
1408 
1409     def _print_MatrixBase(self, expr):
1410         lines = []
1411 
1412         for line in range(expr.rows):  # horrible, should be 'rows'
1413             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1414 
1415         mat_str = self._settings['mat_str']
1416         if mat_str is None:
1417             if self._settings['mode'] == 'inline':
1418                 mat_str = 'smallmatrix'
1419             else:
1420                 if (expr.cols <= 10) is True:
1421                     mat_str = 'matrix'
1422                 else:
1423                     mat_str = 'array'
1424 
1425         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1426         out_str = out_str.replace('%MATSTR%', mat_str)
1427         if mat_str == 'array':
1428             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1429         if self._settings['mat_delim']:
1430             left_delim = self._settings['mat_delim']
1431             right_delim = self._delim_dict[left_delim]
1432             out_str = r'\left' + left_delim + out_str + \
1433                       r'\right' + right_delim
1434         return out_str % r"\\".join(lines)
1435     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1436                            = _print_Matrix \
1437                            = _print_MatrixBase
1438 
1439     def _print_MatrixElement(self, expr):
1440         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1441             + '_{%s, %s}' % (expr.i, expr.j)
1442 
1443     def _print_MatrixSlice(self, expr):
1444         def latexslice(x):
1445             x = list(x)
1446             if x[2] == 1:
1447                 del x[2]
1448             if x[1] == x[0] + 1:
1449                 del x[1]
1450             if x[0] == 0:
1451                 x[0] = ''
1452             return ':'.join(map(self._print, x))
1453         return (self._print(expr.parent) + r'\left[' +
1454                 latexslice(expr.rowslice) + ', ' +
1455                 latexslice(expr.colslice) + r'\right]')
1456 
1457     def _print_BlockMatrix(self, expr):
1458         return self._print(expr.blocks)
1459 
1460     def _print_Transpose(self, expr):
1461         mat = expr.arg
1462         from sympy.matrices import MatrixSymbol
1463         if not isinstance(mat, MatrixSymbol):
1464             return r"\left(%s\right)^T" % self._print(mat)
1465         else:
1466             return "%s^T" % self._print(mat)
1467 
1468     def _print_Trace(self, expr):
1469         mat = expr.arg
1470         return r"\mathrm{tr}\left (%s \right )" % self._print(mat)
1471 
1472     def _print_Adjoint(self, expr):
1473         mat = expr.arg
1474         from sympy.matrices import MatrixSymbol
1475         if not isinstance(mat, MatrixSymbol):
1476             return r"\left(%s\right)^\dagger" % self._print(mat)
1477         else:
1478             return r"%s^\dagger" % self._print(mat)
1479 
1480     def _print_MatMul(self, expr):
1481         from sympy import Add, MatAdd, HadamardProduct, MatMul, Mul
1482 
1483         parens = lambda x: self.parenthesize(x, precedence_traditional(expr), False)
1484 
1485         args = expr.args
1486         if isinstance(args[0], Mul):
1487             args = args[0].as_ordered_factors() + list(args[1:])
1488         else:
1489             args = list(args)
1490 
1491         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1492             if args[0] == -1:
1493                 args = args[1:]
1494             else:
1495                 args[0] = -args[0]
1496             return '- ' + ' '.join(map(parens, args))
1497         else:
1498             return ' '.join(map(parens, args))
1499 
1500     def _print_Mod(self, expr, exp=None):
1501         if exp is not None:
1502             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1503                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1504         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1505                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1506 
1507     def _print_HadamardProduct(self, expr):
1508         from sympy import Add, MatAdd, MatMul
1509 
1510         def parens(x):
1511             if isinstance(x, (Add, MatAdd, MatMul)):
1512                 return r"\left(%s\right)" % self._print(x)
1513             return self._print(x)
1514         return r' \circ '.join(map(parens, expr.args))
1515 
1516     def _print_KroneckerProduct(self, expr):
1517         from sympy import Add, MatAdd, MatMul
1518 
1519         def parens(x):
1520             if isinstance(x, (Add, MatAdd, MatMul)):
1521                 return r"\left(%s\right)" % self._print(x)
1522             return self._print(x)
1523         return r' \otimes '.join(map(parens, expr.args))
1524 
1525     def _print_MatPow(self, expr):
1526         base, exp = expr.base, expr.exp
1527         from sympy.matrices import MatrixSymbol
1528         if not isinstance(base, MatrixSymbol):
1529             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1530         else:
1531             return "%s^{%s}" % (self._print(base), self._print(exp))
1532 
1533     def _print_ZeroMatrix(self, Z):
1534         return r"\mathbb{0}"
1535 
1536     def _print_Identity(self, I):
1537         return r"\mathbb{I}"
1538 
1539     def _print_NDimArray(self, expr):
1540 
1541         if expr.rank() == 0:
1542             return self._print(expr[()])
1543 
1544         mat_str = self._settings['mat_str']
1545         if mat_str is None:
1546             if self._settings['mode'] == 'inline':
1547                 mat_str = 'smallmatrix'
1548             else:
1549                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1550                     mat_str = 'matrix'
1551                 else:
1552                     mat_str = 'array'
1553         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1554         block_str = block_str.replace('%MATSTR%', mat_str)
1555         if self._settings['mat_delim']:
1556             left_delim = self._settings['mat_delim']
1557             right_delim = self._delim_dict[left_delim]
1558             block_str = r'\left' + left_delim + block_str + \
1559                       r'\right' + right_delim
1560 
1561         if expr.rank() == 0:
1562             return block_str % ""
1563 
1564         level_str = [[]] + [[] for i in range(expr.rank())]
1565         shape_ranges = [list(range(i)) for i in expr.shape]
1566         for outer_i in itertools.product(*shape_ranges):
1567             level_str[-1].append(self._print(expr[outer_i]))
1568             even = True
1569             for back_outer_i in range(expr.rank()-1, -1, -1):
1570                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1571                     break
1572                 if even:
1573                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1574                 else:
1575                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1576                     if len(level_str[back_outer_i+1]) == 1:
1577                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1578                 even = not even
1579                 level_str[back_outer_i+1] = []
1580 
1581         out_str = level_str[0][0]
1582 
1583         if expr.rank() % 2 == 1:
1584             out_str = block_str % out_str
1585 
1586         return out_str
1587 
1588     _print_ImmutableDenseNDimArray = _print_NDimArray
1589     _print_ImmutableSparseNDimArray = _print_NDimArray
1590     _print_MutableDenseNDimArray = _print_NDimArray
1591     _print_MutableSparseNDimArray = _print_NDimArray
1592 
1593     def _printer_tensor_indices(self, name, indices, index_map={}):
1594         out_str = self._print(name)
1595         last_valence = None
1596         prev_map = None
1597         for index in indices:
1598             new_valence = index.is_up
1599             if ((index in index_map) or prev_map) and last_valence == new_valence:
1600                 out_str += ","
1601             if last_valence != new_valence:
1602                 if last_valence is not None:
1603                     out_str += "}"
1604                 if index.is_up:
1605                     out_str += "{}^{"
1606                 else:
1607                     out_str += "{}_{"
1608             out_str += self._print(index.args[0])
1609             if index in index_map:
1610                 out_str += "="
1611                 out_str += self._print(index_map[index])
1612                 prev_map = True
1613             else:
1614                 prev_map = False
1615             last_valence = new_valence
1616         if last_valence is not None:
1617             out_str += "}"
1618         return out_str
1619 
1620     def _print_Tensor(self, expr):
1621         name = expr.args[0].args[0]
1622         indices = expr.get_indices()
1623         return self._printer_tensor_indices(name, indices)
1624 
1625     def _print_TensorElement(self, expr):
1626         name = expr.expr.args[0].args[0]
1627         indices = expr.expr.get_indices()
1628         index_map = expr.index_map
1629         return self._printer_tensor_indices(name, indices, index_map)
1630 
1631     def _print_TensMul(self, expr):
1632         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1633         sign, args = expr._get_args_for_traditional_printer()
1634         return sign + "".join(
1635             [self.parenthesize(arg, precedence(expr)) for arg in args]
1636         )
1637 
1638     def _print_TensAdd(self, expr):
1639         a = []
1640         args = expr.args
1641         for x in args:
1642             a.append(self.parenthesize(x, precedence(expr)))
1643         a.sort()
1644         s = ' + '.join(a)
1645         s = s.replace('+ -', '- ')
1646         return s
1647 
1648     def _print_TensorIndex(self, expr):
1649         return "{}%s{%s}" % (
1650             "^" if expr.is_up else "_",
1651             self._print(expr.args[0])
1652         )
1653         return self._print(expr.args[0])
1654 
1655     def _print_tuple(self, expr):
1656         return r"\left ( %s\right )" % \
1657             r", \quad ".join([ self._print(i) for i in expr ])
1658 
1659     def _print_TensorProduct(self, expr):
1660         elements = [self._print(a) for a in expr.args]
1661         return r' \otimes '.join(elements)
1662 
1663     def _print_WedgeProduct(self, expr):
1664         elements = [self._print(a) for a in expr.args]
1665         return r' \wedge '.join(elements)
1666 
1667     def _print_Tuple(self, expr):
1668         return self._print_tuple(expr)
1669 
1670     def _print_list(self, expr):
1671         return r"\left [ %s\right ]" % \
1672             r", \quad ".join([ self._print(i) for i in expr ])
1673 
1674     def _print_dict(self, d):
1675         keys = sorted(d.keys(), key=default_sort_key)
1676         items = []
1677 
1678         for key in keys:
1679             val = d[key]
1680             items.append("%s : %s" % (self._print(key), self._print(val)))
1681 
1682         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1683 
1684     def _print_Dict(self, expr):
1685         return self._print_dict(expr)
1686 
1687     def _print_DiracDelta(self, expr, exp=None):
1688         if len(expr.args) == 1 or expr.args[1] == 0:
1689             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1690         else:
1691             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1692                 self._print(expr.args[1]), self._print(expr.args[0]))
1693         if exp:
1694             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1695         return tex
1696 
1697     def _print_SingularityFunction(self, expr):
1698         shift = self._print(expr.args[0] - expr.args[1])
1699         power = self._print(expr.args[2])
1700         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1701         return tex
1702 
1703     def _print_Heaviside(self, expr, exp=None):
1704         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1705         if exp:
1706             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1707         return tex
1708 
1709     def _print_KroneckerDelta(self, expr, exp=None):
1710         i = self._print(expr.args[0])
1711         j = self._print(expr.args[1])
1712         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1713             tex = r'\delta_{%s %s}' % (i, j)
1714         else:
1715             tex = r'\delta_{%s, %s}' % (i, j)
1716         if exp:
1717             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1718         return tex
1719 
1720     def _print_LeviCivita(self, expr, exp=None):
1721         indices = map(self._print, expr.args)
1722         if all(x.is_Atom for x in expr.args):
1723             tex = r'\varepsilon_{%s}' % " ".join(indices)
1724         else:
1725             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1726         if exp:
1727             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1728         return tex
1729 
1730     def _print_ProductSet(self, p):
1731         if len(p.sets) > 1 and not has_variety(p.sets):
1732             return self._print(p.sets[0]) + "^{%d}" % len(p.sets)
1733         else:
1734             return r" \times ".join(self._print(set) for set in p.sets)
1735 
1736     def _print_RandomDomain(self, d):
1737         if hasattr(d, 'as_boolean'):
1738             return 'Domain: ' + self._print(d.as_boolean())
1739         elif hasattr(d, 'set'):
1740             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1741                     self._print(d.set))
1742         elif hasattr(d, 'symbols'):
1743             return 'Domain on ' + self._print(d.symbols)
1744         else:
1745             return self._print(None)
1746 
1747     def _print_FiniteSet(self, s):
1748         items = sorted(s.args, key=default_sort_key)
1749         return self._print_set(items)
1750 
1751     def _print_set(self, s):
1752         items = sorted(s, key=default_sort_key)
1753         items = ", ".join(map(self._print, items))
1754         return r"\left\{%s\right\}" % items
1755 
1756     _print_frozenset = _print_set
1757 
1758     def _print_Range(self, s):
1759         dots = r'\ldots'
1760 
1761         if s.start.is_infinite:
1762             printset = s.start, dots, s[-1] - s.step, s[-1]
1763         elif s.stop.is_infinite or len(s) > 4:
1764             it = iter(s)
1765             printset = next(it), next(it), dots, s[-1]
1766         else:
1767             printset = tuple(s)
1768 
1769         return (r"\left\{"
1770               + r", ".join(self._print(el) for el in printset)
1771               + r"\right\}")
1772 
1773     def _print_SeqFormula(self, s):
1774         if s.start is S.NegativeInfinity:
1775             stop = s.stop
1776             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1777                 s.coeff(stop - 1), s.coeff(stop))
1778         elif s.stop is S.Infinity or s.length > 4:
1779             printset = s[:4]
1780             printset.append(r'\ldots')
1781         else:
1782             printset = tuple(s)
1783 
1784         return (r"\left["
1785               + r", ".join(self._print(el) for el in printset)
1786               + r"\right]")
1787 
1788     _print_SeqPer = _print_SeqFormula
1789     _print_SeqAdd = _print_SeqFormula
1790     _print_SeqMul = _print_SeqFormula
1791 
1792     def _print_Interval(self, i):
1793         if i.start == i.end:
1794             return r"\left\{%s\right\}" % self._print(i.start)
1795 
1796         else:
1797             if i.left_open:
1798                 left = '('
1799             else:
1800                 left = '['
1801 
1802             if i.right_open:
1803                 right = ')'
1804             else:
1805                 right = ']'
1806 
1807             return r"\left%s%s, %s\right%s" % \
1808                    (left, self._print(i.start), self._print(i.end), right)
1809 
1810     def _print_AccumulationBounds(self, i):
1811         return r"\langle %s, %s\rangle" % \
1812                 (self._print(i.min), self._print(i.max))
1813 
1814     def _print_Union(self, u):
1815         return r" \cup ".join([self._print(i) for i in u.args])
1816 
1817     def _print_Complement(self, u):
1818         return r" \setminus ".join([self._print(i) for i in u.args])
1819 
1820     def _print_Intersection(self, u):
1821         return r" \cap ".join([self._print(i) for i in u.args])
1822 
1823     def _print_SymmetricDifference(self, u):
1824         return r" \triangle ".join([self._print(i) for i in u.args])
1825 
1826     def _print_EmptySet(self, e):
1827         return r"\emptyset"
1828 
1829     def _print_Naturals(self, n):
1830         return r"\mathbb{N}"
1831 
1832     def _print_Naturals0(self, n):
1833         return r"\mathbb{N}_0"
1834 
1835     def _print_Integers(self, i):
1836         return r"\mathbb{Z}"
1837 
1838     def _print_Reals(self, i):
1839         return r"\mathbb{R}"
1840 
1841     def _print_Complexes(self, i):
1842         return r"\mathbb{C}"
1843 
1844     def _print_ImageSet(self, s):
1845         sets = s.args[1:]
1846         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1847             for var, setv in zip(s.lamda.variables, sets)]
1848         return r"\left\{%s\; |\; %s\right\}" % (
1849             self._print(s.lamda.expr),
1850             ', '.join(varsets))
1851 
1852     def _print_ConditionSet(self, s):
1853         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1854         if s.base_set is S.UniversalSet:
1855             return r"\left\{%s \mid %s \right\}" % (
1856             vars_print,
1857             self._print(s.condition.as_expr()))
1858 
1859         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1860             vars_print,
1861             vars_print,
1862             self._print(s.base_set),
1863             self._print(s.condition.as_expr()))
1864 
1865     def _print_ComplexRegion(self, s):
1866         vars_print = ', '.join([self._print(var) for var in s.variables])
1867         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1868             self._print(s.expr),
1869             vars_print,
1870             self._print(s.sets))
1871 
1872     def _print_Contains(self, e):
1873         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1874 
1875     def _print_FourierSeries(self, s):
1876         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1877 
1878     def _print_FormalPowerSeries(self, s):
1879         return self._print_Add(s.infinite)
1880 
1881     def _print_FiniteField(self, expr):
1882         return r"\mathbb{F}_{%s}" % expr.mod
1883 
1884     def _print_IntegerRing(self, expr):
1885         return r"\mathbb{Z}"
1886 
1887     def _print_RationalField(self, expr):
1888         return r"\mathbb{Q}"
1889 
1890     def _print_RealField(self, expr):
1891         return r"\mathbb{R}"
1892 
1893     def _print_ComplexField(self, expr):
1894         return r"\mathbb{C}"
1895 
1896     def _print_PolynomialRing(self, expr):
1897         domain = self._print(expr.domain)
1898         symbols = ", ".join(map(self._print, expr.symbols))
1899         return r"%s\left[%s\right]" % (domain, symbols)
1900 
1901     def _print_FractionField(self, expr):
1902         domain = self._print(expr.domain)
1903         symbols = ", ".join(map(self._print, expr.symbols))
1904         return r"%s\left(%s\right)" % (domain, symbols)
1905 
1906     def _print_PolynomialRingBase(self, expr):
1907         domain = self._print(expr.domain)
1908         symbols = ", ".join(map(self._print, expr.symbols))
1909         inv = ""
1910         if not expr.is_Poly:
1911             inv = r"S_<^{-1}"
1912         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1913 
1914     def _print_Poly(self, poly):
1915         cls = poly.__class__.__name__
1916         terms = []
1917         for monom, coeff in poly.terms():
1918             s_monom = ''
1919             for i, exp in enumerate(monom):
1920                 if exp > 0:
1921                     if exp == 1:
1922                         s_monom += self._print(poly.gens[i])
1923                     else:
1924                         s_monom += self._print(pow(poly.gens[i], exp))
1925 
1926             if coeff.is_Add:
1927                 if s_monom:
1928                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1929                 else:
1930                     s_coeff = self._print(coeff)
1931             else:
1932                 if s_monom:
1933                     if coeff is S.One:
1934                         terms.extend(['+', s_monom])
1935                         continue
1936 
1937                     if coeff is S.NegativeOne:
1938                         terms.extend(['-', s_monom])
1939                         continue
1940 
1941                 s_coeff = self._print(coeff)
1942 
1943             if not s_monom:
1944                 s_term = s_coeff
1945             else:
1946                 s_term = s_coeff + " " + s_monom
1947 
1948             if s_term.startswith('-'):
1949                 terms.extend(['-', s_term[1:]])
1950             else:
1951                 terms.extend(['+', s_term])
1952 
1953         if terms[0] in ['-', '+']:
1954             modifier = terms.pop(0)
1955 
1956             if modifier == '-':
1957                 terms[0] = '-' + terms[0]
1958 
1959         expr = ' '.join(terms)
1960         gens = list(map(self._print, poly.gens))
1961         domain = "domain=%s" % self._print(poly.get_domain())
1962 
1963         args = ", ".join([expr] + gens + [domain])
1964         if cls in accepted_latex_functions:
1965             tex = r"\%s {\left (%s \right )}" % (cls, args)
1966         else:
1967             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1968 
1969         return tex
1970 
1971     def _print_ComplexRootOf(self, root):
1972         cls = root.__class__.__name__
1973         if cls == "ComplexRootOf":
1974             cls = "CRootOf"
1975         expr = self._print(root.expr)
1976         index = root.index
1977         if cls in accepted_latex_functions:
1978             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1979         else:
1980             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1981 
1982     def _print_RootSum(self, expr):
1983         cls = expr.__class__.__name__
1984         args = [self._print(expr.expr)]
1985 
1986         if expr.fun is not S.IdentityFunction:
1987             args.append(self._print(expr.fun))
1988 
1989         if cls in accepted_latex_functions:
1990             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1991         else:
1992             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1993 
1994     def _print_PolyElement(self, poly):
1995         mul_symbol = self._settings['mul_symbol_latex']
1996         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1997 
1998     def _print_FracElement(self, frac):
1999         if frac.denom == 1:
2000             return self._print(frac.numer)
2001         else:
2002             numer = self._print(frac.numer)
2003             denom = self._print(frac.denom)
2004             return r"\frac{%s}{%s}" % (numer, denom)
2005 
2006     def _print_euler(self, expr, exp=None):
2007         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2008         tex = r"E_{%s}" % self._print(m)
2009         if exp is not None:
2010             tex = r"%s^{%s}" % (tex, self._print(exp))
2011         if x is not None:
2012             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2013         return tex
2014 
2015     def _print_catalan(self, expr, exp=None):
2016         tex = r"C_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_MellinTransform(self, expr):
2022         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2023 
2024     def _print_InverseMellinTransform(self, expr):
2025         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2026 
2027     def _print_LaplaceTransform(self, expr):
2028         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2029 
2030     def _print_InverseLaplaceTransform(self, expr):
2031         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2032 
2033     def _print_FourierTransform(self, expr):
2034         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2035 
2036     def _print_InverseFourierTransform(self, expr):
2037         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2038 
2039     def _print_SineTransform(self, expr):
2040         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2041 
2042     def _print_InverseSineTransform(self, expr):
2043         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2044 
2045     def _print_CosineTransform(self, expr):
2046         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2047 
2048     def _print_InverseCosineTransform(self, expr):
2049         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2050 
2051     def _print_DMP(self, p):
2052         try:
2053             if p.ring is not None:
2054                 # TODO incorporate order
2055                 return self._print(p.ring.to_sympy(p))
2056         except SympifyError:
2057             pass
2058         return self._print(repr(p))
2059 
2060     def _print_DMF(self, p):
2061         return self._print_DMP(p)
2062 
2063     def _print_Object(self, object):
2064         return self._print(Symbol(object.name))
2065 
2066     def _print_Morphism(self, morphism):
2067         domain = self._print(morphism.domain)
2068         codomain = self._print(morphism.codomain)
2069         return "%s\\rightarrow %s" % (domain, codomain)
2070 
2071     def _print_NamedMorphism(self, morphism):
2072         pretty_name = self._print(Symbol(morphism.name))
2073         pretty_morphism = self._print_Morphism(morphism)
2074         return "%s:%s" % (pretty_name, pretty_morphism)
2075 
2076     def _print_IdentityMorphism(self, morphism):
2077         from sympy.categories import NamedMorphism
2078         return self._print_NamedMorphism(NamedMorphism(
2079             morphism.domain, morphism.codomain, "id"))
2080 
2081     def _print_CompositeMorphism(self, morphism):
2082         # All components of the morphism have names and it is thus
2083         # possible to build the name of the composite.
2084         component_names_list = [self._print(Symbol(component.name)) for
2085                                 component in morphism.components]
2086         component_names_list.reverse()
2087         component_names = "\\circ ".join(component_names_list) + ":"
2088 
2089         pretty_morphism = self._print_Morphism(morphism)
2090         return component_names + pretty_morphism
2091 
2092     def _print_Category(self, morphism):
2093         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2094 
2095     def _print_Diagram(self, diagram):
2096         if not diagram.premises:
2097             # This is an empty diagram.
2098             return self._print(S.EmptySet)
2099 
2100         latex_result = self._print(diagram.premises)
2101         if diagram.conclusions:
2102             latex_result += "\\Longrightarrow %s" % \
2103                             self._print(diagram.conclusions)
2104 
2105         return latex_result
2106 
2107     def _print_DiagramGrid(self, grid):
2108         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2109 
2110         for i in range(grid.height):
2111             for j in range(grid.width):
2112                 if grid[i, j]:
2113                     latex_result += latex(grid[i, j])
2114                 latex_result += " "
2115                 if j != grid.width - 1:
2116                     latex_result += "& "
2117 
2118             if i != grid.height - 1:
2119                 latex_result += "\\\\"
2120             latex_result += "\n"
2121 
2122         latex_result += "\\end{array}\n"
2123         return latex_result
2124 
2125     def _print_FreeModule(self, M):
2126         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2127 
2128     def _print_FreeModuleElement(self, m):
2129         # Print as row vector for convenience, for now.
2130         return r"\left[ %s \right]" % ",".join(
2131             '{' + self._print(x) + '}' for x in m)
2132 
2133     def _print_SubModule(self, m):
2134         return r"\left< %s \right>" % ",".join(
2135             '{' + self._print(x) + '}' for x in m.gens)
2136 
2137     def _print_ModuleImplementedIdeal(self, m):
2138         return r"\left< %s \right>" % ",".join(
2139             '{' + self._print(x) + '}' for [x] in m._module.gens)
2140 
2141     def _print_Quaternion(self, expr):
2142         # TODO: This expression is potentially confusing,
2143         # shall we print it as `Quaternion( ... )`?
2144         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2145         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2146         return " + ".join(a)
2147 
2148     def _print_QuotientRing(self, R):
2149         # TODO nicer fractions for few generators...
2150         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2151 
2152     def _print_QuotientRingElement(self, x):
2153         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2154 
2155     def _print_QuotientModuleElement(self, m):
2156         return r"{%s} + {%s}" % (self._print(m.data),
2157                                  self._print(m.module.killed_module))
2158 
2159     def _print_QuotientModule(self, M):
2160         # TODO nicer fractions for few generators...
2161         return r"\frac{%s}{%s}" % (self._print(M.base),
2162                                    self._print(M.killed_module))
2163 
2164     def _print_MatrixHomomorphism(self, h):
2165         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2166             self._print(h.domain), self._print(h.codomain))
2167 
2168     def _print_BaseScalarField(self, field):
2169         string = field._coord_sys._names[field._index]
2170         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2171 
2172     def _print_BaseVectorField(self, field):
2173         string = field._coord_sys._names[field._index]
2174         return r'\partial_{%s}' % self._print(Symbol(string))
2175 
2176     def _print_Differential(self, diff):
2177         field = diff._form_field
2178         if hasattr(field, '_coord_sys'):
2179             string = field._coord_sys._names[field._index]
2180             return r'\mathrm{d}%s' % self._print(Symbol(string))
2181         else:
2182             return 'd(%s)' % self._print(field)
2183             string = self._print(field)
2184             return r'\mathrm{d}\left(%s\right)' % string
2185 
2186     def _print_Tr(self, p):
2187         #Todo: Handle indices
2188         contents = self._print(p.args[0])
2189         return r'\mbox{Tr}\left(%s\right)' % (contents)
2190 
2191     def _print_totient(self, expr, exp=None):
2192         if exp is not None:
2193             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2194                     self._print(exp))
2195         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2196 
2197     def _print_reduced_totient(self, expr, exp=None):
2198         if exp is not None:
2199             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2200                     self._print(exp))
2201         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2202 
2203     def _print_divisor_sigma(self, expr, exp=None):
2204         if len(expr.args) == 2:
2205             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2206                                                 (expr.args[1], expr.args[0])))
2207         else:
2208             tex = r"\left(%s\right)" % self._print(expr.args[0])
2209         if exp is not None:
2210             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2211         return r"\sigma%s" % tex
2212 
2213     def _print_udivisor_sigma(self, expr, exp=None):
2214         if len(expr.args) == 2:
2215             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2216                                                 (expr.args[1], expr.args[0])))
2217         else:
2218             tex = r"\left(%s\right)" % self._print(expr.args[0])
2219         if exp is not None:
2220             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2221         return r"\sigma^*%s" % tex
2222 
2223     def _print_primenu(self, expr, exp=None):
2224         if exp is not None:
2225             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2226                     self._print(exp))
2227         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2228 
2229     def _print_primeomega(self, expr, exp=None):
2230         if exp is not None:
2231             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2232                     self._print(exp))
2233         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Sum</method>
<code>
547     def _print_Sum(self, expr):
548         if len(expr.limits) == 1:
549             tex = r"\sum_{%s=%s}^{%s} " % \
550                 tuple([ self._print(i) for i in expr.limits[0] ])
551         else:
552             def _format_ineq(l):
553                 return r"%s \leq %s \leq %s" % \
554                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
555 
556             tex = r"\sum_{\substack{%s}} " % \
557                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
558 
559         if isinstance(expr.function, Add):
560             tex += r"\left(%s\right)" % self._print(expr.function)
561         else:
562             tex += self._print(expr.function)
563 
564         return tex

</code><intended_behavior>Given that the issue involves a summation representation (\sum) as part of the matrix product indexing, this method should correctly handle the generation of summation symbols along with their indices in LaTeX format. The _print_Sum method needs to ensure that indices and their bounds are formatted so that they do not result in syntax errors like double subscripts. It may require adjusting how indexed variables are named or displayed in the summation context. The goal is to maintain mathematical integrity and notational clarity while providing LaTeX that renders correctly in all supported environments.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": None,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137         "ln_notation": False,
138     }
139 
140     def __init__(self, settings=None):
141         Printer.__init__(self, settings)
142 
143         if 'mode' in self._settings:
144             valid_modes = ['inline', 'plain', 'equation',
145                            'equation*']
146             if self._settings['mode'] not in valid_modes:
147                 raise ValueError("'mode' must be one of 'inline', 'plain', "
148                     "'equation' or 'equation*'")
149 
150         if self._settings['fold_short_frac'] is None and \
151                 self._settings['mode'] == 'inline':
152             self._settings['fold_short_frac'] = True
153 
154         mul_symbol_table = {
155             None: r" ",
156             "ldot": r" \,.\, ",
157             "dot": r" \cdot ",
158             "times": r" \times "
159         }
160         try:
161             self._settings['mul_symbol_latex'] = \
162                 mul_symbol_table[self._settings['mul_symbol']]
163         except KeyError:
164             self._settings['mul_symbol_latex'] = \
165                 self._settings['mul_symbol']
166         try:
167             self._settings['mul_symbol_latex_numbers'] = \
168                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
169         except KeyError:
170             if (self._settings['mul_symbol'].strip() in
171                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
172                 self._settings['mul_symbol_latex_numbers'] = \
173                     mul_symbol_table['dot']
174             else:
175                 self._settings['mul_symbol_latex_numbers'] = \
176                     self._settings['mul_symbol']
177 
178         self._delim_dict = {'(': ')', '[': ']'}
179 
180     def parenthesize(self, item, level, strict=False):
181         prec_val = precedence_traditional(item)
182         if (prec_val < level) or ((not strict) and prec_val <= level):
183             return r"\left(%s\right)" % self._print(item)
184         else:
185             return self._print(item)
186 
187     def doprint(self, expr):
188         tex = Printer.doprint(self, expr)
189 
190         if self._settings['mode'] == 'plain':
191             return tex
192         elif self._settings['mode'] == 'inline':
193             return r"$%s$" % tex
194         elif self._settings['itex']:
195             return r"$$%s$$" % tex
196         else:
197             env_str = self._settings['mode']
198             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
199 
200     def _needs_brackets(self, expr):
201         """
202         Returns True if the expression needs to be wrapped in brackets when
203         printed, False otherwise. For example: a + b => True; a => False;
204         10 => False; -10 => True.
205         """
206         return not ((expr.is_Integer and expr.is_nonnegative)
207                     or (expr.is_Atom and (expr is not S.NegativeOne
208                                           and expr.is_Rational is False)))
209 
210     def _needs_function_brackets(self, expr):
211         """
212         Returns True if the expression needs to be wrapped in brackets when
213         passed as an argument to a function, False otherwise. This is a more
214         liberal version of _needs_brackets, in that many expressions which need
215         to be wrapped in brackets when added/subtracted/raised to a power do
216         not need them when passed to a function. Such an example is a*b.
217         """
218         if not self._needs_brackets(expr):
219             return False
220         else:
221             # Muls of the form a*b*c... can be folded
222             if expr.is_Mul and not self._mul_is_clean(expr):
223                 return True
224             # Pows which don't need brackets can be folded
225             elif expr.is_Pow and not self._pow_is_clean(expr):
226                 return True
227             # Add and Function always need brackets
228             elif expr.is_Add or expr.is_Function:
229                 return True
230             else:
231                 return False
232 
233     def _needs_mul_brackets(self, expr, first=False, last=False):
234         """
235         Returns True if the expression needs to be wrapped in brackets when
236         printed as part of a Mul, False otherwise. This is True for Add,
237         but also for some container objects that would not need brackets
238         when appearing last in a Mul, e.g. an Integral. ``last=True``
239         specifies that this expr is the last to appear in a Mul.
240         ``first=True`` specifies that this expr is the first to appear in a Mul.
241         """
242         from sympy import Integral, Piecewise, Product, Sum
243 
244         if expr.is_Mul:
245             if not first and _coeff_isneg(expr):
246                 return True
247         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
248             return True
249         elif expr.is_Relational:
250             return True
251         if expr.is_Piecewise:
252             return True
253         if any([expr.has(x) for x in (Mod,)]):
254             return True
255         if (not last and
256             any([expr.has(x) for x in (Integral, Product, Sum)])):
257             return True
258 
259         return False
260 
261 
262     def _needs_add_brackets(self, expr):
263         """
264         Returns True if the expression needs to be wrapped in brackets when
265         printed as part of an Add, False otherwise.  This is False for most
266         things.
267         """
268         if expr.is_Relational:
269             return True
270         if any([expr.has(x) for x in (Mod,)]):
271             return True
272         if expr.is_Add:
273             return True
274         return False
275 
276 
277     def _mul_is_clean(self, expr):
278         for arg in expr.args:
279             if arg.is_Function:
280                 return False
281         return True
282 
283     def _pow_is_clean(self, expr):
284         return not self._needs_brackets(expr.base)
285 
286     def _do_exponent(self, expr, exp):
287         if exp is not None:
288             return r"\left(%s\right)^{%s}" % (expr, exp)
289         else:
290             return expr
291 
292     def _print_Basic(self, expr):
293         l = [self._print(o) for o in expr.args]
294         return self._deal_with_super_sub(expr.__class__.__name__) + r"\left(%s\right)" % ", ".join(l)
295 
296     def _print_bool(self, e):
297         return r"\mathrm{%s}" % e
298 
299     _print_BooleanTrue = _print_bool
300     _print_BooleanFalse = _print_bool
301 
302     def _print_NoneType(self, e):
303         return r"\mathrm{%s}" % e
304 
305     def _print_Add(self, expr, order=None):
306         if self.order == 'none':
307             terms = list(expr.args)
308         else:
309             terms = self._as_ordered_terms(expr, order=order)
310 
311         tex = ""
312         for i, term in enumerate(terms):
313             if i == 0:
314                 pass
315             elif _coeff_isneg(term):
316                 tex += " - "
317                 term = -term
318             else:
319                 tex += " + "
320             term_tex = self._print(term)
321             if self._needs_add_brackets(term):
322                 term_tex = r"\left(%s\right)" % term_tex
323             tex += term_tex
324 
325         return tex
326 
327     def _print_Cycle(self, expr):
328         from sympy.combinatorics.permutations import Permutation
329         if expr.size == 0:
330             return r"\left( \right)"
331         expr = Permutation(expr)
332         expr_perm = expr.cyclic_form
333         siz = expr.size
334         if expr.array_form[-1] == siz - 1:
335             expr_perm = expr_perm + [[siz - 1]]
336         term_tex = ''
337         for i in expr_perm:
338             term_tex += str(i).replace(',', r"\;")
339         term_tex = term_tex.replace('[', r"\left( ")
340         term_tex = term_tex.replace(']', r"\right)")
341         return term_tex
342 
343     _print_Permutation = _print_Cycle
344 
345     def _print_Float(self, expr):
346         # Based off of that in StrPrinter
347         dps = prec_to_dps(expr._prec)
348         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
349 
350         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
351         # thus we use the number separator
352         separator = self._settings['mul_symbol_latex_numbers']
353 
354         if 'e' in str_real:
355             (mant, exp) = str_real.split('e')
356 
357             if exp[0] == '+':
358                 exp = exp[1:]
359 
360             return r"%s%s10^{%s}" % (mant, separator, exp)
361         elif str_real == "+inf":
362             return r"\infty"
363         elif str_real == "-inf":
364             return r"- \infty"
365         else:
366             return str_real
367 
368     def _print_Cross(self, expr):
369         vec1 = expr._expr1
370         vec2 = expr._expr2
371         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
372                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
373 
374     def _print_Curl(self, expr):
375         vec = expr._expr
376         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
377 
378     def _print_Divergence(self, expr):
379         vec = expr._expr
380         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
381 
382     def _print_Dot(self, expr):
383         vec1 = expr._expr1
384         vec2 = expr._expr2
385         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
386                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
387 
388     def _print_Gradient(self, expr):
389         func = expr._expr
390         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
391 
392     def _print_Mul(self, expr):
393         from sympy.core.power import Pow
394         from sympy.physics.units import Quantity
395         include_parens = False
396         if _coeff_isneg(expr):
397             expr = -expr
398             tex = "- "
399             if expr.is_Add:
400                 tex += "("
401                 include_parens = True
402         else:
403             tex = ""
404 
405         from sympy.simplify import fraction
406         numer, denom = fraction(expr, exact=True)
407         separator = self._settings['mul_symbol_latex']
408         numbersep = self._settings['mul_symbol_latex_numbers']
409 
410         def convert(expr):
411             if not expr.is_Mul:
412                 return str(self._print(expr))
413             else:
414                 _tex = last_term_tex = ""
415 
416                 if self.order not in ('old', 'none'):
417                     args = expr.as_ordered_factors()
418                 else:
419                     args = list(expr.args)
420 
421                 # If quantities are present append them at the back
422                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
423                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
424 
425                 for i, term in enumerate(args):
426                     term_tex = self._print(term)
427 
428                     if self._needs_mul_brackets(term, first=(i == 0),
429                                                 last=(i == len(args) - 1)):
430                         term_tex = r"\left(%s\right)" % term_tex
431 
432                     if _between_two_numbers_p[0].search(last_term_tex) and \
433                             _between_two_numbers_p[1].match(term_tex):
434                         # between two numbers
435                         _tex += numbersep
436                     elif _tex:
437                         _tex += separator
438 
439                     _tex += term_tex
440                     last_term_tex = term_tex
441                 return _tex
442 
443         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
444             # use the original expression here, since fraction() may have
445             # altered it when producing numer and denom
446             tex += convert(expr)
447 
448         else:
449             snumer = convert(numer)
450             sdenom = convert(denom)
451             ldenom = len(sdenom.split())
452             ratio = self._settings['long_frac_ratio']
453             if self._settings['fold_short_frac'] \
454                    and ldenom <= 2 and not "^" in sdenom:
455                 # handle short fractions
456                 if self._needs_mul_brackets(numer, last=False):
457                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
458                 else:
459                     tex += r"%s / %s" % (snumer, sdenom)
460             elif ratio is not None and \
461                     len(snumer.split()) > ratio*ldenom:
462                 # handle long fractions
463                 if self._needs_mul_brackets(numer, last=True):
464                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
465                         % (sdenom, separator, snumer)
466                 elif numer.is_Mul:
467                     # split a long numerator
468                     a = S.One
469                     b = S.One
470                     for x in numer.args:
471                         if self._needs_mul_brackets(x, last=False) or \
472                                 len(convert(a*x).split()) > ratio*ldenom or \
473                                 (b.is_commutative is x.is_commutative is False):
474                             b *= x
475                         else:
476                             a *= x
477                     if self._needs_mul_brackets(b, last=True):
478                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
479                             % (convert(a), sdenom, separator, convert(b))
480                     else:
481                         tex += r"\frac{%s}{%s}%s%s" \
482                             % (convert(a), sdenom, separator, convert(b))
483                 else:
484                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
485             else:
486                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
487 
488         if include_parens:
489             tex += ")"
490         return tex
491 
492     def _print_Pow(self, expr):
493         # Treat x**Rational(1,n) as special case
494         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
495             base = self._print(expr.base)
496             expq = expr.exp.q
497 
498             if expq == 2:
499                 tex = r"\sqrt{%s}" % base
500             elif self._settings['itex']:
501                 tex = r"\root{%d}{%s}" % (expq, base)
502             else:
503                 tex = r"\sqrt[%d]{%s}" % (expq, base)
504 
505             if expr.exp.is_negative:
506                 return r"\frac{1}{%s}" % tex
507             else:
508                 return tex
509         elif self._settings['fold_frac_powers'] \
510             and expr.exp.is_Rational \
511                 and expr.exp.q != 1:
512             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
513             # issue #12886: add parentheses for superscripts raised to powers
514             if '^' in base and expr.base.is_Symbol:
515                 base = r"\left(%s\right)" % base
516             if expr.base.is_Function:
517                 return self._print(expr.base, exp="%s/%s" % (p, q))
518             return r"%s^{%s/%s}" % (base, p, q)
519         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
520             # special case for 1^(-x), issue 9216
521             if expr.base == 1:
522                 return r"%s^{%s}" % (expr.base, expr.exp)
523             # things like 1/x
524             return self._print_Mul(expr)
525         else:
526             if expr.base.is_Function:
527                 return self._print(expr.base, exp=self._print(expr.exp))
528             else:
529                 tex = r"%s^{%s}"
530                 exp = self._print(expr.exp)
531                 # issue #12886: add parentheses around superscripts raised to powers
532                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
533                 if '^' in base and expr.base.is_Symbol:
534                     base = r"\left(%s\right)" % base
535                 elif isinstance(expr.base, Derivative
536                         ) and base.startswith(r'\left('
537                         ) and re.match(r'\\left\(\\d?d?dot', base
538                         ) and base.endswith(r'\right)'):
539                     # don't use parentheses around dotted derivative
540                     base = base[6: -7]  # remove outermost added parens
541 
542                 return tex % (base, exp)
543 
544     def _print_UnevaluatedExpr(self, expr):
545         return self._print(expr.args[0])
546 
547     def _print_Sum(self, expr):
548         if len(expr.limits) == 1:
549             tex = r"\sum_{%s=%s}^{%s} " % \
550                 tuple([ self._print(i) for i in expr.limits[0] ])
551         else:
552             def _format_ineq(l):
553                 return r"%s \leq %s \leq %s" % \
554                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
555 
556             tex = r"\sum_{\substack{%s}} " % \
557                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
558 
559         if isinstance(expr.function, Add):
560             tex += r"\left(%s\right)" % self._print(expr.function)
561         else:
562             tex += self._print(expr.function)
563 
564         return tex
565 
566     def _print_Product(self, expr):
567         if len(expr.limits) == 1:
568             tex = r"\prod_{%s=%s}^{%s} " % \
569                 tuple([ self._print(i) for i in expr.limits[0] ])
570         else:
571             def _format_ineq(l):
572                 return r"%s \leq %s \leq %s" % \
573                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
574 
575             tex = r"\prod_{\substack{%s}} " % \
576                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
577 
578         if isinstance(expr.function, Add):
579             tex += r"\left(%s\right)" % self._print(expr.function)
580         else:
581             tex += self._print(expr.function)
582 
583         return tex
584 
585     def _print_BasisDependent(self, expr):
586         from sympy.vector import Vector
587 
588         o1 = []
589         if expr == expr.zero:
590             return expr.zero._latex_form
591         if isinstance(expr, Vector):
592             items = expr.separate().items()
593         else:
594             items = [(0, expr)]
595 
596         for system, vect in items:
597             inneritems = list(vect.components.items())
598             inneritems.sort(key = lambda x:x[0].__str__())
599             for k, v in inneritems:
600                 if v == 1:
601                     o1.append(' + ' + k._latex_form)
602                 elif v == -1:
603                     o1.append(' - ' + k._latex_form)
604                 else:
605                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
606                     o1.append(' + ' + arg_str + k._latex_form)
607 
608         outstr = (''.join(o1))
609         if outstr[1] != '-':
610             outstr = outstr[3:]
611         else:
612             outstr = outstr[1:]
613         return outstr
614 
615     def _print_Indexed(self, expr):
616         tex_base = self._print(expr.base)
617         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
618             map(self._print, expr.indices))
619         return tex
620 
621     def _print_IndexedBase(self, expr):
622         return self._print(expr.label)
623 
624     def _print_Derivative(self, expr):
625         if requires_partial(expr):
626             diff_symbol = r'\partial'
627         else:
628             diff_symbol = r'd'
629 
630         tex = ""
631         dim = 0
632         for x, num in reversed(expr.variable_count):
633             dim += num
634             if num == 1:
635                 tex += r"%s %s" % (diff_symbol, self._print(x))
636             else:
637                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
638 
639         if dim == 1:
640             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
641         else:
642             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
643 
644         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
645 
646     def _print_Subs(self, subs):
647         expr, old, new = subs.args
648         latex_expr = self._print(expr)
649         latex_old = (self._print(e) for e in old)
650         latex_new = (self._print(e) for e in new)
651         latex_subs = r'\\ '.join(
652             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
653         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
654 
655     def _print_Integral(self, expr):
656         tex, symbols = "", []
657 
658         # Only up to \iiiint exists
659         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
660             # Use len(expr.limits)-1 so that syntax highlighters don't think
661             # \" is an escaped quote
662             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
663             symbols = [r"\, d%s" % self._print(symbol[0])
664                        for symbol in expr.limits]
665 
666         else:
667             for lim in reversed(expr.limits):
668                 symbol = lim[0]
669                 tex += r"\int"
670 
671                 if len(lim) > 1:
672                     if self._settings['mode'] in ['equation', 'equation*'] \
673                             and not self._settings['itex']:
674                         tex += r"\limits"
675 
676                     if len(lim) == 3:
677                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
678                                                self._print(lim[2]))
679                     if len(lim) == 2:
680                         tex += "^{%s}" % (self._print(lim[1]))
681 
682                 symbols.insert(0, r"\, d%s" % self._print(symbol))
683 
684         return r"%s %s%s" % (tex,
685             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
686 
687     def _print_Limit(self, expr):
688         e, z, z0, dir = expr.args
689 
690         tex = r"\lim_{%s \to " % self._print(z)
691         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
692             tex += r"%s}" % self._print(z0)
693         else:
694             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
695 
696         if isinstance(e, AssocOp):
697             return r"%s\left(%s\right)" % (tex, self._print(e))
698         else:
699             return r"%s %s" % (tex, self._print(e))
700 
701     def _hprint_Function(self, func):
702         r'''
703         Logic to decide how to render a function to latex
704           - if it is a recognized latex name, use the appropriate latex command
705           - if it is a single letter, just use that letter
706           - if it is a longer name, then put \operatorname{} around it and be
707             mindful of undercores in the name
708         '''
709         func = self._deal_with_super_sub(func)
710         if func in accepted_latex_functions:
711             name = r"\%s" % func
712         elif len(func) == 1 or func.startswith('\\'):
713             name = func
714         else:
715             name = r"\operatorname{%s}" % func
716         return name
717 
718     def _print_Function(self, expr, exp=None):
719         r'''
720         Render functions to LaTeX, handling functions that LaTeX knows about
721         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
722         For single-letter function names, render them as regular LaTeX math
723         symbols. For multi-letter function names that LaTeX does not know
724         about, (e.g., Li, sech) use \operatorname{} so that the function name
725         is rendered in Roman font and LaTeX handles spacing properly.
726 
727         expr is the expression involving the function
728         exp is an exponent
729         '''
730         func = expr.func.__name__
731         if hasattr(self, '_print_' + func) and \
732             not isinstance(expr, AppliedUndef):
733             return getattr(self, '_print_' + func)(expr, exp)
734         else:
735             args = [ str(self._print(arg)) for arg in expr.args ]
736             # How inverse trig functions should be displayed, formats are:
737             # abbreviated: asin, full: arcsin, power: sin^-1
738             inv_trig_style = self._settings['inv_trig_style']
739             # If we are dealing with a power-style inverse trig function
740             inv_trig_power_case = False
741             # If it is applicable to fold the argument brackets
742             can_fold_brackets = self._settings['fold_func_brackets'] and \
743                 len(args) == 1 and \
744                 not self._needs_function_brackets(expr.args[0])
745 
746             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
747 
748             # If the function is an inverse trig function, handle the style
749             if func in inv_trig_table:
750                 if inv_trig_style == "abbreviated":
751                     func = func
752                 elif inv_trig_style == "full":
753                     func = "arc" + func[1:]
754                 elif inv_trig_style == "power":
755                     func = func[1:]
756                     inv_trig_power_case = True
757 
758                     # Can never fold brackets if we're raised to a power
759                     if exp is not None:
760                         can_fold_brackets = False
761 
762             if inv_trig_power_case:
763                 if func in accepted_latex_functions:
764                     name = r"\%s^{-1}" % func
765                 else:
766                     name = r"\operatorname{%s}^{-1}" % func
767             elif exp is not None:
768                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
769             else:
770                 name = self._hprint_Function(func)
771 
772             if can_fold_brackets:
773                 if func in accepted_latex_functions:
774                     # Wrap argument safely to avoid parse-time conflicts
775                     # with the function name itself
776                     name += r" {%s}"
777                 else:
778                     name += r"%s"
779             else:
780                 name += r"{\left (%s \right )}"
781 
782             if inv_trig_power_case and exp is not None:
783                 name += r"^{%s}" % exp
784 
785             return name % ",".join(args)
786 
787     def _print_UndefinedFunction(self, expr):
788         return self._hprint_Function(str(expr))
789 
790     @property
791     def _special_function_classes(self):
792         from sympy.functions.special.tensor_functions import KroneckerDelta
793         from sympy.functions.special.gamma_functions import gamma, lowergamma
794         from sympy.functions.special.beta_functions import beta
795         from sympy.functions.special.delta_functions import DiracDelta
796         from sympy.functions.special.error_functions import Chi
797         return {KroneckerDelta: r'\delta',
798                 gamma:  r'\Gamma',
799                 lowergamma: r'\gamma',
800                 beta: r'\operatorname{B}',
801                 DiracDelta: r'\delta',
802                 Chi: r'\operatorname{Chi}'}
803 
804     def _print_FunctionClass(self, expr):
805         for cls in self._special_function_classes:
806             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
807                 return self._special_function_classes[cls]
808         return self._hprint_Function(str(expr))
809 
810     def _print_Lambda(self, expr):
811         symbols, expr = expr.args
812 
813         if len(symbols) == 1:
814             symbols = self._print(symbols[0])
815         else:
816             symbols = self._print(tuple(symbols))
817 
818         args = (symbols, self._print(expr))
819         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
820 
821         return tex
822 
823     def _hprint_variadic_function(self, expr, exp=None):
824         args = sorted(expr.args, key=default_sort_key)
825         texargs = [r"%s" % self._print(symbol) for symbol in args]
826         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()), ", ".join(texargs))
827         if exp is not None:
828             return r"%s^{%s}" % (tex, exp)
829         else:
830             return tex
831 
832     _print_Min = _print_Max = _hprint_variadic_function
833 
834     def _print_floor(self, expr, exp=None):
835         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
836 
837         if exp is not None:
838             return r"%s^{%s}" % (tex, exp)
839         else:
840             return tex
841 
842     def _print_ceiling(self, expr, exp=None):
843         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
844 
845         if exp is not None:
846             return r"%s^{%s}" % (tex, exp)
847         else:
848             return tex
849 
850     def _print_log(self, expr, exp=None):
851         if not self._settings["ln_notation"]:
852             tex = r"\log{\left (%s \right )}" % self._print(expr.args[0])
853         else:
854             tex = r"\ln{\left (%s \right )}" % self._print(expr.args[0])
855 
856         if exp is not None:
857             return r"%s^{%s}" % (tex, exp)
858         else:
859             return tex
860 
861     def _print_Abs(self, expr, exp=None):
862         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
863 
864         if exp is not None:
865             return r"%s^{%s}" % (tex, exp)
866         else:
867             return tex
868     _print_Determinant = _print_Abs
869 
870     def _print_re(self, expr, exp=None):
871         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
872 
873         return self._do_exponent(tex, exp)
874 
875     def _print_im(self, expr, exp=None):
876         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
877 
878         return self._do_exponent(tex, exp)
879 
880     def _print_Not(self, e):
881         from sympy import Equivalent, Implies
882         if isinstance(e.args[0], Equivalent):
883             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
884         if isinstance(e.args[0], Implies):
885             return self._print_Implies(e.args[0], r"\not\Rightarrow")
886         if (e.args[0].is_Boolean):
887             return r"\neg (%s)" % self._print(e.args[0])
888         else:
889             return r"\neg %s" % self._print(e.args[0])
890 
891     def _print_LogOp(self, args, char):
892         arg = args[0]
893         if arg.is_Boolean and not arg.is_Not:
894             tex = r"\left(%s\right)" % self._print(arg)
895         else:
896             tex = r"%s" % self._print(arg)
897 
898         for arg in args[1:]:
899             if arg.is_Boolean and not arg.is_Not:
900                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
901             else:
902                 tex += r" %s %s" % (char, self._print(arg))
903 
904         return tex
905 
906     def _print_And(self, e):
907         args = sorted(e.args, key=default_sort_key)
908         return self._print_LogOp(args, r"\wedge")
909 
910     def _print_Or(self, e):
911         args = sorted(e.args, key=default_sort_key)
912         return self._print_LogOp(args, r"\vee")
913 
914     def _print_Xor(self, e):
915         args = sorted(e.args, key=default_sort_key)
916         return self._print_LogOp(args, r"\veebar")
917 
918     def _print_Implies(self, e, altchar=None):
919         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
920 
921     def _print_Equivalent(self, e, altchar=None):
922         args = sorted(e.args, key=default_sort_key)
923         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
924 
925     def _print_conjugate(self, expr, exp=None):
926         tex = r"\overline{%s}" % self._print(expr.args[0])
927 
928         if exp is not None:
929             return r"%s^{%s}" % (tex, exp)
930         else:
931             return tex
932 
933     def _print_polar_lift(self, expr, exp=None):
934         func = r"\operatorname{polar\_lift}"
935         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
936 
937         if exp is not None:
938             return r"%s^{%s}%s" % (func, exp, arg)
939         else:
940             return r"%s%s" % (func, arg)
941 
942     def _print_ExpBase(self, expr, exp=None):
943         # TODO should exp_polar be printed differently?
944         #      what about exp_polar(0), exp_polar(1)?
945         tex = r"e^{%s}" % self._print(expr.args[0])
946         return self._do_exponent(tex, exp)
947 
948     def _print_elliptic_k(self, expr, exp=None):
949         tex = r"\left(%s\right)" % self._print(expr.args[0])
950         if exp is not None:
951             return r"K^{%s}%s" % (exp, tex)
952         else:
953             return r"K%s" % tex
954 
955     def _print_elliptic_f(self, expr, exp=None):
956         tex = r"\left(%s\middle| %s\right)" % \
957             (self._print(expr.args[0]), self._print(expr.args[1]))
958         if exp is not None:
959             return r"F^{%s}%s" % (exp, tex)
960         else:
961             return r"F%s" % tex
962 
963     def _print_elliptic_e(self, expr, exp=None):
964         if len(expr.args) == 2:
965             tex = r"\left(%s\middle| %s\right)" % \
966                 (self._print(expr.args[0]), self._print(expr.args[1]))
967         else:
968             tex = r"\left(%s\right)" % self._print(expr.args[0])
969         if exp is not None:
970             return r"E^{%s}%s" % (exp, tex)
971         else:
972             return r"E%s" % tex
973 
974     def _print_elliptic_pi(self, expr, exp=None):
975         if len(expr.args) == 3:
976             tex = r"\left(%s; %s\middle| %s\right)" % \
977                 (self._print(expr.args[0]), self._print(expr.args[1]), \
978                  self._print(expr.args[2]))
979         else:
980             tex = r"\left(%s\middle| %s\right)" % \
981                 (self._print(expr.args[0]), self._print(expr.args[1]))
982         if exp is not None:
983             return r"\Pi^{%s}%s" % (exp, tex)
984         else:
985             return r"\Pi%s" % tex
986 
987     def _print_beta(self, expr, exp=None):
988         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
989                                         self._print(expr.args[1]))
990 
991         if exp is not None:
992             return r"\operatorname{B}^{%s}%s" % (exp, tex)
993         else:
994             return r"\operatorname{B}%s" % tex
995 
996     def _print_uppergamma(self, expr, exp=None):
997         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
998                                         self._print(expr.args[1]))
999 
1000         if exp is not None:
1001             return r"\Gamma^{%s}%s" % (exp, tex)
1002         else:
1003             return r"\Gamma%s" % tex
1004 
1005     def _print_lowergamma(self, expr, exp=None):
1006         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1007                                         self._print(expr.args[1]))
1008 
1009         if exp is not None:
1010             return r"\gamma^{%s}%s" % (exp, tex)
1011         else:
1012             return r"\gamma%s" % tex
1013 
1014     def _hprint_one_arg_func(self, expr, exp=None):
1015         tex = r"\left(%s\right)" % self._print(expr.args[0])
1016 
1017         if exp is not None:
1018             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1019         else:
1020             return r"%s%s" % (self._print(expr.func), tex)
1021 
1022     _print_gamma = _hprint_one_arg_func
1023 
1024     def _print_Chi(self, expr, exp=None):
1025         tex = r"\left(%s\right)" % self._print(expr.args[0])
1026 
1027         if exp is not None:
1028             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1029         else:
1030             return r"\operatorname{Chi}%s" % tex
1031 
1032     def _print_expint(self, expr, exp=None):
1033         tex = r"\left(%s\right)" % self._print(expr.args[1])
1034         nu = self._print(expr.args[0])
1035 
1036         if exp is not None:
1037             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1038         else:
1039             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1040 
1041     def _print_fresnels(self, expr, exp=None):
1042         tex = r"\left(%s\right)" % self._print(expr.args[0])
1043 
1044         if exp is not None:
1045             return r"S^{%s}%s" % (exp, tex)
1046         else:
1047             return r"S%s" % tex
1048 
1049     def _print_fresnelc(self, expr, exp=None):
1050         tex = r"\left(%s\right)" % self._print(expr.args[0])
1051 
1052         if exp is not None:
1053             return r"C^{%s}%s" % (exp, tex)
1054         else:
1055             return r"C%s" % tex
1056 
1057     def _print_subfactorial(self, expr, exp=None):
1058         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1059 
1060         if exp is not None:
1061             return r"%s^{%s}" % (tex, exp)
1062         else:
1063             return tex
1064 
1065     def _print_factorial(self, expr, exp=None):
1066         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1067 
1068         if exp is not None:
1069             return r"%s^{%s}" % (tex, exp)
1070         else:
1071             return tex
1072 
1073     def _print_factorial2(self, expr, exp=None):
1074         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1075 
1076         if exp is not None:
1077             return r"%s^{%s}" % (tex, exp)
1078         else:
1079             return tex
1080 
1081     def _print_binomial(self, expr, exp=None):
1082         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1083                                      self._print(expr.args[1]))
1084 
1085         if exp is not None:
1086             return r"%s^{%s}" % (tex, exp)
1087         else:
1088             return tex
1089 
1090     def _print_RisingFactorial(self, expr, exp=None):
1091         n, k = expr.args
1092         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1093 
1094         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1095 
1096         return self._do_exponent(tex, exp)
1097 
1098     def _print_FallingFactorial(self, expr, exp=None):
1099         n, k = expr.args
1100         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1101 
1102         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1103 
1104         return self._do_exponent(tex, exp)
1105 
1106     def _hprint_BesselBase(self, expr, exp, sym):
1107         tex = r"%s" % (sym)
1108 
1109         need_exp = False
1110         if exp is not None:
1111             if tex.find('^') == -1:
1112                 tex = r"%s^{%s}" % (tex, self._print(exp))
1113             else:
1114                 need_exp = True
1115 
1116         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1117                                            self._print(expr.argument))
1118 
1119         if need_exp:
1120             tex = self._do_exponent(tex, exp)
1121         return tex
1122 
1123     def _hprint_vec(self, vec):
1124         if len(vec) == 0:
1125             return ""
1126         s = ""
1127         for i in vec[:-1]:
1128             s += "%s, " % self._print(i)
1129         s += self._print(vec[-1])
1130         return s
1131 
1132     def _print_besselj(self, expr, exp=None):
1133         return self._hprint_BesselBase(expr, exp, 'J')
1134 
1135     def _print_besseli(self, expr, exp=None):
1136         return self._hprint_BesselBase(expr, exp, 'I')
1137 
1138     def _print_besselk(self, expr, exp=None):
1139         return self._hprint_BesselBase(expr, exp, 'K')
1140 
1141     def _print_bessely(self, expr, exp=None):
1142         return self._hprint_BesselBase(expr, exp, 'Y')
1143 
1144     def _print_yn(self, expr, exp=None):
1145         return self._hprint_BesselBase(expr, exp, 'y')
1146 
1147     def _print_jn(self, expr, exp=None):
1148         return self._hprint_BesselBase(expr, exp, 'j')
1149 
1150     def _print_hankel1(self, expr, exp=None):
1151         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1152 
1153     def _print_hankel2(self, expr, exp=None):
1154         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1155 
1156     def _print_hn1(self, expr, exp=None):
1157         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1158 
1159     def _print_hn2(self, expr, exp=None):
1160         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1161 
1162     def _hprint_airy(self, expr, exp=None, notation=""):
1163         tex = r"\left(%s\right)" % self._print(expr.args[0])
1164 
1165         if exp is not None:
1166             return r"%s^{%s}%s" % (notation, exp, tex)
1167         else:
1168             return r"%s%s" % (notation, tex)
1169 
1170     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1171         tex = r"\left(%s\right)" % self._print(expr.args[0])
1172 
1173         if exp is not None:
1174             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1175         else:
1176             return r"%s^\prime%s" % (notation, tex)
1177 
1178     def _print_airyai(self, expr, exp=None):
1179         return self._hprint_airy(expr, exp, 'Ai')
1180 
1181     def _print_airybi(self, expr, exp=None):
1182         return self._hprint_airy(expr, exp, 'Bi')
1183 
1184     def _print_airyaiprime(self, expr, exp=None):
1185         return self._hprint_airy_prime(expr, exp, 'Ai')
1186 
1187     def _print_airybiprime(self, expr, exp=None):
1188         return self._hprint_airy_prime(expr, exp, 'Bi')
1189 
1190     def _print_hyper(self, expr, exp=None):
1191         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1192               r"\middle| {%s} \right)}" % \
1193             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1194               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1195               self._print(expr.argument))
1196 
1197         if exp is not None:
1198             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1199         return tex
1200 
1201     def _print_meijerg(self, expr, exp=None):
1202         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1203               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1204             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1205               self._print(len(expr.bm)), self._print(len(expr.an)),
1206               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1207               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1208               self._print(expr.argument))
1209 
1210         if exp is not None:
1211             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1212         return tex
1213 
1214     def _print_dirichlet_eta(self, expr, exp=None):
1215         tex = r"\left(%s\right)" % self._print(expr.args[0])
1216         if exp is not None:
1217             return r"\eta^{%s}%s" % (self._print(exp), tex)
1218         return r"\eta%s" % tex
1219 
1220     def _print_zeta(self, expr, exp=None):
1221         if len(expr.args) == 2:
1222             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1223         else:
1224             tex = r"\left(%s\right)" % self._print(expr.args[0])
1225         if exp is not None:
1226             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1227         return r"\zeta%s" % tex
1228 
1229     def _print_lerchphi(self, expr, exp=None):
1230         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1231         if exp is None:
1232             return r"\Phi%s" % tex
1233         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1234 
1235     def _print_polylog(self, expr, exp=None):
1236         s, z = map(self._print, expr.args)
1237         tex = r"\left(%s\right)" % z
1238         if exp is None:
1239             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1240         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1241 
1242     def _print_jacobi(self, expr, exp=None):
1243         n, a, b, x = map(self._print, expr.args)
1244         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1245         if exp is not None:
1246             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1247         return tex
1248 
1249     def _print_gegenbauer(self, expr, exp=None):
1250         n, a, x = map(self._print, expr.args)
1251         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1252         if exp is not None:
1253             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1254         return tex
1255 
1256     def _print_chebyshevt(self, expr, exp=None):
1257         n, x = map(self._print, expr.args)
1258         tex = r"T_{%s}\left(%s\right)" % (n, x)
1259         if exp is not None:
1260             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1261         return tex
1262 
1263     def _print_chebyshevu(self, expr, exp=None):
1264         n, x = map(self._print, expr.args)
1265         tex = r"U_{%s}\left(%s\right)" % (n, x)
1266         if exp is not None:
1267             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1268         return tex
1269 
1270     def _print_legendre(self, expr, exp=None):
1271         n, x = map(self._print, expr.args)
1272         tex = r"P_{%s}\left(%s\right)" % (n, x)
1273         if exp is not None:
1274             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1275         return tex
1276 
1277     def _print_assoc_legendre(self, expr, exp=None):
1278         n, a, x = map(self._print, expr.args)
1279         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1280         if exp is not None:
1281             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1282         return tex
1283 
1284     def _print_hermite(self, expr, exp=None):
1285         n, x = map(self._print, expr.args)
1286         tex = r"H_{%s}\left(%s\right)" % (n, x)
1287         if exp is not None:
1288             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1289         return tex
1290 
1291     def _print_laguerre(self, expr, exp=None):
1292         n, x = map(self._print, expr.args)
1293         tex = r"L_{%s}\left(%s\right)" % (n, x)
1294         if exp is not None:
1295             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1296         return tex
1297 
1298     def _print_assoc_laguerre(self, expr, exp=None):
1299         n, a, x = map(self._print, expr.args)
1300         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1301         if exp is not None:
1302             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1303         return tex
1304 
1305     def _print_Ynm(self, expr, exp=None):
1306         n, m, theta, phi = map(self._print, expr.args)
1307         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1308         if exp is not None:
1309             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1310         return tex
1311 
1312     def _print_Znm(self, expr, exp=None):
1313         n, m, theta, phi = map(self._print, expr.args)
1314         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1315         if exp is not None:
1316             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1317         return tex
1318 
1319     def _print_Rational(self, expr):
1320         if expr.q != 1:
1321             sign = ""
1322             p = expr.p
1323             if expr.p < 0:
1324                 sign = "- "
1325                 p = -p
1326             if self._settings['fold_short_frac']:
1327                 return r"%s%d / %d" % (sign, p, expr.q)
1328             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1329         else:
1330             return self._print(expr.p)
1331 
1332     def _print_Order(self, expr):
1333         s = self._print(expr.expr)
1334         if expr.point and any(p != S.Zero for p in expr.point) or \
1335            len(expr.variables) > 1:
1336             s += '; '
1337             if len(expr.variables) > 1:
1338                 s += self._print(expr.variables)
1339             elif len(expr.variables):
1340                 s += self._print(expr.variables[0])
1341             s += r'\rightarrow '
1342             if len(expr.point) > 1:
1343                 s += self._print(expr.point)
1344             else:
1345                 s += self._print(expr.point[0])
1346         return r"O\left(%s\right)" % s
1347 
1348     def _print_Symbol(self, expr):
1349         if expr in self._settings['symbol_names']:
1350             return self._settings['symbol_names'][expr]
1351 
1352         return self._deal_with_super_sub(expr.name) if \
1353             '\\' not in expr.name else expr.name
1354 
1355     _print_RandomSymbol = _print_Symbol
1356     _print_MatrixSymbol = _print_Symbol
1357 
1358     def _deal_with_super_sub(self, string):
1359         if '{' in string:
1360             return string
1361 
1362         name, supers, subs = split_super_sub(string)
1363 
1364         name = translate(name)
1365         supers = [translate(sup) for sup in supers]
1366         subs = [translate(sub) for sub in subs]
1367 
1368         # glue all items together:
1369         if len(supers) > 0:
1370             name += "^{%s}" % " ".join(supers)
1371         if len(subs) > 0:
1372             name += "_{%s}" % " ".join(subs)
1373 
1374         return name
1375 
1376     def _print_Relational(self, expr):
1377         if self._settings['itex']:
1378             gt = r"\gt"
1379             lt = r"\lt"
1380         else:
1381             gt = ">"
1382             lt = "<"
1383 
1384         charmap = {
1385             "==": "=",
1386             ">": gt,
1387             "<": lt,
1388             ">=": r"\geq",
1389             "<=": r"\leq",
1390             "!=": r"\neq",
1391         }
1392 
1393         return "%s %s %s" % (self._print(expr.lhs),
1394             charmap[expr.rel_op], self._print(expr.rhs))
1395 
1396     def _print_Piecewise(self, expr):
1397         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1398                    for e, c in expr.args[:-1]]
1399         if expr.args[-1].cond == true:
1400             ecpairs.append(r"%s & \text{otherwise}" %
1401                            self._print(expr.args[-1].expr))
1402         else:
1403             ecpairs.append(r"%s & \text{for}\: %s" %
1404                            (self._print(expr.args[-1].expr),
1405                             self._print(expr.args[-1].cond)))
1406         tex = r"\begin{cases} %s \end{cases}"
1407         return tex % r" \\".join(ecpairs)
1408 
1409     def _print_MatrixBase(self, expr):
1410         lines = []
1411 
1412         for line in range(expr.rows):  # horrible, should be 'rows'
1413             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1414 
1415         mat_str = self._settings['mat_str']
1416         if mat_str is None:
1417             if self._settings['mode'] == 'inline':
1418                 mat_str = 'smallmatrix'
1419             else:
1420                 if (expr.cols <= 10) is True:
1421                     mat_str = 'matrix'
1422                 else:
1423                     mat_str = 'array'
1424 
1425         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1426         out_str = out_str.replace('%MATSTR%', mat_str)
1427         if mat_str == 'array':
1428             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1429         if self._settings['mat_delim']:
1430             left_delim = self._settings['mat_delim']
1431             right_delim = self._delim_dict[left_delim]
1432             out_str = r'\left' + left_delim + out_str + \
1433                       r'\right' + right_delim
1434         return out_str % r"\\".join(lines)
1435     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1436                            = _print_Matrix \
1437                            = _print_MatrixBase
1438 
1439     def _print_MatrixElement(self, expr):
1440         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1441             + '_{%s, %s}' % (expr.i, expr.j)
1442 
1443     def _print_MatrixSlice(self, expr):
1444         def latexslice(x):
1445             x = list(x)
1446             if x[2] == 1:
1447                 del x[2]
1448             if x[1] == x[0] + 1:
1449                 del x[1]
1450             if x[0] == 0:
1451                 x[0] = ''
1452             return ':'.join(map(self._print, x))
1453         return (self._print(expr.parent) + r'\left[' +
1454                 latexslice(expr.rowslice) + ', ' +
1455                 latexslice(expr.colslice) + r'\right]')
1456 
1457     def _print_BlockMatrix(self, expr):
1458         return self._print(expr.blocks)
1459 
1460     def _print_Transpose(self, expr):
1461         mat = expr.arg
1462         from sympy.matrices import MatrixSymbol
1463         if not isinstance(mat, MatrixSymbol):
1464             return r"\left(%s\right)^T" % self._print(mat)
1465         else:
1466             return "%s^T" % self._print(mat)
1467 
1468     def _print_Trace(self, expr):
1469         mat = expr.arg
1470         return r"\mathrm{tr}\left (%s \right )" % self._print(mat)
1471 
1472     def _print_Adjoint(self, expr):
1473         mat = expr.arg
1474         from sympy.matrices import MatrixSymbol
1475         if not isinstance(mat, MatrixSymbol):
1476             return r"\left(%s\right)^\dagger" % self._print(mat)
1477         else:
1478             return r"%s^\dagger" % self._print(mat)
1479 
1480     def _print_MatMul(self, expr):
1481         from sympy import Add, MatAdd, HadamardProduct, MatMul, Mul
1482 
1483         parens = lambda x: self.parenthesize(x, precedence_traditional(expr), False)
1484 
1485         args = expr.args
1486         if isinstance(args[0], Mul):
1487             args = args[0].as_ordered_factors() + list(args[1:])
1488         else:
1489             args = list(args)
1490 
1491         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1492             if args[0] == -1:
1493                 args = args[1:]
1494             else:
1495                 args[0] = -args[0]
1496             return '- ' + ' '.join(map(parens, args))
1497         else:
1498             return ' '.join(map(parens, args))
1499 
1500     def _print_Mod(self, expr, exp=None):
1501         if exp is not None:
1502             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1503                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1504         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1505                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1506 
1507     def _print_HadamardProduct(self, expr):
1508         from sympy import Add, MatAdd, MatMul
1509 
1510         def parens(x):
1511             if isinstance(x, (Add, MatAdd, MatMul)):
1512                 return r"\left(%s\right)" % self._print(x)
1513             return self._print(x)
1514         return r' \circ '.join(map(parens, expr.args))
1515 
1516     def _print_KroneckerProduct(self, expr):
1517         from sympy import Add, MatAdd, MatMul
1518 
1519         def parens(x):
1520             if isinstance(x, (Add, MatAdd, MatMul)):
1521                 return r"\left(%s\right)" % self._print(x)
1522             return self._print(x)
1523         return r' \otimes '.join(map(parens, expr.args))
1524 
1525     def _print_MatPow(self, expr):
1526         base, exp = expr.base, expr.exp
1527         from sympy.matrices import MatrixSymbol
1528         if not isinstance(base, MatrixSymbol):
1529             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1530         else:
1531             return "%s^{%s}" % (self._print(base), self._print(exp))
1532 
1533     def _print_ZeroMatrix(self, Z):
1534         return r"\mathbb{0}"
1535 
1536     def _print_Identity(self, I):
1537         return r"\mathbb{I}"
1538 
1539     def _print_NDimArray(self, expr):
1540 
1541         if expr.rank() == 0:
1542             return self._print(expr[()])
1543 
1544         mat_str = self._settings['mat_str']
1545         if mat_str is None:
1546             if self._settings['mode'] == 'inline':
1547                 mat_str = 'smallmatrix'
1548             else:
1549                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1550                     mat_str = 'matrix'
1551                 else:
1552                     mat_str = 'array'
1553         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1554         block_str = block_str.replace('%MATSTR%', mat_str)
1555         if self._settings['mat_delim']:
1556             left_delim = self._settings['mat_delim']
1557             right_delim = self._delim_dict[left_delim]
1558             block_str = r'\left' + left_delim + block_str + \
1559                       r'\right' + right_delim
1560 
1561         if expr.rank() == 0:
1562             return block_str % ""
1563 
1564         level_str = [[]] + [[] for i in range(expr.rank())]
1565         shape_ranges = [list(range(i)) for i in expr.shape]
1566         for outer_i in itertools.product(*shape_ranges):
1567             level_str[-1].append(self._print(expr[outer_i]))
1568             even = True
1569             for back_outer_i in range(expr.rank()-1, -1, -1):
1570                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1571                     break
1572                 if even:
1573                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1574                 else:
1575                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1576                     if len(level_str[back_outer_i+1]) == 1:
1577                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1578                 even = not even
1579                 level_str[back_outer_i+1] = []
1580 
1581         out_str = level_str[0][0]
1582 
1583         if expr.rank() % 2 == 1:
1584             out_str = block_str % out_str
1585 
1586         return out_str
1587 
1588     _print_ImmutableDenseNDimArray = _print_NDimArray
1589     _print_ImmutableSparseNDimArray = _print_NDimArray
1590     _print_MutableDenseNDimArray = _print_NDimArray
1591     _print_MutableSparseNDimArray = _print_NDimArray
1592 
1593     def _printer_tensor_indices(self, name, indices, index_map={}):
1594         out_str = self._print(name)
1595         last_valence = None
1596         prev_map = None
1597         for index in indices:
1598             new_valence = index.is_up
1599             if ((index in index_map) or prev_map) and last_valence == new_valence:
1600                 out_str += ","
1601             if last_valence != new_valence:
1602                 if last_valence is not None:
1603                     out_str += "}"
1604                 if index.is_up:
1605                     out_str += "{}^{"
1606                 else:
1607                     out_str += "{}_{"
1608             out_str += self._print(index.args[0])
1609             if index in index_map:
1610                 out_str += "="
1611                 out_str += self._print(index_map[index])
1612                 prev_map = True
1613             else:
1614                 prev_map = False
1615             last_valence = new_valence
1616         if last_valence is not None:
1617             out_str += "}"
1618         return out_str
1619 
1620     def _print_Tensor(self, expr):
1621         name = expr.args[0].args[0]
1622         indices = expr.get_indices()
1623         return self._printer_tensor_indices(name, indices)
1624 
1625     def _print_TensorElement(self, expr):
1626         name = expr.expr.args[0].args[0]
1627         indices = expr.expr.get_indices()
1628         index_map = expr.index_map
1629         return self._printer_tensor_indices(name, indices, index_map)
1630 
1631     def _print_TensMul(self, expr):
1632         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1633         sign, args = expr._get_args_for_traditional_printer()
1634         return sign + "".join(
1635             [self.parenthesize(arg, precedence(expr)) for arg in args]
1636         )
1637 
1638     def _print_TensAdd(self, expr):
1639         a = []
1640         args = expr.args
1641         for x in args:
1642             a.append(self.parenthesize(x, precedence(expr)))
1643         a.sort()
1644         s = ' + '.join(a)
1645         s = s.replace('+ -', '- ')
1646         return s
1647 
1648     def _print_TensorIndex(self, expr):
1649         return "{}%s{%s}" % (
1650             "^" if expr.is_up else "_",
1651             self._print(expr.args[0])
1652         )
1653         return self._print(expr.args[0])
1654 
1655     def _print_tuple(self, expr):
1656         return r"\left ( %s\right )" % \
1657             r", \quad ".join([ self._print(i) for i in expr ])
1658 
1659     def _print_TensorProduct(self, expr):
1660         elements = [self._print(a) for a in expr.args]
1661         return r' \otimes '.join(elements)
1662 
1663     def _print_WedgeProduct(self, expr):
1664         elements = [self._print(a) for a in expr.args]
1665         return r' \wedge '.join(elements)
1666 
1667     def _print_Tuple(self, expr):
1668         return self._print_tuple(expr)
1669 
1670     def _print_list(self, expr):
1671         return r"\left [ %s\right ]" % \
1672             r", \quad ".join([ self._print(i) for i in expr ])
1673 
1674     def _print_dict(self, d):
1675         keys = sorted(d.keys(), key=default_sort_key)
1676         items = []
1677 
1678         for key in keys:
1679             val = d[key]
1680             items.append("%s : %s" % (self._print(key), self._print(val)))
1681 
1682         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1683 
1684     def _print_Dict(self, expr):
1685         return self._print_dict(expr)
1686 
1687     def _print_DiracDelta(self, expr, exp=None):
1688         if len(expr.args) == 1 or expr.args[1] == 0:
1689             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1690         else:
1691             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1692                 self._print(expr.args[1]), self._print(expr.args[0]))
1693         if exp:
1694             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1695         return tex
1696 
1697     def _print_SingularityFunction(self, expr):
1698         shift = self._print(expr.args[0] - expr.args[1])
1699         power = self._print(expr.args[2])
1700         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1701         return tex
1702 
1703     def _print_Heaviside(self, expr, exp=None):
1704         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1705         if exp:
1706             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1707         return tex
1708 
1709     def _print_KroneckerDelta(self, expr, exp=None):
1710         i = self._print(expr.args[0])
1711         j = self._print(expr.args[1])
1712         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1713             tex = r'\delta_{%s %s}' % (i, j)
1714         else:
1715             tex = r'\delta_{%s, %s}' % (i, j)
1716         if exp:
1717             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1718         return tex
1719 
1720     def _print_LeviCivita(self, expr, exp=None):
1721         indices = map(self._print, expr.args)
1722         if all(x.is_Atom for x in expr.args):
1723             tex = r'\varepsilon_{%s}' % " ".join(indices)
1724         else:
1725             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1726         if exp:
1727             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1728         return tex
1729 
1730     def _print_ProductSet(self, p):
1731         if len(p.sets) > 1 and not has_variety(p.sets):
1732             return self._print(p.sets[0]) + "^{%d}" % len(p.sets)
1733         else:
1734             return r" \times ".join(self._print(set) for set in p.sets)
1735 
1736     def _print_RandomDomain(self, d):
1737         if hasattr(d, 'as_boolean'):
1738             return 'Domain: ' + self._print(d.as_boolean())
1739         elif hasattr(d, 'set'):
1740             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1741                     self._print(d.set))
1742         elif hasattr(d, 'symbols'):
1743             return 'Domain on ' + self._print(d.symbols)
1744         else:
1745             return self._print(None)
1746 
1747     def _print_FiniteSet(self, s):
1748         items = sorted(s.args, key=default_sort_key)
1749         return self._print_set(items)
1750 
1751     def _print_set(self, s):
1752         items = sorted(s, key=default_sort_key)
1753         items = ", ".join(map(self._print, items))
1754         return r"\left\{%s\right\}" % items
1755 
1756     _print_frozenset = _print_set
1757 
1758     def _print_Range(self, s):
1759         dots = r'\ldots'
1760 
1761         if s.start.is_infinite:
1762             printset = s.start, dots, s[-1] - s.step, s[-1]
1763         elif s.stop.is_infinite or len(s) > 4:
1764             it = iter(s)
1765             printset = next(it), next(it), dots, s[-1]
1766         else:
1767             printset = tuple(s)
1768 
1769         return (r"\left\{"
1770               + r", ".join(self._print(el) for el in printset)
1771               + r"\right\}")
1772 
1773     def _print_SeqFormula(self, s):
1774         if s.start is S.NegativeInfinity:
1775             stop = s.stop
1776             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1777                 s.coeff(stop - 1), s.coeff(stop))
1778         elif s.stop is S.Infinity or s.length > 4:
1779             printset = s[:4]
1780             printset.append(r'\ldots')
1781         else:
1782             printset = tuple(s)
1783 
1784         return (r"\left["
1785               + r", ".join(self._print(el) for el in printset)
1786               + r"\right]")
1787 
1788     _print_SeqPer = _print_SeqFormula
1789     _print_SeqAdd = _print_SeqFormula
1790     _print_SeqMul = _print_SeqFormula
1791 
1792     def _print_Interval(self, i):
1793         if i.start == i.end:
1794             return r"\left\{%s\right\}" % self._print(i.start)
1795 
1796         else:
1797             if i.left_open:
1798                 left = '('
1799             else:
1800                 left = '['
1801 
1802             if i.right_open:
1803                 right = ')'
1804             else:
1805                 right = ']'
1806 
1807             return r"\left%s%s, %s\right%s" % \
1808                    (left, self._print(i.start), self._print(i.end), right)
1809 
1810     def _print_AccumulationBounds(self, i):
1811         return r"\langle %s, %s\rangle" % \
1812                 (self._print(i.min), self._print(i.max))
1813 
1814     def _print_Union(self, u):
1815         return r" \cup ".join([self._print(i) for i in u.args])
1816 
1817     def _print_Complement(self, u):
1818         return r" \setminus ".join([self._print(i) for i in u.args])
1819 
1820     def _print_Intersection(self, u):
1821         return r" \cap ".join([self._print(i) for i in u.args])
1822 
1823     def _print_SymmetricDifference(self, u):
1824         return r" \triangle ".join([self._print(i) for i in u.args])
1825 
1826     def _print_EmptySet(self, e):
1827         return r"\emptyset"
1828 
1829     def _print_Naturals(self, n):
1830         return r"\mathbb{N}"
1831 
1832     def _print_Naturals0(self, n):
1833         return r"\mathbb{N}_0"
1834 
1835     def _print_Integers(self, i):
1836         return r"\mathbb{Z}"
1837 
1838     def _print_Reals(self, i):
1839         return r"\mathbb{R}"
1840 
1841     def _print_Complexes(self, i):
1842         return r"\mathbb{C}"
1843 
1844     def _print_ImageSet(self, s):
1845         sets = s.args[1:]
1846         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1847             for var, setv in zip(s.lamda.variables, sets)]
1848         return r"\left\{%s\; |\; %s\right\}" % (
1849             self._print(s.lamda.expr),
1850             ', '.join(varsets))
1851 
1852     def _print_ConditionSet(self, s):
1853         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1854         if s.base_set is S.UniversalSet:
1855             return r"\left\{%s \mid %s \right\}" % (
1856             vars_print,
1857             self._print(s.condition.as_expr()))
1858 
1859         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1860             vars_print,
1861             vars_print,
1862             self._print(s.base_set),
1863             self._print(s.condition.as_expr()))
1864 
1865     def _print_ComplexRegion(self, s):
1866         vars_print = ', '.join([self._print(var) for var in s.variables])
1867         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1868             self._print(s.expr),
1869             vars_print,
1870             self._print(s.sets))
1871 
1872     def _print_Contains(self, e):
1873         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1874 
1875     def _print_FourierSeries(self, s):
1876         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1877 
1878     def _print_FormalPowerSeries(self, s):
1879         return self._print_Add(s.infinite)
1880 
1881     def _print_FiniteField(self, expr):
1882         return r"\mathbb{F}_{%s}" % expr.mod
1883 
1884     def _print_IntegerRing(self, expr):
1885         return r"\mathbb{Z}"
1886 
1887     def _print_RationalField(self, expr):
1888         return r"\mathbb{Q}"
1889 
1890     def _print_RealField(self, expr):
1891         return r"\mathbb{R}"
1892 
1893     def _print_ComplexField(self, expr):
1894         return r"\mathbb{C}"
1895 
1896     def _print_PolynomialRing(self, expr):
1897         domain = self._print(expr.domain)
1898         symbols = ", ".join(map(self._print, expr.symbols))
1899         return r"%s\left[%s\right]" % (domain, symbols)
1900 
1901     def _print_FractionField(self, expr):
1902         domain = self._print(expr.domain)
1903         symbols = ", ".join(map(self._print, expr.symbols))
1904         return r"%s\left(%s\right)" % (domain, symbols)
1905 
1906     def _print_PolynomialRingBase(self, expr):
1907         domain = self._print(expr.domain)
1908         symbols = ", ".join(map(self._print, expr.symbols))
1909         inv = ""
1910         if not expr.is_Poly:
1911             inv = r"S_<^{-1}"
1912         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1913 
1914     def _print_Poly(self, poly):
1915         cls = poly.__class__.__name__
1916         terms = []
1917         for monom, coeff in poly.terms():
1918             s_monom = ''
1919             for i, exp in enumerate(monom):
1920                 if exp > 0:
1921                     if exp == 1:
1922                         s_monom += self._print(poly.gens[i])
1923                     else:
1924                         s_monom += self._print(pow(poly.gens[i], exp))
1925 
1926             if coeff.is_Add:
1927                 if s_monom:
1928                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1929                 else:
1930                     s_coeff = self._print(coeff)
1931             else:
1932                 if s_monom:
1933                     if coeff is S.One:
1934                         terms.extend(['+', s_monom])
1935                         continue
1936 
1937                     if coeff is S.NegativeOne:
1938                         terms.extend(['-', s_monom])
1939                         continue
1940 
1941                 s_coeff = self._print(coeff)
1942 
1943             if not s_monom:
1944                 s_term = s_coeff
1945             else:
1946                 s_term = s_coeff + " " + s_monom
1947 
1948             if s_term.startswith('-'):
1949                 terms.extend(['-', s_term[1:]])
1950             else:
1951                 terms.extend(['+', s_term])
1952 
1953         if terms[0] in ['-', '+']:
1954             modifier = terms.pop(0)
1955 
1956             if modifier == '-':
1957                 terms[0] = '-' + terms[0]
1958 
1959         expr = ' '.join(terms)
1960         gens = list(map(self._print, poly.gens))
1961         domain = "domain=%s" % self._print(poly.get_domain())
1962 
1963         args = ", ".join([expr] + gens + [domain])
1964         if cls in accepted_latex_functions:
1965             tex = r"\%s {\left (%s \right )}" % (cls, args)
1966         else:
1967             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1968 
1969         return tex
1970 
1971     def _print_ComplexRootOf(self, root):
1972         cls = root.__class__.__name__
1973         if cls == "ComplexRootOf":
1974             cls = "CRootOf"
1975         expr = self._print(root.expr)
1976         index = root.index
1977         if cls in accepted_latex_functions:
1978             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1979         else:
1980             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1981 
1982     def _print_RootSum(self, expr):
1983         cls = expr.__class__.__name__
1984         args = [self._print(expr.expr)]
1985 
1986         if expr.fun is not S.IdentityFunction:
1987             args.append(self._print(expr.fun))
1988 
1989         if cls in accepted_latex_functions:
1990             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1991         else:
1992             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1993 
1994     def _print_PolyElement(self, poly):
1995         mul_symbol = self._settings['mul_symbol_latex']
1996         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1997 
1998     def _print_FracElement(self, frac):
1999         if frac.denom == 1:
2000             return self._print(frac.numer)
2001         else:
2002             numer = self._print(frac.numer)
2003             denom = self._print(frac.denom)
2004             return r"\frac{%s}{%s}" % (numer, denom)
2005 
2006     def _print_euler(self, expr, exp=None):
2007         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2008         tex = r"E_{%s}" % self._print(m)
2009         if exp is not None:
2010             tex = r"%s^{%s}" % (tex, self._print(exp))
2011         if x is not None:
2012             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2013         return tex
2014 
2015     def _print_catalan(self, expr, exp=None):
2016         tex = r"C_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_MellinTransform(self, expr):
2022         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2023 
2024     def _print_InverseMellinTransform(self, expr):
2025         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2026 
2027     def _print_LaplaceTransform(self, expr):
2028         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2029 
2030     def _print_InverseLaplaceTransform(self, expr):
2031         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2032 
2033     def _print_FourierTransform(self, expr):
2034         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2035 
2036     def _print_InverseFourierTransform(self, expr):
2037         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2038 
2039     def _print_SineTransform(self, expr):
2040         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2041 
2042     def _print_InverseSineTransform(self, expr):
2043         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2044 
2045     def _print_CosineTransform(self, expr):
2046         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2047 
2048     def _print_InverseCosineTransform(self, expr):
2049         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2050 
2051     def _print_DMP(self, p):
2052         try:
2053             if p.ring is not None:
2054                 # TODO incorporate order
2055                 return self._print(p.ring.to_sympy(p))
2056         except SympifyError:
2057             pass
2058         return self._print(repr(p))
2059 
2060     def _print_DMF(self, p):
2061         return self._print_DMP(p)
2062 
2063     def _print_Object(self, object):
2064         return self._print(Symbol(object.name))
2065 
2066     def _print_Morphism(self, morphism):
2067         domain = self._print(morphism.domain)
2068         codomain = self._print(morphism.codomain)
2069         return "%s\\rightarrow %s" % (domain, codomain)
2070 
2071     def _print_NamedMorphism(self, morphism):
2072         pretty_name = self._print(Symbol(morphism.name))
2073         pretty_morphism = self._print_Morphism(morphism)
2074         return "%s:%s" % (pretty_name, pretty_morphism)
2075 
2076     def _print_IdentityMorphism(self, morphism):
2077         from sympy.categories import NamedMorphism
2078         return self._print_NamedMorphism(NamedMorphism(
2079             morphism.domain, morphism.codomain, "id"))
2080 
2081     def _print_CompositeMorphism(self, morphism):
2082         # All components of the morphism have names and it is thus
2083         # possible to build the name of the composite.
2084         component_names_list = [self._print(Symbol(component.name)) for
2085                                 component in morphism.components]
2086         component_names_list.reverse()
2087         component_names = "\\circ ".join(component_names_list) + ":"
2088 
2089         pretty_morphism = self._print_Morphism(morphism)
2090         return component_names + pretty_morphism
2091 
2092     def _print_Category(self, morphism):
2093         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2094 
2095     def _print_Diagram(self, diagram):
2096         if not diagram.premises:
2097             # This is an empty diagram.
2098             return self._print(S.EmptySet)
2099 
2100         latex_result = self._print(diagram.premises)
2101         if diagram.conclusions:
2102             latex_result += "\\Longrightarrow %s" % \
2103                             self._print(diagram.conclusions)
2104 
2105         return latex_result
2106 
2107     def _print_DiagramGrid(self, grid):
2108         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2109 
2110         for i in range(grid.height):
2111             for j in range(grid.width):
2112                 if grid[i, j]:
2113                     latex_result += latex(grid[i, j])
2114                 latex_result += " "
2115                 if j != grid.width - 1:
2116                     latex_result += "& "
2117 
2118             if i != grid.height - 1:
2119                 latex_result += "\\\\"
2120             latex_result += "\n"
2121 
2122         latex_result += "\\end{array}\n"
2123         return latex_result
2124 
2125     def _print_FreeModule(self, M):
2126         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2127 
2128     def _print_FreeModuleElement(self, m):
2129         # Print as row vector for convenience, for now.
2130         return r"\left[ %s \right]" % ",".join(
2131             '{' + self._print(x) + '}' for x in m)
2132 
2133     def _print_SubModule(self, m):
2134         return r"\left< %s \right>" % ",".join(
2135             '{' + self._print(x) + '}' for x in m.gens)
2136 
2137     def _print_ModuleImplementedIdeal(self, m):
2138         return r"\left< %s \right>" % ",".join(
2139             '{' + self._print(x) + '}' for [x] in m._module.gens)
2140 
2141     def _print_Quaternion(self, expr):
2142         # TODO: This expression is potentially confusing,
2143         # shall we print it as `Quaternion( ... )`?
2144         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2145         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2146         return " + ".join(a)
2147 
2148     def _print_QuotientRing(self, R):
2149         # TODO nicer fractions for few generators...
2150         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2151 
2152     def _print_QuotientRingElement(self, x):
2153         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2154 
2155     def _print_QuotientModuleElement(self, m):
2156         return r"{%s} + {%s}" % (self._print(m.data),
2157                                  self._print(m.module.killed_module))
2158 
2159     def _print_QuotientModule(self, M):
2160         # TODO nicer fractions for few generators...
2161         return r"\frac{%s}{%s}" % (self._print(M.base),
2162                                    self._print(M.killed_module))
2163 
2164     def _print_MatrixHomomorphism(self, h):
2165         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2166             self._print(h.domain), self._print(h.codomain))
2167 
2168     def _print_BaseScalarField(self, field):
2169         string = field._coord_sys._names[field._index]
2170         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2171 
2172     def _print_BaseVectorField(self, field):
2173         string = field._coord_sys._names[field._index]
2174         return r'\partial_{%s}' % self._print(Symbol(string))
2175 
2176     def _print_Differential(self, diff):
2177         field = diff._form_field
2178         if hasattr(field, '_coord_sys'):
2179             string = field._coord_sys._names[field._index]
2180             return r'\mathrm{d}%s' % self._print(Symbol(string))
2181         else:
2182             return 'd(%s)' % self._print(field)
2183             string = self._print(field)
2184             return r'\mathrm{d}\left(%s\right)' % string
2185 
2186     def _print_Tr(self, p):
2187         #Todo: Handle indices
2188         contents = self._print(p.args[0])
2189         return r'\mbox{Tr}\left(%s\right)' % (contents)
2190 
2191     def _print_totient(self, expr, exp=None):
2192         if exp is not None:
2193             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2194                     self._print(exp))
2195         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2196 
2197     def _print_reduced_totient(self, expr, exp=None):
2198         if exp is not None:
2199             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2200                     self._print(exp))
2201         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2202 
2203     def _print_divisor_sigma(self, expr, exp=None):
2204         if len(expr.args) == 2:
2205             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2206                                                 (expr.args[1], expr.args[0])))
2207         else:
2208             tex = r"\left(%s\right)" % self._print(expr.args[0])
2209         if exp is not None:
2210             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2211         return r"\sigma%s" % tex
2212 
2213     def _print_udivisor_sigma(self, expr, exp=None):
2214         if len(expr.args) == 2:
2215             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2216                                                 (expr.args[1], expr.args[0])))
2217         else:
2218             tex = r"\left(%s\right)" % self._print(expr.args[0])
2219         if exp is not None:
2220             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2221         return r"\sigma^*%s" % tex
2222 
2223     def _print_primenu(self, expr, exp=None):
2224         if exp is not None:
2225             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2226                     self._print(exp))
2227         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2228 
2229     def _print_primeomega(self, expr, exp=None):
2230         if exp is not None:
2231             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2232                     self._print(exp))
2233         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 20:23:56.874 | INFO     | Search completed. Bug locations: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_MatrixElement</method>
<code>
1439     def _print_MatrixElement(self, expr):
1440         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1441             + '_{%s, %s}' % (expr.i, expr.j)

</code><intended_behavior>This method should ensure that when printing the elements of a matrix (especially when they are part of an indexed operation or product of matrices), the subscript notation is generated in a way that is valid LaTeX syntax. The specific fix here should address the issue of double subscripts by perhaps introducing an intermediate representation or formatting step for subscript expressions to ensure they are unique and do not violate LaTeX syntax rules. The method must preserve the accuracy of mathematical expressions while ensuring the generated LaTeX code is compilable.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": None,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137         "ln_notation": False,
138     }
139 
140     def __init__(self, settings=None):
141         Printer.__init__(self, settings)
142 
143         if 'mode' in self._settings:
144             valid_modes = ['inline', 'plain', 'equation',
145                            'equation*']
146             if self._settings['mode'] not in valid_modes:
147                 raise ValueError("'mode' must be one of 'inline', 'plain', "
148                     "'equation' or 'equation*'")
149 
150         if self._settings['fold_short_frac'] is None and \
151                 self._settings['mode'] == 'inline':
152             self._settings['fold_short_frac'] = True
153 
154         mul_symbol_table = {
155             None: r" ",
156             "ldot": r" \,.\, ",
157             "dot": r" \cdot ",
158             "times": r" \times "
159         }
160         try:
161             self._settings['mul_symbol_latex'] = \
162                 mul_symbol_table[self._settings['mul_symbol']]
163         except KeyError:
164             self._settings['mul_symbol_latex'] = \
165                 self._settings['mul_symbol']
166         try:
167             self._settings['mul_symbol_latex_numbers'] = \
168                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
169         except KeyError:
170             if (self._settings['mul_symbol'].strip() in
171                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
172                 self._settings['mul_symbol_latex_numbers'] = \
173                     mul_symbol_table['dot']
174             else:
175                 self._settings['mul_symbol_latex_numbers'] = \
176                     self._settings['mul_symbol']
177 
178         self._delim_dict = {'(': ')', '[': ']'}
179 
180     def parenthesize(self, item, level, strict=False):
181         prec_val = precedence_traditional(item)
182         if (prec_val < level) or ((not strict) and prec_val <= level):
183             return r"\left(%s\right)" % self._print(item)
184         else:
185             return self._print(item)
186 
187     def doprint(self, expr):
188         tex = Printer.doprint(self, expr)
189 
190         if self._settings['mode'] == 'plain':
191             return tex
192         elif self._settings['mode'] == 'inline':
193             return r"$%s$" % tex
194         elif self._settings['itex']:
195             return r"$$%s$$" % tex
196         else:
197             env_str = self._settings['mode']
198             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
199 
200     def _needs_brackets(self, expr):
201         """
202         Returns True if the expression needs to be wrapped in brackets when
203         printed, False otherwise. For example: a + b => True; a => False;
204         10 => False; -10 => True.
205         """
206         return not ((expr.is_Integer and expr.is_nonnegative)
207                     or (expr.is_Atom and (expr is not S.NegativeOne
208                                           and expr.is_Rational is False)))
209 
210     def _needs_function_brackets(self, expr):
211         """
212         Returns True if the expression needs to be wrapped in brackets when
213         passed as an argument to a function, False otherwise. This is a more
214         liberal version of _needs_brackets, in that many expressions which need
215         to be wrapped in brackets when added/subtracted/raised to a power do
216         not need them when passed to a function. Such an example is a*b.
217         """
218         if not self._needs_brackets(expr):
219             return False
220         else:
221             # Muls of the form a*b*c... can be folded
222             if expr.is_Mul and not self._mul_is_clean(expr):
223                 return True
224             # Pows which don't need brackets can be folded
225             elif expr.is_Pow and not self._pow_is_clean(expr):
226                 return True
227             # Add and Function always need brackets
228             elif expr.is_Add or expr.is_Function:
229                 return True
230             else:
231                 return False
232 
233     def _needs_mul_brackets(self, expr, first=False, last=False):
234         """
235         Returns True if the expression needs to be wrapped in brackets when
236         printed as part of a Mul, False otherwise. This is True for Add,
237         but also for some container objects that would not need brackets
238         when appearing last in a Mul, e.g. an Integral. ``last=True``
239         specifies that this expr is the last to appear in a Mul.
240         ``first=True`` specifies that this expr is the first to appear in a Mul.
241         """
242         from sympy import Integral, Piecewise, Product, Sum
243 
244         if expr.is_Mul:
245             if not first and _coeff_isneg(expr):
246                 return True
247         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
248             return True
249         elif expr.is_Relational:
250             return True
251         if expr.is_Piecewise:
252             return True
253         if any([expr.has(x) for x in (Mod,)]):
254             return True
255         if (not last and
256             any([expr.has(x) for x in (Integral, Product, Sum)])):
257             return True
258 
259         return False
260 
261 
262     def _needs_add_brackets(self, expr):
263         """
264         Returns True if the expression needs to be wrapped in brackets when
265         printed as part of an Add, False otherwise.  This is False for most
266         things.
267         """
268         if expr.is_Relational:
269             return True
270         if any([expr.has(x) for x in (Mod,)]):
271             return True
272         if expr.is_Add:
273             return True
274         return False
275 
276 
277     def _mul_is_clean(self, expr):
278         for arg in expr.args:
279             if arg.is_Function:
280                 return False
281         return True
282 
283     def _pow_is_clean(self, expr):
284         return not self._needs_brackets(expr.base)
285 
286     def _do_exponent(self, expr, exp):
287         if exp is not None:
288             return r"\left(%s\right)^{%s}" % (expr, exp)
289         else:
290             return expr
291 
292     def _print_Basic(self, expr):
293         l = [self._print(o) for o in expr.args]
294         return self._deal_with_super_sub(expr.__class__.__name__) + r"\left(%s\right)" % ", ".join(l)
295 
296     def _print_bool(self, e):
297         return r"\mathrm{%s}" % e
298 
299     _print_BooleanTrue = _print_bool
300     _print_BooleanFalse = _print_bool
301 
302     def _print_NoneType(self, e):
303         return r"\mathrm{%s}" % e
304 
305     def _print_Add(self, expr, order=None):
306         if self.order == 'none':
307             terms = list(expr.args)
308         else:
309             terms = self._as_ordered_terms(expr, order=order)
310 
311         tex = ""
312         for i, term in enumerate(terms):
313             if i == 0:
314                 pass
315             elif _coeff_isneg(term):
316                 tex += " - "
317                 term = -term
318             else:
319                 tex += " + "
320             term_tex = self._print(term)
321             if self._needs_add_brackets(term):
322                 term_tex = r"\left(%s\right)" % term_tex
323             tex += term_tex
324 
325         return tex
326 
327     def _print_Cycle(self, expr):
328         from sympy.combinatorics.permutations import Permutation
329         if expr.size == 0:
330             return r"\left( \right)"
331         expr = Permutation(expr)
332         expr_perm = expr.cyclic_form
333         siz = expr.size
334         if expr.array_form[-1] == siz - 1:
335             expr_perm = expr_perm + [[siz - 1]]
336         term_tex = ''
337         for i in expr_perm:
338             term_tex += str(i).replace(',', r"\;")
339         term_tex = term_tex.replace('[', r"\left( ")
340         term_tex = term_tex.replace(']', r"\right)")
341         return term_tex
342 
343     _print_Permutation = _print_Cycle
344 
345     def _print_Float(self, expr):
346         # Based off of that in StrPrinter
347         dps = prec_to_dps(expr._prec)
348         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
349 
350         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
351         # thus we use the number separator
352         separator = self._settings['mul_symbol_latex_numbers']
353 
354         if 'e' in str_real:
355             (mant, exp) = str_real.split('e')
356 
357             if exp[0] == '+':
358                 exp = exp[1:]
359 
360             return r"%s%s10^{%s}" % (mant, separator, exp)
361         elif str_real == "+inf":
362             return r"\infty"
363         elif str_real == "-inf":
364             return r"- \infty"
365         else:
366             return str_real
367 
368     def _print_Cross(self, expr):
369         vec1 = expr._expr1
370         vec2 = expr._expr2
371         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
372                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
373 
374     def _print_Curl(self, expr):
375         vec = expr._expr
376         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
377 
378     def _print_Divergence(self, expr):
379         vec = expr._expr
380         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
381 
382     def _print_Dot(self, expr):
383         vec1 = expr._expr1
384         vec2 = expr._expr2
385         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
386                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
387 
388     def _print_Gradient(self, expr):
389         func = expr._expr
390         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
391 
392     def _print_Mul(self, expr):
393         from sympy.core.power import Pow
394         from sympy.physics.units import Quantity
395         include_parens = False
396         if _coeff_isneg(expr):
397             expr = -expr
398             tex = "- "
399             if expr.is_Add:
400                 tex += "("
401                 include_parens = True
402         else:
403             tex = ""
404 
405         from sympy.simplify import fraction
406         numer, denom = fraction(expr, exact=True)
407         separator = self._settings['mul_symbol_latex']
408         numbersep = self._settings['mul_symbol_latex_numbers']
409 
410         def convert(expr):
411             if not expr.is_Mul:
412                 return str(self._print(expr))
413             else:
414                 _tex = last_term_tex = ""
415 
416                 if self.order not in ('old', 'none'):
417                     args = expr.as_ordered_factors()
418                 else:
419                     args = list(expr.args)
420 
421                 # If quantities are present append them at the back
422                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
423                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
424 
425                 for i, term in enumerate(args):
426                     term_tex = self._print(term)
427 
428                     if self._needs_mul_brackets(term, first=(i == 0),
429                                                 last=(i == len(args) - 1)):
430                         term_tex = r"\left(%s\right)" % term_tex
431 
432                     if _between_two_numbers_p[0].search(last_term_tex) and \
433                             _between_two_numbers_p[1].match(term_tex):
434                         # between two numbers
435                         _tex += numbersep
436                     elif _tex:
437                         _tex += separator
438 
439                     _tex += term_tex
440                     last_term_tex = term_tex
441                 return _tex
442 
443         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
444             # use the original expression here, since fraction() may have
445             # altered it when producing numer and denom
446             tex += convert(expr)
447 
448         else:
449             snumer = convert(numer)
450             sdenom = convert(denom)
451             ldenom = len(sdenom.split())
452             ratio = self._settings['long_frac_ratio']
453             if self._settings['fold_short_frac'] \
454                    and ldenom <= 2 and not "^" in sdenom:
455                 # handle short fractions
456                 if self._needs_mul_brackets(numer, last=False):
457                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
458                 else:
459                     tex += r"%s / %s" % (snumer, sdenom)
460             elif ratio is not None and \
461                     len(snumer.split()) > ratio*ldenom:
462                 # handle long fractions
463                 if self._needs_mul_brackets(numer, last=True):
464                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
465                         % (sdenom, separator, snumer)
466                 elif numer.is_Mul:
467                     # split a long numerator
468                     a = S.One
469                     b = S.One
470                     for x in numer.args:
471                         if self._needs_mul_brackets(x, last=False) or \
472                                 len(convert(a*x).split()) > ratio*ldenom or \
473                                 (b.is_commutative is x.is_commutative is False):
474                             b *= x
475                         else:
476                             a *= x
477                     if self._needs_mul_brackets(b, last=True):
478                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
479                             % (convert(a), sdenom, separator, convert(b))
480                     else:
481                         tex += r"\frac{%s}{%s}%s%s" \
482                             % (convert(a), sdenom, separator, convert(b))
483                 else:
484                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
485             else:
486                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
487 
488         if include_parens:
489             tex += ")"
490         return tex
491 
492     def _print_Pow(self, expr):
493         # Treat x**Rational(1,n) as special case
494         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
495             base = self._print(expr.base)
496             expq = expr.exp.q
497 
498             if expq == 2:
499                 tex = r"\sqrt{%s}" % base
500             elif self._settings['itex']:
501                 tex = r"\root{%d}{%s}" % (expq, base)
502             else:
503                 tex = r"\sqrt[%d]{%s}" % (expq, base)
504 
505             if expr.exp.is_negative:
506                 return r"\frac{1}{%s}" % tex
507             else:
508                 return tex
509         elif self._settings['fold_frac_powers'] \
510             and expr.exp.is_Rational \
511                 and expr.exp.q != 1:
512             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
513             # issue #12886: add parentheses for superscripts raised to powers
514             if '^' in base and expr.base.is_Symbol:
515                 base = r"\left(%s\right)" % base
516             if expr.base.is_Function:
517                 return self._print(expr.base, exp="%s/%s" % (p, q))
518             return r"%s^{%s/%s}" % (base, p, q)
519         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
520             # special case for 1^(-x), issue 9216
521             if expr.base == 1:
522                 return r"%s^{%s}" % (expr.base, expr.exp)
523             # things like 1/x
524             return self._print_Mul(expr)
525         else:
526             if expr.base.is_Function:
527                 return self._print(expr.base, exp=self._print(expr.exp))
528             else:
529                 tex = r"%s^{%s}"
530                 exp = self._print(expr.exp)
531                 # issue #12886: add parentheses around superscripts raised to powers
532                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
533                 if '^' in base and expr.base.is_Symbol:
534                     base = r"\left(%s\right)" % base
535                 elif isinstance(expr.base, Derivative
536                         ) and base.startswith(r'\left('
537                         ) and re.match(r'\\left\(\\d?d?dot', base
538                         ) and base.endswith(r'\right)'):
539                     # don't use parentheses around dotted derivative
540                     base = base[6: -7]  # remove outermost added parens
541 
542                 return tex % (base, exp)
543 
544     def _print_UnevaluatedExpr(self, expr):
545         return self._print(expr.args[0])
546 
547     def _print_Sum(self, expr):
548         if len(expr.limits) == 1:
549             tex = r"\sum_{%s=%s}^{%s} " % \
550                 tuple([ self._print(i) for i in expr.limits[0] ])
551         else:
552             def _format_ineq(l):
553                 return r"%s \leq %s \leq %s" % \
554                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
555 
556             tex = r"\sum_{\substack{%s}} " % \
557                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
558 
559         if isinstance(expr.function, Add):
560             tex += r"\left(%s\right)" % self._print(expr.function)
561         else:
562             tex += self._print(expr.function)
563 
564         return tex
565 
566     def _print_Product(self, expr):
567         if len(expr.limits) == 1:
568             tex = r"\prod_{%s=%s}^{%s} " % \
569                 tuple([ self._print(i) for i in expr.limits[0] ])
570         else:
571             def _format_ineq(l):
572                 return r"%s \leq %s \leq %s" % \
573                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
574 
575             tex = r"\prod_{\substack{%s}} " % \
576                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
577 
578         if isinstance(expr.function, Add):
579             tex += r"\left(%s\right)" % self._print(expr.function)
580         else:
581             tex += self._print(expr.function)
582 
583         return tex
584 
585     def _print_BasisDependent(self, expr):
586         from sympy.vector import Vector
587 
588         o1 = []
589         if expr == expr.zero:
590             return expr.zero._latex_form
591         if isinstance(expr, Vector):
592             items = expr.separate().items()
593         else:
594             items = [(0, expr)]
595 
596         for system, vect in items:
597             inneritems = list(vect.components.items())
598             inneritems.sort(key = lambda x:x[0].__str__())
599             for k, v in inneritems:
600                 if v == 1:
601                     o1.append(' + ' + k._latex_form)
602                 elif v == -1:
603                     o1.append(' - ' + k._latex_form)
604                 else:
605                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
606                     o1.append(' + ' + arg_str + k._latex_form)
607 
608         outstr = (''.join(o1))
609         if outstr[1] != '-':
610             outstr = outstr[3:]
611         else:
612             outstr = outstr[1:]
613         return outstr
614 
615     def _print_Indexed(self, expr):
616         tex_base = self._print(expr.base)
617         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
618             map(self._print, expr.indices))
619         return tex
620 
621     def _print_IndexedBase(self, expr):
622         return self._print(expr.label)
623 
624     def _print_Derivative(self, expr):
625         if requires_partial(expr):
626             diff_symbol = r'\partial'
627         else:
628             diff_symbol = r'd'
629 
630         tex = ""
631         dim = 0
632         for x, num in reversed(expr.variable_count):
633             dim += num
634             if num == 1:
635                 tex += r"%s %s" % (diff_symbol, self._print(x))
636             else:
637                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
638 
639         if dim == 1:
640             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
641         else:
642             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
643 
644         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
645 
646     def _print_Subs(self, subs):
647         expr, old, new = subs.args
648         latex_expr = self._print(expr)
649         latex_old = (self._print(e) for e in old)
650         latex_new = (self._print(e) for e in new)
651         latex_subs = r'\\ '.join(
652             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
653         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
654 
655     def _print_Integral(self, expr):
656         tex, symbols = "", []
657 
658         # Only up to \iiiint exists
659         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
660             # Use len(expr.limits)-1 so that syntax highlighters don't think
661             # \" is an escaped quote
662             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
663             symbols = [r"\, d%s" % self._print(symbol[0])
664                        for symbol in expr.limits]
665 
666         else:
667             for lim in reversed(expr.limits):
668                 symbol = lim[0]
669                 tex += r"\int"
670 
671                 if len(lim) > 1:
672                     if self._settings['mode'] in ['equation', 'equation*'] \
673                             and not self._settings['itex']:
674                         tex += r"\limits"
675 
676                     if len(lim) == 3:
677                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
678                                                self._print(lim[2]))
679                     if len(lim) == 2:
680                         tex += "^{%s}" % (self._print(lim[1]))
681 
682                 symbols.insert(0, r"\, d%s" % self._print(symbol))
683 
684         return r"%s %s%s" % (tex,
685             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
686 
687     def _print_Limit(self, expr):
688         e, z, z0, dir = expr.args
689 
690         tex = r"\lim_{%s \to " % self._print(z)
691         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
692             tex += r"%s}" % self._print(z0)
693         else:
694             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
695 
696         if isinstance(e, AssocOp):
697             return r"%s\left(%s\right)" % (tex, self._print(e))
698         else:
699             return r"%s %s" % (tex, self._print(e))
700 
701     def _hprint_Function(self, func):
702         r'''
703         Logic to decide how to render a function to latex
704           - if it is a recognized latex name, use the appropriate latex command
705           - if it is a single letter, just use that letter
706           - if it is a longer name, then put \operatorname{} around it and be
707             mindful of undercores in the name
708         '''
709         func = self._deal_with_super_sub(func)
710         if func in accepted_latex_functions:
711             name = r"\%s" % func
712         elif len(func) == 1 or func.startswith('\\'):
713             name = func
714         else:
715             name = r"\operatorname{%s}" % func
716         return name
717 
718     def _print_Function(self, expr, exp=None):
719         r'''
720         Render functions to LaTeX, handling functions that LaTeX knows about
721         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
722         For single-letter function names, render them as regular LaTeX math
723         symbols. For multi-letter function names that LaTeX does not know
724         about, (e.g., Li, sech) use \operatorname{} so that the function name
725         is rendered in Roman font and LaTeX handles spacing properly.
726 
727         expr is the expression involving the function
728         exp is an exponent
729         '''
730         func = expr.func.__name__
731         if hasattr(self, '_print_' + func) and \
732             not isinstance(expr, AppliedUndef):
733             return getattr(self, '_print_' + func)(expr, exp)
734         else:
735             args = [ str(self._print(arg)) for arg in expr.args ]
736             # How inverse trig functions should be displayed, formats are:
737             # abbreviated: asin, full: arcsin, power: sin^-1
738             inv_trig_style = self._settings['inv_trig_style']
739             # If we are dealing with a power-style inverse trig function
740             inv_trig_power_case = False
741             # If it is applicable to fold the argument brackets
742             can_fold_brackets = self._settings['fold_func_brackets'] and \
743                 len(args) == 1 and \
744                 not self._needs_function_brackets(expr.args[0])
745 
746             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
747 
748             # If the function is an inverse trig function, handle the style
749             if func in inv_trig_table:
750                 if inv_trig_style == "abbreviated":
751                     func = func
752                 elif inv_trig_style == "full":
753                     func = "arc" + func[1:]
754                 elif inv_trig_style == "power":
755                     func = func[1:]
756                     inv_trig_power_case = True
757 
758                     # Can never fold brackets if we're raised to a power
759                     if exp is not None:
760                         can_fold_brackets = False
761 
762             if inv_trig_power_case:
763                 if func in accepted_latex_functions:
764                     name = r"\%s^{-1}" % func
765                 else:
766                     name = r"\operatorname{%s}^{-1}" % func
767             elif exp is not None:
768                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
769             else:
770                 name = self._hprint_Function(func)
771 
772             if can_fold_brackets:
773                 if func in accepted_latex_functions:
774                     # Wrap argument safely to avoid parse-time conflicts
775                     # with the function name itself
776                     name += r" {%s}"
777                 else:
778                     name += r"%s"
779             else:
780                 name += r"{\left (%s \right )}"
781 
782             if inv_trig_power_case and exp is not None:
783                 name += r"^{%s}" % exp
784 
785             return name % ",".join(args)
786 
787     def _print_UndefinedFunction(self, expr):
788         return self._hprint_Function(str(expr))
789 
790     @property
791     def _special_function_classes(self):
792         from sympy.functions.special.tensor_functions import KroneckerDelta
793         from sympy.functions.special.gamma_functions import gamma, lowergamma
794         from sympy.functions.special.beta_functions import beta
795         from sympy.functions.special.delta_functions import DiracDelta
796         from sympy.functions.special.error_functions import Chi
797         return {KroneckerDelta: r'\delta',
798                 gamma:  r'\Gamma',
799                 lowergamma: r'\gamma',
800                 beta: r'\operatorname{B}',
801                 DiracDelta: r'\delta',
802                 Chi: r'\operatorname{Chi}'}
803 
804     def _print_FunctionClass(self, expr):
805         for cls in self._special_function_classes:
806             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
807                 return self._special_function_classes[cls]
808         return self._hprint_Function(str(expr))
809 
810     def _print_Lambda(self, expr):
811         symbols, expr = expr.args
812 
813         if len(symbols) == 1:
814             symbols = self._print(symbols[0])
815         else:
816             symbols = self._print(tuple(symbols))
817 
818         args = (symbols, self._print(expr))
819         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
820 
821         return tex
822 
823     def _hprint_variadic_function(self, expr, exp=None):
824         args = sorted(expr.args, key=default_sort_key)
825         texargs = [r"%s" % self._print(symbol) for symbol in args]
826         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()), ", ".join(texargs))
827         if exp is not None:
828             return r"%s^{%s}" % (tex, exp)
829         else:
830             return tex
831 
832     _print_Min = _print_Max = _hprint_variadic_function
833 
834     def _print_floor(self, expr, exp=None):
835         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
836 
837         if exp is not None:
838             return r"%s^{%s}" % (tex, exp)
839         else:
840             return tex
841 
842     def _print_ceiling(self, expr, exp=None):
843         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
844 
845         if exp is not None:
846             return r"%s^{%s}" % (tex, exp)
847         else:
848             return tex
849 
850     def _print_log(self, expr, exp=None):
851         if not self._settings["ln_notation"]:
852             tex = r"\log{\left (%s \right )}" % self._print(expr.args[0])
853         else:
854             tex = r"\ln{\left (%s \right )}" % self._print(expr.args[0])
855 
856         if exp is not None:
857             return r"%s^{%s}" % (tex, exp)
858         else:
859             return tex
860 
861     def _print_Abs(self, expr, exp=None):
862         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
863 
864         if exp is not None:
865             return r"%s^{%s}" % (tex, exp)
866         else:
867             return tex
868     _print_Determinant = _print_Abs
869 
870     def _print_re(self, expr, exp=None):
871         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
872 
873         return self._do_exponent(tex, exp)
874 
875     def _print_im(self, expr, exp=None):
876         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
877 
878         return self._do_exponent(tex, exp)
879 
880     def _print_Not(self, e):
881         from sympy import Equivalent, Implies
882         if isinstance(e.args[0], Equivalent):
883             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
884         if isinstance(e.args[0], Implies):
885             return self._print_Implies(e.args[0], r"\not\Rightarrow")
886         if (e.args[0].is_Boolean):
887             return r"\neg (%s)" % self._print(e.args[0])
888         else:
889             return r"\neg %s" % self._print(e.args[0])
890 
891     def _print_LogOp(self, args, char):
892         arg = args[0]
893         if arg.is_Boolean and not arg.is_Not:
894             tex = r"\left(%s\right)" % self._print(arg)
895         else:
896             tex = r"%s" % self._print(arg)
897 
898         for arg in args[1:]:
899             if arg.is_Boolean and not arg.is_Not:
900                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
901             else:
902                 tex += r" %s %s" % (char, self._print(arg))
903 
904         return tex
905 
906     def _print_And(self, e):
907         args = sorted(e.args, key=default_sort_key)
908         return self._print_LogOp(args, r"\wedge")
909 
910     def _print_Or(self, e):
911         args = sorted(e.args, key=default_sort_key)
912         return self._print_LogOp(args, r"\vee")
913 
914     def _print_Xor(self, e):
915         args = sorted(e.args, key=default_sort_key)
916         return self._print_LogOp(args, r"\veebar")
917 
918     def _print_Implies(self, e, altchar=None):
919         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
920 
921     def _print_Equivalent(self, e, altchar=None):
922         args = sorted(e.args, key=default_sort_key)
923         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
924 
925     def _print_conjugate(self, expr, exp=None):
926         tex = r"\overline{%s}" % self._print(expr.args[0])
927 
928         if exp is not None:
929             return r"%s^{%s}" % (tex, exp)
930         else:
931             return tex
932 
933     def _print_polar_lift(self, expr, exp=None):
934         func = r"\operatorname{polar\_lift}"
935         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
936 
937         if exp is not None:
938             return r"%s^{%s}%s" % (func, exp, arg)
939         else:
940             return r"%s%s" % (func, arg)
941 
942     def _print_ExpBase(self, expr, exp=None):
943         # TODO should exp_polar be printed differently?
944         #      what about exp_polar(0), exp_polar(1)?
945         tex = r"e^{%s}" % self._print(expr.args[0])
946         return self._do_exponent(tex, exp)
947 
948     def _print_elliptic_k(self, expr, exp=None):
949         tex = r"\left(%s\right)" % self._print(expr.args[0])
950         if exp is not None:
951             return r"K^{%s}%s" % (exp, tex)
952         else:
953             return r"K%s" % tex
954 
955     def _print_elliptic_f(self, expr, exp=None):
956         tex = r"\left(%s\middle| %s\right)" % \
957             (self._print(expr.args[0]), self._print(expr.args[1]))
958         if exp is not None:
959             return r"F^{%s}%s" % (exp, tex)
960         else:
961             return r"F%s" % tex
962 
963     def _print_elliptic_e(self, expr, exp=None):
964         if len(expr.args) == 2:
965             tex = r"\left(%s\middle| %s\right)" % \
966                 (self._print(expr.args[0]), self._print(expr.args[1]))
967         else:
968             tex = r"\left(%s\right)" % self._print(expr.args[0])
969         if exp is not None:
970             return r"E^{%s}%s" % (exp, tex)
971         else:
972             return r"E%s" % tex
973 
974     def _print_elliptic_pi(self, expr, exp=None):
975         if len(expr.args) == 3:
976             tex = r"\left(%s; %s\middle| %s\right)" % \
977                 (self._print(expr.args[0]), self._print(expr.args[1]), \
978                  self._print(expr.args[2]))
979         else:
980             tex = r"\left(%s\middle| %s\right)" % \
981                 (self._print(expr.args[0]), self._print(expr.args[1]))
982         if exp is not None:
983             return r"\Pi^{%s}%s" % (exp, tex)
984         else:
985             return r"\Pi%s" % tex
986 
987     def _print_beta(self, expr, exp=None):
988         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
989                                         self._print(expr.args[1]))
990 
991         if exp is not None:
992             return r"\operatorname{B}^{%s}%s" % (exp, tex)
993         else:
994             return r"\operatorname{B}%s" % tex
995 
996     def _print_uppergamma(self, expr, exp=None):
997         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
998                                         self._print(expr.args[1]))
999 
1000         if exp is not None:
1001             return r"\Gamma^{%s}%s" % (exp, tex)
1002         else:
1003             return r"\Gamma%s" % tex
1004 
1005     def _print_lowergamma(self, expr, exp=None):
1006         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1007                                         self._print(expr.args[1]))
1008 
1009         if exp is not None:
1010             return r"\gamma^{%s}%s" % (exp, tex)
1011         else:
1012             return r"\gamma%s" % tex
1013 
1014     def _hprint_one_arg_func(self, expr, exp=None):
1015         tex = r"\left(%s\right)" % self._print(expr.args[0])
1016 
1017         if exp is not None:
1018             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1019         else:
1020             return r"%s%s" % (self._print(expr.func), tex)
1021 
1022     _print_gamma = _hprint_one_arg_func
1023 
1024     def _print_Chi(self, expr, exp=None):
1025         tex = r"\left(%s\right)" % self._print(expr.args[0])
1026 
1027         if exp is not None:
1028             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1029         else:
1030             return r"\operatorname{Chi}%s" % tex
1031 
1032     def _print_expint(self, expr, exp=None):
1033         tex = r"\left(%s\right)" % self._print(expr.args[1])
1034         nu = self._print(expr.args[0])
1035 
1036         if exp is not None:
1037             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1038         else:
1039             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1040 
1041     def _print_fresnels(self, expr, exp=None):
1042         tex = r"\left(%s\right)" % self._print(expr.args[0])
1043 
1044         if exp is not None:
1045             return r"S^{%s}%s" % (exp, tex)
1046         else:
1047             return r"S%s" % tex
1048 
1049     def _print_fresnelc(self, expr, exp=None):
1050         tex = r"\left(%s\right)" % self._print(expr.args[0])
1051 
1052         if exp is not None:
1053             return r"C^{%s}%s" % (exp, tex)
1054         else:
1055             return r"C%s" % tex
1056 
1057     def _print_subfactorial(self, expr, exp=None):
1058         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1059 
1060         if exp is not None:
1061             return r"%s^{%s}" % (tex, exp)
1062         else:
1063             return tex
1064 
1065     def _print_factorial(self, expr, exp=None):
1066         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1067 
1068         if exp is not None:
1069             return r"%s^{%s}" % (tex, exp)
1070         else:
1071             return tex
1072 
1073     def _print_factorial2(self, expr, exp=None):
1074         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1075 
1076         if exp is not None:
1077             return r"%s^{%s}" % (tex, exp)
1078         else:
1079             return tex
1080 
1081     def _print_binomial(self, expr, exp=None):
1082         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1083                                      self._print(expr.args[1]))
1084 
1085         if exp is not None:
1086             return r"%s^{%s}" % (tex, exp)
1087         else:
1088             return tex
1089 
1090     def _print_RisingFactorial(self, expr, exp=None):
1091         n, k = expr.args
1092         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1093 
1094         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1095 
1096         return self._do_exponent(tex, exp)
1097 
1098     def _print_FallingFactorial(self, expr, exp=None):
1099         n, k = expr.args
1100         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1101 
1102         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1103 
1104         return self._do_exponent(tex, exp)
1105 
1106     def _hprint_BesselBase(self, expr, exp, sym):
1107         tex = r"%s" % (sym)
1108 
1109         need_exp = False
1110         if exp is not None:
1111             if tex.find('^') == -1:
1112                 tex = r"%s^{%s}" % (tex, self._print(exp))
1113             else:
1114                 need_exp = True
1115 
1116         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1117                                            self._print(expr.argument))
1118 
1119         if need_exp:
1120             tex = self._do_exponent(tex, exp)
1121         return tex
1122 
1123     def _hprint_vec(self, vec):
1124         if len(vec) == 0:
1125             return ""
1126         s = ""
1127         for i in vec[:-1]:
1128             s += "%s, " % self._print(i)
1129         s += self._print(vec[-1])
1130         return s
1131 
1132     def _print_besselj(self, expr, exp=None):
1133         return self._hprint_BesselBase(expr, exp, 'J')
1134 
1135     def _print_besseli(self, expr, exp=None):
1136         return self._hprint_BesselBase(expr, exp, 'I')
1137 
1138     def _print_besselk(self, expr, exp=None):
1139         return self._hprint_BesselBase(expr, exp, 'K')
1140 
1141     def _print_bessely(self, expr, exp=None):
1142         return self._hprint_BesselBase(expr, exp, 'Y')
1143 
1144     def _print_yn(self, expr, exp=None):
1145         return self._hprint_BesselBase(expr, exp, 'y')
1146 
1147     def _print_jn(self, expr, exp=None):
1148         return self._hprint_BesselBase(expr, exp, 'j')
1149 
1150     def _print_hankel1(self, expr, exp=None):
1151         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1152 
1153     def _print_hankel2(self, expr, exp=None):
1154         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1155 
1156     def _print_hn1(self, expr, exp=None):
1157         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1158 
1159     def _print_hn2(self, expr, exp=None):
1160         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1161 
1162     def _hprint_airy(self, expr, exp=None, notation=""):
1163         tex = r"\left(%s\right)" % self._print(expr.args[0])
1164 
1165         if exp is not None:
1166             return r"%s^{%s}%s" % (notation, exp, tex)
1167         else:
1168             return r"%s%s" % (notation, tex)
1169 
1170     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1171         tex = r"\left(%s\right)" % self._print(expr.args[0])
1172 
1173         if exp is not None:
1174             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1175         else:
1176             return r"%s^\prime%s" % (notation, tex)
1177 
1178     def _print_airyai(self, expr, exp=None):
1179         return self._hprint_airy(expr, exp, 'Ai')
1180 
1181     def _print_airybi(self, expr, exp=None):
1182         return self._hprint_airy(expr, exp, 'Bi')
1183 
1184     def _print_airyaiprime(self, expr, exp=None):
1185         return self._hprint_airy_prime(expr, exp, 'Ai')
1186 
1187     def _print_airybiprime(self, expr, exp=None):
1188         return self._hprint_airy_prime(expr, exp, 'Bi')
1189 
1190     def _print_hyper(self, expr, exp=None):
1191         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1192               r"\middle| {%s} \right)}" % \
1193             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1194               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1195               self._print(expr.argument))
1196 
1197         if exp is not None:
1198             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1199         return tex
1200 
1201     def _print_meijerg(self, expr, exp=None):
1202         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1203               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1204             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1205               self._print(len(expr.bm)), self._print(len(expr.an)),
1206               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1207               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1208               self._print(expr.argument))
1209 
1210         if exp is not None:
1211             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1212         return tex
1213 
1214     def _print_dirichlet_eta(self, expr, exp=None):
1215         tex = r"\left(%s\right)" % self._print(expr.args[0])
1216         if exp is not None:
1217             return r"\eta^{%s}%s" % (self._print(exp), tex)
1218         return r"\eta%s" % tex
1219 
1220     def _print_zeta(self, expr, exp=None):
1221         if len(expr.args) == 2:
1222             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1223         else:
1224             tex = r"\left(%s\right)" % self._print(expr.args[0])
1225         if exp is not None:
1226             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1227         return r"\zeta%s" % tex
1228 
1229     def _print_lerchphi(self, expr, exp=None):
1230         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1231         if exp is None:
1232             return r"\Phi%s" % tex
1233         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1234 
1235     def _print_polylog(self, expr, exp=None):
1236         s, z = map(self._print, expr.args)
1237         tex = r"\left(%s\right)" % z
1238         if exp is None:
1239             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1240         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1241 
1242     def _print_jacobi(self, expr, exp=None):
1243         n, a, b, x = map(self._print, expr.args)
1244         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1245         if exp is not None:
1246             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1247         return tex
1248 
1249     def _print_gegenbauer(self, expr, exp=None):
1250         n, a, x = map(self._print, expr.args)
1251         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1252         if exp is not None:
1253             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1254         return tex
1255 
1256     def _print_chebyshevt(self, expr, exp=None):
1257         n, x = map(self._print, expr.args)
1258         tex = r"T_{%s}\left(%s\right)" % (n, x)
1259         if exp is not None:
1260             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1261         return tex
1262 
1263     def _print_chebyshevu(self, expr, exp=None):
1264         n, x = map(self._print, expr.args)
1265         tex = r"U_{%s}\left(%s\right)" % (n, x)
1266         if exp is not None:
1267             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1268         return tex
1269 
1270     def _print_legendre(self, expr, exp=None):
1271         n, x = map(self._print, expr.args)
1272         tex = r"P_{%s}\left(%s\right)" % (n, x)
1273         if exp is not None:
1274             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1275         return tex
1276 
1277     def _print_assoc_legendre(self, expr, exp=None):
1278         n, a, x = map(self._print, expr.args)
1279         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1280         if exp is not None:
1281             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1282         return tex
1283 
1284     def _print_hermite(self, expr, exp=None):
1285         n, x = map(self._print, expr.args)
1286         tex = r"H_{%s}\left(%s\right)" % (n, x)
1287         if exp is not None:
1288             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1289         return tex
1290 
1291     def _print_laguerre(self, expr, exp=None):
1292         n, x = map(self._print, expr.args)
1293         tex = r"L_{%s}\left(%s\right)" % (n, x)
1294         if exp is not None:
1295             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1296         return tex
1297 
1298     def _print_assoc_laguerre(self, expr, exp=None):
1299         n, a, x = map(self._print, expr.args)
1300         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1301         if exp is not None:
1302             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1303         return tex
1304 
1305     def _print_Ynm(self, expr, exp=None):
1306         n, m, theta, phi = map(self._print, expr.args)
1307         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1308         if exp is not None:
1309             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1310         return tex
1311 
1312     def _print_Znm(self, expr, exp=None):
1313         n, m, theta, phi = map(self._print, expr.args)
1314         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1315         if exp is not None:
1316             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1317         return tex
1318 
1319     def _print_Rational(self, expr):
1320         if expr.q != 1:
1321             sign = ""
1322             p = expr.p
1323             if expr.p < 0:
1324                 sign = "- "
1325                 p = -p
1326             if self._settings['fold_short_frac']:
1327                 return r"%s%d / %d" % (sign, p, expr.q)
1328             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1329         else:
1330             return self._print(expr.p)
1331 
1332     def _print_Order(self, expr):
1333         s = self._print(expr.expr)
1334         if expr.point and any(p != S.Zero for p in expr.point) or \
1335            len(expr.variables) > 1:
1336             s += '; '
1337             if len(expr.variables) > 1:
1338                 s += self._print(expr.variables)
1339             elif len(expr.variables):
1340                 s += self._print(expr.variables[0])
1341             s += r'\rightarrow '
1342             if len(expr.point) > 1:
1343                 s += self._print(expr.point)
1344             else:
1345                 s += self._print(expr.point[0])
1346         return r"O\left(%s\right)" % s
1347 
1348     def _print_Symbol(self, expr):
1349         if expr in self._settings['symbol_names']:
1350             return self._settings['symbol_names'][expr]
1351 
1352         return self._deal_with_super_sub(expr.name) if \
1353             '\\' not in expr.name else expr.name
1354 
1355     _print_RandomSymbol = _print_Symbol
1356     _print_MatrixSymbol = _print_Symbol
1357 
1358     def _deal_with_super_sub(self, string):
1359         if '{' in string:
1360             return string
1361 
1362         name, supers, subs = split_super_sub(string)
1363 
1364         name = translate(name)
1365         supers = [translate(sup) for sup in supers]
1366         subs = [translate(sub) for sub in subs]
1367 
1368         # glue all items together:
1369         if len(supers) > 0:
1370             name += "^{%s}" % " ".join(supers)
1371         if len(subs) > 0:
1372             name += "_{%s}" % " ".join(subs)
1373 
1374         return name
1375 
1376     def _print_Relational(self, expr):
1377         if self._settings['itex']:
1378             gt = r"\gt"
1379             lt = r"\lt"
1380         else:
1381             gt = ">"
1382             lt = "<"
1383 
1384         charmap = {
1385             "==": "=",
1386             ">": gt,
1387             "<": lt,
1388             ">=": r"\geq",
1389             "<=": r"\leq",
1390             "!=": r"\neq",
1391         }
1392 
1393         return "%s %s %s" % (self._print(expr.lhs),
1394             charmap[expr.rel_op], self._print(expr.rhs))
1395 
1396     def _print_Piecewise(self, expr):
1397         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1398                    for e, c in expr.args[:-1]]
1399         if expr.args[-1].cond == true:
1400             ecpairs.append(r"%s & \text{otherwise}" %
1401                            self._print(expr.args[-1].expr))
1402         else:
1403             ecpairs.append(r"%s & \text{for}\: %s" %
1404                            (self._print(expr.args[-1].expr),
1405                             self._print(expr.args[-1].cond)))
1406         tex = r"\begin{cases} %s \end{cases}"
1407         return tex % r" \\".join(ecpairs)
1408 
1409     def _print_MatrixBase(self, expr):
1410         lines = []
1411 
1412         for line in range(expr.rows):  # horrible, should be 'rows'
1413             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1414 
1415         mat_str = self._settings['mat_str']
1416         if mat_str is None:
1417             if self._settings['mode'] == 'inline':
1418                 mat_str = 'smallmatrix'
1419             else:
1420                 if (expr.cols <= 10) is True:
1421                     mat_str = 'matrix'
1422                 else:
1423                     mat_str = 'array'
1424 
1425         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1426         out_str = out_str.replace('%MATSTR%', mat_str)
1427         if mat_str == 'array':
1428             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1429         if self._settings['mat_delim']:
1430             left_delim = self._settings['mat_delim']
1431             right_delim = self._delim_dict[left_delim]
1432             out_str = r'\left' + left_delim + out_str + \
1433                       r'\right' + right_delim
1434         return out_str % r"\\".join(lines)
1435     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1436                            = _print_Matrix \
1437                            = _print_MatrixBase
1438 
1439     def _print_MatrixElement(self, expr):
1440         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1441             + '_{%s, %s}' % (expr.i, expr.j)
1442 
1443     def _print_MatrixSlice(self, expr):
1444         def latexslice(x):
1445             x = list(x)
1446             if x[2] == 1:
1447                 del x[2]
1448             if x[1] == x[0] + 1:
1449                 del x[1]
1450             if x[0] == 0:
1451                 x[0] = ''
1452             return ':'.join(map(self._print, x))
1453         return (self._print(expr.parent) + r'\left[' +
1454                 latexslice(expr.rowslice) + ', ' +
1455                 latexslice(expr.colslice) + r'\right]')
1456 
1457     def _print_BlockMatrix(self, expr):
1458         return self._print(expr.blocks)
1459 
1460     def _print_Transpose(self, expr):
1461         mat = expr.arg
1462         from sympy.matrices import MatrixSymbol
1463         if not isinstance(mat, MatrixSymbol):
1464             return r"\left(%s\right)^T" % self._print(mat)
1465         else:
1466             return "%s^T" % self._print(mat)
1467 
1468     def _print_Trace(self, expr):
1469         mat = expr.arg
1470         return r"\mathrm{tr}\left (%s \right )" % self._print(mat)
1471 
1472     def _print_Adjoint(self, expr):
1473         mat = expr.arg
1474         from sympy.matrices import MatrixSymbol
1475         if not isinstance(mat, MatrixSymbol):
1476             return r"\left(%s\right)^\dagger" % self._print(mat)
1477         else:
1478             return r"%s^\dagger" % self._print(mat)
1479 
1480     def _print_MatMul(self, expr):
1481         from sympy import Add, MatAdd, HadamardProduct, MatMul, Mul
1482 
1483         parens = lambda x: self.parenthesize(x, precedence_traditional(expr), False)
1484 
1485         args = expr.args
1486         if isinstance(args[0], Mul):
1487             args = args[0].as_ordered_factors() + list(args[1:])
1488         else:
1489             args = list(args)
1490 
1491         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1492             if args[0] == -1:
1493                 args = args[1:]
1494             else:
1495                 args[0] = -args[0]
1496             return '- ' + ' '.join(map(parens, args))
1497         else:
1498             return ' '.join(map(parens, args))
1499 
1500     def _print_Mod(self, expr, exp=None):
1501         if exp is not None:
1502             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1503                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1504         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1505                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1506 
1507     def _print_HadamardProduct(self, expr):
1508         from sympy import Add, MatAdd, MatMul
1509 
1510         def parens(x):
1511             if isinstance(x, (Add, MatAdd, MatMul)):
1512                 return r"\left(%s\right)" % self._print(x)
1513             return self._print(x)
1514         return r' \circ '.join(map(parens, expr.args))
1515 
1516     def _print_KroneckerProduct(self, expr):
1517         from sympy import Add, MatAdd, MatMul
1518 
1519         def parens(x):
1520             if isinstance(x, (Add, MatAdd, MatMul)):
1521                 return r"\left(%s\right)" % self._print(x)
1522             return self._print(x)
1523         return r' \otimes '.join(map(parens, expr.args))
1524 
1525     def _print_MatPow(self, expr):
1526         base, exp = expr.base, expr.exp
1527         from sympy.matrices import MatrixSymbol
1528         if not isinstance(base, MatrixSymbol):
1529             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1530         else:
1531             return "%s^{%s}" % (self._print(base), self._print(exp))
1532 
1533     def _print_ZeroMatrix(self, Z):
1534         return r"\mathbb{0}"
1535 
1536     def _print_Identity(self, I):
1537         return r"\mathbb{I}"
1538 
1539     def _print_NDimArray(self, expr):
1540 
1541         if expr.rank() == 0:
1542             return self._print(expr[()])
1543 
1544         mat_str = self._settings['mat_str']
1545         if mat_str is None:
1546             if self._settings['mode'] == 'inline':
1547                 mat_str = 'smallmatrix'
1548             else:
1549                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1550                     mat_str = 'matrix'
1551                 else:
1552                     mat_str = 'array'
1553         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1554         block_str = block_str.replace('%MATSTR%', mat_str)
1555         if self._settings['mat_delim']:
1556             left_delim = self._settings['mat_delim']
1557             right_delim = self._delim_dict[left_delim]
1558             block_str = r'\left' + left_delim + block_str + \
1559                       r'\right' + right_delim
1560 
1561         if expr.rank() == 0:
1562             return block_str % ""
1563 
1564         level_str = [[]] + [[] for i in range(expr.rank())]
1565         shape_ranges = [list(range(i)) for i in expr.shape]
1566         for outer_i in itertools.product(*shape_ranges):
1567             level_str[-1].append(self._print(expr[outer_i]))
1568             even = True
1569             for back_outer_i in range(expr.rank()-1, -1, -1):
1570                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1571                     break
1572                 if even:
1573                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1574                 else:
1575                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1576                     if len(level_str[back_outer_i+1]) == 1:
1577                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1578                 even = not even
1579                 level_str[back_outer_i+1] = []
1580 
1581         out_str = level_str[0][0]
1582 
1583         if expr.rank() % 2 == 1:
1584             out_str = block_str % out_str
1585 
1586         return out_str
1587 
1588     _print_ImmutableDenseNDimArray = _print_NDimArray
1589     _print_ImmutableSparseNDimArray = _print_NDimArray
1590     _print_MutableDenseNDimArray = _print_NDimArray
1591     _print_MutableSparseNDimArray = _print_NDimArray
1592 
1593     def _printer_tensor_indices(self, name, indices, index_map={}):
1594         out_str = self._print(name)
1595         last_valence = None
1596         prev_map = None
1597         for index in indices:
1598             new_valence = index.is_up
1599             if ((index in index_map) or prev_map) and last_valence == new_valence:
1600                 out_str += ","
1601             if last_valence != new_valence:
1602                 if last_valence is not None:
1603                     out_str += "}"
1604                 if index.is_up:
1605                     out_str += "{}^{"
1606                 else:
1607                     out_str += "{}_{"
1608             out_str += self._print(index.args[0])
1609             if index in index_map:
1610                 out_str += "="
1611                 out_str += self._print(index_map[index])
1612                 prev_map = True
1613             else:
1614                 prev_map = False
1615             last_valence = new_valence
1616         if last_valence is not None:
1617             out_str += "}"
1618         return out_str
1619 
1620     def _print_Tensor(self, expr):
1621         name = expr.args[0].args[0]
1622         indices = expr.get_indices()
1623         return self._printer_tensor_indices(name, indices)
1624 
1625     def _print_TensorElement(self, expr):
1626         name = expr.expr.args[0].args[0]
1627         indices = expr.expr.get_indices()
1628         index_map = expr.index_map
1629         return self._printer_tensor_indices(name, indices, index_map)
1630 
1631     def _print_TensMul(self, expr):
1632         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1633         sign, args = expr._get_args_for_traditional_printer()
1634         return sign + "".join(
1635             [self.parenthesize(arg, precedence(expr)) for arg in args]
1636         )
1637 
1638     def _print_TensAdd(self, expr):
1639         a = []
1640         args = expr.args
1641         for x in args:
1642             a.append(self.parenthesize(x, precedence(expr)))
1643         a.sort()
1644         s = ' + '.join(a)
1645         s = s.replace('+ -', '- ')
1646         return s
1647 
1648     def _print_TensorIndex(self, expr):
1649         return "{}%s{%s}" % (
1650             "^" if expr.is_up else "_",
1651             self._print(expr.args[0])
1652         )
1653         return self._print(expr.args[0])
1654 
1655     def _print_tuple(self, expr):
1656         return r"\left ( %s\right )" % \
1657             r", \quad ".join([ self._print(i) for i in expr ])
1658 
1659     def _print_TensorProduct(self, expr):
1660         elements = [self._print(a) for a in expr.args]
1661         return r' \otimes '.join(elements)
1662 
1663     def _print_WedgeProduct(self, expr):
1664         elements = [self._print(a) for a in expr.args]
1665         return r' \wedge '.join(elements)
1666 
1667     def _print_Tuple(self, expr):
1668         return self._print_tuple(expr)
1669 
1670     def _print_list(self, expr):
1671         return r"\left [ %s\right ]" % \
1672             r", \quad ".join([ self._print(i) for i in expr ])
1673 
1674     def _print_dict(self, d):
1675         keys = sorted(d.keys(), key=default_sort_key)
1676         items = []
1677 
1678         for key in keys:
1679             val = d[key]
1680             items.append("%s : %s" % (self._print(key), self._print(val)))
1681 
1682         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1683 
1684     def _print_Dict(self, expr):
1685         return self._print_dict(expr)
1686 
1687     def _print_DiracDelta(self, expr, exp=None):
1688         if len(expr.args) == 1 or expr.args[1] == 0:
1689             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1690         else:
1691             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1692                 self._print(expr.args[1]), self._print(expr.args[0]))
1693         if exp:
1694             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1695         return tex
1696 
1697     def _print_SingularityFunction(self, expr):
1698         shift = self._print(expr.args[0] - expr.args[1])
1699         power = self._print(expr.args[2])
1700         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1701         return tex
1702 
1703     def _print_Heaviside(self, expr, exp=None):
1704         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1705         if exp:
1706             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1707         return tex
1708 
1709     def _print_KroneckerDelta(self, expr, exp=None):
1710         i = self._print(expr.args[0])
1711         j = self._print(expr.args[1])
1712         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1713             tex = r'\delta_{%s %s}' % (i, j)
1714         else:
1715             tex = r'\delta_{%s, %s}' % (i, j)
1716         if exp:
1717             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1718         return tex
1719 
1720     def _print_LeviCivita(self, expr, exp=None):
1721         indices = map(self._print, expr.args)
1722         if all(x.is_Atom for x in expr.args):
1723             tex = r'\varepsilon_{%s}' % " ".join(indices)
1724         else:
1725             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1726         if exp:
1727             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1728         return tex
1729 
1730     def _print_ProductSet(self, p):
1731         if len(p.sets) > 1 and not has_variety(p.sets):
1732             return self._print(p.sets[0]) + "^{%d}" % len(p.sets)
1733         else:
1734             return r" \times ".join(self._print(set) for set in p.sets)
1735 
1736     def _print_RandomDomain(self, d):
1737         if hasattr(d, 'as_boolean'):
1738             return 'Domain: ' + self._print(d.as_boolean())
1739         elif hasattr(d, 'set'):
1740             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1741                     self._print(d.set))
1742         elif hasattr(d, 'symbols'):
1743             return 'Domain on ' + self._print(d.symbols)
1744         else:
1745             return self._print(None)
1746 
1747     def _print_FiniteSet(self, s):
1748         items = sorted(s.args, key=default_sort_key)
1749         return self._print_set(items)
1750 
1751     def _print_set(self, s):
1752         items = sorted(s, key=default_sort_key)
1753         items = ", ".join(map(self._print, items))
1754         return r"\left\{%s\right\}" % items
1755 
1756     _print_frozenset = _print_set
1757 
1758     def _print_Range(self, s):
1759         dots = r'\ldots'
1760 
1761         if s.start.is_infinite:
1762             printset = s.start, dots, s[-1] - s.step, s[-1]
1763         elif s.stop.is_infinite or len(s) > 4:
1764             it = iter(s)
1765             printset = next(it), next(it), dots, s[-1]
1766         else:
1767             printset = tuple(s)
1768 
1769         return (r"\left\{"
1770               + r", ".join(self._print(el) for el in printset)
1771               + r"\right\}")
1772 
1773     def _print_SeqFormula(self, s):
1774         if s.start is S.NegativeInfinity:
1775             stop = s.stop
1776             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1777                 s.coeff(stop - 1), s.coeff(stop))
1778         elif s.stop is S.Infinity or s.length > 4:
1779             printset = s[:4]
1780             printset.append(r'\ldots')
1781         else:
1782             printset = tuple(s)
1783 
1784         return (r"\left["
1785               + r", ".join(self._print(el) for el in printset)
1786               + r"\right]")
1787 
1788     _print_SeqPer = _print_SeqFormula
1789     _print_SeqAdd = _print_SeqFormula
1790     _print_SeqMul = _print_SeqFormula
1791 
1792     def _print_Interval(self, i):
1793         if i.start == i.end:
1794             return r"\left\{%s\right\}" % self._print(i.start)
1795 
1796         else:
1797             if i.left_open:
1798                 left = '('
1799             else:
1800                 left = '['
1801 
1802             if i.right_open:
1803                 right = ')'
1804             else:
1805                 right = ']'
1806 
1807             return r"\left%s%s, %s\right%s" % \
1808                    (left, self._print(i.start), self._print(i.end), right)
1809 
1810     def _print_AccumulationBounds(self, i):
1811         return r"\langle %s, %s\rangle" % \
1812                 (self._print(i.min), self._print(i.max))
1813 
1814     def _print_Union(self, u):
1815         return r" \cup ".join([self._print(i) for i in u.args])
1816 
1817     def _print_Complement(self, u):
1818         return r" \setminus ".join([self._print(i) for i in u.args])
1819 
1820     def _print_Intersection(self, u):
1821         return r" \cap ".join([self._print(i) for i in u.args])
1822 
1823     def _print_SymmetricDifference(self, u):
1824         return r" \triangle ".join([self._print(i) for i in u.args])
1825 
1826     def _print_EmptySet(self, e):
1827         return r"\emptyset"
1828 
1829     def _print_Naturals(self, n):
1830         return r"\mathbb{N}"
1831 
1832     def _print_Naturals0(self, n):
1833         return r"\mathbb{N}_0"
1834 
1835     def _print_Integers(self, i):
1836         return r"\mathbb{Z}"
1837 
1838     def _print_Reals(self, i):
1839         return r"\mathbb{R}"
1840 
1841     def _print_Complexes(self, i):
1842         return r"\mathbb{C}"
1843 
1844     def _print_ImageSet(self, s):
1845         sets = s.args[1:]
1846         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1847             for var, setv in zip(s.lamda.variables, sets)]
1848         return r"\left\{%s\; |\; %s\right\}" % (
1849             self._print(s.lamda.expr),
1850             ', '.join(varsets))
1851 
1852     def _print_ConditionSet(self, s):
1853         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1854         if s.base_set is S.UniversalSet:
1855             return r"\left\{%s \mid %s \right\}" % (
1856             vars_print,
1857             self._print(s.condition.as_expr()))
1858 
1859         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1860             vars_print,
1861             vars_print,
1862             self._print(s.base_set),
1863             self._print(s.condition.as_expr()))
1864 
1865     def _print_ComplexRegion(self, s):
1866         vars_print = ', '.join([self._print(var) for var in s.variables])
1867         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1868             self._print(s.expr),
1869             vars_print,
1870             self._print(s.sets))
1871 
1872     def _print_Contains(self, e):
1873         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1874 
1875     def _print_FourierSeries(self, s):
1876         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1877 
1878     def _print_FormalPowerSeries(self, s):
1879         return self._print_Add(s.infinite)
1880 
1881     def _print_FiniteField(self, expr):
1882         return r"\mathbb{F}_{%s}" % expr.mod
1883 
1884     def _print_IntegerRing(self, expr):
1885         return r"\mathbb{Z}"
1886 
1887     def _print_RationalField(self, expr):
1888         return r"\mathbb{Q}"
1889 
1890     def _print_RealField(self, expr):
1891         return r"\mathbb{R}"
1892 
1893     def _print_ComplexField(self, expr):
1894         return r"\mathbb{C}"
1895 
1896     def _print_PolynomialRing(self, expr):
1897         domain = self._print(expr.domain)
1898         symbols = ", ".join(map(self._print, expr.symbols))
1899         return r"%s\left[%s\right]" % (domain, symbols)
1900 
1901     def _print_FractionField(self, expr):
1902         domain = self._print(expr.domain)
1903         symbols = ", ".join(map(self._print, expr.symbols))
1904         return r"%s\left(%s\right)" % (domain, symbols)
1905 
1906     def _print_PolynomialRingBase(self, expr):
1907         domain = self._print(expr.domain)
1908         symbols = ", ".join(map(self._print, expr.symbols))
1909         inv = ""
1910         if not expr.is_Poly:
1911             inv = r"S_<^{-1}"
1912         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1913 
1914     def _print_Poly(self, poly):
1915         cls = poly.__class__.__name__
1916         terms = []
1917         for monom, coeff in poly.terms():
1918             s_monom = ''
1919             for i, exp in enumerate(monom):
1920                 if exp > 0:
1921                     if exp == 1:
1922                         s_monom += self._print(poly.gens[i])
1923                     else:
1924                         s_monom += self._print(pow(poly.gens[i], exp))
1925 
1926             if coeff.is_Add:
1927                 if s_monom:
1928                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1929                 else:
1930                     s_coeff = self._print(coeff)
1931             else:
1932                 if s_monom:
1933                     if coeff is S.One:
1934                         terms.extend(['+', s_monom])
1935                         continue
1936 
1937                     if coeff is S.NegativeOne:
1938                         terms.extend(['-', s_monom])
1939                         continue
1940 
1941                 s_coeff = self._print(coeff)
1942 
1943             if not s_monom:
1944                 s_term = s_coeff
1945             else:
1946                 s_term = s_coeff + " " + s_monom
1947 
1948             if s_term.startswith('-'):
1949                 terms.extend(['-', s_term[1:]])
1950             else:
1951                 terms.extend(['+', s_term])
1952 
1953         if terms[0] in ['-', '+']:
1954             modifier = terms.pop(0)
1955 
1956             if modifier == '-':
1957                 terms[0] = '-' + terms[0]
1958 
1959         expr = ' '.join(terms)
1960         gens = list(map(self._print, poly.gens))
1961         domain = "domain=%s" % self._print(poly.get_domain())
1962 
1963         args = ", ".join([expr] + gens + [domain])
1964         if cls in accepted_latex_functions:
1965             tex = r"\%s {\left (%s \right )}" % (cls, args)
1966         else:
1967             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1968 
1969         return tex
1970 
1971     def _print_ComplexRootOf(self, root):
1972         cls = root.__class__.__name__
1973         if cls == "ComplexRootOf":
1974             cls = "CRootOf"
1975         expr = self._print(root.expr)
1976         index = root.index
1977         if cls in accepted_latex_functions:
1978             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1979         else:
1980             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1981 
1982     def _print_RootSum(self, expr):
1983         cls = expr.__class__.__name__
1984         args = [self._print(expr.expr)]
1985 
1986         if expr.fun is not S.IdentityFunction:
1987             args.append(self._print(expr.fun))
1988 
1989         if cls in accepted_latex_functions:
1990             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1991         else:
1992             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1993 
1994     def _print_PolyElement(self, poly):
1995         mul_symbol = self._settings['mul_symbol_latex']
1996         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1997 
1998     def _print_FracElement(self, frac):
1999         if frac.denom == 1:
2000             return self._print(frac.numer)
2001         else:
2002             numer = self._print(frac.numer)
2003             denom = self._print(frac.denom)
2004             return r"\frac{%s}{%s}" % (numer, denom)
2005 
2006     def _print_euler(self, expr, exp=None):
2007         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2008         tex = r"E_{%s}" % self._print(m)
2009         if exp is not None:
2010             tex = r"%s^{%s}" % (tex, self._print(exp))
2011         if x is not None:
2012             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2013         return tex
2014 
2015     def _print_catalan(self, expr, exp=None):
2016         tex = r"C_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_MellinTransform(self, expr):
2022         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2023 
2024     def _print_InverseMellinTransform(self, expr):
2025         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2026 
2027     def _print_LaplaceTransform(self, expr):
2028         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2029 
2030     def _print_InverseLaplaceTransform(self, expr):
2031         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2032 
2033     def _print_FourierTransform(self, expr):
2034         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2035 
2036     def _print_InverseFourierTransform(self, expr):
2037         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2038 
2039     def _print_SineTransform(self, expr):
2040         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2041 
2042     def _print_InverseSineTransform(self, expr):
2043         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2044 
2045     def _print_CosineTransform(self, expr):
2046         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2047 
2048     def _print_InverseCosineTransform(self, expr):
2049         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2050 
2051     def _print_DMP(self, p):
2052         try:
2053             if p.ring is not None:
2054                 # TODO incorporate order
2055                 return self._print(p.ring.to_sympy(p))
2056         except SympifyError:
2057             pass
2058         return self._print(repr(p))
2059 
2060     def _print_DMF(self, p):
2061         return self._print_DMP(p)
2062 
2063     def _print_Object(self, object):
2064         return self._print(Symbol(object.name))
2065 
2066     def _print_Morphism(self, morphism):
2067         domain = self._print(morphism.domain)
2068         codomain = self._print(morphism.codomain)
2069         return "%s\\rightarrow %s" % (domain, codomain)
2070 
2071     def _print_NamedMorphism(self, morphism):
2072         pretty_name = self._print(Symbol(morphism.name))
2073         pretty_morphism = self._print_Morphism(morphism)
2074         return "%s:%s" % (pretty_name, pretty_morphism)
2075 
2076     def _print_IdentityMorphism(self, morphism):
2077         from sympy.categories import NamedMorphism
2078         return self._print_NamedMorphism(NamedMorphism(
2079             morphism.domain, morphism.codomain, "id"))
2080 
2081     def _print_CompositeMorphism(self, morphism):
2082         # All components of the morphism have names and it is thus
2083         # possible to build the name of the composite.
2084         component_names_list = [self._print(Symbol(component.name)) for
2085                                 component in morphism.components]
2086         component_names_list.reverse()
2087         component_names = "\\circ ".join(component_names_list) + ":"
2088 
2089         pretty_morphism = self._print_Morphism(morphism)
2090         return component_names + pretty_morphism
2091 
2092     def _print_Category(self, morphism):
2093         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2094 
2095     def _print_Diagram(self, diagram):
2096         if not diagram.premises:
2097             # This is an empty diagram.
2098             return self._print(S.EmptySet)
2099 
2100         latex_result = self._print(diagram.premises)
2101         if diagram.conclusions:
2102             latex_result += "\\Longrightarrow %s" % \
2103                             self._print(diagram.conclusions)
2104 
2105         return latex_result
2106 
2107     def _print_DiagramGrid(self, grid):
2108         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2109 
2110         for i in range(grid.height):
2111             for j in range(grid.width):
2112                 if grid[i, j]:
2113                     latex_result += latex(grid[i, j])
2114                 latex_result += " "
2115                 if j != grid.width - 1:
2116                     latex_result += "& "
2117 
2118             if i != grid.height - 1:
2119                 latex_result += "\\\\"
2120             latex_result += "\n"
2121 
2122         latex_result += "\\end{array}\n"
2123         return latex_result
2124 
2125     def _print_FreeModule(self, M):
2126         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2127 
2128     def _print_FreeModuleElement(self, m):
2129         # Print as row vector for convenience, for now.
2130         return r"\left[ %s \right]" % ",".join(
2131             '{' + self._print(x) + '}' for x in m)
2132 
2133     def _print_SubModule(self, m):
2134         return r"\left< %s \right>" % ",".join(
2135             '{' + self._print(x) + '}' for x in m.gens)
2136 
2137     def _print_ModuleImplementedIdeal(self, m):
2138         return r"\left< %s \right>" % ",".join(
2139             '{' + self._print(x) + '}' for [x] in m._module.gens)
2140 
2141     def _print_Quaternion(self, expr):
2142         # TODO: This expression is potentially confusing,
2143         # shall we print it as `Quaternion( ... )`?
2144         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2145         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2146         return " + ".join(a)
2147 
2148     def _print_QuotientRing(self, R):
2149         # TODO nicer fractions for few generators...
2150         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2151 
2152     def _print_QuotientRingElement(self, x):
2153         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2154 
2155     def _print_QuotientModuleElement(self, m):
2156         return r"{%s} + {%s}" % (self._print(m.data),
2157                                  self._print(m.module.killed_module))
2158 
2159     def _print_QuotientModule(self, M):
2160         # TODO nicer fractions for few generators...
2161         return r"\frac{%s}{%s}" % (self._print(M.base),
2162                                    self._print(M.killed_module))
2163 
2164     def _print_MatrixHomomorphism(self, h):
2165         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2166             self._print(h.domain), self._print(h.codomain))
2167 
2168     def _print_BaseScalarField(self, field):
2169         string = field._coord_sys._names[field._index]
2170         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2171 
2172     def _print_BaseVectorField(self, field):
2173         string = field._coord_sys._names[field._index]
2174         return r'\partial_{%s}' % self._print(Symbol(string))
2175 
2176     def _print_Differential(self, diff):
2177         field = diff._form_field
2178         if hasattr(field, '_coord_sys'):
2179             string = field._coord_sys._names[field._index]
2180             return r'\mathrm{d}%s' % self._print(Symbol(string))
2181         else:
2182             return 'd(%s)' % self._print(field)
2183             string = self._print(field)
2184             return r'\mathrm{d}\left(%s\right)' % string
2185 
2186     def _print_Tr(self, p):
2187         #Todo: Handle indices
2188         contents = self._print(p.args[0])
2189         return r'\mbox{Tr}\left(%s\right)' % (contents)
2190 
2191     def _print_totient(self, expr, exp=None):
2192         if exp is not None:
2193             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2194                     self._print(exp))
2195         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2196 
2197     def _print_reduced_totient(self, expr, exp=None):
2198         if exp is not None:
2199             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2200                     self._print(exp))
2201         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2202 
2203     def _print_divisor_sigma(self, expr, exp=None):
2204         if len(expr.args) == 2:
2205             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2206                                                 (expr.args[1], expr.args[0])))
2207         else:
2208             tex = r"\left(%s\right)" % self._print(expr.args[0])
2209         if exp is not None:
2210             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2211         return r"\sigma%s" % tex
2212 
2213     def _print_udivisor_sigma(self, expr, exp=None):
2214         if len(expr.args) == 2:
2215             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2216                                                 (expr.args[1], expr.args[0])))
2217         else:
2218             tex = r"\left(%s\right)" % self._print(expr.args[0])
2219         if exp is not None:
2220             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2221         return r"\sigma^*%s" % tex
2222 
2223     def _print_primenu(self, expr, exp=None):
2224         if exp is not None:
2225             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2226                     self._print(exp))
2227         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2228 
2229     def _print_primeomega(self, expr, exp=None):
2230         if exp is not None:
2231             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2232                     self._print(exp))
2233         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Sum</method>
<code>
547     def _print_Sum(self, expr):
548         if len(expr.limits) == 1:
549             tex = r"\sum_{%s=%s}^{%s} " % \
550                 tuple([ self._print(i) for i in expr.limits[0] ])
551         else:
552             def _format_ineq(l):
553                 return r"%s \leq %s \leq %s" % \
554                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
555 
556             tex = r"\sum_{\substack{%s}} " % \
557                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
558 
559         if isinstance(expr.function, Add):
560             tex += r"\left(%s\right)" % self._print(expr.function)
561         else:
562             tex += self._print(expr.function)
563 
564         return tex

</code><intended_behavior>Given that the issue involves a summation representation (\sum) as part of the matrix product indexing, this method should correctly handle the generation of summation symbols along with their indices in LaTeX format. The _print_Sum method needs to ensure that indices and their bounds are formatted so that they do not result in syntax errors like double subscripts. It may require adjusting how indexed variables are named or displayed in the summation context. The goal is to maintain mathematical integrity and notational clarity while providing LaTeX that renders correctly in all supported environments.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
121 class LatexPrinter(Printer):
122     printmethod = "_latex"
123 
124     _default_settings = {
125         "order": None,
126         "mode": "plain",
127         "itex": False,
128         "fold_frac_powers": False,
129         "fold_func_brackets": False,
130         "fold_short_frac": None,
131         "long_frac_ratio": None,
132         "mul_symbol": None,
133         "inv_trig_style": "abbreviated",
134         "mat_str": None,
135         "mat_delim": "[",
136         "symbol_names": {},
137         "ln_notation": False,
138     }
139 
140     def __init__(self, settings=None):
141         Printer.__init__(self, settings)
142 
143         if 'mode' in self._settings:
144             valid_modes = ['inline', 'plain', 'equation',
145                            'equation*']
146             if self._settings['mode'] not in valid_modes:
147                 raise ValueError("'mode' must be one of 'inline', 'plain', "
148                     "'equation' or 'equation*'")
149 
150         if self._settings['fold_short_frac'] is None and \
151                 self._settings['mode'] == 'inline':
152             self._settings['fold_short_frac'] = True
153 
154         mul_symbol_table = {
155             None: r" ",
156             "ldot": r" \,.\, ",
157             "dot": r" \cdot ",
158             "times": r" \times "
159         }
160         try:
161             self._settings['mul_symbol_latex'] = \
162                 mul_symbol_table[self._settings['mul_symbol']]
163         except KeyError:
164             self._settings['mul_symbol_latex'] = \
165                 self._settings['mul_symbol']
166         try:
167             self._settings['mul_symbol_latex_numbers'] = \
168                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
169         except KeyError:
170             if (self._settings['mul_symbol'].strip() in
171                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
172                 self._settings['mul_symbol_latex_numbers'] = \
173                     mul_symbol_table['dot']
174             else:
175                 self._settings['mul_symbol_latex_numbers'] = \
176                     self._settings['mul_symbol']
177 
178         self._delim_dict = {'(': ')', '[': ']'}
179 
180     def parenthesize(self, item, level, strict=False):
181         prec_val = precedence_traditional(item)
182         if (prec_val < level) or ((not strict) and prec_val <= level):
183             return r"\left(%s\right)" % self._print(item)
184         else:
185             return self._print(item)
186 
187     def doprint(self, expr):
188         tex = Printer.doprint(self, expr)
189 
190         if self._settings['mode'] == 'plain':
191             return tex
192         elif self._settings['mode'] == 'inline':
193             return r"$%s$" % tex
194         elif self._settings['itex']:
195             return r"$$%s$$" % tex
196         else:
197             env_str = self._settings['mode']
198             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
199 
200     def _needs_brackets(self, expr):
201         """
202         Returns True if the expression needs to be wrapped in brackets when
203         printed, False otherwise. For example: a + b => True; a => False;
204         10 => False; -10 => True.
205         """
206         return not ((expr.is_Integer and expr.is_nonnegative)
207                     or (expr.is_Atom and (expr is not S.NegativeOne
208                                           and expr.is_Rational is False)))
209 
210     def _needs_function_brackets(self, expr):
211         """
212         Returns True if the expression needs to be wrapped in brackets when
213         passed as an argument to a function, False otherwise. This is a more
214         liberal version of _needs_brackets, in that many expressions which need
215         to be wrapped in brackets when added/subtracted/raised to a power do
216         not need them when passed to a function. Such an example is a*b.
217         """
218         if not self._needs_brackets(expr):
219             return False
220         else:
221             # Muls of the form a*b*c... can be folded
222             if expr.is_Mul and not self._mul_is_clean(expr):
223                 return True
224             # Pows which don't need brackets can be folded
225             elif expr.is_Pow and not self._pow_is_clean(expr):
226                 return True
227             # Add and Function always need brackets
228             elif expr.is_Add or expr.is_Function:
229                 return True
230             else:
231                 return False
232 
233     def _needs_mul_brackets(self, expr, first=False, last=False):
234         """
235         Returns True if the expression needs to be wrapped in brackets when
236         printed as part of a Mul, False otherwise. This is True for Add,
237         but also for some container objects that would not need brackets
238         when appearing last in a Mul, e.g. an Integral. ``last=True``
239         specifies that this expr is the last to appear in a Mul.
240         ``first=True`` specifies that this expr is the first to appear in a Mul.
241         """
242         from sympy import Integral, Piecewise, Product, Sum
243 
244         if expr.is_Mul:
245             if not first and _coeff_isneg(expr):
246                 return True
247         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
248             return True
249         elif expr.is_Relational:
250             return True
251         if expr.is_Piecewise:
252             return True
253         if any([expr.has(x) for x in (Mod,)]):
254             return True
255         if (not last and
256             any([expr.has(x) for x in (Integral, Product, Sum)])):
257             return True
258 
259         return False
260 
261 
262     def _needs_add_brackets(self, expr):
263         """
264         Returns True if the expression needs to be wrapped in brackets when
265         printed as part of an Add, False otherwise.  This is False for most
266         things.
267         """
268         if expr.is_Relational:
269             return True
270         if any([expr.has(x) for x in (Mod,)]):
271             return True
272         if expr.is_Add:
273             return True
274         return False
275 
276 
277     def _mul_is_clean(self, expr):
278         for arg in expr.args:
279             if arg.is_Function:
280                 return False
281         return True
282 
283     def _pow_is_clean(self, expr):
284         return not self._needs_brackets(expr.base)
285 
286     def _do_exponent(self, expr, exp):
287         if exp is not None:
288             return r"\left(%s\right)^{%s}" % (expr, exp)
289         else:
290             return expr
291 
292     def _print_Basic(self, expr):
293         l = [self._print(o) for o in expr.args]
294         return self._deal_with_super_sub(expr.__class__.__name__) + r"\left(%s\right)" % ", ".join(l)
295 
296     def _print_bool(self, e):
297         return r"\mathrm{%s}" % e
298 
299     _print_BooleanTrue = _print_bool
300     _print_BooleanFalse = _print_bool
301 
302     def _print_NoneType(self, e):
303         return r"\mathrm{%s}" % e
304 
305     def _print_Add(self, expr, order=None):
306         if self.order == 'none':
307             terms = list(expr.args)
308         else:
309             terms = self._as_ordered_terms(expr, order=order)
310 
311         tex = ""
312         for i, term in enumerate(terms):
313             if i == 0:
314                 pass
315             elif _coeff_isneg(term):
316                 tex += " - "
317                 term = -term
318             else:
319                 tex += " + "
320             term_tex = self._print(term)
321             if self._needs_add_brackets(term):
322                 term_tex = r"\left(%s\right)" % term_tex
323             tex += term_tex
324 
325         return tex
326 
327     def _print_Cycle(self, expr):
328         from sympy.combinatorics.permutations import Permutation
329         if expr.size == 0:
330             return r"\left( \right)"
331         expr = Permutation(expr)
332         expr_perm = expr.cyclic_form
333         siz = expr.size
334         if expr.array_form[-1] == siz - 1:
335             expr_perm = expr_perm + [[siz - 1]]
336         term_tex = ''
337         for i in expr_perm:
338             term_tex += str(i).replace(',', r"\;")
339         term_tex = term_tex.replace('[', r"\left( ")
340         term_tex = term_tex.replace(']', r"\right)")
341         return term_tex
342 
343     _print_Permutation = _print_Cycle
344 
345     def _print_Float(self, expr):
346         # Based off of that in StrPrinter
347         dps = prec_to_dps(expr._prec)
348         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)
349 
350         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
351         # thus we use the number separator
352         separator = self._settings['mul_symbol_latex_numbers']
353 
354         if 'e' in str_real:
355             (mant, exp) = str_real.split('e')
356 
357             if exp[0] == '+':
358                 exp = exp[1:]
359 
360             return r"%s%s10^{%s}" % (mant, separator, exp)
361         elif str_real == "+inf":
362             return r"\infty"
363         elif str_real == "-inf":
364             return r"- \infty"
365         else:
366             return str_real
367 
368     def _print_Cross(self, expr):
369         vec1 = expr._expr1
370         vec2 = expr._expr2
371         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
372                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
373 
374     def _print_Curl(self, expr):
375         vec = expr._expr
376         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
377 
378     def _print_Divergence(self, expr):
379         vec = expr._expr
380         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
381 
382     def _print_Dot(self, expr):
383         vec1 = expr._expr1
384         vec2 = expr._expr2
385         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
386                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
387 
388     def _print_Gradient(self, expr):
389         func = expr._expr
390         return r"\nabla\cdot %s" % self.parenthesize(func, PRECEDENCE['Mul'])
391 
392     def _print_Mul(self, expr):
393         from sympy.core.power import Pow
394         from sympy.physics.units import Quantity
395         include_parens = False
396         if _coeff_isneg(expr):
397             expr = -expr
398             tex = "- "
399             if expr.is_Add:
400                 tex += "("
401                 include_parens = True
402         else:
403             tex = ""
404 
405         from sympy.simplify import fraction
406         numer, denom = fraction(expr, exact=True)
407         separator = self._settings['mul_symbol_latex']
408         numbersep = self._settings['mul_symbol_latex_numbers']
409 
410         def convert(expr):
411             if not expr.is_Mul:
412                 return str(self._print(expr))
413             else:
414                 _tex = last_term_tex = ""
415 
416                 if self.order not in ('old', 'none'):
417                     args = expr.as_ordered_factors()
418                 else:
419                     args = list(expr.args)
420 
421                 # If quantities are present append them at the back
422                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
423                              (isinstance(x, Pow) and isinstance(x.base, Quantity)))
424 
425                 for i, term in enumerate(args):
426                     term_tex = self._print(term)
427 
428                     if self._needs_mul_brackets(term, first=(i == 0),
429                                                 last=(i == len(args) - 1)):
430                         term_tex = r"\left(%s\right)" % term_tex
431 
432                     if _between_two_numbers_p[0].search(last_term_tex) and \
433                             _between_two_numbers_p[1].match(term_tex):
434                         # between two numbers
435                         _tex += numbersep
436                     elif _tex:
437                         _tex += separator
438 
439                     _tex += term_tex
440                     last_term_tex = term_tex
441                 return _tex
442 
443         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
444             # use the original expression here, since fraction() may have
445             # altered it when producing numer and denom
446             tex += convert(expr)
447 
448         else:
449             snumer = convert(numer)
450             sdenom = convert(denom)
451             ldenom = len(sdenom.split())
452             ratio = self._settings['long_frac_ratio']
453             if self._settings['fold_short_frac'] \
454                    and ldenom <= 2 and not "^" in sdenom:
455                 # handle short fractions
456                 if self._needs_mul_brackets(numer, last=False):
457                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
458                 else:
459                     tex += r"%s / %s" % (snumer, sdenom)
460             elif ratio is not None and \
461                     len(snumer.split()) > ratio*ldenom:
462                 # handle long fractions
463                 if self._needs_mul_brackets(numer, last=True):
464                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
465                         % (sdenom, separator, snumer)
466                 elif numer.is_Mul:
467                     # split a long numerator
468                     a = S.One
469                     b = S.One
470                     for x in numer.args:
471                         if self._needs_mul_brackets(x, last=False) or \
472                                 len(convert(a*x).split()) > ratio*ldenom or \
473                                 (b.is_commutative is x.is_commutative is False):
474                             b *= x
475                         else:
476                             a *= x
477                     if self._needs_mul_brackets(b, last=True):
478                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
479                             % (convert(a), sdenom, separator, convert(b))
480                     else:
481                         tex += r"\frac{%s}{%s}%s%s" \
482                             % (convert(a), sdenom, separator, convert(b))
483                 else:
484                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
485             else:
486                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
487 
488         if include_parens:
489             tex += ")"
490         return tex
491 
492     def _print_Pow(self, expr):
493         # Treat x**Rational(1,n) as special case
494         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1:
495             base = self._print(expr.base)
496             expq = expr.exp.q
497 
498             if expq == 2:
499                 tex = r"\sqrt{%s}" % base
500             elif self._settings['itex']:
501                 tex = r"\root{%d}{%s}" % (expq, base)
502             else:
503                 tex = r"\sqrt[%d]{%s}" % (expq, base)
504 
505             if expr.exp.is_negative:
506                 return r"\frac{1}{%s}" % tex
507             else:
508                 return tex
509         elif self._settings['fold_frac_powers'] \
510             and expr.exp.is_Rational \
511                 and expr.exp.q != 1:
512             base, p, q = self.parenthesize(expr.base, PRECEDENCE['Pow']), expr.exp.p, expr.exp.q
513             # issue #12886: add parentheses for superscripts raised to powers
514             if '^' in base and expr.base.is_Symbol:
515                 base = r"\left(%s\right)" % base
516             if expr.base.is_Function:
517                 return self._print(expr.base, exp="%s/%s" % (p, q))
518             return r"%s^{%s/%s}" % (base, p, q)
519         elif expr.exp.is_Rational and expr.exp.is_negative and expr.base.is_commutative:
520             # special case for 1^(-x), issue 9216
521             if expr.base == 1:
522                 return r"%s^{%s}" % (expr.base, expr.exp)
523             # things like 1/x
524             return self._print_Mul(expr)
525         else:
526             if expr.base.is_Function:
527                 return self._print(expr.base, exp=self._print(expr.exp))
528             else:
529                 tex = r"%s^{%s}"
530                 exp = self._print(expr.exp)
531                 # issue #12886: add parentheses around superscripts raised to powers
532                 base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
533                 if '^' in base and expr.base.is_Symbol:
534                     base = r"\left(%s\right)" % base
535                 elif isinstance(expr.base, Derivative
536                         ) and base.startswith(r'\left('
537                         ) and re.match(r'\\left\(\\d?d?dot', base
538                         ) and base.endswith(r'\right)'):
539                     # don't use parentheses around dotted derivative
540                     base = base[6: -7]  # remove outermost added parens
541 
542                 return tex % (base, exp)
543 
544     def _print_UnevaluatedExpr(self, expr):
545         return self._print(expr.args[0])
546 
547     def _print_Sum(self, expr):
548         if len(expr.limits) == 1:
549             tex = r"\sum_{%s=%s}^{%s} " % \
550                 tuple([ self._print(i) for i in expr.limits[0] ])
551         else:
552             def _format_ineq(l):
553                 return r"%s \leq %s \leq %s" % \
554                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
555 
556             tex = r"\sum_{\substack{%s}} " % \
557                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
558 
559         if isinstance(expr.function, Add):
560             tex += r"\left(%s\right)" % self._print(expr.function)
561         else:
562             tex += self._print(expr.function)
563 
564         return tex
565 
566     def _print_Product(self, expr):
567         if len(expr.limits) == 1:
568             tex = r"\prod_{%s=%s}^{%s} " % \
569                 tuple([ self._print(i) for i in expr.limits[0] ])
570         else:
571             def _format_ineq(l):
572                 return r"%s \leq %s \leq %s" % \
573                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
574 
575             tex = r"\prod_{\substack{%s}} " % \
576                 str.join('\\\\', [ _format_ineq(l) for l in expr.limits ])
577 
578         if isinstance(expr.function, Add):
579             tex += r"\left(%s\right)" % self._print(expr.function)
580         else:
581             tex += self._print(expr.function)
582 
583         return tex
584 
585     def _print_BasisDependent(self, expr):
586         from sympy.vector import Vector
587 
588         o1 = []
589         if expr == expr.zero:
590             return expr.zero._latex_form
591         if isinstance(expr, Vector):
592             items = expr.separate().items()
593         else:
594             items = [(0, expr)]
595 
596         for system, vect in items:
597             inneritems = list(vect.components.items())
598             inneritems.sort(key = lambda x:x[0].__str__())
599             for k, v in inneritems:
600                 if v == 1:
601                     o1.append(' + ' + k._latex_form)
602                 elif v == -1:
603                     o1.append(' - ' + k._latex_form)
604                 else:
605                     arg_str = '(' + LatexPrinter().doprint(v) + ')'
606                     o1.append(' + ' + arg_str + k._latex_form)
607 
608         outstr = (''.join(o1))
609         if outstr[1] != '-':
610             outstr = outstr[3:]
611         else:
612             outstr = outstr[1:]
613         return outstr
614 
615     def _print_Indexed(self, expr):
616         tex_base = self._print(expr.base)
617         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
618             map(self._print, expr.indices))
619         return tex
620 
621     def _print_IndexedBase(self, expr):
622         return self._print(expr.label)
623 
624     def _print_Derivative(self, expr):
625         if requires_partial(expr):
626             diff_symbol = r'\partial'
627         else:
628             diff_symbol = r'd'
629 
630         tex = ""
631         dim = 0
632         for x, num in reversed(expr.variable_count):
633             dim += num
634             if num == 1:
635                 tex += r"%s %s" % (diff_symbol, self._print(x))
636             else:
637                 tex += r"%s %s^{%s}" % (diff_symbol, self._print(x), num)
638 
639         if dim == 1:
640             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
641         else:
642             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, dim, tex)
643 
644         return r"%s %s" % (tex, self.parenthesize(expr.expr, PRECEDENCE["Mul"], strict=True))
645 
646     def _print_Subs(self, subs):
647         expr, old, new = subs.args
648         latex_expr = self._print(expr)
649         latex_old = (self._print(e) for e in old)
650         latex_new = (self._print(e) for e in new)
651         latex_subs = r'\\ '.join(
652             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
653         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr, latex_subs)
654 
655     def _print_Integral(self, expr):
656         tex, symbols = "", []
657 
658         # Only up to \iiiint exists
659         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
660             # Use len(expr.limits)-1 so that syntax highlighters don't think
661             # \" is an escaped quote
662             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
663             symbols = [r"\, d%s" % self._print(symbol[0])
664                        for symbol in expr.limits]
665 
666         else:
667             for lim in reversed(expr.limits):
668                 symbol = lim[0]
669                 tex += r"\int"
670 
671                 if len(lim) > 1:
672                     if self._settings['mode'] in ['equation', 'equation*'] \
673                             and not self._settings['itex']:
674                         tex += r"\limits"
675 
676                     if len(lim) == 3:
677                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
678                                                self._print(lim[2]))
679                     if len(lim) == 2:
680                         tex += "^{%s}" % (self._print(lim[1]))
681 
682                 symbols.insert(0, r"\, d%s" % self._print(symbol))
683 
684         return r"%s %s%s" % (tex,
685             self.parenthesize(expr.function, PRECEDENCE["Mul"], strict=True), "".join(symbols))
686 
687     def _print_Limit(self, expr):
688         e, z, z0, dir = expr.args
689 
690         tex = r"\lim_{%s \to " % self._print(z)
691         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
692             tex += r"%s}" % self._print(z0)
693         else:
694             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
695 
696         if isinstance(e, AssocOp):
697             return r"%s\left(%s\right)" % (tex, self._print(e))
698         else:
699             return r"%s %s" % (tex, self._print(e))
700 
701     def _hprint_Function(self, func):
702         r'''
703         Logic to decide how to render a function to latex
704           - if it is a recognized latex name, use the appropriate latex command
705           - if it is a single letter, just use that letter
706           - if it is a longer name, then put \operatorname{} around it and be
707             mindful of undercores in the name
708         '''
709         func = self._deal_with_super_sub(func)
710         if func in accepted_latex_functions:
711             name = r"\%s" % func
712         elif len(func) == 1 or func.startswith('\\'):
713             name = func
714         else:
715             name = r"\operatorname{%s}" % func
716         return name
717 
718     def _print_Function(self, expr, exp=None):
719         r'''
720         Render functions to LaTeX, handling functions that LaTeX knows about
721         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
722         For single-letter function names, render them as regular LaTeX math
723         symbols. For multi-letter function names that LaTeX does not know
724         about, (e.g., Li, sech) use \operatorname{} so that the function name
725         is rendered in Roman font and LaTeX handles spacing properly.
726 
727         expr is the expression involving the function
728         exp is an exponent
729         '''
730         func = expr.func.__name__
731         if hasattr(self, '_print_' + func) and \
732             not isinstance(expr, AppliedUndef):
733             return getattr(self, '_print_' + func)(expr, exp)
734         else:
735             args = [ str(self._print(arg)) for arg in expr.args ]
736             # How inverse trig functions should be displayed, formats are:
737             # abbreviated: asin, full: arcsin, power: sin^-1
738             inv_trig_style = self._settings['inv_trig_style']
739             # If we are dealing with a power-style inverse trig function
740             inv_trig_power_case = False
741             # If it is applicable to fold the argument brackets
742             can_fold_brackets = self._settings['fold_func_brackets'] and \
743                 len(args) == 1 and \
744                 not self._needs_function_brackets(expr.args[0])
745 
746             inv_trig_table = ["asin", "acos", "atan", "acsc", "asec", "acot"]
747 
748             # If the function is an inverse trig function, handle the style
749             if func in inv_trig_table:
750                 if inv_trig_style == "abbreviated":
751                     func = func
752                 elif inv_trig_style == "full":
753                     func = "arc" + func[1:]
754                 elif inv_trig_style == "power":
755                     func = func[1:]
756                     inv_trig_power_case = True
757 
758                     # Can never fold brackets if we're raised to a power
759                     if exp is not None:
760                         can_fold_brackets = False
761 
762             if inv_trig_power_case:
763                 if func in accepted_latex_functions:
764                     name = r"\%s^{-1}" % func
765                 else:
766                     name = r"\operatorname{%s}^{-1}" % func
767             elif exp is not None:
768                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)
769             else:
770                 name = self._hprint_Function(func)
771 
772             if can_fold_brackets:
773                 if func in accepted_latex_functions:
774                     # Wrap argument safely to avoid parse-time conflicts
775                     # with the function name itself
776                     name += r" {%s}"
777                 else:
778                     name += r"%s"
779             else:
780                 name += r"{\left (%s \right )}"
781 
782             if inv_trig_power_case and exp is not None:
783                 name += r"^{%s}" % exp
784 
785             return name % ",".join(args)
786 
787     def _print_UndefinedFunction(self, expr):
788         return self._hprint_Function(str(expr))
789 
790     @property
791     def _special_function_classes(self):
792         from sympy.functions.special.tensor_functions import KroneckerDelta
793         from sympy.functions.special.gamma_functions import gamma, lowergamma
794         from sympy.functions.special.beta_functions import beta
795         from sympy.functions.special.delta_functions import DiracDelta
796         from sympy.functions.special.error_functions import Chi
797         return {KroneckerDelta: r'\delta',
798                 gamma:  r'\Gamma',
799                 lowergamma: r'\gamma',
800                 beta: r'\operatorname{B}',
801                 DiracDelta: r'\delta',
802                 Chi: r'\operatorname{Chi}'}
803 
804     def _print_FunctionClass(self, expr):
805         for cls in self._special_function_classes:
806             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
807                 return self._special_function_classes[cls]
808         return self._hprint_Function(str(expr))
809 
810     def _print_Lambda(self, expr):
811         symbols, expr = expr.args
812 
813         if len(symbols) == 1:
814             symbols = self._print(symbols[0])
815         else:
816             symbols = self._print(tuple(symbols))
817 
818         args = (symbols, self._print(expr))
819         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
820 
821         return tex
822 
823     def _hprint_variadic_function(self, expr, exp=None):
824         args = sorted(expr.args, key=default_sort_key)
825         texargs = [r"%s" % self._print(symbol) for symbol in args]
826         tex = r"\%s\left(%s\right)" % (self._print((str(expr.func)).lower()), ", ".join(texargs))
827         if exp is not None:
828             return r"%s^{%s}" % (tex, exp)
829         else:
830             return tex
831 
832     _print_Min = _print_Max = _hprint_variadic_function
833 
834     def _print_floor(self, expr, exp=None):
835         tex = r"\lfloor{%s}\rfloor" % self._print(expr.args[0])
836 
837         if exp is not None:
838             return r"%s^{%s}" % (tex, exp)
839         else:
840             return tex
841 
842     def _print_ceiling(self, expr, exp=None):
843         tex = r"\lceil{%s}\rceil" % self._print(expr.args[0])
844 
845         if exp is not None:
846             return r"%s^{%s}" % (tex, exp)
847         else:
848             return tex
849 
850     def _print_log(self, expr, exp=None):
851         if not self._settings["ln_notation"]:
852             tex = r"\log{\left (%s \right )}" % self._print(expr.args[0])
853         else:
854             tex = r"\ln{\left (%s \right )}" % self._print(expr.args[0])
855 
856         if exp is not None:
857             return r"%s^{%s}" % (tex, exp)
858         else:
859             return tex
860 
861     def _print_Abs(self, expr, exp=None):
862         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
863 
864         if exp is not None:
865             return r"%s^{%s}" % (tex, exp)
866         else:
867             return tex
868     _print_Determinant = _print_Abs
869 
870     def _print_re(self, expr, exp=None):
871         tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
872 
873         return self._do_exponent(tex, exp)
874 
875     def _print_im(self, expr, exp=None):
876         tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
877 
878         return self._do_exponent(tex, exp)
879 
880     def _print_Not(self, e):
881         from sympy import Equivalent, Implies
882         if isinstance(e.args[0], Equivalent):
883             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
884         if isinstance(e.args[0], Implies):
885             return self._print_Implies(e.args[0], r"\not\Rightarrow")
886         if (e.args[0].is_Boolean):
887             return r"\neg (%s)" % self._print(e.args[0])
888         else:
889             return r"\neg %s" % self._print(e.args[0])
890 
891     def _print_LogOp(self, args, char):
892         arg = args[0]
893         if arg.is_Boolean and not arg.is_Not:
894             tex = r"\left(%s\right)" % self._print(arg)
895         else:
896             tex = r"%s" % self._print(arg)
897 
898         for arg in args[1:]:
899             if arg.is_Boolean and not arg.is_Not:
900                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
901             else:
902                 tex += r" %s %s" % (char, self._print(arg))
903 
904         return tex
905 
906     def _print_And(self, e):
907         args = sorted(e.args, key=default_sort_key)
908         return self._print_LogOp(args, r"\wedge")
909 
910     def _print_Or(self, e):
911         args = sorted(e.args, key=default_sort_key)
912         return self._print_LogOp(args, r"\vee")
913 
914     def _print_Xor(self, e):
915         args = sorted(e.args, key=default_sort_key)
916         return self._print_LogOp(args, r"\veebar")
917 
918     def _print_Implies(self, e, altchar=None):
919         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
920 
921     def _print_Equivalent(self, e, altchar=None):
922         args = sorted(e.args, key=default_sort_key)
923         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
924 
925     def _print_conjugate(self, expr, exp=None):
926         tex = r"\overline{%s}" % self._print(expr.args[0])
927 
928         if exp is not None:
929             return r"%s^{%s}" % (tex, exp)
930         else:
931             return tex
932 
933     def _print_polar_lift(self, expr, exp=None):
934         func = r"\operatorname{polar\_lift}"
935         arg = r"{\left (%s \right )}" % self._print(expr.args[0])
936 
937         if exp is not None:
938             return r"%s^{%s}%s" % (func, exp, arg)
939         else:
940             return r"%s%s" % (func, arg)
941 
942     def _print_ExpBase(self, expr, exp=None):
943         # TODO should exp_polar be printed differently?
944         #      what about exp_polar(0), exp_polar(1)?
945         tex = r"e^{%s}" % self._print(expr.args[0])
946         return self._do_exponent(tex, exp)
947 
948     def _print_elliptic_k(self, expr, exp=None):
949         tex = r"\left(%s\right)" % self._print(expr.args[0])
950         if exp is not None:
951             return r"K^{%s}%s" % (exp, tex)
952         else:
953             return r"K%s" % tex
954 
955     def _print_elliptic_f(self, expr, exp=None):
956         tex = r"\left(%s\middle| %s\right)" % \
957             (self._print(expr.args[0]), self._print(expr.args[1]))
958         if exp is not None:
959             return r"F^{%s}%s" % (exp, tex)
960         else:
961             return r"F%s" % tex
962 
963     def _print_elliptic_e(self, expr, exp=None):
964         if len(expr.args) == 2:
965             tex = r"\left(%s\middle| %s\right)" % \
966                 (self._print(expr.args[0]), self._print(expr.args[1]))
967         else:
968             tex = r"\left(%s\right)" % self._print(expr.args[0])
969         if exp is not None:
970             return r"E^{%s}%s" % (exp, tex)
971         else:
972             return r"E%s" % tex
973 
974     def _print_elliptic_pi(self, expr, exp=None):
975         if len(expr.args) == 3:
976             tex = r"\left(%s; %s\middle| %s\right)" % \
977                 (self._print(expr.args[0]), self._print(expr.args[1]), \
978                  self._print(expr.args[2]))
979         else:
980             tex = r"\left(%s\middle| %s\right)" % \
981                 (self._print(expr.args[0]), self._print(expr.args[1]))
982         if exp is not None:
983             return r"\Pi^{%s}%s" % (exp, tex)
984         else:
985             return r"\Pi%s" % tex
986 
987     def _print_beta(self, expr, exp=None):
988         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
989                                         self._print(expr.args[1]))
990 
991         if exp is not None:
992             return r"\operatorname{B}^{%s}%s" % (exp, tex)
993         else:
994             return r"\operatorname{B}%s" % tex
995 
996     def _print_uppergamma(self, expr, exp=None):
997         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
998                                         self._print(expr.args[1]))
999 
1000         if exp is not None:
1001             return r"\Gamma^{%s}%s" % (exp, tex)
1002         else:
1003             return r"\Gamma%s" % tex
1004 
1005     def _print_lowergamma(self, expr, exp=None):
1006         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1007                                         self._print(expr.args[1]))
1008 
1009         if exp is not None:
1010             return r"\gamma^{%s}%s" % (exp, tex)
1011         else:
1012             return r"\gamma%s" % tex
1013 
1014     def _hprint_one_arg_func(self, expr, exp=None):
1015         tex = r"\left(%s\right)" % self._print(expr.args[0])
1016 
1017         if exp is not None:
1018             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1019         else:
1020             return r"%s%s" % (self._print(expr.func), tex)
1021 
1022     _print_gamma = _hprint_one_arg_func
1023 
1024     def _print_Chi(self, expr, exp=None):
1025         tex = r"\left(%s\right)" % self._print(expr.args[0])
1026 
1027         if exp is not None:
1028             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1029         else:
1030             return r"\operatorname{Chi}%s" % tex
1031 
1032     def _print_expint(self, expr, exp=None):
1033         tex = r"\left(%s\right)" % self._print(expr.args[1])
1034         nu = self._print(expr.args[0])
1035 
1036         if exp is not None:
1037             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1038         else:
1039             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1040 
1041     def _print_fresnels(self, expr, exp=None):
1042         tex = r"\left(%s\right)" % self._print(expr.args[0])
1043 
1044         if exp is not None:
1045             return r"S^{%s}%s" % (exp, tex)
1046         else:
1047             return r"S%s" % tex
1048 
1049     def _print_fresnelc(self, expr, exp=None):
1050         tex = r"\left(%s\right)" % self._print(expr.args[0])
1051 
1052         if exp is not None:
1053             return r"C^{%s}%s" % (exp, tex)
1054         else:
1055             return r"C%s" % tex
1056 
1057     def _print_subfactorial(self, expr, exp=None):
1058         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1059 
1060         if exp is not None:
1061             return r"%s^{%s}" % (tex, exp)
1062         else:
1063             return tex
1064 
1065     def _print_factorial(self, expr, exp=None):
1066         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1067 
1068         if exp is not None:
1069             return r"%s^{%s}" % (tex, exp)
1070         else:
1071             return tex
1072 
1073     def _print_factorial2(self, expr, exp=None):
1074         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1075 
1076         if exp is not None:
1077             return r"%s^{%s}" % (tex, exp)
1078         else:
1079             return tex
1080 
1081     def _print_binomial(self, expr, exp=None):
1082         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1083                                      self._print(expr.args[1]))
1084 
1085         if exp is not None:
1086             return r"%s^{%s}" % (tex, exp)
1087         else:
1088             return tex
1089 
1090     def _print_RisingFactorial(self, expr, exp=None):
1091         n, k = expr.args
1092         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1093 
1094         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1095 
1096         return self._do_exponent(tex, exp)
1097 
1098     def _print_FallingFactorial(self, expr, exp=None):
1099         n, k = expr.args
1100         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1101 
1102         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1103 
1104         return self._do_exponent(tex, exp)
1105 
1106     def _hprint_BesselBase(self, expr, exp, sym):
1107         tex = r"%s" % (sym)
1108 
1109         need_exp = False
1110         if exp is not None:
1111             if tex.find('^') == -1:
1112                 tex = r"%s^{%s}" % (tex, self._print(exp))
1113             else:
1114                 need_exp = True
1115 
1116         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1117                                            self._print(expr.argument))
1118 
1119         if need_exp:
1120             tex = self._do_exponent(tex, exp)
1121         return tex
1122 
1123     def _hprint_vec(self, vec):
1124         if len(vec) == 0:
1125             return ""
1126         s = ""
1127         for i in vec[:-1]:
1128             s += "%s, " % self._print(i)
1129         s += self._print(vec[-1])
1130         return s
1131 
1132     def _print_besselj(self, expr, exp=None):
1133         return self._hprint_BesselBase(expr, exp, 'J')
1134 
1135     def _print_besseli(self, expr, exp=None):
1136         return self._hprint_BesselBase(expr, exp, 'I')
1137 
1138     def _print_besselk(self, expr, exp=None):
1139         return self._hprint_BesselBase(expr, exp, 'K')
1140 
1141     def _print_bessely(self, expr, exp=None):
1142         return self._hprint_BesselBase(expr, exp, 'Y')
1143 
1144     def _print_yn(self, expr, exp=None):
1145         return self._hprint_BesselBase(expr, exp, 'y')
1146 
1147     def _print_jn(self, expr, exp=None):
1148         return self._hprint_BesselBase(expr, exp, 'j')
1149 
1150     def _print_hankel1(self, expr, exp=None):
1151         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1152 
1153     def _print_hankel2(self, expr, exp=None):
1154         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1155 
1156     def _print_hn1(self, expr, exp=None):
1157         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1158 
1159     def _print_hn2(self, expr, exp=None):
1160         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1161 
1162     def _hprint_airy(self, expr, exp=None, notation=""):
1163         tex = r"\left(%s\right)" % self._print(expr.args[0])
1164 
1165         if exp is not None:
1166             return r"%s^{%s}%s" % (notation, exp, tex)
1167         else:
1168             return r"%s%s" % (notation, tex)
1169 
1170     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1171         tex = r"\left(%s\right)" % self._print(expr.args[0])
1172 
1173         if exp is not None:
1174             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1175         else:
1176             return r"%s^\prime%s" % (notation, tex)
1177 
1178     def _print_airyai(self, expr, exp=None):
1179         return self._hprint_airy(expr, exp, 'Ai')
1180 
1181     def _print_airybi(self, expr, exp=None):
1182         return self._hprint_airy(expr, exp, 'Bi')
1183 
1184     def _print_airyaiprime(self, expr, exp=None):
1185         return self._hprint_airy_prime(expr, exp, 'Ai')
1186 
1187     def _print_airybiprime(self, expr, exp=None):
1188         return self._hprint_airy_prime(expr, exp, 'Bi')
1189 
1190     def _print_hyper(self, expr, exp=None):
1191         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1192               r"\middle| {%s} \right)}" % \
1193             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1194               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1195               self._print(expr.argument))
1196 
1197         if exp is not None:
1198             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1199         return tex
1200 
1201     def _print_meijerg(self, expr, exp=None):
1202         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1203               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1204             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1205               self._print(len(expr.bm)), self._print(len(expr.an)),
1206               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1207               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1208               self._print(expr.argument))
1209 
1210         if exp is not None:
1211             tex = r"{%s}^{%s}" % (tex, self._print(exp))
1212         return tex
1213 
1214     def _print_dirichlet_eta(self, expr, exp=None):
1215         tex = r"\left(%s\right)" % self._print(expr.args[0])
1216         if exp is not None:
1217             return r"\eta^{%s}%s" % (self._print(exp), tex)
1218         return r"\eta%s" % tex
1219 
1220     def _print_zeta(self, expr, exp=None):
1221         if len(expr.args) == 2:
1222             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1223         else:
1224             tex = r"\left(%s\right)" % self._print(expr.args[0])
1225         if exp is not None:
1226             return r"\zeta^{%s}%s" % (self._print(exp), tex)
1227         return r"\zeta%s" % tex
1228 
1229     def _print_lerchphi(self, expr, exp=None):
1230         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1231         if exp is None:
1232             return r"\Phi%s" % tex
1233         return r"\Phi^{%s}%s" % (self._print(exp), tex)
1234 
1235     def _print_polylog(self, expr, exp=None):
1236         s, z = map(self._print, expr.args)
1237         tex = r"\left(%s\right)" % z
1238         if exp is None:
1239             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1240         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, self._print(exp), tex)
1241 
1242     def _print_jacobi(self, expr, exp=None):
1243         n, a, b, x = map(self._print, expr.args)
1244         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1245         if exp is not None:
1246             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1247         return tex
1248 
1249     def _print_gegenbauer(self, expr, exp=None):
1250         n, a, x = map(self._print, expr.args)
1251         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1252         if exp is not None:
1253             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1254         return tex
1255 
1256     def _print_chebyshevt(self, expr, exp=None):
1257         n, x = map(self._print, expr.args)
1258         tex = r"T_{%s}\left(%s\right)" % (n, x)
1259         if exp is not None:
1260             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1261         return tex
1262 
1263     def _print_chebyshevu(self, expr, exp=None):
1264         n, x = map(self._print, expr.args)
1265         tex = r"U_{%s}\left(%s\right)" % (n, x)
1266         if exp is not None:
1267             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1268         return tex
1269 
1270     def _print_legendre(self, expr, exp=None):
1271         n, x = map(self._print, expr.args)
1272         tex = r"P_{%s}\left(%s\right)" % (n, x)
1273         if exp is not None:
1274             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1275         return tex
1276 
1277     def _print_assoc_legendre(self, expr, exp=None):
1278         n, a, x = map(self._print, expr.args)
1279         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1280         if exp is not None:
1281             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1282         return tex
1283 
1284     def _print_hermite(self, expr, exp=None):
1285         n, x = map(self._print, expr.args)
1286         tex = r"H_{%s}\left(%s\right)" % (n, x)
1287         if exp is not None:
1288             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1289         return tex
1290 
1291     def _print_laguerre(self, expr, exp=None):
1292         n, x = map(self._print, expr.args)
1293         tex = r"L_{%s}\left(%s\right)" % (n, x)
1294         if exp is not None:
1295             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1296         return tex
1297 
1298     def _print_assoc_laguerre(self, expr, exp=None):
1299         n, a, x = map(self._print, expr.args)
1300         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1301         if exp is not None:
1302             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1303         return tex
1304 
1305     def _print_Ynm(self, expr, exp=None):
1306         n, m, theta, phi = map(self._print, expr.args)
1307         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1308         if exp is not None:
1309             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1310         return tex
1311 
1312     def _print_Znm(self, expr, exp=None):
1313         n, m, theta, phi = map(self._print, expr.args)
1314         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1315         if exp is not None:
1316             tex = r"\left(" + tex + r"\right)^{%s}" % (self._print(exp))
1317         return tex
1318 
1319     def _print_Rational(self, expr):
1320         if expr.q != 1:
1321             sign = ""
1322             p = expr.p
1323             if expr.p < 0:
1324                 sign = "- "
1325                 p = -p
1326             if self._settings['fold_short_frac']:
1327                 return r"%s%d / %d" % (sign, p, expr.q)
1328             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1329         else:
1330             return self._print(expr.p)
1331 
1332     def _print_Order(self, expr):
1333         s = self._print(expr.expr)
1334         if expr.point and any(p != S.Zero for p in expr.point) or \
1335            len(expr.variables) > 1:
1336             s += '; '
1337             if len(expr.variables) > 1:
1338                 s += self._print(expr.variables)
1339             elif len(expr.variables):
1340                 s += self._print(expr.variables[0])
1341             s += r'\rightarrow '
1342             if len(expr.point) > 1:
1343                 s += self._print(expr.point)
1344             else:
1345                 s += self._print(expr.point[0])
1346         return r"O\left(%s\right)" % s
1347 
1348     def _print_Symbol(self, expr):
1349         if expr in self._settings['symbol_names']:
1350             return self._settings['symbol_names'][expr]
1351 
1352         return self._deal_with_super_sub(expr.name) if \
1353             '\\' not in expr.name else expr.name
1354 
1355     _print_RandomSymbol = _print_Symbol
1356     _print_MatrixSymbol = _print_Symbol
1357 
1358     def _deal_with_super_sub(self, string):
1359         if '{' in string:
1360             return string
1361 
1362         name, supers, subs = split_super_sub(string)
1363 
1364         name = translate(name)
1365         supers = [translate(sup) for sup in supers]
1366         subs = [translate(sub) for sub in subs]
1367 
1368         # glue all items together:
1369         if len(supers) > 0:
1370             name += "^{%s}" % " ".join(supers)
1371         if len(subs) > 0:
1372             name += "_{%s}" % " ".join(subs)
1373 
1374         return name
1375 
1376     def _print_Relational(self, expr):
1377         if self._settings['itex']:
1378             gt = r"\gt"
1379             lt = r"\lt"
1380         else:
1381             gt = ">"
1382             lt = "<"
1383 
1384         charmap = {
1385             "==": "=",
1386             ">": gt,
1387             "<": lt,
1388             ">=": r"\geq",
1389             "<=": r"\leq",
1390             "!=": r"\neq",
1391         }
1392 
1393         return "%s %s %s" % (self._print(expr.lhs),
1394             charmap[expr.rel_op], self._print(expr.rhs))
1395 
1396     def _print_Piecewise(self, expr):
1397         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1398                    for e, c in expr.args[:-1]]
1399         if expr.args[-1].cond == true:
1400             ecpairs.append(r"%s & \text{otherwise}" %
1401                            self._print(expr.args[-1].expr))
1402         else:
1403             ecpairs.append(r"%s & \text{for}\: %s" %
1404                            (self._print(expr.args[-1].expr),
1405                             self._print(expr.args[-1].cond)))
1406         tex = r"\begin{cases} %s \end{cases}"
1407         return tex % r" \\".join(ecpairs)
1408 
1409     def _print_MatrixBase(self, expr):
1410         lines = []
1411 
1412         for line in range(expr.rows):  # horrible, should be 'rows'
1413             lines.append(" & ".join([ self._print(i) for i in expr[line, :] ]))
1414 
1415         mat_str = self._settings['mat_str']
1416         if mat_str is None:
1417             if self._settings['mode'] == 'inline':
1418                 mat_str = 'smallmatrix'
1419             else:
1420                 if (expr.cols <= 10) is True:
1421                     mat_str = 'matrix'
1422                 else:
1423                     mat_str = 'array'
1424 
1425         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1426         out_str = out_str.replace('%MATSTR%', mat_str)
1427         if mat_str == 'array':
1428             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1429         if self._settings['mat_delim']:
1430             left_delim = self._settings['mat_delim']
1431             right_delim = self._delim_dict[left_delim]
1432             out_str = r'\left' + left_delim + out_str + \
1433                       r'\right' + right_delim
1434         return out_str % r"\\".join(lines)
1435     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \
1436                            = _print_Matrix \
1437                            = _print_MatrixBase
1438 
1439     def _print_MatrixElement(self, expr):
1440         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) \
1441             + '_{%s, %s}' % (expr.i, expr.j)
1442 
1443     def _print_MatrixSlice(self, expr):
1444         def latexslice(x):
1445             x = list(x)
1446             if x[2] == 1:
1447                 del x[2]
1448             if x[1] == x[0] + 1:
1449                 del x[1]
1450             if x[0] == 0:
1451                 x[0] = ''
1452             return ':'.join(map(self._print, x))
1453         return (self._print(expr.parent) + r'\left[' +
1454                 latexslice(expr.rowslice) + ', ' +
1455                 latexslice(expr.colslice) + r'\right]')
1456 
1457     def _print_BlockMatrix(self, expr):
1458         return self._print(expr.blocks)
1459 
1460     def _print_Transpose(self, expr):
1461         mat = expr.arg
1462         from sympy.matrices import MatrixSymbol
1463         if not isinstance(mat, MatrixSymbol):
1464             return r"\left(%s\right)^T" % self._print(mat)
1465         else:
1466             return "%s^T" % self._print(mat)
1467 
1468     def _print_Trace(self, expr):
1469         mat = expr.arg
1470         return r"\mathrm{tr}\left (%s \right )" % self._print(mat)
1471 
1472     def _print_Adjoint(self, expr):
1473         mat = expr.arg
1474         from sympy.matrices import MatrixSymbol
1475         if not isinstance(mat, MatrixSymbol):
1476             return r"\left(%s\right)^\dagger" % self._print(mat)
1477         else:
1478             return r"%s^\dagger" % self._print(mat)
1479 
1480     def _print_MatMul(self, expr):
1481         from sympy import Add, MatAdd, HadamardProduct, MatMul, Mul
1482 
1483         parens = lambda x: self.parenthesize(x, precedence_traditional(expr), False)
1484 
1485         args = expr.args
1486         if isinstance(args[0], Mul):
1487             args = args[0].as_ordered_factors() + list(args[1:])
1488         else:
1489             args = list(args)
1490 
1491         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1492             if args[0] == -1:
1493                 args = args[1:]
1494             else:
1495                 args[0] = -args[0]
1496             return '- ' + ' '.join(map(parens, args))
1497         else:
1498             return ' '.join(map(parens, args))
1499 
1500     def _print_Mod(self, expr, exp=None):
1501         if exp is not None:
1502             return r'\left(%s\bmod{%s}\right)^{%s}' % (self.parenthesize(expr.args[0],
1503                     PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]), self._print(exp))
1504         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1505                 PRECEDENCE['Mul'], strict=True), self._print(expr.args[1]))
1506 
1507     def _print_HadamardProduct(self, expr):
1508         from sympy import Add, MatAdd, MatMul
1509 
1510         def parens(x):
1511             if isinstance(x, (Add, MatAdd, MatMul)):
1512                 return r"\left(%s\right)" % self._print(x)
1513             return self._print(x)
1514         return r' \circ '.join(map(parens, expr.args))
1515 
1516     def _print_KroneckerProduct(self, expr):
1517         from sympy import Add, MatAdd, MatMul
1518 
1519         def parens(x):
1520             if isinstance(x, (Add, MatAdd, MatMul)):
1521                 return r"\left(%s\right)" % self._print(x)
1522             return self._print(x)
1523         return r' \otimes '.join(map(parens, expr.args))
1524 
1525     def _print_MatPow(self, expr):
1526         base, exp = expr.base, expr.exp
1527         from sympy.matrices import MatrixSymbol
1528         if not isinstance(base, MatrixSymbol):
1529             return r"\left(%s\right)^{%s}" % (self._print(base), self._print(exp))
1530         else:
1531             return "%s^{%s}" % (self._print(base), self._print(exp))
1532 
1533     def _print_ZeroMatrix(self, Z):
1534         return r"\mathbb{0}"
1535 
1536     def _print_Identity(self, I):
1537         return r"\mathbb{I}"
1538 
1539     def _print_NDimArray(self, expr):
1540 
1541         if expr.rank() == 0:
1542             return self._print(expr[()])
1543 
1544         mat_str = self._settings['mat_str']
1545         if mat_str is None:
1546             if self._settings['mode'] == 'inline':
1547                 mat_str = 'smallmatrix'
1548             else:
1549                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1550                     mat_str = 'matrix'
1551                 else:
1552                     mat_str = 'array'
1553         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1554         block_str = block_str.replace('%MATSTR%', mat_str)
1555         if self._settings['mat_delim']:
1556             left_delim = self._settings['mat_delim']
1557             right_delim = self._delim_dict[left_delim]
1558             block_str = r'\left' + left_delim + block_str + \
1559                       r'\right' + right_delim
1560 
1561         if expr.rank() == 0:
1562             return block_str % ""
1563 
1564         level_str = [[]] + [[] for i in range(expr.rank())]
1565         shape_ranges = [list(range(i)) for i in expr.shape]
1566         for outer_i in itertools.product(*shape_ranges):
1567             level_str[-1].append(self._print(expr[outer_i]))
1568             even = True
1569             for back_outer_i in range(expr.rank()-1, -1, -1):
1570                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1571                     break
1572                 if even:
1573                     level_str[back_outer_i].append(r" & ".join(level_str[back_outer_i+1]))
1574                 else:
1575                     level_str[back_outer_i].append(block_str % (r"\\".join(level_str[back_outer_i+1])))
1576                     if len(level_str[back_outer_i+1]) == 1:
1577                         level_str[back_outer_i][-1] = r"\left[" + level_str[back_outer_i][-1] + r"\right]"
1578                 even = not even
1579                 level_str[back_outer_i+1] = []
1580 
1581         out_str = level_str[0][0]
1582 
1583         if expr.rank() % 2 == 1:
1584             out_str = block_str % out_str
1585 
1586         return out_str
1587 
1588     _print_ImmutableDenseNDimArray = _print_NDimArray
1589     _print_ImmutableSparseNDimArray = _print_NDimArray
1590     _print_MutableDenseNDimArray = _print_NDimArray
1591     _print_MutableSparseNDimArray = _print_NDimArray
1592 
1593     def _printer_tensor_indices(self, name, indices, index_map={}):
1594         out_str = self._print(name)
1595         last_valence = None
1596         prev_map = None
1597         for index in indices:
1598             new_valence = index.is_up
1599             if ((index in index_map) or prev_map) and last_valence == new_valence:
1600                 out_str += ","
1601             if last_valence != new_valence:
1602                 if last_valence is not None:
1603                     out_str += "}"
1604                 if index.is_up:
1605                     out_str += "{}^{"
1606                 else:
1607                     out_str += "{}_{"
1608             out_str += self._print(index.args[0])
1609             if index in index_map:
1610                 out_str += "="
1611                 out_str += self._print(index_map[index])
1612                 prev_map = True
1613             else:
1614                 prev_map = False
1615             last_valence = new_valence
1616         if last_valence is not None:
1617             out_str += "}"
1618         return out_str
1619 
1620     def _print_Tensor(self, expr):
1621         name = expr.args[0].args[0]
1622         indices = expr.get_indices()
1623         return self._printer_tensor_indices(name, indices)
1624 
1625     def _print_TensorElement(self, expr):
1626         name = expr.expr.args[0].args[0]
1627         indices = expr.expr.get_indices()
1628         index_map = expr.index_map
1629         return self._printer_tensor_indices(name, indices, index_map)
1630 
1631     def _print_TensMul(self, expr):
1632         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1633         sign, args = expr._get_args_for_traditional_printer()
1634         return sign + "".join(
1635             [self.parenthesize(arg, precedence(expr)) for arg in args]
1636         )
1637 
1638     def _print_TensAdd(self, expr):
1639         a = []
1640         args = expr.args
1641         for x in args:
1642             a.append(self.parenthesize(x, precedence(expr)))
1643         a.sort()
1644         s = ' + '.join(a)
1645         s = s.replace('+ -', '- ')
1646         return s
1647 
1648     def _print_TensorIndex(self, expr):
1649         return "{}%s{%s}" % (
1650             "^" if expr.is_up else "_",
1651             self._print(expr.args[0])
1652         )
1653         return self._print(expr.args[0])
1654 
1655     def _print_tuple(self, expr):
1656         return r"\left ( %s\right )" % \
1657             r", \quad ".join([ self._print(i) for i in expr ])
1658 
1659     def _print_TensorProduct(self, expr):
1660         elements = [self._print(a) for a in expr.args]
1661         return r' \otimes '.join(elements)
1662 
1663     def _print_WedgeProduct(self, expr):
1664         elements = [self._print(a) for a in expr.args]
1665         return r' \wedge '.join(elements)
1666 
1667     def _print_Tuple(self, expr):
1668         return self._print_tuple(expr)
1669 
1670     def _print_list(self, expr):
1671         return r"\left [ %s\right ]" % \
1672             r", \quad ".join([ self._print(i) for i in expr ])
1673 
1674     def _print_dict(self, d):
1675         keys = sorted(d.keys(), key=default_sort_key)
1676         items = []
1677 
1678         for key in keys:
1679             val = d[key]
1680             items.append("%s : %s" % (self._print(key), self._print(val)))
1681 
1682         return r"\left \{ %s\right \}" % r", \quad ".join(items)
1683 
1684     def _print_Dict(self, expr):
1685         return self._print_dict(expr)
1686 
1687     def _print_DiracDelta(self, expr, exp=None):
1688         if len(expr.args) == 1 or expr.args[1] == 0:
1689             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1690         else:
1691             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1692                 self._print(expr.args[1]), self._print(expr.args[0]))
1693         if exp:
1694             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1695         return tex
1696 
1697     def _print_SingularityFunction(self, expr):
1698         shift = self._print(expr.args[0] - expr.args[1])
1699         power = self._print(expr.args[2])
1700         tex = r"{\langle %s \rangle}^{%s}" % (shift, power)
1701         return tex
1702 
1703     def _print_Heaviside(self, expr, exp=None):
1704         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1705         if exp:
1706             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1707         return tex
1708 
1709     def _print_KroneckerDelta(self, expr, exp=None):
1710         i = self._print(expr.args[0])
1711         j = self._print(expr.args[1])
1712         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1713             tex = r'\delta_{%s %s}' % (i, j)
1714         else:
1715             tex = r'\delta_{%s, %s}' % (i, j)
1716         if exp:
1717             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1718         return tex
1719 
1720     def _print_LeviCivita(self, expr, exp=None):
1721         indices = map(self._print, expr.args)
1722         if all(x.is_Atom for x in expr.args):
1723             tex = r'\varepsilon_{%s}' % " ".join(indices)
1724         else:
1725             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1726         if exp:
1727             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1728         return tex
1729 
1730     def _print_ProductSet(self, p):
1731         if len(p.sets) > 1 and not has_variety(p.sets):
1732             return self._print(p.sets[0]) + "^{%d}" % len(p.sets)
1733         else:
1734             return r" \times ".join(self._print(set) for set in p.sets)
1735 
1736     def _print_RandomDomain(self, d):
1737         if hasattr(d, 'as_boolean'):
1738             return 'Domain: ' + self._print(d.as_boolean())
1739         elif hasattr(d, 'set'):
1740             return ('Domain: ' + self._print(d.symbols) + ' in ' +
1741                     self._print(d.set))
1742         elif hasattr(d, 'symbols'):
1743             return 'Domain on ' + self._print(d.symbols)
1744         else:
1745             return self._print(None)
1746 
1747     def _print_FiniteSet(self, s):
1748         items = sorted(s.args, key=default_sort_key)
1749         return self._print_set(items)
1750 
1751     def _print_set(self, s):
1752         items = sorted(s, key=default_sort_key)
1753         items = ", ".join(map(self._print, items))
1754         return r"\left\{%s\right\}" % items
1755 
1756     _print_frozenset = _print_set
1757 
1758     def _print_Range(self, s):
1759         dots = r'\ldots'
1760 
1761         if s.start.is_infinite:
1762             printset = s.start, dots, s[-1] - s.step, s[-1]
1763         elif s.stop.is_infinite or len(s) > 4:
1764             it = iter(s)
1765             printset = next(it), next(it), dots, s[-1]
1766         else:
1767             printset = tuple(s)
1768 
1769         return (r"\left\{"
1770               + r", ".join(self._print(el) for el in printset)
1771               + r"\right\}")
1772 
1773     def _print_SeqFormula(self, s):
1774         if s.start is S.NegativeInfinity:
1775             stop = s.stop
1776             printset = (r'\ldots', s.coeff(stop - 3), s.coeff(stop - 2),
1777                 s.coeff(stop - 1), s.coeff(stop))
1778         elif s.stop is S.Infinity or s.length > 4:
1779             printset = s[:4]
1780             printset.append(r'\ldots')
1781         else:
1782             printset = tuple(s)
1783 
1784         return (r"\left["
1785               + r", ".join(self._print(el) for el in printset)
1786               + r"\right]")
1787 
1788     _print_SeqPer = _print_SeqFormula
1789     _print_SeqAdd = _print_SeqFormula
1790     _print_SeqMul = _print_SeqFormula
1791 
1792     def _print_Interval(self, i):
1793         if i.start == i.end:
1794             return r"\left\{%s\right\}" % self._print(i.start)
1795 
1796         else:
1797             if i.left_open:
1798                 left = '('
1799             else:
1800                 left = '['
1801 
1802             if i.right_open:
1803                 right = ')'
1804             else:
1805                 right = ']'
1806 
1807             return r"\left%s%s, %s\right%s" % \
1808                    (left, self._print(i.start), self._print(i.end), right)
1809 
1810     def _print_AccumulationBounds(self, i):
1811         return r"\langle %s, %s\rangle" % \
1812                 (self._print(i.min), self._print(i.max))
1813 
1814     def _print_Union(self, u):
1815         return r" \cup ".join([self._print(i) for i in u.args])
1816 
1817     def _print_Complement(self, u):
1818         return r" \setminus ".join([self._print(i) for i in u.args])
1819 
1820     def _print_Intersection(self, u):
1821         return r" \cap ".join([self._print(i) for i in u.args])
1822 
1823     def _print_SymmetricDifference(self, u):
1824         return r" \triangle ".join([self._print(i) for i in u.args])
1825 
1826     def _print_EmptySet(self, e):
1827         return r"\emptyset"
1828 
1829     def _print_Naturals(self, n):
1830         return r"\mathbb{N}"
1831 
1832     def _print_Naturals0(self, n):
1833         return r"\mathbb{N}_0"
1834 
1835     def _print_Integers(self, i):
1836         return r"\mathbb{Z}"
1837 
1838     def _print_Reals(self, i):
1839         return r"\mathbb{R}"
1840 
1841     def _print_Complexes(self, i):
1842         return r"\mathbb{C}"
1843 
1844     def _print_ImageSet(self, s):
1845         sets = s.args[1:]
1846         varsets = [r"%s \in %s" % (self._print(var), self._print(setv))
1847             for var, setv in zip(s.lamda.variables, sets)]
1848         return r"\left\{%s\; |\; %s\right\}" % (
1849             self._print(s.lamda.expr),
1850             ', '.join(varsets))
1851 
1852     def _print_ConditionSet(self, s):
1853         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
1854         if s.base_set is S.UniversalSet:
1855             return r"\left\{%s \mid %s \right\}" % (
1856             vars_print,
1857             self._print(s.condition.as_expr()))
1858 
1859         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
1860             vars_print,
1861             vars_print,
1862             self._print(s.base_set),
1863             self._print(s.condition.as_expr()))
1864 
1865     def _print_ComplexRegion(self, s):
1866         vars_print = ', '.join([self._print(var) for var in s.variables])
1867         return r"\left\{%s\; |\; %s \in %s \right\}" % (
1868             self._print(s.expr),
1869             vars_print,
1870             self._print(s.sets))
1871 
1872     def _print_Contains(self, e):
1873         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
1874 
1875     def _print_FourierSeries(self, s):
1876         return self._print_Add(s.truncate()) + self._print(r' + \ldots')
1877 
1878     def _print_FormalPowerSeries(self, s):
1879         return self._print_Add(s.infinite)
1880 
1881     def _print_FiniteField(self, expr):
1882         return r"\mathbb{F}_{%s}" % expr.mod
1883 
1884     def _print_IntegerRing(self, expr):
1885         return r"\mathbb{Z}"
1886 
1887     def _print_RationalField(self, expr):
1888         return r"\mathbb{Q}"
1889 
1890     def _print_RealField(self, expr):
1891         return r"\mathbb{R}"
1892 
1893     def _print_ComplexField(self, expr):
1894         return r"\mathbb{C}"
1895 
1896     def _print_PolynomialRing(self, expr):
1897         domain = self._print(expr.domain)
1898         symbols = ", ".join(map(self._print, expr.symbols))
1899         return r"%s\left[%s\right]" % (domain, symbols)
1900 
1901     def _print_FractionField(self, expr):
1902         domain = self._print(expr.domain)
1903         symbols = ", ".join(map(self._print, expr.symbols))
1904         return r"%s\left(%s\right)" % (domain, symbols)
1905 
1906     def _print_PolynomialRingBase(self, expr):
1907         domain = self._print(expr.domain)
1908         symbols = ", ".join(map(self._print, expr.symbols))
1909         inv = ""
1910         if not expr.is_Poly:
1911             inv = r"S_<^{-1}"
1912         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
1913 
1914     def _print_Poly(self, poly):
1915         cls = poly.__class__.__name__
1916         terms = []
1917         for monom, coeff in poly.terms():
1918             s_monom = ''
1919             for i, exp in enumerate(monom):
1920                 if exp > 0:
1921                     if exp == 1:
1922                         s_monom += self._print(poly.gens[i])
1923                     else:
1924                         s_monom += self._print(pow(poly.gens[i], exp))
1925 
1926             if coeff.is_Add:
1927                 if s_monom:
1928                     s_coeff = r"\left(%s\right)" % self._print(coeff)
1929                 else:
1930                     s_coeff = self._print(coeff)
1931             else:
1932                 if s_monom:
1933                     if coeff is S.One:
1934                         terms.extend(['+', s_monom])
1935                         continue
1936 
1937                     if coeff is S.NegativeOne:
1938                         terms.extend(['-', s_monom])
1939                         continue
1940 
1941                 s_coeff = self._print(coeff)
1942 
1943             if not s_monom:
1944                 s_term = s_coeff
1945             else:
1946                 s_term = s_coeff + " " + s_monom
1947 
1948             if s_term.startswith('-'):
1949                 terms.extend(['-', s_term[1:]])
1950             else:
1951                 terms.extend(['+', s_term])
1952 
1953         if terms[0] in ['-', '+']:
1954             modifier = terms.pop(0)
1955 
1956             if modifier == '-':
1957                 terms[0] = '-' + terms[0]
1958 
1959         expr = ' '.join(terms)
1960         gens = list(map(self._print, poly.gens))
1961         domain = "domain=%s" % self._print(poly.get_domain())
1962 
1963         args = ", ".join([expr] + gens + [domain])
1964         if cls in accepted_latex_functions:
1965             tex = r"\%s {\left (%s \right )}" % (cls, args)
1966         else:
1967             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
1968 
1969         return tex
1970 
1971     def _print_ComplexRootOf(self, root):
1972         cls = root.__class__.__name__
1973         if cls == "ComplexRootOf":
1974             cls = "CRootOf"
1975         expr = self._print(root.expr)
1976         index = root.index
1977         if cls in accepted_latex_functions:
1978             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
1979         else:
1980             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr, index)
1981 
1982     def _print_RootSum(self, expr):
1983         cls = expr.__class__.__name__
1984         args = [self._print(expr.expr)]
1985 
1986         if expr.fun is not S.IdentityFunction:
1987             args.append(self._print(expr.fun))
1988 
1989         if cls in accepted_latex_functions:
1990             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
1991         else:
1992             return r"\operatorname{%s} {\left(%s\right)}" % (cls, ", ".join(args))
1993 
1994     def _print_PolyElement(self, poly):
1995         mul_symbol = self._settings['mul_symbol_latex']
1996         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
1997 
1998     def _print_FracElement(self, frac):
1999         if frac.denom == 1:
2000             return self._print(frac.numer)
2001         else:
2002             numer = self._print(frac.numer)
2003             denom = self._print(frac.denom)
2004             return r"\frac{%s}{%s}" % (numer, denom)
2005 
2006     def _print_euler(self, expr, exp=None):
2007         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2008         tex = r"E_{%s}" % self._print(m)
2009         if exp is not None:
2010             tex = r"%s^{%s}" % (tex, self._print(exp))
2011         if x is not None:
2012             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2013         return tex
2014 
2015     def _print_catalan(self, expr, exp=None):
2016         tex = r"C_{%s}" % self._print(expr.args[0])
2017         if exp is not None:
2018             tex = r"%s^{%s}" % (tex, self._print(exp))
2019         return tex
2020 
2021     def _print_MellinTransform(self, expr):
2022         return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2023 
2024     def _print_InverseMellinTransform(self, expr):
2025         return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2026 
2027     def _print_LaplaceTransform(self, expr):
2028         return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2029 
2030     def _print_InverseLaplaceTransform(self, expr):
2031         return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2032 
2033     def _print_FourierTransform(self, expr):
2034         return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2035 
2036     def _print_InverseFourierTransform(self, expr):
2037         return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2038 
2039     def _print_SineTransform(self, expr):
2040         return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2041 
2042     def _print_InverseSineTransform(self, expr):
2043         return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2044 
2045     def _print_CosineTransform(self, expr):
2046         return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2047 
2048     def _print_InverseCosineTransform(self, expr):
2049         return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % (self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2050 
2051     def _print_DMP(self, p):
2052         try:
2053             if p.ring is not None:
2054                 # TODO incorporate order
2055                 return self._print(p.ring.to_sympy(p))
2056         except SympifyError:
2057             pass
2058         return self._print(repr(p))
2059 
2060     def _print_DMF(self, p):
2061         return self._print_DMP(p)
2062 
2063     def _print_Object(self, object):
2064         return self._print(Symbol(object.name))
2065 
2066     def _print_Morphism(self, morphism):
2067         domain = self._print(morphism.domain)
2068         codomain = self._print(morphism.codomain)
2069         return "%s\\rightarrow %s" % (domain, codomain)
2070 
2071     def _print_NamedMorphism(self, morphism):
2072         pretty_name = self._print(Symbol(morphism.name))
2073         pretty_morphism = self._print_Morphism(morphism)
2074         return "%s:%s" % (pretty_name, pretty_morphism)
2075 
2076     def _print_IdentityMorphism(self, morphism):
2077         from sympy.categories import NamedMorphism
2078         return self._print_NamedMorphism(NamedMorphism(
2079             morphism.domain, morphism.codomain, "id"))
2080 
2081     def _print_CompositeMorphism(self, morphism):
2082         # All components of the morphism have names and it is thus
2083         # possible to build the name of the composite.
2084         component_names_list = [self._print(Symbol(component.name)) for
2085                                 component in morphism.components]
2086         component_names_list.reverse()
2087         component_names = "\\circ ".join(component_names_list) + ":"
2088 
2089         pretty_morphism = self._print_Morphism(morphism)
2090         return component_names + pretty_morphism
2091 
2092     def _print_Category(self, morphism):
2093         return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
2094 
2095     def _print_Diagram(self, diagram):
2096         if not diagram.premises:
2097             # This is an empty diagram.
2098             return self._print(S.EmptySet)
2099 
2100         latex_result = self._print(diagram.premises)
2101         if diagram.conclusions:
2102             latex_result += "\\Longrightarrow %s" % \
2103                             self._print(diagram.conclusions)
2104 
2105         return latex_result
2106 
2107     def _print_DiagramGrid(self, grid):
2108         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2109 
2110         for i in range(grid.height):
2111             for j in range(grid.width):
2112                 if grid[i, j]:
2113                     latex_result += latex(grid[i, j])
2114                 latex_result += " "
2115                 if j != grid.width - 1:
2116                     latex_result += "& "
2117 
2118             if i != grid.height - 1:
2119                 latex_result += "\\\\"
2120             latex_result += "\n"
2121 
2122         latex_result += "\\end{array}\n"
2123         return latex_result
2124 
2125     def _print_FreeModule(self, M):
2126         return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
2127 
2128     def _print_FreeModuleElement(self, m):
2129         # Print as row vector for convenience, for now.
2130         return r"\left[ %s \right]" % ",".join(
2131             '{' + self._print(x) + '}' for x in m)
2132 
2133     def _print_SubModule(self, m):
2134         return r"\left< %s \right>" % ",".join(
2135             '{' + self._print(x) + '}' for x in m.gens)
2136 
2137     def _print_ModuleImplementedIdeal(self, m):
2138         return r"\left< %s \right>" % ",".join(
2139             '{' + self._print(x) + '}' for [x] in m._module.gens)
2140 
2141     def _print_Quaternion(self, expr):
2142         # TODO: This expression is potentially confusing,
2143         # shall we print it as `Quaternion( ... )`?
2144         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True) for i in expr.args]
2145         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2146         return " + ".join(a)
2147 
2148     def _print_QuotientRing(self, R):
2149         # TODO nicer fractions for few generators...
2150         return r"\frac{%s}{%s}" % (self._print(R.ring), self._print(R.base_ideal))
2151 
2152     def _print_QuotientRingElement(self, x):
2153         return r"{%s} + {%s}" % (self._print(x.data), self._print(x.ring.base_ideal))
2154 
2155     def _print_QuotientModuleElement(self, m):
2156         return r"{%s} + {%s}" % (self._print(m.data),
2157                                  self._print(m.module.killed_module))
2158 
2159     def _print_QuotientModule(self, M):
2160         # TODO nicer fractions for few generators...
2161         return r"\frac{%s}{%s}" % (self._print(M.base),
2162                                    self._print(M.killed_module))
2163 
2164     def _print_MatrixHomomorphism(self, h):
2165         return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
2166             self._print(h.domain), self._print(h.codomain))
2167 
2168     def _print_BaseScalarField(self, field):
2169         string = field._coord_sys._names[field._index]
2170         return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
2171 
2172     def _print_BaseVectorField(self, field):
2173         string = field._coord_sys._names[field._index]
2174         return r'\partial_{%s}' % self._print(Symbol(string))
2175 
2176     def _print_Differential(self, diff):
2177         field = diff._form_field
2178         if hasattr(field, '_coord_sys'):
2179             string = field._coord_sys._names[field._index]
2180             return r'\mathrm{d}%s' % self._print(Symbol(string))
2181         else:
2182             return 'd(%s)' % self._print(field)
2183             string = self._print(field)
2184             return r'\mathrm{d}\left(%s\right)' % string
2185 
2186     def _print_Tr(self, p):
2187         #Todo: Handle indices
2188         contents = self._print(p.args[0])
2189         return r'\mbox{Tr}\left(%s\right)' % (contents)
2190 
2191     def _print_totient(self, expr, exp=None):
2192         if exp is not None:
2193             return r'\left(\phi\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2194                     self._print(exp))
2195         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2196 
2197     def _print_reduced_totient(self, expr, exp=None):
2198         if exp is not None:
2199             return r'\left(\lambda\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2200                     self._print(exp))
2201         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2202 
2203     def _print_divisor_sigma(self, expr, exp=None):
2204         if len(expr.args) == 2:
2205             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2206                                                 (expr.args[1], expr.args[0])))
2207         else:
2208             tex = r"\left(%s\right)" % self._print(expr.args[0])
2209         if exp is not None:
2210             return r"\sigma^{%s}%s" % (self._print(exp), tex)
2211         return r"\sigma%s" % tex
2212 
2213     def _print_udivisor_sigma(self, expr, exp=None):
2214         if len(expr.args) == 2:
2215             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2216                                                 (expr.args[1], expr.args[0])))
2217         else:
2218             tex = r"\left(%s\right)" % self._print(expr.args[0])
2219         if exp is not None:
2220             return r"\sigma^*^{%s}%s" % (self._print(exp), tex)
2221         return r"\sigma^*%s" % tex
2222 
2223     def _print_primenu(self, expr, exp=None):
2224         if exp is not None:
2225             return r'\left(\nu\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2226                     self._print(exp))
2227         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2228 
2229     def _print_primeomega(self, expr, exp=None):
2230         if exp is not None:
2231             return r'\left(\Omega\left(%s\right)\right)^{%s}' % (self._print(expr.args[0]),
2232                     self._print(exp))
2233         return r'\Omega\left(%s\right)' % self._print(expr.args[0])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 20:23:56.875 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 20:23:56.875 | INFO     | Search-only: skipping patch selection
2025-10-17 20:23:56.952 | INFO     | Task sympy__sympy-15609 completed successfully.
2025-10-17 20:23:56.953 | INFO     | No patch generated. You can try running ACR again.
