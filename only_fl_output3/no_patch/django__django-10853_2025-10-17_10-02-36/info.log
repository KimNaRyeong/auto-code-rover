2025-10-17 10:02:37.470 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 10:02:40.400 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=500, output_tokens=12, cost=0.005360
2025-10-17 10:02:54.136 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=680, output_tokens=501, cost=0.021830
2025-10-17 10:02:55.146 | INFO     | registered non reproducing test 0
2025-10-17 10:03:12.388 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1462, output_tokens=618, cost=0.033160
2025-10-17 10:03:13.365 | INFO     | registered non reproducing test 1
2025-10-17 10:03:31.472 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1577, output_tokens=790, cost=0.039470
2025-10-17 10:03:32.440 | INFO     | registered non reproducing test 2
2025-10-17 10:03:32.440 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 10:03:32.443 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:03:40.289 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=809, output_tokens=322, cost=0.017750
2025-10-17 10:03:40.296 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:03:43.974 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=676, output_tokens=82, cost=0.009220
2025-10-17 10:03:43.975 | DEBUG    | Extracted a valid json.
2025-10-17 10:03:43.975 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"sqlite3.connect\")",
        "search_code(\"SQLite version\")",
        "search_class(\"DatabaseWrapper\")",
        "search_method(\"create_connection\")",
        "search_method_in_class(\"execute\", \"DatabaseWrapper\")",
        "search_code(\"raise django.db.utils.OperationalError\")"
    ],
    "bug_locations": []
}
2025-10-17 10:03:44.059 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 10:03:44.060 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 10:03:59.413 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1576, output_tokens=638, cost=0.034900
2025-10-17 10:03:59.419 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:04:06.456 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2430, output_tokens=272, cost=0.032460
2025-10-17 10:04:06.461 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:04:13.210 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=626, output_tokens=252, cost=0.013820
2025-10-17 10:04:13.211 | DEBUG    | Extracted a valid json.
2025-10-17 10:04:13.212 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"get_new_connection\", \"django/db/backends/sqlite3/base.py\")",
        "search_code_in_file(\"features\", \"django/db/backends/sqlite3/base.py\")",
        "search_code_in_file(\"OperationalError\", \"django/db/backends/sqlite3/base.py\")"
    ],
    "bug_locations":[
        {
            "file": "django/db/backends/sqlite3/base.py",
            "class": "DatabaseWrapper",
            "method": "",
            "intended_behavior": "This class should include a mechanism to check the SQLite version at the time of connection establishment (`get_new_connection` method might be a relevant point for this). Based on the version check, Django should map the availability of window functions to a feature flag within the SQLite backend's `features` attribute. If an attempt is made to use window functions and the SQLite version is identified to be less than 3.25.0, Django should raise a clear, user-friendly error before attempting to execute the SQL. This preserves existing functionalities for database features that are supported across different SQLite versions while preventing confusing `OperationalError` messages for unsupported features."
        }
    ]
}
2025-10-17 10:04:13.258 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 10:04:13.259 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 10:04:31.709 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4891, output_tokens=765, cost=0.071860
2025-10-17 10:04:31.722 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:04:39.632 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5872, output_tokens=289, cost=0.067390
2025-10-17 10:04:39.638 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:04:47.244 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=643, output_tokens=275, cost=0.014680
2025-10-17 10:04:47.245 | DEBUG    | Extracted a valid json.
2025-10-17 10:04:47.245 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/backends/sqlite3/base.py", 
            "class": "DatabaseWrapper", 
            "method": "get_new_connection", 
            "intended_behavior": "Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection."
        }, 
        {
            "file": "django/db/backends/sqlite3/base.py", 
            "class": "DatabaseFeatures", 
            "method": "", 
            "intended_behavior": "Add a new attribute e.g., `supports_window_functions` within the `DatabaseFeatures` class. This attribute should dynamically reflect whether the connected SQLite database supports window functions based on the SQLite version determined at connection time. This feature flag should be used throughout Django's ORM layer to conditionally allow or disallow window function usage, presenting a clear and informative error when such usage is attempted on unsupported versions."
        }
    ]
}
2025-10-17 10:04:47.255 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/sqlite3/base.py</file>
<class>DatabaseWrapper</class>
<method>get_new_connection</method>
<code>
193     def get_new_connection(self, conn_params):
194         conn = Database.connect(**conn_params)
195         conn.create_function("django_date_extract", 2, _sqlite_datetime_extract)
196         conn.create_function("django_date_trunc", 2, _sqlite_date_trunc)
197         conn.create_function("django_datetime_cast_date", 2, _sqlite_datetime_cast_date)
198         conn.create_function("django_datetime_cast_time", 2, _sqlite_datetime_cast_time)
199         conn.create_function("django_datetime_extract", 3, _sqlite_datetime_extract)
200         conn.create_function("django_datetime_trunc", 3, _sqlite_datetime_trunc)
201         conn.create_function("django_time_extract", 2, _sqlite_time_extract)
202         conn.create_function("django_time_trunc", 2, _sqlite_time_trunc)
203         conn.create_function("django_time_diff", 2, _sqlite_time_diff)
204         conn.create_function("django_timestamp_diff", 2, _sqlite_timestamp_diff)
205         conn.create_function("django_format_dtdelta", 3, _sqlite_format_dtdelta)
206         conn.create_function('regexp', 2, _sqlite_regexp)
207         conn.create_function('ACOS', 1, none_guard(math.acos))
208         conn.create_function('ASIN', 1, none_guard(math.asin))
209         conn.create_function('ATAN', 1, none_guard(math.atan))
210         conn.create_function('ATAN2', 2, none_guard(math.atan2))
211         conn.create_function('CEILING', 1, none_guard(math.ceil))
212         conn.create_function('COS', 1, none_guard(math.cos))
213         conn.create_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
214         conn.create_function('DEGREES', 1, none_guard(math.degrees))
215         conn.create_function('EXP', 1, none_guard(math.exp))
216         conn.create_function('FLOOR', 1, none_guard(math.floor))
217         conn.create_function('LN', 1, none_guard(math.log))
218         conn.create_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
219         conn.create_function('LPAD', 3, _sqlite_lpad)
220         conn.create_function('MOD', 2, none_guard(math.fmod))
221         conn.create_function('PI', 0, lambda: math.pi)
222         conn.create_function('POWER', 2, none_guard(operator.pow))
223         conn.create_function('RADIANS', 1, none_guard(math.radians))
224         conn.create_function('REPEAT', 2, none_guard(operator.mul))
225         conn.create_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
226         conn.create_function('RPAD', 3, _sqlite_rpad)
227         conn.create_function('SIN', 1, none_guard(math.sin))
228         conn.create_function('SQRT', 1, none_guard(math.sqrt))
229         conn.create_function('TAN', 1, none_guard(math.tan))
230         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
231         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
232         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
233         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
234         conn.execute('PRAGMA foreign_keys = ON')
235         return conn

</code><intended_behavior>Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection.</intended_behavior>, <file>django/db/backends/oracle/base.py</file>
<class>DatabaseWrapper</class>
<method>get_new_connection</method>
<code>
224     def get_new_connection(self, conn_params):
225         return Database.connect(
226             user=self.settings_dict['USER'],
227             password=self.settings_dict['PASSWORD'],
228             dsn=self._dsn(),
229             **conn_params,
230         )

</code><intended_behavior>Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection.</intended_behavior>, <file>django/db/backends/postgresql/base.py</file>
<class>DatabaseWrapper</class>
<method>get_new_connection</method>
<code>
177     def get_new_connection(self, conn_params):
178         connection = Database.connect(**conn_params)
179 
180         # self.isolation_level must be set:
181         # - after connecting to the database in order to obtain the database's
182         #   default when no value is explicitly specified in options.
183         # - before calling _set_autocommit() because if autocommit is on, that
184         #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.
185         options = self.settings_dict['OPTIONS']
186         try:
187             self.isolation_level = options['isolation_level']
188         except KeyError:
189             self.isolation_level = connection.isolation_level
190         else:
191             # Set the isolation level to the value from OPTIONS.
192             if self.isolation_level != connection.isolation_level:
193                 connection.set_session(isolation_level=self.isolation_level)
194 
195         return connection

</code><intended_behavior>Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection.</intended_behavior>, <file>django/db/backends/sqlite3/base.py</file>
<class>DatabaseWrapper</class>
<method>None</method>
<code>
77 class DatabaseWrapper(BaseDatabaseWrapper):
78     vendor = 'sqlite'
79     display_name = 'SQLite'
80     # SQLite doesn't actually support most of these types, but it "does the right
81     # thing" given more verbose field definitions, so leave them as is so that
82     # schema inspection is more useful.
83     data_types = {
84         'AutoField': 'integer',
85         'BigAutoField': 'integer',
86         'BinaryField': 'BLOB',
87         'BooleanField': 'bool',
88         'CharField': 'varchar(%(max_length)s)',
89         'DateField': 'date',
90         'DateTimeField': 'datetime',
91         'DecimalField': 'decimal',
92         'DurationField': 'bigint',
93         'FileField': 'varchar(%(max_length)s)',
94         'FilePathField': 'varchar(%(max_length)s)',
95         'FloatField': 'real',
96         'IntegerField': 'integer',
97         'BigIntegerField': 'bigint',
98         'IPAddressField': 'char(15)',
99         'GenericIPAddressField': 'char(39)',
100         'NullBooleanField': 'bool',
101         'OneToOneField': 'integer',
102         'PositiveIntegerField': 'integer unsigned',
103         'PositiveSmallIntegerField': 'smallint unsigned',
104         'SlugField': 'varchar(%(max_length)s)',
105         'SmallIntegerField': 'smallint',
106         'TextField': 'text',
107         'TimeField': 'time',
108         'UUIDField': 'char(32)',
109     }
110     data_type_check_constraints = {
111         'PositiveIntegerField': '"%(column)s" >= 0',
112         'PositiveSmallIntegerField': '"%(column)s" >= 0',
113     }
114     data_types_suffix = {
115         'AutoField': 'AUTOINCREMENT',
116         'BigAutoField': 'AUTOINCREMENT',
117     }
118     # SQLite requires LIKE statements to include an ESCAPE clause if the value
119     # being escaped has a percent or underscore in it.
120     # See https://www.sqlite.org/lang_expr.html for an explanation.
121     operators = {
122         'exact': '= %s',
123         'iexact': "LIKE %s ESCAPE '\\'",
124         'contains': "LIKE %s ESCAPE '\\'",
125         'icontains': "LIKE %s ESCAPE '\\'",
126         'regex': 'REGEXP %s',
127         'iregex': "REGEXP '(?i)' || %s",
128         'gt': '> %s',
129         'gte': '>= %s',
130         'lt': '< %s',
131         'lte': '<= %s',
132         'startswith': "LIKE %s ESCAPE '\\'",
133         'endswith': "LIKE %s ESCAPE '\\'",
134         'istartswith': "LIKE %s ESCAPE '\\'",
135         'iendswith': "LIKE %s ESCAPE '\\'",
136     }
137 
138     # The patterns below are used to generate SQL pattern lookup clauses when
139     # the right-hand side of the lookup isn't a raw string (it might be an expression
140     # or the result of a bilateral transformation).
141     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
142     # escaped on database side.
143     #
144     # Note: we use str.format() here for readability as '%' is used as a wildcard for
145     # the LIKE operator.
146     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
147     pattern_ops = {
148         'contains': r"LIKE '%%' || {} || '%%' ESCAPE '\'",
149         'icontains': r"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'",
150         'startswith': r"LIKE {} || '%%' ESCAPE '\'",
151         'istartswith': r"LIKE UPPER({}) || '%%' ESCAPE '\'",
152         'endswith': r"LIKE '%%' || {} ESCAPE '\'",
153         'iendswith': r"LIKE '%%' || UPPER({}) ESCAPE '\'",
154     }
155 
156     Database = Database
157     SchemaEditorClass = DatabaseSchemaEditor
158     # Classes instantiated in __init__().
159     client_class = DatabaseClient
160     creation_class = DatabaseCreation
161     features_class = DatabaseFeatures
162     introspection_class = DatabaseIntrospection
163     ops_class = DatabaseOperations
164 
165     def get_connection_params(self):
166         settings_dict = self.settings_dict
167         if not settings_dict['NAME']:
168             raise ImproperlyConfigured(
169                 "settings.DATABASES is improperly configured. "
170                 "Please supply the NAME value.")
171         kwargs = {
172             'database': settings_dict['NAME'],
173             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,
174             **settings_dict['OPTIONS'],
175         }
176         # Always allow the underlying SQLite connection to be shareable
177         # between multiple threads. The safe-guarding will be handled at a
178         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`
179         # property. This is necessary as the shareability is disabled by
180         # default in pysqlite and it cannot be changed once a connection is
181         # opened.
182         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:
183             warnings.warn(
184                 'The `check_same_thread` option was provided and set to '
185                 'True. It will be overridden with False. Use the '
186                 '`DatabaseWrapper.allow_thread_sharing` property instead '
187                 'for controlling thread shareability.',
188                 RuntimeWarning
189             )
190         kwargs.update({'check_same_thread': False, 'uri': True})
191         return kwargs
192 
193     def get_new_connection(self, conn_params):
194         conn = Database.connect(**conn_params)
195         conn.create_function("django_date_extract", 2, _sqlite_datetime_extract)
196         conn.create_function("django_date_trunc", 2, _sqlite_date_trunc)
197         conn.create_function("django_datetime_cast_date", 2, _sqlite_datetime_cast_date)
198         conn.create_function("django_datetime_cast_time", 2, _sqlite_datetime_cast_time)
199         conn.create_function("django_datetime_extract", 3, _sqlite_datetime_extract)
200         conn.create_function("django_datetime_trunc", 3, _sqlite_datetime_trunc)
201         conn.create_function("django_time_extract", 2, _sqlite_time_extract)
202         conn.create_function("django_time_trunc", 2, _sqlite_time_trunc)
203         conn.create_function("django_time_diff", 2, _sqlite_time_diff)
204         conn.create_function("django_timestamp_diff", 2, _sqlite_timestamp_diff)
205         conn.create_function("django_format_dtdelta", 3, _sqlite_format_dtdelta)
206         conn.create_function('regexp', 2, _sqlite_regexp)
207         conn.create_function('ACOS', 1, none_guard(math.acos))
208         conn.create_function('ASIN', 1, none_guard(math.asin))
209         conn.create_function('ATAN', 1, none_guard(math.atan))
210         conn.create_function('ATAN2', 2, none_guard(math.atan2))
211         conn.create_function('CEILING', 1, none_guard(math.ceil))
212         conn.create_function('COS', 1, none_guard(math.cos))
213         conn.create_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
214         conn.create_function('DEGREES', 1, none_guard(math.degrees))
215         conn.create_function('EXP', 1, none_guard(math.exp))
216         conn.create_function('FLOOR', 1, none_guard(math.floor))
217         conn.create_function('LN', 1, none_guard(math.log))
218         conn.create_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
219         conn.create_function('LPAD', 3, _sqlite_lpad)
220         conn.create_function('MOD', 2, none_guard(math.fmod))
221         conn.create_function('PI', 0, lambda: math.pi)
222         conn.create_function('POWER', 2, none_guard(operator.pow))
223         conn.create_function('RADIANS', 1, none_guard(math.radians))
224         conn.create_function('REPEAT', 2, none_guard(operator.mul))
225         conn.create_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
226         conn.create_function('RPAD', 3, _sqlite_rpad)
227         conn.create_function('SIN', 1, none_guard(math.sin))
228         conn.create_function('SQRT', 1, none_guard(math.sqrt))
229         conn.create_function('TAN', 1, none_guard(math.tan))
230         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
231         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
232         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
233         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
234         conn.execute('PRAGMA foreign_keys = ON')
235         return conn
236 
237     def init_connection_state(self):
238         pass
239 
240     def create_cursor(self, name=None):
241         return self.connection.cursor(factory=SQLiteCursorWrapper)
242 
243     def close(self):
244         self.validate_thread_sharing()
245         # If database is in memory, closing the connection destroys the
246         # database. To prevent accidental data loss, ignore close requests on
247         # an in-memory db.
248         if not self.is_in_memory_db():
249             BaseDatabaseWrapper.close(self)
250 
251     def _savepoint_allowed(self):
252         # When 'isolation_level' is not None, sqlite3 commits before each
253         # savepoint; it's a bug. When it is None, savepoints don't make sense
254         # because autocommit is enabled. The only exception is inside 'atomic'
255         # blocks. To work around that bug, on SQLite, 'atomic' starts a
256         # transaction explicitly rather than simply disable autocommit.
257         return self.in_atomic_block
258 
259     def _set_autocommit(self, autocommit):
260         if autocommit:
261             level = None
262         else:
263             # sqlite3's internal default is ''. It's different from None.
264             # See Modules/_sqlite/connection.c.
265             level = ''
266         # 'isolation_level' is a misleading API.
267         # SQLite always runs at the SERIALIZABLE isolation level.
268         with self.wrap_database_errors:
269             self.connection.isolation_level = level
270 
271     def disable_constraint_checking(self):
272         with self.cursor() as cursor:
273             cursor.execute('PRAGMA foreign_keys = OFF')
274             # Foreign key constraints cannot be turned off while in a multi-
275             # statement transaction. Fetch the current state of the pragma
276             # to determine if constraints are effectively disabled.
277             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]
278         return not bool(enabled)
279 
280     def enable_constraint_checking(self):
281         self.cursor().execute('PRAGMA foreign_keys = ON')
282 
283     def check_constraints(self, table_names=None):
284         """
285         Check each table name in `table_names` for rows with invalid foreign
286         key references. This method is intended to be used in conjunction with
287         `disable_constraint_checking()` and `enable_constraint_checking()`, to
288         determine if rows with invalid references were entered while constraint
289         checks were off.
290         """
291         if self.features.supports_pragma_foreign_key_check:
292             with self.cursor() as cursor:
293                 if table_names is None:
294                     violations = self.cursor().execute('PRAGMA foreign_key_check').fetchall()
295                 else:
296                     violations = chain.from_iterable(
297                         cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()
298                         for table_name in table_names
299                     )
300                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
301                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:
302                     foreign_key = cursor.execute(
303                         'PRAGMA foreign_key_list(%s)' % table_name
304                     ).fetchall()[foreign_key_index]
305                     column_name, referenced_column_name = foreign_key[3:5]
306                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
307                     primary_key_value, bad_value = cursor.execute(
308                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (
309                             primary_key_column_name, column_name, table_name
310                         ),
311                         (rowid,),
312                     ).fetchone()
313                     raise utils.IntegrityError(
314                         "The row in table '%s' with primary key '%s' has an "
315                         "invalid foreign key: %s.%s contains a value '%s' that "
316                         "does not have a corresponding value in %s.%s." % (
317                             table_name, primary_key_value, table_name, column_name,
318                             bad_value, referenced_table_name, referenced_column_name
319                         )
320                     )
321         else:
322             with self.cursor() as cursor:
323                 if table_names is None:
324                     table_names = self.introspection.table_names(cursor)
325                 for table_name in table_names:
326                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
327                     if not primary_key_column_name:
328                         continue
329                     key_columns = self.introspection.get_key_columns(cursor, table_name)
330                     for column_name, referenced_table_name, referenced_column_name in key_columns:
331                         cursor.execute(
332                             """
333                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING
334                             LEFT JOIN `%s` as REFERRED
335                             ON (REFERRING.`%s` = REFERRED.`%s`)
336                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL
337                             """
338                             % (
339                                 primary_key_column_name, column_name, table_name,
340                                 referenced_table_name, column_name, referenced_column_name,
341                                 column_name, referenced_column_name,
342                             )
343                         )
344                         for bad_row in cursor.fetchall():
345                             raise utils.IntegrityError(
346                                 "The row in table '%s' with primary key '%s' has an "
347                                 "invalid foreign key: %s.%s contains a value '%s' that "
348                                 "does not have a corresponding value in %s.%s." % (
349                                     table_name, bad_row[0], table_name, column_name,
350                                     bad_row[1], referenced_table_name, referenced_column_name,
351                                 )
352                             )
353 
354     def is_usable(self):
355         return True
356 
357     def _start_transaction_under_autocommit(self):
358         """
359         Start a transaction explicitly in autocommit mode.
360 
361         Staying in autocommit mode works around a bug of sqlite3 that breaks
362         savepoints when autocommit is disabled.
363         """
364         self.cursor().execute("BEGIN")
365 
366     def is_in_memory_db(self):
367         return self.creation.is_in_memory_db(self.settings_dict['NAME'])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/oracle/base.py</file>
<class>DatabaseWrapper</class>
<method>None</method>
<code>
93 class DatabaseWrapper(BaseDatabaseWrapper):
94     vendor = 'oracle'
95     display_name = 'Oracle'
96     # This dictionary maps Field objects to their associated Oracle column
97     # types, as strings. Column-type strings can contain format strings; they'll
98     # be interpolated against the values of Field.__dict__ before being output.
99     # If a column type is set to None, it won't be included in the output.
100     #
101     # Any format strings starting with "qn_" are quoted before being used in the
102     # output (the "qn_" prefix is stripped before the lookup is performed.
103     data_types = {
104         'AutoField': 'NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY',
105         'BigAutoField': 'NUMBER(19) GENERATED BY DEFAULT ON NULL AS IDENTITY',
106         'BinaryField': 'BLOB',
107         'BooleanField': 'NUMBER(1)',
108         'CharField': 'NVARCHAR2(%(max_length)s)',
109         'DateField': 'DATE',
110         'DateTimeField': 'TIMESTAMP',
111         'DecimalField': 'NUMBER(%(max_digits)s, %(decimal_places)s)',
112         'DurationField': 'INTERVAL DAY(9) TO SECOND(6)',
113         'FileField': 'NVARCHAR2(%(max_length)s)',
114         'FilePathField': 'NVARCHAR2(%(max_length)s)',
115         'FloatField': 'DOUBLE PRECISION',
116         'IntegerField': 'NUMBER(11)',
117         'BigIntegerField': 'NUMBER(19)',
118         'IPAddressField': 'VARCHAR2(15)',
119         'GenericIPAddressField': 'VARCHAR2(39)',
120         'NullBooleanField': 'NUMBER(1)',
121         'OneToOneField': 'NUMBER(11)',
122         'PositiveIntegerField': 'NUMBER(11)',
123         'PositiveSmallIntegerField': 'NUMBER(11)',
124         'SlugField': 'NVARCHAR2(%(max_length)s)',
125         'SmallIntegerField': 'NUMBER(11)',
126         'TextField': 'NCLOB',
127         'TimeField': 'TIMESTAMP',
128         'URLField': 'VARCHAR2(%(max_length)s)',
129         'UUIDField': 'VARCHAR2(32)',
130     }
131     data_type_check_constraints = {
132         'BooleanField': '%(qn_column)s IN (0,1)',
133         'NullBooleanField': '%(qn_column)s IN (0,1)',
134         'PositiveIntegerField': '%(qn_column)s >= 0',
135         'PositiveSmallIntegerField': '%(qn_column)s >= 0',
136     }
137 
138     # Oracle doesn't support a database index on these columns.
139     _limited_data_types = ('clob', 'nclob', 'blob')
140 
141     operators = _UninitializedOperatorsDescriptor()
142 
143     _standard_operators = {
144         'exact': '= %s',
145         'iexact': '= UPPER(%s)',
146         'contains': "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
147         'icontains': "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
148         'gt': '> %s',
149         'gte': '>= %s',
150         'lt': '< %s',
151         'lte': '<= %s',
152         'startswith': "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
153         'endswith': "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
154         'istartswith': "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
155         'iendswith': "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
156     }
157 
158     _likec_operators = {
159         **_standard_operators,
160         'contains': "LIKEC %s ESCAPE '\\'",
161         'icontains': "LIKEC UPPER(%s) ESCAPE '\\'",
162         'startswith': "LIKEC %s ESCAPE '\\'",
163         'endswith': "LIKEC %s ESCAPE '\\'",
164         'istartswith': "LIKEC UPPER(%s) ESCAPE '\\'",
165         'iendswith': "LIKEC UPPER(%s) ESCAPE '\\'",
166     }
167 
168     # The patterns below are used to generate SQL pattern lookup clauses when
169     # the right-hand side of the lookup isn't a raw string (it might be an expression
170     # or the result of a bilateral transformation).
171     # In those cases, special characters for LIKE operators (e.g. \, %, _)
172     # should be escaped on the database side.
173     #
174     # Note: we use str.format() here for readability as '%' is used as a wildcard for
175     # the LIKE operator.
176     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
177     _pattern_ops = {
178         'contains': "'%%' || {} || '%%'",
179         'icontains': "'%%' || UPPER({}) || '%%'",
180         'startswith': "{} || '%%'",
181         'istartswith': "UPPER({}) || '%%'",
182         'endswith': "'%%' || {}",
183         'iendswith': "'%%' || UPPER({})",
184     }
185 
186     _standard_pattern_ops = {k: "LIKE TRANSLATE( " + v + " USING NCHAR_CS)"
187                                 " ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
188                              for k, v in _pattern_ops.items()}
189     _likec_pattern_ops = {k: "LIKEC " + v + " ESCAPE '\\'"
190                           for k, v in _pattern_ops.items()}
191 
192     Database = Database
193     SchemaEditorClass = DatabaseSchemaEditor
194     # Classes instantiated in __init__().
195     client_class = DatabaseClient
196     creation_class = DatabaseCreation
197     features_class = DatabaseFeatures
198     introspection_class = DatabaseIntrospection
199     ops_class = DatabaseOperations
200     validation_class = DatabaseValidation
201 
202     def __init__(self, *args, **kwargs):
203         super().__init__(*args, **kwargs)
204         use_returning_into = self.settings_dict["OPTIONS"].get('use_returning_into', True)
205         self.features.can_return_columns_from_insert = use_returning_into
206 
207     def _dsn(self):
208         settings_dict = self.settings_dict
209         if not settings_dict['HOST'].strip():
210             settings_dict['HOST'] = 'localhost'
211         if settings_dict['PORT']:
212             return Database.makedsn(settings_dict['HOST'], int(settings_dict['PORT']), settings_dict['NAME'])
213         return settings_dict['NAME']
214 
215     def _connect_string(self):
216         return '%s/\\"%s\\"@%s' % (self.settings_dict['USER'], self.settings_dict['PASSWORD'], self._dsn())
217 
218     def get_connection_params(self):
219         conn_params = self.settings_dict['OPTIONS'].copy()
220         if 'use_returning_into' in conn_params:
221             del conn_params['use_returning_into']
222         return conn_params
223 
224     def get_new_connection(self, conn_params):
225         return Database.connect(
226             user=self.settings_dict['USER'],
227             password=self.settings_dict['PASSWORD'],
228             dsn=self._dsn(),
229             **conn_params,
230         )
231 
232     def init_connection_state(self):
233         cursor = self.create_cursor()
234         # Set the territory first. The territory overrides NLS_DATE_FORMAT
235         # and NLS_TIMESTAMP_FORMAT to the territory default. When all of
236         # these are set in single statement it isn't clear what is supposed
237         # to happen.
238         cursor.execute("ALTER SESSION SET NLS_TERRITORY = 'AMERICA'")
239         # Set Oracle date to ANSI date format.  This only needs to execute
240         # once when we create a new connection. We also set the Territory
241         # to 'AMERICA' which forces Sunday to evaluate to a '1' in
242         # TO_CHAR().
243         cursor.execute(
244             "ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS'"
245             " NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF'" +
246             (" TIME_ZONE = 'UTC'" if settings.USE_TZ else '')
247         )
248         cursor.close()
249         if 'operators' not in self.__dict__:
250             # Ticket #14149: Check whether our LIKE implementation will
251             # work for this connection or we need to fall back on LIKEC.
252             # This check is performed only once per DatabaseWrapper
253             # instance per thread, since subsequent connections will use
254             # the same settings.
255             cursor = self.create_cursor()
256             try:
257                 cursor.execute("SELECT 1 FROM DUAL WHERE DUMMY %s"
258                                % self._standard_operators['contains'],
259                                ['X'])
260             except Database.DatabaseError:
261                 self.operators = self._likec_operators
262                 self.pattern_ops = self._likec_pattern_ops
263             else:
264                 self.operators = self._standard_operators
265                 self.pattern_ops = self._standard_pattern_ops
266             cursor.close()
267         self.connection.stmtcachesize = 20
268         # Ensure all changes are preserved even when AUTOCOMMIT is False.
269         if not self.get_autocommit():
270             self.commit()
271 
272     def create_cursor(self, name=None):
273         return FormatStylePlaceholderCursor(self.connection)
274 
275     def _commit(self):
276         if self.connection is not None:
277             with wrap_oracle_errors():
278                 return self.connection.commit()
279 
280     # Oracle doesn't support releasing savepoints. But we fake them when query
281     # logging is enabled to keep query counts consistent with other backends.
282     def _savepoint_commit(self, sid):
283         if self.queries_logged:
284             self.queries_log.append({
285                 'sql': '-- RELEASE SAVEPOINT %s (faked)' % self.ops.quote_name(sid),
286                 'time': '0.000',
287             })
288 
289     def _set_autocommit(self, autocommit):
290         with self.wrap_database_errors:
291             self.connection.autocommit = autocommit
292 
293     def check_constraints(self, table_names=None):
294         """
295         Check constraints by setting them to immediate. Return them to deferred
296         afterward.
297         """
298         self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')
299         self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')
300 
301     def is_usable(self):
302         try:
303             self.connection.ping()
304         except Database.Error:
305             return False
306         else:
307             return True
308 
309     @cached_property
310     def oracle_version(self):
311         with self.temporary_connection():
312             return tuple(int(x) for x in self.connection.version.split('.'))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/postgresql/base.py</file>
<class>DatabaseWrapper</class>
<method>None</method>
<code>
61 class DatabaseWrapper(BaseDatabaseWrapper):
62     vendor = 'postgresql'
63     display_name = 'PostgreSQL'
64     # This dictionary maps Field objects to their associated PostgreSQL column
65     # types, as strings. Column-type strings can contain format strings; they'll
66     # be interpolated against the values of Field.__dict__ before being output.
67     # If a column type is set to None, it won't be included in the output.
68     data_types = {
69         'AutoField': 'serial',
70         'BigAutoField': 'bigserial',
71         'BinaryField': 'bytea',
72         'BooleanField': 'boolean',
73         'CharField': 'varchar(%(max_length)s)',
74         'DateField': 'date',
75         'DateTimeField': 'timestamp with time zone',
76         'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)',
77         'DurationField': 'interval',
78         'FileField': 'varchar(%(max_length)s)',
79         'FilePathField': 'varchar(%(max_length)s)',
80         'FloatField': 'double precision',
81         'IntegerField': 'integer',
82         'BigIntegerField': 'bigint',
83         'IPAddressField': 'inet',
84         'GenericIPAddressField': 'inet',
85         'NullBooleanField': 'boolean',
86         'OneToOneField': 'integer',
87         'PositiveIntegerField': 'integer',
88         'PositiveSmallIntegerField': 'smallint',
89         'SlugField': 'varchar(%(max_length)s)',
90         'SmallIntegerField': 'smallint',
91         'TextField': 'text',
92         'TimeField': 'time',
93         'UUIDField': 'uuid',
94     }
95     data_type_check_constraints = {
96         'PositiveIntegerField': '"%(column)s" >= 0',
97         'PositiveSmallIntegerField': '"%(column)s" >= 0',
98     }
99     operators = {
100         'exact': '= %s',
101         'iexact': '= UPPER(%s)',
102         'contains': 'LIKE %s',
103         'icontains': 'LIKE UPPER(%s)',
104         'regex': '~ %s',
105         'iregex': '~* %s',
106         'gt': '> %s',
107         'gte': '>= %s',
108         'lt': '< %s',
109         'lte': '<= %s',
110         'startswith': 'LIKE %s',
111         'endswith': 'LIKE %s',
112         'istartswith': 'LIKE UPPER(%s)',
113         'iendswith': 'LIKE UPPER(%s)',
114     }
115 
116     # The patterns below are used to generate SQL pattern lookup clauses when
117     # the right-hand side of the lookup isn't a raw string (it might be an expression
118     # or the result of a bilateral transformation).
119     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
120     # escaped on database side.
121     #
122     # Note: we use str.format() here for readability as '%' is used as a wildcard for
123     # the LIKE operator.
124     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, E'\\', E'\\\\'), E'%%', E'\\%%'), E'_', E'\\_')"
125     pattern_ops = {
126         'contains': "LIKE '%%' || {} || '%%'",
127         'icontains': "LIKE '%%' || UPPER({}) || '%%'",
128         'startswith': "LIKE {} || '%%'",
129         'istartswith': "LIKE UPPER({}) || '%%'",
130         'endswith': "LIKE '%%' || {}",
131         'iendswith': "LIKE '%%' || UPPER({})",
132     }
133 
134     Database = Database
135     SchemaEditorClass = DatabaseSchemaEditor
136     # Classes instantiated in __init__().
137     client_class = DatabaseClient
138     creation_class = DatabaseCreation
139     features_class = DatabaseFeatures
140     introspection_class = DatabaseIntrospection
141     ops_class = DatabaseOperations
142     # PostgreSQL backend-specific attributes.
143     _named_cursor_idx = 0
144 
145     def get_connection_params(self):
146         settings_dict = self.settings_dict
147         # None may be used to connect to the default 'postgres' db
148         if settings_dict['NAME'] == '':
149             raise ImproperlyConfigured(
150                 "settings.DATABASES is improperly configured. "
151                 "Please supply the NAME value.")
152         if len(settings_dict['NAME'] or '') > self.ops.max_name_length():
153             raise ImproperlyConfigured(
154                 "The database name '%s' (%d characters) is longer than "
155                 "PostgreSQL's limit of %d characters. Supply a shorter NAME "
156                 "in settings.DATABASES." % (
157                     settings_dict['NAME'],
158                     len(settings_dict['NAME']),
159                     self.ops.max_name_length(),
160                 )
161             )
162         conn_params = {
163             'database': settings_dict['NAME'] or 'postgres',
164             **settings_dict['OPTIONS'],
165         }
166         conn_params.pop('isolation_level', None)
167         if settings_dict['USER']:
168             conn_params['user'] = settings_dict['USER']
169         if settings_dict['PASSWORD']:
170             conn_params['password'] = settings_dict['PASSWORD']
171         if settings_dict['HOST']:
172             conn_params['host'] = settings_dict['HOST']
173         if settings_dict['PORT']:
174             conn_params['port'] = settings_dict['PORT']
175         return conn_params
176 
177     def get_new_connection(self, conn_params):
178         connection = Database.connect(**conn_params)
179 
180         # self.isolation_level must be set:
181         # - after connecting to the database in order to obtain the database's
182         #   default when no value is explicitly specified in options.
183         # - before calling _set_autocommit() because if autocommit is on, that
184         #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.
185         options = self.settings_dict['OPTIONS']
186         try:
187             self.isolation_level = options['isolation_level']
188         except KeyError:
189             self.isolation_level = connection.isolation_level
190         else:
191             # Set the isolation level to the value from OPTIONS.
192             if self.isolation_level != connection.isolation_level:
193                 connection.set_session(isolation_level=self.isolation_level)
194 
195         return connection
196 
197     def ensure_timezone(self):
198         if not self.is_usable():
199             return False
200         conn_timezone_name = self.connection.get_parameter_status('TimeZone')
201         timezone_name = self.timezone_name
202         if timezone_name and conn_timezone_name != timezone_name:
203             with self.connection.cursor() as cursor:
204                 cursor.execute(self.ops.set_time_zone_sql(), [timezone_name])
205             return True
206         return False
207 
208     def init_connection_state(self):
209         self.connection.set_client_encoding('UTF8')
210 
211         self.ensure_connection()
212         timezone_changed = self.ensure_timezone()
213         if timezone_changed:
214             # Commit after setting the time zone (see #17062)
215             if not self.get_autocommit():
216                 self.connection.commit()
217 
218     def create_cursor(self, name=None):
219         if name:
220             # In autocommit mode, the cursor will be used outside of a
221             # transaction, hence use a holdable cursor.
222             cursor = self.connection.cursor(name, scrollable=False, withhold=self.connection.autocommit)
223         else:
224             cursor = self.connection.cursor()
225         cursor.tzinfo_factory = utc_tzinfo_factory if settings.USE_TZ else None
226         return cursor
227 
228     def chunked_cursor(self):
229         self._named_cursor_idx += 1
230         return self._cursor(
231             name='_django_curs_%d_%d' % (
232                 # Avoid reusing name in other threads
233                 threading.current_thread().ident,
234                 self._named_cursor_idx,
235             )
236         )
237 
238     def _set_autocommit(self, autocommit):
239         with self.wrap_database_errors:
240             self.connection.autocommit = autocommit
241 
242     def check_constraints(self, table_names=None):
243         """
244         Check constraints by setting them to immediate. Return them to deferred
245         afterward.
246         """
247         self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')
248         self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')
249 
250     def is_usable(self):
251         if self.connection is None:
252             return False
253         try:
254             # Use a psycopg cursor directly, bypassing Django's utilities.
255             self.connection.cursor().execute("SELECT 1")
256         except Database.Error:
257             return False
258         else:
259             return True
260 
261     @property
262     def _nodb_connection(self):
263         nodb_connection = super()._nodb_connection
264         try:
265             nodb_connection.ensure_connection()
266         except (Database.DatabaseError, WrappedDatabaseError):
267             warnings.warn(
268                 "Normally Django will use a connection to the 'postgres' database "
269                 "to avoid running initialization queries against the production "
270                 "database when it's not needed (for example, when running tests). "
271                 "Django was unable to create a connection to the 'postgres' database "
272                 "and will use the first PostgreSQL database instead.",
273                 RuntimeWarning
274             )
275             for connection in connections.all():
276                 if connection.vendor == 'postgresql' and connection.settings_dict['NAME'] != 'postgres':
277                     return self.__class__(
278                         {**self.settings_dict, 'NAME': connection.settings_dict['NAME']},
279                         alias=self.alias,
280                         allow_thread_sharing=False,
281                     )
282         return nodb_connection
283 
284     @cached_property
285     def pg_version(self):
286         with self.temporary_connection():
287             return self.connection.server_version

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/sqlite3/features.py</file>
<class>DatabaseFeatures</class>
<method>None</method>
<code>
6 class DatabaseFeatures(BaseDatabaseFeatures):
7     # SQLite can read from a cursor since SQLite 3.6.5, subject to the caveat
8     # that statements within a connection aren't isolated from each other. See
9     # https://sqlite.org/isolation.html.
10     can_use_chunked_reads = True
11     test_db_allows_multiple_connections = False
12     supports_unspecified_pk = True
13     supports_timezones = False
14     max_query_params = 999
15     supports_mixed_date_datetime_comparisons = False
16     can_introspect_autofield = True
17     can_introspect_decimal_field = False
18     can_introspect_duration_field = False
19     can_introspect_positive_integer_field = True
20     can_introspect_small_integer_field = True
21     introspected_big_auto_field_type = 'AutoField'
22     supports_transactions = True
23     atomic_transactions = False
24     can_rollback_ddl = True
25     supports_atomic_references_rename = Database.sqlite_version_info >= (3, 26, 0)
26     can_create_inline_fk = False
27     supports_paramstyle_pyformat = False
28     supports_sequence_reset = False
29     can_clone_databases = True
30     supports_temporal_subtraction = True
31     ignores_table_name_case = True
32     supports_cast_with_precision = False
33     time_cast_precision = 3
34     can_release_savepoints = True
35     # Is "ALTER TABLE ... RENAME COLUMN" supported?
36     can_alter_table_rename_column = Database.sqlite_version_info >= (3, 25, 0)
37     supports_parentheses_in_compound = False
38     # Deferred constraint checks can be emulated on SQLite < 3.20 but not in a
39     # reasonably performant way.
40     supports_pragma_foreign_key_check = Database.sqlite_version_info >= (3, 20, 0)
41     can_defer_constraint_checks = supports_pragma_foreign_key_check
42     supports_functions_in_partial_indexes = Database.sqlite_version_info >= (3, 15, 0)

</code><intended_behavior>Add a new attribute e.g., `supports_window_functions` within the `DatabaseFeatures` class. This attribute should dynamically reflect whether the connected SQLite database supports window functions based on the SQLite version determined at connection time. This feature flag should be used throughout Django's ORM layer to conditionally allow or disallow window function usage, presenting a clear and informative error when such usage is attempted on unsupported versions.</intended_behavior>, <file>django/db/backends/oracle/features.py</file>
<class>DatabaseFeatures</class>
<method>None</method>
<code>
5 class DatabaseFeatures(BaseDatabaseFeatures):
6     interprets_empty_strings_as_nulls = True
7     has_select_for_update = True
8     has_select_for_update_nowait = True
9     has_select_for_update_skip_locked = True
10     has_select_for_update_of = True
11     select_for_update_of_column = True
12     can_return_columns_from_insert = True
13     can_introspect_autofield = True
14     supports_subqueries_in_group_by = False
15     supports_transactions = True
16     supports_timezones = False
17     has_native_duration_field = True
18     can_defer_constraint_checks = True
19     supports_partially_nullable_unique_constraints = False
20     truncates_names = True
21     supports_tablespaces = True
22     supports_sequence_reset = False
23     can_introspect_materialized_views = True
24     can_introspect_time_field = False
25     atomic_transactions = False
26     supports_combined_alters = False
27     nulls_order_largest = True
28     requires_literal_defaults = True
29     closed_cursor_error_class = InterfaceError
30     bare_select_suffix = " FROM DUAL"
31     # select for update with limit can be achieved on Oracle, but not with the current backend.
32     supports_select_for_update_with_limit = False
33     supports_temporal_subtraction = True
34     # Oracle doesn't ignore quoted identifiers case but the current backend
35     # does by uppercasing all identifiers.
36     ignores_table_name_case = True
37     supports_index_on_text_field = False
38     has_case_insensitive_like = False
39     create_test_procedure_without_params_sql = """
40         CREATE PROCEDURE "TEST_PROCEDURE" AS
41             V_I INTEGER;
42         BEGIN
43             V_I := 1;
44         END;
45     """
46     create_test_procedure_with_int_param_sql = """
47         CREATE PROCEDURE "TEST_PROCEDURE" (P_I INTEGER) AS
48             V_I INTEGER;
49         BEGIN
50             V_I := P_I;
51         END;
52     """
53     supports_callproc_kwargs = True
54     supports_over_clause = True
55     supports_ignore_conflicts = False
56     max_query_params = 2**16 - 1
57     supports_partial_indexes = False
58     supports_slicing_ordering_in_compound = True

</code><intended_behavior>Add a new attribute e.g., `supports_window_functions` within the `DatabaseFeatures` class. This attribute should dynamically reflect whether the connected SQLite database supports window functions based on the SQLite version determined at connection time. This feature flag should be used throughout Django's ORM layer to conditionally allow or disallow window function usage, presenting a clear and informative error when such usage is attempted on unsupported versions.</intended_behavior>]
2025-10-17 10:04:47.255 | INFO     | Search completed. Bug locations: [<file>django/db/backends/sqlite3/base.py</file>
<class>DatabaseWrapper</class>
<method>get_new_connection</method>
<code>
193     def get_new_connection(self, conn_params):
194         conn = Database.connect(**conn_params)
195         conn.create_function("django_date_extract", 2, _sqlite_datetime_extract)
196         conn.create_function("django_date_trunc", 2, _sqlite_date_trunc)
197         conn.create_function("django_datetime_cast_date", 2, _sqlite_datetime_cast_date)
198         conn.create_function("django_datetime_cast_time", 2, _sqlite_datetime_cast_time)
199         conn.create_function("django_datetime_extract", 3, _sqlite_datetime_extract)
200         conn.create_function("django_datetime_trunc", 3, _sqlite_datetime_trunc)
201         conn.create_function("django_time_extract", 2, _sqlite_time_extract)
202         conn.create_function("django_time_trunc", 2, _sqlite_time_trunc)
203         conn.create_function("django_time_diff", 2, _sqlite_time_diff)
204         conn.create_function("django_timestamp_diff", 2, _sqlite_timestamp_diff)
205         conn.create_function("django_format_dtdelta", 3, _sqlite_format_dtdelta)
206         conn.create_function('regexp', 2, _sqlite_regexp)
207         conn.create_function('ACOS', 1, none_guard(math.acos))
208         conn.create_function('ASIN', 1, none_guard(math.asin))
209         conn.create_function('ATAN', 1, none_guard(math.atan))
210         conn.create_function('ATAN2', 2, none_guard(math.atan2))
211         conn.create_function('CEILING', 1, none_guard(math.ceil))
212         conn.create_function('COS', 1, none_guard(math.cos))
213         conn.create_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
214         conn.create_function('DEGREES', 1, none_guard(math.degrees))
215         conn.create_function('EXP', 1, none_guard(math.exp))
216         conn.create_function('FLOOR', 1, none_guard(math.floor))
217         conn.create_function('LN', 1, none_guard(math.log))
218         conn.create_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
219         conn.create_function('LPAD', 3, _sqlite_lpad)
220         conn.create_function('MOD', 2, none_guard(math.fmod))
221         conn.create_function('PI', 0, lambda: math.pi)
222         conn.create_function('POWER', 2, none_guard(operator.pow))
223         conn.create_function('RADIANS', 1, none_guard(math.radians))
224         conn.create_function('REPEAT', 2, none_guard(operator.mul))
225         conn.create_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
226         conn.create_function('RPAD', 3, _sqlite_rpad)
227         conn.create_function('SIN', 1, none_guard(math.sin))
228         conn.create_function('SQRT', 1, none_guard(math.sqrt))
229         conn.create_function('TAN', 1, none_guard(math.tan))
230         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
231         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
232         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
233         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
234         conn.execute('PRAGMA foreign_keys = ON')
235         return conn

</code><intended_behavior>Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection.</intended_behavior>, <file>django/db/backends/oracle/base.py</file>
<class>DatabaseWrapper</class>
<method>get_new_connection</method>
<code>
224     def get_new_connection(self, conn_params):
225         return Database.connect(
226             user=self.settings_dict['USER'],
227             password=self.settings_dict['PASSWORD'],
228             dsn=self._dsn(),
229             **conn_params,
230         )

</code><intended_behavior>Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection.</intended_behavior>, <file>django/db/backends/postgresql/base.py</file>
<class>DatabaseWrapper</class>
<method>get_new_connection</method>
<code>
177     def get_new_connection(self, conn_params):
178         connection = Database.connect(**conn_params)
179 
180         # self.isolation_level must be set:
181         # - after connecting to the database in order to obtain the database's
182         #   default when no value is explicitly specified in options.
183         # - before calling _set_autocommit() because if autocommit is on, that
184         #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.
185         options = self.settings_dict['OPTIONS']
186         try:
187             self.isolation_level = options['isolation_level']
188         except KeyError:
189             self.isolation_level = connection.isolation_level
190         else:
191             # Set the isolation level to the value from OPTIONS.
192             if self.isolation_level != connection.isolation_level:
193                 connection.set_session(isolation_level=self.isolation_level)
194 
195         return connection

</code><intended_behavior>Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection.</intended_behavior>, <file>django/db/backends/sqlite3/base.py</file>
<class>DatabaseWrapper</class>
<method>None</method>
<code>
77 class DatabaseWrapper(BaseDatabaseWrapper):
78     vendor = 'sqlite'
79     display_name = 'SQLite'
80     # SQLite doesn't actually support most of these types, but it "does the right
81     # thing" given more verbose field definitions, so leave them as is so that
82     # schema inspection is more useful.
83     data_types = {
84         'AutoField': 'integer',
85         'BigAutoField': 'integer',
86         'BinaryField': 'BLOB',
87         'BooleanField': 'bool',
88         'CharField': 'varchar(%(max_length)s)',
89         'DateField': 'date',
90         'DateTimeField': 'datetime',
91         'DecimalField': 'decimal',
92         'DurationField': 'bigint',
93         'FileField': 'varchar(%(max_length)s)',
94         'FilePathField': 'varchar(%(max_length)s)',
95         'FloatField': 'real',
96         'IntegerField': 'integer',
97         'BigIntegerField': 'bigint',
98         'IPAddressField': 'char(15)',
99         'GenericIPAddressField': 'char(39)',
100         'NullBooleanField': 'bool',
101         'OneToOneField': 'integer',
102         'PositiveIntegerField': 'integer unsigned',
103         'PositiveSmallIntegerField': 'smallint unsigned',
104         'SlugField': 'varchar(%(max_length)s)',
105         'SmallIntegerField': 'smallint',
106         'TextField': 'text',
107         'TimeField': 'time',
108         'UUIDField': 'char(32)',
109     }
110     data_type_check_constraints = {
111         'PositiveIntegerField': '"%(column)s" >= 0',
112         'PositiveSmallIntegerField': '"%(column)s" >= 0',
113     }
114     data_types_suffix = {
115         'AutoField': 'AUTOINCREMENT',
116         'BigAutoField': 'AUTOINCREMENT',
117     }
118     # SQLite requires LIKE statements to include an ESCAPE clause if the value
119     # being escaped has a percent or underscore in it.
120     # See https://www.sqlite.org/lang_expr.html for an explanation.
121     operators = {
122         'exact': '= %s',
123         'iexact': "LIKE %s ESCAPE '\\'",
124         'contains': "LIKE %s ESCAPE '\\'",
125         'icontains': "LIKE %s ESCAPE '\\'",
126         'regex': 'REGEXP %s',
127         'iregex': "REGEXP '(?i)' || %s",
128         'gt': '> %s',
129         'gte': '>= %s',
130         'lt': '< %s',
131         'lte': '<= %s',
132         'startswith': "LIKE %s ESCAPE '\\'",
133         'endswith': "LIKE %s ESCAPE '\\'",
134         'istartswith': "LIKE %s ESCAPE '\\'",
135         'iendswith': "LIKE %s ESCAPE '\\'",
136     }
137 
138     # The patterns below are used to generate SQL pattern lookup clauses when
139     # the right-hand side of the lookup isn't a raw string (it might be an expression
140     # or the result of a bilateral transformation).
141     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
142     # escaped on database side.
143     #
144     # Note: we use str.format() here for readability as '%' is used as a wildcard for
145     # the LIKE operator.
146     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
147     pattern_ops = {
148         'contains': r"LIKE '%%' || {} || '%%' ESCAPE '\'",
149         'icontains': r"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'",
150         'startswith': r"LIKE {} || '%%' ESCAPE '\'",
151         'istartswith': r"LIKE UPPER({}) || '%%' ESCAPE '\'",
152         'endswith': r"LIKE '%%' || {} ESCAPE '\'",
153         'iendswith': r"LIKE '%%' || UPPER({}) ESCAPE '\'",
154     }
155 
156     Database = Database
157     SchemaEditorClass = DatabaseSchemaEditor
158     # Classes instantiated in __init__().
159     client_class = DatabaseClient
160     creation_class = DatabaseCreation
161     features_class = DatabaseFeatures
162     introspection_class = DatabaseIntrospection
163     ops_class = DatabaseOperations
164 
165     def get_connection_params(self):
166         settings_dict = self.settings_dict
167         if not settings_dict['NAME']:
168             raise ImproperlyConfigured(
169                 "settings.DATABASES is improperly configured. "
170                 "Please supply the NAME value.")
171         kwargs = {
172             'database': settings_dict['NAME'],
173             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,
174             **settings_dict['OPTIONS'],
175         }
176         # Always allow the underlying SQLite connection to be shareable
177         # between multiple threads. The safe-guarding will be handled at a
178         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`
179         # property. This is necessary as the shareability is disabled by
180         # default in pysqlite and it cannot be changed once a connection is
181         # opened.
182         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:
183             warnings.warn(
184                 'The `check_same_thread` option was provided and set to '
185                 'True. It will be overridden with False. Use the '
186                 '`DatabaseWrapper.allow_thread_sharing` property instead '
187                 'for controlling thread shareability.',
188                 RuntimeWarning
189             )
190         kwargs.update({'check_same_thread': False, 'uri': True})
191         return kwargs
192 
193     def get_new_connection(self, conn_params):
194         conn = Database.connect(**conn_params)
195         conn.create_function("django_date_extract", 2, _sqlite_datetime_extract)
196         conn.create_function("django_date_trunc", 2, _sqlite_date_trunc)
197         conn.create_function("django_datetime_cast_date", 2, _sqlite_datetime_cast_date)
198         conn.create_function("django_datetime_cast_time", 2, _sqlite_datetime_cast_time)
199         conn.create_function("django_datetime_extract", 3, _sqlite_datetime_extract)
200         conn.create_function("django_datetime_trunc", 3, _sqlite_datetime_trunc)
201         conn.create_function("django_time_extract", 2, _sqlite_time_extract)
202         conn.create_function("django_time_trunc", 2, _sqlite_time_trunc)
203         conn.create_function("django_time_diff", 2, _sqlite_time_diff)
204         conn.create_function("django_timestamp_diff", 2, _sqlite_timestamp_diff)
205         conn.create_function("django_format_dtdelta", 3, _sqlite_format_dtdelta)
206         conn.create_function('regexp', 2, _sqlite_regexp)
207         conn.create_function('ACOS', 1, none_guard(math.acos))
208         conn.create_function('ASIN', 1, none_guard(math.asin))
209         conn.create_function('ATAN', 1, none_guard(math.atan))
210         conn.create_function('ATAN2', 2, none_guard(math.atan2))
211         conn.create_function('CEILING', 1, none_guard(math.ceil))
212         conn.create_function('COS', 1, none_guard(math.cos))
213         conn.create_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
214         conn.create_function('DEGREES', 1, none_guard(math.degrees))
215         conn.create_function('EXP', 1, none_guard(math.exp))
216         conn.create_function('FLOOR', 1, none_guard(math.floor))
217         conn.create_function('LN', 1, none_guard(math.log))
218         conn.create_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
219         conn.create_function('LPAD', 3, _sqlite_lpad)
220         conn.create_function('MOD', 2, none_guard(math.fmod))
221         conn.create_function('PI', 0, lambda: math.pi)
222         conn.create_function('POWER', 2, none_guard(operator.pow))
223         conn.create_function('RADIANS', 1, none_guard(math.radians))
224         conn.create_function('REPEAT', 2, none_guard(operator.mul))
225         conn.create_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
226         conn.create_function('RPAD', 3, _sqlite_rpad)
227         conn.create_function('SIN', 1, none_guard(math.sin))
228         conn.create_function('SQRT', 1, none_guard(math.sqrt))
229         conn.create_function('TAN', 1, none_guard(math.tan))
230         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
231         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
232         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
233         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
234         conn.execute('PRAGMA foreign_keys = ON')
235         return conn
236 
237     def init_connection_state(self):
238         pass
239 
240     def create_cursor(self, name=None):
241         return self.connection.cursor(factory=SQLiteCursorWrapper)
242 
243     def close(self):
244         self.validate_thread_sharing()
245         # If database is in memory, closing the connection destroys the
246         # database. To prevent accidental data loss, ignore close requests on
247         # an in-memory db.
248         if not self.is_in_memory_db():
249             BaseDatabaseWrapper.close(self)
250 
251     def _savepoint_allowed(self):
252         # When 'isolation_level' is not None, sqlite3 commits before each
253         # savepoint; it's a bug. When it is None, savepoints don't make sense
254         # because autocommit is enabled. The only exception is inside 'atomic'
255         # blocks. To work around that bug, on SQLite, 'atomic' starts a
256         # transaction explicitly rather than simply disable autocommit.
257         return self.in_atomic_block
258 
259     def _set_autocommit(self, autocommit):
260         if autocommit:
261             level = None
262         else:
263             # sqlite3's internal default is ''. It's different from None.
264             # See Modules/_sqlite/connection.c.
265             level = ''
266         # 'isolation_level' is a misleading API.
267         # SQLite always runs at the SERIALIZABLE isolation level.
268         with self.wrap_database_errors:
269             self.connection.isolation_level = level
270 
271     def disable_constraint_checking(self):
272         with self.cursor() as cursor:
273             cursor.execute('PRAGMA foreign_keys = OFF')
274             # Foreign key constraints cannot be turned off while in a multi-
275             # statement transaction. Fetch the current state of the pragma
276             # to determine if constraints are effectively disabled.
277             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]
278         return not bool(enabled)
279 
280     def enable_constraint_checking(self):
281         self.cursor().execute('PRAGMA foreign_keys = ON')
282 
283     def check_constraints(self, table_names=None):
284         """
285         Check each table name in `table_names` for rows with invalid foreign
286         key references. This method is intended to be used in conjunction with
287         `disable_constraint_checking()` and `enable_constraint_checking()`, to
288         determine if rows with invalid references were entered while constraint
289         checks were off.
290         """
291         if self.features.supports_pragma_foreign_key_check:
292             with self.cursor() as cursor:
293                 if table_names is None:
294                     violations = self.cursor().execute('PRAGMA foreign_key_check').fetchall()
295                 else:
296                     violations = chain.from_iterable(
297                         cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()
298                         for table_name in table_names
299                     )
300                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
301                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:
302                     foreign_key = cursor.execute(
303                         'PRAGMA foreign_key_list(%s)' % table_name
304                     ).fetchall()[foreign_key_index]
305                     column_name, referenced_column_name = foreign_key[3:5]
306                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
307                     primary_key_value, bad_value = cursor.execute(
308                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (
309                             primary_key_column_name, column_name, table_name
310                         ),
311                         (rowid,),
312                     ).fetchone()
313                     raise utils.IntegrityError(
314                         "The row in table '%s' with primary key '%s' has an "
315                         "invalid foreign key: %s.%s contains a value '%s' that "
316                         "does not have a corresponding value in %s.%s." % (
317                             table_name, primary_key_value, table_name, column_name,
318                             bad_value, referenced_table_name, referenced_column_name
319                         )
320                     )
321         else:
322             with self.cursor() as cursor:
323                 if table_names is None:
324                     table_names = self.introspection.table_names(cursor)
325                 for table_name in table_names:
326                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
327                     if not primary_key_column_name:
328                         continue
329                     key_columns = self.introspection.get_key_columns(cursor, table_name)
330                     for column_name, referenced_table_name, referenced_column_name in key_columns:
331                         cursor.execute(
332                             """
333                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING
334                             LEFT JOIN `%s` as REFERRED
335                             ON (REFERRING.`%s` = REFERRED.`%s`)
336                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL
337                             """
338                             % (
339                                 primary_key_column_name, column_name, table_name,
340                                 referenced_table_name, column_name, referenced_column_name,
341                                 column_name, referenced_column_name,
342                             )
343                         )
344                         for bad_row in cursor.fetchall():
345                             raise utils.IntegrityError(
346                                 "The row in table '%s' with primary key '%s' has an "
347                                 "invalid foreign key: %s.%s contains a value '%s' that "
348                                 "does not have a corresponding value in %s.%s." % (
349                                     table_name, bad_row[0], table_name, column_name,
350                                     bad_row[1], referenced_table_name, referenced_column_name,
351                                 )
352                             )
353 
354     def is_usable(self):
355         return True
356 
357     def _start_transaction_under_autocommit(self):
358         """
359         Start a transaction explicitly in autocommit mode.
360 
361         Staying in autocommit mode works around a bug of sqlite3 that breaks
362         savepoints when autocommit is disabled.
363         """
364         self.cursor().execute("BEGIN")
365 
366     def is_in_memory_db(self):
367         return self.creation.is_in_memory_db(self.settings_dict['NAME'])

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/oracle/base.py</file>
<class>DatabaseWrapper</class>
<method>None</method>
<code>
93 class DatabaseWrapper(BaseDatabaseWrapper):
94     vendor = 'oracle'
95     display_name = 'Oracle'
96     # This dictionary maps Field objects to their associated Oracle column
97     # types, as strings. Column-type strings can contain format strings; they'll
98     # be interpolated against the values of Field.__dict__ before being output.
99     # If a column type is set to None, it won't be included in the output.
100     #
101     # Any format strings starting with "qn_" are quoted before being used in the
102     # output (the "qn_" prefix is stripped before the lookup is performed.
103     data_types = {
104         'AutoField': 'NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY',
105         'BigAutoField': 'NUMBER(19) GENERATED BY DEFAULT ON NULL AS IDENTITY',
106         'BinaryField': 'BLOB',
107         'BooleanField': 'NUMBER(1)',
108         'CharField': 'NVARCHAR2(%(max_length)s)',
109         'DateField': 'DATE',
110         'DateTimeField': 'TIMESTAMP',
111         'DecimalField': 'NUMBER(%(max_digits)s, %(decimal_places)s)',
112         'DurationField': 'INTERVAL DAY(9) TO SECOND(6)',
113         'FileField': 'NVARCHAR2(%(max_length)s)',
114         'FilePathField': 'NVARCHAR2(%(max_length)s)',
115         'FloatField': 'DOUBLE PRECISION',
116         'IntegerField': 'NUMBER(11)',
117         'BigIntegerField': 'NUMBER(19)',
118         'IPAddressField': 'VARCHAR2(15)',
119         'GenericIPAddressField': 'VARCHAR2(39)',
120         'NullBooleanField': 'NUMBER(1)',
121         'OneToOneField': 'NUMBER(11)',
122         'PositiveIntegerField': 'NUMBER(11)',
123         'PositiveSmallIntegerField': 'NUMBER(11)',
124         'SlugField': 'NVARCHAR2(%(max_length)s)',
125         'SmallIntegerField': 'NUMBER(11)',
126         'TextField': 'NCLOB',
127         'TimeField': 'TIMESTAMP',
128         'URLField': 'VARCHAR2(%(max_length)s)',
129         'UUIDField': 'VARCHAR2(32)',
130     }
131     data_type_check_constraints = {
132         'BooleanField': '%(qn_column)s IN (0,1)',
133         'NullBooleanField': '%(qn_column)s IN (0,1)',
134         'PositiveIntegerField': '%(qn_column)s >= 0',
135         'PositiveSmallIntegerField': '%(qn_column)s >= 0',
136     }
137 
138     # Oracle doesn't support a database index on these columns.
139     _limited_data_types = ('clob', 'nclob', 'blob')
140 
141     operators = _UninitializedOperatorsDescriptor()
142 
143     _standard_operators = {
144         'exact': '= %s',
145         'iexact': '= UPPER(%s)',
146         'contains': "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
147         'icontains': "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
148         'gt': '> %s',
149         'gte': '>= %s',
150         'lt': '< %s',
151         'lte': '<= %s',
152         'startswith': "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
153         'endswith': "LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
154         'istartswith': "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
155         'iendswith': "LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\' USING NCHAR_CS)",
156     }
157 
158     _likec_operators = {
159         **_standard_operators,
160         'contains': "LIKEC %s ESCAPE '\\'",
161         'icontains': "LIKEC UPPER(%s) ESCAPE '\\'",
162         'startswith': "LIKEC %s ESCAPE '\\'",
163         'endswith': "LIKEC %s ESCAPE '\\'",
164         'istartswith': "LIKEC UPPER(%s) ESCAPE '\\'",
165         'iendswith': "LIKEC UPPER(%s) ESCAPE '\\'",
166     }
167 
168     # The patterns below are used to generate SQL pattern lookup clauses when
169     # the right-hand side of the lookup isn't a raw string (it might be an expression
170     # or the result of a bilateral transformation).
171     # In those cases, special characters for LIKE operators (e.g. \, %, _)
172     # should be escaped on the database side.
173     #
174     # Note: we use str.format() here for readability as '%' is used as a wildcard for
175     # the LIKE operator.
176     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
177     _pattern_ops = {
178         'contains': "'%%' || {} || '%%'",
179         'icontains': "'%%' || UPPER({}) || '%%'",
180         'startswith': "{} || '%%'",
181         'istartswith': "UPPER({}) || '%%'",
182         'endswith': "'%%' || {}",
183         'iendswith': "'%%' || UPPER({})",
184     }
185 
186     _standard_pattern_ops = {k: "LIKE TRANSLATE( " + v + " USING NCHAR_CS)"
187                                 " ESCAPE TRANSLATE('\\' USING NCHAR_CS)"
188                              for k, v in _pattern_ops.items()}
189     _likec_pattern_ops = {k: "LIKEC " + v + " ESCAPE '\\'"
190                           for k, v in _pattern_ops.items()}
191 
192     Database = Database
193     SchemaEditorClass = DatabaseSchemaEditor
194     # Classes instantiated in __init__().
195     client_class = DatabaseClient
196     creation_class = DatabaseCreation
197     features_class = DatabaseFeatures
198     introspection_class = DatabaseIntrospection
199     ops_class = DatabaseOperations
200     validation_class = DatabaseValidation
201 
202     def __init__(self, *args, **kwargs):
203         super().__init__(*args, **kwargs)
204         use_returning_into = self.settings_dict["OPTIONS"].get('use_returning_into', True)
205         self.features.can_return_columns_from_insert = use_returning_into
206 
207     def _dsn(self):
208         settings_dict = self.settings_dict
209         if not settings_dict['HOST'].strip():
210             settings_dict['HOST'] = 'localhost'
211         if settings_dict['PORT']:
212             return Database.makedsn(settings_dict['HOST'], int(settings_dict['PORT']), settings_dict['NAME'])
213         return settings_dict['NAME']
214 
215     def _connect_string(self):
216         return '%s/\\"%s\\"@%s' % (self.settings_dict['USER'], self.settings_dict['PASSWORD'], self._dsn())
217 
218     def get_connection_params(self):
219         conn_params = self.settings_dict['OPTIONS'].copy()
220         if 'use_returning_into' in conn_params:
221             del conn_params['use_returning_into']
222         return conn_params
223 
224     def get_new_connection(self, conn_params):
225         return Database.connect(
226             user=self.settings_dict['USER'],
227             password=self.settings_dict['PASSWORD'],
228             dsn=self._dsn(),
229             **conn_params,
230         )
231 
232     def init_connection_state(self):
233         cursor = self.create_cursor()
234         # Set the territory first. The territory overrides NLS_DATE_FORMAT
235         # and NLS_TIMESTAMP_FORMAT to the territory default. When all of
236         # these are set in single statement it isn't clear what is supposed
237         # to happen.
238         cursor.execute("ALTER SESSION SET NLS_TERRITORY = 'AMERICA'")
239         # Set Oracle date to ANSI date format.  This only needs to execute
240         # once when we create a new connection. We also set the Territory
241         # to 'AMERICA' which forces Sunday to evaluate to a '1' in
242         # TO_CHAR().
243         cursor.execute(
244             "ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS'"
245             " NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF'" +
246             (" TIME_ZONE = 'UTC'" if settings.USE_TZ else '')
247         )
248         cursor.close()
249         if 'operators' not in self.__dict__:
250             # Ticket #14149: Check whether our LIKE implementation will
251             # work for this connection or we need to fall back on LIKEC.
252             # This check is performed only once per DatabaseWrapper
253             # instance per thread, since subsequent connections will use
254             # the same settings.
255             cursor = self.create_cursor()
256             try:
257                 cursor.execute("SELECT 1 FROM DUAL WHERE DUMMY %s"
258                                % self._standard_operators['contains'],
259                                ['X'])
260             except Database.DatabaseError:
261                 self.operators = self._likec_operators
262                 self.pattern_ops = self._likec_pattern_ops
263             else:
264                 self.operators = self._standard_operators
265                 self.pattern_ops = self._standard_pattern_ops
266             cursor.close()
267         self.connection.stmtcachesize = 20
268         # Ensure all changes are preserved even when AUTOCOMMIT is False.
269         if not self.get_autocommit():
270             self.commit()
271 
272     def create_cursor(self, name=None):
273         return FormatStylePlaceholderCursor(self.connection)
274 
275     def _commit(self):
276         if self.connection is not None:
277             with wrap_oracle_errors():
278                 return self.connection.commit()
279 
280     # Oracle doesn't support releasing savepoints. But we fake them when query
281     # logging is enabled to keep query counts consistent with other backends.
282     def _savepoint_commit(self, sid):
283         if self.queries_logged:
284             self.queries_log.append({
285                 'sql': '-- RELEASE SAVEPOINT %s (faked)' % self.ops.quote_name(sid),
286                 'time': '0.000',
287             })
288 
289     def _set_autocommit(self, autocommit):
290         with self.wrap_database_errors:
291             self.connection.autocommit = autocommit
292 
293     def check_constraints(self, table_names=None):
294         """
295         Check constraints by setting them to immediate. Return them to deferred
296         afterward.
297         """
298         self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')
299         self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')
300 
301     def is_usable(self):
302         try:
303             self.connection.ping()
304         except Database.Error:
305             return False
306         else:
307             return True
308 
309     @cached_property
310     def oracle_version(self):
311         with self.temporary_connection():
312             return tuple(int(x) for x in self.connection.version.split('.'))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/postgresql/base.py</file>
<class>DatabaseWrapper</class>
<method>None</method>
<code>
61 class DatabaseWrapper(BaseDatabaseWrapper):
62     vendor = 'postgresql'
63     display_name = 'PostgreSQL'
64     # This dictionary maps Field objects to their associated PostgreSQL column
65     # types, as strings. Column-type strings can contain format strings; they'll
66     # be interpolated against the values of Field.__dict__ before being output.
67     # If a column type is set to None, it won't be included in the output.
68     data_types = {
69         'AutoField': 'serial',
70         'BigAutoField': 'bigserial',
71         'BinaryField': 'bytea',
72         'BooleanField': 'boolean',
73         'CharField': 'varchar(%(max_length)s)',
74         'DateField': 'date',
75         'DateTimeField': 'timestamp with time zone',
76         'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)',
77         'DurationField': 'interval',
78         'FileField': 'varchar(%(max_length)s)',
79         'FilePathField': 'varchar(%(max_length)s)',
80         'FloatField': 'double precision',
81         'IntegerField': 'integer',
82         'BigIntegerField': 'bigint',
83         'IPAddressField': 'inet',
84         'GenericIPAddressField': 'inet',
85         'NullBooleanField': 'boolean',
86         'OneToOneField': 'integer',
87         'PositiveIntegerField': 'integer',
88         'PositiveSmallIntegerField': 'smallint',
89         'SlugField': 'varchar(%(max_length)s)',
90         'SmallIntegerField': 'smallint',
91         'TextField': 'text',
92         'TimeField': 'time',
93         'UUIDField': 'uuid',
94     }
95     data_type_check_constraints = {
96         'PositiveIntegerField': '"%(column)s" >= 0',
97         'PositiveSmallIntegerField': '"%(column)s" >= 0',
98     }
99     operators = {
100         'exact': '= %s',
101         'iexact': '= UPPER(%s)',
102         'contains': 'LIKE %s',
103         'icontains': 'LIKE UPPER(%s)',
104         'regex': '~ %s',
105         'iregex': '~* %s',
106         'gt': '> %s',
107         'gte': '>= %s',
108         'lt': '< %s',
109         'lte': '<= %s',
110         'startswith': 'LIKE %s',
111         'endswith': 'LIKE %s',
112         'istartswith': 'LIKE UPPER(%s)',
113         'iendswith': 'LIKE UPPER(%s)',
114     }
115 
116     # The patterns below are used to generate SQL pattern lookup clauses when
117     # the right-hand side of the lookup isn't a raw string (it might be an expression
118     # or the result of a bilateral transformation).
119     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
120     # escaped on database side.
121     #
122     # Note: we use str.format() here for readability as '%' is used as a wildcard for
123     # the LIKE operator.
124     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, E'\\', E'\\\\'), E'%%', E'\\%%'), E'_', E'\\_')"
125     pattern_ops = {
126         'contains': "LIKE '%%' || {} || '%%'",
127         'icontains': "LIKE '%%' || UPPER({}) || '%%'",
128         'startswith': "LIKE {} || '%%'",
129         'istartswith': "LIKE UPPER({}) || '%%'",
130         'endswith': "LIKE '%%' || {}",
131         'iendswith': "LIKE '%%' || UPPER({})",
132     }
133 
134     Database = Database
135     SchemaEditorClass = DatabaseSchemaEditor
136     # Classes instantiated in __init__().
137     client_class = DatabaseClient
138     creation_class = DatabaseCreation
139     features_class = DatabaseFeatures
140     introspection_class = DatabaseIntrospection
141     ops_class = DatabaseOperations
142     # PostgreSQL backend-specific attributes.
143     _named_cursor_idx = 0
144 
145     def get_connection_params(self):
146         settings_dict = self.settings_dict
147         # None may be used to connect to the default 'postgres' db
148         if settings_dict['NAME'] == '':
149             raise ImproperlyConfigured(
150                 "settings.DATABASES is improperly configured. "
151                 "Please supply the NAME value.")
152         if len(settings_dict['NAME'] or '') > self.ops.max_name_length():
153             raise ImproperlyConfigured(
154                 "The database name '%s' (%d characters) is longer than "
155                 "PostgreSQL's limit of %d characters. Supply a shorter NAME "
156                 "in settings.DATABASES." % (
157                     settings_dict['NAME'],
158                     len(settings_dict['NAME']),
159                     self.ops.max_name_length(),
160                 )
161             )
162         conn_params = {
163             'database': settings_dict['NAME'] or 'postgres',
164             **settings_dict['OPTIONS'],
165         }
166         conn_params.pop('isolation_level', None)
167         if settings_dict['USER']:
168             conn_params['user'] = settings_dict['USER']
169         if settings_dict['PASSWORD']:
170             conn_params['password'] = settings_dict['PASSWORD']
171         if settings_dict['HOST']:
172             conn_params['host'] = settings_dict['HOST']
173         if settings_dict['PORT']:
174             conn_params['port'] = settings_dict['PORT']
175         return conn_params
176 
177     def get_new_connection(self, conn_params):
178         connection = Database.connect(**conn_params)
179 
180         # self.isolation_level must be set:
181         # - after connecting to the database in order to obtain the database's
182         #   default when no value is explicitly specified in options.
183         # - before calling _set_autocommit() because if autocommit is on, that
184         #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.
185         options = self.settings_dict['OPTIONS']
186         try:
187             self.isolation_level = options['isolation_level']
188         except KeyError:
189             self.isolation_level = connection.isolation_level
190         else:
191             # Set the isolation level to the value from OPTIONS.
192             if self.isolation_level != connection.isolation_level:
193                 connection.set_session(isolation_level=self.isolation_level)
194 
195         return connection
196 
197     def ensure_timezone(self):
198         if not self.is_usable():
199             return False
200         conn_timezone_name = self.connection.get_parameter_status('TimeZone')
201         timezone_name = self.timezone_name
202         if timezone_name and conn_timezone_name != timezone_name:
203             with self.connection.cursor() as cursor:
204                 cursor.execute(self.ops.set_time_zone_sql(), [timezone_name])
205             return True
206         return False
207 
208     def init_connection_state(self):
209         self.connection.set_client_encoding('UTF8')
210 
211         self.ensure_connection()
212         timezone_changed = self.ensure_timezone()
213         if timezone_changed:
214             # Commit after setting the time zone (see #17062)
215             if not self.get_autocommit():
216                 self.connection.commit()
217 
218     def create_cursor(self, name=None):
219         if name:
220             # In autocommit mode, the cursor will be used outside of a
221             # transaction, hence use a holdable cursor.
222             cursor = self.connection.cursor(name, scrollable=False, withhold=self.connection.autocommit)
223         else:
224             cursor = self.connection.cursor()
225         cursor.tzinfo_factory = utc_tzinfo_factory if settings.USE_TZ else None
226         return cursor
227 
228     def chunked_cursor(self):
229         self._named_cursor_idx += 1
230         return self._cursor(
231             name='_django_curs_%d_%d' % (
232                 # Avoid reusing name in other threads
233                 threading.current_thread().ident,
234                 self._named_cursor_idx,
235             )
236         )
237 
238     def _set_autocommit(self, autocommit):
239         with self.wrap_database_errors:
240             self.connection.autocommit = autocommit
241 
242     def check_constraints(self, table_names=None):
243         """
244         Check constraints by setting them to immediate. Return them to deferred
245         afterward.
246         """
247         self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')
248         self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')
249 
250     def is_usable(self):
251         if self.connection is None:
252             return False
253         try:
254             # Use a psycopg cursor directly, bypassing Django's utilities.
255             self.connection.cursor().execute("SELECT 1")
256         except Database.Error:
257             return False
258         else:
259             return True
260 
261     @property
262     def _nodb_connection(self):
263         nodb_connection = super()._nodb_connection
264         try:
265             nodb_connection.ensure_connection()
266         except (Database.DatabaseError, WrappedDatabaseError):
267             warnings.warn(
268                 "Normally Django will use a connection to the 'postgres' database "
269                 "to avoid running initialization queries against the production "
270                 "database when it's not needed (for example, when running tests). "
271                 "Django was unable to create a connection to the 'postgres' database "
272                 "and will use the first PostgreSQL database instead.",
273                 RuntimeWarning
274             )
275             for connection in connections.all():
276                 if connection.vendor == 'postgresql' and connection.settings_dict['NAME'] != 'postgres':
277                     return self.__class__(
278                         {**self.settings_dict, 'NAME': connection.settings_dict['NAME']},
279                         alias=self.alias,
280                         allow_thread_sharing=False,
281                     )
282         return nodb_connection
283 
284     @cached_property
285     def pg_version(self):
286         with self.temporary_connection():
287             return self.connection.server_version

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/sqlite3/features.py</file>
<class>DatabaseFeatures</class>
<method>None</method>
<code>
6 class DatabaseFeatures(BaseDatabaseFeatures):
7     # SQLite can read from a cursor since SQLite 3.6.5, subject to the caveat
8     # that statements within a connection aren't isolated from each other. See
9     # https://sqlite.org/isolation.html.
10     can_use_chunked_reads = True
11     test_db_allows_multiple_connections = False
12     supports_unspecified_pk = True
13     supports_timezones = False
14     max_query_params = 999
15     supports_mixed_date_datetime_comparisons = False
16     can_introspect_autofield = True
17     can_introspect_decimal_field = False
18     can_introspect_duration_field = False
19     can_introspect_positive_integer_field = True
20     can_introspect_small_integer_field = True
21     introspected_big_auto_field_type = 'AutoField'
22     supports_transactions = True
23     atomic_transactions = False
24     can_rollback_ddl = True
25     supports_atomic_references_rename = Database.sqlite_version_info >= (3, 26, 0)
26     can_create_inline_fk = False
27     supports_paramstyle_pyformat = False
28     supports_sequence_reset = False
29     can_clone_databases = True
30     supports_temporal_subtraction = True
31     ignores_table_name_case = True
32     supports_cast_with_precision = False
33     time_cast_precision = 3
34     can_release_savepoints = True
35     # Is "ALTER TABLE ... RENAME COLUMN" supported?
36     can_alter_table_rename_column = Database.sqlite_version_info >= (3, 25, 0)
37     supports_parentheses_in_compound = False
38     # Deferred constraint checks can be emulated on SQLite < 3.20 but not in a
39     # reasonably performant way.
40     supports_pragma_foreign_key_check = Database.sqlite_version_info >= (3, 20, 0)
41     can_defer_constraint_checks = supports_pragma_foreign_key_check
42     supports_functions_in_partial_indexes = Database.sqlite_version_info >= (3, 15, 0)

</code><intended_behavior>Add a new attribute e.g., `supports_window_functions` within the `DatabaseFeatures` class. This attribute should dynamically reflect whether the connected SQLite database supports window functions based on the SQLite version determined at connection time. This feature flag should be used throughout Django's ORM layer to conditionally allow or disallow window function usage, presenting a clear and informative error when such usage is attempted on unsupported versions.</intended_behavior>, <file>django/db/backends/oracle/features.py</file>
<class>DatabaseFeatures</class>
<method>None</method>
<code>
5 class DatabaseFeatures(BaseDatabaseFeatures):
6     interprets_empty_strings_as_nulls = True
7     has_select_for_update = True
8     has_select_for_update_nowait = True
9     has_select_for_update_skip_locked = True
10     has_select_for_update_of = True
11     select_for_update_of_column = True
12     can_return_columns_from_insert = True
13     can_introspect_autofield = True
14     supports_subqueries_in_group_by = False
15     supports_transactions = True
16     supports_timezones = False
17     has_native_duration_field = True
18     can_defer_constraint_checks = True
19     supports_partially_nullable_unique_constraints = False
20     truncates_names = True
21     supports_tablespaces = True
22     supports_sequence_reset = False
23     can_introspect_materialized_views = True
24     can_introspect_time_field = False
25     atomic_transactions = False
26     supports_combined_alters = False
27     nulls_order_largest = True
28     requires_literal_defaults = True
29     closed_cursor_error_class = InterfaceError
30     bare_select_suffix = " FROM DUAL"
31     # select for update with limit can be achieved on Oracle, but not with the current backend.
32     supports_select_for_update_with_limit = False
33     supports_temporal_subtraction = True
34     # Oracle doesn't ignore quoted identifiers case but the current backend
35     # does by uppercasing all identifiers.
36     ignores_table_name_case = True
37     supports_index_on_text_field = False
38     has_case_insensitive_like = False
39     create_test_procedure_without_params_sql = """
40         CREATE PROCEDURE "TEST_PROCEDURE" AS
41             V_I INTEGER;
42         BEGIN
43             V_I := 1;
44         END;
45     """
46     create_test_procedure_with_int_param_sql = """
47         CREATE PROCEDURE "TEST_PROCEDURE" (P_I INTEGER) AS
48             V_I INTEGER;
49         BEGIN
50             V_I := P_I;
51         END;
52     """
53     supports_callproc_kwargs = True
54     supports_over_clause = True
55     supports_ignore_conflicts = False
56     max_query_params = 2**16 - 1
57     supports_partial_indexes = False
58     supports_slicing_ordering_in_compound = True

</code><intended_behavior>Add a new attribute e.g., `supports_window_functions` within the `DatabaseFeatures` class. This attribute should dynamically reflect whether the connected SQLite database supports window functions based on the SQLite version determined at connection time. This feature flag should be used throughout Django's ORM layer to conditionally allow or disallow window function usage, presenting a clear and informative error when such usage is attempted on unsupported versions.</intended_behavior>]
2025-10-17 10:04:47.256 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 10:04:47.256 | INFO     | Search-only: skipping patch selection
2025-10-17 10:04:47.478 | INFO     | Task django__django-10853 completed successfully.
2025-10-17 10:04:47.478 | INFO     | No patch generated. You can try running ACR again.
