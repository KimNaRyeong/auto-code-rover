[
    {
        "rel_file_path": "django/db/backends/sqlite3/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/sqlite3/base.py",
        "start": 193,
        "end": 235,
        "class_name": "DatabaseWrapper",
        "method_name": "get_new_connection",
        "code": "193     def get_new_connection(self, conn_params):\n194         conn = Database.connect(**conn_params)\n195         conn.create_function(\"django_date_extract\", 2, _sqlite_datetime_extract)\n196         conn.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n197         conn.create_function(\"django_datetime_cast_date\", 2, _sqlite_datetime_cast_date)\n198         conn.create_function(\"django_datetime_cast_time\", 2, _sqlite_datetime_cast_time)\n199         conn.create_function(\"django_datetime_extract\", 3, _sqlite_datetime_extract)\n200         conn.create_function(\"django_datetime_trunc\", 3, _sqlite_datetime_trunc)\n201         conn.create_function(\"django_time_extract\", 2, _sqlite_time_extract)\n202         conn.create_function(\"django_time_trunc\", 2, _sqlite_time_trunc)\n203         conn.create_function(\"django_time_diff\", 2, _sqlite_time_diff)\n204         conn.create_function(\"django_timestamp_diff\", 2, _sqlite_timestamp_diff)\n205         conn.create_function(\"django_format_dtdelta\", 3, _sqlite_format_dtdelta)\n206         conn.create_function('regexp', 2, _sqlite_regexp)\n207         conn.create_function('ACOS', 1, none_guard(math.acos))\n208         conn.create_function('ASIN', 1, none_guard(math.asin))\n209         conn.create_function('ATAN', 1, none_guard(math.atan))\n210         conn.create_function('ATAN2', 2, none_guard(math.atan2))\n211         conn.create_function('CEILING', 1, none_guard(math.ceil))\n212         conn.create_function('COS', 1, none_guard(math.cos))\n213         conn.create_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))\n214         conn.create_function('DEGREES', 1, none_guard(math.degrees))\n215         conn.create_function('EXP', 1, none_guard(math.exp))\n216         conn.create_function('FLOOR', 1, none_guard(math.floor))\n217         conn.create_function('LN', 1, none_guard(math.log))\n218         conn.create_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))\n219         conn.create_function('LPAD', 3, _sqlite_lpad)\n220         conn.create_function('MOD', 2, none_guard(math.fmod))\n221         conn.create_function('PI', 0, lambda: math.pi)\n222         conn.create_function('POWER', 2, none_guard(operator.pow))\n223         conn.create_function('RADIANS', 1, none_guard(math.radians))\n224         conn.create_function('REPEAT', 2, none_guard(operator.mul))\n225         conn.create_function('REVERSE', 1, none_guard(lambda x: x[::-1]))\n226         conn.create_function('RPAD', 3, _sqlite_rpad)\n227         conn.create_function('SIN', 1, none_guard(math.sin))\n228         conn.create_function('SQRT', 1, none_guard(math.sqrt))\n229         conn.create_function('TAN', 1, none_guard(math.tan))\n230         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))\n231         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))\n232         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))\n233         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))\n234         conn.execute('PRAGMA foreign_keys = ON')\n235         return conn\n",
        "intended_behavior": "Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection."
    },
    {
        "rel_file_path": "django/db/backends/oracle/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/oracle/base.py",
        "start": 224,
        "end": 230,
        "class_name": "DatabaseWrapper",
        "method_name": "get_new_connection",
        "code": "224     def get_new_connection(self, conn_params):\n225         return Database.connect(\n226             user=self.settings_dict['USER'],\n227             password=self.settings_dict['PASSWORD'],\n228             dsn=self._dsn(),\n229             **conn_params,\n230         )\n",
        "intended_behavior": "Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection."
    },
    {
        "rel_file_path": "django/db/backends/postgresql/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/postgresql/base.py",
        "start": 177,
        "end": 195,
        "class_name": "DatabaseWrapper",
        "method_name": "get_new_connection",
        "code": "177     def get_new_connection(self, conn_params):\n178         connection = Database.connect(**conn_params)\n179 \n180         # self.isolation_level must be set:\n181         # - after connecting to the database in order to obtain the database's\n182         #   default when no value is explicitly specified in options.\n183         # - before calling _set_autocommit() because if autocommit is on, that\n184         #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.\n185         options = self.settings_dict['OPTIONS']\n186         try:\n187             self.isolation_level = options['isolation_level']\n188         except KeyError:\n189             self.isolation_level = connection.isolation_level\n190         else:\n191             # Set the isolation level to the value from OPTIONS.\n192             if self.isolation_level != connection.isolation_level:\n193                 connection.set_session(isolation_level=self.isolation_level)\n194 \n195         return connection\n",
        "intended_behavior": "Within the `get_new_connection` method, after establishing the connection to the SQLite database, the method should execute a `PRAGMA user_version;` command to retrieve the SQLite version. Depending on the version, if it's lower than 3.25.0, the method should set a feature flag indicating that window functions are not supported. This could be managed by setting an attribute within the `DatabaseFeatures` class instance associated with the connection."
    },
    {
        "rel_file_path": "django/db/backends/sqlite3/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/sqlite3/base.py",
        "start": 77,
        "end": 367,
        "class_name": "DatabaseWrapper",
        "method_name": null,
        "code": "77 class DatabaseWrapper(BaseDatabaseWrapper):\n78     vendor = 'sqlite'\n79     display_name = 'SQLite'\n80     # SQLite doesn't actually support most of these types, but it \"does the right\n81     # thing\" given more verbose field definitions, so leave them as is so that\n82     # schema inspection is more useful.\n83     data_types = {\n84         'AutoField': 'integer',\n85         'BigAutoField': 'integer',\n86         'BinaryField': 'BLOB',\n87         'BooleanField': 'bool',\n88         'CharField': 'varchar(%(max_length)s)',\n89         'DateField': 'date',\n90         'DateTimeField': 'datetime',\n91         'DecimalField': 'decimal',\n92         'DurationField': 'bigint',\n93         'FileField': 'varchar(%(max_length)s)',\n94         'FilePathField': 'varchar(%(max_length)s)',\n95         'FloatField': 'real',\n96         'IntegerField': 'integer',\n97         'BigIntegerField': 'bigint',\n98         'IPAddressField': 'char(15)',\n99         'GenericIPAddressField': 'char(39)',\n100         'NullBooleanField': 'bool',\n101         'OneToOneField': 'integer',\n102         'PositiveIntegerField': 'integer unsigned',\n103         'PositiveSmallIntegerField': 'smallint unsigned',\n104         'SlugField': 'varchar(%(max_length)s)',\n105         'SmallIntegerField': 'smallint',\n106         'TextField': 'text',\n107         'TimeField': 'time',\n108         'UUIDField': 'char(32)',\n109     }\n110     data_type_check_constraints = {\n111         'PositiveIntegerField': '\"%(column)s\" >= 0',\n112         'PositiveSmallIntegerField': '\"%(column)s\" >= 0',\n113     }\n114     data_types_suffix = {\n115         'AutoField': 'AUTOINCREMENT',\n116         'BigAutoField': 'AUTOINCREMENT',\n117     }\n118     # SQLite requires LIKE statements to include an ESCAPE clause if the value\n119     # being escaped has a percent or underscore in it.\n120     # See https://www.sqlite.org/lang_expr.html for an explanation.\n121     operators = {\n122         'exact': '= %s',\n123         'iexact': \"LIKE %s ESCAPE '\\\\'\",\n124         'contains': \"LIKE %s ESCAPE '\\\\'\",\n125         'icontains': \"LIKE %s ESCAPE '\\\\'\",\n126         'regex': 'REGEXP %s',\n127         'iregex': \"REGEXP '(?i)' || %s\",\n128         'gt': '> %s',\n129         'gte': '>= %s',\n130         'lt': '< %s',\n131         'lte': '<= %s',\n132         'startswith': \"LIKE %s ESCAPE '\\\\'\",\n133         'endswith': \"LIKE %s ESCAPE '\\\\'\",\n134         'istartswith': \"LIKE %s ESCAPE '\\\\'\",\n135         'iendswith': \"LIKE %s ESCAPE '\\\\'\",\n136     }\n137 \n138     # The patterns below are used to generate SQL pattern lookup clauses when\n139     # the right-hand side of the lookup isn't a raw string (it might be an expression\n140     # or the result of a bilateral transformation).\n141     # In those cases, special characters for LIKE operators (e.g. \\, *, _) should be\n142     # escaped on database side.\n143     #\n144     # Note: we use str.format() here for readability as '%' is used as a wildcard for\n145     # the LIKE operator.\n146     pattern_esc = r\"REPLACE(REPLACE(REPLACE({}, '\\', '\\\\'), '%%', '\\%%'), '_', '\\_')\"\n147     pattern_ops = {\n148         'contains': r\"LIKE '%%' || {} || '%%' ESCAPE '\\'\",\n149         'icontains': r\"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\\'\",\n150         'startswith': r\"LIKE {} || '%%' ESCAPE '\\'\",\n151         'istartswith': r\"LIKE UPPER({}) || '%%' ESCAPE '\\'\",\n152         'endswith': r\"LIKE '%%' || {} ESCAPE '\\'\",\n153         'iendswith': r\"LIKE '%%' || UPPER({}) ESCAPE '\\'\",\n154     }\n155 \n156     Database = Database\n157     SchemaEditorClass = DatabaseSchemaEditor\n158     # Classes instantiated in __init__().\n159     client_class = DatabaseClient\n160     creation_class = DatabaseCreation\n161     features_class = DatabaseFeatures\n162     introspection_class = DatabaseIntrospection\n163     ops_class = DatabaseOperations\n164 \n165     def get_connection_params(self):\n166         settings_dict = self.settings_dict\n167         if not settings_dict['NAME']:\n168             raise ImproperlyConfigured(\n169                 \"settings.DATABASES is improperly configured. \"\n170                 \"Please supply the NAME value.\")\n171         kwargs = {\n172             'database': settings_dict['NAME'],\n173             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,\n174             **settings_dict['OPTIONS'],\n175         }\n176         # Always allow the underlying SQLite connection to be shareable\n177         # between multiple threads. The safe-guarding will be handled at a\n178         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`\n179         # property. This is necessary as the shareability is disabled by\n180         # default in pysqlite and it cannot be changed once a connection is\n181         # opened.\n182         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:\n183             warnings.warn(\n184                 'The `check_same_thread` option was provided and set to '\n185                 'True. It will be overridden with False. Use the '\n186                 '`DatabaseWrapper.allow_thread_sharing` property instead '\n187                 'for controlling thread shareability.',\n188                 RuntimeWarning\n189             )\n190         kwargs.update({'check_same_thread': False, 'uri': True})\n191         return kwargs\n192 \n193     def get_new_connection(self, conn_params):\n194         conn = Database.connect(**conn_params)\n195         conn.create_function(\"django_date_extract\", 2, _sqlite_datetime_extract)\n196         conn.create_function(\"django_date_trunc\", 2, _sqlite_date_trunc)\n197         conn.create_function(\"django_datetime_cast_date\", 2, _sqlite_datetime_cast_date)\n198         conn.create_function(\"django_datetime_cast_time\", 2, _sqlite_datetime_cast_time)\n199         conn.create_function(\"django_datetime_extract\", 3, _sqlite_datetime_extract)\n200         conn.create_function(\"django_datetime_trunc\", 3, _sqlite_datetime_trunc)\n201         conn.create_function(\"django_time_extract\", 2, _sqlite_time_extract)\n202         conn.create_function(\"django_time_trunc\", 2, _sqlite_time_trunc)\n203         conn.create_function(\"django_time_diff\", 2, _sqlite_time_diff)\n204         conn.create_function(\"django_timestamp_diff\", 2, _sqlite_timestamp_diff)\n205         conn.create_function(\"django_format_dtdelta\", 3, _sqlite_format_dtdelta)\n206         conn.create_function('regexp', 2, _sqlite_regexp)\n207         conn.create_function('ACOS', 1, none_guard(math.acos))\n208         conn.create_function('ASIN', 1, none_guard(math.asin))\n209         conn.create_function('ATAN', 1, none_guard(math.atan))\n210         conn.create_function('ATAN2', 2, none_guard(math.atan2))\n211         conn.create_function('CEILING', 1, none_guard(math.ceil))\n212         conn.create_function('COS', 1, none_guard(math.cos))\n213         conn.create_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))\n214         conn.create_function('DEGREES', 1, none_guard(math.degrees))\n215         conn.create_function('EXP', 1, none_guard(math.exp))\n216         conn.create_function('FLOOR', 1, none_guard(math.floor))\n217         conn.create_function('LN', 1, none_guard(math.log))\n218         conn.create_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))\n219         conn.create_function('LPAD', 3, _sqlite_lpad)\n220         conn.create_function('MOD', 2, none_guard(math.fmod))\n221         conn.create_function('PI', 0, lambda: math.pi)\n222         conn.create_function('POWER', 2, none_guard(operator.pow))\n223         conn.create_function('RADIANS', 1, none_guard(math.radians))\n224         conn.create_function('REPEAT', 2, none_guard(operator.mul))\n225         conn.create_function('REVERSE', 1, none_guard(lambda x: x[::-1]))\n226         conn.create_function('RPAD', 3, _sqlite_rpad)\n227         conn.create_function('SIN', 1, none_guard(math.sin))\n228         conn.create_function('SQRT', 1, none_guard(math.sqrt))\n229         conn.create_function('TAN', 1, none_guard(math.tan))\n230         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))\n231         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))\n232         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))\n233         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))\n234         conn.execute('PRAGMA foreign_keys = ON')\n235         return conn\n236 \n237     def init_connection_state(self):\n238         pass\n239 \n240     def create_cursor(self, name=None):\n241         return self.connection.cursor(factory=SQLiteCursorWrapper)\n242 \n243     def close(self):\n244         self.validate_thread_sharing()\n245         # If database is in memory, closing the connection destroys the\n246         # database. To prevent accidental data loss, ignore close requests on\n247         # an in-memory db.\n248         if not self.is_in_memory_db():\n249             BaseDatabaseWrapper.close(self)\n250 \n251     def _savepoint_allowed(self):\n252         # When 'isolation_level' is not None, sqlite3 commits before each\n253         # savepoint; it's a bug. When it is None, savepoints don't make sense\n254         # because autocommit is enabled. The only exception is inside 'atomic'\n255         # blocks. To work around that bug, on SQLite, 'atomic' starts a\n256         # transaction explicitly rather than simply disable autocommit.\n257         return self.in_atomic_block\n258 \n259     def _set_autocommit(self, autocommit):\n260         if autocommit:\n261             level = None\n262         else:\n263             # sqlite3's internal default is ''. It's different from None.\n264             # See Modules/_sqlite/connection.c.\n265             level = ''\n266         # 'isolation_level' is a misleading API.\n267         # SQLite always runs at the SERIALIZABLE isolation level.\n268         with self.wrap_database_errors:\n269             self.connection.isolation_level = level\n270 \n271     def disable_constraint_checking(self):\n272         with self.cursor() as cursor:\n273             cursor.execute('PRAGMA foreign_keys = OFF')\n274             # Foreign key constraints cannot be turned off while in a multi-\n275             # statement transaction. Fetch the current state of the pragma\n276             # to determine if constraints are effectively disabled.\n277             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]\n278         return not bool(enabled)\n279 \n280     def enable_constraint_checking(self):\n281         self.cursor().execute('PRAGMA foreign_keys = ON')\n282 \n283     def check_constraints(self, table_names=None):\n284         \"\"\"\n285         Check each table name in `table_names` for rows with invalid foreign\n286         key references. This method is intended to be used in conjunction with\n287         `disable_constraint_checking()` and `enable_constraint_checking()`, to\n288         determine if rows with invalid references were entered while constraint\n289         checks were off.\n290         \"\"\"\n291         if self.features.supports_pragma_foreign_key_check:\n292             with self.cursor() as cursor:\n293                 if table_names is None:\n294                     violations = self.cursor().execute('PRAGMA foreign_key_check').fetchall()\n295                 else:\n296                     violations = chain.from_iterable(\n297                         cursor.execute('PRAGMA foreign_key_check(%s)' % table_name).fetchall()\n298                         for table_name in table_names\n299                     )\n300                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check\n301                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:\n302                     foreign_key = cursor.execute(\n303                         'PRAGMA foreign_key_list(%s)' % table_name\n304                     ).fetchall()[foreign_key_index]\n305                     column_name, referenced_column_name = foreign_key[3:5]\n306                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n307                     primary_key_value, bad_value = cursor.execute(\n308                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (\n309                             primary_key_column_name, column_name, table_name\n310                         ),\n311                         (rowid,),\n312                     ).fetchone()\n313                     raise utils.IntegrityError(\n314                         \"The row in table '%s' with primary key '%s' has an \"\n315                         \"invalid foreign key: %s.%s contains a value '%s' that \"\n316                         \"does not have a corresponding value in %s.%s.\" % (\n317                             table_name, primary_key_value, table_name, column_name,\n318                             bad_value, referenced_table_name, referenced_column_name\n319                         )\n320                     )\n321         else:\n322             with self.cursor() as cursor:\n323                 if table_names is None:\n324                     table_names = self.introspection.table_names(cursor)\n325                 for table_name in table_names:\n326                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)\n327                     if not primary_key_column_name:\n328                         continue\n329                     key_columns = self.introspection.get_key_columns(cursor, table_name)\n330                     for column_name, referenced_table_name, referenced_column_name in key_columns:\n331                         cursor.execute(\n332                             \"\"\"\n333                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING\n334                             LEFT JOIN `%s` as REFERRED\n335                             ON (REFERRING.`%s` = REFERRED.`%s`)\n336                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL\n337                             \"\"\"\n338                             % (\n339                                 primary_key_column_name, column_name, table_name,\n340                                 referenced_table_name, column_name, referenced_column_name,\n341                                 column_name, referenced_column_name,\n342                             )\n343                         )\n344                         for bad_row in cursor.fetchall():\n345                             raise utils.IntegrityError(\n346                                 \"The row in table '%s' with primary key '%s' has an \"\n347                                 \"invalid foreign key: %s.%s contains a value '%s' that \"\n348                                 \"does not have a corresponding value in %s.%s.\" % (\n349                                     table_name, bad_row[0], table_name, column_name,\n350                                     bad_row[1], referenced_table_name, referenced_column_name,\n351                                 )\n352                             )\n353 \n354     def is_usable(self):\n355         return True\n356 \n357     def _start_transaction_under_autocommit(self):\n358         \"\"\"\n359         Start a transaction explicitly in autocommit mode.\n360 \n361         Staying in autocommit mode works around a bug of sqlite3 that breaks\n362         savepoints when autocommit is disabled.\n363         \"\"\"\n364         self.cursor().execute(\"BEGIN\")\n365 \n366     def is_in_memory_db(self):\n367         return self.creation.is_in_memory_db(self.settings_dict['NAME'])\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/backends/oracle/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/oracle/base.py",
        "start": 93,
        "end": 312,
        "class_name": "DatabaseWrapper",
        "method_name": null,
        "code": "93 class DatabaseWrapper(BaseDatabaseWrapper):\n94     vendor = 'oracle'\n95     display_name = 'Oracle'\n96     # This dictionary maps Field objects to their associated Oracle column\n97     # types, as strings. Column-type strings can contain format strings; they'll\n98     # be interpolated against the values of Field.__dict__ before being output.\n99     # If a column type is set to None, it won't be included in the output.\n100     #\n101     # Any format strings starting with \"qn_\" are quoted before being used in the\n102     # output (the \"qn_\" prefix is stripped before the lookup is performed.\n103     data_types = {\n104         'AutoField': 'NUMBER(11) GENERATED BY DEFAULT ON NULL AS IDENTITY',\n105         'BigAutoField': 'NUMBER(19) GENERATED BY DEFAULT ON NULL AS IDENTITY',\n106         'BinaryField': 'BLOB',\n107         'BooleanField': 'NUMBER(1)',\n108         'CharField': 'NVARCHAR2(%(max_length)s)',\n109         'DateField': 'DATE',\n110         'DateTimeField': 'TIMESTAMP',\n111         'DecimalField': 'NUMBER(%(max_digits)s, %(decimal_places)s)',\n112         'DurationField': 'INTERVAL DAY(9) TO SECOND(6)',\n113         'FileField': 'NVARCHAR2(%(max_length)s)',\n114         'FilePathField': 'NVARCHAR2(%(max_length)s)',\n115         'FloatField': 'DOUBLE PRECISION',\n116         'IntegerField': 'NUMBER(11)',\n117         'BigIntegerField': 'NUMBER(19)',\n118         'IPAddressField': 'VARCHAR2(15)',\n119         'GenericIPAddressField': 'VARCHAR2(39)',\n120         'NullBooleanField': 'NUMBER(1)',\n121         'OneToOneField': 'NUMBER(11)',\n122         'PositiveIntegerField': 'NUMBER(11)',\n123         'PositiveSmallIntegerField': 'NUMBER(11)',\n124         'SlugField': 'NVARCHAR2(%(max_length)s)',\n125         'SmallIntegerField': 'NUMBER(11)',\n126         'TextField': 'NCLOB',\n127         'TimeField': 'TIMESTAMP',\n128         'URLField': 'VARCHAR2(%(max_length)s)',\n129         'UUIDField': 'VARCHAR2(32)',\n130     }\n131     data_type_check_constraints = {\n132         'BooleanField': '%(qn_column)s IN (0,1)',\n133         'NullBooleanField': '%(qn_column)s IN (0,1)',\n134         'PositiveIntegerField': '%(qn_column)s >= 0',\n135         'PositiveSmallIntegerField': '%(qn_column)s >= 0',\n136     }\n137 \n138     # Oracle doesn't support a database index on these columns.\n139     _limited_data_types = ('clob', 'nclob', 'blob')\n140 \n141     operators = _UninitializedOperatorsDescriptor()\n142 \n143     _standard_operators = {\n144         'exact': '= %s',\n145         'iexact': '= UPPER(%s)',\n146         'contains': \"LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\\\' USING NCHAR_CS)\",\n147         'icontains': \"LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\\\' USING NCHAR_CS)\",\n148         'gt': '> %s',\n149         'gte': '>= %s',\n150         'lt': '< %s',\n151         'lte': '<= %s',\n152         'startswith': \"LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\\\' USING NCHAR_CS)\",\n153         'endswith': \"LIKE TRANSLATE(%s USING NCHAR_CS) ESCAPE TRANSLATE('\\\\' USING NCHAR_CS)\",\n154         'istartswith': \"LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\\\' USING NCHAR_CS)\",\n155         'iendswith': \"LIKE UPPER(TRANSLATE(%s USING NCHAR_CS)) ESCAPE TRANSLATE('\\\\' USING NCHAR_CS)\",\n156     }\n157 \n158     _likec_operators = {\n159         **_standard_operators,\n160         'contains': \"LIKEC %s ESCAPE '\\\\'\",\n161         'icontains': \"LIKEC UPPER(%s) ESCAPE '\\\\'\",\n162         'startswith': \"LIKEC %s ESCAPE '\\\\'\",\n163         'endswith': \"LIKEC %s ESCAPE '\\\\'\",\n164         'istartswith': \"LIKEC UPPER(%s) ESCAPE '\\\\'\",\n165         'iendswith': \"LIKEC UPPER(%s) ESCAPE '\\\\'\",\n166     }\n167 \n168     # The patterns below are used to generate SQL pattern lookup clauses when\n169     # the right-hand side of the lookup isn't a raw string (it might be an expression\n170     # or the result of a bilateral transformation).\n171     # In those cases, special characters for LIKE operators (e.g. \\, %, _)\n172     # should be escaped on the database side.\n173     #\n174     # Note: we use str.format() here for readability as '%' is used as a wildcard for\n175     # the LIKE operator.\n176     pattern_esc = r\"REPLACE(REPLACE(REPLACE({}, '\\', '\\\\'), '%%', '\\%%'), '_', '\\_')\"\n177     _pattern_ops = {\n178         'contains': \"'%%' || {} || '%%'\",\n179         'icontains': \"'%%' || UPPER({}) || '%%'\",\n180         'startswith': \"{} || '%%'\",\n181         'istartswith': \"UPPER({}) || '%%'\",\n182         'endswith': \"'%%' || {}\",\n183         'iendswith': \"'%%' || UPPER({})\",\n184     }\n185 \n186     _standard_pattern_ops = {k: \"LIKE TRANSLATE( \" + v + \" USING NCHAR_CS)\"\n187                                 \" ESCAPE TRANSLATE('\\\\' USING NCHAR_CS)\"\n188                              for k, v in _pattern_ops.items()}\n189     _likec_pattern_ops = {k: \"LIKEC \" + v + \" ESCAPE '\\\\'\"\n190                           for k, v in _pattern_ops.items()}\n191 \n192     Database = Database\n193     SchemaEditorClass = DatabaseSchemaEditor\n194     # Classes instantiated in __init__().\n195     client_class = DatabaseClient\n196     creation_class = DatabaseCreation\n197     features_class = DatabaseFeatures\n198     introspection_class = DatabaseIntrospection\n199     ops_class = DatabaseOperations\n200     validation_class = DatabaseValidation\n201 \n202     def __init__(self, *args, **kwargs):\n203         super().__init__(*args, **kwargs)\n204         use_returning_into = self.settings_dict[\"OPTIONS\"].get('use_returning_into', True)\n205         self.features.can_return_columns_from_insert = use_returning_into\n206 \n207     def _dsn(self):\n208         settings_dict = self.settings_dict\n209         if not settings_dict['HOST'].strip():\n210             settings_dict['HOST'] = 'localhost'\n211         if settings_dict['PORT']:\n212             return Database.makedsn(settings_dict['HOST'], int(settings_dict['PORT']), settings_dict['NAME'])\n213         return settings_dict['NAME']\n214 \n215     def _connect_string(self):\n216         return '%s/\\\\\"%s\\\\\"@%s' % (self.settings_dict['USER'], self.settings_dict['PASSWORD'], self._dsn())\n217 \n218     def get_connection_params(self):\n219         conn_params = self.settings_dict['OPTIONS'].copy()\n220         if 'use_returning_into' in conn_params:\n221             del conn_params['use_returning_into']\n222         return conn_params\n223 \n224     def get_new_connection(self, conn_params):\n225         return Database.connect(\n226             user=self.settings_dict['USER'],\n227             password=self.settings_dict['PASSWORD'],\n228             dsn=self._dsn(),\n229             **conn_params,\n230         )\n231 \n232     def init_connection_state(self):\n233         cursor = self.create_cursor()\n234         # Set the territory first. The territory overrides NLS_DATE_FORMAT\n235         # and NLS_TIMESTAMP_FORMAT to the territory default. When all of\n236         # these are set in single statement it isn't clear what is supposed\n237         # to happen.\n238         cursor.execute(\"ALTER SESSION SET NLS_TERRITORY = 'AMERICA'\")\n239         # Set Oracle date to ANSI date format.  This only needs to execute\n240         # once when we create a new connection. We also set the Territory\n241         # to 'AMERICA' which forces Sunday to evaluate to a '1' in\n242         # TO_CHAR().\n243         cursor.execute(\n244             \"ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS'\"\n245             \" NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS.FF'\" +\n246             (\" TIME_ZONE = 'UTC'\" if settings.USE_TZ else '')\n247         )\n248         cursor.close()\n249         if 'operators' not in self.__dict__:\n250             # Ticket #14149: Check whether our LIKE implementation will\n251             # work for this connection or we need to fall back on LIKEC.\n252             # This check is performed only once per DatabaseWrapper\n253             # instance per thread, since subsequent connections will use\n254             # the same settings.\n255             cursor = self.create_cursor()\n256             try:\n257                 cursor.execute(\"SELECT 1 FROM DUAL WHERE DUMMY %s\"\n258                                % self._standard_operators['contains'],\n259                                ['X'])\n260             except Database.DatabaseError:\n261                 self.operators = self._likec_operators\n262                 self.pattern_ops = self._likec_pattern_ops\n263             else:\n264                 self.operators = self._standard_operators\n265                 self.pattern_ops = self._standard_pattern_ops\n266             cursor.close()\n267         self.connection.stmtcachesize = 20\n268         # Ensure all changes are preserved even when AUTOCOMMIT is False.\n269         if not self.get_autocommit():\n270             self.commit()\n271 \n272     def create_cursor(self, name=None):\n273         return FormatStylePlaceholderCursor(self.connection)\n274 \n275     def _commit(self):\n276         if self.connection is not None:\n277             with wrap_oracle_errors():\n278                 return self.connection.commit()\n279 \n280     # Oracle doesn't support releasing savepoints. But we fake them when query\n281     # logging is enabled to keep query counts consistent with other backends.\n282     def _savepoint_commit(self, sid):\n283         if self.queries_logged:\n284             self.queries_log.append({\n285                 'sql': '-- RELEASE SAVEPOINT %s (faked)' % self.ops.quote_name(sid),\n286                 'time': '0.000',\n287             })\n288 \n289     def _set_autocommit(self, autocommit):\n290         with self.wrap_database_errors:\n291             self.connection.autocommit = autocommit\n292 \n293     def check_constraints(self, table_names=None):\n294         \"\"\"\n295         Check constraints by setting them to immediate. Return them to deferred\n296         afterward.\n297         \"\"\"\n298         self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n299         self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n300 \n301     def is_usable(self):\n302         try:\n303             self.connection.ping()\n304         except Database.Error:\n305             return False\n306         else:\n307             return True\n308 \n309     @cached_property\n310     def oracle_version(self):\n311         with self.temporary_connection():\n312             return tuple(int(x) for x in self.connection.version.split('.'))\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/backends/postgresql/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/postgresql/base.py",
        "start": 61,
        "end": 287,
        "class_name": "DatabaseWrapper",
        "method_name": null,
        "code": "61 class DatabaseWrapper(BaseDatabaseWrapper):\n62     vendor = 'postgresql'\n63     display_name = 'PostgreSQL'\n64     # This dictionary maps Field objects to their associated PostgreSQL column\n65     # types, as strings. Column-type strings can contain format strings; they'll\n66     # be interpolated against the values of Field.__dict__ before being output.\n67     # If a column type is set to None, it won't be included in the output.\n68     data_types = {\n69         'AutoField': 'serial',\n70         'BigAutoField': 'bigserial',\n71         'BinaryField': 'bytea',\n72         'BooleanField': 'boolean',\n73         'CharField': 'varchar(%(max_length)s)',\n74         'DateField': 'date',\n75         'DateTimeField': 'timestamp with time zone',\n76         'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)',\n77         'DurationField': 'interval',\n78         'FileField': 'varchar(%(max_length)s)',\n79         'FilePathField': 'varchar(%(max_length)s)',\n80         'FloatField': 'double precision',\n81         'IntegerField': 'integer',\n82         'BigIntegerField': 'bigint',\n83         'IPAddressField': 'inet',\n84         'GenericIPAddressField': 'inet',\n85         'NullBooleanField': 'boolean',\n86         'OneToOneField': 'integer',\n87         'PositiveIntegerField': 'integer',\n88         'PositiveSmallIntegerField': 'smallint',\n89         'SlugField': 'varchar(%(max_length)s)',\n90         'SmallIntegerField': 'smallint',\n91         'TextField': 'text',\n92         'TimeField': 'time',\n93         'UUIDField': 'uuid',\n94     }\n95     data_type_check_constraints = {\n96         'PositiveIntegerField': '\"%(column)s\" >= 0',\n97         'PositiveSmallIntegerField': '\"%(column)s\" >= 0',\n98     }\n99     operators = {\n100         'exact': '= %s',\n101         'iexact': '= UPPER(%s)',\n102         'contains': 'LIKE %s',\n103         'icontains': 'LIKE UPPER(%s)',\n104         'regex': '~ %s',\n105         'iregex': '~* %s',\n106         'gt': '> %s',\n107         'gte': '>= %s',\n108         'lt': '< %s',\n109         'lte': '<= %s',\n110         'startswith': 'LIKE %s',\n111         'endswith': 'LIKE %s',\n112         'istartswith': 'LIKE UPPER(%s)',\n113         'iendswith': 'LIKE UPPER(%s)',\n114     }\n115 \n116     # The patterns below are used to generate SQL pattern lookup clauses when\n117     # the right-hand side of the lookup isn't a raw string (it might be an expression\n118     # or the result of a bilateral transformation).\n119     # In those cases, special characters for LIKE operators (e.g. \\, *, _) should be\n120     # escaped on database side.\n121     #\n122     # Note: we use str.format() here for readability as '%' is used as a wildcard for\n123     # the LIKE operator.\n124     pattern_esc = r\"REPLACE(REPLACE(REPLACE({}, E'\\\\', E'\\\\\\\\'), E'%%', E'\\\\%%'), E'_', E'\\\\_')\"\n125     pattern_ops = {\n126         'contains': \"LIKE '%%' || {} || '%%'\",\n127         'icontains': \"LIKE '%%' || UPPER({}) || '%%'\",\n128         'startswith': \"LIKE {} || '%%'\",\n129         'istartswith': \"LIKE UPPER({}) || '%%'\",\n130         'endswith': \"LIKE '%%' || {}\",\n131         'iendswith': \"LIKE '%%' || UPPER({})\",\n132     }\n133 \n134     Database = Database\n135     SchemaEditorClass = DatabaseSchemaEditor\n136     # Classes instantiated in __init__().\n137     client_class = DatabaseClient\n138     creation_class = DatabaseCreation\n139     features_class = DatabaseFeatures\n140     introspection_class = DatabaseIntrospection\n141     ops_class = DatabaseOperations\n142     # PostgreSQL backend-specific attributes.\n143     _named_cursor_idx = 0\n144 \n145     def get_connection_params(self):\n146         settings_dict = self.settings_dict\n147         # None may be used to connect to the default 'postgres' db\n148         if settings_dict['NAME'] == '':\n149             raise ImproperlyConfigured(\n150                 \"settings.DATABASES is improperly configured. \"\n151                 \"Please supply the NAME value.\")\n152         if len(settings_dict['NAME'] or '') > self.ops.max_name_length():\n153             raise ImproperlyConfigured(\n154                 \"The database name '%s' (%d characters) is longer than \"\n155                 \"PostgreSQL's limit of %d characters. Supply a shorter NAME \"\n156                 \"in settings.DATABASES.\" % (\n157                     settings_dict['NAME'],\n158                     len(settings_dict['NAME']),\n159                     self.ops.max_name_length(),\n160                 )\n161             )\n162         conn_params = {\n163             'database': settings_dict['NAME'] or 'postgres',\n164             **settings_dict['OPTIONS'],\n165         }\n166         conn_params.pop('isolation_level', None)\n167         if settings_dict['USER']:\n168             conn_params['user'] = settings_dict['USER']\n169         if settings_dict['PASSWORD']:\n170             conn_params['password'] = settings_dict['PASSWORD']\n171         if settings_dict['HOST']:\n172             conn_params['host'] = settings_dict['HOST']\n173         if settings_dict['PORT']:\n174             conn_params['port'] = settings_dict['PORT']\n175         return conn_params\n176 \n177     def get_new_connection(self, conn_params):\n178         connection = Database.connect(**conn_params)\n179 \n180         # self.isolation_level must be set:\n181         # - after connecting to the database in order to obtain the database's\n182         #   default when no value is explicitly specified in options.\n183         # - before calling _set_autocommit() because if autocommit is on, that\n184         #   will set connection.isolation_level to ISOLATION_LEVEL_AUTOCOMMIT.\n185         options = self.settings_dict['OPTIONS']\n186         try:\n187             self.isolation_level = options['isolation_level']\n188         except KeyError:\n189             self.isolation_level = connection.isolation_level\n190         else:\n191             # Set the isolation level to the value from OPTIONS.\n192             if self.isolation_level != connection.isolation_level:\n193                 connection.set_session(isolation_level=self.isolation_level)\n194 \n195         return connection\n196 \n197     def ensure_timezone(self):\n198         if not self.is_usable():\n199             return False\n200         conn_timezone_name = self.connection.get_parameter_status('TimeZone')\n201         timezone_name = self.timezone_name\n202         if timezone_name and conn_timezone_name != timezone_name:\n203             with self.connection.cursor() as cursor:\n204                 cursor.execute(self.ops.set_time_zone_sql(), [timezone_name])\n205             return True\n206         return False\n207 \n208     def init_connection_state(self):\n209         self.connection.set_client_encoding('UTF8')\n210 \n211         self.ensure_connection()\n212         timezone_changed = self.ensure_timezone()\n213         if timezone_changed:\n214             # Commit after setting the time zone (see #17062)\n215             if not self.get_autocommit():\n216                 self.connection.commit()\n217 \n218     def create_cursor(self, name=None):\n219         if name:\n220             # In autocommit mode, the cursor will be used outside of a\n221             # transaction, hence use a holdable cursor.\n222             cursor = self.connection.cursor(name, scrollable=False, withhold=self.connection.autocommit)\n223         else:\n224             cursor = self.connection.cursor()\n225         cursor.tzinfo_factory = utc_tzinfo_factory if settings.USE_TZ else None\n226         return cursor\n227 \n228     def chunked_cursor(self):\n229         self._named_cursor_idx += 1\n230         return self._cursor(\n231             name='_django_curs_%d_%d' % (\n232                 # Avoid reusing name in other threads\n233                 threading.current_thread().ident,\n234                 self._named_cursor_idx,\n235             )\n236         )\n237 \n238     def _set_autocommit(self, autocommit):\n239         with self.wrap_database_errors:\n240             self.connection.autocommit = autocommit\n241 \n242     def check_constraints(self, table_names=None):\n243         \"\"\"\n244         Check constraints by setting them to immediate. Return them to deferred\n245         afterward.\n246         \"\"\"\n247         self.cursor().execute('SET CONSTRAINTS ALL IMMEDIATE')\n248         self.cursor().execute('SET CONSTRAINTS ALL DEFERRED')\n249 \n250     def is_usable(self):\n251         if self.connection is None:\n252             return False\n253         try:\n254             # Use a psycopg cursor directly, bypassing Django's utilities.\n255             self.connection.cursor().execute(\"SELECT 1\")\n256         except Database.Error:\n257             return False\n258         else:\n259             return True\n260 \n261     @property\n262     def _nodb_connection(self):\n263         nodb_connection = super()._nodb_connection\n264         try:\n265             nodb_connection.ensure_connection()\n266         except (Database.DatabaseError, WrappedDatabaseError):\n267             warnings.warn(\n268                 \"Normally Django will use a connection to the 'postgres' database \"\n269                 \"to avoid running initialization queries against the production \"\n270                 \"database when it's not needed (for example, when running tests). \"\n271                 \"Django was unable to create a connection to the 'postgres' database \"\n272                 \"and will use the first PostgreSQL database instead.\",\n273                 RuntimeWarning\n274             )\n275             for connection in connections.all():\n276                 if connection.vendor == 'postgresql' and connection.settings_dict['NAME'] != 'postgres':\n277                     return self.__class__(\n278                         {**self.settings_dict, 'NAME': connection.settings_dict['NAME']},\n279                         alias=self.alias,\n280                         allow_thread_sharing=False,\n281                     )\n282         return nodb_connection\n283 \n284     @cached_property\n285     def pg_version(self):\n286         with self.temporary_connection():\n287             return self.connection.server_version\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/backends/sqlite3/features.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/sqlite3/features.py",
        "start": 6,
        "end": 42,
        "class_name": "DatabaseFeatures",
        "method_name": null,
        "code": "6 class DatabaseFeatures(BaseDatabaseFeatures):\n7     # SQLite can read from a cursor since SQLite 3.6.5, subject to the caveat\n8     # that statements within a connection aren't isolated from each other. See\n9     # https://sqlite.org/isolation.html.\n10     can_use_chunked_reads = True\n11     test_db_allows_multiple_connections = False\n12     supports_unspecified_pk = True\n13     supports_timezones = False\n14     max_query_params = 999\n15     supports_mixed_date_datetime_comparisons = False\n16     can_introspect_autofield = True\n17     can_introspect_decimal_field = False\n18     can_introspect_duration_field = False\n19     can_introspect_positive_integer_field = True\n20     can_introspect_small_integer_field = True\n21     introspected_big_auto_field_type = 'AutoField'\n22     supports_transactions = True\n23     atomic_transactions = False\n24     can_rollback_ddl = True\n25     supports_atomic_references_rename = Database.sqlite_version_info >= (3, 26, 0)\n26     can_create_inline_fk = False\n27     supports_paramstyle_pyformat = False\n28     supports_sequence_reset = False\n29     can_clone_databases = True\n30     supports_temporal_subtraction = True\n31     ignores_table_name_case = True\n32     supports_cast_with_precision = False\n33     time_cast_precision = 3\n34     can_release_savepoints = True\n35     # Is \"ALTER TABLE ... RENAME COLUMN\" supported?\n36     can_alter_table_rename_column = Database.sqlite_version_info >= (3, 25, 0)\n37     supports_parentheses_in_compound = False\n38     # Deferred constraint checks can be emulated on SQLite < 3.20 but not in a\n39     # reasonably performant way.\n40     supports_pragma_foreign_key_check = Database.sqlite_version_info >= (3, 20, 0)\n41     can_defer_constraint_checks = supports_pragma_foreign_key_check\n42     supports_functions_in_partial_indexes = Database.sqlite_version_info >= (3, 15, 0)\n",
        "intended_behavior": "Add a new attribute e.g., `supports_window_functions` within the `DatabaseFeatures` class. This attribute should dynamically reflect whether the connected SQLite database supports window functions based on the SQLite version determined at connection time. This feature flag should be used throughout Django's ORM layer to conditionally allow or disallow window function usage, presenting a clear and informative error when such usage is attempted on unsupported versions."
    },
    {
        "rel_file_path": "django/db/backends/oracle/features.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/db/backends/oracle/features.py",
        "start": 5,
        "end": 58,
        "class_name": "DatabaseFeatures",
        "method_name": null,
        "code": "5 class DatabaseFeatures(BaseDatabaseFeatures):\n6     interprets_empty_strings_as_nulls = True\n7     has_select_for_update = True\n8     has_select_for_update_nowait = True\n9     has_select_for_update_skip_locked = True\n10     has_select_for_update_of = True\n11     select_for_update_of_column = True\n12     can_return_columns_from_insert = True\n13     can_introspect_autofield = True\n14     supports_subqueries_in_group_by = False\n15     supports_transactions = True\n16     supports_timezones = False\n17     has_native_duration_field = True\n18     can_defer_constraint_checks = True\n19     supports_partially_nullable_unique_constraints = False\n20     truncates_names = True\n21     supports_tablespaces = True\n22     supports_sequence_reset = False\n23     can_introspect_materialized_views = True\n24     can_introspect_time_field = False\n25     atomic_transactions = False\n26     supports_combined_alters = False\n27     nulls_order_largest = True\n28     requires_literal_defaults = True\n29     closed_cursor_error_class = InterfaceError\n30     bare_select_suffix = \" FROM DUAL\"\n31     # select for update with limit can be achieved on Oracle, but not with the current backend.\n32     supports_select_for_update_with_limit = False\n33     supports_temporal_subtraction = True\n34     # Oracle doesn't ignore quoted identifiers case but the current backend\n35     # does by uppercasing all identifiers.\n36     ignores_table_name_case = True\n37     supports_index_on_text_field = False\n38     has_case_insensitive_like = False\n39     create_test_procedure_without_params_sql = \"\"\"\n40         CREATE PROCEDURE \"TEST_PROCEDURE\" AS\n41             V_I INTEGER;\n42         BEGIN\n43             V_I := 1;\n44         END;\n45     \"\"\"\n46     create_test_procedure_with_int_param_sql = \"\"\"\n47         CREATE PROCEDURE \"TEST_PROCEDURE\" (P_I INTEGER) AS\n48             V_I INTEGER;\n49         BEGIN\n50             V_I := P_I;\n51         END;\n52     \"\"\"\n53     supports_callproc_kwargs = True\n54     supports_over_clause = True\n55     supports_ignore_conflicts = False\n56     max_query_params = 2**16 - 1\n57     supports_partial_indexes = False\n58     supports_slicing_ordering_in_compound = True\n",
        "intended_behavior": "Add a new attribute e.g., `supports_window_functions` within the `DatabaseFeatures` class. This attribute should dynamically reflect whether the connected SQLite database supports window functions based on the SQLite version determined at connection time. This feature flag should be used throughout Django's ORM layer to conditionally allow or disallow window function usage, presenting a clear and informative error when such usage is attempted on unsupported versions."
    }
]