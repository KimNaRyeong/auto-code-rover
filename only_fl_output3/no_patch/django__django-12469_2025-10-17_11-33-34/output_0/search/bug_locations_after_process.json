[
    {
        "rel_file_path": "django/contrib/admin/filters.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/admin/filters.py",
        "start": 1,
        "end": 474,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 This encapsulates the logic for displaying filters in the Django admin.\n3 Filters are specified in models with the \"list_filter\" option.\n4 \n5 Each filter subclass knows how to display a filter for a field that passes a\n6 certain test -- e.g. being a DateField or ForeignKey.\n7 \"\"\"\n8 import datetime\n9 \n10 from django.contrib.admin.options import IncorrectLookupParameters\n11 from django.contrib.admin.utils import (\n12     get_model_from_relation, prepare_lookup_value, reverse_field_path,\n13 )\n14 from django.core.exceptions import ImproperlyConfigured, ValidationError\n15 from django.db import models\n16 from django.utils import timezone\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 \n20 class ListFilter:\n21     title = None  # Human-readable title to appear in the right sidebar.\n22     template = 'admin/filter.html'\n23 \n24     def __init__(self, request, params, model, model_admin):\n25         # This dictionary will eventually contain the request's query string\n26         # parameters actually used by this filter.\n27         self.used_parameters = {}\n28         if self.title is None:\n29             raise ImproperlyConfigured(\n30                 \"The list filter '%s' does not specify a 'title'.\"\n31                 % self.__class__.__name__\n32             )\n33 \n34     def has_output(self):\n35         \"\"\"\n36         Return True if some choices would be output for this filter.\n37         \"\"\"\n38         raise NotImplementedError('subclasses of ListFilter must provide a has_output() method')\n39 \n40     def choices(self, changelist):\n41         \"\"\"\n42         Return choices ready to be output in the template.\n43 \n44         `changelist` is the ChangeList to be displayed.\n45         \"\"\"\n46         raise NotImplementedError('subclasses of ListFilter must provide a choices() method')\n47 \n48     def queryset(self, request, queryset):\n49         \"\"\"\n50         Return the filtered queryset.\n51         \"\"\"\n52         raise NotImplementedError('subclasses of ListFilter must provide a queryset() method')\n53 \n54     def expected_parameters(self):\n55         \"\"\"\n56         Return the list of parameter names that are expected from the\n57         request's query string and that will be used by this filter.\n58         \"\"\"\n59         raise NotImplementedError('subclasses of ListFilter must provide an expected_parameters() method')\n60 \n61 \n62 class SimpleListFilter(ListFilter):\n63     # The parameter that should be used in the query string for that filter.\n64     parameter_name = None\n65 \n66     def __init__(self, request, params, model, model_admin):\n67         super().__init__(request, params, model, model_admin)\n68         if self.parameter_name is None:\n69             raise ImproperlyConfigured(\n70                 \"The list filter '%s' does not specify a 'parameter_name'.\"\n71                 % self.__class__.__name__\n72             )\n73         if self.parameter_name in params:\n74             value = params.pop(self.parameter_name)\n75             self.used_parameters[self.parameter_name] = value\n76         lookup_choices = self.lookups(request, model_admin)\n77         if lookup_choices is None:\n78             lookup_choices = ()\n79         self.lookup_choices = list(lookup_choices)\n80 \n81     def has_output(self):\n82         return len(self.lookup_choices) > 0\n83 \n84     def value(self):\n85         \"\"\"\n86         Return the value (in string format) provided in the request's\n87         query string for this filter, if any, or None if the value wasn't\n88         provided.\n89         \"\"\"\n90         return self.used_parameters.get(self.parameter_name)\n91 \n92     def lookups(self, request, model_admin):\n93         \"\"\"\n94         Must be overridden to return a list of tuples (value, verbose value)\n95         \"\"\"\n96         raise NotImplementedError(\n97             'The SimpleListFilter.lookups() method must be overridden to '\n98             'return a list of tuples (value, verbose value).'\n99         )\n100 \n101     def expected_parameters(self):\n102         return [self.parameter_name]\n103 \n104     def choices(self, changelist):\n105         yield {\n106             'selected': self.value() is None,\n107             'query_string': changelist.get_query_string(remove=[self.parameter_name]),\n108             'display': _('All'),\n109         }\n110         for lookup, title in self.lookup_choices:\n111             yield {\n112                 'selected': self.value() == str(lookup),\n113                 'query_string': changelist.get_query_string({self.parameter_name: lookup}),\n114                 'display': title,\n115             }\n116 \n117 \n118 class FieldListFilter(ListFilter):\n119     _field_list_filters = []\n120     _take_priority_index = 0\n121 \n122     def __init__(self, field, request, params, model, model_admin, field_path):\n123         self.field = field\n124         self.field_path = field_path\n125         self.title = getattr(field, 'verbose_name', field_path)\n126         super().__init__(request, params, model, model_admin)\n127         for p in self.expected_parameters():\n128             if p in params:\n129                 value = params.pop(p)\n130                 self.used_parameters[p] = prepare_lookup_value(p, value)\n131 \n132     def has_output(self):\n133         return True\n134 \n135     def queryset(self, request, queryset):\n136         try:\n137             return queryset.filter(**self.used_parameters)\n138         except (ValueError, ValidationError) as e:\n139             # Fields may raise a ValueError or ValidationError when converting\n140             # the parameters to the correct type.\n141             raise IncorrectLookupParameters(e)\n142 \n143     @classmethod\n144     def register(cls, test, list_filter_class, take_priority=False):\n145         if take_priority:\n146             # This is to allow overriding the default filters for certain types\n147             # of fields with some custom filters. The first found in the list\n148             # is used in priority.\n149             cls._field_list_filters.insert(\n150                 cls._take_priority_index, (test, list_filter_class))\n151             cls._take_priority_index += 1\n152         else:\n153             cls._field_list_filters.append((test, list_filter_class))\n154 \n155     @classmethod\n156     def create(cls, field, request, params, model, model_admin, field_path):\n157         for test, list_filter_class in cls._field_list_filters:\n158             if test(field):\n159                 return list_filter_class(field, request, params, model, model_admin, field_path=field_path)\n160 \n161 \n162 class RelatedFieldListFilter(FieldListFilter):\n163     def __init__(self, field, request, params, model, model_admin, field_path):\n164         other_model = get_model_from_relation(field)\n165         self.lookup_kwarg = '%s__%s__exact' % (field_path, field.target_field.name)\n166         self.lookup_kwarg_isnull = '%s__isnull' % field_path\n167         self.lookup_val = params.get(self.lookup_kwarg)\n168         self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)\n169         super().__init__(field, request, params, model, model_admin, field_path)\n170         self.lookup_choices = self.field_choices(field, request, model_admin)\n171         if hasattr(field, 'verbose_name'):\n172             self.lookup_title = field.verbose_name\n173         else:\n174             self.lookup_title = other_model._meta.verbose_name\n175         self.title = self.lookup_title\n176         self.empty_value_display = model_admin.get_empty_value_display()\n177 \n178     @property\n179     def include_empty_choice(self):\n180         \"\"\"\n181         Return True if a \"(None)\" choice should be included, which filters\n182         out everything except empty relationships.\n183         \"\"\"\n184         return self.field.null or (self.field.is_relation and self.field.many_to_many)\n185 \n186     def has_output(self):\n187         if self.include_empty_choice:\n188             extra = 1\n189         else:\n190             extra = 0\n191         return len(self.lookup_choices) + extra > 1\n192 \n193     def expected_parameters(self):\n194         return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n195 \n196     def field_admin_ordering(self, field, request, model_admin):\n197         \"\"\"\n198         Return the model admin's ordering for related field, if provided.\n199         \"\"\"\n200         related_admin = model_admin.admin_site._registry.get(field.remote_field.model)\n201         if related_admin is not None:\n202             return related_admin.get_ordering(request)\n203         return ()\n204 \n205     def field_choices(self, field, request, model_admin):\n206         ordering = self.field_admin_ordering(field, request, model_admin)\n207         return field.get_choices(include_blank=False, ordering=ordering)\n208 \n209     def choices(self, changelist):\n210         yield {\n211             'selected': self.lookup_val is None and not self.lookup_val_isnull,\n212             'query_string': changelist.get_query_string(remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]),\n213             'display': _('All'),\n214         }\n215         for pk_val, val in self.lookup_choices:\n216             yield {\n217                 'selected': self.lookup_val == str(pk_val),\n218                 'query_string': changelist.get_query_string({self.lookup_kwarg: pk_val}, [self.lookup_kwarg_isnull]),\n219                 'display': val,\n220             }\n221         if self.include_empty_choice:\n222             yield {\n223                 'selected': bool(self.lookup_val_isnull),\n224                 'query_string': changelist.get_query_string({self.lookup_kwarg_isnull: 'True'}, [self.lookup_kwarg]),\n225                 'display': self.empty_value_display,\n226             }\n227 \n228 \n229 FieldListFilter.register(lambda f: f.remote_field, RelatedFieldListFilter)\n230 \n231 \n232 class BooleanFieldListFilter(FieldListFilter):\n233     def __init__(self, field, request, params, model, model_admin, field_path):\n234         self.lookup_kwarg = '%s__exact' % field_path\n235         self.lookup_kwarg2 = '%s__isnull' % field_path\n236         self.lookup_val = params.get(self.lookup_kwarg)\n237         self.lookup_val2 = params.get(self.lookup_kwarg2)\n238         super().__init__(field, request, params, model, model_admin, field_path)\n239         if (self.used_parameters and self.lookup_kwarg in self.used_parameters and\n240                 self.used_parameters[self.lookup_kwarg] in ('1', '0')):\n241             self.used_parameters[self.lookup_kwarg] = bool(int(self.used_parameters[self.lookup_kwarg]))\n242 \n243     def expected_parameters(self):\n244         return [self.lookup_kwarg, self.lookup_kwarg2]\n245 \n246     def choices(self, changelist):\n247         for lookup, title in (\n248                 (None, _('All')),\n249                 ('1', _('Yes')),\n250                 ('0', _('No'))):\n251             yield {\n252                 'selected': self.lookup_val == lookup and not self.lookup_val2,\n253                 'query_string': changelist.get_query_string({self.lookup_kwarg: lookup}, [self.lookup_kwarg2]),\n254                 'display': title,\n255             }\n256         if self.field.null:\n257             yield {\n258                 'selected': self.lookup_val2 == 'True',\n259                 'query_string': changelist.get_query_string({self.lookup_kwarg2: 'True'}, [self.lookup_kwarg]),\n260                 'display': _('Unknown'),\n261             }\n262 \n263 \n264 FieldListFilter.register(lambda f: isinstance(f, models.BooleanField), BooleanFieldListFilter)\n265 \n266 \n267 class ChoicesFieldListFilter(FieldListFilter):\n268     def __init__(self, field, request, params, model, model_admin, field_path):\n269         self.lookup_kwarg = '%s__exact' % field_path\n270         self.lookup_kwarg_isnull = '%s__isnull' % field_path\n271         self.lookup_val = params.get(self.lookup_kwarg)\n272         self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)\n273         super().__init__(field, request, params, model, model_admin, field_path)\n274 \n275     def expected_parameters(self):\n276         return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n277 \n278     def choices(self, changelist):\n279         yield {\n280             'selected': self.lookup_val is None,\n281             'query_string': changelist.get_query_string(remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]),\n282             'display': _('All')\n283         }\n284         none_title = ''\n285         for lookup, title in self.field.flatchoices:\n286             if lookup is None:\n287                 none_title = title\n288                 continue\n289             yield {\n290                 'selected': str(lookup) == self.lookup_val,\n291                 'query_string': changelist.get_query_string({self.lookup_kwarg: lookup}, [self.lookup_kwarg_isnull]),\n292                 'display': title,\n293             }\n294         if none_title:\n295             yield {\n296                 'selected': bool(self.lookup_val_isnull),\n297                 'query_string': changelist.get_query_string({self.lookup_kwarg_isnull: 'True'}, [self.lookup_kwarg]),\n298                 'display': none_title,\n299             }\n300 \n301 \n302 FieldListFilter.register(lambda f: bool(f.choices), ChoicesFieldListFilter)\n303 \n304 \n305 class DateFieldListFilter(FieldListFilter):\n306     def __init__(self, field, request, params, model, model_admin, field_path):\n307         self.field_generic = '%s__' % field_path\n308         self.date_params = {k: v for k, v in params.items() if k.startswith(self.field_generic)}\n309 \n310         now = timezone.now()\n311         # When time zone support is enabled, convert \"now\" to the user's time\n312         # zone so Django's definition of \"Today\" matches what the user expects.\n313         if timezone.is_aware(now):\n314             now = timezone.localtime(now)\n315 \n316         if isinstance(field, models.DateTimeField):\n317             today = now.replace(hour=0, minute=0, second=0, microsecond=0)\n318         else:       # field is a models.DateField\n319             today = now.date()\n320         tomorrow = today + datetime.timedelta(days=1)\n321         if today.month == 12:\n322             next_month = today.replace(year=today.year + 1, month=1, day=1)\n323         else:\n324             next_month = today.replace(month=today.month + 1, day=1)\n325         next_year = today.replace(year=today.year + 1, month=1, day=1)\n326 \n327         self.lookup_kwarg_since = '%s__gte' % field_path\n328         self.lookup_kwarg_until = '%s__lt' % field_path\n329         self.links = (\n330             (_('Any date'), {}),\n331             (_('Today'), {\n332                 self.lookup_kwarg_since: str(today),\n333                 self.lookup_kwarg_until: str(tomorrow),\n334             }),\n335             (_('Past 7 days'), {\n336                 self.lookup_kwarg_since: str(today - datetime.timedelta(days=7)),\n337                 self.lookup_kwarg_until: str(tomorrow),\n338             }),\n339             (_('This month'), {\n340                 self.lookup_kwarg_since: str(today.replace(day=1)),\n341                 self.lookup_kwarg_until: str(next_month),\n342             }),\n343             (_('This year'), {\n344                 self.lookup_kwarg_since: str(today.replace(month=1, day=1)),\n345                 self.lookup_kwarg_until: str(next_year),\n346             }),\n347         )\n348         if field.null:\n349             self.lookup_kwarg_isnull = '%s__isnull' % field_path\n350             self.links += (\n351                 (_('No date'), {self.field_generic + 'isnull': 'True'}),\n352                 (_('Has date'), {self.field_generic + 'isnull': 'False'}),\n353             )\n354         super().__init__(field, request, params, model, model_admin, field_path)\n355 \n356     def expected_parameters(self):\n357         params = [self.lookup_kwarg_since, self.lookup_kwarg_until]\n358         if self.field.null:\n359             params.append(self.lookup_kwarg_isnull)\n360         return params\n361 \n362     def choices(self, changelist):\n363         for title, param_dict in self.links:\n364             yield {\n365                 'selected': self.date_params == param_dict,\n366                 'query_string': changelist.get_query_string(param_dict, [self.field_generic]),\n367                 'display': title,\n368             }\n369 \n370 \n371 FieldListFilter.register(\n372     lambda f: isinstance(f, models.DateField), DateFieldListFilter)\n373 \n374 \n375 # This should be registered last, because it's a last resort. For example,\n376 # if a field is eligible to use the BooleanFieldListFilter, that'd be much\n377 # more appropriate, and the AllValuesFieldListFilter won't get used for it.\n378 class AllValuesFieldListFilter(FieldListFilter):\n379     def __init__(self, field, request, params, model, model_admin, field_path):\n380         self.lookup_kwarg = field_path\n381         self.lookup_kwarg_isnull = '%s__isnull' % field_path\n382         self.lookup_val = params.get(self.lookup_kwarg)\n383         self.lookup_val_isnull = params.get(self.lookup_kwarg_isnull)\n384         self.empty_value_display = model_admin.get_empty_value_display()\n385         parent_model, reverse_path = reverse_field_path(model, field_path)\n386         # Obey parent ModelAdmin queryset when deciding which options to show\n387         if model == parent_model:\n388             queryset = model_admin.get_queryset(request)\n389         else:\n390             queryset = parent_model._default_manager.all()\n391         self.lookup_choices = queryset.distinct().order_by(field.name).values_list(field.name, flat=True)\n392         super().__init__(field, request, params, model, model_admin, field_path)\n393 \n394     def expected_parameters(self):\n395         return [self.lookup_kwarg, self.lookup_kwarg_isnull]\n396 \n397     def choices(self, changelist):\n398         yield {\n399             'selected': self.lookup_val is None and self.lookup_val_isnull is None,\n400             'query_string': changelist.get_query_string(remove=[self.lookup_kwarg, self.lookup_kwarg_isnull]),\n401             'display': _('All'),\n402         }\n403         include_none = False\n404         for val in self.lookup_choices:\n405             if val is None:\n406                 include_none = True\n407                 continue\n408             val = str(val)\n409             yield {\n410                 'selected': self.lookup_val == val,\n411                 'query_string': changelist.get_query_string({self.lookup_kwarg: val}, [self.lookup_kwarg_isnull]),\n412                 'display': val,\n413             }\n414         if include_none:\n415             yield {\n416                 'selected': bool(self.lookup_val_isnull),\n417                 'query_string': changelist.get_query_string({self.lookup_kwarg_isnull: 'True'}, [self.lookup_kwarg]),\n418                 'display': self.empty_value_display,\n419             }\n420 \n421 \n422 FieldListFilter.register(lambda f: True, AllValuesFieldListFilter)\n423 \n424 \n425 class RelatedOnlyFieldListFilter(RelatedFieldListFilter):\n426     def field_choices(self, field, request, model_admin):\n427         pk_qs = model_admin.get_queryset(request).distinct().values_list('%s__pk' % self.field_path, flat=True)\n428         ordering = self.field_admin_ordering(field, request, model_admin)\n429         return field.get_choices(include_blank=False, limit_choices_to={'pk__in': pk_qs}, ordering=ordering)\n430 \n431 \n432 class EmptyFieldListFilter(FieldListFilter):\n433     def __init__(self, field, request, params, model, model_admin, field_path):\n434         if not field.empty_strings_allowed and not field.null:\n435             raise ImproperlyConfigured(\n436                 \"The list filter '%s' cannot be used with field '%s' which \"\n437                 \"doesn't allow empty strings and nulls.\" % (\n438                     self.__class__.__name__,\n439                     field.name,\n440                 )\n441             )\n442         self.lookup_kwarg = '%s__isempty' % field_path\n443         self.lookup_val = params.get(self.lookup_kwarg)\n444         super().__init__(field, request, params, model, model_admin, field_path)\n445 \n446     def queryset(self, request, queryset):\n447         if self.lookup_kwarg not in self.used_parameters:\n448             return queryset\n449         if self.lookup_val not in ('0', '1'):\n450             raise IncorrectLookupParameters\n451 \n452         lookup_condition = models.Q()\n453         if self.field.empty_strings_allowed:\n454             lookup_condition |= models.Q(**{self.field_path: ''})\n455         if self.field.null:\n456             lookup_condition |= models.Q(**{'%s__isnull' % self.field_path: True})\n457         if self.lookup_val == '1':\n458             return queryset.filter(lookup_condition)\n459         return queryset.exclude(lookup_condition)\n460 \n461     def expected_parameters(self):\n462         return [self.lookup_kwarg]\n463 \n464     def choices(self, changelist):\n465         for lookup, title in (\n466             (None, _('All')),\n467             ('1', _('Empty')),\n468             ('0', _('Not empty')),\n469         ):\n470             yield {\n471                 'selected': self.lookup_val == lookup,\n472                 'query_string': changelist.get_query_string({self.lookup_kwarg: lookup}),\n473                 'display': title,\n474             }\n",
        "intended_behavior": "The code within `django/contrib/admin/filters.py` that deals with the date hierarchy filters should ensure accurate calculation of start and end dates of the selected month, considering the user's time zone to prevent the inclusion of an extra day from the previous month due to timezone differences."
    }
]