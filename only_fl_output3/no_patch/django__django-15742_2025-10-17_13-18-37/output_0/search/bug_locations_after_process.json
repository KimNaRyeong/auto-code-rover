[
    {
        "rel_file_path": "django/template/base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/template/base.py",
        "start": 1,
        "end": 1121,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 This is the Django template system.\n3 \n4 How it works:\n5 \n6 The Lexer.tokenize() method converts a template string (i.e., a string\n7 containing markup with custom template tags) to tokens, which can be either\n8 plain text (TokenType.TEXT), variables (TokenType.VAR), or block statements\n9 (TokenType.BLOCK).\n10 \n11 The Parser() class takes a list of tokens in its constructor, and its parse()\n12 method returns a compiled template -- which is, under the hood, a list of\n13 Node objects.\n14 \n15 Each Node is responsible for creating some sort of output -- e.g. simple text\n16 (TextNode), variable values in a given context (VariableNode), results of basic\n17 logic (IfNode), results of looping (ForNode), or anything else. The core Node\n18 types are TextNode, VariableNode, IfNode and ForNode, but plugin modules can\n19 define their own custom node types.\n20 \n21 Each Node has a render() method, which takes a Context and returns a string of\n22 the rendered node. For example, the render() method of a Variable Node returns\n23 the variable's value as a string. The render() method of a ForNode returns the\n24 rendered output of whatever was inside the loop, recursively.\n25 \n26 The Template class is a convenient wrapper that takes care of template\n27 compilation and rendering.\n28 \n29 Usage:\n30 \n31 The only thing you should ever use directly in this file is the Template class.\n32 Create a compiled template object with a template_string, then call render()\n33 with a context. In the compilation stage, the TemplateSyntaxError exception\n34 will be raised if the template doesn't have proper syntax.\n35 \n36 Sample code:\n37 \n38 >>> from django import template\n39 >>> s = '<html>{% if test %}<h1>{{ varvalue }}</h1>{% endif %}</html>'\n40 >>> t = template.Template(s)\n41 \n42 (t is now a compiled template, and its render() method can be called multiple\n43 times with multiple contexts)\n44 \n45 >>> c = template.Context({'test':True, 'varvalue': 'Hello'})\n46 >>> t.render(c)\n47 '<html><h1>Hello</h1></html>'\n48 >>> c = template.Context({'test':False, 'varvalue': 'Hello'})\n49 >>> t.render(c)\n50 '<html></html>'\n51 \"\"\"\n52 \n53 import inspect\n54 import logging\n55 import re\n56 from enum import Enum\n57 \n58 from django.template.context import BaseContext\n59 from django.utils.formats import localize\n60 from django.utils.html import conditional_escape, escape\n61 from django.utils.regex_helper import _lazy_re_compile\n62 from django.utils.safestring import SafeData, SafeString, mark_safe\n63 from django.utils.text import get_text_list, smart_split, unescape_string_literal\n64 from django.utils.timezone import template_localtime\n65 from django.utils.translation import gettext_lazy, pgettext_lazy\n66 \n67 from .exceptions import TemplateSyntaxError\n68 \n69 # template syntax constants\n70 FILTER_SEPARATOR = \"|\"\n71 FILTER_ARGUMENT_SEPARATOR = \":\"\n72 VARIABLE_ATTRIBUTE_SEPARATOR = \".\"\n73 BLOCK_TAG_START = \"{%\"\n74 BLOCK_TAG_END = \"%}\"\n75 VARIABLE_TAG_START = \"{{\"\n76 VARIABLE_TAG_END = \"}}\"\n77 COMMENT_TAG_START = \"{#\"\n78 COMMENT_TAG_END = \"#}\"\n79 SINGLE_BRACE_START = \"{\"\n80 SINGLE_BRACE_END = \"}\"\n81 \n82 # what to report as the origin for templates that come from non-loader sources\n83 # (e.g. strings)\n84 UNKNOWN_SOURCE = \"<unknown source>\"\n85 \n86 # Match BLOCK_TAG_*, VARIABLE_TAG_*, and COMMENT_TAG_* tags and capture the\n87 # entire tag, including start/end delimiters. Using re.compile() is faster\n88 # than instantiating SimpleLazyObject with _lazy_re_compile().\n89 tag_re = re.compile(r\"({%.*?%}|{{.*?}}|{#.*?#})\")\n90 \n91 logger = logging.getLogger(\"django.template\")\n92 \n93 \n94 class TokenType(Enum):\n95     TEXT = 0\n96     VAR = 1\n97     BLOCK = 2\n98     COMMENT = 3\n99 \n100 \n101 class VariableDoesNotExist(Exception):\n102     def __init__(self, msg, params=()):\n103         self.msg = msg\n104         self.params = params\n105 \n106     def __str__(self):\n107         return self.msg % self.params\n108 \n109 \n110 class Origin:\n111     def __init__(self, name, template_name=None, loader=None):\n112         self.name = name\n113         self.template_name = template_name\n114         self.loader = loader\n115 \n116     def __str__(self):\n117         return self.name\n118 \n119     def __repr__(self):\n120         return \"<%s name=%r>\" % (self.__class__.__qualname__, self.name)\n121 \n122     def __eq__(self, other):\n123         return (\n124             isinstance(other, Origin)\n125             and self.name == other.name\n126             and self.loader == other.loader\n127         )\n128 \n129     @property\n130     def loader_name(self):\n131         if self.loader:\n132             return \"%s.%s\" % (\n133                 self.loader.__module__,\n134                 self.loader.__class__.__name__,\n135             )\n136 \n137 \n138 class Template:\n139     def __init__(self, template_string, origin=None, name=None, engine=None):\n140         # If Template is instantiated directly rather than from an Engine and\n141         # exactly one Django template engine is configured, use that engine.\n142         # This is required to preserve backwards-compatibility for direct use\n143         # e.g. Template('...').render(Context({...}))\n144         if engine is None:\n145             from .engine import Engine\n146 \n147             engine = Engine.get_default()\n148         if origin is None:\n149             origin = Origin(UNKNOWN_SOURCE)\n150         self.name = name\n151         self.origin = origin\n152         self.engine = engine\n153         self.source = str(template_string)  # May be lazy.\n154         self.nodelist = self.compile_nodelist()\n155 \n156     def __iter__(self):\n157         for node in self.nodelist:\n158             yield from node\n159 \n160     def __repr__(self):\n161         return '<%s template_string=\"%s...\">' % (\n162             self.__class__.__qualname__,\n163             self.source[:20].replace(\"\\n\", \"\"),\n164         )\n165 \n166     def _render(self, context):\n167         return self.nodelist.render(context)\n168 \n169     def render(self, context):\n170         \"Display stage -- can be called many times\"\n171         with context.render_context.push_state(self):\n172             if context.template is None:\n173                 with context.bind_template(self):\n174                     context.template_name = self.name\n175                     return self._render(context)\n176             else:\n177                 return self._render(context)\n178 \n179     def compile_nodelist(self):\n180         \"\"\"\n181         Parse and compile the template source into a nodelist. If debug\n182         is True and an exception occurs during parsing, the exception is\n183         annotated with contextual line information where it occurred in the\n184         template source.\n185         \"\"\"\n186         if self.engine.debug:\n187             lexer = DebugLexer(self.source)\n188         else:\n189             lexer = Lexer(self.source)\n190 \n191         tokens = lexer.tokenize()\n192         parser = Parser(\n193             tokens,\n194             self.engine.template_libraries,\n195             self.engine.template_builtins,\n196             self.origin,\n197         )\n198 \n199         try:\n200             return parser.parse()\n201         except Exception as e:\n202             if self.engine.debug:\n203                 e.template_debug = self.get_exception_info(e, e.token)\n204             raise\n205 \n206     def get_exception_info(self, exception, token):\n207         \"\"\"\n208         Return a dictionary containing contextual line information of where\n209         the exception occurred in the template. The following information is\n210         provided:\n211 \n212         message\n213             The message of the exception raised.\n214 \n215         source_lines\n216             The lines before, after, and including the line the exception\n217             occurred on.\n218 \n219         line\n220             The line number the exception occurred on.\n221 \n222         before, during, after\n223             The line the exception occurred on split into three parts:\n224             1. The content before the token that raised the error.\n225             2. The token that raised the error.\n226             3. The content after the token that raised the error.\n227 \n228         total\n229             The number of lines in source_lines.\n230 \n231         top\n232             The line number where source_lines starts.\n233 \n234         bottom\n235             The line number where source_lines ends.\n236 \n237         start\n238             The start position of the token in the template source.\n239 \n240         end\n241             The end position of the token in the template source.\n242         \"\"\"\n243         start, end = token.position\n244         context_lines = 10\n245         line = 0\n246         upto = 0\n247         source_lines = []\n248         before = during = after = \"\"\n249         for num, next in enumerate(linebreak_iter(self.source)):\n250             if start >= upto and end <= next:\n251                 line = num\n252                 before = escape(self.source[upto:start])\n253                 during = escape(self.source[start:end])\n254                 after = escape(self.source[end:next])\n255             source_lines.append((num, escape(self.source[upto:next])))\n256             upto = next\n257         total = len(source_lines)\n258 \n259         top = max(1, line - context_lines)\n260         bottom = min(total, line + 1 + context_lines)\n261 \n262         # In some rare cases exc_value.args can be empty or an invalid\n263         # string.\n264         try:\n265             message = str(exception.args[0])\n266         except (IndexError, UnicodeDecodeError):\n267             message = \"(Could not get exception message)\"\n268 \n269         return {\n270             \"message\": message,\n271             \"source_lines\": source_lines[top:bottom],\n272             \"before\": before,\n273             \"during\": during,\n274             \"after\": after,\n275             \"top\": top,\n276             \"bottom\": bottom,\n277             \"total\": total,\n278             \"line\": line,\n279             \"name\": self.origin.name,\n280             \"start\": start,\n281             \"end\": end,\n282         }\n283 \n284 \n285 def linebreak_iter(template_source):\n286     yield 0\n287     p = template_source.find(\"\\n\")\n288     while p >= 0:\n289         yield p + 1\n290         p = template_source.find(\"\\n\", p + 1)\n291     yield len(template_source) + 1\n292 \n293 \n294 class Token:\n295     def __init__(self, token_type, contents, position=None, lineno=None):\n296         \"\"\"\n297         A token representing a string from the template.\n298 \n299         token_type\n300             A TokenType, either .TEXT, .VAR, .BLOCK, or .COMMENT.\n301 \n302         contents\n303             The token source string.\n304 \n305         position\n306             An optional tuple containing the start and end index of the token\n307             in the template source. This is used for traceback information\n308             when debug is on.\n309 \n310         lineno\n311             The line number the token appears on in the template source.\n312             This is used for traceback information and gettext files.\n313         \"\"\"\n314         self.token_type, self.contents = token_type, contents\n315         self.lineno = lineno\n316         self.position = position\n317 \n318     def __repr__(self):\n319         token_name = self.token_type.name.capitalize()\n320         return '<%s token: \"%s...\">' % (\n321             token_name,\n322             self.contents[:20].replace(\"\\n\", \"\"),\n323         )\n324 \n325     def split_contents(self):\n326         split = []\n327         bits = smart_split(self.contents)\n328         for bit in bits:\n329             # Handle translation-marked template pieces\n330             if bit.startswith(('_(\"', \"_('\")):\n331                 sentinel = bit[2] + \")\"\n332                 trans_bit = [bit]\n333                 while not bit.endswith(sentinel):\n334                     bit = next(bits)\n335                     trans_bit.append(bit)\n336                 bit = \" \".join(trans_bit)\n337             split.append(bit)\n338         return split\n339 \n340 \n341 class Lexer:\n342     def __init__(self, template_string):\n343         self.template_string = template_string\n344         self.verbatim = False\n345 \n346     def __repr__(self):\n347         return '<%s template_string=\"%s...\", verbatim=%s>' % (\n348             self.__class__.__qualname__,\n349             self.template_string[:20].replace(\"\\n\", \"\"),\n350             self.verbatim,\n351         )\n352 \n353     def tokenize(self):\n354         \"\"\"\n355         Return a list of tokens from a given template_string.\n356         \"\"\"\n357         in_tag = False\n358         lineno = 1\n359         result = []\n360         for token_string in tag_re.split(self.template_string):\n361             if token_string:\n362                 result.append(self.create_token(token_string, None, lineno, in_tag))\n363                 lineno += token_string.count(\"\\n\")\n364             in_tag = not in_tag\n365         return result\n366 \n367     def create_token(self, token_string, position, lineno, in_tag):\n368         \"\"\"\n369         Convert the given token string into a new Token object and return it.\n370         If in_tag is True, we are processing something that matched a tag,\n371         otherwise it should be treated as a literal string.\n372         \"\"\"\n373         if in_tag:\n374             # The [0:2] and [2:-2] ranges below strip off *_TAG_START and\n375             # *_TAG_END. The 2's are hard-coded for performance. Using\n376             # len(BLOCK_TAG_START) would permit BLOCK_TAG_START to be\n377             # different, but it's not likely that the TAG_START values will\n378             # change anytime soon.\n379             token_start = token_string[0:2]\n380             if token_start == BLOCK_TAG_START:\n381                 content = token_string[2:-2].strip()\n382                 if self.verbatim:\n383                     # Then a verbatim block is being processed.\n384                     if content != self.verbatim:\n385                         return Token(TokenType.TEXT, token_string, position, lineno)\n386                     # Otherwise, the current verbatim block is ending.\n387                     self.verbatim = False\n388                 elif content[:9] in (\"verbatim\", \"verbatim \"):\n389                     # Then a verbatim block is starting.\n390                     self.verbatim = \"end%s\" % content\n391                 return Token(TokenType.BLOCK, content, position, lineno)\n392             if not self.verbatim:\n393                 content = token_string[2:-2].strip()\n394                 if token_start == VARIABLE_TAG_START:\n395                     return Token(TokenType.VAR, content, position, lineno)\n396                 # BLOCK_TAG_START was handled above.\n397                 assert token_start == COMMENT_TAG_START\n398                 return Token(TokenType.COMMENT, content, position, lineno)\n399         return Token(TokenType.TEXT, token_string, position, lineno)\n400 \n401 \n402 class DebugLexer(Lexer):\n403     def _tag_re_split_positions(self):\n404         last = 0\n405         for match in tag_re.finditer(self.template_string):\n406             start, end = match.span()\n407             yield last, start\n408             yield start, end\n409             last = end\n410         yield last, len(self.template_string)\n411 \n412     # This parallels the use of tag_re.split() in Lexer.tokenize().\n413     def _tag_re_split(self):\n414         for position in self._tag_re_split_positions():\n415             yield self.template_string[slice(*position)], position\n416 \n417     def tokenize(self):\n418         \"\"\"\n419         Split a template string into tokens and annotates each token with its\n420         start and end position in the source. This is slower than the default\n421         lexer so only use it when debug is True.\n422         \"\"\"\n423         # For maintainability, it is helpful if the implementation below can\n424         # continue to closely parallel Lexer.tokenize()'s implementation.\n425         in_tag = False\n426         lineno = 1\n427         result = []\n428         for token_string, position in self._tag_re_split():\n429             if token_string:\n430                 result.append(self.create_token(token_string, position, lineno, in_tag))\n431                 lineno += token_string.count(\"\\n\")\n432             in_tag = not in_tag\n433         return result\n434 \n435 \n436 class Parser:\n437     def __init__(self, tokens, libraries=None, builtins=None, origin=None):\n438         # Reverse the tokens so delete_first_token(), prepend_token(), and\n439         # next_token() can operate at the end of the list in constant time.\n440         self.tokens = list(reversed(tokens))\n441         self.tags = {}\n442         self.filters = {}\n443         self.command_stack = []\n444 \n445         if libraries is None:\n446             libraries = {}\n447         if builtins is None:\n448             builtins = []\n449 \n450         self.libraries = libraries\n451         for builtin in builtins:\n452             self.add_library(builtin)\n453         self.origin = origin\n454 \n455     def __repr__(self):\n456         return \"<%s tokens=%r>\" % (self.__class__.__qualname__, self.tokens)\n457 \n458     def parse(self, parse_until=None):\n459         \"\"\"\n460         Iterate through the parser tokens and compiles each one into a node.\n461 \n462         If parse_until is provided, parsing will stop once one of the\n463         specified tokens has been reached. This is formatted as a list of\n464         tokens, e.g. ['elif', 'else', 'endif']. If no matching token is\n465         reached, raise an exception with the unclosed block tag details.\n466         \"\"\"\n467         if parse_until is None:\n468             parse_until = []\n469         nodelist = NodeList()\n470         while self.tokens:\n471             token = self.next_token()\n472             # Use the raw values here for TokenType.* for a tiny performance boost.\n473             token_type = token.token_type.value\n474             if token_type == 0:  # TokenType.TEXT\n475                 self.extend_nodelist(nodelist, TextNode(token.contents), token)\n476             elif token_type == 1:  # TokenType.VAR\n477                 if not token.contents:\n478                     raise self.error(\n479                         token, \"Empty variable tag on line %d\" % token.lineno\n480                     )\n481                 try:\n482                     filter_expression = self.compile_filter(token.contents)\n483                 except TemplateSyntaxError as e:\n484                     raise self.error(token, e)\n485                 var_node = VariableNode(filter_expression)\n486                 self.extend_nodelist(nodelist, var_node, token)\n487             elif token_type == 2:  # TokenType.BLOCK\n488                 try:\n489                     command = token.contents.split()[0]\n490                 except IndexError:\n491                     raise self.error(token, \"Empty block tag on line %d\" % token.lineno)\n492                 if command in parse_until:\n493                     # A matching token has been reached. Return control to\n494                     # the caller. Put the token back on the token list so the\n495                     # caller knows where it terminated.\n496                     self.prepend_token(token)\n497                     return nodelist\n498                 # Add the token to the command stack. This is used for error\n499                 # messages if further parsing fails due to an unclosed block\n500                 # tag.\n501                 self.command_stack.append((command, token))\n502                 # Get the tag callback function from the ones registered with\n503                 # the parser.\n504                 try:\n505                     compile_func = self.tags[command]\n506                 except KeyError:\n507                     self.invalid_block_tag(token, command, parse_until)\n508                 # Compile the callback into a node object and add it to\n509                 # the node list.\n510                 try:\n511                     compiled_result = compile_func(self, token)\n512                 except Exception as e:\n513                     raise self.error(token, e)\n514                 self.extend_nodelist(nodelist, compiled_result, token)\n515                 # Compile success. Remove the token from the command stack.\n516                 self.command_stack.pop()\n517         if parse_until:\n518             self.unclosed_block_tag(parse_until)\n519         return nodelist\n520 \n521     def skip_past(self, endtag):\n522         while self.tokens:\n523             token = self.next_token()\n524             if token.token_type == TokenType.BLOCK and token.contents == endtag:\n525                 return\n526         self.unclosed_block_tag([endtag])\n527 \n528     def extend_nodelist(self, nodelist, node, token):\n529         # Check that non-text nodes don't appear before an extends tag.\n530         if node.must_be_first and nodelist.contains_nontext:\n531             raise self.error(\n532                 token,\n533                 \"%r must be the first tag in the template.\" % node,\n534             )\n535         if not isinstance(node, TextNode):\n536             nodelist.contains_nontext = True\n537         # Set origin and token here since we can't modify the node __init__()\n538         # method.\n539         node.token = token\n540         node.origin = self.origin\n541         nodelist.append(node)\n542 \n543     def error(self, token, e):\n544         \"\"\"\n545         Return an exception annotated with the originating token. Since the\n546         parser can be called recursively, check if a token is already set. This\n547         ensures the innermost token is highlighted if an exception occurs,\n548         e.g. a compile error within the body of an if statement.\n549         \"\"\"\n550         if not isinstance(e, Exception):\n551             e = TemplateSyntaxError(e)\n552         if not hasattr(e, \"token\"):\n553             e.token = token\n554         return e\n555 \n556     def invalid_block_tag(self, token, command, parse_until=None):\n557         if parse_until:\n558             raise self.error(\n559                 token,\n560                 \"Invalid block tag on line %d: '%s', expected %s. Did you \"\n561                 \"forget to register or load this tag?\"\n562                 % (\n563                     token.lineno,\n564                     command,\n565                     get_text_list([\"'%s'\" % p for p in parse_until], \"or\"),\n566                 ),\n567             )\n568         raise self.error(\n569             token,\n570             \"Invalid block tag on line %d: '%s'. Did you forget to register \"\n571             \"or load this tag?\" % (token.lineno, command),\n572         )\n573 \n574     def unclosed_block_tag(self, parse_until):\n575         command, token = self.command_stack.pop()\n576         msg = \"Unclosed tag on line %d: '%s'. Looking for one of: %s.\" % (\n577             token.lineno,\n578             command,\n579             \", \".join(parse_until),\n580         )\n581         raise self.error(token, msg)\n582 \n583     def next_token(self):\n584         return self.tokens.pop()\n585 \n586     def prepend_token(self, token):\n587         self.tokens.append(token)\n588 \n589     def delete_first_token(self):\n590         del self.tokens[-1]\n591 \n592     def add_library(self, lib):\n593         self.tags.update(lib.tags)\n594         self.filters.update(lib.filters)\n595 \n596     def compile_filter(self, token):\n597         \"\"\"\n598         Convenient wrapper for FilterExpression\n599         \"\"\"\n600         return FilterExpression(token, self)\n601 \n602     def find_filter(self, filter_name):\n603         if filter_name in self.filters:\n604             return self.filters[filter_name]\n605         else:\n606             raise TemplateSyntaxError(\"Invalid filter: '%s'\" % filter_name)\n607 \n608 \n609 # This only matches constant *strings* (things in quotes or marked for\n610 # translation). Numbers are treated as variables for implementation reasons\n611 # (so that they retain their type when passed to filters).\n612 constant_string = r\"\"\"\n613 (?:%(i18n_open)s%(strdq)s%(i18n_close)s|\n614 %(i18n_open)s%(strsq)s%(i18n_close)s|\n615 %(strdq)s|\n616 %(strsq)s)\n617 \"\"\" % {\n618     \"strdq\": r'\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"',  # double-quoted string\n619     \"strsq\": r\"'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\",  # single-quoted string\n620     \"i18n_open\": re.escape(\"_(\"),\n621     \"i18n_close\": re.escape(\")\"),\n622 }\n623 constant_string = constant_string.replace(\"\\n\", \"\")\n624 \n625 filter_raw_string = r\"\"\"\n626 ^(?P<constant>%(constant)s)|\n627 ^(?P<var>[%(var_chars)s]+|%(num)s)|\n628  (?:\\s*%(filter_sep)s\\s*\n629      (?P<filter_name>\\w+)\n630          (?:%(arg_sep)s\n631              (?:\n632               (?P<constant_arg>%(constant)s)|\n633               (?P<var_arg>[%(var_chars)s]+|%(num)s)\n634              )\n635          )?\n636  )\"\"\" % {\n637     \"constant\": constant_string,\n638     \"num\": r\"[-+\\.]?\\d[\\d\\.e]*\",\n639     \"var_chars\": r\"\\w\\.\",\n640     \"filter_sep\": re.escape(FILTER_SEPARATOR),\n641     \"arg_sep\": re.escape(FILTER_ARGUMENT_SEPARATOR),\n642 }\n643 \n644 filter_re = _lazy_re_compile(filter_raw_string, re.VERBOSE)\n645 \n646 \n647 class FilterExpression:\n648     \"\"\"\n649     Parse a variable token and its optional filters (all as a single string),\n650     and return a list of tuples of the filter name and arguments.\n651     Sample::\n652 \n653         >>> token = 'variable|default:\"Default value\"|date:\"Y-m-d\"'\n654         >>> p = Parser('')\n655         >>> fe = FilterExpression(token, p)\n656         >>> len(fe.filters)\n657         2\n658         >>> fe.var\n659         <Variable: 'variable'>\n660     \"\"\"\n661 \n662     __slots__ = (\"token\", \"filters\", \"var\", \"is_var\")\n663 \n664     def __init__(self, token, parser):\n665         self.token = token\n666         matches = filter_re.finditer(token)\n667         var_obj = None\n668         filters = []\n669         upto = 0\n670         for match in matches:\n671             start = match.start()\n672             if upto != start:\n673                 raise TemplateSyntaxError(\n674                     \"Could not parse some characters: \"\n675                     \"%s|%s|%s\" % (token[:upto], token[upto:start], token[start:])\n676                 )\n677             if var_obj is None:\n678                 var, constant = match[\"var\"], match[\"constant\"]\n679                 if constant:\n680                     try:\n681                         var_obj = Variable(constant).resolve({})\n682                     except VariableDoesNotExist:\n683                         var_obj = None\n684                 elif var is None:\n685                     raise TemplateSyntaxError(\n686                         \"Could not find variable at start of %s.\" % token\n687                     )\n688                 else:\n689                     var_obj = Variable(var)\n690             else:\n691                 filter_name = match[\"filter_name\"]\n692                 args = []\n693                 constant_arg, var_arg = match[\"constant_arg\"], match[\"var_arg\"]\n694                 if constant_arg:\n695                     args.append((False, Variable(constant_arg).resolve({})))\n696                 elif var_arg:\n697                     args.append((True, Variable(var_arg)))\n698                 filter_func = parser.find_filter(filter_name)\n699                 self.args_check(filter_name, filter_func, args)\n700                 filters.append((filter_func, args))\n701             upto = match.end()\n702         if upto != len(token):\n703             raise TemplateSyntaxError(\n704                 \"Could not parse the remainder: '%s' \"\n705                 \"from '%s'\" % (token[upto:], token)\n706             )\n707 \n708         self.filters = filters\n709         self.var = var_obj\n710         self.is_var = isinstance(var_obj, Variable)\n711 \n712     def resolve(self, context, ignore_failures=False):\n713         if self.is_var:\n714             try:\n715                 obj = self.var.resolve(context)\n716             except VariableDoesNotExist:\n717                 if ignore_failures:\n718                     obj = None\n719                 else:\n720                     string_if_invalid = context.template.engine.string_if_invalid\n721                     if string_if_invalid:\n722                         if \"%s\" in string_if_invalid:\n723                             return string_if_invalid % self.var\n724                         else:\n725                             return string_if_invalid\n726                     else:\n727                         obj = string_if_invalid\n728         else:\n729             obj = self.var\n730         for func, args in self.filters:\n731             arg_vals = []\n732             for lookup, arg in args:\n733                 if not lookup:\n734                     arg_vals.append(mark_safe(arg))\n735                 else:\n736                     arg_vals.append(arg.resolve(context))\n737             if getattr(func, \"expects_localtime\", False):\n738                 obj = template_localtime(obj, context.use_tz)\n739             if getattr(func, \"needs_autoescape\", False):\n740                 new_obj = func(obj, autoescape=context.autoescape, *arg_vals)\n741             else:\n742                 new_obj = func(obj, *arg_vals)\n743             if getattr(func, \"is_safe\", False) and isinstance(obj, SafeData):\n744                 obj = mark_safe(new_obj)\n745             else:\n746                 obj = new_obj\n747         return obj\n748 \n749     def args_check(name, func, provided):\n750         provided = list(provided)\n751         # First argument, filter input, is implied.\n752         plen = len(provided) + 1\n753         # Check to see if a decorator is providing the real function.\n754         func = inspect.unwrap(func)\n755 \n756         args, _, _, defaults, _, _, _ = inspect.getfullargspec(func)\n757         alen = len(args)\n758         dlen = len(defaults or [])\n759         # Not enough OR Too many\n760         if plen < (alen - dlen) or plen > alen:\n761             raise TemplateSyntaxError(\n762                 \"%s requires %d arguments, %d provided\" % (name, alen - dlen, plen)\n763             )\n764 \n765         return True\n766 \n767     args_check = staticmethod(args_check)\n768 \n769     def __str__(self):\n770         return self.token\n771 \n772     def __repr__(self):\n773         return \"<%s %r>\" % (self.__class__.__qualname__, self.token)\n774 \n775 \n776 class Variable:\n777     \"\"\"\n778     A template variable, resolvable against a given context. The variable may\n779     be a hard-coded string (if it begins and ends with single or double quote\n780     marks)::\n781 \n782         >>> c = {'article': {'section':'News'}}\n783         >>> Variable('article.section').resolve(c)\n784         'News'\n785         >>> Variable('article').resolve(c)\n786         {'section': 'News'}\n787         >>> class AClass: pass\n788         >>> c = AClass()\n789         >>> c.article = AClass()\n790         >>> c.article.section = 'News'\n791 \n792     (The example assumes VARIABLE_ATTRIBUTE_SEPARATOR is '.')\n793     \"\"\"\n794 \n795     __slots__ = (\"var\", \"literal\", \"lookups\", \"translate\", \"message_context\")\n796 \n797     def __init__(self, var):\n798         self.var = var\n799         self.literal = None\n800         self.lookups = None\n801         self.translate = False\n802         self.message_context = None\n803 \n804         if not isinstance(var, str):\n805             raise TypeError(\"Variable must be a string or number, got %s\" % type(var))\n806         try:\n807             # First try to treat this variable as a number.\n808             #\n809             # Note that this could cause an OverflowError here that we're not\n810             # catching. Since this should only happen at compile time, that's\n811             # probably OK.\n812 \n813             # Try to interpret values containing a period or an 'e'/'E'\n814             # (possibly scientific notation) as a float;  otherwise, try int.\n815             if \".\" in var or \"e\" in var.lower():\n816                 self.literal = float(var)\n817                 # \"2.\" is invalid\n818                 if var[-1] == \".\":\n819                     raise ValueError\n820             else:\n821                 self.literal = int(var)\n822         except ValueError:\n823             # A ValueError means that the variable isn't a number.\n824             if var[0:2] == \"_(\" and var[-1] == \")\":\n825                 # The result of the lookup should be translated at rendering\n826                 # time.\n827                 self.translate = True\n828                 var = var[2:-1]\n829             # If it's wrapped with quotes (single or double), then\n830             # we're also dealing with a literal.\n831             try:\n832                 self.literal = mark_safe(unescape_string_literal(var))\n833             except ValueError:\n834                 # Otherwise we'll set self.lookups so that resolve() knows we're\n835                 # dealing with a bonafide variable\n836                 if VARIABLE_ATTRIBUTE_SEPARATOR + \"_\" in var or var[0] == \"_\":\n837                     raise TemplateSyntaxError(\n838                         \"Variables and attributes may \"\n839                         \"not begin with underscores: '%s'\" % var\n840                     )\n841                 self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))\n842 \n843     def resolve(self, context):\n844         \"\"\"Resolve this variable against a given context.\"\"\"\n845         if self.lookups is not None:\n846             # We're dealing with a variable that needs to be resolved\n847             value = self._resolve_lookup(context)\n848         else:\n849             # We're dealing with a literal, so it's already been \"resolved\"\n850             value = self.literal\n851         if self.translate:\n852             is_safe = isinstance(value, SafeData)\n853             msgid = value.replace(\"%\", \"%%\")\n854             msgid = mark_safe(msgid) if is_safe else msgid\n855             if self.message_context:\n856                 return pgettext_lazy(self.message_context, msgid)\n857             else:\n858                 return gettext_lazy(msgid)\n859         return value\n860 \n861     def __repr__(self):\n862         return \"<%s: %r>\" % (self.__class__.__name__, self.var)\n863 \n864     def __str__(self):\n865         return self.var\n866 \n867     def _resolve_lookup(self, context):\n868         \"\"\"\n869         Perform resolution of a real variable (i.e. not a literal) against the\n870         given context.\n871 \n872         As indicated by the method's name, this method is an implementation\n873         detail and shouldn't be called by external code. Use Variable.resolve()\n874         instead.\n875         \"\"\"\n876         current = context\n877         try:  # catch-all for silent variable failures\n878             for bit in self.lookups:\n879                 try:  # dictionary lookup\n880                     current = current[bit]\n881                     # ValueError/IndexError are for numpy.array lookup on\n882                     # numpy < 1.9 and 1.9+ respectively\n883                 except (TypeError, AttributeError, KeyError, ValueError, IndexError):\n884                     try:  # attribute lookup\n885                         # Don't return class attributes if the class is the context:\n886                         if isinstance(current, BaseContext) and getattr(\n887                             type(current), bit\n888                         ):\n889                             raise AttributeError\n890                         current = getattr(current, bit)\n891                     except (TypeError, AttributeError):\n892                         # Reraise if the exception was raised by a @property\n893                         if not isinstance(current, BaseContext) and bit in dir(current):\n894                             raise\n895                         try:  # list-index lookup\n896                             current = current[int(bit)]\n897                         except (\n898                             IndexError,  # list index out of range\n899                             ValueError,  # invalid literal for int()\n900                             KeyError,  # current is a dict without `int(bit)` key\n901                             TypeError,\n902                         ):  # unsubscriptable object\n903                             raise VariableDoesNotExist(\n904                                 \"Failed lookup for key [%s] in %r\",\n905                                 (bit, current),\n906                             )  # missing attribute\n907                 if callable(current):\n908                     if getattr(current, \"do_not_call_in_templates\", False):\n909                         pass\n910                     elif getattr(current, \"alters_data\", False):\n911                         current = context.template.engine.string_if_invalid\n912                     else:\n913                         try:  # method call (assuming no args required)\n914                             current = current()\n915                         except TypeError:\n916                             try:\n917                                 signature = inspect.signature(current)\n918                             except ValueError:  # No signature found.\n919                                 current = context.template.engine.string_if_invalid\n920                             else:\n921                                 try:\n922                                     signature.bind()\n923                                 except TypeError:  # Arguments *were* required.\n924                                     # Invalid method call.\n925                                     current = context.template.engine.string_if_invalid\n926                                 else:\n927                                     raise\n928         except Exception as e:\n929             template_name = getattr(context, \"template_name\", None) or \"unknown\"\n930             logger.debug(\n931                 \"Exception while resolving variable '%s' in template '%s'.\",\n932                 bit,\n933                 template_name,\n934                 exc_info=True,\n935             )\n936 \n937             if getattr(e, \"silent_variable_failure\", False):\n938                 current = context.template.engine.string_if_invalid\n939             else:\n940                 raise\n941 \n942         return current\n943 \n944 \n945 class Node:\n946     # Set this to True for nodes that must be first in the template (although\n947     # they can be preceded by text nodes.\n948     must_be_first = False\n949     child_nodelists = (\"nodelist\",)\n950     token = None\n951 \n952     def render(self, context):\n953         \"\"\"\n954         Return the node rendered as a string.\n955         \"\"\"\n956         pass\n957 \n958     def render_annotated(self, context):\n959         \"\"\"\n960         Render the node. If debug is True and an exception occurs during\n961         rendering, the exception is annotated with contextual line information\n962         where it occurred in the template. For internal usage this method is\n963         preferred over using the render method directly.\n964         \"\"\"\n965         try:\n966             return self.render(context)\n967         except Exception as e:\n968             if context.template.engine.debug:\n969                 # Store the actual node that caused the exception.\n970                 if not hasattr(e, \"_culprit_node\"):\n971                     e._culprit_node = self\n972                 if (\n973                     not hasattr(e, \"template_debug\")\n974                     and context.render_context.template.origin == e._culprit_node.origin\n975                 ):\n976                     e.template_debug = (\n977                         context.render_context.template.get_exception_info(\n978                             e,\n979                             e._culprit_node.token,\n980                         )\n981                     )\n982             raise\n983 \n984     def get_nodes_by_type(self, nodetype):\n985         \"\"\"\n986         Return a list of all nodes (within this node and its nodelist)\n987         of the given type\n988         \"\"\"\n989         nodes = []\n990         if isinstance(self, nodetype):\n991             nodes.append(self)\n992         for attr in self.child_nodelists:\n993             nodelist = getattr(self, attr, None)\n994             if nodelist:\n995                 nodes.extend(nodelist.get_nodes_by_type(nodetype))\n996         return nodes\n997 \n998 \n999 class NodeList(list):\n1000     # Set to True the first time a non-TextNode is inserted by\n1001     # extend_nodelist().\n1002     contains_nontext = False\n1003 \n1004     def render(self, context):\n1005         return SafeString(\"\".join([node.render_annotated(context) for node in self]))\n1006 \n1007     def get_nodes_by_type(self, nodetype):\n1008         \"Return a list of all nodes of the given type\"\n1009         nodes = []\n1010         for node in self:\n1011             nodes.extend(node.get_nodes_by_type(nodetype))\n1012         return nodes\n1013 \n1014 \n1015 class TextNode(Node):\n1016     child_nodelists = ()\n1017 \n1018     def __init__(self, s):\n1019         self.s = s\n1020 \n1021     def __repr__(self):\n1022         return \"<%s: %r>\" % (self.__class__.__name__, self.s[:25])\n1023 \n1024     def render(self, context):\n1025         return self.s\n1026 \n1027     def render_annotated(self, context):\n1028         \"\"\"\n1029         Return the given value.\n1030 \n1031         The default implementation of this method handles exceptions raised\n1032         during rendering, which is not necessary for text nodes.\n1033         \"\"\"\n1034         return self.s\n1035 \n1036 \n1037 def render_value_in_context(value, context):\n1038     \"\"\"\n1039     Convert any value to a string to become part of a rendered template. This\n1040     means escaping, if required, and conversion to a string. If value is a\n1041     string, it's expected to already be translated.\n1042     \"\"\"\n1043     value = template_localtime(value, use_tz=context.use_tz)\n1044     value = localize(value, use_l10n=context.use_l10n)\n1045     if context.autoescape:\n1046         if not issubclass(type(value), str):\n1047             value = str(value)\n1048         return conditional_escape(value)\n1049     else:\n1050         return str(value)\n1051 \n1052 \n1053 class VariableNode(Node):\n1054     child_nodelists = ()\n1055 \n1056     def __init__(self, filter_expression):\n1057         self.filter_expression = filter_expression\n1058 \n1059     def __repr__(self):\n1060         return \"<Variable Node: %s>\" % self.filter_expression\n1061 \n1062     def render(self, context):\n1063         try:\n1064             output = self.filter_expression.resolve(context)\n1065         except UnicodeDecodeError:\n1066             # Unicode conversion can fail sometimes for reasons out of our\n1067             # control (e.g. exception rendering). In that case, we fail\n1068             # quietly.\n1069             return \"\"\n1070         return render_value_in_context(output, context)\n1071 \n1072 \n1073 # Regex for token keyword arguments\n1074 kwarg_re = _lazy_re_compile(r\"(?:(\\w+)=)?(.+)\")\n1075 \n1076 \n1077 def token_kwargs(bits, parser, support_legacy=False):\n1078     \"\"\"\n1079     Parse token keyword arguments and return a dictionary of the arguments\n1080     retrieved from the ``bits`` token list.\n1081 \n1082     `bits` is a list containing the remainder of the token (split by spaces)\n1083     that is to be checked for arguments. Valid arguments are removed from this\n1084     list.\n1085 \n1086     `support_legacy` - if True, the legacy format ``1 as foo`` is accepted.\n1087     Otherwise, only the standard ``foo=1`` format is allowed.\n1088 \n1089     There is no requirement for all remaining token ``bits`` to be keyword\n1090     arguments, so return the dictionary as soon as an invalid argument format\n1091     is reached.\n1092     \"\"\"\n1093     if not bits:\n1094         return {}\n1095     match = kwarg_re.match(bits[0])\n1096     kwarg_format = match and match[1]\n1097     if not kwarg_format:\n1098         if not support_legacy:\n1099             return {}\n1100         if len(bits) < 3 or bits[1] != \"as\":\n1101             return {}\n1102 \n1103     kwargs = {}\n1104     while bits:\n1105         if kwarg_format:\n1106             match = kwarg_re.match(bits[0])\n1107             if not match or not match[1]:\n1108                 return kwargs\n1109             key, value = match.groups()\n1110             del bits[:1]\n1111         else:\n1112             if len(bits) < 3 or bits[1] != \"as\":\n1113                 return kwargs\n1114             key, value = bits[2], bits[0]\n1115             del bits[:3]\n1116         kwargs[key] = parser.compile_filter(value)\n1117         if bits and not kwarg_format:\n1118             if bits[0] != \"and\":\n1119                 return kwargs\n1120             del bits[:1]\n1121     return kwargs\n",
        "intended_behavior": "When handling variables within the `blocktranslate` template tag, especially with `asvar`, the system should: Either ensure that variables are not prematurely escaped, preserving them for contextual escaping at rendering, if not already marked safe. Or, if escaping occurs within the `blocktranslate` scope, it should store the result as a `SafeString` to prevent re-escaping when the variable is reused. This change must be carefully integrated to avoid affecting the general security posture of Django's templating system, which escapes variables by default to prevent injection attacks."
    },
    {
        "rel_file_path": "django/utils/safestring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/utils/safestring.py",
        "start": 1,
        "end": 72,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Functions for working with \"safe strings\": strings that can be displayed safely\n3 without further escaping in HTML. Marking something as a \"safe string\" means\n4 that the producer of the string has already turned characters that should not\n5 be interpreted by the HTML engine (e.g. '<') into the appropriate entities.\n6 \"\"\"\n7 \n8 from functools import wraps\n9 \n10 from django.utils.functional import keep_lazy\n11 \n12 \n13 class SafeData:\n14     __slots__ = ()\n15 \n16     def __html__(self):\n17         \"\"\"\n18         Return the html representation of a string for interoperability.\n19 \n20         This allows other template engines to understand Django's SafeData.\n21         \"\"\"\n22         return self\n23 \n24 \n25 class SafeString(str, SafeData):\n26     \"\"\"\n27     A str subclass that has been specifically marked as \"safe\" for HTML output\n28     purposes.\n29     \"\"\"\n30 \n31     __slots__ = ()\n32 \n33     def __add__(self, rhs):\n34         \"\"\"\n35         Concatenating a safe string with another safe bytestring or\n36         safe string is safe. Otherwise, the result is no longer safe.\n37         \"\"\"\n38         t = super().__add__(rhs)\n39         if isinstance(rhs, SafeData):\n40             return SafeString(t)\n41         return t\n42 \n43     def __str__(self):\n44         return self\n45 \n46 \n47 SafeText = SafeString  # For backwards compatibility since Django 2.0.\n48 \n49 \n50 def _safety_decorator(safety_marker, func):\n51     @wraps(func)\n52     def wrapper(*args, **kwargs):\n53         return safety_marker(func(*args, **kwargs))\n54 \n55     return wrapper\n56 \n57 \n58 @keep_lazy(SafeString)\n59 def mark_safe(s):\n60     \"\"\"\n61     Explicitly mark a string as safe for (HTML) output purposes. The returned\n62     object can be used everywhere a string is appropriate.\n63 \n64     If used on a method as a decorator, mark the returned data as safe.\n65 \n66     Can be called multiple times on a single string.\n67     \"\"\"\n68     if hasattr(s, \"__html__\"):\n69         return s\n70     if callable(s):\n71         return _safety_decorator(mark_safe, s)\n72     return SafeString(s)\n",
        "intended_behavior": "Ensure that the handling and rendering of `SafeString` instances within templates are well-documented and perhaps enhanced if necessary, to clarify its usage in preventing double escaping. While this file may not contain the bug itself, improvements or clarifications here could help prevent misuse that leads to similar issues."
    }
]