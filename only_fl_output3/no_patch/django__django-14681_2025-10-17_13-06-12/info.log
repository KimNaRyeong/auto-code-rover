2025-10-17 13:06:12.883 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 13:06:16.578 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=391, output_tokens=12, cost=0.004270
2025-10-17 13:06:35.401 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=571, output_tokens=833, cost=0.030700
2025-10-17 13:06:36.506 | INFO     | registered non reproducing test 0
2025-10-17 13:06:56.850 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1761, output_tokens=900, cost=0.044610
2025-10-17 13:06:58.027 | INFO     | registered non reproducing test 1
2025-10-17 13:07:18.342 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2244, output_tokens=840, cost=0.047640
2025-10-17 13:07:19.437 | INFO     | registered non reproducing test 2
2025-10-17 13:07:19.438 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 13:07:19.444 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 13:07:28.900 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=698, output_tokens=336, cost=0.017060
2025-10-17 13:07:28.907 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 13:07:32.653 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=690, output_tokens=85, cost=0.009450
2025-10-17 13:07:32.655 | DEBUG    | Extracted a valid json.
2025-10-17 13:07:32.655 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"File\")",
        "search_code(\"csrf_exempt\")",
        "search_code_in_file(\"MEDIA_ROOT\", \"settings.py\")",
        "search_code_in_file(\"FILE_UPLOAD_MAX_MEMORY_SIZE\", \"settings.py\")",
        "search_method(\"handle_uploaded_file\")",
        "search_code(\"FileField\")"
    ],
    "bug_locations": []
}
2025-10-17 13:07:32.763 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 13:07:32.763 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 13:07:53.116 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2073, output_tokens=877, cost=0.047040
2025-10-17 13:07:53.125 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 13:08:06.210 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3166, output_tokens=504, cost=0.046780
2025-10-17 13:08:06.218 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 13:08:12.798 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=858, output_tokens=262, cost=0.016440
2025-10-17 13:08:12.799 | DEBUG    | Extracted a valid json.
2025-10-17 13:08:12.799 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/core/files/storage.py",
            "class": "",
            "method": "",
            "intended_behavior": "The intended behavior at this location should include robust error handling that can differentiate between CSRF errors and storage-related errors. When an issue is detected with file storage (e.g., MEDIA_ROOT misconfiguration or inaccessible), the system should raise a clear and specific exception related to storage instead of deferring to a CSRF error. This distinction ensures administrators and developers can quickly diagnose and rectify configuration issues or filesystem permissions rather than being misled by incorrect CSRF failure messages."
        },
        {
            "file": "django/middleware/csrf.py",
            "class": "",
            "method": "",
            "intended_behavior": "This middleware should include exception handling that accurately reflects when an error is due to CSRF issues versus other errors thrown during the request process, such as those arising from file upload problems. If a request fails due to a storage issue in the process of file upload, the CSRF middleware should not overwrite or mask this error with a CSRF verification failure. Instead, it should allow storage or filesystem errors to pass through unchanged or be logged appropriately, aiding in debugging and system administration."
        }
    ]
}
2025-10-17 13:08:12.805 | DEBUG    | Bug location extracted successfully: [<file>django/core/files/storage.py</file>
<class>None</class>
<method>None</method>
<code>
1 import os
2 import pathlib
3 from datetime import datetime
4 from urllib.parse import urljoin
5 
6 from django.conf import settings
7 from django.core.exceptions import SuspiciousFileOperation
8 from django.core.files import File, locks
9 from django.core.files.move import file_move_safe
10 from django.core.files.utils import validate_file_name
11 from django.core.signals import setting_changed
12 from django.utils import timezone
13 from django.utils._os import safe_join
14 from django.utils.crypto import get_random_string
15 from django.utils.deconstruct import deconstructible
16 from django.utils.encoding import filepath_to_uri
17 from django.utils.functional import LazyObject, cached_property
18 from django.utils.module_loading import import_string
19 from django.utils.text import get_valid_filename
20 
21 __all__ = (
22     'Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage',
23     'get_storage_class',
24 )
25 
26 
27 class Storage:
28     """
29     A base storage class, providing some default behaviors that all other
30     storage systems can inherit or override, as necessary.
31     """
32 
33     # The following methods represent a public interface to private methods.
34     # These shouldn't be overridden by subclasses unless absolutely necessary.
35 
36     def open(self, name, mode='rb'):
37         """Retrieve the specified file from storage."""
38         return self._open(name, mode)
39 
40     def save(self, name, content, max_length=None):
41         """
42         Save new content to the file specified by name. The content should be
43         a proper File object or any Python file-like object, ready to be read
44         from the beginning.
45         """
46         # Get the proper name for the file, as it will actually be saved.
47         if name is None:
48             name = content.name
49 
50         if not hasattr(content, 'chunks'):
51             content = File(content, name)
52 
53         name = self.get_available_name(name, max_length=max_length)
54         return self._save(name, content)
55 
56     # These methods are part of the public API, with default implementations.
57 
58     def get_valid_name(self, name):
59         """
60         Return a filename, based on the provided filename, that's suitable for
61         use in the target storage system.
62         """
63         return get_valid_filename(name)
64 
65     def get_alternative_name(self, file_root, file_ext):
66         """
67         Return an alternative filename, by adding an underscore and a random 7
68         character alphanumeric string (before the file extension, if one
69         exists) to the filename.
70         """
71         return '%s_%s%s' % (file_root, get_random_string(7), file_ext)
72 
73     def get_available_name(self, name, max_length=None):
74         """
75         Return a filename that's free on the target storage system and
76         available for new content to be written to.
77         """
78         dir_name, file_name = os.path.split(name)
79         if '..' in pathlib.PurePath(dir_name).parts:
80             raise SuspiciousFileOperation("Detected path traversal attempt in '%s'" % dir_name)
81         validate_file_name(file_name)
82         file_root, file_ext = os.path.splitext(file_name)
83         # If the filename already exists, generate an alternative filename
84         # until it doesn't exist.
85         # Truncate original name if required, so the new filename does not
86         # exceed the max_length.
87         while self.exists(name) or (max_length and len(name) > max_length):
88             # file_ext includes the dot.
89             name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
90             if max_length is None:
91                 continue
92             # Truncate file_root if max_length exceeded.
93             truncation = len(name) - max_length
94             if truncation > 0:
95                 file_root = file_root[:-truncation]
96                 # Entire file_root was truncated in attempt to find an available filename.
97                 if not file_root:
98                     raise SuspiciousFileOperation(
99                         'Storage can not find an available filename for "%s". '
100                         'Please make sure that the corresponding file field '
101                         'allows sufficient "max_length".' % name
102                     )
103                 name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
104         return name
105 
106     def generate_filename(self, filename):
107         """
108         Validate the filename by calling get_valid_name() and return a filename
109         to be passed to the save() method.
110         """
111         # `filename` may include a path as returned by FileField.upload_to.
112         dirname, filename = os.path.split(filename)
113         if '..' in pathlib.PurePath(dirname).parts:
114             raise SuspiciousFileOperation("Detected path traversal attempt in '%s'" % dirname)
115         return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))
116 
117     def path(self, name):
118         """
119         Return a local filesystem path where the file can be retrieved using
120         Python's built-in open() function. Storage systems that can't be
121         accessed using open() should *not* implement this method.
122         """
123         raise NotImplementedError("This backend doesn't support absolute paths.")
124 
125     # The following methods form the public API for storage systems, but with
126     # no default implementations. Subclasses must implement *all* of these.
127 
128     def delete(self, name):
129         """
130         Delete the specified file from the storage system.
131         """
132         raise NotImplementedError('subclasses of Storage must provide a delete() method')
133 
134     def exists(self, name):
135         """
136         Return True if a file referenced by the given name already exists in the
137         storage system, or False if the name is available for a new file.
138         """
139         raise NotImplementedError('subclasses of Storage must provide an exists() method')
140 
141     def listdir(self, path):
142         """
143         List the contents of the specified path. Return a 2-tuple of lists:
144         the first item being directories, the second item being files.
145         """
146         raise NotImplementedError('subclasses of Storage must provide a listdir() method')
147 
148     def size(self, name):
149         """
150         Return the total size, in bytes, of the file specified by name.
151         """
152         raise NotImplementedError('subclasses of Storage must provide a size() method')
153 
154     def url(self, name):
155         """
156         Return an absolute URL where the file's contents can be accessed
157         directly by a Web browser.
158         """
159         raise NotImplementedError('subclasses of Storage must provide a url() method')
160 
161     def get_accessed_time(self, name):
162         """
163         Return the last accessed time (as a datetime) of the file specified by
164         name. The datetime will be timezone-aware if USE_TZ=True.
165         """
166         raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')
167 
168     def get_created_time(self, name):
169         """
170         Return the creation time (as a datetime) of the file specified by name.
171         The datetime will be timezone-aware if USE_TZ=True.
172         """
173         raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')
174 
175     def get_modified_time(self, name):
176         """
177         Return the last modified time (as a datetime) of the file specified by
178         name. The datetime will be timezone-aware if USE_TZ=True.
179         """
180         raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')
181 
182 
183 @deconstructible
184 class FileSystemStorage(Storage):
185     """
186     Standard filesystem storage
187     """
188     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if
189     # the file already exists before it's opened.
190     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)
191 
192     def __init__(self, location=None, base_url=None, file_permissions_mode=None,
193                  directory_permissions_mode=None):
194         self._location = location
195         self._base_url = base_url
196         self._file_permissions_mode = file_permissions_mode
197         self._directory_permissions_mode = directory_permissions_mode
198         setting_changed.connect(self._clear_cached_properties)
199 
200     def _clear_cached_properties(self, setting, **kwargs):
201         """Reset setting based property values."""
202         if setting == 'MEDIA_ROOT':
203             self.__dict__.pop('base_location', None)
204             self.__dict__.pop('location', None)
205         elif setting == 'MEDIA_URL':
206             self.__dict__.pop('base_url', None)
207         elif setting == 'FILE_UPLOAD_PERMISSIONS':
208             self.__dict__.pop('file_permissions_mode', None)
209         elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':
210             self.__dict__.pop('directory_permissions_mode', None)
211 
212     def _value_or_setting(self, value, setting):
213         return setting if value is None else value
214 
215     @cached_property
216     def base_location(self):
217         return self._value_or_setting(self._location, settings.MEDIA_ROOT)
218 
219     @cached_property
220     def location(self):
221         return os.path.abspath(self.base_location)
222 
223     @cached_property
224     def base_url(self):
225         if self._base_url is not None and not self._base_url.endswith('/'):
226             self._base_url += '/'
227         return self._value_or_setting(self._base_url, settings.MEDIA_URL)
228 
229     @cached_property
230     def file_permissions_mode(self):
231         return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)
232 
233     @cached_property
234     def directory_permissions_mode(self):
235         return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)
236 
237     def _open(self, name, mode='rb'):
238         return File(open(self.path(name), mode))
239 
240     def _save(self, name, content):
241         full_path = self.path(name)
242 
243         # Create any intermediate directories that do not exist.
244         directory = os.path.dirname(full_path)
245         try:
246             if self.directory_permissions_mode is not None:
247                 # Set the umask because os.makedirs() doesn't apply the "mode"
248                 # argument to intermediate-level directories.
249                 old_umask = os.umask(0o777 & ~self.directory_permissions_mode)
250                 try:
251                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)
252                 finally:
253                     os.umask(old_umask)
254             else:
255                 os.makedirs(directory, exist_ok=True)
256         except FileExistsError:
257             raise FileExistsError('%s exists and is not a directory.' % directory)
258 
259         # There's a potential race condition between get_available_name and
260         # saving the file; it's possible that two threads might return the
261         # same name, at which point all sorts of fun happens. So we need to
262         # try to create the file, but if it already exists we have to go back
263         # to get_available_name() and try again.
264 
265         while True:
266             try:
267                 # This file has a file path that we can move.
268                 if hasattr(content, 'temporary_file_path'):
269                     file_move_safe(content.temporary_file_path(), full_path)
270 
271                 # This is a normal uploadedfile that we can stream.
272                 else:
273                     # The current umask value is masked out by os.open!
274                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)
275                     _file = None
276                     try:
277                         locks.lock(fd, locks.LOCK_EX)
278                         for chunk in content.chunks():
279                             if _file is None:
280                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'
281                                 _file = os.fdopen(fd, mode)
282                             _file.write(chunk)
283                     finally:
284                         locks.unlock(fd)
285                         if _file is not None:
286                             _file.close()
287                         else:
288                             os.close(fd)
289             except FileExistsError:
290                 # A new name is needed if the file exists.
291                 name = self.get_available_name(name)
292                 full_path = self.path(name)
293             else:
294                 # OK, the file save worked. Break out of the loop.
295                 break
296 
297         if self.file_permissions_mode is not None:
298             os.chmod(full_path, self.file_permissions_mode)
299 
300         # Store filenames with forward slashes, even on Windows.
301         return str(name).replace('\\', '/')
302 
303     def delete(self, name):
304         if not name:
305             raise ValueError('The name must be given to delete().')
306         name = self.path(name)
307         # If the file or directory exists, delete it from the filesystem.
308         try:
309             if os.path.isdir(name):
310                 os.rmdir(name)
311             else:
312                 os.remove(name)
313         except FileNotFoundError:
314             # FileNotFoundError is raised if the file or directory was removed
315             # concurrently.
316             pass
317 
318     def exists(self, name):
319         return os.path.lexists(self.path(name))
320 
321     def listdir(self, path):
322         path = self.path(path)
323         directories, files = [], []
324         with os.scandir(path) as entries:
325             for entry in entries:
326                 if entry.is_dir():
327                     directories.append(entry.name)
328                 else:
329                     files.append(entry.name)
330         return directories, files
331 
332     def path(self, name):
333         return safe_join(self.location, name)
334 
335     def size(self, name):
336         return os.path.getsize(self.path(name))
337 
338     def url(self, name):
339         if self.base_url is None:
340             raise ValueError("This file is not accessible via a URL.")
341         url = filepath_to_uri(name)
342         if url is not None:
343             url = url.lstrip('/')
344         return urljoin(self.base_url, url)
345 
346     def _datetime_from_timestamp(self, ts):
347         """
348         If timezone support is enabled, make an aware datetime object in UTC;
349         otherwise make a naive one in the local timezone.
350         """
351         tz = timezone.utc if settings.USE_TZ else None
352         return datetime.fromtimestamp(ts, tz=tz)
353 
354     def get_accessed_time(self, name):
355         return self._datetime_from_timestamp(os.path.getatime(self.path(name)))
356 
357     def get_created_time(self, name):
358         return self._datetime_from_timestamp(os.path.getctime(self.path(name)))
359 
360     def get_modified_time(self, name):
361         return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))
362 
363 
364 def get_storage_class(import_path=None):
365     return import_string(import_path or settings.DEFAULT_FILE_STORAGE)
366 
367 
368 class DefaultStorage(LazyObject):
369     def _setup(self):
370         self._wrapped = get_storage_class()()
371 
372 
373 default_storage = DefaultStorage()

</code><intended_behavior>The intended behavior at this location should include robust error handling that can differentiate between CSRF errors and storage-related errors. When an issue is detected with file storage (e.g., MEDIA_ROOT misconfiguration or inaccessible), the system should raise a clear and specific exception related to storage instead of deferring to a CSRF error. This distinction ensures administrators and developers can quickly diagnose and rectify configuration issues or filesystem permissions rather than being misled by incorrect CSRF failure messages.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import string
9 from collections import defaultdict
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.http.request import HttpHeaders
15 from django.urls import get_callable
16 from django.utils.cache import patch_vary_headers
17 from django.utils.crypto import constant_time_compare, get_random_string
18 from django.utils.deprecation import MiddlewareMixin
19 from django.utils.functional import cached_property
20 from django.utils.http import is_same_domain
21 from django.utils.log import log_response
22 from django.utils.regex_helper import _lazy_re_compile
23 
24 logger = logging.getLogger('django.security.csrf')
25 # This matches if any character is not in CSRF_ALLOWED_CHARS.
26 invalid_token_chars_re = _lazy_re_compile('[^a-zA-Z0-9]')
27 
28 REASON_BAD_ORIGIN = "Origin checking failed - %s does not match any trusted origins."
29 REASON_NO_REFERER = "Referer checking failed - no Referer."
30 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
31 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
32 REASON_CSRF_TOKEN_MISSING = 'CSRF token missing.'
33 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
34 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
35 # The reason strings below are for passing to InvalidTokenFormat. They are
36 # phrases without a subject because they can be in reference to either the CSRF
37 # cookie or non-cookie token.
38 REASON_INCORRECT_LENGTH = 'has incorrect length'
39 REASON_INVALID_CHARACTERS = 'has invalid characters'
40 
41 CSRF_SECRET_LENGTH = 32
42 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
43 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
44 CSRF_SESSION_KEY = '_csrftoken'
45 
46 
47 def _get_failure_view():
48     """Return the view to be used for CSRF rejections."""
49     return get_callable(settings.CSRF_FAILURE_VIEW)
50 
51 
52 def _get_new_csrf_string():
53     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
54 
55 
56 def _mask_cipher_secret(secret):
57     """
58     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
59     token by adding a mask and applying it to the secret.
60     """
61     mask = _get_new_csrf_string()
62     chars = CSRF_ALLOWED_CHARS
63     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))
64     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
65     return mask + cipher
66 
67 
68 def _unmask_cipher_token(token):
69     """
70     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
71     CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt
72     the second half to produce the original secret.
73     """
74     mask = token[:CSRF_SECRET_LENGTH]
75     token = token[CSRF_SECRET_LENGTH:]
76     chars = CSRF_ALLOWED_CHARS
77     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))
78     return ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
79 
80 
81 def _get_new_csrf_token():
82     return _mask_cipher_secret(_get_new_csrf_string())
83 
84 
85 def get_token(request):
86     """
87     Return the CSRF token required for a POST form. The token is an
88     alphanumeric value. A new token is created if one is not already set.
89 
90     A side effect of calling this function is to make the csrf_protect
91     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
92     header to the outgoing response.  For this reason, you may need to use this
93     function lazily, as is done by the csrf context processor.
94     """
95     if "CSRF_COOKIE" not in request.META:
96         csrf_secret = _get_new_csrf_string()
97         request.META["CSRF_COOKIE"] = _mask_cipher_secret(csrf_secret)
98     else:
99         csrf_secret = _unmask_cipher_token(request.META["CSRF_COOKIE"])
100     request.META["CSRF_COOKIE_USED"] = True
101     return _mask_cipher_secret(csrf_secret)
102 
103 
104 def rotate_token(request):
105     """
106     Change the CSRF token in use for a request - should be done on login
107     for security purposes.
108     """
109     request.META.update({
110         "CSRF_COOKIE_USED": True,
111         "CSRF_COOKIE": _get_new_csrf_token(),
112     })
113     request.csrf_cookie_needs_reset = True
114 
115 
116 class InvalidTokenFormat(Exception):
117     def __init__(self, reason):
118         self.reason = reason
119 
120 
121 def _sanitize_token(token):
122     if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):
123         raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)
124     # Make sure all characters are in CSRF_ALLOWED_CHARS.
125     if invalid_token_chars_re.search(token):
126         raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)
127     if len(token) == CSRF_SECRET_LENGTH:
128         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
129         # alphanumeric characters. For backwards compatibility, accept
130         # such values as unmasked secrets.
131         # It's easier to mask here and be consistent later, rather than add
132         # different code paths in the checks, although that might be a tad more
133         # efficient.
134         return _mask_cipher_secret(token)
135     return token
136 
137 
138 def _compare_masked_tokens(request_csrf_token, csrf_token):
139     # Assume both arguments are sanitized -- that is, strings of
140     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
141     return constant_time_compare(
142         _unmask_cipher_token(request_csrf_token),
143         _unmask_cipher_token(csrf_token),
144     )
145 
146 
147 class RejectRequest(Exception):
148     def __init__(self, reason):
149         self.reason = reason
150 
151 
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             # This can raise InvalidTokenFormat.
221             csrf_token = _sanitize_token(cookie_token)
222 
223             if csrf_token != cookie_token:
224                 # Then the cookie token had length CSRF_SECRET_LENGTH, so flag
225                 # to replace it with the masked version.
226                 request.csrf_cookie_needs_reset = True
227             return csrf_token
228 
229     def _set_token(self, request, response):
230         if settings.CSRF_USE_SESSIONS:
231             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
232                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
233         else:
234             response.set_cookie(
235                 settings.CSRF_COOKIE_NAME,
236                 request.META['CSRF_COOKIE'],
237                 max_age=settings.CSRF_COOKIE_AGE,
238                 domain=settings.CSRF_COOKIE_DOMAIN,
239                 path=settings.CSRF_COOKIE_PATH,
240                 secure=settings.CSRF_COOKIE_SECURE,
241                 httponly=settings.CSRF_COOKIE_HTTPONLY,
242                 samesite=settings.CSRF_COOKIE_SAMESITE,
243             )
244             # Set the Vary header since content varies with the CSRF cookie.
245             patch_vary_headers(response, ('Cookie',))
246 
247     def _origin_verified(self, request):
248         request_origin = request.META['HTTP_ORIGIN']
249         try:
250             good_host = request.get_host()
251         except DisallowedHost:
252             pass
253         else:
254             good_origin = '%s://%s' % (
255                 'https' if request.is_secure() else 'http',
256                 good_host,
257             )
258             if request_origin == good_origin:
259                 return True
260         if request_origin in self.allowed_origins_exact:
261             return True
262         try:
263             parsed_origin = urlparse(request_origin)
264         except ValueError:
265             return False
266         request_scheme = parsed_origin.scheme
267         request_netloc = parsed_origin.netloc
268         return any(
269             is_same_domain(request_netloc, host)
270             for host in self.allowed_origin_subdomains.get(request_scheme, ())
271         )
272 
273     def _check_referer(self, request):
274         referer = request.META.get('HTTP_REFERER')
275         if referer is None:
276             raise RejectRequest(REASON_NO_REFERER)
277 
278         try:
279             referer = urlparse(referer)
280         except ValueError:
281             raise RejectRequest(REASON_MALFORMED_REFERER)
282 
283         # Make sure we have a valid URL for Referer.
284         if '' in (referer.scheme, referer.netloc):
285             raise RejectRequest(REASON_MALFORMED_REFERER)
286 
287         # Ensure that our Referer is also secure.
288         if referer.scheme != 'https':
289             raise RejectRequest(REASON_INSECURE_REFERER)
290 
291         if any(
292             is_same_domain(referer.netloc, host)
293             for host in self.csrf_trusted_origins_hosts
294         ):
295             return
296         # Allow matching the configured cookie domain.
297         good_referer = (
298             settings.SESSION_COOKIE_DOMAIN
299             if settings.CSRF_USE_SESSIONS
300             else settings.CSRF_COOKIE_DOMAIN
301         )
302         if good_referer is None:
303             # If no cookie domain is configured, allow matching the current
304             # host:port exactly if it's permitted by ALLOWED_HOSTS.
305             try:
306                 # request.get_host() includes the port.
307                 good_referer = request.get_host()
308             except DisallowedHost:
309                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
310         else:
311             server_port = request.get_port()
312             if server_port not in ('443', '80'):
313                 good_referer = '%s:%s' % (good_referer, server_port)
314 
315         if not is_same_domain(referer.netloc, good_referer):
316             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
317 
318     def _bad_token_message(self, reason, token_source):
319         if token_source != 'POST':
320             # Assume it is a settings.CSRF_HEADER_NAME value.
321             header_name = HttpHeaders.parse_header_name(token_source)
322             token_source = f'the {header_name!r} HTTP header'
323         return f'CSRF token from {token_source} {reason}.'
324 
325     def _check_token(self, request):
326         # Access csrf_token via self._get_token() as rotate_token() may have
327         # been called by an authentication middleware during the
328         # process_request() phase.
329         try:
330             csrf_token = self._get_token(request)
331         except InvalidTokenFormat as exc:
332             raise RejectRequest(f'CSRF cookie {exc.reason}.')
333 
334         if csrf_token is None:
335             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
336             # and in this way we can avoid all CSRF attacks, including login
337             # CSRF.
338             raise RejectRequest(REASON_NO_CSRF_COOKIE)
339 
340         # Check non-cookie token for match.
341         request_csrf_token = ''
342         if request.method == 'POST':
343             try:
344                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
345             except OSError:
346                 # Handle a broken connection before we've completed reading the
347                 # POST data. process_view shouldn't raise any exceptions, so
348                 # we'll ignore and serve the user a 403 (assuming they're still
349                 # listening, which they probably aren't because of the error).
350                 pass
351 
352         if request_csrf_token == '':
353             # Fall back to X-CSRFToken, to make things easier for AJAX, and
354             # possible for PUT/DELETE.
355             try:
356                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
357             except KeyError:
358                 raise RejectRequest(REASON_CSRF_TOKEN_MISSING)
359             token_source = settings.CSRF_HEADER_NAME
360         else:
361             token_source = 'POST'
362 
363         try:
364             request_csrf_token = _sanitize_token(request_csrf_token)
365         except InvalidTokenFormat as exc:
366             reason = self._bad_token_message(exc.reason, token_source)
367             raise RejectRequest(reason)
368 
369         if not _compare_masked_tokens(request_csrf_token, csrf_token):
370             reason = self._bad_token_message('incorrect', token_source)
371             raise RejectRequest(reason)
372 
373     def process_request(self, request):
374         try:
375             csrf_token = self._get_token(request)
376         except InvalidTokenFormat:
377             csrf_token = _get_new_csrf_token()
378             request.csrf_cookie_needs_reset = True
379 
380         if csrf_token is not None:
381             # Use same token next time.
382             request.META['CSRF_COOKIE'] = csrf_token
383 
384     def process_view(self, request, callback, callback_args, callback_kwargs):
385         if getattr(request, 'csrf_processing_done', False):
386             return None
387 
388         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
389         # bailing out, so that get_token still works
390         if getattr(callback, 'csrf_exempt', False):
391             return None
392 
393         # Assume that anything not defined as 'safe' by RFC7231 needs protection
394         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
395             return self._accept(request)
396 
397         if getattr(request, '_dont_enforce_csrf_checks', False):
398             # Mechanism to turn off CSRF checks for test suite. It comes after
399             # the creation of CSRF cookies, so that everything else continues
400             # to work exactly the same (e.g. cookies are sent, etc.), but
401             # before any branches that call the _reject method.
402             return self._accept(request)
403 
404         # Reject the request if the Origin header doesn't match an allowed
405         # value.
406         if 'HTTP_ORIGIN' in request.META:
407             if not self._origin_verified(request):
408                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
409         elif request.is_secure():
410             # If the Origin header wasn't provided, reject HTTPS requests if
411             # the Referer header doesn't match an allowed value.
412             #
413             # Suppose user visits http://example.com/
414             # An active network attacker (man-in-the-middle, MITM) sends a
415             # POST form that targets https://example.com/detonate-bomb/ and
416             # submits it via JavaScript.
417             #
418             # The attacker will need to provide a CSRF cookie and token, but
419             # that's no problem for a MITM and the session-independent secret
420             # we're using. So the MITM can circumvent the CSRF protection. This
421             # is true for any HTTP connection, but anyone using HTTPS expects
422             # better! For this reason, for https://example.com/ we need
423             # additional protection that treats http://example.com/ as
424             # completely untrusted. Under HTTPS, Barth et al. found that the
425             # Referer header is missing for same-domain requests in only about
426             # 0.2% of cases or less, so we can use strict Referer checking.
427             try:
428                 self._check_referer(request)
429             except RejectRequest as exc:
430                 return self._reject(request, exc.reason)
431 
432         try:
433             self._check_token(request)
434         except RejectRequest as exc:
435             return self._reject(request, exc.reason)
436 
437         return self._accept(request)
438 
439     def process_response(self, request, response):
440         # Send the CSRF cookie whenever the cookie is being used (even if the
441         # client already has it) in order to renew the expiry timer, but only
442         # if it hasn't already been sent during this request-response cycle.
443         # Also, send the cookie no matter what if a reset was requested.
444         if (
445             getattr(request, 'csrf_cookie_needs_reset', False) or (
446                 request.META.get('CSRF_COOKIE_USED') and
447                 not getattr(response, 'csrf_cookie_set', False)
448             )
449         ):
450             self._set_token(request, response)
451             # Update state to prevent _set_token() from being unnecessarily
452             # called again in process_response() by other instances of
453             # CsrfViewMiddleware. This can happen e.g. when both a decorator
454             # and middleware are used. However, the csrf_cookie_needs_reset
455             # attribute is still respected in subsequent calls e.g. in case
456             # rotate_token() is called in process_response() later by custom
457             # middleware but before those subsequent calls.
458             response.csrf_cookie_set = True
459             request.csrf_cookie_needs_reset = False
460 
461         return response

</code><intended_behavior>This middleware should include exception handling that accurately reflects when an error is due to CSRF issues versus other errors thrown during the request process, such as those arising from file upload problems. If a request fails due to a storage issue in the process of file upload, the CSRF middleware should not overwrite or mask this error with a CSRF verification failure. Instead, it should allow storage or filesystem errors to pass through unchanged or be logged appropriately, aiding in debugging and system administration.</intended_behavior>]
2025-10-17 13:08:12.805 | INFO     | Search completed. Bug locations: [<file>django/core/files/storage.py</file>
<class>None</class>
<method>None</method>
<code>
1 import os
2 import pathlib
3 from datetime import datetime
4 from urllib.parse import urljoin
5 
6 from django.conf import settings
7 from django.core.exceptions import SuspiciousFileOperation
8 from django.core.files import File, locks
9 from django.core.files.move import file_move_safe
10 from django.core.files.utils import validate_file_name
11 from django.core.signals import setting_changed
12 from django.utils import timezone
13 from django.utils._os import safe_join
14 from django.utils.crypto import get_random_string
15 from django.utils.deconstruct import deconstructible
16 from django.utils.encoding import filepath_to_uri
17 from django.utils.functional import LazyObject, cached_property
18 from django.utils.module_loading import import_string
19 from django.utils.text import get_valid_filename
20 
21 __all__ = (
22     'Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage',
23     'get_storage_class',
24 )
25 
26 
27 class Storage:
28     """
29     A base storage class, providing some default behaviors that all other
30     storage systems can inherit or override, as necessary.
31     """
32 
33     # The following methods represent a public interface to private methods.
34     # These shouldn't be overridden by subclasses unless absolutely necessary.
35 
36     def open(self, name, mode='rb'):
37         """Retrieve the specified file from storage."""
38         return self._open(name, mode)
39 
40     def save(self, name, content, max_length=None):
41         """
42         Save new content to the file specified by name. The content should be
43         a proper File object or any Python file-like object, ready to be read
44         from the beginning.
45         """
46         # Get the proper name for the file, as it will actually be saved.
47         if name is None:
48             name = content.name
49 
50         if not hasattr(content, 'chunks'):
51             content = File(content, name)
52 
53         name = self.get_available_name(name, max_length=max_length)
54         return self._save(name, content)
55 
56     # These methods are part of the public API, with default implementations.
57 
58     def get_valid_name(self, name):
59         """
60         Return a filename, based on the provided filename, that's suitable for
61         use in the target storage system.
62         """
63         return get_valid_filename(name)
64 
65     def get_alternative_name(self, file_root, file_ext):
66         """
67         Return an alternative filename, by adding an underscore and a random 7
68         character alphanumeric string (before the file extension, if one
69         exists) to the filename.
70         """
71         return '%s_%s%s' % (file_root, get_random_string(7), file_ext)
72 
73     def get_available_name(self, name, max_length=None):
74         """
75         Return a filename that's free on the target storage system and
76         available for new content to be written to.
77         """
78         dir_name, file_name = os.path.split(name)
79         if '..' in pathlib.PurePath(dir_name).parts:
80             raise SuspiciousFileOperation("Detected path traversal attempt in '%s'" % dir_name)
81         validate_file_name(file_name)
82         file_root, file_ext = os.path.splitext(file_name)
83         # If the filename already exists, generate an alternative filename
84         # until it doesn't exist.
85         # Truncate original name if required, so the new filename does not
86         # exceed the max_length.
87         while self.exists(name) or (max_length and len(name) > max_length):
88             # file_ext includes the dot.
89             name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
90             if max_length is None:
91                 continue
92             # Truncate file_root if max_length exceeded.
93             truncation = len(name) - max_length
94             if truncation > 0:
95                 file_root = file_root[:-truncation]
96                 # Entire file_root was truncated in attempt to find an available filename.
97                 if not file_root:
98                     raise SuspiciousFileOperation(
99                         'Storage can not find an available filename for "%s". '
100                         'Please make sure that the corresponding file field '
101                         'allows sufficient "max_length".' % name
102                     )
103                 name = os.path.join(dir_name, self.get_alternative_name(file_root, file_ext))
104         return name
105 
106     def generate_filename(self, filename):
107         """
108         Validate the filename by calling get_valid_name() and return a filename
109         to be passed to the save() method.
110         """
111         # `filename` may include a path as returned by FileField.upload_to.
112         dirname, filename = os.path.split(filename)
113         if '..' in pathlib.PurePath(dirname).parts:
114             raise SuspiciousFileOperation("Detected path traversal attempt in '%s'" % dirname)
115         return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))
116 
117     def path(self, name):
118         """
119         Return a local filesystem path where the file can be retrieved using
120         Python's built-in open() function. Storage systems that can't be
121         accessed using open() should *not* implement this method.
122         """
123         raise NotImplementedError("This backend doesn't support absolute paths.")
124 
125     # The following methods form the public API for storage systems, but with
126     # no default implementations. Subclasses must implement *all* of these.
127 
128     def delete(self, name):
129         """
130         Delete the specified file from the storage system.
131         """
132         raise NotImplementedError('subclasses of Storage must provide a delete() method')
133 
134     def exists(self, name):
135         """
136         Return True if a file referenced by the given name already exists in the
137         storage system, or False if the name is available for a new file.
138         """
139         raise NotImplementedError('subclasses of Storage must provide an exists() method')
140 
141     def listdir(self, path):
142         """
143         List the contents of the specified path. Return a 2-tuple of lists:
144         the first item being directories, the second item being files.
145         """
146         raise NotImplementedError('subclasses of Storage must provide a listdir() method')
147 
148     def size(self, name):
149         """
150         Return the total size, in bytes, of the file specified by name.
151         """
152         raise NotImplementedError('subclasses of Storage must provide a size() method')
153 
154     def url(self, name):
155         """
156         Return an absolute URL where the file's contents can be accessed
157         directly by a Web browser.
158         """
159         raise NotImplementedError('subclasses of Storage must provide a url() method')
160 
161     def get_accessed_time(self, name):
162         """
163         Return the last accessed time (as a datetime) of the file specified by
164         name. The datetime will be timezone-aware if USE_TZ=True.
165         """
166         raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')
167 
168     def get_created_time(self, name):
169         """
170         Return the creation time (as a datetime) of the file specified by name.
171         The datetime will be timezone-aware if USE_TZ=True.
172         """
173         raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')
174 
175     def get_modified_time(self, name):
176         """
177         Return the last modified time (as a datetime) of the file specified by
178         name. The datetime will be timezone-aware if USE_TZ=True.
179         """
180         raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')
181 
182 
183 @deconstructible
184 class FileSystemStorage(Storage):
185     """
186     Standard filesystem storage
187     """
188     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if
189     # the file already exists before it's opened.
190     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)
191 
192     def __init__(self, location=None, base_url=None, file_permissions_mode=None,
193                  directory_permissions_mode=None):
194         self._location = location
195         self._base_url = base_url
196         self._file_permissions_mode = file_permissions_mode
197         self._directory_permissions_mode = directory_permissions_mode
198         setting_changed.connect(self._clear_cached_properties)
199 
200     def _clear_cached_properties(self, setting, **kwargs):
201         """Reset setting based property values."""
202         if setting == 'MEDIA_ROOT':
203             self.__dict__.pop('base_location', None)
204             self.__dict__.pop('location', None)
205         elif setting == 'MEDIA_URL':
206             self.__dict__.pop('base_url', None)
207         elif setting == 'FILE_UPLOAD_PERMISSIONS':
208             self.__dict__.pop('file_permissions_mode', None)
209         elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':
210             self.__dict__.pop('directory_permissions_mode', None)
211 
212     def _value_or_setting(self, value, setting):
213         return setting if value is None else value
214 
215     @cached_property
216     def base_location(self):
217         return self._value_or_setting(self._location, settings.MEDIA_ROOT)
218 
219     @cached_property
220     def location(self):
221         return os.path.abspath(self.base_location)
222 
223     @cached_property
224     def base_url(self):
225         if self._base_url is not None and not self._base_url.endswith('/'):
226             self._base_url += '/'
227         return self._value_or_setting(self._base_url, settings.MEDIA_URL)
228 
229     @cached_property
230     def file_permissions_mode(self):
231         return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)
232 
233     @cached_property
234     def directory_permissions_mode(self):
235         return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)
236 
237     def _open(self, name, mode='rb'):
238         return File(open(self.path(name), mode))
239 
240     def _save(self, name, content):
241         full_path = self.path(name)
242 
243         # Create any intermediate directories that do not exist.
244         directory = os.path.dirname(full_path)
245         try:
246             if self.directory_permissions_mode is not None:
247                 # Set the umask because os.makedirs() doesn't apply the "mode"
248                 # argument to intermediate-level directories.
249                 old_umask = os.umask(0o777 & ~self.directory_permissions_mode)
250                 try:
251                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)
252                 finally:
253                     os.umask(old_umask)
254             else:
255                 os.makedirs(directory, exist_ok=True)
256         except FileExistsError:
257             raise FileExistsError('%s exists and is not a directory.' % directory)
258 
259         # There's a potential race condition between get_available_name and
260         # saving the file; it's possible that two threads might return the
261         # same name, at which point all sorts of fun happens. So we need to
262         # try to create the file, but if it already exists we have to go back
263         # to get_available_name() and try again.
264 
265         while True:
266             try:
267                 # This file has a file path that we can move.
268                 if hasattr(content, 'temporary_file_path'):
269                     file_move_safe(content.temporary_file_path(), full_path)
270 
271                 # This is a normal uploadedfile that we can stream.
272                 else:
273                     # The current umask value is masked out by os.open!
274                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)
275                     _file = None
276                     try:
277                         locks.lock(fd, locks.LOCK_EX)
278                         for chunk in content.chunks():
279                             if _file is None:
280                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'
281                                 _file = os.fdopen(fd, mode)
282                             _file.write(chunk)
283                     finally:
284                         locks.unlock(fd)
285                         if _file is not None:
286                             _file.close()
287                         else:
288                             os.close(fd)
289             except FileExistsError:
290                 # A new name is needed if the file exists.
291                 name = self.get_available_name(name)
292                 full_path = self.path(name)
293             else:
294                 # OK, the file save worked. Break out of the loop.
295                 break
296 
297         if self.file_permissions_mode is not None:
298             os.chmod(full_path, self.file_permissions_mode)
299 
300         # Store filenames with forward slashes, even on Windows.
301         return str(name).replace('\\', '/')
302 
303     def delete(self, name):
304         if not name:
305             raise ValueError('The name must be given to delete().')
306         name = self.path(name)
307         # If the file or directory exists, delete it from the filesystem.
308         try:
309             if os.path.isdir(name):
310                 os.rmdir(name)
311             else:
312                 os.remove(name)
313         except FileNotFoundError:
314             # FileNotFoundError is raised if the file or directory was removed
315             # concurrently.
316             pass
317 
318     def exists(self, name):
319         return os.path.lexists(self.path(name))
320 
321     def listdir(self, path):
322         path = self.path(path)
323         directories, files = [], []
324         with os.scandir(path) as entries:
325             for entry in entries:
326                 if entry.is_dir():
327                     directories.append(entry.name)
328                 else:
329                     files.append(entry.name)
330         return directories, files
331 
332     def path(self, name):
333         return safe_join(self.location, name)
334 
335     def size(self, name):
336         return os.path.getsize(self.path(name))
337 
338     def url(self, name):
339         if self.base_url is None:
340             raise ValueError("This file is not accessible via a URL.")
341         url = filepath_to_uri(name)
342         if url is not None:
343             url = url.lstrip('/')
344         return urljoin(self.base_url, url)
345 
346     def _datetime_from_timestamp(self, ts):
347         """
348         If timezone support is enabled, make an aware datetime object in UTC;
349         otherwise make a naive one in the local timezone.
350         """
351         tz = timezone.utc if settings.USE_TZ else None
352         return datetime.fromtimestamp(ts, tz=tz)
353 
354     def get_accessed_time(self, name):
355         return self._datetime_from_timestamp(os.path.getatime(self.path(name)))
356 
357     def get_created_time(self, name):
358         return self._datetime_from_timestamp(os.path.getctime(self.path(name)))
359 
360     def get_modified_time(self, name):
361         return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))
362 
363 
364 def get_storage_class(import_path=None):
365     return import_string(import_path or settings.DEFAULT_FILE_STORAGE)
366 
367 
368 class DefaultStorage(LazyObject):
369     def _setup(self):
370         self._wrapped = get_storage_class()()
371 
372 
373 default_storage = DefaultStorage()

</code><intended_behavior>The intended behavior at this location should include robust error handling that can differentiate between CSRF errors and storage-related errors. When an issue is detected with file storage (e.g., MEDIA_ROOT misconfiguration or inaccessible), the system should raise a clear and specific exception related to storage instead of deferring to a CSRF error. This distinction ensures administrators and developers can quickly diagnose and rectify configuration issues or filesystem permissions rather than being misled by incorrect CSRF failure messages.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import string
9 from collections import defaultdict
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.http.request import HttpHeaders
15 from django.urls import get_callable
16 from django.utils.cache import patch_vary_headers
17 from django.utils.crypto import constant_time_compare, get_random_string
18 from django.utils.deprecation import MiddlewareMixin
19 from django.utils.functional import cached_property
20 from django.utils.http import is_same_domain
21 from django.utils.log import log_response
22 from django.utils.regex_helper import _lazy_re_compile
23 
24 logger = logging.getLogger('django.security.csrf')
25 # This matches if any character is not in CSRF_ALLOWED_CHARS.
26 invalid_token_chars_re = _lazy_re_compile('[^a-zA-Z0-9]')
27 
28 REASON_BAD_ORIGIN = "Origin checking failed - %s does not match any trusted origins."
29 REASON_NO_REFERER = "Referer checking failed - no Referer."
30 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
31 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
32 REASON_CSRF_TOKEN_MISSING = 'CSRF token missing.'
33 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
34 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
35 # The reason strings below are for passing to InvalidTokenFormat. They are
36 # phrases without a subject because they can be in reference to either the CSRF
37 # cookie or non-cookie token.
38 REASON_INCORRECT_LENGTH = 'has incorrect length'
39 REASON_INVALID_CHARACTERS = 'has invalid characters'
40 
41 CSRF_SECRET_LENGTH = 32
42 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
43 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
44 CSRF_SESSION_KEY = '_csrftoken'
45 
46 
47 def _get_failure_view():
48     """Return the view to be used for CSRF rejections."""
49     return get_callable(settings.CSRF_FAILURE_VIEW)
50 
51 
52 def _get_new_csrf_string():
53     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
54 
55 
56 def _mask_cipher_secret(secret):
57     """
58     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
59     token by adding a mask and applying it to the secret.
60     """
61     mask = _get_new_csrf_string()
62     chars = CSRF_ALLOWED_CHARS
63     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))
64     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
65     return mask + cipher
66 
67 
68 def _unmask_cipher_token(token):
69     """
70     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
71     CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt
72     the second half to produce the original secret.
73     """
74     mask = token[:CSRF_SECRET_LENGTH]
75     token = token[CSRF_SECRET_LENGTH:]
76     chars = CSRF_ALLOWED_CHARS
77     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))
78     return ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
79 
80 
81 def _get_new_csrf_token():
82     return _mask_cipher_secret(_get_new_csrf_string())
83 
84 
85 def get_token(request):
86     """
87     Return the CSRF token required for a POST form. The token is an
88     alphanumeric value. A new token is created if one is not already set.
89 
90     A side effect of calling this function is to make the csrf_protect
91     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
92     header to the outgoing response.  For this reason, you may need to use this
93     function lazily, as is done by the csrf context processor.
94     """
95     if "CSRF_COOKIE" not in request.META:
96         csrf_secret = _get_new_csrf_string()
97         request.META["CSRF_COOKIE"] = _mask_cipher_secret(csrf_secret)
98     else:
99         csrf_secret = _unmask_cipher_token(request.META["CSRF_COOKIE"])
100     request.META["CSRF_COOKIE_USED"] = True
101     return _mask_cipher_secret(csrf_secret)
102 
103 
104 def rotate_token(request):
105     """
106     Change the CSRF token in use for a request - should be done on login
107     for security purposes.
108     """
109     request.META.update({
110         "CSRF_COOKIE_USED": True,
111         "CSRF_COOKIE": _get_new_csrf_token(),
112     })
113     request.csrf_cookie_needs_reset = True
114 
115 
116 class InvalidTokenFormat(Exception):
117     def __init__(self, reason):
118         self.reason = reason
119 
120 
121 def _sanitize_token(token):
122     if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):
123         raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)
124     # Make sure all characters are in CSRF_ALLOWED_CHARS.
125     if invalid_token_chars_re.search(token):
126         raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)
127     if len(token) == CSRF_SECRET_LENGTH:
128         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
129         # alphanumeric characters. For backwards compatibility, accept
130         # such values as unmasked secrets.
131         # It's easier to mask here and be consistent later, rather than add
132         # different code paths in the checks, although that might be a tad more
133         # efficient.
134         return _mask_cipher_secret(token)
135     return token
136 
137 
138 def _compare_masked_tokens(request_csrf_token, csrf_token):
139     # Assume both arguments are sanitized -- that is, strings of
140     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
141     return constant_time_compare(
142         _unmask_cipher_token(request_csrf_token),
143         _unmask_cipher_token(csrf_token),
144     )
145 
146 
147 class RejectRequest(Exception):
148     def __init__(self, reason):
149         self.reason = reason
150 
151 
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             # This can raise InvalidTokenFormat.
221             csrf_token = _sanitize_token(cookie_token)
222 
223             if csrf_token != cookie_token:
224                 # Then the cookie token had length CSRF_SECRET_LENGTH, so flag
225                 # to replace it with the masked version.
226                 request.csrf_cookie_needs_reset = True
227             return csrf_token
228 
229     def _set_token(self, request, response):
230         if settings.CSRF_USE_SESSIONS:
231             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
232                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
233         else:
234             response.set_cookie(
235                 settings.CSRF_COOKIE_NAME,
236                 request.META['CSRF_COOKIE'],
237                 max_age=settings.CSRF_COOKIE_AGE,
238                 domain=settings.CSRF_COOKIE_DOMAIN,
239                 path=settings.CSRF_COOKIE_PATH,
240                 secure=settings.CSRF_COOKIE_SECURE,
241                 httponly=settings.CSRF_COOKIE_HTTPONLY,
242                 samesite=settings.CSRF_COOKIE_SAMESITE,
243             )
244             # Set the Vary header since content varies with the CSRF cookie.
245             patch_vary_headers(response, ('Cookie',))
246 
247     def _origin_verified(self, request):
248         request_origin = request.META['HTTP_ORIGIN']
249         try:
250             good_host = request.get_host()
251         except DisallowedHost:
252             pass
253         else:
254             good_origin = '%s://%s' % (
255                 'https' if request.is_secure() else 'http',
256                 good_host,
257             )
258             if request_origin == good_origin:
259                 return True
260         if request_origin in self.allowed_origins_exact:
261             return True
262         try:
263             parsed_origin = urlparse(request_origin)
264         except ValueError:
265             return False
266         request_scheme = parsed_origin.scheme
267         request_netloc = parsed_origin.netloc
268         return any(
269             is_same_domain(request_netloc, host)
270             for host in self.allowed_origin_subdomains.get(request_scheme, ())
271         )
272 
273     def _check_referer(self, request):
274         referer = request.META.get('HTTP_REFERER')
275         if referer is None:
276             raise RejectRequest(REASON_NO_REFERER)
277 
278         try:
279             referer = urlparse(referer)
280         except ValueError:
281             raise RejectRequest(REASON_MALFORMED_REFERER)
282 
283         # Make sure we have a valid URL for Referer.
284         if '' in (referer.scheme, referer.netloc):
285             raise RejectRequest(REASON_MALFORMED_REFERER)
286 
287         # Ensure that our Referer is also secure.
288         if referer.scheme != 'https':
289             raise RejectRequest(REASON_INSECURE_REFERER)
290 
291         if any(
292             is_same_domain(referer.netloc, host)
293             for host in self.csrf_trusted_origins_hosts
294         ):
295             return
296         # Allow matching the configured cookie domain.
297         good_referer = (
298             settings.SESSION_COOKIE_DOMAIN
299             if settings.CSRF_USE_SESSIONS
300             else settings.CSRF_COOKIE_DOMAIN
301         )
302         if good_referer is None:
303             # If no cookie domain is configured, allow matching the current
304             # host:port exactly if it's permitted by ALLOWED_HOSTS.
305             try:
306                 # request.get_host() includes the port.
307                 good_referer = request.get_host()
308             except DisallowedHost:
309                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
310         else:
311             server_port = request.get_port()
312             if server_port not in ('443', '80'):
313                 good_referer = '%s:%s' % (good_referer, server_port)
314 
315         if not is_same_domain(referer.netloc, good_referer):
316             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
317 
318     def _bad_token_message(self, reason, token_source):
319         if token_source != 'POST':
320             # Assume it is a settings.CSRF_HEADER_NAME value.
321             header_name = HttpHeaders.parse_header_name(token_source)
322             token_source = f'the {header_name!r} HTTP header'
323         return f'CSRF token from {token_source} {reason}.'
324 
325     def _check_token(self, request):
326         # Access csrf_token via self._get_token() as rotate_token() may have
327         # been called by an authentication middleware during the
328         # process_request() phase.
329         try:
330             csrf_token = self._get_token(request)
331         except InvalidTokenFormat as exc:
332             raise RejectRequest(f'CSRF cookie {exc.reason}.')
333 
334         if csrf_token is None:
335             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
336             # and in this way we can avoid all CSRF attacks, including login
337             # CSRF.
338             raise RejectRequest(REASON_NO_CSRF_COOKIE)
339 
340         # Check non-cookie token for match.
341         request_csrf_token = ''
342         if request.method == 'POST':
343             try:
344                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
345             except OSError:
346                 # Handle a broken connection before we've completed reading the
347                 # POST data. process_view shouldn't raise any exceptions, so
348                 # we'll ignore and serve the user a 403 (assuming they're still
349                 # listening, which they probably aren't because of the error).
350                 pass
351 
352         if request_csrf_token == '':
353             # Fall back to X-CSRFToken, to make things easier for AJAX, and
354             # possible for PUT/DELETE.
355             try:
356                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
357             except KeyError:
358                 raise RejectRequest(REASON_CSRF_TOKEN_MISSING)
359             token_source = settings.CSRF_HEADER_NAME
360         else:
361             token_source = 'POST'
362 
363         try:
364             request_csrf_token = _sanitize_token(request_csrf_token)
365         except InvalidTokenFormat as exc:
366             reason = self._bad_token_message(exc.reason, token_source)
367             raise RejectRequest(reason)
368 
369         if not _compare_masked_tokens(request_csrf_token, csrf_token):
370             reason = self._bad_token_message('incorrect', token_source)
371             raise RejectRequest(reason)
372 
373     def process_request(self, request):
374         try:
375             csrf_token = self._get_token(request)
376         except InvalidTokenFormat:
377             csrf_token = _get_new_csrf_token()
378             request.csrf_cookie_needs_reset = True
379 
380         if csrf_token is not None:
381             # Use same token next time.
382             request.META['CSRF_COOKIE'] = csrf_token
383 
384     def process_view(self, request, callback, callback_args, callback_kwargs):
385         if getattr(request, 'csrf_processing_done', False):
386             return None
387 
388         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
389         # bailing out, so that get_token still works
390         if getattr(callback, 'csrf_exempt', False):
391             return None
392 
393         # Assume that anything not defined as 'safe' by RFC7231 needs protection
394         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
395             return self._accept(request)
396 
397         if getattr(request, '_dont_enforce_csrf_checks', False):
398             # Mechanism to turn off CSRF checks for test suite. It comes after
399             # the creation of CSRF cookies, so that everything else continues
400             # to work exactly the same (e.g. cookies are sent, etc.), but
401             # before any branches that call the _reject method.
402             return self._accept(request)
403 
404         # Reject the request if the Origin header doesn't match an allowed
405         # value.
406         if 'HTTP_ORIGIN' in request.META:
407             if not self._origin_verified(request):
408                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
409         elif request.is_secure():
410             # If the Origin header wasn't provided, reject HTTPS requests if
411             # the Referer header doesn't match an allowed value.
412             #
413             # Suppose user visits http://example.com/
414             # An active network attacker (man-in-the-middle, MITM) sends a
415             # POST form that targets https://example.com/detonate-bomb/ and
416             # submits it via JavaScript.
417             #
418             # The attacker will need to provide a CSRF cookie and token, but
419             # that's no problem for a MITM and the session-independent secret
420             # we're using. So the MITM can circumvent the CSRF protection. This
421             # is true for any HTTP connection, but anyone using HTTPS expects
422             # better! For this reason, for https://example.com/ we need
423             # additional protection that treats http://example.com/ as
424             # completely untrusted. Under HTTPS, Barth et al. found that the
425             # Referer header is missing for same-domain requests in only about
426             # 0.2% of cases or less, so we can use strict Referer checking.
427             try:
428                 self._check_referer(request)
429             except RejectRequest as exc:
430                 return self._reject(request, exc.reason)
431 
432         try:
433             self._check_token(request)
434         except RejectRequest as exc:
435             return self._reject(request, exc.reason)
436 
437         return self._accept(request)
438 
439     def process_response(self, request, response):
440         # Send the CSRF cookie whenever the cookie is being used (even if the
441         # client already has it) in order to renew the expiry timer, but only
442         # if it hasn't already been sent during this request-response cycle.
443         # Also, send the cookie no matter what if a reset was requested.
444         if (
445             getattr(request, 'csrf_cookie_needs_reset', False) or (
446                 request.META.get('CSRF_COOKIE_USED') and
447                 not getattr(response, 'csrf_cookie_set', False)
448             )
449         ):
450             self._set_token(request, response)
451             # Update state to prevent _set_token() from being unnecessarily
452             # called again in process_response() by other instances of
453             # CsrfViewMiddleware. This can happen e.g. when both a decorator
454             # and middleware are used. However, the csrf_cookie_needs_reset
455             # attribute is still respected in subsequent calls e.g. in case
456             # rotate_token() is called in process_response() later by custom
457             # middleware but before those subsequent calls.
458             response.csrf_cookie_set = True
459             request.csrf_cookie_needs_reset = False
460 
461         return response

</code><intended_behavior>This middleware should include exception handling that accurately reflects when an error is due to CSRF issues versus other errors thrown during the request process, such as those arising from file upload problems. If a request fails due to a storage issue in the process of file upload, the CSRF middleware should not overwrite or mask this error with a CSRF verification failure. Instead, it should allow storage or filesystem errors to pass through unchanged or be logged appropriately, aiding in debugging and system administration.</intended_behavior>]
2025-10-17 13:08:12.806 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 13:08:12.806 | INFO     | Search-only: skipping patch selection
2025-10-17 13:08:12.968 | INFO     | Task django__django-14681 completed successfully.
2025-10-17 13:08:12.969 | INFO     | No patch generated. You can try running ACR again.
