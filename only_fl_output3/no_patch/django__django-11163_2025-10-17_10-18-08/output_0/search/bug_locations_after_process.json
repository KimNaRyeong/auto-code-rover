[
    {
        "rel_file_path": "django/forms/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/forms/models.py",
        "start": 69,
        "end": 91,
        "class_name": null,
        "method_name": "model_to_dict",
        "code": "69 def model_to_dict(instance, fields=None, exclude=None):\n70     \"\"\"\n71     Return a dict containing the data in ``instance`` suitable for passing as\n72     a Form's ``initial`` keyword argument.\n73 \n74     ``fields`` is an optional list of field names. If provided, return only the\n75     named.\n76 \n77     ``exclude`` is an optional list of field names. If provided, exclude the\n78     named from the returned dict, even if they are listed in the ``fields``\n79     argument.\n80     \"\"\"\n81     opts = instance._meta\n82     data = {}\n83     for f in chain(opts.concrete_fields, opts.private_fields, opts.many_to_many):\n84         if not getattr(f, 'editable', False):\n85             continue\n86         if fields and f.name not in fields:\n87             continue\n88         if exclude and f.name in exclude:\n89             continue\n90         data[f.name] = f.value_from_object(instance)\n91     return data\n",
        "intended_behavior": "The condition `if fields and f.name not in fields:` should be altered to `if fields is not None and f.name not in fields:`. This change ensures that `model_to_dict` will return an empty dictionary when called with `fields=[]`, as opposed to returning a dictionary with all fields. This behavior aligns with the expected functionality, where specifying an empty list for `fields` explicitly requests no fields to be included in the output. The rest of the method's functionality, including its handling of the `exclude` parameter and its process for gathering data from the provided instance, should remain unchanged to preserve existing behavior when `fields` is specified or `None`."
    }
]