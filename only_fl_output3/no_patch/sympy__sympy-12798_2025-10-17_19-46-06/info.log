2025-10-17 19:46:07.072 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 19:46:11.410 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=125, output_tokens=12, cost=0.001610
2025-10-17 19:46:11.410 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 19:46:11.414 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:46:15.515 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=433, output_tokens=105, cost=0.007480
2025-10-17 19:46:15.518 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:46:17.438 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=459, output_tokens=27, cost=0.005400
2025-10-17 19:46:17.440 | DEBUG    | Extracted a valid json.
2025-10-17 19:46:17.440 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"ff\")", "search_method(\"rf\")"],
    "bug_locations": []
}
2025-10-17 19:46:17.445 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 19:46:17.446 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 19:46:27.740 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=685, output_tokens=413, cost=0.019240
2025-10-17 19:46:27.750 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:46:32.114 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1314, output_tokens=124, cost=0.016860
2025-10-17 19:46:32.118 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:46:33.186 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=478, output_tokens=14, cost=0.005200
2025-10-17 19:46:33.187 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:46:33.187 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 19:46:34.962 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=478, output_tokens=14, cost=0.005200
2025-10-17 19:46:34.963 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:46:34.963 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 19:46:36.212 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=478, output_tokens=14, cost=0.005200
2025-10-17 19:46:36.213 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:46:36.213 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 19:46:38.037 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=478, output_tokens=14, cost=0.005200
2025-10-17 19:46:38.039 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:46:38.044 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 19:46:39.390 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=478, output_tokens=14, cost=0.005200
2025-10-17 19:46:39.391 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:46:39.391 | DEBUG    | Agent proxy return the following json: None
2025-10-17 19:46:39.392 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 19:46:39.393 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 19:46:39.393 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:46:46.719 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1465, output_tokens=267, cost=0.022660
2025-10-17 19:46:46.724 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:46:49.336 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=621, output_tokens=27, cost=0.007020
2025-10-17 19:46:49.337 | DEBUG    | Extracted a valid json.
2025-10-17 19:46:49.337 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"ff\")", "search_code(\"rf\")"],
    "bug_locations": []
}
2025-10-17 19:47:03.829 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 19:47:03.829 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 19:47:21.852 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=12944, output_tokens=615, cost=0.147890
2025-10-17 19:47:21.862 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:47:36.250 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=13775, output_tokens=459, cost=0.151520
2025-10-17 19:47:36.259 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:47:45.964 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=813, output_tokens=240, cost=0.015330
2025-10-17 19:47:45.966 | DEBUG    | Extracted a valid json.
2025-10-17 19:47:45.966 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/functions/combinatorial/factorials.py",
            "class": "",
            "method": "",
            "intended_behavior": "The intended behavior at these locations is to compute the falling factorial and rising factorial accurately according to their mathematical definitions. This means ff(n, k) should calculate the product of k consecutive numbers starting from n and decreasing, and rf(n, k) should calculate the product of k consecutive numbers starting from n and increasing. Any previous functionality that was altered leading to incorrect computations or interface changes should be reverted to preserve the expected mathematical behavior and ensure backward compatibility."
        },
        {
            "file": "sympy/functions/combinatorial/numbers.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that any usage or reference to ff and rf within this file reflects the correct and intended mathematical definitions. If these functions' behavior was altered in a way that affects the calculations or results of combinatorial numbers, the intention would be to revert or fix these changes to align with expected outcomes."
        }
    ]
}
2025-10-17 19:47:45.973 | DEBUG    | Bug location extracted successfully: [<file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import S, sympify, Dummy, Mod
4 from sympy.core.function import Function, ArgumentIndexError
5 from sympy.core.logic import fuzzy_and
6 from sympy.core.numbers import Integer, pi
7 from sympy.core.relational import Eq
8 
9 from sympy.ntheory import sieve
10 
11 from math import sqrt as _sqrt
12 
13 from sympy.core.compatibility import reduce, range, HAS_GMPY
14 from sympy.core.cache import cacheit
15 
16 from sympy.polys.polytools import poly_from_expr
17 from sympy.polys.polyerrors import PolificationFailed
18 
19 
20 class CombinatorialFunction(Function):
21     """Base class for combinatorial functions. """
22 
23     def _eval_simplify(self, ratio, measure):
24         from sympy.simplify.simplify import combsimp
25         expr = combsimp(self)
26         if measure(expr) <= ratio*measure(self):
27             return expr
28         return self
29 
30 ###############################################################################
31 ######################## FACTORIAL and MULTI-FACTORIAL ########################
32 ###############################################################################
33 
34 
35 class factorial(CombinatorialFunction):
36     """Implementation of factorial function over nonnegative integers.
37        By convention (consistent with the gamma function and the binomial
38        coefficients), factorial of a negative integer is complex infinity.
39 
40        The factorial is very important in combinatorics where it gives
41        the number of ways in which `n` objects can be permuted. It also
42        arises in calculus, probability, number theory, etc.
43 
44        There is strict relation of factorial with gamma function. In
45        fact n! = gamma(n+1) for nonnegative integers. Rewrite of this
46        kind is very useful in case of combinatorial simplification.
47 
48        Computation of the factorial is done using two algorithms. For
49        small arguments a precomputed look up table is used. However for bigger
50        input algorithm Prime-Swing is used. It is the fastest algorithm
51        known and computes n! via prime factorization of special class
52        of numbers, called here the 'Swing Numbers'.
53 
54        Examples
55        ========
56 
57        >>> from sympy import Symbol, factorial, S
58        >>> n = Symbol('n', integer=True)
59 
60        >>> factorial(0)
61        1
62 
63        >>> factorial(7)
64        5040
65 
66        >>> factorial(-2)
67        zoo
68 
69        >>> factorial(n)
70        factorial(n)
71 
72        >>> factorial(2*n)
73        factorial(2*n)
74 
75        >>> factorial(S(1)/2)
76        factorial(1/2)
77 
78        See Also
79        ========
80 
81        factorial2, RisingFactorial, FallingFactorial
82     """
83 
84     def fdiff(self, argindex=1):
85         from sympy import gamma, polygamma
86         if argindex == 1:
87             return gamma(self.args[0] + 1)*polygamma(0, self.args[0] + 1)
88         else:
89             raise ArgumentIndexError(self, argindex)
90 
91     _small_swing = [
92         1, 1, 1, 3, 3, 15, 5, 35, 35, 315, 63, 693, 231, 3003, 429, 6435, 6435, 109395,
93         12155, 230945, 46189, 969969, 88179, 2028117, 676039, 16900975, 1300075,
94         35102025, 5014575, 145422675, 9694845, 300540195, 300540195
95     ]
96 
97     _small_factorials = []
98 
99     @classmethod
100     def _swing(cls, n):
101         if n < 33:
102             return cls._small_swing[n]
103         else:
104             N, primes = int(_sqrt(n)), []
105 
106             for prime in sieve.primerange(3, N + 1):
107                 p, q = 1, n
108 
109                 while True:
110                     q //= prime
111 
112                     if q > 0:
113                         if q & 1 == 1:
114                             p *= prime
115                     else:
116                         break
117 
118                 if p > 1:
119                     primes.append(p)
120 
121             for prime in sieve.primerange(N + 1, n//3 + 1):
122                 if (n // prime) & 1 == 1:
123                     primes.append(prime)
124 
125             L_product = R_product = 1
126 
127             for prime in sieve.primerange(n//2 + 1, n + 1):
128                 L_product *= prime
129 
130             for prime in primes:
131                 R_product *= prime
132 
133             return L_product*R_product
134 
135     @classmethod
136     def _recursive(cls, n):
137         if n < 2:
138             return 1
139         else:
140             return (cls._recursive(n//2)**2)*cls._swing(n)
141 
142     @classmethod
143     def eval(cls, n):
144         n = sympify(n)
145 
146         if n.is_Number:
147             if n is S.Zero:
148                 return S.One
149             elif n is S.Infinity:
150                 return S.Infinity
151             elif n.is_Integer:
152                 if n.is_negative:
153                     return S.ComplexInfinity
154                 else:
155                     n = n.p
156 
157                     if n < 20:
158                         if not cls._small_factorials:
159                             result = 1
160                             for i in range(1, 20):
161                                 result *= i
162                                 cls._small_factorials.append(result)
163                         result = cls._small_factorials[n-1]
164 
165                     # GMPY factorial is faster, use it when available
166                     elif HAS_GMPY:
167                         from sympy.core.compatibility import gmpy
168                         result = gmpy.fac(n)
169 
170                     else:
171                         bits = bin(n).count('1')
172                         result = cls._recursive(n)*2**(n - bits)
173 
174                     return Integer(result)
175 
176     def _eval_rewrite_as_gamma(self, n):
177         from sympy import gamma
178         return gamma(n + 1)
179 
180     def _eval_rewrite_as_Product(self, n):
181         from sympy import Product
182         if n.is_nonnegative and n.is_integer:
183             i = Dummy('i', integer=True)
184             return Product(i, (i, 1, n))
185 
186     def _eval_is_integer(self):
187         if self.args[0].is_integer and self.args[0].is_nonnegative:
188             return True
189 
190     def _eval_is_positive(self):
191         if self.args[0].is_integer and self.args[0].is_nonnegative:
192             return True
193 
194     def _eval_is_composite(self):
195         x = self.args[0]
196         if x.is_integer:
197             return (x - 3).is_nonnegative
198 
199     def _eval_is_real(self):
200         x = self.args[0]
201         if x.is_nonnegative or x.is_noninteger:
202             return True
203 
204 
205 class MultiFactorial(CombinatorialFunction):
206     pass
207 
208 
209 class subfactorial(CombinatorialFunction):
210     r"""The subfactorial counts the derangements of n items and is
211     defined for non-negative integers as::
212 
213               ,
214              |  1                             for n = 0
215         !n = {  0                             for n = 1
216              |  (n - 1)*(!(n - 1) + !(n - 2)) for n > 1
217               `
218 
219     It can also be written as int(round(n!/exp(1))) but the recursive
220     definition with caching is implemented for this function.
221 
222     An interesting analytic expression is the following [2]_
223 
224     .. math:: !x = \Gamma(x + 1, -1)/e
225 
226     which is valid for non-negative integers x. The above formula
227     is not very useful incase of non-integers. :math:`\Gamma(x + 1, -1)` is
228     single-valued only for integral arguments x, elsewhere on the positive real
229     axis it has an infinite number of branches none of which are real.
230 
231     References
232     ==========
233 
234     .. [1] http://en.wikipedia.org/wiki/Subfactorial
235     .. [2] http://mathworld.wolfram.com/Subfactorial.html
236 
237     Examples
238     ========
239 
240     >>> from sympy import subfactorial
241     >>> from sympy.abc import n
242     >>> subfactorial(n + 1)
243     subfactorial(n + 1)
244     >>> subfactorial(5)
245     44
246 
247     See Also
248     ========
249 
250     sympy.functions.combinatorial.factorials.factorial,
251     sympy.utilities.iterables.generate_derangements,
252     sympy.functions.special.gamma_functions.uppergamma
253     """
254 
255     @classmethod
256     @cacheit
257     def _eval(self, n):
258         if not n:
259             return S.One
260         elif n == 1:
261             return S.Zero
262         return (n - 1)*(self._eval(n - 1) + self._eval(n - 2))
263 
264     @classmethod
265     def eval(cls, arg):
266         if arg.is_Number:
267             if arg.is_Integer and arg.is_nonnegative:
268                 return cls._eval(arg)
269             elif arg is S.NaN:
270                 return S.NaN
271             elif arg is S.Infinity:
272                 return S.Infinity
273 
274     def _eval_is_even(self):
275         if self.args[0].is_odd and self.args[0].is_nonnegative:
276             return True
277 
278     def _eval_is_integer(self):
279         if self.args[0].is_integer and self.args[0].is_nonnegative:
280             return True
281 
282     def _eval_rewrite_as_uppergamma(self, arg):
283         from sympy import uppergamma
284         return uppergamma(arg + 1, -1)/S.Exp1
285 
286     def _eval_is_nonnegative(self):
287         if self.args[0].is_integer and self.args[0].is_nonnegative:
288             return True
289 
290     def _eval_is_odd(self):
291         if self.args[0].is_even and self.args[0].is_nonnegative:
292             return True
293 
294 
295 class factorial2(CombinatorialFunction):
296     """The double factorial n!!, not to be confused with (n!)!
297 
298     The double factorial is defined for nonnegative integers and for odd
299     negative integers as::
300 
301                ,
302               |  n*(n - 2)*(n - 4)* ... * 1    for n positive odd
303         n!! = {  n*(n - 2)*(n - 4)* ... * 2    for n positive even
304               |  1                             for n = 0
305               |  (n+2)!! / (n+2)               for n negative odd
306                `
307 
308     References
309     ==========
310     .. [1] https://en.wikipedia.org/wiki/Double_factorial
311 
312     Examples
313     ========
314 
315     >>> from sympy import factorial2, var
316     >>> var('n')
317     n
318     >>> factorial2(n + 1)
319     factorial2(n + 1)
320     >>> factorial2(5)
321     15
322     >>> factorial2(-1)
323     1
324     >>> factorial2(-5)
325     1/3
326 
327     See Also
328     ========
329 
330     factorial, RisingFactorial, FallingFactorial
331     """
332 
333     @classmethod
334     def eval(cls, arg):
335         # TODO: extend this to complex numbers?
336 
337         if arg.is_Number:
338             if not arg.is_Integer:
339                 raise ValueError("argument must be nonnegative integer or negative odd integer")
340 
341             # This implementation is faster than the recursive one
342             # It also avoids "maximum recursion depth exceeded" runtime error
343             if arg.is_nonnegative:
344                 if arg.is_even:
345                     k = arg / 2
346                     return 2 ** k * factorial(k)
347                 return factorial(arg) / factorial2(arg - 1)
348 
349 
350             if arg.is_odd:
351                 return arg * (S.NegativeOne) ** ((1 - arg) / 2) / factorial2(-arg)
352             raise ValueError("argument must be nonnegative integer or negative odd integer")
353 
354 
355     def _eval_is_even(self):
356         # Double factorial is even for every positive even input
357         n = self.args[0]
358         if n.is_integer:
359             if n.is_odd:
360                 return False
361             if n.is_even:
362                 if n.is_positive:
363                     return True
364                 if n.is_zero:
365                     return False
366 
367     def _eval_is_integer(self):
368         # Double factorial is an integer for every nonnegative input, and for
369         # -1 and -3
370         n = self.args[0]
371         if n.is_integer:
372             if (n + 1).is_nonnegative:
373                 return True
374             if n.is_odd:
375                 return (n + 3).is_nonnegative
376 
377     def _eval_is_odd(self):
378         # Double factorial is odd for every odd input not smaller than -3, and
379         # for 0
380         n = self.args[0]
381         if n.is_odd:
382             return (n + 3).is_nonnegative
383         if n.is_even:
384             if n.is_positive:
385                 return False
386             if n.is_zero:
387                 return True
388 
389     def _eval_is_positive(self):
390         # Double factorial is positive for every nonnegative input, and for
391         # every odd negative input which is of the form -1-4k for an
392         # nonnegative integer k
393         n = self.args[0]
394         if n.is_integer:
395             if (n + 1).is_nonnegative:
396                 return True
397             if n.is_odd:
398                 return ((n + 1) / 2).is_even
399 
400     def _eval_rewrite_as_gamma(self, n):
401         from sympy import gamma, Piecewise, sqrt
402         return 2**(n/2)*gamma(n/2 + 1) * Piecewise((1, Eq(Mod(n, 2), 0)), (sqrt(2/pi), Eq(Mod(n, 2), 1)))
403 
404 
405 ###############################################################################
406 ######################## RISING and FALLING FACTORIALS ########################
407 ###############################################################################
408 
409 
410 class RisingFactorial(CombinatorialFunction):
411     """Rising factorial (also called Pochhammer symbol) is a double valued
412     function arising in concrete mathematics, hypergeometric functions
413     and series expansions. It is defined by:
414 
415                 rf(x, k) = x * (x + 1) * ... * (x + k - 1)
416 
417     where 'x' can be arbitrary expression and 'k' is an integer. For
418     more information check "Concrete mathematics" by Graham, pp. 66
419     or visit http://mathworld.wolfram.com/RisingFactorial.html page.
420 
421     When x is a polynomial f of a single variable y of order >= 1,
422     rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in
423     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
424     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
425 
426     Examples
427     ========
428 
429     >>> from sympy import rf, symbols, factorial, ff, binomial
430     >>> from sympy.abc import x
431     >>> n, k = symbols('n k', integer=True)
432     >>> rf(x, 0)
433     1
434     >>> rf(1, 5)
435     120
436     >>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)
437     True
438     >>> rf(x**3, 2)
439     Poly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')
440 
441     Rewrite
442 
443     >>> rf(x, k).rewrite(ff)
444     FallingFactorial(k + x - 1, k)
445     >>> rf(x, k).rewrite(binomial)
446     binomial(k + x - 1, k)*factorial(k)
447     >>> rf(n, k).rewrite(factorial)
448     factorial(k + n - 1)/factorial(n - 1)
449 
450     See Also
451     ========
452 
453     factorial, factorial2, FallingFactorial
454 
455     References
456     ==========
457 
458     .. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol
459     """
460 
461     @classmethod
462     def eval(cls, x, k):
463         x = sympify(x)
464         k = sympify(k)
465 
466         if x is S.NaN or k is S.NaN:
467             return S.NaN
468         elif x is S.One:
469             return factorial(k)
470         elif k.is_Integer:
471             if k is S.Zero:
472                 return S.One
473             else:
474                 if k.is_positive:
475                     if x is S.Infinity:
476                         return S.Infinity
477                     elif x is S.NegativeInfinity:
478                         if k.is_odd:
479                             return S.NegativeInfinity
480                         else:
481                             return S.Infinity
482                     else:
483                         try:
484                             F, opt = poly_from_expr(x)
485                         except PolificationFailed:
486                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
487                         if len(opt.gens) > 1 or F.degree() <= 1:
488                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
489                         else:
490                             v = opt.gens[0]
491                             return reduce(lambda r, i:
492                                           r*(F.subs(v, v + i).expand()),
493                                           range(0, int(k)), 1)
494                 else:
495                     if x is S.Infinity:
496                         return S.Infinity
497                     elif x is S.NegativeInfinity:
498                         return S.Infinity
499                     else:
500                         try:
501                             F, opt = poly_from_expr(x)
502                         except PolificationFailed:
503                             return 1/reduce(lambda r, i:
504                                             r*(x - i),
505                                             range(1, abs(int(k)) + 1), 1)
506                         if len(opt.gens) > 1 or F.degree() <= 1:
507                             return 1/reduce(lambda r, i:
508                                             r*(x - i),
509                                             range(1, abs(int(k)) + 1), 1)
510                         else:
511                             v = opt.gens[0]
512                             return 1/reduce(lambda r, i:
513                                             r*(F.subs(v, v - i).expand()),
514                                             range(1, abs(int(k)) + 1), 1)
515 
516     def _eval_rewrite_as_gamma(self, x, k):
517         from sympy import gamma
518         return gamma(x + k) / gamma(x)
519 
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)
522 
523     def _eval_rewrite_as_factorial(self, x, k):
524         if x.is_integer and k.is_integer:
525             return factorial(k + x - 1) / factorial(x - 1)
526 
527     def _eval_rewrite_as_binomial(self, x, k):
528         if k.is_integer:
529             return factorial(k) * binomial(x + k - 1, k)
530 
531     def _eval_is_integer(self):
532         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
533                           self.args[1].is_nonnegative))
534 
535     def _sage_(self):
536         import sage.all as sage
537         return sage.rising_factorial(self.args[0]._sage_(), self.args[1]._sage_())
538 
539 
540 class FallingFactorial(CombinatorialFunction):
541     """Falling factorial (related to rising factorial) is a double valued
542     function arising in concrete mathematics, hypergeometric functions
543     and series expansions. It is defined by
544 
545                 ff(x, k) = x * (x-1) * ... * (x - k+1)
546 
547     where 'x' can be arbitrary expression and 'k' is an integer. For
548     more information check "Concrete mathematics" by Graham, pp. 66
549     or visit http://mathworld.wolfram.com/FallingFactorial.html page.
550 
551     When x is a polynomial f of a single variable y of order >= 1,
552     ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in
553     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
554     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
555 
556     >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols
557     >>> from sympy.abc import x, k
558     >>> n, m = symbols('n m', integer=True)
559     >>> ff(x, 0)
560     1
561     >>> ff(5, 5)
562     120
563     >>> ff(x, 5) == x*(x-1)*(x-2)*(x-3)*(x-4)
564     True
565     >>> ff(x**2, 2)
566     Poly(x**4 - 2*x**3 + x**2, x, domain='ZZ')
567     >>> ff(n, n)
568     factorial(n)
569 
570     Rewrite
571 
572     >>> ff(x, k).rewrite(gamma)
573     (-1)**k*gamma(k - x)/gamma(-x)
574     >>> ff(x, k).rewrite(rf)
575     RisingFactorial(-k + x + 1, k)
576     >>> ff(x, m).rewrite(binomial)
577     binomial(x, m)*factorial(m)
578     >>> ff(n, m).rewrite(factorial)
579     factorial(n)/factorial(-m + n)
580 
581     See Also
582     ========
583 
584     factorial, factorial2, RisingFactorial
585 
586     References
587     ==========
588 
589     .. [1] http://mathworld.wolfram.com/FallingFactorial.html
590     """
591 
592     @classmethod
593     def eval(cls, x, k):
594         x = sympify(x)
595         k = sympify(k)
596 
597         if x is S.NaN or k is S.NaN:
598             return S.NaN
599         elif k.is_integer and x == k:
600             return factorial(x)
601         elif k.is_Integer:
602             if k is S.Zero:
603                 return S.One
604             else:
605                 if k.is_positive:
606                     if x is S.Infinity:
607                         return S.Infinity
608                     elif x is S.NegativeInfinity:
609                         if k.is_odd:
610                             return S.NegativeInfinity
611                         else:
612                             return S.Infinity
613                     else:
614                         try:
615                             F, opt = poly_from_expr(x)
616                         except PolificationFailed:
617                             return reduce(lambda r, i: r*(x - i),
618                                           range(0, int(k)), 1)
619                         if len(opt.gens) > 1 or F.degree() <= 1:
620                             return reduce(lambda r, i: r*(x - i),
621                                           range(0, int(k)), 1)
622                         else:
623                             v = opt.gens[0]
624                             return reduce(lambda r, i:
625                                           r*(F.subs(v, v - i).expand()),
626                                           range(0, int(k)), 1)
627                 else:
628                     if x is S.Infinity:
629                         return S.Infinity
630                     elif x is S.NegativeInfinity:
631                         return S.Infinity
632                     else:
633                         try:
634                             F, opt = poly_from_expr(x)
635                         except PolificationFailed:
636                             return 1/reduce(lambda r, i: r*(x + i),
637                                             range(1, abs(int(k)) + 1), 1)
638                         if len(opt.gens) > 1 or F.degree() <= 1:
639                             return 1/reduce(lambda r, i: r*(x + i),
640                                             range(1, abs(int(k)) + 1), 1)
641                         else:
642                             v = opt.gens[0]
643                             return 1/reduce(lambda r, i:
644                                             r*(F.subs(v, v + i).expand()),
645                                             range(1, abs(int(k)) + 1), 1)
646 
647     def _eval_rewrite_as_gamma(self, x, k):
648         from sympy import gamma
649         return (-1)**k*gamma(k - x) / gamma(-x)
650 
651     def _eval_rewrite_as_RisingFactorial(self, x, k):
652         return rf(x - k + 1, k)
653 
654     def _eval_rewrite_as_binomial(self, x, k):
655         if k.is_integer:
656             return factorial(k) * binomial(x, k)
657 
658     def _eval_rewrite_as_factorial(self, x, k):
659         if x.is_integer and k.is_integer:
660             return factorial(x) / factorial(x - k)
661 
662     def _eval_is_integer(self):
663         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
664                           self.args[1].is_nonnegative))
665 
666     def _sage_(self):
667         import sage.all as sage
668         return sage.falling_factorial(self.args[0]._sage_(),
669                                       self.args[1]._sage_())
670 
671 
672 rf = RisingFactorial
673 ff = FallingFactorial
674 
675 ###############################################################################
676 ########################### BINOMIAL COEFFICIENTS #############################
677 ###############################################################################
678 
679 
680 class binomial(CombinatorialFunction):
681     """Implementation of the binomial coefficient. It can be defined
682     in two ways depending on its desired interpretation:
683 
684         C(n,k) = n!/(k!(n-k)!)   or   C(n, k) = ff(n, k)/k!
685 
686     First, in a strict combinatorial sense it defines the
687     number of ways we can choose 'k' elements from a set of
688     'n' elements. In this case both arguments are nonnegative
689     integers and binomial is computed using an efficient
690     algorithm based on prime factorization.
691 
692     The other definition is generalization for arbitrary 'n',
693     however 'k' must also be nonnegative. This case is very
694     useful when evaluating summations.
695 
696     For the sake of convenience for negative 'k' this function
697     will return zero no matter what valued is the other argument.
698 
699     To expand the binomial when n is a symbol, use either
700     expand_func() or expand(func=True). The former will keep the
701     polynomial in factored form while the latter will expand the
702     polynomial itself. See examples for details.
703 
704     Examples
705     ========
706 
707     >>> from sympy import Symbol, Rational, binomial, expand_func
708     >>> n = Symbol('n', integer=True, positive=True)
709 
710     >>> binomial(15, 8)
711     6435
712 
713     >>> binomial(n, -1)
714     0
715 
716     Rows of Pascal's triangle can be generated with the binomial function:
717 
718     >>> for N in range(8):
719     ...     print([ binomial(N, i) for i in range(N + 1)])
720     ...
721     [1]
722     [1, 1]
723     [1, 2, 1]
724     [1, 3, 3, 1]
725     [1, 4, 6, 4, 1]
726     [1, 5, 10, 10, 5, 1]
727     [1, 6, 15, 20, 15, 6, 1]
728     [1, 7, 21, 35, 35, 21, 7, 1]
729 
730     As can a given diagonal, e.g. the 4th diagonal:
731 
732     >>> N = -4
733     >>> [ binomial(N, i) for i in range(1 - N)]
734     [1, -4, 10, -20, 35]
735 
736     >>> binomial(Rational(5, 4), 3)
737     -5/128
738     >>> binomial(Rational(-5, 4), 3)
739     -195/128
740 
741     >>> binomial(n, 3)
742     binomial(n, 3)
743 
744     >>> binomial(n, 3).expand(func=True)
745     n**3/6 - n**2/2 + n/3
746 
747     >>> expand_func(binomial(n, 3))
748     n*(n - 2)*(n - 1)/6
749 
750     """
751 
752     def fdiff(self, argindex=1):
753         from sympy import polygamma
754         if argindex == 1:
755             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/01/
756             n, k = self.args
757             return binomial(n, k)*(polygamma(0, n + 1) - \
758                 polygamma(0, n - k + 1))
759         elif argindex == 2:
760             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/02/
761             n, k = self.args
762             return binomial(n, k)*(polygamma(0, n - k + 1) - \
763                 polygamma(0, k + 1))
764         else:
765             raise ArgumentIndexError(self, argindex)
766 
767     @classmethod
768     def _eval(self, n, k):
769         # n.is_Number and k.is_Integer and k != 1 and n != k
770         if k.is_Integer:
771             if n.is_Integer and n >= 0:
772                 n, k = int(n), int(k)
773 
774                 if k > n:
775                     return S.Zero
776                 elif k > n // 2:
777                     k = n - k
778 
779                 M, result = int(_sqrt(n)), 1
780 
781                 for prime in sieve.primerange(2, n + 1):
782                     if prime > n - k:
783                         result *= prime
784                     elif prime > n // 2:
785                         continue
786                     elif prime > M:
787                         if n % prime < k % prime:
788                             result *= prime
789                     else:
790                         N, K = n, k
791                         exp = a = 0
792 
793                         while N > 0:
794                             a = int((N % prime) < (K % prime + a))
795                             N, K = N // prime, K // prime
796                             exp = a + exp
797 
798                         if exp > 0:
799                             result *= prime**exp
800                 return Integer(result)
801             else:
802                 d = result = n - k + 1
803                 for i in range(2, k + 1):
804                     d += 1
805                     result *= d
806                     result /= i
807                 return result
808 
809     @classmethod
810     def eval(cls, n, k):
811         n, k = map(sympify, (n, k))
812         d = n - k
813         if d.is_zero or k.is_zero:
814             return S.One
815         elif d.is_zero is False:
816             if (k - 1).is_zero:
817                 return n
818             elif k.is_negative:
819                 return S.Zero
820             elif n.is_integer and n.is_nonnegative and d.is_negative:
821                 return S.Zero
822         if k.is_Integer and k > 0 and n.is_Number:
823             return cls._eval(n, k)
824 
825     def _eval_expand_func(self, **hints):
826         """
827         Function to expand binomial(n,k) when m is positive integer
828         Also,
829         n is self.args[0] and k is self.args[1] while using binomial(n, k)
830         """
831         n = self.args[0]
832         if n.is_Number:
833             return binomial(*self.args)
834 
835         k = self.args[1]
836         if k.is_Add and n in k.args:
837             k = n - k
838 
839         if k.is_Integer:
840             if k == S.Zero:
841                 return S.One
842             elif k < 0:
843                 return S.Zero
844             else:
845                 n = self.args[0]
846                 result = n - k + 1
847                 for i in range(2, k + 1):
848                     result *= n - k + i
849                     result /= i
850                 return result
851         else:
852             return binomial(*self.args)
853 
854     def _eval_rewrite_as_factorial(self, n, k):
855         return factorial(n)/(factorial(k)*factorial(n - k))
856 
857     def _eval_rewrite_as_gamma(self, n, k):
858         from sympy import gamma
859         return gamma(n + 1)/(gamma(k + 1)*gamma(n - k + 1))
860 
861     def _eval_rewrite_as_tractable(self, n, k):
862         return self._eval_rewrite_as_gamma(n, k).rewrite('tractable')
863 
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)
867 
868     def _eval_is_integer(self):
869         n, k = self.args
870         if n.is_integer and k.is_integer:
871             return True
872         elif k.is_integer is False:
873             return False

</code><intended_behavior>The intended behavior at these locations is to compute the falling factorial and rising factorial accurately according to their mathematical definitions. This means ff(n, k) should calculate the product of k consecutive numbers starting from n and decreasing, and rf(n, k) should calculate the product of k consecutive numbers starting from n and increasing. Any previous functionality that was altered leading to incorrect computations or interface changes should be reverted to preserve the expected mathematical behavior and ensure backward compatibility.</intended_behavior>, <file>sympy/functions/combinatorial/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 This module implements some special functions that commonly appear in
3 combinatorial contexts (e.g. in power series); in particular,
4 sequences of rational numbers such as Bernoulli and Fibonacci numbers.
5 
6 Factorials, binomial coefficients and related functions are located in
7 the separate 'factorials' module.
8 """
9 
10 from __future__ import print_function, division
11 
12 from sympy.core import S, Symbol, Rational, Integer, Add, Dummy
13 from sympy.core.compatibility import as_int, SYMPY_INTS, range
14 from sympy.core.cache import cacheit
15 from sympy.core.function import Function, expand_mul
16 from sympy.core.numbers import E, pi
17 from sympy.core.relational import LessThan, StrictGreaterThan
18 from sympy.functions.combinatorial.factorials import binomial, factorial
19 from sympy.functions.elementary.exponential import log
20 from sympy.functions.elementary.integers import floor
21 from sympy.functions.elementary.trigonometric import sin, cos, cot
22 from sympy.functions.elementary.miscellaneous import sqrt
23 from sympy.utilities.memoization import recurrence_memo
24 
25 from mpmath import bernfrac, workprec
26 from mpmath.libmp import ifib as _ifib
27 
28 
29 def _product(a, b):
30     p = 1
31     for k in range(a, b + 1):
32         p *= k
33     return p
34 
35 
36 
37 # Dummy symbol used for computing polynomial sequences
38 _sym = Symbol('x')
39 _symbols = Function('x')
40 
41 
42 #----------------------------------------------------------------------------#
43 #                                                                            #
44 #                           Fibonacci numbers                                #
45 #                                                                            #
46 #----------------------------------------------------------------------------#
47 
48 class fibonacci(Function):
49     r"""
50     Fibonacci numbers / Fibonacci polynomials
51 
52     The Fibonacci numbers are the integer sequence defined by the
53     initial terms F_0 = 0, F_1 = 1 and the two-term recurrence
54     relation F_n = F_{n-1} + F_{n-2}.  This definition
55     extended to arbitrary real and complex arguments using
56     the formula
57 
58     .. math :: F_z = \frac{\phi^z - \cos(\pi z) \phi^{-z}}{\sqrt 5}
59 
60     The Fibonacci polynomials are defined by F_1(x) = 1,
61     F_2(x) = x, and F_n(x) = x*F_{n-1}(x) + F_{n-2}(x) for n > 2.
62     For all positive integers n, F_n(1) = F_n.
63 
64     * fibonacci(n) gives the nth Fibonacci number, F_n
65     * fibonacci(n, x) gives the nth Fibonacci polynomial in x, F_n(x)
66 
67     Examples
68     ========
69 
70     >>> from sympy import fibonacci, Symbol
71 
72     >>> [fibonacci(x) for x in range(11)]
73     [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
74     >>> fibonacci(5, Symbol('t'))
75     t**4 + 3*t**2 + 1
76 
77     References
78     ==========
79 
80     .. [1] http://en.wikipedia.org/wiki/Fibonacci_number
81     .. [2] http://mathworld.wolfram.com/FibonacciNumber.html
82 
83     See Also
84     ========
85 
86     bell, bernoulli, catalan, euler, harmonic, lucas
87     """
88 
89     @staticmethod
90     def _fib(n):
91         return _ifib(n)
92 
93     @staticmethod
94     @recurrence_memo([None, S.One, _sym])
95     def _fibpoly(n, prev):
96         return (prev[-2] + _sym*prev[-1]).expand()
97 
98     @classmethod
99     def eval(cls, n, sym=None):
100         if n is S.Infinity:
101             return S.Infinity
102 
103         if n.is_Integer:
104             n = int(n)
105             if n < 0:
106                 return S.NegativeOne**(n + 1) * fibonacci(-n)
107             if sym is None:
108                 return Integer(cls._fib(n))
109             else:
110                 if n < 1:
111                     raise ValueError("Fibonacci polynomials are defined "
112                        "only for positive integer indices.")
113                 return cls._fibpoly(n).subs(_sym, sym)
114 
115     def _eval_rewrite_as_sqrt(self, n):
116         return 2**(-n)*sqrt(5)*((1 + sqrt(5))**n - (-sqrt(5) + 1)**n) / 5
117 
118     def _eval_rewrite_as_GoldenRatio(self,n):
119         return (S.GoldenRatio**n - 1/(-S.GoldenRatio)**n)/(2*S.GoldenRatio-1)
120 
121 
122 class lucas(Function):
123     """
124     Lucas numbers
125 
126     Lucas numbers satisfy a recurrence relation similar to that of
127     the Fibonacci sequence, in which each term is the sum of the
128     preceding two. They are generated by choosing the initial
129     values L_0 = 2 and L_1 = 1.
130 
131     * lucas(n) gives the nth Lucas number
132 
133     Examples
134     ========
135 
136     >>> from sympy import lucas
137 
138     >>> [lucas(x) for x in range(11)]
139     [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123]
140 
141     References
142     ==========
143 
144     .. [1] http://en.wikipedia.org/wiki/Lucas_number
145     .. [2] http://mathworld.wolfram.com/LucasNumber.html
146 
147     See Also
148     ========
149 
150     bell, bernoulli, catalan, euler, fibonacci, harmonic
151     """
152 
153     @classmethod
154     def eval(cls, n):
155         if n is S.Infinity:
156             return S.Infinity
157 
158         if n.is_Integer:
159             return fibonacci(n + 1) + fibonacci(n - 1)
160 
161     def _eval_rewrite_as_sqrt(self, n):
162         return 2**(-n)*((1 + sqrt(5))**n + (-sqrt(5) + 1)**n)
163 
164 #----------------------------------------------------------------------------#
165 #                                                                            #
166 #                           Bernoulli numbers                                #
167 #                                                                            #
168 #----------------------------------------------------------------------------#
169 
170 
171 class bernoulli(Function):
172     r"""
173     Bernoulli numbers / Bernoulli polynomials
174 
175     The Bernoulli numbers are a sequence of rational numbers
176     defined by B_0 = 1 and the recursive relation (n > 0)::
177 
178                 n
179                ___
180               \      / n + 1 \
181           0 =  )     |       | * B .
182               /___   \   k   /    k
183               k = 0
184 
185     They are also commonly defined by their exponential generating
186     function, which is x/(exp(x) - 1). For odd indices > 1, the
187     Bernoulli numbers are zero.
188 
189     The Bernoulli polynomials satisfy the analogous formula::
190 
191                     n
192                    ___
193                   \      / n \         n-k
194           B (x) =  )     |   | * B  * x   .
195            n      /___   \ k /    k
196                   k = 0
197 
198     Bernoulli numbers and Bernoulli polynomials are related as
199     B_n(0) = B_n.
200 
201     We compute Bernoulli numbers using Ramanujan's formula::
202 
203                                    / n + 3 \
204           B   =  (A(n) - S(n))  /  |       |
205            n                       \   n   /
206 
207     where A(n) = (n+3)/3 when n = 0 or 2 (mod 6), A(n) = -(n+3)/6
208     when n = 4 (mod 6), and::
209 
210                  [n/6]
211                   ___
212                  \      /  n + 3  \
213           S(n) =  )     |         | * B
214                  /___   \ n - 6*k /    n-6*k
215                  k = 1
216 
217     This formula is similar to the sum given in the definition, but
218     cuts 2/3 of the terms. For Bernoulli polynomials, we use the
219     formula in the definition.
220 
221     * bernoulli(n) gives the nth Bernoulli number, B_n
222     * bernoulli(n, x) gives the nth Bernoulli polynomial in x, B_n(x)
223 
224     Examples
225     ========
226 
227     >>> from sympy import bernoulli
228 
229     >>> [bernoulli(n) for n in range(11)]
230     [1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]
231     >>> bernoulli(1000001)
232     0
233 
234     References
235     ==========
236 
237     .. [1] http://en.wikipedia.org/wiki/Bernoulli_number
238     .. [2] http://en.wikipedia.org/wiki/Bernoulli_polynomial
239     .. [3] http://mathworld.wolfram.com/BernoulliNumber.html
240     .. [4] http://mathworld.wolfram.com/BernoulliPolynomial.html
241 
242     See Also
243     ========
244 
245     bell, catalan, euler, fibonacci, harmonic, lucas
246     """
247 
248     # Calculates B_n for positive even n
249     @staticmethod
250     def _calc_bernoulli(n):
251         s = 0
252         a = int(binomial(n + 3, n - 6))
253         for j in range(1, n//6 + 1):
254             s += a * bernoulli(n - 6*j)
255             # Avoid computing each binomial coefficient from scratch
256             a *= _product(n - 6 - 6*j + 1, n - 6*j)
257             a //= _product(6*j + 4, 6*j + 9)
258         if n % 6 == 4:
259             s = -Rational(n + 3, 6) - s
260         else:
261             s = Rational(n + 3, 3) - s
262         return s / binomial(n + 3, n)
263 
264     # We implement a specialized memoization scheme to handle each
265     # case modulo 6 separately
266     _cache = {0: S.One, 2: Rational(1, 6), 4: Rational(-1, 30)}
267     _highest = {0: 0, 2: 2, 4: 4}
268 
269     @classmethod
270     def eval(cls, n, sym=None):
271         if n.is_Number:
272             if n.is_Integer and n.is_nonnegative:
273                 if n is S.Zero:
274                     return S.One
275                 elif n is S.One:
276                     if sym is None:
277                         return -S.Half
278                     else:
279                         return sym - S.Half
280                 # Bernoulli numbers
281                 elif sym is None:
282                     if n.is_odd:
283                         return S.Zero
284                     n = int(n)
285                     # Use mpmath for enormous Bernoulli numbers
286                     if n > 500:
287                         p, q = bernfrac(n)
288                         return Rational(int(p), int(q))
289                     case = n % 6
290                     highest_cached = cls._highest[case]
291                     if n <= highest_cached:
292                         return cls._cache[n]
293                     # To avoid excessive recursion when, say, bernoulli(1000) is
294                     # requested, calculate and cache the entire sequence ... B_988,
295                     # B_994, B_1000 in increasing order
296                     for i in range(highest_cached + 6, n + 6, 6):
297                         b = cls._calc_bernoulli(i)
298                         cls._cache[i] = b
299                         cls._highest[case] = i
300                     return b
301                 # Bernoulli polynomials
302                 else:
303                     n, result = int(n), []
304                     for k in range(n + 1):
305                         result.append(binomial(n, k)*cls(k)*sym**(n - k))
306                     return Add(*result)
307             else:
308                 raise ValueError("Bernoulli numbers are defined only"
309                                  " for nonnegative integer indices.")
310 
311         if sym is None:
312             if n.is_odd and (n - 1).is_positive:
313                 return S.Zero
314 
315 
316 #----------------------------------------------------------------------------#
317 #                                                                            #
318 #                             Bell numbers                                   #
319 #                                                                            #
320 #----------------------------------------------------------------------------#
321 
322 class bell(Function):
323     r"""
324     Bell numbers / Bell polynomials
325 
326     The Bell numbers satisfy `B_0 = 1` and
327 
328     .. math:: B_n = \sum_{k=0}^{n-1} \binom{n-1}{k} B_k.
329 
330     They are also given by:
331 
332     .. math:: B_n = \frac{1}{e} \sum_{k=0}^{\infty} \frac{k^n}{k!}.
333 
334     The Bell polynomials are given by `B_0(x) = 1` and
335 
336     .. math:: B_n(x) = x \sum_{k=1}^{n-1} \binom{n-1}{k-1} B_{k-1}(x).
337 
338     The second kind of Bell polynomials (are sometimes called "partial" Bell
339     polynomials or incomplete Bell polynomials) are defined as
340 
341     .. math:: B_{n,k}(x_1, x_2,\dotsc x_{n-k+1}) =
342             \sum_{j_1+j_2+j_2+\dotsb=k \atop j_1+2j_2+3j_2+\dotsb=n}
343                 \frac{n!}{j_1!j_2!\dotsb j_{n-k+1}!}
344                 \left(\frac{x_1}{1!} \right)^{j_1}
345                 \left(\frac{x_2}{2!} \right)^{j_2} \dotsb
346                 \left(\frac{x_{n-k+1}}{(n-k+1)!} \right) ^{j_{n-k+1}}.
347 
348     * bell(n) gives the `n^{th}` Bell number, `B_n`.
349     * bell(n, x) gives the `n^{th}` Bell polynomial, `B_n(x)`.
350     * bell(n, k, (x1, x2, ...)) gives Bell polynomials of the second kind,
351       `B_{n,k}(x_1, x_2, \dotsc, x_{n-k+1})`.
352 
353     Notes
354     =====
355 
356     Not to be confused with Bernoulli numbers and Bernoulli polynomials,
357     which use the same notation.
358 
359     Examples
360     ========
361 
362     >>> from sympy import bell, Symbol, symbols
363 
364     >>> [bell(n) for n in range(11)]
365     [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975]
366     >>> bell(30)
367     846749014511809332450147
368     >>> bell(4, Symbol('t'))
369     t**4 + 6*t**3 + 7*t**2 + t
370     >>> bell(6, 2, symbols('x:6')[1:])
371     6*x1*x5 + 15*x2*x4 + 10*x3**2
372 
373     References
374     ==========
375 
376     .. [1] http://en.wikipedia.org/wiki/Bell_number
377     .. [2] http://mathworld.wolfram.com/BellNumber.html
378     .. [3] http://mathworld.wolfram.com/BellPolynomial.html
379 
380     See Also
381     ========
382 
383     bernoulli, catalan, euler, fibonacci, harmonic, lucas
384     """
385 
386     @staticmethod
387     @recurrence_memo([1, 1])
388     def _bell(n, prev):
389         s = 1
390         a = 1
391         for k in range(1, n):
392             a = a * (n - k) // k
393             s += a * prev[k]
394         return s
395 
396     @staticmethod
397     @recurrence_memo([S.One, _sym])
398     def _bell_poly(n, prev):
399         s = 1
400         a = 1
401         for k in range(2, n + 1):
402             a = a * (n - k + 1) // (k - 1)
403             s += a * prev[k - 1]
404         return expand_mul(_sym * s)
405 
406     @staticmethod
407     def _bell_incomplete_poly(n, k, symbols):
408         r"""
409         The second kind of Bell polynomials (incomplete Bell polynomials).
410 
411         Calculated by recurrence formula:
412 
413         .. math:: B_{n,k}(x_1, x_2, \dotsc, x_{n-k+1}) =
414                 \sum_{m=1}^{n-k+1}
415                 \x_m \binom{n-1}{m-1} B_{n-m,k-1}(x_1, x_2, \dotsc, x_{n-m-k})
416 
417         where
418             B_{0,0} = 1;
419             B_{n,0} = 0; for n>=1
420             B_{0,k} = 0; for k>=1
421 
422         """
423         if (n == 0) and (k == 0):
424             return S.One
425         elif (n == 0) or (k == 0):
426             return S.Zero
427         s = S.Zero
428         a = S.One
429         for m in range(1, n - k + 2):
430             s += a * bell._bell_incomplete_poly(
431                 n - m, k - 1, symbols) * symbols[m - 1]
432             a = a * (n - m) / m
433         return expand_mul(s)
434 
435     @classmethod
436     def eval(cls, n, k_sym=None, symbols=None):
437         if n.is_Integer and n.is_nonnegative:
438             if k_sym is None:
439                 return Integer(cls._bell(int(n)))
440             elif symbols is None:
441                 return cls._bell_poly(int(n)).subs(_sym, k_sym)
442             else:
443                 r = cls._bell_incomplete_poly(int(n), int(k_sym), symbols)
444                 return r
445 
446     def _eval_rewrite_as_Sum(self, n, k_sym=None, symbols=None):
447         from sympy import Sum
448         if (k_sym is not None) or (symbols is not None):
449             return self
450 
451         # Dobinski's formula
452         if not n.is_nonnegative:
453             return self
454         k = Dummy('k', integer=True, nonnegative=True)
455         return 1 / E * Sum(k**n / factorial(k), (k, 0, S.Infinity))
456 
457 #----------------------------------------------------------------------------#
458 #                                                                            #
459 #                           Harmonic numbers                                 #
460 #                                                                            #
461 #----------------------------------------------------------------------------#
462 
463 
464 class harmonic(Function):
465     r"""
466     Harmonic numbers
467 
468     The nth harmonic number is given by `\operatorname{H}_{n} =
469     1 + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n}`.
470 
471     More generally:
472 
473     .. math:: \operatorname{H}_{n,m} = \sum_{k=1}^{n} \frac{1}{k^m}
474 
475     As `n \rightarrow \infty`, `\operatorname{H}_{n,m} \rightarrow \zeta(m)`,
476     the Riemann zeta function.
477 
478     * ``harmonic(n)`` gives the nth harmonic number, `\operatorname{H}_n`
479 
480     * ``harmonic(n, m)`` gives the nth generalized harmonic number
481       of order `m`, `\operatorname{H}_{n,m}`, where
482       ``harmonic(n) == harmonic(n, 1)``
483 
484     Examples
485     ========
486 
487     >>> from sympy import harmonic, oo
488 
489     >>> [harmonic(n) for n in range(6)]
490     [0, 1, 3/2, 11/6, 25/12, 137/60]
491     >>> [harmonic(n, 2) for n in range(6)]
492     [0, 1, 5/4, 49/36, 205/144, 5269/3600]
493     >>> harmonic(oo, 2)
494     pi**2/6
495 
496     >>> from sympy import Symbol, Sum
497     >>> n = Symbol("n")
498 
499     >>> harmonic(n).rewrite(Sum)
500     Sum(1/_k, (_k, 1, n))
501 
502     We can evaluate harmonic numbers for all integral and positive
503     rational arguments:
504 
505     >>> from sympy import S, expand_func, simplify
506     >>> harmonic(8)
507     761/280
508     >>> harmonic(11)
509     83711/27720
510 
511     >>> H = harmonic(1/S(3))
512     >>> H
513     harmonic(1/3)
514     >>> He = expand_func(H)
515     >>> He
516     -log(6) - sqrt(3)*pi/6 + 2*Sum(log(sin(_k*pi/3))*cos(2*_k*pi/3), (_k, 1, 1))
517                            + 3*Sum(1/(3*_k + 1), (_k, 0, 0))
518     >>> He.doit()
519     -log(6) - sqrt(3)*pi/6 - log(sqrt(3)/2) + 3
520     >>> H = harmonic(25/S(7))
521     >>> He = simplify(expand_func(H).doit())
522     >>> He
523     log(sin(pi/7)**(-2*cos(pi/7))*sin(2*pi/7)**(2*cos(16*pi/7))*cos(pi/14)**(-2*sin(pi/14))/14)
524     + pi*tan(pi/14)/2 + 30247/9900
525     >>> He.n(40)
526     1.983697455232980674869851942390639915940
527     >>> harmonic(25/S(7)).n(40)
528     1.983697455232980674869851942390639915940
529 
530     We can rewrite harmonic numbers in terms of polygamma functions:
531 
532     >>> from sympy import digamma, polygamma
533     >>> m = Symbol("m")
534 
535     >>> harmonic(n).rewrite(digamma)
536     polygamma(0, n + 1) + EulerGamma
537 
538     >>> harmonic(n).rewrite(polygamma)
539     polygamma(0, n + 1) + EulerGamma
540 
541     >>> harmonic(n,3).rewrite(polygamma)
542     polygamma(2, n + 1)/2 - polygamma(2, 1)/2
543 
544     >>> harmonic(n,m).rewrite(polygamma)
545     (-1)**m*(polygamma(m - 1, 1) - polygamma(m - 1, n + 1))/factorial(m - 1)
546 
547     Integer offsets in the argument can be pulled out:
548 
549     >>> from sympy import expand_func
550 
551     >>> expand_func(harmonic(n+4))
552     harmonic(n) + 1/(n + 4) + 1/(n + 3) + 1/(n + 2) + 1/(n + 1)
553 
554     >>> expand_func(harmonic(n-4))
555     harmonic(n) - 1/(n - 1) - 1/(n - 2) - 1/(n - 3) - 1/n
556 
557     Some limits can be computed as well:
558 
559     >>> from sympy import limit, oo
560 
561     >>> limit(harmonic(n), n, oo)
562     oo
563 
564     >>> limit(harmonic(n, 2), n, oo)
565     pi**2/6
566 
567     >>> limit(harmonic(n, 3), n, oo)
568     -polygamma(2, 1)/2
569 
570     However we can not compute the general relation yet:
571 
572     >>> limit(harmonic(n, m), n, oo)
573     harmonic(oo, m)
574 
575     which equals ``zeta(m)`` for ``m > 1``.
576 
577     References
578     ==========
579 
580     .. [1] http://en.wikipedia.org/wiki/Harmonic_number
581     .. [2] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber/
582     .. [3] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber2/
583 
584     See Also
585     ========
586 
587     bell, bernoulli, catalan, euler, fibonacci, lucas
588     """
589 
590     # Generate one memoized Harmonic number-generating function for each
591     # order and store it in a dictionary
592     _functions = {}
593 
594     @classmethod
595     def eval(cls, n, m=None):
596         from sympy import zeta
597         if m is S.One:
598             return cls(n)
599         if m is None:
600             m = S.One
601 
602         if m.is_zero:
603             return n
604 
605         if n is S.Infinity and m.is_Number:
606             # TODO: Fix for symbolic values of m
607             if m.is_negative:
608                 return S.NaN
609             elif LessThan(m, S.One):
610                 return S.Infinity
611             elif StrictGreaterThan(m, S.One):
612                 return zeta(m)
613             else:
614                 return cls
615 
616         if n.is_Integer and n.is_nonnegative and m.is_Integer:
617             if n == 0:
618                 return S.Zero
619             if not m in cls._functions:
620                 @recurrence_memo([0])
621                 def f(n, prev):
622                     return prev[-1] + S.One / n**m
623                 cls._functions[m] = f
624             return cls._functions[m](int(n))
625 
626     def _eval_rewrite_as_polygamma(self, n, m=1):
627         from sympy.functions.special.gamma_functions import polygamma
628         return S.NegativeOne**m/factorial(m - 1) * (polygamma(m - 1, 1) - polygamma(m - 1, n + 1))
629 
630     def _eval_rewrite_as_digamma(self, n, m=1):
631         from sympy.functions.special.gamma_functions import polygamma
632         return self.rewrite(polygamma)
633 
634     def _eval_rewrite_as_trigamma(self, n, m=1):
635         from sympy.functions.special.gamma_functions import polygamma
636         return self.rewrite(polygamma)
637 
638     def _eval_rewrite_as_Sum(self, n, m=None):
639         from sympy import Sum
640         k = Dummy("k", integer=True)
641         if m is None:
642             m = S.One
643         return Sum(k**(-m), (k, 1, n))
644 
645     def _eval_expand_func(self, **hints):
646         from sympy import Sum
647         n = self.args[0]
648         m = self.args[1] if len(self.args) == 2 else 1
649 
650         if m == S.One:
651             if n.is_Add:
652                 off = n.args[0]
653                 nnew = n - off
654                 if off.is_Integer and off.is_positive:
655                     result = [S.One/(nnew + i) for i in range(off, 0, -1)] + [harmonic(nnew)]
656                     return Add(*result)
657                 elif off.is_Integer and off.is_negative:
658                     result = [-S.One/(nnew + i) for i in range(0, off, -1)] + [harmonic(nnew)]
659                     return Add(*result)
660 
661             if n.is_Rational:
662                 # Expansions for harmonic numbers at general rational arguments (u + p/q)
663                 # Split n as u + p/q with p < q
664                 p, q = n.as_numer_denom()
665                 u = p // q
666                 p = p - u * q
667                 if u.is_nonnegative and p.is_positive and q.is_positive and p < q:
668                     k = Dummy("k")
669                     t1 = q * Sum(1 / (q * k + p), (k, 0, u))
670                     t2 = 2 * Sum(cos((2 * pi * p * k) / S(q)) *
671                                    log(sin((pi * k) / S(q))),
672                                    (k, 1, floor((q - 1) / S(2))))
673                     t3 = (pi / 2) * cot((pi * p) / q) + log(2 * q)
674                     return t1 + t2 - t3
675 
676         return self
677 
678     def _eval_rewrite_as_tractable(self, n, m=1):
679         from sympy import polygamma
680         return self.rewrite(polygamma).rewrite("tractable", deep=True)
681 
682     def _eval_evalf(self, prec):
683         from sympy import polygamma
684         if all(i.is_number for i in self.args):
685             return self.rewrite(polygamma)._eval_evalf(prec)
686 
687 
688 #----------------------------------------------------------------------------#
689 #                                                                            #
690 #                           Euler numbers                                    #
691 #                                                                            #
692 #----------------------------------------------------------------------------#
693 
694 
695 class euler(Function):
696     r"""
697     Euler numbers
698 
699     The euler numbers are given by::
700 
701                   2*n+1   k
702                    ___   ___            j          2*n+1
703                   \     \     / k \ (-1)  * (k-2*j)
704           E   = I  )     )    |   | --------------------
705            2n     /___  /___  \ j /      k    k
706                   k = 1 j = 0           2  * I  * k
707 
708           E     = 0
709            2n+1
710 
711     * euler(n) gives the n-th Euler number, E_n
712 
713     Examples
714     ========
715 
716     >>> from sympy import Symbol
717     >>> from sympy.functions import euler
718     >>> [euler(n) for n in range(10)]
719     [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0]
720     >>> n = Symbol("n")
721     >>> euler(n+2*n)
722     euler(3*n)
723 
724     References
725     ==========
726 
727     .. [1] http://en.wikipedia.org/wiki/Euler_numbers
728     .. [2] http://mathworld.wolfram.com/EulerNumber.html
729     .. [3] http://en.wikipedia.org/wiki/Alternating_permutation
730     .. [4] http://mathworld.wolfram.com/AlternatingPermutation.html
731 
732     See Also
733     ========
734 
735     bell, bernoulli, catalan, fibonacci, harmonic, lucas
736     """
737 
738     @classmethod
739     def eval(cls, m):
740         if m.is_odd:
741             return S.Zero
742         if m.is_Integer and m.is_nonnegative:
743             from mpmath import mp
744             m = m._to_mpmath(mp.prec)
745             res = mp.eulernum(m, exact=True)
746             return Integer(res)
747 
748     def _eval_rewrite_as_Sum(self, arg):
749         from sympy import Sum
750         if arg.is_even:
751             k = Dummy("k", integer=True)
752             j = Dummy("j", integer=True)
753             n = self.args[0] / 2
754             Em = (S.ImaginaryUnit * Sum(Sum(binomial(k, j) * ((-1)**j * (k - 2*j)**(2*n + 1)) /
755                   (2**k*S.ImaginaryUnit**k * k), (j, 0, k)), (k, 1, 2*n + 1)))
756 
757             return Em
758 
759     def _eval_evalf(self, prec):
760         m = self.args[0]
761 
762         if m.is_Integer and m.is_nonnegative:
763             from mpmath import mp
764             from sympy import Expr
765             m = m._to_mpmath(prec)
766             with workprec(prec):
767                 res = mp.eulernum(m)
768             return Expr._from_mpmath(res, prec)
769 
770 #----------------------------------------------------------------------------#
771 #                                                                            #
772 #                           Catalan numbers                                  #
773 #                                                                            #
774 #----------------------------------------------------------------------------#
775 
776 
777 class catalan(Function):
778     r"""
779     Catalan numbers
780 
781     The n-th catalan number is given by::
782 
783                  1   / 2*n \
784           C  = ----- |     |
785            n   n + 1 \  n  /
786 
787     * catalan(n) gives the n-th Catalan number, C_n
788 
789     Examples
790     ========
791 
792     >>> from sympy import (Symbol, binomial, gamma, hyper, polygamma,
793     ...             catalan, diff, combsimp, Rational, I)
794 
795     >>> [ catalan(i) for i in range(1,10) ]
796     [1, 2, 5, 14, 42, 132, 429, 1430, 4862]
797 
798     >>> n = Symbol("n", integer=True)
799 
800     >>> catalan(n)
801     catalan(n)
802 
803     Catalan numbers can be transformed into several other, identical
804     expressions involving other mathematical functions
805 
806     >>> catalan(n).rewrite(binomial)
807     binomial(2*n, n)/(n + 1)
808 
809     >>> catalan(n).rewrite(gamma)
810     4**n*gamma(n + 1/2)/(sqrt(pi)*gamma(n + 2))
811 
812     >>> catalan(n).rewrite(hyper)
813     hyper((-n + 1, -n), (2,), 1)
814 
815     For some non-integer values of n we can get closed form
816     expressions by rewriting in terms of gamma functions:
817 
818     >>> catalan(Rational(1,2)).rewrite(gamma)
819     8/(3*pi)
820 
821     We can differentiate the Catalan numbers C(n) interpreted as a
822     continuous real funtion in n:
823 
824     >>> diff(catalan(n), n)
825     (polygamma(0, n + 1/2) - polygamma(0, n + 2) + log(4))*catalan(n)
826 
827     As a more advanced example consider the following ratio
828     between consecutive numbers:
829 
830     >>> combsimp((catalan(n + 1)/catalan(n)).rewrite(binomial))
831     2*(2*n + 1)/(n + 2)
832 
833     The Catalan numbers can be generalized to complex numbers:
834 
835     >>> catalan(I).rewrite(gamma)
836     4**I*gamma(1/2 + I)/(sqrt(pi)*gamma(2 + I))
837 
838     and evaluated with arbitrary precision:
839 
840     >>> catalan(I).evalf(20)
841     0.39764993382373624267 - 0.020884341620842555705*I
842 
843     References
844     ==========
845 
846     .. [1] http://en.wikipedia.org/wiki/Catalan_number
847     .. [2] http://mathworld.wolfram.com/CatalanNumber.html
848     .. [3] http://functions.wolfram.com/GammaBetaErf/CatalanNumber/
849     .. [4] http://geometer.org/mathcircles/catalan.pdf
850 
851     See Also
852     ========
853 
854     bell, bernoulli, euler, fibonacci, harmonic, lucas
855     sympy.functions.combinatorial.factorials.binomial
856     """
857 
858     @classmethod
859     def eval(cls, n):
860         from sympy import gamma
861         if (n.is_Integer and n.is_nonnegative) or \
862            (n.is_noninteger and n.is_negative):
863             return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))
864 
865         if (n.is_integer and n.is_negative):
866             if (n + 1).is_negative:
867                 return S.Zero
868             if (n + 1).is_zero:
869                 return -S.Half
870 
871     def fdiff(self, argindex=1):
872         from sympy import polygamma, log
873         n = self.args[0]
874         return catalan(n)*(polygamma(0, n + Rational(1, 2)) - polygamma(0, n + 2) + log(4))
875 
876     def _eval_rewrite_as_binomial(self, n):
877         return binomial(2*n, n)/(n + 1)
878 
879     def _eval_rewrite_as_factorial(self, n):
880         return factorial(2*n) / (factorial(n+1) * factorial(n))
881 
882     def _eval_rewrite_as_gamma(self, n):
883         from sympy import gamma
884         # The gamma function allows to generalize Catalan numbers to complex n
885         return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))
886 
887     def _eval_rewrite_as_hyper(self, n):
888         from sympy import hyper
889         return hyper([1 - n, -n], [2], 1)
890 
891     def _eval_rewrite_as_Product(self, n):
892         from sympy import Product
893         if not (n.is_integer and n.is_nonnegative):
894             return self
895         k = Dummy('k', integer=True, positive=True)
896         return Product((n + k) / k, (k, 2, n))
897 
898     def _eval_evalf(self, prec):
899         from sympy import gamma
900         if self.args[0].is_number:
901             return self.rewrite(gamma)._eval_evalf(prec)
902 
903 
904 #----------------------------------------------------------------------------#
905 #                                                                            #
906 #                           Genocchi numbers                                 #
907 #                                                                            #
908 #----------------------------------------------------------------------------#
909 
910 
911 class genocchi(Function):
912     r"""
913     Genocchi numbers
914 
915     The Genocchi numbers are a sequence of integers G_n that satisfy the
916     relation::
917 
918                            oo
919                          ____
920                          \   `
921                  2*t      \         n
922                 ------ =   \   G_n*t
923                  t         /   ------
924                 e  + 1    /      n!
925                          /___,
926                          n = 1
927 
928     Examples
929     ========
930 
931     >>> from sympy import Symbol
932     >>> from sympy.functions import genocchi
933     >>> [genocchi(n) for n in range(1, 9)]
934     [1, -1, 0, 1, 0, -3, 0, 17]
935     >>> n = Symbol('n', integer=True, positive=True)
936     >>> genocchi(2 * n + 1)
937     0
938 
939     References
940     ==========
941 
942     .. [1] https://en.wikipedia.org/wiki/Genocchi_number
943     .. [2] http://mathworld.wolfram.com/GenocchiNumber.html
944 
945     See Also
946     ========
947 
948     bell, bernoulli, catalan, euler, fibonacci, harmonic, lucas
949     """
950 
951     @classmethod
952     def eval(cls, n):
953         if n.is_Number:
954             if (not n.is_Integer) or n.is_nonpositive:
955                 raise ValueError("Genocchi numbers are defined only for " +
956                                  "positive integers")
957             return 2 * (1 - S(2) ** n) * bernoulli(n)
958 
959         if n.is_odd and (n - 1).is_positive:
960             return S.Zero
961 
962         if (n - 1).is_zero:
963             return S.One
964 
965     def _eval_rewrite_as_bernoulli(self, n):
966         if n.is_integer and n.is_nonnegative:
967             return (1 - S(2) ** n) * bernoulli(n) * 2
968 
969     def _eval_is_integer(self):
970         if self.args[0].is_integer and self.args[0].is_positive:
971             return True
972 
973     def _eval_is_negative(self):
974         n = self.args[0]
975         if n.is_integer and n.is_positive:
976             if n.is_odd:
977                 return False
978             return (n / 2).is_odd
979 
980     def _eval_is_positive(self):
981         n = self.args[0]
982         if n.is_integer and n.is_positive:
983             if n.is_odd:
984                 return fuzzy_not((n - 1).is_positive)
985             return (n / 2).is_even
986 
987     def _eval_is_even(self):
988         n = self.args[0]
989         if n.is_integer and n.is_positive:
990             if n.is_even:
991                 return False
992             return (n - 1).is_positive
993 
994     def _eval_is_odd(self):
995         n = self.args[0]
996         if n.is_integer and n.is_positive:
997             if n.is_even:
998                 return True
999             return fuzzy_not((n - 1).is_positive)
1000 
1001     def _eval_is_prime(self):
1002         n = self.args[0]
1003         # only G_6 = -3 and G_8 = 17 are prime,
1004         # but SymPy does not consider negatives as prime
1005         # so only n=8 is tested
1006         return (n - 8).is_zero
1007 
1008 
1009 #######################################################################
1010 ###
1011 ### Functions for enumerating partitions, permutations and combinations
1012 ###
1013 #######################################################################
1014 
1015 
1016 class _MultisetHistogram(tuple):
1017     pass
1018 
1019 
1020 _N = -1
1021 _ITEMS = -2
1022 _M = slice(None, _ITEMS)
1023 
1024 
1025 def _multiset_histogram(n):
1026     """Return tuple used in permutation and combination counting. Input
1027     is a dictionary giving items with counts as values or a sequence of
1028     items (which need not be sorted).
1029 
1030     The data is stored in a class deriving from tuple so it is easily
1031     recognized and so it can be converted easily to a list.
1032     """
1033     if type(n) is dict:  # item: count
1034         if not all(isinstance(v, int) and v >= 0 for v in n.values()):
1035             raise ValueError
1036         tot = sum(n.values())
1037         items = sum(1 for k in n if n[k] > 0)
1038         return _MultisetHistogram([n[k] for k in n if n[k] > 0] + [items, tot])
1039     else:
1040         n = list(n)
1041         s = set(n)
1042         if len(s) == len(n):
1043             n = [1]*len(n)
1044             n.extend([len(n), len(n)])
1045             return _MultisetHistogram(n)
1046         m = dict(zip(s, range(len(s))))
1047         d = dict(zip(range(len(s)), [0]*len(s)))
1048         for i in n:
1049             d[m[i]] += 1
1050         return _multiset_histogram(d)
1051 
1052 
1053 def nP(n, k=None, replacement=False):
1054     """Return the number of permutations of ``n`` items taken ``k`` at a time.
1055 
1056     Possible values for ``n``::
1057         integer - set of length ``n``
1058         sequence - converted to a multiset internally
1059         multiset - {element: multiplicity}
1060 
1061     If ``k`` is None then the total of all permutations of length 0
1062     through the number of items represented by ``n`` will be returned.
1063 
1064     If ``replacement`` is True then a given item can appear more than once
1065     in the ``k`` items. (For example, for 'ab' permutations of 2 would
1066     include 'aa', 'ab', 'ba' and 'bb'.) The multiplicity of elements in
1067     ``n`` is ignored when ``replacement`` is True but the total number
1068     of elements is considered since no element can appear more times than
1069     the number of elements in ``n``.
1070 
1071     Examples
1072     ========
1073 
1074     >>> from sympy.functions.combinatorial.numbers import nP
1075     >>> from sympy.utilities.iterables import multiset_permutations, multiset
1076     >>> nP(3, 2)
1077     6
1078     >>> nP('abc', 2) == nP(multiset('abc'), 2) == 6
1079     True
1080     >>> nP('aab', 2)
1081     3
1082     >>> nP([1, 2, 2], 2)
1083     3
1084     >>> [nP(3, i) for i in range(4)]
1085     [1, 3, 6, 6]
1086     >>> nP(3) == sum(_)
1087     True
1088 
1089     When ``replacement`` is True, each item can have multiplicity
1090     equal to the length represented by ``n``:
1091 
1092     >>> nP('aabc', replacement=True)
1093     121
1094     >>> [len(list(multiset_permutations('aaaabbbbcccc', i))) for i in range(5)]
1095     [1, 3, 9, 27, 81]
1096     >>> sum(_)
1097     121
1098 
1099     References
1100     ==========
1101 
1102     .. [1] http://en.wikipedia.org/wiki/Permutation
1103 
1104     See Also
1105     ========
1106     sympy.utilities.iterables.multiset_permutations
1107 
1108     """
1109     try:
1110         n = as_int(n)
1111     except ValueError:
1112         return Integer(_nP(_multiset_histogram(n), k, replacement))
1113     return Integer(_nP(n, k, replacement))
1114 
1115 
1116 @cacheit
1117 def _nP(n, k=None, replacement=False):
1118     from sympy.functions.combinatorial.factorials import factorial
1119     from sympy.core.mul import prod
1120 
1121     if k == 0:
1122         return 1
1123     if isinstance(n, SYMPY_INTS):  # n different items
1124         # assert n >= 0
1125         if k is None:
1126             return sum(_nP(n, i, replacement) for i in range(n + 1))
1127         elif replacement:
1128             return n**k
1129         elif k > n:
1130             return 0
1131         elif k == n:
1132             return factorial(k)
1133         elif k == 1:
1134             return n
1135         else:
1136             # assert k >= 0
1137             return _product(n - k + 1, n)
1138     elif isinstance(n, _MultisetHistogram):
1139         if k is None:
1140             return sum(_nP(n, i, replacement) for i in range(n[_N] + 1))
1141         elif replacement:
1142             return n[_ITEMS]**k
1143         elif k == n[_N]:
1144             return factorial(k)/prod([factorial(i) for i in n[_M] if i > 1])
1145         elif k > n[_N]:
1146             return 0
1147         elif k == 1:
1148             return n[_ITEMS]
1149         else:
1150             # assert k >= 0
1151             tot = 0
1152             n = list(n)
1153             for i in range(len(n[_M])):
1154                 if not n[i]:
1155                     continue
1156                 n[_N] -= 1
1157                 if n[i] == 1:
1158                     n[i] = 0
1159                     n[_ITEMS] -= 1
1160                     tot += _nP(_MultisetHistogram(n), k - 1)
1161                     n[_ITEMS] += 1
1162                     n[i] = 1
1163                 else:
1164                     n[i] -= 1
1165                     tot += _nP(_MultisetHistogram(n), k - 1)
1166                     n[i] += 1
1167                 n[_N] += 1
1168             return tot
1169 
1170 
1171 @cacheit
1172 def _AOP_product(n):
1173     """for n = (m1, m2, .., mk) return the coefficients of the polynomial,
1174     prod(sum(x**i for i in range(nj + 1)) for nj in n); i.e. the coefficients
1175     of the product of AOPs (all-one polynomials) or order given in n.  The
1176     resulting coefficient corresponding to x**r is the number of r-length
1177     combinations of sum(n) elements with multiplicities given in n.
1178     The coefficients are given as a default dictionary (so if a query is made
1179     for a key that is not present, 0 will be returned).
1180 
1181     Examples
1182     ========
1183 
1184     >>> from sympy.functions.combinatorial.numbers import _AOP_product
1185     >>> from sympy.abc import x
1186     >>> n = (2, 2, 3)  # e.g. aabbccc
1187     >>> prod = ((x**2 + x + 1)*(x**2 + x + 1)*(x**3 + x**2 + x + 1)).expand()
1188     >>> c = _AOP_product(n); dict(c)
1189     {0: 1, 1: 3, 2: 6, 3: 8, 4: 8, 5: 6, 6: 3, 7: 1}
1190     >>> [c[i] for i in range(8)] == [prod.coeff(x, i) for i in range(8)]
1191     True
1192 
1193     The generating poly used here is the same as that listed in
1194     http://tinyurl.com/cep849r, but in a refactored form.
1195 
1196     """
1197     from collections import defaultdict
1198 
1199     n = list(n)
1200     ord = sum(n)
1201     need = (ord + 2)//2
1202     rv = [1]*(n.pop() + 1)
1203     rv.extend([0]*(need - len(rv)))
1204     rv = rv[:need]
1205     while n:
1206         ni = n.pop()
1207         N = ni + 1
1208         was = rv[:]
1209         for i in range(1, min(N, len(rv))):
1210             rv[i] += rv[i - 1]
1211         for i in range(N, need):
1212             rv[i] += rv[i - 1] - was[i - N]
1213     rev = list(reversed(rv))
1214     if ord % 2:
1215         rv = rv + rev
1216     else:
1217         rv[-1:] = rev
1218     d = defaultdict(int)
1219     for i in range(len(rv)):
1220         d[i] = rv[i]
1221     return d
1222 
1223 
1224 def nC(n, k=None, replacement=False):
1225     """Return the number of combinations of ``n`` items taken ``k`` at a time.
1226 
1227     Possible values for ``n``::
1228         integer - set of length ``n``
1229         sequence - converted to a multiset internally
1230         multiset - {element: multiplicity}
1231 
1232     If ``k`` is None then the total of all combinations of length 0
1233     through the number of items represented in ``n`` will be returned.
1234 
1235     If ``replacement`` is True then a given item can appear more than once
1236     in the ``k`` items. (For example, for 'ab' sets of 2 would include 'aa',
1237     'ab', and 'bb'.) The multiplicity of elements in ``n`` is ignored when
1238     ``replacement`` is True but the total number of elements is considered
1239     since no element can appear more times than the number of elements in
1240     ``n``.
1241 
1242     Examples
1243     ========
1244 
1245     >>> from sympy.functions.combinatorial.numbers import nC
1246     >>> from sympy.utilities.iterables import multiset_combinations
1247     >>> nC(3, 2)
1248     3
1249     >>> nC('abc', 2)
1250     3
1251     >>> nC('aab', 2)
1252     2
1253 
1254     When ``replacement`` is True, each item can have multiplicity
1255     equal to the length represented by ``n``:
1256 
1257     >>> nC('aabc', replacement=True)
1258     35
1259     >>> [len(list(multiset_combinations('aaaabbbbcccc', i))) for i in range(5)]
1260     [1, 3, 6, 10, 15]
1261     >>> sum(_)
1262     35
1263 
1264     If there are ``k`` items with multiplicities ``m_1, m_2, ..., m_k``
1265     then the total of all combinations of length 0 hrough ``k`` is the
1266     product, ``(m_1 + 1)*(m_2 + 1)*...*(m_k + 1)``. When the multiplicity
1267     of each item is 1 (i.e., k unique items) then there are 2**k
1268     combinations. For example, if there are 4 unique items, the total number
1269     of combinations is 16:
1270 
1271     >>> sum(nC(4, i) for i in range(5))
1272     16
1273 
1274     References
1275     ==========
1276 
1277     .. [1] http://en.wikipedia.org/wiki/Combination
1278     .. [2] http://tinyurl.com/cep849r
1279 
1280     See Also
1281     ========
1282     sympy.utilities.iterables.multiset_combinations
1283     """
1284     from sympy.functions.combinatorial.factorials import binomial
1285     from sympy.core.mul import prod
1286 
1287     if isinstance(n, SYMPY_INTS):
1288         if k is None:
1289             if not replacement:
1290                 return 2**n
1291             return sum(nC(n, i, replacement) for i in range(n + 1))
1292         if k < 0:
1293             raise ValueError("k cannot be negative")
1294         if replacement:
1295             return binomial(n + k - 1, k)
1296         return binomial(n, k)
1297     if isinstance(n, _MultisetHistogram):
1298         N = n[_N]
1299         if k is None:
1300             if not replacement:
1301                 return prod(m + 1 for m in n[_M])
1302             return sum(nC(n, i, replacement) for i in range(N + 1))
1303         elif replacement:
1304             return nC(n[_ITEMS], k, replacement)
1305         # assert k >= 0
1306         elif k in (1, N - 1):
1307             return n[_ITEMS]
1308         elif k in (0, N):
1309             return 1
1310         return _AOP_product(tuple(n[_M]))[k]
1311     else:
1312         return nC(_multiset_histogram(n), k, replacement)
1313 
1314 
1315 @cacheit
1316 def _stirling1(n, k):
1317     if n == k == 0:
1318         return S.One
1319     if 0 in (n, k):
1320         return S.Zero
1321     n1 = n - 1
1322 
1323     # some special values
1324     if n == k:
1325         return S.One
1326     elif k == 1:
1327         return factorial(n1)
1328     elif k == n1:
1329         return binomial(n, 2)
1330     elif k == n - 2:
1331         return (3*n - 1)*binomial(n, 3)/4
1332     elif k == n - 3:
1333         return binomial(n, 2)*binomial(n, 4)
1334 
1335     # general recurrence
1336     return n1*_stirling1(n1, k) + _stirling1(n1, k - 1)
1337 
1338 
1339 @cacheit
1340 def _stirling2(n, k):
1341     if n == k == 0:
1342         return S.One
1343     if 0 in (n, k):
1344         return S.Zero
1345     n1 = n - 1
1346 
1347     # some special values
1348     if k == n1:
1349         return binomial(n, 2)
1350     elif k == 2:
1351         return 2**n1 - 1
1352 
1353     # general recurrence
1354     return k*_stirling2(n1, k) + _stirling2(n1, k - 1)
1355 
1356 
1357 def stirling(n, k, d=None, kind=2, signed=False):
1358     """Return Stirling number S(n, k) of the first or second (default) kind.
1359 
1360     The sum of all Stirling numbers of the second kind for k = 1
1361     through n is bell(n). The recurrence relationship for these numbers
1362     is::
1363 
1364     {0}       {n}   {0}      {n + 1}     {n}   {  n  }
1365     { } = 1;  { } = { } = 0; {     } = j*{ } + {     }
1366     {0}       {0}   {k}      {  k  }     {k}   {k - 1}
1367 
1368     where ``j`` is::
1369         ``n`` for Stirling numbers of the first kind
1370         ``-n`` for signed Stirling numbers of the first kind
1371         ``k`` for Stirling numbers of the second kind
1372 
1373     The first kind of Stirling number counts the number of permutations of
1374     ``n`` distinct items that have ``k`` cycles; the second kind counts the
1375     ways in which ``n`` distinct items can be partitioned into ``k`` parts.
1376     If ``d`` is given, the "reduced Stirling number of the second kind" is
1377     returned: ``S^{d}(n, k) = S(n - d + 1, k - d + 1)`` with ``n >= k >= d``.
1378     (This counts the ways to partition ``n`` consecutive integers into
1379     ``k`` groups with no pairwise difference less than ``d``. See example
1380     below.)
1381 
1382     To obtain the signed Stirling numbers of the first kind, use keyword
1383     ``signed=True``. Using this keyword automatically sets ``kind`` to 1.
1384 
1385     Examples
1386     ========
1387 
1388     >>> from sympy.functions.combinatorial.numbers import stirling, bell
1389     >>> from sympy.combinatorics import Permutation
1390     >>> from sympy.utilities.iterables import multiset_partitions, permutations
1391 
1392     First kind (unsigned by default):
1393 
1394     >>> [stirling(6, i, kind=1) for i in range(7)]
1395     [0, 120, 274, 225, 85, 15, 1]
1396     >>> perms = list(permutations(range(4)))
1397     >>> [sum(Permutation(p).cycles == i for p in perms) for i in range(5)]
1398     [0, 6, 11, 6, 1]
1399     >>> [stirling(4, i, kind=1) for i in range(5)]
1400     [0, 6, 11, 6, 1]
1401 
1402     First kind (signed):
1403 
1404     >>> [stirling(4, i, signed=True) for i in range(5)]
1405     [0, -6, 11, -6, 1]
1406 
1407     Second kind:
1408 
1409     >>> [stirling(10, i) for i in range(12)]
1410     [0, 1, 511, 9330, 34105, 42525, 22827, 5880, 750, 45, 1, 0]
1411     >>> sum(_) == bell(10)
1412     True
1413     >>> len(list(multiset_partitions(range(4), 2))) == stirling(4, 2)
1414     True
1415 
1416     Reduced second kind:
1417 
1418     >>> from sympy import subsets, oo
1419     >>> def delta(p):
1420     ...    if len(p) == 1:
1421     ...        return oo
1422     ...    return min(abs(i[0] - i[1]) for i in subsets(p, 2))
1423     >>> parts = multiset_partitions(range(5), 3)
1424     >>> d = 2
1425     >>> sum(1 for p in parts if all(delta(i) >= d for i in p))
1426     7
1427     >>> stirling(5, 3, 2)
1428     7
1429 
1430     References
1431     ==========
1432 
1433     .. [1] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind
1434     .. [2] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind
1435 
1436     See Also
1437     ========
1438     sympy.utilities.iterables.multiset_partitions
1439 
1440     """
1441     # TODO: make this a class like bell()
1442 
1443     n = as_int(n)
1444     k = as_int(k)
1445     if n < 0:
1446         raise ValueError('n must be nonnegative')
1447     if k > n:
1448         return S.Zero
1449     if d:
1450         # assert k >= d
1451         # kind is ignored -- only kind=2 is supported
1452         return _stirling2(n - d + 1, k - d + 1)
1453     elif signed:
1454         # kind is ignored -- only kind=1 is supported
1455         return (-1)**(n - k)*_stirling1(n, k)
1456 
1457     if kind == 1:
1458         return _stirling1(n, k)
1459     elif kind == 2:
1460         return _stirling2(n, k)
1461     else:
1462         raise ValueError('kind must be 1 or 2, not %s' % k)
1463 
1464 
1465 @cacheit
1466 def _nT(n, k):
1467     """Return the partitions of ``n`` items into ``k`` parts. This
1468     is used by ``nT`` for the case when ``n`` is an integer."""
1469     if k == 0:
1470         return 1 if k == n else 0
1471     return sum(_nT(n - k, j) for j in range(min(k, n - k) + 1))
1472 
1473 
1474 def nT(n, k=None):
1475     """Return the number of ``k``-sized partitions of ``n`` items.
1476 
1477     Possible values for ``n``::
1478         integer - ``n`` identical items
1479         sequence - converted to a multiset internally
1480         multiset - {element: multiplicity}
1481 
1482     Note: the convention for ``nT`` is different than that of ``nC`` and
1483     ``nP`` in that
1484     here an integer indicates ``n`` *identical* items instead of a set of
1485     length ``n``; this is in keeping with the ``partitions`` function which
1486     treats its integer-``n`` input like a list of ``n`` 1s. One can use
1487     ``range(n)`` for ``n`` to indicate ``n`` distinct items.
1488 
1489     If ``k`` is None then the total number of ways to partition the elements
1490     represented in ``n`` will be returned.
1491 
1492     Examples
1493     ========
1494 
1495     >>> from sympy.functions.combinatorial.numbers import nT
1496 
1497     Partitions of the given multiset:
1498 
1499     >>> [nT('aabbc', i) for i in range(1, 7)]
1500     [1, 8, 11, 5, 1, 0]
1501     >>> nT('aabbc') == sum(_)
1502     True
1503 
1504     >>> [nT("mississippi", i) for i in range(1, 12)]
1505     [1, 74, 609, 1521, 1768, 1224, 579, 197, 50, 9, 1]
1506 
1507     Partitions when all items are identical:
1508 
1509     >>> [nT(5, i) for i in range(1, 6)]
1510     [1, 2, 2, 1, 1]
1511     >>> nT('1'*5) == sum(_)
1512     True
1513 
1514     When all items are different:
1515 
1516     >>> [nT(range(5), i) for i in range(1, 6)]
1517     [1, 15, 25, 10, 1]
1518     >>> nT(range(5)) == sum(_)
1519     True
1520 
1521     References
1522     ==========
1523 
1524     .. [1] http://undergraduate.csse.uwa.edu.au/units/CITS7209/partition.pdf
1525 
1526     See Also
1527     ========
1528     sympy.utilities.iterables.partitions
1529     sympy.utilities.iterables.multiset_partitions
1530 
1531     """
1532     from sympy.utilities.enumerative import MultisetPartitionTraverser
1533 
1534     if isinstance(n, SYMPY_INTS):
1535         # assert n >= 0
1536         # all the same
1537         if k is None:
1538             return sum(_nT(n, k) for k in range(1, n + 1))
1539         return _nT(n, k)
1540     if not isinstance(n, _MultisetHistogram):
1541         try:
1542             # if n contains hashable items there is some
1543             # quick handling that can be done
1544             u = len(set(n))
1545             if u == 1:
1546                 return nT(len(n), k)
1547             elif u == len(n):
1548                 n = range(u)
1549             raise TypeError
1550         except TypeError:
1551             n = _multiset_histogram(n)
1552     N = n[_N]
1553     if k is None and N == 1:
1554         return 1
1555     if k in (1, N):
1556         return 1
1557     if k == 2 or N == 2 and k is None:
1558         m, r = divmod(N, 2)
1559         rv = sum(nC(n, i) for i in range(1, m + 1))
1560         if not r:
1561             rv -= nC(n, m)//2
1562         if k is None:
1563             rv += 1  # for k == 1
1564         return rv
1565     if N == n[_ITEMS]:
1566         # all distinct
1567         if k is None:
1568             return bell(N)
1569         return stirling(N, k)
1570     m = MultisetPartitionTraverser()
1571     if k is None:
1572         return m.count_partitions(n[_M])
1573     # MultisetPartitionTraverser does not have a range-limited count
1574     # method, so need to enumerate and count
1575     tot = 0
1576     for discard in m.enum_range(n[_M], k-1, k):
1577         tot += 1
1578     return tot

</code><intended_behavior>Ensure that any usage or reference to ff and rf within this file reflects the correct and intended mathematical definitions. If these functions' behavior was altered in a way that affects the calculations or results of combinatorial numbers, the intention would be to revert or fix these changes to align with expected outcomes.</intended_behavior>]
2025-10-17 19:47:45.973 | INFO     | Search completed. Bug locations: [<file>sympy/functions/combinatorial/factorials.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from sympy.core import S, sympify, Dummy, Mod
4 from sympy.core.function import Function, ArgumentIndexError
5 from sympy.core.logic import fuzzy_and
6 from sympy.core.numbers import Integer, pi
7 from sympy.core.relational import Eq
8 
9 from sympy.ntheory import sieve
10 
11 from math import sqrt as _sqrt
12 
13 from sympy.core.compatibility import reduce, range, HAS_GMPY
14 from sympy.core.cache import cacheit
15 
16 from sympy.polys.polytools import poly_from_expr
17 from sympy.polys.polyerrors import PolificationFailed
18 
19 
20 class CombinatorialFunction(Function):
21     """Base class for combinatorial functions. """
22 
23     def _eval_simplify(self, ratio, measure):
24         from sympy.simplify.simplify import combsimp
25         expr = combsimp(self)
26         if measure(expr) <= ratio*measure(self):
27             return expr
28         return self
29 
30 ###############################################################################
31 ######################## FACTORIAL and MULTI-FACTORIAL ########################
32 ###############################################################################
33 
34 
35 class factorial(CombinatorialFunction):
36     """Implementation of factorial function over nonnegative integers.
37        By convention (consistent with the gamma function and the binomial
38        coefficients), factorial of a negative integer is complex infinity.
39 
40        The factorial is very important in combinatorics where it gives
41        the number of ways in which `n` objects can be permuted. It also
42        arises in calculus, probability, number theory, etc.
43 
44        There is strict relation of factorial with gamma function. In
45        fact n! = gamma(n+1) for nonnegative integers. Rewrite of this
46        kind is very useful in case of combinatorial simplification.
47 
48        Computation of the factorial is done using two algorithms. For
49        small arguments a precomputed look up table is used. However for bigger
50        input algorithm Prime-Swing is used. It is the fastest algorithm
51        known and computes n! via prime factorization of special class
52        of numbers, called here the 'Swing Numbers'.
53 
54        Examples
55        ========
56 
57        >>> from sympy import Symbol, factorial, S
58        >>> n = Symbol('n', integer=True)
59 
60        >>> factorial(0)
61        1
62 
63        >>> factorial(7)
64        5040
65 
66        >>> factorial(-2)
67        zoo
68 
69        >>> factorial(n)
70        factorial(n)
71 
72        >>> factorial(2*n)
73        factorial(2*n)
74 
75        >>> factorial(S(1)/2)
76        factorial(1/2)
77 
78        See Also
79        ========
80 
81        factorial2, RisingFactorial, FallingFactorial
82     """
83 
84     def fdiff(self, argindex=1):
85         from sympy import gamma, polygamma
86         if argindex == 1:
87             return gamma(self.args[0] + 1)*polygamma(0, self.args[0] + 1)
88         else:
89             raise ArgumentIndexError(self, argindex)
90 
91     _small_swing = [
92         1, 1, 1, 3, 3, 15, 5, 35, 35, 315, 63, 693, 231, 3003, 429, 6435, 6435, 109395,
93         12155, 230945, 46189, 969969, 88179, 2028117, 676039, 16900975, 1300075,
94         35102025, 5014575, 145422675, 9694845, 300540195, 300540195
95     ]
96 
97     _small_factorials = []
98 
99     @classmethod
100     def _swing(cls, n):
101         if n < 33:
102             return cls._small_swing[n]
103         else:
104             N, primes = int(_sqrt(n)), []
105 
106             for prime in sieve.primerange(3, N + 1):
107                 p, q = 1, n
108 
109                 while True:
110                     q //= prime
111 
112                     if q > 0:
113                         if q & 1 == 1:
114                             p *= prime
115                     else:
116                         break
117 
118                 if p > 1:
119                     primes.append(p)
120 
121             for prime in sieve.primerange(N + 1, n//3 + 1):
122                 if (n // prime) & 1 == 1:
123                     primes.append(prime)
124 
125             L_product = R_product = 1
126 
127             for prime in sieve.primerange(n//2 + 1, n + 1):
128                 L_product *= prime
129 
130             for prime in primes:
131                 R_product *= prime
132 
133             return L_product*R_product
134 
135     @classmethod
136     def _recursive(cls, n):
137         if n < 2:
138             return 1
139         else:
140             return (cls._recursive(n//2)**2)*cls._swing(n)
141 
142     @classmethod
143     def eval(cls, n):
144         n = sympify(n)
145 
146         if n.is_Number:
147             if n is S.Zero:
148                 return S.One
149             elif n is S.Infinity:
150                 return S.Infinity
151             elif n.is_Integer:
152                 if n.is_negative:
153                     return S.ComplexInfinity
154                 else:
155                     n = n.p
156 
157                     if n < 20:
158                         if not cls._small_factorials:
159                             result = 1
160                             for i in range(1, 20):
161                                 result *= i
162                                 cls._small_factorials.append(result)
163                         result = cls._small_factorials[n-1]
164 
165                     # GMPY factorial is faster, use it when available
166                     elif HAS_GMPY:
167                         from sympy.core.compatibility import gmpy
168                         result = gmpy.fac(n)
169 
170                     else:
171                         bits = bin(n).count('1')
172                         result = cls._recursive(n)*2**(n - bits)
173 
174                     return Integer(result)
175 
176     def _eval_rewrite_as_gamma(self, n):
177         from sympy import gamma
178         return gamma(n + 1)
179 
180     def _eval_rewrite_as_Product(self, n):
181         from sympy import Product
182         if n.is_nonnegative and n.is_integer:
183             i = Dummy('i', integer=True)
184             return Product(i, (i, 1, n))
185 
186     def _eval_is_integer(self):
187         if self.args[0].is_integer and self.args[0].is_nonnegative:
188             return True
189 
190     def _eval_is_positive(self):
191         if self.args[0].is_integer and self.args[0].is_nonnegative:
192             return True
193 
194     def _eval_is_composite(self):
195         x = self.args[0]
196         if x.is_integer:
197             return (x - 3).is_nonnegative
198 
199     def _eval_is_real(self):
200         x = self.args[0]
201         if x.is_nonnegative or x.is_noninteger:
202             return True
203 
204 
205 class MultiFactorial(CombinatorialFunction):
206     pass
207 
208 
209 class subfactorial(CombinatorialFunction):
210     r"""The subfactorial counts the derangements of n items and is
211     defined for non-negative integers as::
212 
213               ,
214              |  1                             for n = 0
215         !n = {  0                             for n = 1
216              |  (n - 1)*(!(n - 1) + !(n - 2)) for n > 1
217               `
218 
219     It can also be written as int(round(n!/exp(1))) but the recursive
220     definition with caching is implemented for this function.
221 
222     An interesting analytic expression is the following [2]_
223 
224     .. math:: !x = \Gamma(x + 1, -1)/e
225 
226     which is valid for non-negative integers x. The above formula
227     is not very useful incase of non-integers. :math:`\Gamma(x + 1, -1)` is
228     single-valued only for integral arguments x, elsewhere on the positive real
229     axis it has an infinite number of branches none of which are real.
230 
231     References
232     ==========
233 
234     .. [1] http://en.wikipedia.org/wiki/Subfactorial
235     .. [2] http://mathworld.wolfram.com/Subfactorial.html
236 
237     Examples
238     ========
239 
240     >>> from sympy import subfactorial
241     >>> from sympy.abc import n
242     >>> subfactorial(n + 1)
243     subfactorial(n + 1)
244     >>> subfactorial(5)
245     44
246 
247     See Also
248     ========
249 
250     sympy.functions.combinatorial.factorials.factorial,
251     sympy.utilities.iterables.generate_derangements,
252     sympy.functions.special.gamma_functions.uppergamma
253     """
254 
255     @classmethod
256     @cacheit
257     def _eval(self, n):
258         if not n:
259             return S.One
260         elif n == 1:
261             return S.Zero
262         return (n - 1)*(self._eval(n - 1) + self._eval(n - 2))
263 
264     @classmethod
265     def eval(cls, arg):
266         if arg.is_Number:
267             if arg.is_Integer and arg.is_nonnegative:
268                 return cls._eval(arg)
269             elif arg is S.NaN:
270                 return S.NaN
271             elif arg is S.Infinity:
272                 return S.Infinity
273 
274     def _eval_is_even(self):
275         if self.args[0].is_odd and self.args[0].is_nonnegative:
276             return True
277 
278     def _eval_is_integer(self):
279         if self.args[0].is_integer and self.args[0].is_nonnegative:
280             return True
281 
282     def _eval_rewrite_as_uppergamma(self, arg):
283         from sympy import uppergamma
284         return uppergamma(arg + 1, -1)/S.Exp1
285 
286     def _eval_is_nonnegative(self):
287         if self.args[0].is_integer and self.args[0].is_nonnegative:
288             return True
289 
290     def _eval_is_odd(self):
291         if self.args[0].is_even and self.args[0].is_nonnegative:
292             return True
293 
294 
295 class factorial2(CombinatorialFunction):
296     """The double factorial n!!, not to be confused with (n!)!
297 
298     The double factorial is defined for nonnegative integers and for odd
299     negative integers as::
300 
301                ,
302               |  n*(n - 2)*(n - 4)* ... * 1    for n positive odd
303         n!! = {  n*(n - 2)*(n - 4)* ... * 2    for n positive even
304               |  1                             for n = 0
305               |  (n+2)!! / (n+2)               for n negative odd
306                `
307 
308     References
309     ==========
310     .. [1] https://en.wikipedia.org/wiki/Double_factorial
311 
312     Examples
313     ========
314 
315     >>> from sympy import factorial2, var
316     >>> var('n')
317     n
318     >>> factorial2(n + 1)
319     factorial2(n + 1)
320     >>> factorial2(5)
321     15
322     >>> factorial2(-1)
323     1
324     >>> factorial2(-5)
325     1/3
326 
327     See Also
328     ========
329 
330     factorial, RisingFactorial, FallingFactorial
331     """
332 
333     @classmethod
334     def eval(cls, arg):
335         # TODO: extend this to complex numbers?
336 
337         if arg.is_Number:
338             if not arg.is_Integer:
339                 raise ValueError("argument must be nonnegative integer or negative odd integer")
340 
341             # This implementation is faster than the recursive one
342             # It also avoids "maximum recursion depth exceeded" runtime error
343             if arg.is_nonnegative:
344                 if arg.is_even:
345                     k = arg / 2
346                     return 2 ** k * factorial(k)
347                 return factorial(arg) / factorial2(arg - 1)
348 
349 
350             if arg.is_odd:
351                 return arg * (S.NegativeOne) ** ((1 - arg) / 2) / factorial2(-arg)
352             raise ValueError("argument must be nonnegative integer or negative odd integer")
353 
354 
355     def _eval_is_even(self):
356         # Double factorial is even for every positive even input
357         n = self.args[0]
358         if n.is_integer:
359             if n.is_odd:
360                 return False
361             if n.is_even:
362                 if n.is_positive:
363                     return True
364                 if n.is_zero:
365                     return False
366 
367     def _eval_is_integer(self):
368         # Double factorial is an integer for every nonnegative input, and for
369         # -1 and -3
370         n = self.args[0]
371         if n.is_integer:
372             if (n + 1).is_nonnegative:
373                 return True
374             if n.is_odd:
375                 return (n + 3).is_nonnegative
376 
377     def _eval_is_odd(self):
378         # Double factorial is odd for every odd input not smaller than -3, and
379         # for 0
380         n = self.args[0]
381         if n.is_odd:
382             return (n + 3).is_nonnegative
383         if n.is_even:
384             if n.is_positive:
385                 return False
386             if n.is_zero:
387                 return True
388 
389     def _eval_is_positive(self):
390         # Double factorial is positive for every nonnegative input, and for
391         # every odd negative input which is of the form -1-4k for an
392         # nonnegative integer k
393         n = self.args[0]
394         if n.is_integer:
395             if (n + 1).is_nonnegative:
396                 return True
397             if n.is_odd:
398                 return ((n + 1) / 2).is_even
399 
400     def _eval_rewrite_as_gamma(self, n):
401         from sympy import gamma, Piecewise, sqrt
402         return 2**(n/2)*gamma(n/2 + 1) * Piecewise((1, Eq(Mod(n, 2), 0)), (sqrt(2/pi), Eq(Mod(n, 2), 1)))
403 
404 
405 ###############################################################################
406 ######################## RISING and FALLING FACTORIALS ########################
407 ###############################################################################
408 
409 
410 class RisingFactorial(CombinatorialFunction):
411     """Rising factorial (also called Pochhammer symbol) is a double valued
412     function arising in concrete mathematics, hypergeometric functions
413     and series expansions. It is defined by:
414 
415                 rf(x, k) = x * (x + 1) * ... * (x + k - 1)
416 
417     where 'x' can be arbitrary expression and 'k' is an integer. For
418     more information check "Concrete mathematics" by Graham, pp. 66
419     or visit http://mathworld.wolfram.com/RisingFactorial.html page.
420 
421     When x is a polynomial f of a single variable y of order >= 1,
422     rf(x,k) = f(y) * f(y+1) * ... * f(x+k-1) as described in
423     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
424     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
425 
426     Examples
427     ========
428 
429     >>> from sympy import rf, symbols, factorial, ff, binomial
430     >>> from sympy.abc import x
431     >>> n, k = symbols('n k', integer=True)
432     >>> rf(x, 0)
433     1
434     >>> rf(1, 5)
435     120
436     >>> rf(x, 5) == x*(1 + x)*(2 + x)*(3 + x)*(4 + x)
437     True
438     >>> rf(x**3, 2)
439     Poly(x**6 + 3*x**5 + 3*x**4 + x**3, x, domain='ZZ')
440 
441     Rewrite
442 
443     >>> rf(x, k).rewrite(ff)
444     FallingFactorial(k + x - 1, k)
445     >>> rf(x, k).rewrite(binomial)
446     binomial(k + x - 1, k)*factorial(k)
447     >>> rf(n, k).rewrite(factorial)
448     factorial(k + n - 1)/factorial(n - 1)
449 
450     See Also
451     ========
452 
453     factorial, factorial2, FallingFactorial
454 
455     References
456     ==========
457 
458     .. [1] https://en.wikipedia.org/wiki/Pochhammer_symbol
459     """
460 
461     @classmethod
462     def eval(cls, x, k):
463         x = sympify(x)
464         k = sympify(k)
465 
466         if x is S.NaN or k is S.NaN:
467             return S.NaN
468         elif x is S.One:
469             return factorial(k)
470         elif k.is_Integer:
471             if k is S.Zero:
472                 return S.One
473             else:
474                 if k.is_positive:
475                     if x is S.Infinity:
476                         return S.Infinity
477                     elif x is S.NegativeInfinity:
478                         if k.is_odd:
479                             return S.NegativeInfinity
480                         else:
481                             return S.Infinity
482                     else:
483                         try:
484                             F, opt = poly_from_expr(x)
485                         except PolificationFailed:
486                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
487                         if len(opt.gens) > 1 or F.degree() <= 1:
488                             return reduce(lambda r, i: r*(x + i), range(0, int(k)), 1)
489                         else:
490                             v = opt.gens[0]
491                             return reduce(lambda r, i:
492                                           r*(F.subs(v, v + i).expand()),
493                                           range(0, int(k)), 1)
494                 else:
495                     if x is S.Infinity:
496                         return S.Infinity
497                     elif x is S.NegativeInfinity:
498                         return S.Infinity
499                     else:
500                         try:
501                             F, opt = poly_from_expr(x)
502                         except PolificationFailed:
503                             return 1/reduce(lambda r, i:
504                                             r*(x - i),
505                                             range(1, abs(int(k)) + 1), 1)
506                         if len(opt.gens) > 1 or F.degree() <= 1:
507                             return 1/reduce(lambda r, i:
508                                             r*(x - i),
509                                             range(1, abs(int(k)) + 1), 1)
510                         else:
511                             v = opt.gens[0]
512                             return 1/reduce(lambda r, i:
513                                             r*(F.subs(v, v - i).expand()),
514                                             range(1, abs(int(k)) + 1), 1)
515 
516     def _eval_rewrite_as_gamma(self, x, k):
517         from sympy import gamma
518         return gamma(x + k) / gamma(x)
519 
520     def _eval_rewrite_as_FallingFactorial(self, x, k):
521         return FallingFactorial(x + k - 1, k)
522 
523     def _eval_rewrite_as_factorial(self, x, k):
524         if x.is_integer and k.is_integer:
525             return factorial(k + x - 1) / factorial(x - 1)
526 
527     def _eval_rewrite_as_binomial(self, x, k):
528         if k.is_integer:
529             return factorial(k) * binomial(x + k - 1, k)
530 
531     def _eval_is_integer(self):
532         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
533                           self.args[1].is_nonnegative))
534 
535     def _sage_(self):
536         import sage.all as sage
537         return sage.rising_factorial(self.args[0]._sage_(), self.args[1]._sage_())
538 
539 
540 class FallingFactorial(CombinatorialFunction):
541     """Falling factorial (related to rising factorial) is a double valued
542     function arising in concrete mathematics, hypergeometric functions
543     and series expansions. It is defined by
544 
545                 ff(x, k) = x * (x-1) * ... * (x - k+1)
546 
547     where 'x' can be arbitrary expression and 'k' is an integer. For
548     more information check "Concrete mathematics" by Graham, pp. 66
549     or visit http://mathworld.wolfram.com/FallingFactorial.html page.
550 
551     When x is a polynomial f of a single variable y of order >= 1,
552     ff(x,k) = f(y) * f(y-1) * ... * f(x-k+1) as described in
553     Peter Paule, "Greatest Factorial Factorization and Symbolic Summation",
554     Journal of Symbolic Computation, vol. 20, pp. 235-268, 1995.
555 
556     >>> from sympy import ff, factorial, rf, gamma, polygamma, binomial, symbols
557     >>> from sympy.abc import x, k
558     >>> n, m = symbols('n m', integer=True)
559     >>> ff(x, 0)
560     1
561     >>> ff(5, 5)
562     120
563     >>> ff(x, 5) == x*(x-1)*(x-2)*(x-3)*(x-4)
564     True
565     >>> ff(x**2, 2)
566     Poly(x**4 - 2*x**3 + x**2, x, domain='ZZ')
567     >>> ff(n, n)
568     factorial(n)
569 
570     Rewrite
571 
572     >>> ff(x, k).rewrite(gamma)
573     (-1)**k*gamma(k - x)/gamma(-x)
574     >>> ff(x, k).rewrite(rf)
575     RisingFactorial(-k + x + 1, k)
576     >>> ff(x, m).rewrite(binomial)
577     binomial(x, m)*factorial(m)
578     >>> ff(n, m).rewrite(factorial)
579     factorial(n)/factorial(-m + n)
580 
581     See Also
582     ========
583 
584     factorial, factorial2, RisingFactorial
585 
586     References
587     ==========
588 
589     .. [1] http://mathworld.wolfram.com/FallingFactorial.html
590     """
591 
592     @classmethod
593     def eval(cls, x, k):
594         x = sympify(x)
595         k = sympify(k)
596 
597         if x is S.NaN or k is S.NaN:
598             return S.NaN
599         elif k.is_integer and x == k:
600             return factorial(x)
601         elif k.is_Integer:
602             if k is S.Zero:
603                 return S.One
604             else:
605                 if k.is_positive:
606                     if x is S.Infinity:
607                         return S.Infinity
608                     elif x is S.NegativeInfinity:
609                         if k.is_odd:
610                             return S.NegativeInfinity
611                         else:
612                             return S.Infinity
613                     else:
614                         try:
615                             F, opt = poly_from_expr(x)
616                         except PolificationFailed:
617                             return reduce(lambda r, i: r*(x - i),
618                                           range(0, int(k)), 1)
619                         if len(opt.gens) > 1 or F.degree() <= 1:
620                             return reduce(lambda r, i: r*(x - i),
621                                           range(0, int(k)), 1)
622                         else:
623                             v = opt.gens[0]
624                             return reduce(lambda r, i:
625                                           r*(F.subs(v, v - i).expand()),
626                                           range(0, int(k)), 1)
627                 else:
628                     if x is S.Infinity:
629                         return S.Infinity
630                     elif x is S.NegativeInfinity:
631                         return S.Infinity
632                     else:
633                         try:
634                             F, opt = poly_from_expr(x)
635                         except PolificationFailed:
636                             return 1/reduce(lambda r, i: r*(x + i),
637                                             range(1, abs(int(k)) + 1), 1)
638                         if len(opt.gens) > 1 or F.degree() <= 1:
639                             return 1/reduce(lambda r, i: r*(x + i),
640                                             range(1, abs(int(k)) + 1), 1)
641                         else:
642                             v = opt.gens[0]
643                             return 1/reduce(lambda r, i:
644                                             r*(F.subs(v, v + i).expand()),
645                                             range(1, abs(int(k)) + 1), 1)
646 
647     def _eval_rewrite_as_gamma(self, x, k):
648         from sympy import gamma
649         return (-1)**k*gamma(k - x) / gamma(-x)
650 
651     def _eval_rewrite_as_RisingFactorial(self, x, k):
652         return rf(x - k + 1, k)
653 
654     def _eval_rewrite_as_binomial(self, x, k):
655         if k.is_integer:
656             return factorial(k) * binomial(x, k)
657 
658     def _eval_rewrite_as_factorial(self, x, k):
659         if x.is_integer and k.is_integer:
660             return factorial(x) / factorial(x - k)
661 
662     def _eval_is_integer(self):
663         return fuzzy_and((self.args[0].is_integer, self.args[1].is_integer,
664                           self.args[1].is_nonnegative))
665 
666     def _sage_(self):
667         import sage.all as sage
668         return sage.falling_factorial(self.args[0]._sage_(),
669                                       self.args[1]._sage_())
670 
671 
672 rf = RisingFactorial
673 ff = FallingFactorial
674 
675 ###############################################################################
676 ########################### BINOMIAL COEFFICIENTS #############################
677 ###############################################################################
678 
679 
680 class binomial(CombinatorialFunction):
681     """Implementation of the binomial coefficient. It can be defined
682     in two ways depending on its desired interpretation:
683 
684         C(n,k) = n!/(k!(n-k)!)   or   C(n, k) = ff(n, k)/k!
685 
686     First, in a strict combinatorial sense it defines the
687     number of ways we can choose 'k' elements from a set of
688     'n' elements. In this case both arguments are nonnegative
689     integers and binomial is computed using an efficient
690     algorithm based on prime factorization.
691 
692     The other definition is generalization for arbitrary 'n',
693     however 'k' must also be nonnegative. This case is very
694     useful when evaluating summations.
695 
696     For the sake of convenience for negative 'k' this function
697     will return zero no matter what valued is the other argument.
698 
699     To expand the binomial when n is a symbol, use either
700     expand_func() or expand(func=True). The former will keep the
701     polynomial in factored form while the latter will expand the
702     polynomial itself. See examples for details.
703 
704     Examples
705     ========
706 
707     >>> from sympy import Symbol, Rational, binomial, expand_func
708     >>> n = Symbol('n', integer=True, positive=True)
709 
710     >>> binomial(15, 8)
711     6435
712 
713     >>> binomial(n, -1)
714     0
715 
716     Rows of Pascal's triangle can be generated with the binomial function:
717 
718     >>> for N in range(8):
719     ...     print([ binomial(N, i) for i in range(N + 1)])
720     ...
721     [1]
722     [1, 1]
723     [1, 2, 1]
724     [1, 3, 3, 1]
725     [1, 4, 6, 4, 1]
726     [1, 5, 10, 10, 5, 1]
727     [1, 6, 15, 20, 15, 6, 1]
728     [1, 7, 21, 35, 35, 21, 7, 1]
729 
730     As can a given diagonal, e.g. the 4th diagonal:
731 
732     >>> N = -4
733     >>> [ binomial(N, i) for i in range(1 - N)]
734     [1, -4, 10, -20, 35]
735 
736     >>> binomial(Rational(5, 4), 3)
737     -5/128
738     >>> binomial(Rational(-5, 4), 3)
739     -195/128
740 
741     >>> binomial(n, 3)
742     binomial(n, 3)
743 
744     >>> binomial(n, 3).expand(func=True)
745     n**3/6 - n**2/2 + n/3
746 
747     >>> expand_func(binomial(n, 3))
748     n*(n - 2)*(n - 1)/6
749 
750     """
751 
752     def fdiff(self, argindex=1):
753         from sympy import polygamma
754         if argindex == 1:
755             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/01/
756             n, k = self.args
757             return binomial(n, k)*(polygamma(0, n + 1) - \
758                 polygamma(0, n - k + 1))
759         elif argindex == 2:
760             # http://functions.wolfram.com/GammaBetaErf/Binomial/20/01/02/
761             n, k = self.args
762             return binomial(n, k)*(polygamma(0, n - k + 1) - \
763                 polygamma(0, k + 1))
764         else:
765             raise ArgumentIndexError(self, argindex)
766 
767     @classmethod
768     def _eval(self, n, k):
769         # n.is_Number and k.is_Integer and k != 1 and n != k
770         if k.is_Integer:
771             if n.is_Integer and n >= 0:
772                 n, k = int(n), int(k)
773 
774                 if k > n:
775                     return S.Zero
776                 elif k > n // 2:
777                     k = n - k
778 
779                 M, result = int(_sqrt(n)), 1
780 
781                 for prime in sieve.primerange(2, n + 1):
782                     if prime > n - k:
783                         result *= prime
784                     elif prime > n // 2:
785                         continue
786                     elif prime > M:
787                         if n % prime < k % prime:
788                             result *= prime
789                     else:
790                         N, K = n, k
791                         exp = a = 0
792 
793                         while N > 0:
794                             a = int((N % prime) < (K % prime + a))
795                             N, K = N // prime, K // prime
796                             exp = a + exp
797 
798                         if exp > 0:
799                             result *= prime**exp
800                 return Integer(result)
801             else:
802                 d = result = n - k + 1
803                 for i in range(2, k + 1):
804                     d += 1
805                     result *= d
806                     result /= i
807                 return result
808 
809     @classmethod
810     def eval(cls, n, k):
811         n, k = map(sympify, (n, k))
812         d = n - k
813         if d.is_zero or k.is_zero:
814             return S.One
815         elif d.is_zero is False:
816             if (k - 1).is_zero:
817                 return n
818             elif k.is_negative:
819                 return S.Zero
820             elif n.is_integer and n.is_nonnegative and d.is_negative:
821                 return S.Zero
822         if k.is_Integer and k > 0 and n.is_Number:
823             return cls._eval(n, k)
824 
825     def _eval_expand_func(self, **hints):
826         """
827         Function to expand binomial(n,k) when m is positive integer
828         Also,
829         n is self.args[0] and k is self.args[1] while using binomial(n, k)
830         """
831         n = self.args[0]
832         if n.is_Number:
833             return binomial(*self.args)
834 
835         k = self.args[1]
836         if k.is_Add and n in k.args:
837             k = n - k
838 
839         if k.is_Integer:
840             if k == S.Zero:
841                 return S.One
842             elif k < 0:
843                 return S.Zero
844             else:
845                 n = self.args[0]
846                 result = n - k + 1
847                 for i in range(2, k + 1):
848                     result *= n - k + i
849                     result /= i
850                 return result
851         else:
852             return binomial(*self.args)
853 
854     def _eval_rewrite_as_factorial(self, n, k):
855         return factorial(n)/(factorial(k)*factorial(n - k))
856 
857     def _eval_rewrite_as_gamma(self, n, k):
858         from sympy import gamma
859         return gamma(n + 1)/(gamma(k + 1)*gamma(n - k + 1))
860 
861     def _eval_rewrite_as_tractable(self, n, k):
862         return self._eval_rewrite_as_gamma(n, k).rewrite('tractable')
863 
864     def _eval_rewrite_as_FallingFactorial(self, n, k):
865         if k.is_integer:
866             return ff(n, k) / factorial(k)
867 
868     def _eval_is_integer(self):
869         n, k = self.args
870         if n.is_integer and k.is_integer:
871             return True
872         elif k.is_integer is False:
873             return False

</code><intended_behavior>The intended behavior at these locations is to compute the falling factorial and rising factorial accurately according to their mathematical definitions. This means ff(n, k) should calculate the product of k consecutive numbers starting from n and decreasing, and rf(n, k) should calculate the product of k consecutive numbers starting from n and increasing. Any previous functionality that was altered leading to incorrect computations or interface changes should be reverted to preserve the expected mathematical behavior and ensure backward compatibility.</intended_behavior>, <file>sympy/functions/combinatorial/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 This module implements some special functions that commonly appear in
3 combinatorial contexts (e.g. in power series); in particular,
4 sequences of rational numbers such as Bernoulli and Fibonacci numbers.
5 
6 Factorials, binomial coefficients and related functions are located in
7 the separate 'factorials' module.
8 """
9 
10 from __future__ import print_function, division
11 
12 from sympy.core import S, Symbol, Rational, Integer, Add, Dummy
13 from sympy.core.compatibility import as_int, SYMPY_INTS, range
14 from sympy.core.cache import cacheit
15 from sympy.core.function import Function, expand_mul
16 from sympy.core.numbers import E, pi
17 from sympy.core.relational import LessThan, StrictGreaterThan
18 from sympy.functions.combinatorial.factorials import binomial, factorial
19 from sympy.functions.elementary.exponential import log
20 from sympy.functions.elementary.integers import floor
21 from sympy.functions.elementary.trigonometric import sin, cos, cot
22 from sympy.functions.elementary.miscellaneous import sqrt
23 from sympy.utilities.memoization import recurrence_memo
24 
25 from mpmath import bernfrac, workprec
26 from mpmath.libmp import ifib as _ifib
27 
28 
29 def _product(a, b):
30     p = 1
31     for k in range(a, b + 1):
32         p *= k
33     return p
34 
35 
36 
37 # Dummy symbol used for computing polynomial sequences
38 _sym = Symbol('x')
39 _symbols = Function('x')
40 
41 
42 #----------------------------------------------------------------------------#
43 #                                                                            #
44 #                           Fibonacci numbers                                #
45 #                                                                            #
46 #----------------------------------------------------------------------------#
47 
48 class fibonacci(Function):
49     r"""
50     Fibonacci numbers / Fibonacci polynomials
51 
52     The Fibonacci numbers are the integer sequence defined by the
53     initial terms F_0 = 0, F_1 = 1 and the two-term recurrence
54     relation F_n = F_{n-1} + F_{n-2}.  This definition
55     extended to arbitrary real and complex arguments using
56     the formula
57 
58     .. math :: F_z = \frac{\phi^z - \cos(\pi z) \phi^{-z}}{\sqrt 5}
59 
60     The Fibonacci polynomials are defined by F_1(x) = 1,
61     F_2(x) = x, and F_n(x) = x*F_{n-1}(x) + F_{n-2}(x) for n > 2.
62     For all positive integers n, F_n(1) = F_n.
63 
64     * fibonacci(n) gives the nth Fibonacci number, F_n
65     * fibonacci(n, x) gives the nth Fibonacci polynomial in x, F_n(x)
66 
67     Examples
68     ========
69 
70     >>> from sympy import fibonacci, Symbol
71 
72     >>> [fibonacci(x) for x in range(11)]
73     [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
74     >>> fibonacci(5, Symbol('t'))
75     t**4 + 3*t**2 + 1
76 
77     References
78     ==========
79 
80     .. [1] http://en.wikipedia.org/wiki/Fibonacci_number
81     .. [2] http://mathworld.wolfram.com/FibonacciNumber.html
82 
83     See Also
84     ========
85 
86     bell, bernoulli, catalan, euler, harmonic, lucas
87     """
88 
89     @staticmethod
90     def _fib(n):
91         return _ifib(n)
92 
93     @staticmethod
94     @recurrence_memo([None, S.One, _sym])
95     def _fibpoly(n, prev):
96         return (prev[-2] + _sym*prev[-1]).expand()
97 
98     @classmethod
99     def eval(cls, n, sym=None):
100         if n is S.Infinity:
101             return S.Infinity
102 
103         if n.is_Integer:
104             n = int(n)
105             if n < 0:
106                 return S.NegativeOne**(n + 1) * fibonacci(-n)
107             if sym is None:
108                 return Integer(cls._fib(n))
109             else:
110                 if n < 1:
111                     raise ValueError("Fibonacci polynomials are defined "
112                        "only for positive integer indices.")
113                 return cls._fibpoly(n).subs(_sym, sym)
114 
115     def _eval_rewrite_as_sqrt(self, n):
116         return 2**(-n)*sqrt(5)*((1 + sqrt(5))**n - (-sqrt(5) + 1)**n) / 5
117 
118     def _eval_rewrite_as_GoldenRatio(self,n):
119         return (S.GoldenRatio**n - 1/(-S.GoldenRatio)**n)/(2*S.GoldenRatio-1)
120 
121 
122 class lucas(Function):
123     """
124     Lucas numbers
125 
126     Lucas numbers satisfy a recurrence relation similar to that of
127     the Fibonacci sequence, in which each term is the sum of the
128     preceding two. They are generated by choosing the initial
129     values L_0 = 2 and L_1 = 1.
130 
131     * lucas(n) gives the nth Lucas number
132 
133     Examples
134     ========
135 
136     >>> from sympy import lucas
137 
138     >>> [lucas(x) for x in range(11)]
139     [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123]
140 
141     References
142     ==========
143 
144     .. [1] http://en.wikipedia.org/wiki/Lucas_number
145     .. [2] http://mathworld.wolfram.com/LucasNumber.html
146 
147     See Also
148     ========
149 
150     bell, bernoulli, catalan, euler, fibonacci, harmonic
151     """
152 
153     @classmethod
154     def eval(cls, n):
155         if n is S.Infinity:
156             return S.Infinity
157 
158         if n.is_Integer:
159             return fibonacci(n + 1) + fibonacci(n - 1)
160 
161     def _eval_rewrite_as_sqrt(self, n):
162         return 2**(-n)*((1 + sqrt(5))**n + (-sqrt(5) + 1)**n)
163 
164 #----------------------------------------------------------------------------#
165 #                                                                            #
166 #                           Bernoulli numbers                                #
167 #                                                                            #
168 #----------------------------------------------------------------------------#
169 
170 
171 class bernoulli(Function):
172     r"""
173     Bernoulli numbers / Bernoulli polynomials
174 
175     The Bernoulli numbers are a sequence of rational numbers
176     defined by B_0 = 1 and the recursive relation (n > 0)::
177 
178                 n
179                ___
180               \      / n + 1 \
181           0 =  )     |       | * B .
182               /___   \   k   /    k
183               k = 0
184 
185     They are also commonly defined by their exponential generating
186     function, which is x/(exp(x) - 1). For odd indices > 1, the
187     Bernoulli numbers are zero.
188 
189     The Bernoulli polynomials satisfy the analogous formula::
190 
191                     n
192                    ___
193                   \      / n \         n-k
194           B (x) =  )     |   | * B  * x   .
195            n      /___   \ k /    k
196                   k = 0
197 
198     Bernoulli numbers and Bernoulli polynomials are related as
199     B_n(0) = B_n.
200 
201     We compute Bernoulli numbers using Ramanujan's formula::
202 
203                                    / n + 3 \
204           B   =  (A(n) - S(n))  /  |       |
205            n                       \   n   /
206 
207     where A(n) = (n+3)/3 when n = 0 or 2 (mod 6), A(n) = -(n+3)/6
208     when n = 4 (mod 6), and::
209 
210                  [n/6]
211                   ___
212                  \      /  n + 3  \
213           S(n) =  )     |         | * B
214                  /___   \ n - 6*k /    n-6*k
215                  k = 1
216 
217     This formula is similar to the sum given in the definition, but
218     cuts 2/3 of the terms. For Bernoulli polynomials, we use the
219     formula in the definition.
220 
221     * bernoulli(n) gives the nth Bernoulli number, B_n
222     * bernoulli(n, x) gives the nth Bernoulli polynomial in x, B_n(x)
223 
224     Examples
225     ========
226 
227     >>> from sympy import bernoulli
228 
229     >>> [bernoulli(n) for n in range(11)]
230     [1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]
231     >>> bernoulli(1000001)
232     0
233 
234     References
235     ==========
236 
237     .. [1] http://en.wikipedia.org/wiki/Bernoulli_number
238     .. [2] http://en.wikipedia.org/wiki/Bernoulli_polynomial
239     .. [3] http://mathworld.wolfram.com/BernoulliNumber.html
240     .. [4] http://mathworld.wolfram.com/BernoulliPolynomial.html
241 
242     See Also
243     ========
244 
245     bell, catalan, euler, fibonacci, harmonic, lucas
246     """
247 
248     # Calculates B_n for positive even n
249     @staticmethod
250     def _calc_bernoulli(n):
251         s = 0
252         a = int(binomial(n + 3, n - 6))
253         for j in range(1, n//6 + 1):
254             s += a * bernoulli(n - 6*j)
255             # Avoid computing each binomial coefficient from scratch
256             a *= _product(n - 6 - 6*j + 1, n - 6*j)
257             a //= _product(6*j + 4, 6*j + 9)
258         if n % 6 == 4:
259             s = -Rational(n + 3, 6) - s
260         else:
261             s = Rational(n + 3, 3) - s
262         return s / binomial(n + 3, n)
263 
264     # We implement a specialized memoization scheme to handle each
265     # case modulo 6 separately
266     _cache = {0: S.One, 2: Rational(1, 6), 4: Rational(-1, 30)}
267     _highest = {0: 0, 2: 2, 4: 4}
268 
269     @classmethod
270     def eval(cls, n, sym=None):
271         if n.is_Number:
272             if n.is_Integer and n.is_nonnegative:
273                 if n is S.Zero:
274                     return S.One
275                 elif n is S.One:
276                     if sym is None:
277                         return -S.Half
278                     else:
279                         return sym - S.Half
280                 # Bernoulli numbers
281                 elif sym is None:
282                     if n.is_odd:
283                         return S.Zero
284                     n = int(n)
285                     # Use mpmath for enormous Bernoulli numbers
286                     if n > 500:
287                         p, q = bernfrac(n)
288                         return Rational(int(p), int(q))
289                     case = n % 6
290                     highest_cached = cls._highest[case]
291                     if n <= highest_cached:
292                         return cls._cache[n]
293                     # To avoid excessive recursion when, say, bernoulli(1000) is
294                     # requested, calculate and cache the entire sequence ... B_988,
295                     # B_994, B_1000 in increasing order
296                     for i in range(highest_cached + 6, n + 6, 6):
297                         b = cls._calc_bernoulli(i)
298                         cls._cache[i] = b
299                         cls._highest[case] = i
300                     return b
301                 # Bernoulli polynomials
302                 else:
303                     n, result = int(n), []
304                     for k in range(n + 1):
305                         result.append(binomial(n, k)*cls(k)*sym**(n - k))
306                     return Add(*result)
307             else:
308                 raise ValueError("Bernoulli numbers are defined only"
309                                  " for nonnegative integer indices.")
310 
311         if sym is None:
312             if n.is_odd and (n - 1).is_positive:
313                 return S.Zero
314 
315 
316 #----------------------------------------------------------------------------#
317 #                                                                            #
318 #                             Bell numbers                                   #
319 #                                                                            #
320 #----------------------------------------------------------------------------#
321 
322 class bell(Function):
323     r"""
324     Bell numbers / Bell polynomials
325 
326     The Bell numbers satisfy `B_0 = 1` and
327 
328     .. math:: B_n = \sum_{k=0}^{n-1} \binom{n-1}{k} B_k.
329 
330     They are also given by:
331 
332     .. math:: B_n = \frac{1}{e} \sum_{k=0}^{\infty} \frac{k^n}{k!}.
333 
334     The Bell polynomials are given by `B_0(x) = 1` and
335 
336     .. math:: B_n(x) = x \sum_{k=1}^{n-1} \binom{n-1}{k-1} B_{k-1}(x).
337 
338     The second kind of Bell polynomials (are sometimes called "partial" Bell
339     polynomials or incomplete Bell polynomials) are defined as
340 
341     .. math:: B_{n,k}(x_1, x_2,\dotsc x_{n-k+1}) =
342             \sum_{j_1+j_2+j_2+\dotsb=k \atop j_1+2j_2+3j_2+\dotsb=n}
343                 \frac{n!}{j_1!j_2!\dotsb j_{n-k+1}!}
344                 \left(\frac{x_1}{1!} \right)^{j_1}
345                 \left(\frac{x_2}{2!} \right)^{j_2} \dotsb
346                 \left(\frac{x_{n-k+1}}{(n-k+1)!} \right) ^{j_{n-k+1}}.
347 
348     * bell(n) gives the `n^{th}` Bell number, `B_n`.
349     * bell(n, x) gives the `n^{th}` Bell polynomial, `B_n(x)`.
350     * bell(n, k, (x1, x2, ...)) gives Bell polynomials of the second kind,
351       `B_{n,k}(x_1, x_2, \dotsc, x_{n-k+1})`.
352 
353     Notes
354     =====
355 
356     Not to be confused with Bernoulli numbers and Bernoulli polynomials,
357     which use the same notation.
358 
359     Examples
360     ========
361 
362     >>> from sympy import bell, Symbol, symbols
363 
364     >>> [bell(n) for n in range(11)]
365     [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975]
366     >>> bell(30)
367     846749014511809332450147
368     >>> bell(4, Symbol('t'))
369     t**4 + 6*t**3 + 7*t**2 + t
370     >>> bell(6, 2, symbols('x:6')[1:])
371     6*x1*x5 + 15*x2*x4 + 10*x3**2
372 
373     References
374     ==========
375 
376     .. [1] http://en.wikipedia.org/wiki/Bell_number
377     .. [2] http://mathworld.wolfram.com/BellNumber.html
378     .. [3] http://mathworld.wolfram.com/BellPolynomial.html
379 
380     See Also
381     ========
382 
383     bernoulli, catalan, euler, fibonacci, harmonic, lucas
384     """
385 
386     @staticmethod
387     @recurrence_memo([1, 1])
388     def _bell(n, prev):
389         s = 1
390         a = 1
391         for k in range(1, n):
392             a = a * (n - k) // k
393             s += a * prev[k]
394         return s
395 
396     @staticmethod
397     @recurrence_memo([S.One, _sym])
398     def _bell_poly(n, prev):
399         s = 1
400         a = 1
401         for k in range(2, n + 1):
402             a = a * (n - k + 1) // (k - 1)
403             s += a * prev[k - 1]
404         return expand_mul(_sym * s)
405 
406     @staticmethod
407     def _bell_incomplete_poly(n, k, symbols):
408         r"""
409         The second kind of Bell polynomials (incomplete Bell polynomials).
410 
411         Calculated by recurrence formula:
412 
413         .. math:: B_{n,k}(x_1, x_2, \dotsc, x_{n-k+1}) =
414                 \sum_{m=1}^{n-k+1}
415                 \x_m \binom{n-1}{m-1} B_{n-m,k-1}(x_1, x_2, \dotsc, x_{n-m-k})
416 
417         where
418             B_{0,0} = 1;
419             B_{n,0} = 0; for n>=1
420             B_{0,k} = 0; for k>=1
421 
422         """
423         if (n == 0) and (k == 0):
424             return S.One
425         elif (n == 0) or (k == 0):
426             return S.Zero
427         s = S.Zero
428         a = S.One
429         for m in range(1, n - k + 2):
430             s += a * bell._bell_incomplete_poly(
431                 n - m, k - 1, symbols) * symbols[m - 1]
432             a = a * (n - m) / m
433         return expand_mul(s)
434 
435     @classmethod
436     def eval(cls, n, k_sym=None, symbols=None):
437         if n.is_Integer and n.is_nonnegative:
438             if k_sym is None:
439                 return Integer(cls._bell(int(n)))
440             elif symbols is None:
441                 return cls._bell_poly(int(n)).subs(_sym, k_sym)
442             else:
443                 r = cls._bell_incomplete_poly(int(n), int(k_sym), symbols)
444                 return r
445 
446     def _eval_rewrite_as_Sum(self, n, k_sym=None, symbols=None):
447         from sympy import Sum
448         if (k_sym is not None) or (symbols is not None):
449             return self
450 
451         # Dobinski's formula
452         if not n.is_nonnegative:
453             return self
454         k = Dummy('k', integer=True, nonnegative=True)
455         return 1 / E * Sum(k**n / factorial(k), (k, 0, S.Infinity))
456 
457 #----------------------------------------------------------------------------#
458 #                                                                            #
459 #                           Harmonic numbers                                 #
460 #                                                                            #
461 #----------------------------------------------------------------------------#
462 
463 
464 class harmonic(Function):
465     r"""
466     Harmonic numbers
467 
468     The nth harmonic number is given by `\operatorname{H}_{n} =
469     1 + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n}`.
470 
471     More generally:
472 
473     .. math:: \operatorname{H}_{n,m} = \sum_{k=1}^{n} \frac{1}{k^m}
474 
475     As `n \rightarrow \infty`, `\operatorname{H}_{n,m} \rightarrow \zeta(m)`,
476     the Riemann zeta function.
477 
478     * ``harmonic(n)`` gives the nth harmonic number, `\operatorname{H}_n`
479 
480     * ``harmonic(n, m)`` gives the nth generalized harmonic number
481       of order `m`, `\operatorname{H}_{n,m}`, where
482       ``harmonic(n) == harmonic(n, 1)``
483 
484     Examples
485     ========
486 
487     >>> from sympy import harmonic, oo
488 
489     >>> [harmonic(n) for n in range(6)]
490     [0, 1, 3/2, 11/6, 25/12, 137/60]
491     >>> [harmonic(n, 2) for n in range(6)]
492     [0, 1, 5/4, 49/36, 205/144, 5269/3600]
493     >>> harmonic(oo, 2)
494     pi**2/6
495 
496     >>> from sympy import Symbol, Sum
497     >>> n = Symbol("n")
498 
499     >>> harmonic(n).rewrite(Sum)
500     Sum(1/_k, (_k, 1, n))
501 
502     We can evaluate harmonic numbers for all integral and positive
503     rational arguments:
504 
505     >>> from sympy import S, expand_func, simplify
506     >>> harmonic(8)
507     761/280
508     >>> harmonic(11)
509     83711/27720
510 
511     >>> H = harmonic(1/S(3))
512     >>> H
513     harmonic(1/3)
514     >>> He = expand_func(H)
515     >>> He
516     -log(6) - sqrt(3)*pi/6 + 2*Sum(log(sin(_k*pi/3))*cos(2*_k*pi/3), (_k, 1, 1))
517                            + 3*Sum(1/(3*_k + 1), (_k, 0, 0))
518     >>> He.doit()
519     -log(6) - sqrt(3)*pi/6 - log(sqrt(3)/2) + 3
520     >>> H = harmonic(25/S(7))
521     >>> He = simplify(expand_func(H).doit())
522     >>> He
523     log(sin(pi/7)**(-2*cos(pi/7))*sin(2*pi/7)**(2*cos(16*pi/7))*cos(pi/14)**(-2*sin(pi/14))/14)
524     + pi*tan(pi/14)/2 + 30247/9900
525     >>> He.n(40)
526     1.983697455232980674869851942390639915940
527     >>> harmonic(25/S(7)).n(40)
528     1.983697455232980674869851942390639915940
529 
530     We can rewrite harmonic numbers in terms of polygamma functions:
531 
532     >>> from sympy import digamma, polygamma
533     >>> m = Symbol("m")
534 
535     >>> harmonic(n).rewrite(digamma)
536     polygamma(0, n + 1) + EulerGamma
537 
538     >>> harmonic(n).rewrite(polygamma)
539     polygamma(0, n + 1) + EulerGamma
540 
541     >>> harmonic(n,3).rewrite(polygamma)
542     polygamma(2, n + 1)/2 - polygamma(2, 1)/2
543 
544     >>> harmonic(n,m).rewrite(polygamma)
545     (-1)**m*(polygamma(m - 1, 1) - polygamma(m - 1, n + 1))/factorial(m - 1)
546 
547     Integer offsets in the argument can be pulled out:
548 
549     >>> from sympy import expand_func
550 
551     >>> expand_func(harmonic(n+4))
552     harmonic(n) + 1/(n + 4) + 1/(n + 3) + 1/(n + 2) + 1/(n + 1)
553 
554     >>> expand_func(harmonic(n-4))
555     harmonic(n) - 1/(n - 1) - 1/(n - 2) - 1/(n - 3) - 1/n
556 
557     Some limits can be computed as well:
558 
559     >>> from sympy import limit, oo
560 
561     >>> limit(harmonic(n), n, oo)
562     oo
563 
564     >>> limit(harmonic(n, 2), n, oo)
565     pi**2/6
566 
567     >>> limit(harmonic(n, 3), n, oo)
568     -polygamma(2, 1)/2
569 
570     However we can not compute the general relation yet:
571 
572     >>> limit(harmonic(n, m), n, oo)
573     harmonic(oo, m)
574 
575     which equals ``zeta(m)`` for ``m > 1``.
576 
577     References
578     ==========
579 
580     .. [1] http://en.wikipedia.org/wiki/Harmonic_number
581     .. [2] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber/
582     .. [3] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber2/
583 
584     See Also
585     ========
586 
587     bell, bernoulli, catalan, euler, fibonacci, lucas
588     """
589 
590     # Generate one memoized Harmonic number-generating function for each
591     # order and store it in a dictionary
592     _functions = {}
593 
594     @classmethod
595     def eval(cls, n, m=None):
596         from sympy import zeta
597         if m is S.One:
598             return cls(n)
599         if m is None:
600             m = S.One
601 
602         if m.is_zero:
603             return n
604 
605         if n is S.Infinity and m.is_Number:
606             # TODO: Fix for symbolic values of m
607             if m.is_negative:
608                 return S.NaN
609             elif LessThan(m, S.One):
610                 return S.Infinity
611             elif StrictGreaterThan(m, S.One):
612                 return zeta(m)
613             else:
614                 return cls
615 
616         if n.is_Integer and n.is_nonnegative and m.is_Integer:
617             if n == 0:
618                 return S.Zero
619             if not m in cls._functions:
620                 @recurrence_memo([0])
621                 def f(n, prev):
622                     return prev[-1] + S.One / n**m
623                 cls._functions[m] = f
624             return cls._functions[m](int(n))
625 
626     def _eval_rewrite_as_polygamma(self, n, m=1):
627         from sympy.functions.special.gamma_functions import polygamma
628         return S.NegativeOne**m/factorial(m - 1) * (polygamma(m - 1, 1) - polygamma(m - 1, n + 1))
629 
630     def _eval_rewrite_as_digamma(self, n, m=1):
631         from sympy.functions.special.gamma_functions import polygamma
632         return self.rewrite(polygamma)
633 
634     def _eval_rewrite_as_trigamma(self, n, m=1):
635         from sympy.functions.special.gamma_functions import polygamma
636         return self.rewrite(polygamma)
637 
638     def _eval_rewrite_as_Sum(self, n, m=None):
639         from sympy import Sum
640         k = Dummy("k", integer=True)
641         if m is None:
642             m = S.One
643         return Sum(k**(-m), (k, 1, n))
644 
645     def _eval_expand_func(self, **hints):
646         from sympy import Sum
647         n = self.args[0]
648         m = self.args[1] if len(self.args) == 2 else 1
649 
650         if m == S.One:
651             if n.is_Add:
652                 off = n.args[0]
653                 nnew = n - off
654                 if off.is_Integer and off.is_positive:
655                     result = [S.One/(nnew + i) for i in range(off, 0, -1)] + [harmonic(nnew)]
656                     return Add(*result)
657                 elif off.is_Integer and off.is_negative:
658                     result = [-S.One/(nnew + i) for i in range(0, off, -1)] + [harmonic(nnew)]
659                     return Add(*result)
660 
661             if n.is_Rational:
662                 # Expansions for harmonic numbers at general rational arguments (u + p/q)
663                 # Split n as u + p/q with p < q
664                 p, q = n.as_numer_denom()
665                 u = p // q
666                 p = p - u * q
667                 if u.is_nonnegative and p.is_positive and q.is_positive and p < q:
668                     k = Dummy("k")
669                     t1 = q * Sum(1 / (q * k + p), (k, 0, u))
670                     t2 = 2 * Sum(cos((2 * pi * p * k) / S(q)) *
671                                    log(sin((pi * k) / S(q))),
672                                    (k, 1, floor((q - 1) / S(2))))
673                     t3 = (pi / 2) * cot((pi * p) / q) + log(2 * q)
674                     return t1 + t2 - t3
675 
676         return self
677 
678     def _eval_rewrite_as_tractable(self, n, m=1):
679         from sympy import polygamma
680         return self.rewrite(polygamma).rewrite("tractable", deep=True)
681 
682     def _eval_evalf(self, prec):
683         from sympy import polygamma
684         if all(i.is_number for i in self.args):
685             return self.rewrite(polygamma)._eval_evalf(prec)
686 
687 
688 #----------------------------------------------------------------------------#
689 #                                                                            #
690 #                           Euler numbers                                    #
691 #                                                                            #
692 #----------------------------------------------------------------------------#
693 
694 
695 class euler(Function):
696     r"""
697     Euler numbers
698 
699     The euler numbers are given by::
700 
701                   2*n+1   k
702                    ___   ___            j          2*n+1
703                   \     \     / k \ (-1)  * (k-2*j)
704           E   = I  )     )    |   | --------------------
705            2n     /___  /___  \ j /      k    k
706                   k = 1 j = 0           2  * I  * k
707 
708           E     = 0
709            2n+1
710 
711     * euler(n) gives the n-th Euler number, E_n
712 
713     Examples
714     ========
715 
716     >>> from sympy import Symbol
717     >>> from sympy.functions import euler
718     >>> [euler(n) for n in range(10)]
719     [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0]
720     >>> n = Symbol("n")
721     >>> euler(n+2*n)
722     euler(3*n)
723 
724     References
725     ==========
726 
727     .. [1] http://en.wikipedia.org/wiki/Euler_numbers
728     .. [2] http://mathworld.wolfram.com/EulerNumber.html
729     .. [3] http://en.wikipedia.org/wiki/Alternating_permutation
730     .. [4] http://mathworld.wolfram.com/AlternatingPermutation.html
731 
732     See Also
733     ========
734 
735     bell, bernoulli, catalan, fibonacci, harmonic, lucas
736     """
737 
738     @classmethod
739     def eval(cls, m):
740         if m.is_odd:
741             return S.Zero
742         if m.is_Integer and m.is_nonnegative:
743             from mpmath import mp
744             m = m._to_mpmath(mp.prec)
745             res = mp.eulernum(m, exact=True)
746             return Integer(res)
747 
748     def _eval_rewrite_as_Sum(self, arg):
749         from sympy import Sum
750         if arg.is_even:
751             k = Dummy("k", integer=True)
752             j = Dummy("j", integer=True)
753             n = self.args[0] / 2
754             Em = (S.ImaginaryUnit * Sum(Sum(binomial(k, j) * ((-1)**j * (k - 2*j)**(2*n + 1)) /
755                   (2**k*S.ImaginaryUnit**k * k), (j, 0, k)), (k, 1, 2*n + 1)))
756 
757             return Em
758 
759     def _eval_evalf(self, prec):
760         m = self.args[0]
761 
762         if m.is_Integer and m.is_nonnegative:
763             from mpmath import mp
764             from sympy import Expr
765             m = m._to_mpmath(prec)
766             with workprec(prec):
767                 res = mp.eulernum(m)
768             return Expr._from_mpmath(res, prec)
769 
770 #----------------------------------------------------------------------------#
771 #                                                                            #
772 #                           Catalan numbers                                  #
773 #                                                                            #
774 #----------------------------------------------------------------------------#
775 
776 
777 class catalan(Function):
778     r"""
779     Catalan numbers
780 
781     The n-th catalan number is given by::
782 
783                  1   / 2*n \
784           C  = ----- |     |
785            n   n + 1 \  n  /
786 
787     * catalan(n) gives the n-th Catalan number, C_n
788 
789     Examples
790     ========
791 
792     >>> from sympy import (Symbol, binomial, gamma, hyper, polygamma,
793     ...             catalan, diff, combsimp, Rational, I)
794 
795     >>> [ catalan(i) for i in range(1,10) ]
796     [1, 2, 5, 14, 42, 132, 429, 1430, 4862]
797 
798     >>> n = Symbol("n", integer=True)
799 
800     >>> catalan(n)
801     catalan(n)
802 
803     Catalan numbers can be transformed into several other, identical
804     expressions involving other mathematical functions
805 
806     >>> catalan(n).rewrite(binomial)
807     binomial(2*n, n)/(n + 1)
808 
809     >>> catalan(n).rewrite(gamma)
810     4**n*gamma(n + 1/2)/(sqrt(pi)*gamma(n + 2))
811 
812     >>> catalan(n).rewrite(hyper)
813     hyper((-n + 1, -n), (2,), 1)
814 
815     For some non-integer values of n we can get closed form
816     expressions by rewriting in terms of gamma functions:
817 
818     >>> catalan(Rational(1,2)).rewrite(gamma)
819     8/(3*pi)
820 
821     We can differentiate the Catalan numbers C(n) interpreted as a
822     continuous real funtion in n:
823 
824     >>> diff(catalan(n), n)
825     (polygamma(0, n + 1/2) - polygamma(0, n + 2) + log(4))*catalan(n)
826 
827     As a more advanced example consider the following ratio
828     between consecutive numbers:
829 
830     >>> combsimp((catalan(n + 1)/catalan(n)).rewrite(binomial))
831     2*(2*n + 1)/(n + 2)
832 
833     The Catalan numbers can be generalized to complex numbers:
834 
835     >>> catalan(I).rewrite(gamma)
836     4**I*gamma(1/2 + I)/(sqrt(pi)*gamma(2 + I))
837 
838     and evaluated with arbitrary precision:
839 
840     >>> catalan(I).evalf(20)
841     0.39764993382373624267 - 0.020884341620842555705*I
842 
843     References
844     ==========
845 
846     .. [1] http://en.wikipedia.org/wiki/Catalan_number
847     .. [2] http://mathworld.wolfram.com/CatalanNumber.html
848     .. [3] http://functions.wolfram.com/GammaBetaErf/CatalanNumber/
849     .. [4] http://geometer.org/mathcircles/catalan.pdf
850 
851     See Also
852     ========
853 
854     bell, bernoulli, euler, fibonacci, harmonic, lucas
855     sympy.functions.combinatorial.factorials.binomial
856     """
857 
858     @classmethod
859     def eval(cls, n):
860         from sympy import gamma
861         if (n.is_Integer and n.is_nonnegative) or \
862            (n.is_noninteger and n.is_negative):
863             return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))
864 
865         if (n.is_integer and n.is_negative):
866             if (n + 1).is_negative:
867                 return S.Zero
868             if (n + 1).is_zero:
869                 return -S.Half
870 
871     def fdiff(self, argindex=1):
872         from sympy import polygamma, log
873         n = self.args[0]
874         return catalan(n)*(polygamma(0, n + Rational(1, 2)) - polygamma(0, n + 2) + log(4))
875 
876     def _eval_rewrite_as_binomial(self, n):
877         return binomial(2*n, n)/(n + 1)
878 
879     def _eval_rewrite_as_factorial(self, n):
880         return factorial(2*n) / (factorial(n+1) * factorial(n))
881 
882     def _eval_rewrite_as_gamma(self, n):
883         from sympy import gamma
884         # The gamma function allows to generalize Catalan numbers to complex n
885         return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))
886 
887     def _eval_rewrite_as_hyper(self, n):
888         from sympy import hyper
889         return hyper([1 - n, -n], [2], 1)
890 
891     def _eval_rewrite_as_Product(self, n):
892         from sympy import Product
893         if not (n.is_integer and n.is_nonnegative):
894             return self
895         k = Dummy('k', integer=True, positive=True)
896         return Product((n + k) / k, (k, 2, n))
897 
898     def _eval_evalf(self, prec):
899         from sympy import gamma
900         if self.args[0].is_number:
901             return self.rewrite(gamma)._eval_evalf(prec)
902 
903 
904 #----------------------------------------------------------------------------#
905 #                                                                            #
906 #                           Genocchi numbers                                 #
907 #                                                                            #
908 #----------------------------------------------------------------------------#
909 
910 
911 class genocchi(Function):
912     r"""
913     Genocchi numbers
914 
915     The Genocchi numbers are a sequence of integers G_n that satisfy the
916     relation::
917 
918                            oo
919                          ____
920                          \   `
921                  2*t      \         n
922                 ------ =   \   G_n*t
923                  t         /   ------
924                 e  + 1    /      n!
925                          /___,
926                          n = 1
927 
928     Examples
929     ========
930 
931     >>> from sympy import Symbol
932     >>> from sympy.functions import genocchi
933     >>> [genocchi(n) for n in range(1, 9)]
934     [1, -1, 0, 1, 0, -3, 0, 17]
935     >>> n = Symbol('n', integer=True, positive=True)
936     >>> genocchi(2 * n + 1)
937     0
938 
939     References
940     ==========
941 
942     .. [1] https://en.wikipedia.org/wiki/Genocchi_number
943     .. [2] http://mathworld.wolfram.com/GenocchiNumber.html
944 
945     See Also
946     ========
947 
948     bell, bernoulli, catalan, euler, fibonacci, harmonic, lucas
949     """
950 
951     @classmethod
952     def eval(cls, n):
953         if n.is_Number:
954             if (not n.is_Integer) or n.is_nonpositive:
955                 raise ValueError("Genocchi numbers are defined only for " +
956                                  "positive integers")
957             return 2 * (1 - S(2) ** n) * bernoulli(n)
958 
959         if n.is_odd and (n - 1).is_positive:
960             return S.Zero
961 
962         if (n - 1).is_zero:
963             return S.One
964 
965     def _eval_rewrite_as_bernoulli(self, n):
966         if n.is_integer and n.is_nonnegative:
967             return (1 - S(2) ** n) * bernoulli(n) * 2
968 
969     def _eval_is_integer(self):
970         if self.args[0].is_integer and self.args[0].is_positive:
971             return True
972 
973     def _eval_is_negative(self):
974         n = self.args[0]
975         if n.is_integer and n.is_positive:
976             if n.is_odd:
977                 return False
978             return (n / 2).is_odd
979 
980     def _eval_is_positive(self):
981         n = self.args[0]
982         if n.is_integer and n.is_positive:
983             if n.is_odd:
984                 return fuzzy_not((n - 1).is_positive)
985             return (n / 2).is_even
986 
987     def _eval_is_even(self):
988         n = self.args[0]
989         if n.is_integer and n.is_positive:
990             if n.is_even:
991                 return False
992             return (n - 1).is_positive
993 
994     def _eval_is_odd(self):
995         n = self.args[0]
996         if n.is_integer and n.is_positive:
997             if n.is_even:
998                 return True
999             return fuzzy_not((n - 1).is_positive)
1000 
1001     def _eval_is_prime(self):
1002         n = self.args[0]
1003         # only G_6 = -3 and G_8 = 17 are prime,
1004         # but SymPy does not consider negatives as prime
1005         # so only n=8 is tested
1006         return (n - 8).is_zero
1007 
1008 
1009 #######################################################################
1010 ###
1011 ### Functions for enumerating partitions, permutations and combinations
1012 ###
1013 #######################################################################
1014 
1015 
1016 class _MultisetHistogram(tuple):
1017     pass
1018 
1019 
1020 _N = -1
1021 _ITEMS = -2
1022 _M = slice(None, _ITEMS)
1023 
1024 
1025 def _multiset_histogram(n):
1026     """Return tuple used in permutation and combination counting. Input
1027     is a dictionary giving items with counts as values or a sequence of
1028     items (which need not be sorted).
1029 
1030     The data is stored in a class deriving from tuple so it is easily
1031     recognized and so it can be converted easily to a list.
1032     """
1033     if type(n) is dict:  # item: count
1034         if not all(isinstance(v, int) and v >= 0 for v in n.values()):
1035             raise ValueError
1036         tot = sum(n.values())
1037         items = sum(1 for k in n if n[k] > 0)
1038         return _MultisetHistogram([n[k] for k in n if n[k] > 0] + [items, tot])
1039     else:
1040         n = list(n)
1041         s = set(n)
1042         if len(s) == len(n):
1043             n = [1]*len(n)
1044             n.extend([len(n), len(n)])
1045             return _MultisetHistogram(n)
1046         m = dict(zip(s, range(len(s))))
1047         d = dict(zip(range(len(s)), [0]*len(s)))
1048         for i in n:
1049             d[m[i]] += 1
1050         return _multiset_histogram(d)
1051 
1052 
1053 def nP(n, k=None, replacement=False):
1054     """Return the number of permutations of ``n`` items taken ``k`` at a time.
1055 
1056     Possible values for ``n``::
1057         integer - set of length ``n``
1058         sequence - converted to a multiset internally
1059         multiset - {element: multiplicity}
1060 
1061     If ``k`` is None then the total of all permutations of length 0
1062     through the number of items represented by ``n`` will be returned.
1063 
1064     If ``replacement`` is True then a given item can appear more than once
1065     in the ``k`` items. (For example, for 'ab' permutations of 2 would
1066     include 'aa', 'ab', 'ba' and 'bb'.) The multiplicity of elements in
1067     ``n`` is ignored when ``replacement`` is True but the total number
1068     of elements is considered since no element can appear more times than
1069     the number of elements in ``n``.
1070 
1071     Examples
1072     ========
1073 
1074     >>> from sympy.functions.combinatorial.numbers import nP
1075     >>> from sympy.utilities.iterables import multiset_permutations, multiset
1076     >>> nP(3, 2)
1077     6
1078     >>> nP('abc', 2) == nP(multiset('abc'), 2) == 6
1079     True
1080     >>> nP('aab', 2)
1081     3
1082     >>> nP([1, 2, 2], 2)
1083     3
1084     >>> [nP(3, i) for i in range(4)]
1085     [1, 3, 6, 6]
1086     >>> nP(3) == sum(_)
1087     True
1088 
1089     When ``replacement`` is True, each item can have multiplicity
1090     equal to the length represented by ``n``:
1091 
1092     >>> nP('aabc', replacement=True)
1093     121
1094     >>> [len(list(multiset_permutations('aaaabbbbcccc', i))) for i in range(5)]
1095     [1, 3, 9, 27, 81]
1096     >>> sum(_)
1097     121
1098 
1099     References
1100     ==========
1101 
1102     .. [1] http://en.wikipedia.org/wiki/Permutation
1103 
1104     See Also
1105     ========
1106     sympy.utilities.iterables.multiset_permutations
1107 
1108     """
1109     try:
1110         n = as_int(n)
1111     except ValueError:
1112         return Integer(_nP(_multiset_histogram(n), k, replacement))
1113     return Integer(_nP(n, k, replacement))
1114 
1115 
1116 @cacheit
1117 def _nP(n, k=None, replacement=False):
1118     from sympy.functions.combinatorial.factorials import factorial
1119     from sympy.core.mul import prod
1120 
1121     if k == 0:
1122         return 1
1123     if isinstance(n, SYMPY_INTS):  # n different items
1124         # assert n >= 0
1125         if k is None:
1126             return sum(_nP(n, i, replacement) for i in range(n + 1))
1127         elif replacement:
1128             return n**k
1129         elif k > n:
1130             return 0
1131         elif k == n:
1132             return factorial(k)
1133         elif k == 1:
1134             return n
1135         else:
1136             # assert k >= 0
1137             return _product(n - k + 1, n)
1138     elif isinstance(n, _MultisetHistogram):
1139         if k is None:
1140             return sum(_nP(n, i, replacement) for i in range(n[_N] + 1))
1141         elif replacement:
1142             return n[_ITEMS]**k
1143         elif k == n[_N]:
1144             return factorial(k)/prod([factorial(i) for i in n[_M] if i > 1])
1145         elif k > n[_N]:
1146             return 0
1147         elif k == 1:
1148             return n[_ITEMS]
1149         else:
1150             # assert k >= 0
1151             tot = 0
1152             n = list(n)
1153             for i in range(len(n[_M])):
1154                 if not n[i]:
1155                     continue
1156                 n[_N] -= 1
1157                 if n[i] == 1:
1158                     n[i] = 0
1159                     n[_ITEMS] -= 1
1160                     tot += _nP(_MultisetHistogram(n), k - 1)
1161                     n[_ITEMS] += 1
1162                     n[i] = 1
1163                 else:
1164                     n[i] -= 1
1165                     tot += _nP(_MultisetHistogram(n), k - 1)
1166                     n[i] += 1
1167                 n[_N] += 1
1168             return tot
1169 
1170 
1171 @cacheit
1172 def _AOP_product(n):
1173     """for n = (m1, m2, .., mk) return the coefficients of the polynomial,
1174     prod(sum(x**i for i in range(nj + 1)) for nj in n); i.e. the coefficients
1175     of the product of AOPs (all-one polynomials) or order given in n.  The
1176     resulting coefficient corresponding to x**r is the number of r-length
1177     combinations of sum(n) elements with multiplicities given in n.
1178     The coefficients are given as a default dictionary (so if a query is made
1179     for a key that is not present, 0 will be returned).
1180 
1181     Examples
1182     ========
1183 
1184     >>> from sympy.functions.combinatorial.numbers import _AOP_product
1185     >>> from sympy.abc import x
1186     >>> n = (2, 2, 3)  # e.g. aabbccc
1187     >>> prod = ((x**2 + x + 1)*(x**2 + x + 1)*(x**3 + x**2 + x + 1)).expand()
1188     >>> c = _AOP_product(n); dict(c)
1189     {0: 1, 1: 3, 2: 6, 3: 8, 4: 8, 5: 6, 6: 3, 7: 1}
1190     >>> [c[i] for i in range(8)] == [prod.coeff(x, i) for i in range(8)]
1191     True
1192 
1193     The generating poly used here is the same as that listed in
1194     http://tinyurl.com/cep849r, but in a refactored form.
1195 
1196     """
1197     from collections import defaultdict
1198 
1199     n = list(n)
1200     ord = sum(n)
1201     need = (ord + 2)//2
1202     rv = [1]*(n.pop() + 1)
1203     rv.extend([0]*(need - len(rv)))
1204     rv = rv[:need]
1205     while n:
1206         ni = n.pop()
1207         N = ni + 1
1208         was = rv[:]
1209         for i in range(1, min(N, len(rv))):
1210             rv[i] += rv[i - 1]
1211         for i in range(N, need):
1212             rv[i] += rv[i - 1] - was[i - N]
1213     rev = list(reversed(rv))
1214     if ord % 2:
1215         rv = rv + rev
1216     else:
1217         rv[-1:] = rev
1218     d = defaultdict(int)
1219     for i in range(len(rv)):
1220         d[i] = rv[i]
1221     return d
1222 
1223 
1224 def nC(n, k=None, replacement=False):
1225     """Return the number of combinations of ``n`` items taken ``k`` at a time.
1226 
1227     Possible values for ``n``::
1228         integer - set of length ``n``
1229         sequence - converted to a multiset internally
1230         multiset - {element: multiplicity}
1231 
1232     If ``k`` is None then the total of all combinations of length 0
1233     through the number of items represented in ``n`` will be returned.
1234 
1235     If ``replacement`` is True then a given item can appear more than once
1236     in the ``k`` items. (For example, for 'ab' sets of 2 would include 'aa',
1237     'ab', and 'bb'.) The multiplicity of elements in ``n`` is ignored when
1238     ``replacement`` is True but the total number of elements is considered
1239     since no element can appear more times than the number of elements in
1240     ``n``.
1241 
1242     Examples
1243     ========
1244 
1245     >>> from sympy.functions.combinatorial.numbers import nC
1246     >>> from sympy.utilities.iterables import multiset_combinations
1247     >>> nC(3, 2)
1248     3
1249     >>> nC('abc', 2)
1250     3
1251     >>> nC('aab', 2)
1252     2
1253 
1254     When ``replacement`` is True, each item can have multiplicity
1255     equal to the length represented by ``n``:
1256 
1257     >>> nC('aabc', replacement=True)
1258     35
1259     >>> [len(list(multiset_combinations('aaaabbbbcccc', i))) for i in range(5)]
1260     [1, 3, 6, 10, 15]
1261     >>> sum(_)
1262     35
1263 
1264     If there are ``k`` items with multiplicities ``m_1, m_2, ..., m_k``
1265     then the total of all combinations of length 0 hrough ``k`` is the
1266     product, ``(m_1 + 1)*(m_2 + 1)*...*(m_k + 1)``. When the multiplicity
1267     of each item is 1 (i.e., k unique items) then there are 2**k
1268     combinations. For example, if there are 4 unique items, the total number
1269     of combinations is 16:
1270 
1271     >>> sum(nC(4, i) for i in range(5))
1272     16
1273 
1274     References
1275     ==========
1276 
1277     .. [1] http://en.wikipedia.org/wiki/Combination
1278     .. [2] http://tinyurl.com/cep849r
1279 
1280     See Also
1281     ========
1282     sympy.utilities.iterables.multiset_combinations
1283     """
1284     from sympy.functions.combinatorial.factorials import binomial
1285     from sympy.core.mul import prod
1286 
1287     if isinstance(n, SYMPY_INTS):
1288         if k is None:
1289             if not replacement:
1290                 return 2**n
1291             return sum(nC(n, i, replacement) for i in range(n + 1))
1292         if k < 0:
1293             raise ValueError("k cannot be negative")
1294         if replacement:
1295             return binomial(n + k - 1, k)
1296         return binomial(n, k)
1297     if isinstance(n, _MultisetHistogram):
1298         N = n[_N]
1299         if k is None:
1300             if not replacement:
1301                 return prod(m + 1 for m in n[_M])
1302             return sum(nC(n, i, replacement) for i in range(N + 1))
1303         elif replacement:
1304             return nC(n[_ITEMS], k, replacement)
1305         # assert k >= 0
1306         elif k in (1, N - 1):
1307             return n[_ITEMS]
1308         elif k in (0, N):
1309             return 1
1310         return _AOP_product(tuple(n[_M]))[k]
1311     else:
1312         return nC(_multiset_histogram(n), k, replacement)
1313 
1314 
1315 @cacheit
1316 def _stirling1(n, k):
1317     if n == k == 0:
1318         return S.One
1319     if 0 in (n, k):
1320         return S.Zero
1321     n1 = n - 1
1322 
1323     # some special values
1324     if n == k:
1325         return S.One
1326     elif k == 1:
1327         return factorial(n1)
1328     elif k == n1:
1329         return binomial(n, 2)
1330     elif k == n - 2:
1331         return (3*n - 1)*binomial(n, 3)/4
1332     elif k == n - 3:
1333         return binomial(n, 2)*binomial(n, 4)
1334 
1335     # general recurrence
1336     return n1*_stirling1(n1, k) + _stirling1(n1, k - 1)
1337 
1338 
1339 @cacheit
1340 def _stirling2(n, k):
1341     if n == k == 0:
1342         return S.One
1343     if 0 in (n, k):
1344         return S.Zero
1345     n1 = n - 1
1346 
1347     # some special values
1348     if k == n1:
1349         return binomial(n, 2)
1350     elif k == 2:
1351         return 2**n1 - 1
1352 
1353     # general recurrence
1354     return k*_stirling2(n1, k) + _stirling2(n1, k - 1)
1355 
1356 
1357 def stirling(n, k, d=None, kind=2, signed=False):
1358     """Return Stirling number S(n, k) of the first or second (default) kind.
1359 
1360     The sum of all Stirling numbers of the second kind for k = 1
1361     through n is bell(n). The recurrence relationship for these numbers
1362     is::
1363 
1364     {0}       {n}   {0}      {n + 1}     {n}   {  n  }
1365     { } = 1;  { } = { } = 0; {     } = j*{ } + {     }
1366     {0}       {0}   {k}      {  k  }     {k}   {k - 1}
1367 
1368     where ``j`` is::
1369         ``n`` for Stirling numbers of the first kind
1370         ``-n`` for signed Stirling numbers of the first kind
1371         ``k`` for Stirling numbers of the second kind
1372 
1373     The first kind of Stirling number counts the number of permutations of
1374     ``n`` distinct items that have ``k`` cycles; the second kind counts the
1375     ways in which ``n`` distinct items can be partitioned into ``k`` parts.
1376     If ``d`` is given, the "reduced Stirling number of the second kind" is
1377     returned: ``S^{d}(n, k) = S(n - d + 1, k - d + 1)`` with ``n >= k >= d``.
1378     (This counts the ways to partition ``n`` consecutive integers into
1379     ``k`` groups with no pairwise difference less than ``d``. See example
1380     below.)
1381 
1382     To obtain the signed Stirling numbers of the first kind, use keyword
1383     ``signed=True``. Using this keyword automatically sets ``kind`` to 1.
1384 
1385     Examples
1386     ========
1387 
1388     >>> from sympy.functions.combinatorial.numbers import stirling, bell
1389     >>> from sympy.combinatorics import Permutation
1390     >>> from sympy.utilities.iterables import multiset_partitions, permutations
1391 
1392     First kind (unsigned by default):
1393 
1394     >>> [stirling(6, i, kind=1) for i in range(7)]
1395     [0, 120, 274, 225, 85, 15, 1]
1396     >>> perms = list(permutations(range(4)))
1397     >>> [sum(Permutation(p).cycles == i for p in perms) for i in range(5)]
1398     [0, 6, 11, 6, 1]
1399     >>> [stirling(4, i, kind=1) for i in range(5)]
1400     [0, 6, 11, 6, 1]
1401 
1402     First kind (signed):
1403 
1404     >>> [stirling(4, i, signed=True) for i in range(5)]
1405     [0, -6, 11, -6, 1]
1406 
1407     Second kind:
1408 
1409     >>> [stirling(10, i) for i in range(12)]
1410     [0, 1, 511, 9330, 34105, 42525, 22827, 5880, 750, 45, 1, 0]
1411     >>> sum(_) == bell(10)
1412     True
1413     >>> len(list(multiset_partitions(range(4), 2))) == stirling(4, 2)
1414     True
1415 
1416     Reduced second kind:
1417 
1418     >>> from sympy import subsets, oo
1419     >>> def delta(p):
1420     ...    if len(p) == 1:
1421     ...        return oo
1422     ...    return min(abs(i[0] - i[1]) for i in subsets(p, 2))
1423     >>> parts = multiset_partitions(range(5), 3)
1424     >>> d = 2
1425     >>> sum(1 for p in parts if all(delta(i) >= d for i in p))
1426     7
1427     >>> stirling(5, 3, 2)
1428     7
1429 
1430     References
1431     ==========
1432 
1433     .. [1] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind
1434     .. [2] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind
1435 
1436     See Also
1437     ========
1438     sympy.utilities.iterables.multiset_partitions
1439 
1440     """
1441     # TODO: make this a class like bell()
1442 
1443     n = as_int(n)
1444     k = as_int(k)
1445     if n < 0:
1446         raise ValueError('n must be nonnegative')
1447     if k > n:
1448         return S.Zero
1449     if d:
1450         # assert k >= d
1451         # kind is ignored -- only kind=2 is supported
1452         return _stirling2(n - d + 1, k - d + 1)
1453     elif signed:
1454         # kind is ignored -- only kind=1 is supported
1455         return (-1)**(n - k)*_stirling1(n, k)
1456 
1457     if kind == 1:
1458         return _stirling1(n, k)
1459     elif kind == 2:
1460         return _stirling2(n, k)
1461     else:
1462         raise ValueError('kind must be 1 or 2, not %s' % k)
1463 
1464 
1465 @cacheit
1466 def _nT(n, k):
1467     """Return the partitions of ``n`` items into ``k`` parts. This
1468     is used by ``nT`` for the case when ``n`` is an integer."""
1469     if k == 0:
1470         return 1 if k == n else 0
1471     return sum(_nT(n - k, j) for j in range(min(k, n - k) + 1))
1472 
1473 
1474 def nT(n, k=None):
1475     """Return the number of ``k``-sized partitions of ``n`` items.
1476 
1477     Possible values for ``n``::
1478         integer - ``n`` identical items
1479         sequence - converted to a multiset internally
1480         multiset - {element: multiplicity}
1481 
1482     Note: the convention for ``nT`` is different than that of ``nC`` and
1483     ``nP`` in that
1484     here an integer indicates ``n`` *identical* items instead of a set of
1485     length ``n``; this is in keeping with the ``partitions`` function which
1486     treats its integer-``n`` input like a list of ``n`` 1s. One can use
1487     ``range(n)`` for ``n`` to indicate ``n`` distinct items.
1488 
1489     If ``k`` is None then the total number of ways to partition the elements
1490     represented in ``n`` will be returned.
1491 
1492     Examples
1493     ========
1494 
1495     >>> from sympy.functions.combinatorial.numbers import nT
1496 
1497     Partitions of the given multiset:
1498 
1499     >>> [nT('aabbc', i) for i in range(1, 7)]
1500     [1, 8, 11, 5, 1, 0]
1501     >>> nT('aabbc') == sum(_)
1502     True
1503 
1504     >>> [nT("mississippi", i) for i in range(1, 12)]
1505     [1, 74, 609, 1521, 1768, 1224, 579, 197, 50, 9, 1]
1506 
1507     Partitions when all items are identical:
1508 
1509     >>> [nT(5, i) for i in range(1, 6)]
1510     [1, 2, 2, 1, 1]
1511     >>> nT('1'*5) == sum(_)
1512     True
1513 
1514     When all items are different:
1515 
1516     >>> [nT(range(5), i) for i in range(1, 6)]
1517     [1, 15, 25, 10, 1]
1518     >>> nT(range(5)) == sum(_)
1519     True
1520 
1521     References
1522     ==========
1523 
1524     .. [1] http://undergraduate.csse.uwa.edu.au/units/CITS7209/partition.pdf
1525 
1526     See Also
1527     ========
1528     sympy.utilities.iterables.partitions
1529     sympy.utilities.iterables.multiset_partitions
1530 
1531     """
1532     from sympy.utilities.enumerative import MultisetPartitionTraverser
1533 
1534     if isinstance(n, SYMPY_INTS):
1535         # assert n >= 0
1536         # all the same
1537         if k is None:
1538             return sum(_nT(n, k) for k in range(1, n + 1))
1539         return _nT(n, k)
1540     if not isinstance(n, _MultisetHistogram):
1541         try:
1542             # if n contains hashable items there is some
1543             # quick handling that can be done
1544             u = len(set(n))
1545             if u == 1:
1546                 return nT(len(n), k)
1547             elif u == len(n):
1548                 n = range(u)
1549             raise TypeError
1550         except TypeError:
1551             n = _multiset_histogram(n)
1552     N = n[_N]
1553     if k is None and N == 1:
1554         return 1
1555     if k in (1, N):
1556         return 1
1557     if k == 2 or N == 2 and k is None:
1558         m, r = divmod(N, 2)
1559         rv = sum(nC(n, i) for i in range(1, m + 1))
1560         if not r:
1561             rv -= nC(n, m)//2
1562         if k is None:
1563             rv += 1  # for k == 1
1564         return rv
1565     if N == n[_ITEMS]:
1566         # all distinct
1567         if k is None:
1568             return bell(N)
1569         return stirling(N, k)
1570     m = MultisetPartitionTraverser()
1571     if k is None:
1572         return m.count_partitions(n[_M])
1573     # MultisetPartitionTraverser does not have a range-limited count
1574     # method, so need to enumerate and count
1575     tot = 0
1576     for discard in m.enum_range(n[_M], k-1, k):
1577         tot += 1
1578     return tot

</code><intended_behavior>Ensure that any usage or reference to ff and rf within this file reflects the correct and intended mathematical definitions. If these functions' behavior was altered in a way that affects the calculations or results of combinatorial numbers, the intention would be to revert or fix these changes to align with expected outcomes.</intended_behavior>]
2025-10-17 19:47:45.974 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 19:47:45.974 | INFO     | Search-only: skipping patch selection
2025-10-17 19:47:46.049 | INFO     | Task sympy__sympy-12798 completed successfully.
2025-10-17 19:47:46.050 | INFO     | No patch generated. You can try running ACR again.
