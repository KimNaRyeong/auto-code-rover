2025-10-17 14:46:01.290 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 14:46:06.393 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=322, output_tokens=12, cost=0.003580
2025-10-17 14:46:06.394 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 14:46:06.397 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:46:13.603 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=240, cost=0.011940
2025-10-17 14:46:13.607 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:46:16.343 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=594, output_tokens=50, cost=0.007440
2025-10-17 14:46:16.344 | INFO     | Refactored invocation argument parsing failed on 'search_class_in_file(class_name, file_name)': malformed node or string on line 1: <ast.Name object at 0x7e9fd2805890>
2025-10-17 14:46:16.345 | INFO     | Refactored invocation argument parsing failed on 'search_method_in_file("tick_params", file_path)': malformed node or string on line 1: <ast.Name object at 0x7e9fd27d0850>
2025-10-17 14:46:16.346 | DEBUG    | Extracted a valid json.
2025-10-17 14:46:16.346 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"tick_params\")",
        "search_class_in_file(class_name, file_name)",
        "search_method_in_file(\"tick_params\", file_path)"
    ],
    "bug_locations": []
}
2025-10-17 14:46:16.352 | INFO     | Refactored invocation argument parsing failed on 'search_class_in_file(class_name, file_name)': malformed node or string on line 1: <ast.Name object at 0x7e9fd27d0a10>
2025-10-17 14:46:16.353 | INFO     | Refactored invocation argument parsing failed on 'search_method_in_file("tick_params", file_path)': malformed node or string on line 1: <ast.Name object at 0x7e9fd27d3610>
2025-10-17 14:46:16.358 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:46:16.359 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:46:29.841 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=962, output_tokens=598, cost=0.027560
2025-10-17 14:46:29.853 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:46:38.319 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1776, output_tokens=310, cost=0.027060
2025-10-17 14:46:38.325 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:46:42.732 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=664, output_tokens=125, cost=0.010390
2025-10-17 14:46:42.733 | DEBUG    | Extracted a valid json.
2025-10-17 14:46:42.733 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method_in_file(\"tick_params\", \"lib/matplotlib/axes/_base.py\")"],
    "bug_locations":[
        {
            "file": "lib/matplotlib/axes/_base.py",
            "class": "Axes",
            "method": "tick_params",
            "intended_behavior": "Modify the 'tick_params' method to accept a 'fontfamily' keyword argument. This argument should then be used to set the font family for tick labels, while preserving all existing functionalities such as setting the color, size, and visibility of ticks."
        }
    ]
}
2025-10-17 14:46:42.778 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:46:42.779 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:46:56.667 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3956, output_tokens=575, cost=0.056810
2025-10-17 14:46:56.678 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:47:04.642 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4747, output_tokens=308, cost=0.056710
2025-10-17 14:47:04.649 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:47:10.265 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=662, output_tokens=156, cost=0.011300
2025-10-17 14:47:10.266 | DEBUG    | Extracted a valid json.
2025-10-17 14:47:10.266 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/axes/_base.py",
            "class": "_AxesBase",
            "method": "tick_params",
            "intended_behavior": "The `tick_params` method should be enhanced to support a new keyword argument `fontfamily`. This argument will allow users to specify the font family for tick labels directly within the `tick_params` call. The method should accept `fontfamily` as part of its `**kwargs`, implement logic to apply the `fontfamily` to tick labels, ensure the addition of `fontfamily` does not disrupt any existing functionality, and update the documentation to include `fontfamily`, specifying its usage."
        }
    ]
}
2025-10-17 14:47:10.280 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>tick_params</method>
<code>
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)

</code><intended_behavior>The `tick_params` method should be enhanced to support a new keyword argument `fontfamily`. This argument will allow users to specify the font family for tick labels directly within the `tick_params` call. The method should accept `fontfamily` as part of its `**kwargs`, implement logic to apply the `fontfamily` to tick labels, ensure the addition of `fontfamily` does not disrupt any existing functionality, and update the documentation to include `fontfamily`, specifying its usage.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     def get_window_extent(self, renderer=None):
800         """
801         Return the Axes bounding box in display space.
802 
803         This bounding box does not include the spines, ticks, ticklabels,
804         or other labels.  For a bounding box including these elements use
805         `~matplotlib.axes.Axes.get_tightbbox`.
806 
807         See Also
808         --------
809         matplotlib.axes.Axes.get_tightbbox
810         matplotlib.axis.Axis.get_tightbbox
811         matplotlib.spines.Spine.get_window_extent
812         """
813         return self.bbox
814 
815     def _init_axis(self):
816         # This is moved out of __init__ because non-separable axes don't use it
817         self.xaxis = maxis.XAxis(self)
818         self.spines.bottom.register_axis(self.xaxis)
819         self.spines.top.register_axis(self.xaxis)
820         self.yaxis = maxis.YAxis(self)
821         self.spines.left.register_axis(self.yaxis)
822         self.spines.right.register_axis(self.yaxis)
823 
824     def set_figure(self, fig):
825         # docstring inherited
826         super().set_figure(fig)
827 
828         self.bbox = mtransforms.TransformedBbox(self._position,
829                                                 fig.transSubfigure)
830         # these will be updated later as data is added
831         self.dataLim = mtransforms.Bbox.null()
832         self._viewLim = mtransforms.Bbox.unit()
833         self.transScale = mtransforms.TransformWrapper(
834             mtransforms.IdentityTransform())
835 
836         self._set_lim_and_transforms()
837 
838     def _unstale_viewLim(self):
839         # We should arrange to store this information once per share-group
840         # instead of on every axis.
841         need_scale = {
842             name: any(ax._stale_viewlims[name]
843                       for ax in self._shared_axes[name].get_siblings(self))
844             for name in self._axis_names}
845         if any(need_scale.values()):
846             for name in need_scale:
847                 for ax in self._shared_axes[name].get_siblings(self):
848                     ax._stale_viewlims[name] = False
849             self.autoscale_view(**{f"scale{name}": scale
850                                    for name, scale in need_scale.items()})
851 
852     @property
853     def viewLim(self):
854         self._unstale_viewLim()
855         return self._viewLim
856 
857     def _request_autoscale_view(self, axis="all", tight=None):
858         """
859         Mark a single axis, or all of them, as stale wrt. autoscaling.
860 
861         No computation is performed until the next autoscaling; thus, separate
862         calls to control individual axises incur negligible performance cost.
863 
864         Parameters
865         ----------
866         axis : str, default: "all"
867             Either an element of ``self._axis_names``, or "all".
868         tight : bool or None, default: None
869         """
870         axis_names = _api.check_getitem(
871             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
872             axis=axis)
873         for name in axis_names:
874             self._stale_viewlims[name] = True
875         if tight is not None:
876             self._tight = tight
877 
878     def _set_lim_and_transforms(self):
879         """
880         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
881         *transData*, *transLimits* and *transAxes* transformations.
882 
883         .. note::
884 
885             This method is primarily used by rectilinear projections of the
886             `~matplotlib.axes.Axes` class, and is meant to be overridden by
887             new kinds of projection Axes that need different transformations
888             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
889             example.)
890         """
891         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
892 
893         # Transforms the x and y axis separately by a scale factor.
894         # It is assumed that this part will have non-linear components
895         # (e.g., for a log scale).
896         self.transScale = mtransforms.TransformWrapper(
897             mtransforms.IdentityTransform())
898 
899         # An affine transformation on the data, generally to limit the
900         # range of the axes
901         self.transLimits = mtransforms.BboxTransformFrom(
902             mtransforms.TransformedBbox(self._viewLim, self.transScale))
903 
904         # The parentheses are important for efficiency here -- they
905         # group the last two (which are usually affines) separately
906         # from the first (which, with log-scaling can be non-affine).
907         self.transData = self.transScale + (self.transLimits + self.transAxes)
908 
909         self._xaxis_transform = mtransforms.blended_transform_factory(
910             self.transData, self.transAxes)
911         self._yaxis_transform = mtransforms.blended_transform_factory(
912             self.transAxes, self.transData)
913 
914     def get_xaxis_transform(self, which='grid'):
915         """
916         Get the transformation used for drawing x-axis labels, ticks
917         and gridlines.  The x-direction is in data coordinates and the
918         y-direction is in axis coordinates.
919 
920         .. note::
921 
922             This transformation is primarily used by the
923             `~matplotlib.axis.Axis` class, and is meant to be
924             overridden by new kinds of projections that may need to
925             place axis elements in different locations.
926 
927         Parameters
928         ----------
929         which : {'grid', 'tick1', 'tick2'}
930         """
931         if which == 'grid':
932             return self._xaxis_transform
933         elif which == 'tick1':
934             # for cartesian projection, this is bottom spine
935             return self.spines.bottom.get_spine_transform()
936         elif which == 'tick2':
937             # for cartesian projection, this is top spine
938             return self.spines.top.get_spine_transform()
939         else:
940             raise ValueError(f'unknown value for which: {which!r}')
941 
942     def get_xaxis_text1_transform(self, pad_points):
943         """
944         Returns
945         -------
946         transform : Transform
947             The transform used for drawing x-axis labels, which will add
948             *pad_points* of padding (in points) between the axis and the label.
949             The x-direction is in data coordinates and the y-direction is in
950             axis coordinates
951         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
952             The text vertical alignment.
953         halign : {'center', 'left', 'right'}
954             The text horizontal alignment.
955 
956         Notes
957         -----
958         This transformation is primarily used by the `~matplotlib.axis.Axis`
959         class, and is meant to be overridden by new kinds of projections that
960         may need to place axis elements in different locations.
961         """
962         labels_align = mpl.rcParams["xtick.alignment"]
963         return (self.get_xaxis_transform(which='tick1') +
964                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
965                                               self.figure.dpi_scale_trans),
966                 "top", labels_align)
967 
968     def get_xaxis_text2_transform(self, pad_points):
969         """
970         Returns
971         -------
972         transform : Transform
973             The transform used for drawing secondary x-axis labels, which will
974             add *pad_points* of padding (in points) between the axis and the
975             label.  The x-direction is in data coordinates and the y-direction
976             is in axis coordinates
977         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
978             The text vertical alignment.
979         halign : {'center', 'left', 'right'}
980             The text horizontal alignment.
981 
982         Notes
983         -----
984         This transformation is primarily used by the `~matplotlib.axis.Axis`
985         class, and is meant to be overridden by new kinds of projections that
986         may need to place axis elements in different locations.
987         """
988         labels_align = mpl.rcParams["xtick.alignment"]
989         return (self.get_xaxis_transform(which='tick2') +
990                 mtransforms.ScaledTranslation(0, pad_points / 72,
991                                               self.figure.dpi_scale_trans),
992                 "bottom", labels_align)
993 
994     def get_yaxis_transform(self, which='grid'):
995         """
996         Get the transformation used for drawing y-axis labels, ticks
997         and gridlines.  The x-direction is in axis coordinates and the
998         y-direction is in data coordinates.
999 
1000         .. note::
1001 
1002             This transformation is primarily used by the
1003             `~matplotlib.axis.Axis` class, and is meant to be
1004             overridden by new kinds of projections that may need to
1005             place axis elements in different locations.
1006 
1007         Parameters
1008         ----------
1009         which : {'grid', 'tick1', 'tick2'}
1010         """
1011         if which == 'grid':
1012             return self._yaxis_transform
1013         elif which == 'tick1':
1014             # for cartesian projection, this is bottom spine
1015             return self.spines.left.get_spine_transform()
1016         elif which == 'tick2':
1017             # for cartesian projection, this is top spine
1018             return self.spines.right.get_spine_transform()
1019         else:
1020             raise ValueError(f'unknown value for which: {which!r}')
1021 
1022     def get_yaxis_text1_transform(self, pad_points):
1023         """
1024         Returns
1025         -------
1026         transform : Transform
1027             The transform used for drawing y-axis labels, which will add
1028             *pad_points* of padding (in points) between the axis and the label.
1029             The x-direction is in axis coordinates and the y-direction is in
1030             data coordinates
1031         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1032             The text vertical alignment.
1033         halign : {'center', 'left', 'right'}
1034             The text horizontal alignment.
1035 
1036         Notes
1037         -----
1038         This transformation is primarily used by the `~matplotlib.axis.Axis`
1039         class, and is meant to be overridden by new kinds of projections that
1040         may need to place axis elements in different locations.
1041         """
1042         labels_align = mpl.rcParams["ytick.alignment"]
1043         return (self.get_yaxis_transform(which='tick1') +
1044                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1045                                               self.figure.dpi_scale_trans),
1046                 labels_align, "right")
1047 
1048     def get_yaxis_text2_transform(self, pad_points):
1049         """
1050         Returns
1051         -------
1052         transform : Transform
1053             The transform used for drawing secondart y-axis labels, which will
1054             add *pad_points* of padding (in points) between the axis and the
1055             label.  The x-direction is in axis coordinates and the y-direction
1056             is in data coordinates
1057         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1058             The text vertical alignment.
1059         halign : {'center', 'left', 'right'}
1060             The text horizontal alignment.
1061 
1062         Notes
1063         -----
1064         This transformation is primarily used by the `~matplotlib.axis.Axis`
1065         class, and is meant to be overridden by new kinds of projections that
1066         may need to place axis elements in different locations.
1067         """
1068         labels_align = mpl.rcParams["ytick.alignment"]
1069         return (self.get_yaxis_transform(which='tick2') +
1070                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1071                                               self.figure.dpi_scale_trans),
1072                 labels_align, "left")
1073 
1074     def _update_transScale(self):
1075         self.transScale.set(
1076             mtransforms.blended_transform_factory(
1077                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1078 
1079     def get_position(self, original=False):
1080         """
1081         Return the position of the Axes within the figure as a `.Bbox`.
1082 
1083         Parameters
1084         ----------
1085         original : bool
1086             If ``True``, return the original position. Otherwise, return the
1087             active position. For an explanation of the positions see
1088             `.set_position`.
1089 
1090         Returns
1091         -------
1092         `.Bbox`
1093 
1094         """
1095         if original:
1096             return self._originalPosition.frozen()
1097         else:
1098             locator = self.get_axes_locator()
1099             if not locator:
1100                 self.apply_aspect()
1101             return self._position.frozen()
1102 
1103     def set_position(self, pos, which='both'):
1104         """
1105         Set the Axes position.
1106 
1107         Axes have two position attributes. The 'original' position is the
1108         position allocated for the Axes. The 'active' position is the
1109         position the Axes is actually drawn at. These positions are usually
1110         the same unless a fixed aspect is set to the Axes. See
1111         `.Axes.set_aspect` for details.
1112 
1113         Parameters
1114         ----------
1115         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1116             The new position of the Axes in `.Figure` coordinates.
1117 
1118         which : {'both', 'active', 'original'}, default: 'both'
1119             Determines which position variables to change.
1120 
1121         See Also
1122         --------
1123         matplotlib.transforms.Bbox.from_bounds
1124         matplotlib.transforms.Bbox.from_extents
1125         """
1126         self._set_position(pos, which=which)
1127         # because this is being called externally to the library we
1128         # don't let it be in the layout.
1129         self.set_in_layout(False)
1130 
1131     def _set_position(self, pos, which='both'):
1132         """
1133         Private version of set_position.
1134 
1135         Call this internally to get the same functionality of `set_position`,
1136         but not to take the axis out of the constrained_layout hierarchy.
1137         """
1138         if not isinstance(pos, mtransforms.BboxBase):
1139             pos = mtransforms.Bbox.from_bounds(*pos)
1140         for ax in self._twinned_axes.get_siblings(self):
1141             if which in ('both', 'active'):
1142                 ax._position.set(pos)
1143             if which in ('both', 'original'):
1144                 ax._originalPosition.set(pos)
1145         self.stale = True
1146 
1147     def reset_position(self):
1148         """
1149         Reset the active position to the original position.
1150 
1151         This undoes changes to the active position (as defined in
1152         `.set_position`) which may have been performed to satisfy fixed-aspect
1153         constraints.
1154         """
1155         for ax in self._twinned_axes.get_siblings(self):
1156             pos = ax.get_position(original=True)
1157             ax.set_position(pos, which='active')
1158 
1159     def set_axes_locator(self, locator):
1160         """
1161         Set the Axes locator.
1162 
1163         Parameters
1164         ----------
1165         locator : Callable[[Axes, Renderer], Bbox]
1166         """
1167         self._axes_locator = locator
1168         self.stale = True
1169 
1170     def get_axes_locator(self):
1171         """
1172         Return the axes_locator.
1173         """
1174         return self._axes_locator
1175 
1176     def _set_artist_props(self, a):
1177         """Set the boilerplate props for artists added to Axes."""
1178         a.set_figure(self.figure)
1179         if not a.is_transform_set():
1180             a.set_transform(self.transData)
1181 
1182         a.axes = self
1183         if a.get_mouseover():
1184             self._mouseover_set.add(a)
1185 
1186     def _gen_axes_patch(self):
1187         """
1188         Returns
1189         -------
1190         Patch
1191             The patch used to draw the background of the Axes.  It is also used
1192             as the clipping path for any data elements on the Axes.
1193 
1194             In the standard Axes, this is a rectangle, but in other projections
1195             it may not be.
1196 
1197         Notes
1198         -----
1199         Intended to be overridden by new projection types.
1200         """
1201         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1202 
1203     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1204         """
1205         Returns
1206         -------
1207         dict
1208             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1209             used to draw Axes spines.
1210 
1211             In the standard Axes, spines are single line segments, but in other
1212             projections they may not be.
1213 
1214         Notes
1215         -----
1216         Intended to be overridden by new projection types.
1217         """
1218         return {side: mspines.Spine.linear_spine(self, side)
1219                 for side in ['left', 'right', 'bottom', 'top']}
1220 
1221     def sharex(self, other):
1222         """
1223         Share the x-axis with *other*.
1224 
1225         This is equivalent to passing ``sharex=other`` when constructing the
1226         Axes, and cannot be used if the x-axis is already being shared with
1227         another Axes.
1228         """
1229         _api.check_isinstance(_AxesBase, other=other)
1230         if self._sharex is not None and other is not self._sharex:
1231             raise ValueError("x-axis is already shared")
1232         self._shared_axes["x"].join(self, other)
1233         self._sharex = other
1234         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1235         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1236         x0, x1 = other.get_xlim()
1237         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1238         self.xaxis._scale = other.xaxis._scale
1239 
1240     def sharey(self, other):
1241         """
1242         Share the y-axis with *other*.
1243 
1244         This is equivalent to passing ``sharey=other`` when constructing the
1245         Axes, and cannot be used if the y-axis is already being shared with
1246         another Axes.
1247         """
1248         _api.check_isinstance(_AxesBase, other=other)
1249         if self._sharey is not None and other is not self._sharey:
1250             raise ValueError("y-axis is already shared")
1251         self._shared_axes["y"].join(self, other)
1252         self._sharey = other
1253         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1254         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1255         y0, y1 = other.get_ylim()
1256         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1257         self.yaxis._scale = other.yaxis._scale
1258 
1259     def __clear(self):
1260         """Clear the Axes."""
1261         # The actual implementation of clear() as long as clear() has to be
1262         # an adapter delegating to the correct implementation.
1263         # The implementation can move back into clear() when the
1264         # deprecation on cla() subclassing expires.
1265 
1266         # stash the current visibility state
1267         if hasattr(self, 'patch'):
1268             patch_visible = self.patch.get_visible()
1269         else:
1270             patch_visible = True
1271 
1272         xaxis_visible = self.xaxis.get_visible()
1273         yaxis_visible = self.yaxis.get_visible()
1274 
1275         for axis in self._axis_map.values():
1276             axis.clear()  # Also resets the scale to linear.
1277         for spine in self.spines.values():
1278             spine.clear()
1279 
1280         self.ignore_existing_data_limits = True
1281         self.callbacks = cbook.CallbackRegistry(
1282             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1283 
1284         # update the minor locator for x and y axis based on rcParams
1285         if mpl.rcParams['xtick.minor.visible']:
1286             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1287         if mpl.rcParams['ytick.minor.visible']:
1288             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1289 
1290         self._xmargin = mpl.rcParams['axes.xmargin']
1291         self._ymargin = mpl.rcParams['axes.ymargin']
1292         self._tight = None
1293         self._use_sticky_edges = True
1294 
1295         self._get_lines = _process_plot_var_args(self)
1296         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1297 
1298         self._gridOn = mpl.rcParams['axes.grid']
1299         old_children, self._children = self._children, []
1300         for chld in old_children:
1301             chld.axes = chld.figure = None
1302         self._mouseover_set = _OrderedSet()
1303         self.child_axes = []
1304         self._current_image = None  # strictly for pyplot via _sci, _gci
1305         self._projection_init = None  # strictly for pyplot.subplot
1306         self.legend_ = None
1307         self.containers = []
1308 
1309         self.grid(False)  # Disable grid on init to use rcParameter
1310         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1311                   axis=mpl.rcParams['axes.grid.axis'])
1312         props = font_manager.FontProperties(
1313             size=mpl.rcParams['axes.titlesize'],
1314             weight=mpl.rcParams['axes.titleweight'])
1315 
1316         y = mpl.rcParams['axes.titley']
1317         if y is None:
1318             y = 1.0
1319             self._autotitlepos = True
1320         else:
1321             self._autotitlepos = False
1322 
1323         self.title = mtext.Text(
1324             x=0.5, y=y, text='',
1325             fontproperties=props,
1326             verticalalignment='baseline',
1327             horizontalalignment='center',
1328             )
1329         self._left_title = mtext.Text(
1330             x=0.0, y=y, text='',
1331             fontproperties=props.copy(),
1332             verticalalignment='baseline',
1333             horizontalalignment='left', )
1334         self._right_title = mtext.Text(
1335             x=1.0, y=y, text='',
1336             fontproperties=props.copy(),
1337             verticalalignment='baseline',
1338             horizontalalignment='right',
1339             )
1340         title_offset_points = mpl.rcParams['axes.titlepad']
1341         # refactor this out so it can be called in ax.set_title if
1342         # pad argument used...
1343         self._set_title_offset_trans(title_offset_points)
1344 
1345         for _title in (self.title, self._left_title, self._right_title):
1346             self._set_artist_props(_title)
1347 
1348         # The patch draws the background of the Axes.  We want this to be below
1349         # the other artists.  We use the frame to draw the edges so we are
1350         # setting the edgecolor to None.
1351         self.patch = self._gen_axes_patch()
1352         self.patch.set_figure(self.figure)
1353         self.patch.set_facecolor(self._facecolor)
1354         self.patch.set_edgecolor('none')
1355         self.patch.set_linewidth(0)
1356         self.patch.set_transform(self.transAxes)
1357 
1358         self.set_axis_on()
1359 
1360         self.xaxis.set_clip_path(self.patch)
1361         self.yaxis.set_clip_path(self.patch)
1362 
1363         if self._sharex is not None:
1364             self.xaxis.set_visible(xaxis_visible)
1365             self.patch.set_visible(patch_visible)
1366         if self._sharey is not None:
1367             self.yaxis.set_visible(yaxis_visible)
1368             self.patch.set_visible(patch_visible)
1369 
1370         # This comes last, as the call to _set_lim may trigger an autoscale (in
1371         # case of shared axes), requiring children to be already set up.
1372         for name, axis in self._axis_map.items():
1373             share = getattr(self, f"_share{name}")
1374             if share is not None:
1375                 getattr(self, f"share{name}")(share)
1376             else:
1377                 axis._set_scale("linear")
1378                 axis._set_lim(0, 1, auto=True)
1379         self._update_transScale()
1380 
1381         self.stale = True
1382 
1383     def clear(self):
1384         """Clear the Axes."""
1385         # Act as an alias, or as the superclass implementation depending on the
1386         # subclass implementation.
1387         if self._subclass_uses_cla:
1388             self.cla()
1389         else:
1390             self.__clear()
1391 
1392     def cla(self):
1393         """Clear the Axes."""
1394         # Act as an alias, or as the superclass implementation depending on the
1395         # subclass implementation.
1396         if self._subclass_uses_cla:
1397             self.__clear()
1398         else:
1399             self.clear()
1400 
1401     class ArtistList(Sequence):
1402         """
1403         A sublist of Axes children based on their type.
1404 
1405         The type-specific children sublists were made immutable in Matplotlib
1406         3.7.  In the future these artist lists may be replaced by tuples. Use
1407         as if this is a tuple already.
1408         """
1409         def __init__(self, axes, prop_name,
1410                      valid_types=None, invalid_types=None):
1411             """
1412             Parameters
1413             ----------
1414             axes : `~matplotlib.axes.Axes`
1415                 The Axes from which this sublist will pull the children
1416                 Artists.
1417             prop_name : str
1418                 The property name used to access this sublist from the Axes;
1419                 used to generate deprecation warnings.
1420             valid_types : list of type, optional
1421                 A list of types that determine which children will be returned
1422                 by this sublist. If specified, then the Artists in the sublist
1423                 must be instances of any of these types. If unspecified, then
1424                 any type of Artist is valid (unless limited by
1425                 *invalid_types*.)
1426             invalid_types : tuple, optional
1427                 A list of types that determine which children will *not* be
1428                 returned by this sublist. If specified, then Artists in the
1429                 sublist will never be an instance of these types. Otherwise, no
1430                 types will be excluded.
1431             """
1432             self._axes = axes
1433             self._prop_name = prop_name
1434             self._type_check = lambda artist: (
1435                 (not valid_types or isinstance(artist, valid_types)) and
1436                 (not invalid_types or not isinstance(artist, invalid_types))
1437             )
1438 
1439         def __repr__(self):
1440             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1441 
1442         def __len__(self):
1443             return sum(self._type_check(artist)
1444                        for artist in self._axes._children)
1445 
1446         def __iter__(self):
1447             for artist in list(self._axes._children):
1448                 if self._type_check(artist):
1449                     yield artist
1450 
1451         def __getitem__(self, key):
1452             return [artist
1453                     for artist in self._axes._children
1454                     if self._type_check(artist)][key]
1455 
1456         def __add__(self, other):
1457             if isinstance(other, (list, _AxesBase.ArtistList)):
1458                 return [*self, *other]
1459             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1460                 return (*self, *other)
1461             return NotImplemented
1462 
1463         def __radd__(self, other):
1464             if isinstance(other, list):
1465                 return other + list(self)
1466             if isinstance(other, tuple):
1467                 return other + tuple(self)
1468             return NotImplemented
1469 
1470     @property
1471     def artists(self):
1472         return self.ArtistList(self, 'artists', invalid_types=(
1473             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1474             mtable.Table, mtext.Text))
1475 
1476     @property
1477     def collections(self):
1478         return self.ArtistList(self, 'collections',
1479                                valid_types=mcoll.Collection)
1480 
1481     @property
1482     def images(self):
1483         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1484 
1485     @property
1486     def lines(self):
1487         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1488 
1489     @property
1490     def patches(self):
1491         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1492 
1493     @property
1494     def tables(self):
1495         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1496 
1497     @property
1498     def texts(self):
1499         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1500 
1501     def get_facecolor(self):
1502         """Get the facecolor of the Axes."""
1503         return self.patch.get_facecolor()
1504 
1505     def set_facecolor(self, color):
1506         """
1507         Set the facecolor of the Axes.
1508 
1509         Parameters
1510         ----------
1511         color : color
1512         """
1513         self._facecolor = color
1514         self.stale = True
1515         return self.patch.set_facecolor(color)
1516 
1517     def _set_title_offset_trans(self, title_offset_points):
1518         """
1519         Set the offset for the title either from :rc:`axes.titlepad`
1520         or from set_title kwarg ``pad``.
1521         """
1522         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1523                 0.0, title_offset_points / 72,
1524                 self.figure.dpi_scale_trans)
1525         for _title in (self.title, self._left_title, self._right_title):
1526             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1527             _title.set_clip_box(None)
1528 
1529     def set_prop_cycle(self, *args, **kwargs):
1530         """
1531         Set the property cycle of the Axes.
1532 
1533         The property cycle controls the style properties such as color,
1534         marker and linestyle of future plot commands. The style properties
1535         of data already added to the Axes are not modified.
1536 
1537         Call signatures::
1538 
1539           set_prop_cycle(cycler)
1540           set_prop_cycle(label=values[, label2=values2[, ...]])
1541           set_prop_cycle(label, values)
1542 
1543         Form 1 sets given `~cycler.Cycler` object.
1544 
1545         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1546         properties simultaneously and set it as the property cycle of the
1547         Axes. If multiple properties are given, their value lists must have
1548         the same length. This is just a shortcut for explicitly creating a
1549         cycler and passing it to the function, i.e. it's short for
1550         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1551 
1552         Form 3 creates a `~cycler.Cycler` for a single property and set it
1553         as the property cycle of the Axes. This form exists for compatibility
1554         with the original `cycler.cycler` interface. Its use is discouraged
1555         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1556 
1557         Parameters
1558         ----------
1559         cycler : Cycler
1560             Set the given Cycler. *None* resets to the cycle defined by the
1561             current style.
1562 
1563         label : str
1564             The property key. Must be a valid `.Artist` property.
1565             For example, 'color' or 'linestyle'. Aliases are allowed,
1566             such as 'c' for 'color' and 'lw' for 'linewidth'.
1567 
1568         values : iterable
1569             Finite-length iterable of the property values. These values
1570             are validated and will raise a ValueError if invalid.
1571 
1572         See Also
1573         --------
1574         matplotlib.rcsetup.cycler
1575             Convenience function for creating validated cyclers for properties.
1576         cycler.cycler
1577             The original function for creating unvalidated cyclers.
1578 
1579         Examples
1580         --------
1581         Setting the property cycle for a single property:
1582 
1583         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1584 
1585         Setting the property cycle for simultaneously cycling over multiple
1586         properties (e.g. red circle, green plus, blue cross):
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1589         ...                   marker=['o', '+', 'x'])
1590 
1591         """
1592         if args and kwargs:
1593             raise TypeError("Cannot supply both positional and keyword "
1594                             "arguments to this method.")
1595         # Can't do `args == (None,)` as that crashes cycler.
1596         if len(args) == 1 and args[0] is None:
1597             prop_cycle = None
1598         else:
1599             prop_cycle = cycler(*args, **kwargs)
1600         self._get_lines.set_prop_cycle(prop_cycle)
1601         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1602 
1603     def get_aspect(self):
1604         """
1605         Return the aspect ratio of the axes scaling.
1606 
1607         This is either "auto" or a float giving the ratio of y/x-scale.
1608         """
1609         return self._aspect
1610 
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True
1682 
1683     def get_adjustable(self):
1684         """
1685         Return whether the Axes will adjust its physical dimension ('box') or
1686         its data limits ('datalim') to achieve the desired aspect ratio.
1687 
1688         See Also
1689         --------
1690         matplotlib.axes.Axes.set_adjustable
1691             Set how the Axes adjusts to achieve the required aspect ratio.
1692         matplotlib.axes.Axes.set_aspect
1693             For a description of aspect handling.
1694         """
1695         return self._adjustable
1696 
1697     def set_adjustable(self, adjustable, share=False):
1698         """
1699         Set how the Axes adjusts to achieve the required aspect ratio.
1700 
1701         Parameters
1702         ----------
1703         adjustable : {'box', 'datalim'}
1704             If 'box', change the physical dimensions of the Axes.
1705             If 'datalim', change the ``x`` or ``y`` data limits.
1706 
1707         share : bool, default: False
1708             If ``True``, apply the settings to all shared Axes.
1709 
1710         See Also
1711         --------
1712         matplotlib.axes.Axes.set_aspect
1713             For a description of aspect handling.
1714 
1715         Notes
1716         -----
1717         Shared Axes (of which twinned Axes are a special case)
1718         impose restrictions on how aspect ratios can be imposed.
1719         For twinned Axes, use 'datalim'.  For Axes that share both
1720         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1721         may be used.  These limitations are partly a requirement
1722         to avoid over-specification, and partly a result of the
1723         particular implementation we are currently using, in
1724         which the adjustments for aspect ratios are done sequentially
1725         and independently on each Axes as it is drawn.
1726         """
1727         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1728         if share:
1729             axs = {sibling for name in self._axis_names
1730                    for sibling in self._shared_axes[name].get_siblings(self)}
1731         else:
1732             axs = [self]
1733         if (adjustable == "datalim"
1734                 and any(getattr(ax.get_data_ratio, "__func__", None)
1735                         != _AxesBase.get_data_ratio
1736                         for ax in axs)):
1737             # Limits adjustment by apply_aspect assumes that the axes' aspect
1738             # ratio can be computed from the data limits and scales.
1739             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1740                              "Axes which override 'get_data_ratio'")
1741         for ax in axs:
1742             ax._adjustable = adjustable
1743         self.stale = True
1744 
1745     def get_box_aspect(self):
1746         """
1747         Return the Axes box aspect, i.e. the ratio of height to width.
1748 
1749         The box aspect is ``None`` (i.e. chosen depending on the available
1750         figure space) unless explicitly specified.
1751 
1752         See Also
1753         --------
1754         matplotlib.axes.Axes.set_box_aspect
1755             for a description of box aspect.
1756         matplotlib.axes.Axes.set_aspect
1757             for a description of aspect handling.
1758         """
1759         return self._box_aspect
1760 
1761     def set_box_aspect(self, aspect=None):
1762         """
1763         Set the Axes box aspect, i.e. the ratio of height to width.
1764 
1765         This defines the aspect of the Axes in figure space and is not to be
1766         confused with the data aspect (see `~.Axes.set_aspect`).
1767 
1768         Parameters
1769         ----------
1770         aspect : float or None
1771             Changes the physical dimensions of the Axes, such that the ratio
1772             of the Axes height to the Axes width in physical units is equal to
1773             *aspect*. Defining a box aspect will change the *adjustable*
1774             property to 'datalim' (see `~.Axes.set_adjustable`).
1775 
1776             *None* will disable a fixed box aspect so that height and width
1777             of the Axes are chosen independently.
1778 
1779         See Also
1780         --------
1781         matplotlib.axes.Axes.set_aspect
1782             for a description of aspect handling.
1783         """
1784         axs = {*self._twinned_axes.get_siblings(self),
1785                *self._twinned_axes.get_siblings(self)}
1786 
1787         if aspect is not None:
1788             aspect = float(aspect)
1789             # when box_aspect is set to other than None`,
1790             # adjustable must be "datalim"
1791             for ax in axs:
1792                 ax.set_adjustable("datalim")
1793 
1794         for ax in axs:
1795             ax._box_aspect = aspect
1796             ax.stale = True
1797 
1798     def get_anchor(self):
1799         """
1800         Get the anchor location.
1801 
1802         See Also
1803         --------
1804         matplotlib.axes.Axes.set_anchor
1805             for a description of the anchor.
1806         matplotlib.axes.Axes.set_aspect
1807             for a description of aspect handling.
1808         """
1809         return self._anchor
1810 
1811     def set_anchor(self, anchor, share=False):
1812         """
1813         Define the anchor location.
1814 
1815         The actual drawing area (active position) of the Axes may be smaller
1816         than the Bbox (original position) when a fixed aspect is required. The
1817         anchor defines where the drawing area will be located within the
1818         available space.
1819 
1820         Parameters
1821         ----------
1822         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1823             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1824             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1825             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1826             for (*x*, *y*) coordinates, as shown in the following diagram::
1827 
1828                
1829                 'NW' (0.0, 1.0)  'N' (0.5, 1.0)   'NE' (1.0, 1.0) 
1830                
1831                 'W'  (0.0, 0.5)  'C' (0.5, 0.5)   'E'  (1.0, 0.5) 
1832                
1833                 'SW' (0.0, 0.0)  'S' (0.5, 0.0)   'SE' (1.0, 0.0) 
1834                
1835 
1836         share : bool, default: False
1837             If ``True``, apply the settings to all shared Axes.
1838 
1839         See Also
1840         --------
1841         matplotlib.axes.Axes.set_aspect
1842             for a description of aspect handling.
1843         """
1844         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1845             raise ValueError('argument must be among %s' %
1846                              ', '.join(mtransforms.Bbox.coefs))
1847         if share:
1848             axes = {sibling for name in self._axis_names
1849                     for sibling in self._shared_axes[name].get_siblings(self)}
1850         else:
1851             axes = [self]
1852         for ax in axes:
1853             ax._anchor = anchor
1854 
1855         self.stale = True
1856 
1857     def get_data_ratio(self):
1858         """
1859         Return the aspect ratio of the scaled data.
1860 
1861         Notes
1862         -----
1863         This method is intended to be overridden by new projection types.
1864         """
1865         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1866         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1867         xsize = max(abs(txmax - txmin), 1e-30)
1868         ysize = max(abs(tymax - tymin), 1e-30)
1869         return ysize / xsize
1870 
1871     def apply_aspect(self, position=None):
1872         """
1873         Adjust the Axes for a specified data aspect ratio.
1874 
1875         Depending on `.get_adjustable` this will modify either the
1876         Axes box (position) or the view limits. In the former case,
1877         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1878 
1879         Parameters
1880         ----------
1881         position : None or .Bbox
1882             If not ``None``, this defines the position of the
1883             Axes within the figure as a Bbox. See `~.Axes.get_position`
1884             for further details.
1885 
1886         Notes
1887         -----
1888         This is called automatically when each Axes is drawn.  You may need
1889         to call it yourself if you need to update the Axes position and/or
1890         view limits before the Figure is drawn.
1891 
1892         See Also
1893         --------
1894         matplotlib.axes.Axes.set_aspect
1895             For a description of aspect ratio handling.
1896         matplotlib.axes.Axes.set_adjustable
1897             Set how the Axes adjusts to achieve the required aspect ratio.
1898         matplotlib.axes.Axes.set_anchor
1899             Set the position in case of extra space.
1900         """
1901         if position is None:
1902             position = self.get_position(original=True)
1903 
1904         aspect = self.get_aspect()
1905 
1906         if aspect == 'auto' and self._box_aspect is None:
1907             self._set_position(position, which='active')
1908             return
1909 
1910         trans = self.get_figure().transSubfigure
1911         bb = mtransforms.Bbox.unit().transformed(trans)
1912         # this is the physical aspect of the panel (or figure):
1913         fig_aspect = bb.height / bb.width
1914 
1915         if self._adjustable == 'box':
1916             if self in self._twinned_axes:
1917                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1918                                    "twinned Axes; use 'datalim' instead")
1919             box_aspect = aspect * self.get_data_ratio()
1920             pb = position.frozen()
1921             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1922             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1923             return
1924 
1925         # The following is only seen if self._adjustable == 'datalim'
1926         if self._box_aspect is not None:
1927             pb = position.frozen()
1928             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1929             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1930             if aspect == "auto":
1931                 return
1932 
1933         # reset active to original in case it had been changed by prior use
1934         # of 'box'
1935         if self._box_aspect is None:
1936             self._set_position(position, which='active')
1937         else:
1938             position = pb1.anchored(self.get_anchor(), pb)
1939 
1940         x_trf = self.xaxis.get_transform()
1941         y_trf = self.yaxis.get_transform()
1942         xmin, xmax = x_trf.transform(self.get_xbound())
1943         ymin, ymax = y_trf.transform(self.get_ybound())
1944         xsize = max(abs(xmax - xmin), 1e-30)
1945         ysize = max(abs(ymax - ymin), 1e-30)
1946 
1947         box_aspect = fig_aspect * (position.height / position.width)
1948         data_ratio = box_aspect / aspect
1949 
1950         y_expander = data_ratio * xsize / ysize - 1
1951         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1952         if abs(y_expander) < 0.005:
1953             return
1954 
1955         dL = self.dataLim
1956         x0, x1 = x_trf.transform(dL.intervalx)
1957         y0, y1 = y_trf.transform(dL.intervaly)
1958         xr = 1.05 * (x1 - x0)
1959         yr = 1.05 * (y1 - y0)
1960 
1961         xmarg = xsize - xr
1962         ymarg = ysize - yr
1963         Ysize = data_ratio * xsize
1964         Xsize = ysize / data_ratio
1965         Xmarg = Xsize - xr
1966         Ymarg = Ysize - yr
1967         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1968         xm = 0
1969         ym = 0
1970 
1971         shared_x = self in self._shared_axes["x"]
1972         shared_y = self in self._shared_axes["y"]
1973 
1974         if shared_x and shared_y:
1975             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1976                                "axis('equal') are not allowed when both axes "
1977                                "are shared.  Try set_aspect(..., "
1978                                "adjustable='box').")
1979 
1980         # If y is shared, then we are only allowed to change x, etc.
1981         if shared_y:
1982             adjust_y = False
1983         else:
1984             if xmarg > xm and ymarg > ym:
1985                 adjy = ((Ymarg > 0 and y_expander < 0) or
1986                         (Xmarg < 0 and y_expander > 0))
1987             else:
1988                 adjy = y_expander > 0
1989             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1990 
1991         if adjust_y:
1992             yc = 0.5 * (ymin + ymax)
1993             y0 = yc - Ysize / 2.0
1994             y1 = yc + Ysize / 2.0
1995             self.set_ybound(y_trf.inverted().transform([y0, y1]))
1996         else:
1997             xc = 0.5 * (xmin + xmax)
1998             x0 = xc - Xsize / 2.0
1999             x1 = xc + Xsize / 2.0
2000             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2001 
2002     def axis(self, arg=None, /, *, emit=True, **kwargs):
2003         """
2004         Convenience method to get or set some axis properties.
2005 
2006         Call signatures::
2007 
2008           xmin, xmax, ymin, ymax = axis()
2009           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2010           xmin, xmax, ymin, ymax = axis(option)
2011           xmin, xmax, ymin, ymax = axis(**kwargs)
2012 
2013         Parameters
2014         ----------
2015         xmin, xmax, ymin, ymax : float, optional
2016             The axis limits to be set.  This can also be achieved using ::
2017 
2018                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2019 
2020         option : bool or str
2021             If a bool, turns axis lines and labels on or off. If a string,
2022             possible values are:
2023 
2024             ======== ==========================================================
2025             Value    Description
2026             ======== ==========================================================
2027             'on'     Turn on axis lines and labels. Same as ``True``.
2028             'off'    Turn off axis lines and labels. Same as ``False``.
2029             'equal'  Set equal scaling (i.e., make circles circular) by
2030                      changing axis limits. This is the same as
2031                      ``ax.set_aspect('equal', adjustable='datalim')``.
2032                      Explicit data limits may not be respected in this case.
2033             'scaled' Set equal scaling (i.e., make circles circular) by
2034                      changing dimensions of the plot box. This is the same as
2035                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2036                      Additionally, further autoscaling will be disabled.
2037             'tight'  Set limits just large enough to show all data, then
2038                      disable further autoscaling.
2039             'auto'   Automatic scaling (fill plot box with data).
2040             'image'  'scaled' with axis limits equal to data limits.
2041             'square' Square plot; similar to 'scaled', but initially forcing
2042                      ``xmax-xmin == ymax-ymin``.
2043             ======== ==========================================================
2044 
2045         emit : bool, default: True
2046             Whether observers are notified of the axis limit change.
2047             This option is passed on to `~.Axes.set_xlim` and
2048             `~.Axes.set_ylim`.
2049 
2050         Returns
2051         -------
2052         xmin, xmax, ymin, ymax : float
2053             The axis limits.
2054 
2055         See Also
2056         --------
2057         matplotlib.axes.Axes.set_xlim
2058         matplotlib.axes.Axes.set_ylim
2059         """
2060         if isinstance(arg, (str, bool)):
2061             if arg is True:
2062                 arg = 'on'
2063             if arg is False:
2064                 arg = 'off'
2065             arg = arg.lower()
2066             if arg == 'on':
2067                 self.set_axis_on()
2068             elif arg == 'off':
2069                 self.set_axis_off()
2070             elif arg in [
2071                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2072                 self.set_autoscale_on(True)
2073                 self.set_aspect('auto')
2074                 self.autoscale_view(tight=False)
2075                 if arg == 'equal':
2076                     self.set_aspect('equal', adjustable='datalim')
2077                 elif arg == 'scaled':
2078                     self.set_aspect('equal', adjustable='box', anchor='C')
2079                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2080                 elif arg == 'tight':
2081                     self.autoscale_view(tight=True)
2082                     self.set_autoscale_on(False)
2083                 elif arg == 'image':
2084                     self.autoscale_view(tight=True)
2085                     self.set_autoscale_on(False)
2086                     self.set_aspect('equal', adjustable='box', anchor='C')
2087                 elif arg == 'square':
2088                     self.set_aspect('equal', adjustable='box', anchor='C')
2089                     self.set_autoscale_on(False)
2090                     xlim = self.get_xlim()
2091                     ylim = self.get_ylim()
2092                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2093                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2094                                   emit=emit, auto=False)
2095                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2096                                   emit=emit, auto=False)
2097             else:
2098                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2099                                  "try 'on' or 'off'")
2100         else:
2101             if arg is not None:
2102                 try:
2103                     xmin, xmax, ymin, ymax = arg
2104                 except (TypeError, ValueError) as err:
2105                     raise TypeError('the first argument to axis() must be an '
2106                                     'iterable of the form '
2107                                     '[xmin, xmax, ymin, ymax]') from err
2108             else:
2109                 xmin = kwargs.pop('xmin', None)
2110                 xmax = kwargs.pop('xmax', None)
2111                 ymin = kwargs.pop('ymin', None)
2112                 ymax = kwargs.pop('ymax', None)
2113             xauto = (None  # Keep autoscale state as is.
2114                      if xmin is None and xmax is None
2115                      else False)  # Turn off autoscale.
2116             yauto = (None
2117                      if ymin is None and ymax is None
2118                      else False)
2119             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2120             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2121         if kwargs:
2122             raise _api.kwarg_error("axis", kwargs)
2123         return (*self.get_xlim(), *self.get_ylim())
2124 
2125     def get_legend(self):
2126         """Return the `.Legend` instance, or None if no legend is defined."""
2127         return self.legend_
2128 
2129     def get_images(self):
2130         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2131         return cbook.silent_list('AxesImage', self.images)
2132 
2133     def get_lines(self):
2134         """Return a list of lines contained by the Axes."""
2135         return cbook.silent_list('Line2D', self.lines)
2136 
2137     def get_xaxis(self):
2138         """
2139         [*Discouraged*] Return the XAxis instance.
2140 
2141         .. admonition:: Discouraged
2142 
2143             The use of this function is discouraged. You should instead
2144             directly access the attribute ``ax.xaxis``.
2145         """
2146         return self.xaxis
2147 
2148     def get_yaxis(self):
2149         """
2150         [*Discouraged*] Return the YAxis instance.
2151 
2152         .. admonition:: Discouraged
2153 
2154             The use of this function is discouraged. You should instead
2155             directly access the attribute ``ax.yaxis``.
2156         """
2157         return self.yaxis
2158 
2159     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2160     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2161     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2162     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2163 
2164     # Adding and tracking artists
2165 
2166     def _sci(self, im):
2167         """
2168         Set the current image.
2169 
2170         This image will be the target of colormap functions like
2171         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2172         current image is an attribute of the current Axes.
2173         """
2174         _api.check_isinstance(
2175             (mpl.contour.ContourSet, mcoll.Collection, mimage.AxesImage),
2176             im=im)
2177         if isinstance(im, mpl.contour.ContourSet):
2178             if im.collections[0] not in self._children:
2179                 raise ValueError("ContourSet must be in current Axes")
2180         elif im not in self._children:
2181             raise ValueError("Argument must be an image, collection, or "
2182                              "ContourSet in this Axes")
2183         self._current_image = im
2184 
2185     def _gci(self):
2186         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2187         return self._current_image
2188 
2189     def has_data(self):
2190         """
2191         Return whether any artists have been added to the Axes.
2192 
2193         This should not be used to determine whether the *dataLim*
2194         need to be updated, and may not actually be useful for
2195         anything.
2196         """
2197         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2198                                   mlines.Line2D, mpatches.Patch))
2199                    for a in self._children)
2200 
2201     def add_artist(self, a):
2202         """
2203         Add an `.Artist` to the Axes; return the artist.
2204 
2205         Use `add_artist` only for artists for which there is no dedicated
2206         "add" method; and if necessary, use a method such as `update_datalim`
2207         to manually update the dataLim if the artist is to be included in
2208         autoscaling.
2209 
2210         If no ``transform`` has been specified when creating the artist (e.g.
2211         ``artist.get_transform() == None``) then the transform is set to
2212         ``ax.transData``.
2213         """
2214         a.axes = self
2215         self._children.append(a)
2216         a._remove_method = self._children.remove
2217         self._set_artist_props(a)
2218         if a.get_clip_path() is None:
2219             a.set_clip_path(self.patch)
2220         self.stale = True
2221         return a
2222 
2223     def add_child_axes(self, ax):
2224         """
2225         Add an `.AxesBase` to the Axes' children; return the child Axes.
2226 
2227         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2228         """
2229 
2230         # normally Axes have themselves as the Axes, but these need to have
2231         # their parent...
2232         # Need to bypass the getter...
2233         ax._axes = self
2234         ax.stale_callback = martist._stale_axes_callback
2235 
2236         self.child_axes.append(ax)
2237         ax._remove_method = self.child_axes.remove
2238         self.stale = True
2239         return ax
2240 
2241     def add_collection(self, collection, autolim=True):
2242         """
2243         Add a `.Collection` to the Axes; return the collection.
2244         """
2245         _api.check_isinstance(mcoll.Collection, collection=collection)
2246         label = collection.get_label()
2247         if not label:
2248             collection.set_label(f'_child{len(self._children)}')
2249         self._children.append(collection)
2250         collection._remove_method = self._children.remove
2251         self._set_artist_props(collection)
2252 
2253         if collection.get_clip_path() is None:
2254             collection.set_clip_path(self.patch)
2255 
2256         if autolim:
2257             # Make sure viewLim is not stale (mostly to match
2258             # pre-lazy-autoscale behavior, which is not really better).
2259             self._unstale_viewLim()
2260             datalim = collection.get_datalim(self.transData)
2261             points = datalim.get_points()
2262             if not np.isinf(datalim.minpos).all():
2263                 # By definition, if minpos (minimum positive value) is set
2264                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2265                 # and minpos would be superfluous. However, we add minpos to
2266                 # the call so that self.dataLim will update its own minpos.
2267                 # This ensures that log scales see the correct minimum.
2268                 points = np.concatenate([points, [datalim.minpos]])
2269             self.update_datalim(points)
2270 
2271         self.stale = True
2272         return collection
2273 
2274     def add_image(self, image):
2275         """
2276         Add an `.AxesImage` to the Axes; return the image.
2277         """
2278         _api.check_isinstance(mimage.AxesImage, image=image)
2279         self._set_artist_props(image)
2280         if not image.get_label():
2281             image.set_label(f'_child{len(self._children)}')
2282         self._children.append(image)
2283         image._remove_method = self._children.remove
2284         self.stale = True
2285         return image
2286 
2287     def _update_image_limits(self, image):
2288         xmin, xmax, ymin, ymax = image.get_extent()
2289         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2290 
2291     def add_line(self, line):
2292         """
2293         Add a `.Line2D` to the Axes; return the line.
2294         """
2295         _api.check_isinstance(mlines.Line2D, line=line)
2296         self._set_artist_props(line)
2297         if line.get_clip_path() is None:
2298             line.set_clip_path(self.patch)
2299 
2300         self._update_line_limits(line)
2301         if not line.get_label():
2302             line.set_label(f'_child{len(self._children)}')
2303         self._children.append(line)
2304         line._remove_method = self._children.remove
2305         self.stale = True
2306         return line
2307 
2308     def _add_text(self, txt):
2309         """
2310         Add a `.Text` to the Axes; return the text.
2311         """
2312         _api.check_isinstance(mtext.Text, txt=txt)
2313         self._set_artist_props(txt)
2314         self._children.append(txt)
2315         txt._remove_method = self._children.remove
2316         self.stale = True
2317         return txt
2318 
2319     def _update_line_limits(self, line):
2320         """
2321         Figures out the data limit of the given line, updating self.dataLim.
2322         """
2323         path = line.get_path()
2324         if path.vertices.size == 0:
2325             return
2326 
2327         line_trf = line.get_transform()
2328 
2329         if line_trf == self.transData:
2330             data_path = path
2331         elif any(line_trf.contains_branch_seperately(self.transData)):
2332             # Compute the transform from line coordinates to data coordinates.
2333             trf_to_data = line_trf - self.transData
2334             # If transData is affine we can use the cached non-affine component
2335             # of line's path (since the non-affine part of line_trf is
2336             # entirely encapsulated in trf_to_data).
2337             if self.transData.is_affine:
2338                 line_trans_path = line._get_transformed_path()
2339                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2340                 data_path = trf_to_data.transform_path_affine(na_path)
2341             else:
2342                 data_path = trf_to_data.transform_path(path)
2343         else:
2344             # For backwards compatibility we update the dataLim with the
2345             # coordinate range of the given path, even though the coordinate
2346             # systems are completely different. This may occur in situations
2347             # such as when ax.transAxes is passed through for absolute
2348             # positioning.
2349             data_path = path
2350 
2351         if not data_path.vertices.size:
2352             return
2353 
2354         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2355         if self.name != "rectilinear":
2356             # This block is mostly intended to handle axvline in polar plots,
2357             # for which updatey would otherwise be True.
2358             if updatex and line_trf == self.get_yaxis_transform():
2359                 updatex = False
2360             if updatey and line_trf == self.get_xaxis_transform():
2361                 updatey = False
2362         self.dataLim.update_from_path(data_path,
2363                                       self.ignore_existing_data_limits,
2364                                       updatex=updatex, updatey=updatey)
2365         self.ignore_existing_data_limits = False
2366 
2367     def add_patch(self, p):
2368         """
2369         Add a `.Patch` to the Axes; return the patch.
2370         """
2371         _api.check_isinstance(mpatches.Patch, p=p)
2372         self._set_artist_props(p)
2373         if p.get_clip_path() is None:
2374             p.set_clip_path(self.patch)
2375         self._update_patch_limits(p)
2376         self._children.append(p)
2377         p._remove_method = self._children.remove
2378         return p
2379 
2380     def _update_patch_limits(self, patch):
2381         """Update the data limits for the given patch."""
2382         # hist can add zero height Rectangles, which is useful to keep
2383         # the bins, counts and patches lined up, but it throws off log
2384         # scaling.  We'll ignore rects with zero height or width in
2385         # the auto-scaling
2386 
2387         # cannot check for '==0' since unitized data may not compare to zero
2388         # issue #2150 - we update the limits if patch has non zero width
2389         # or height.
2390         if (isinstance(patch, mpatches.Rectangle) and
2391                 ((not patch.get_width()) and (not patch.get_height()))):
2392             return
2393         p = patch.get_path()
2394         # Get all vertices on the path
2395         # Loop through each segment to get extrema for Bezier curve sections
2396         vertices = []
2397         for curve, code in p.iter_bezier(simplify=False):
2398             # Get distance along the curve of any extrema
2399             _, dzeros = curve.axis_aligned_extrema()
2400             # Calculate vertices of start, end and any extrema in between
2401             vertices.append(curve([0, *dzeros, 1]))
2402 
2403         if len(vertices):
2404             vertices = np.row_stack(vertices)
2405 
2406         patch_trf = patch.get_transform()
2407         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2408         if not (updatex or updatey):
2409             return
2410         if self.name != "rectilinear":
2411             # As in _update_line_limits, but for axvspan.
2412             if updatex and patch_trf == self.get_yaxis_transform():
2413                 updatex = False
2414             if updatey and patch_trf == self.get_xaxis_transform():
2415                 updatey = False
2416         trf_to_data = patch_trf - self.transData
2417         xys = trf_to_data.transform(vertices)
2418         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2419 
2420     def add_table(self, tab):
2421         """
2422         Add a `.Table` to the Axes; return the table.
2423         """
2424         _api.check_isinstance(mtable.Table, tab=tab)
2425         self._set_artist_props(tab)
2426         self._children.append(tab)
2427         if tab.get_clip_path() is None:
2428             tab.set_clip_path(self.patch)
2429         tab._remove_method = self._children.remove
2430         return tab
2431 
2432     def add_container(self, container):
2433         """
2434         Add a `.Container` to the Axes' containers; return the container.
2435         """
2436         label = container.get_label()
2437         if not label:
2438             container.set_label('_container%d' % len(self.containers))
2439         self.containers.append(container)
2440         container._remove_method = self.containers.remove
2441         return container
2442 
2443     def _unit_change_handler(self, axis_name, event=None):
2444         """
2445         Process axis units changes: requests updates to data and view limits.
2446         """
2447         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2448             return functools.partial(
2449                 self._unit_change_handler, axis_name, event=object())
2450         _api.check_in_list(self._axis_map, axis_name=axis_name)
2451         for line in self.lines:
2452             line.recache_always()
2453         self.relim()
2454         self._request_autoscale_view(axis_name)
2455 
2456     def relim(self, visible_only=False):
2457         """
2458         Recompute the data limits based on current artists.
2459 
2460         At present, `.Collection` instances are not supported.
2461 
2462         Parameters
2463         ----------
2464         visible_only : bool, default: False
2465             Whether to exclude invisible artists.
2466         """
2467         # Collections are deliberately not supported (yet); see
2468         # the TODO note in artists.py.
2469         self.dataLim.ignore(True)
2470         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2471         self.ignore_existing_data_limits = True
2472 
2473         for artist in self._children:
2474             if not visible_only or artist.get_visible():
2475                 if isinstance(artist, mlines.Line2D):
2476                     self._update_line_limits(artist)
2477                 elif isinstance(artist, mpatches.Patch):
2478                     self._update_patch_limits(artist)
2479                 elif isinstance(artist, mimage.AxesImage):
2480                     self._update_image_limits(artist)
2481 
2482     def update_datalim(self, xys, updatex=True, updatey=True):
2483         """
2484         Extend the `~.Axes.dataLim` Bbox to include the given points.
2485 
2486         If no data is set currently, the Bbox will ignore its limits and set
2487         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2488         compute the bounds of the union of its current data and the data in
2489         *xys*.
2490 
2491         Parameters
2492         ----------
2493         xys : 2D array-like
2494             The points to include in the data limits Bbox. This can be either
2495             a list of (x, y) tuples or a (N, 2) array.
2496 
2497         updatex, updatey : bool, default: True
2498             Whether to update the x/y limits.
2499         """
2500         xys = np.asarray(xys)
2501         if not np.any(np.isfinite(xys)):
2502             return
2503         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2504                                          updatex=updatex, updatey=updatey)
2505         self.ignore_existing_data_limits = False
2506 
2507     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2508         """
2509         Set axis units based on *datasets* and *kwargs*, and optionally apply
2510         unit conversions to *datasets*.
2511 
2512         Parameters
2513         ----------
2514         datasets : list
2515             List of (axis_name, dataset) pairs (where the axis name is defined
2516             as in `._axis_map`).  Individual datasets can also be None
2517             (which gets passed through).
2518         kwargs : dict
2519             Other parameters from which unit info (i.e., the *xunits*,
2520             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2521             polar) entries) is popped, if present.  Note that this dict is
2522             mutated in-place!
2523         convert : bool, default: True
2524             Whether to return the original datasets or the converted ones.
2525 
2526         Returns
2527         -------
2528         list
2529             Either the original datasets if *convert* is False, or the
2530             converted ones if *convert* is True (the default).
2531         """
2532         # The API makes datasets a list of pairs rather than an axis_name to
2533         # dataset mapping because it is sometimes necessary to process multiple
2534         # datasets for a single axis, and concatenating them may be tricky
2535         # (e.g. if some are scalars, etc.).
2536         datasets = datasets or []
2537         kwargs = kwargs or {}
2538         axis_map = self._axis_map
2539         for axis_name, data in datasets:
2540             try:
2541                 axis = axis_map[axis_name]
2542             except KeyError:
2543                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2544             # Update from data if axis is already set but no unit is set yet.
2545             if axis is not None and data is not None and not axis.have_units():
2546                 axis.update_units(data)
2547         for axis_name, axis in axis_map.items():
2548             # Return if no axis is set.
2549             if axis is None:
2550                 continue
2551             # Check for units in the kwargs, and if present update axis.
2552             units = kwargs.pop(f"{axis_name}units", axis.units)
2553             if self.name == "polar":
2554                 # Special case: polar supports "thetaunits"/"runits".
2555                 polar_units = {"x": "thetaunits", "y": "runits"}
2556                 units = kwargs.pop(polar_units[axis_name], units)
2557             if units != axis.units and units is not None:
2558                 axis.set_units(units)
2559                 # If the units being set imply a different converter,
2560                 # we need to update again.
2561                 for dataset_axis_name, data in datasets:
2562                     if dataset_axis_name == axis_name and data is not None:
2563                         axis.update_units(data)
2564         return [axis_map[axis_name].convert_units(data)
2565                 if convert and data is not None else data
2566                 for axis_name, data in datasets]
2567 
2568     def in_axes(self, mouseevent):
2569         """
2570         Return whether the given event (in display coords) is in the Axes.
2571         """
2572         return self.patch.contains(mouseevent)[0]
2573 
2574     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2575     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2576     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2577     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2578 
2579     def get_autoscale_on(self):
2580         """Return True if each axis is autoscaled, False otherwise."""
2581         return all(axis._get_autoscale_on()
2582                    for axis in self._axis_map.values())
2583 
2584     def set_autoscale_on(self, b):
2585         """
2586         Set whether autoscaling is applied to each axis on the next draw or
2587         call to `.Axes.autoscale_view`.
2588 
2589         Parameters
2590         ----------
2591         b : bool
2592         """
2593         for axis in self._axis_map.values():
2594             axis._set_autoscale_on(b)
2595 
2596     @property
2597     def use_sticky_edges(self):
2598         """
2599         When autoscaling, whether to obey all `Artist.sticky_edges`.
2600 
2601         Default is ``True``.
2602 
2603         Setting this to ``False`` ensures that the specified margins
2604         will be applied, even if the plot includes an image, for
2605         example, which would otherwise force a view limit to coincide
2606         with its data limit.
2607 
2608         The changing this property does not change the plot until
2609         `autoscale` or `autoscale_view` is called.
2610         """
2611         return self._use_sticky_edges
2612 
2613     @use_sticky_edges.setter
2614     def use_sticky_edges(self, b):
2615         self._use_sticky_edges = bool(b)
2616         # No effect until next autoscaling, which will mark the Axes as stale.
2617 
2618     def set_xmargin(self, m):
2619         """
2620         Set padding of X data limits prior to autoscaling.
2621 
2622         *m* times the data interval will be added to each end of that interval
2623         before it is used in autoscaling.  If *m* is negative, this will clip
2624         the data range instead of expanding it.
2625 
2626         For example, if your data is in the range [0, 2], a margin of 0.1 will
2627         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2628         of [0.2, 1.8].
2629 
2630         Parameters
2631         ----------
2632         m : float greater than -0.5
2633         """
2634         if m <= -0.5:
2635             raise ValueError("margin must be greater than -0.5")
2636         self._xmargin = m
2637         self._request_autoscale_view("x")
2638         self.stale = True
2639 
2640     def set_ymargin(self, m):
2641         """
2642         Set padding of Y data limits prior to autoscaling.
2643 
2644         *m* times the data interval will be added to each end of that interval
2645         before it is used in autoscaling.  If *m* is negative, this will clip
2646         the data range instead of expanding it.
2647 
2648         For example, if your data is in the range [0, 2], a margin of 0.1 will
2649         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2650         of [0.2, 1.8].
2651 
2652         Parameters
2653         ----------
2654         m : float greater than -0.5
2655         """
2656         if m <= -0.5:
2657             raise ValueError("margin must be greater than -0.5")
2658         self._ymargin = m
2659         self._request_autoscale_view("y")
2660         self.stale = True
2661 
2662     def margins(self, *margins, x=None, y=None, tight=True):
2663         """
2664         Set or retrieve autoscaling margins.
2665 
2666         The padding added to each limit of the Axes is the *margin*
2667         times the data interval. All input parameters must be floats
2668         within the range [0, 1]. Passing both positional and keyword
2669         arguments is invalid and will raise a TypeError. If no
2670         arguments (positional or otherwise) are provided, the current
2671         margins will remain in place and simply be returned.
2672 
2673         Specifying any margin changes only the autoscaling; for example,
2674         if *xmargin* is not None, then *xmargin* times the X data
2675         interval will be added to each end of that interval before
2676         it is used in autoscaling.
2677 
2678         Parameters
2679         ----------
2680         *margins : float, optional
2681             If a single positional argument is provided, it specifies
2682             both margins of the x-axis and y-axis limits. If two
2683             positional arguments are provided, they will be interpreted
2684             as *xmargin*, *ymargin*. If setting the margin on a single
2685             axis is desired, use the keyword arguments described below.
2686 
2687         x, y : float, optional
2688             Specific margin values for the x-axis and y-axis,
2689             respectively. These cannot be used with positional
2690             arguments, but can be used individually to alter on e.g.,
2691             only the y-axis.
2692 
2693         tight : bool or None, default: True
2694             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2695             which is executed after a margin is changed; the default
2696             here is *True*, on the assumption that when margins are
2697             specified, no additional padding to match tick marks is
2698             usually desired.  Setting *tight* to *None* preserves
2699             the previous setting.
2700 
2701         Returns
2702         -------
2703         xmargin, ymargin : float
2704 
2705         Notes
2706         -----
2707         If a previously used Axes method such as :meth:`pcolor` has set
2708         :attr:`use_sticky_edges` to `True`, only the limits not set by
2709         the "sticky artists" will be modified. To force all of the
2710         margins to be set, set :attr:`use_sticky_edges` to `False`
2711         before calling :meth:`margins`.
2712         """
2713 
2714         if margins and (x is not None or y is not None):
2715             raise TypeError('Cannot pass both positional and keyword '
2716                             'arguments for x and/or y.')
2717         elif len(margins) == 1:
2718             x = y = margins[0]
2719         elif len(margins) == 2:
2720             x, y = margins
2721         elif margins:
2722             raise TypeError('Must pass a single positional argument for all '
2723                             'margins, or one for each margin (x, y).')
2724 
2725         if x is None and y is None:
2726             if tight is not True:
2727                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2728             return self._xmargin, self._ymargin
2729 
2730         if tight is not None:
2731             self._tight = tight
2732         if x is not None:
2733             self.set_xmargin(x)
2734         if y is not None:
2735             self.set_ymargin(y)
2736 
2737     def set_rasterization_zorder(self, z):
2738         """
2739         Set the zorder threshold for rasterization for vector graphics output.
2740 
2741         All artists with a zorder below the given value will be rasterized if
2742         they support rasterization.
2743 
2744         This setting is ignored for pixel-based output.
2745 
2746         See also :doc:`/gallery/misc/rasterization_demo`.
2747 
2748         Parameters
2749         ----------
2750         z : float or None
2751             The zorder below which artists are rasterized.
2752             If ``None`` rasterization based on zorder is deactivated.
2753         """
2754         self._rasterization_zorder = z
2755         self.stale = True
2756 
2757     def get_rasterization_zorder(self):
2758         """Return the zorder value below which artists will be rasterized."""
2759         return self._rasterization_zorder
2760 
2761     def autoscale(self, enable=True, axis='both', tight=None):
2762         """
2763         Autoscale the axis view to the data (toggle).
2764 
2765         Convenience method for simple axis view autoscaling.
2766         It turns autoscaling on or off, and then,
2767         if autoscaling for either axis is on, it performs
2768         the autoscaling on the specified axis or Axes.
2769 
2770         Parameters
2771         ----------
2772         enable : bool or None, default: True
2773             True turns autoscaling on, False turns it off.
2774             None leaves the autoscaling state unchanged.
2775         axis : {'both', 'x', 'y'}, default: 'both'
2776             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2777             to 'z', and 'both' refers to all three axes.)
2778         tight : bool or None, default: None
2779             If True, first set the margins to zero.  Then, this argument is
2780             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2781             its value); see the description of its behavior there.
2782         """
2783         if enable is None:
2784             scalex = True
2785             scaley = True
2786         else:
2787             if axis in ['x', 'both']:
2788                 self.set_autoscalex_on(bool(enable))
2789                 scalex = self.get_autoscalex_on()
2790             else:
2791                 scalex = False
2792             if axis in ['y', 'both']:
2793                 self.set_autoscaley_on(bool(enable))
2794                 scaley = self.get_autoscaley_on()
2795             else:
2796                 scaley = False
2797         if tight and scalex:
2798             self._xmargin = 0
2799         if tight and scaley:
2800             self._ymargin = 0
2801         if scalex:
2802             self._request_autoscale_view("x", tight=tight)
2803         if scaley:
2804             self._request_autoscale_view("y", tight=tight)
2805 
2806     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2807         """
2808         Autoscale the view limits using the data limits.
2809 
2810         Parameters
2811         ----------
2812         tight : bool or None
2813             If *True*, only expand the axis limits using the margins.  Note
2814             that unlike for `autoscale`, ``tight=True`` does *not* set the
2815             margins to zero.
2816 
2817             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2818             after expansion by the margins, further expand the axis limits
2819             using the axis major locator.
2820 
2821             If None (the default), reuse the value set in the previous call to
2822             `autoscale_view` (the initial value is False, but the default style
2823             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2824             behaves like True).
2825 
2826         scalex : bool, default: True
2827             Whether to autoscale the x-axis.
2828 
2829         scaley : bool, default: True
2830             Whether to autoscale the y-axis.
2831 
2832         Notes
2833         -----
2834         The autoscaling preserves any preexisting axis direction reversal.
2835 
2836         The data limits are not updated automatically when artist data are
2837         changed after the artist has been added to an Axes instance.  In that
2838         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2839         autoscale_view.
2840 
2841         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2842         not be changed by autoscale_view().
2843         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2844         """
2845         if tight is not None:
2846             self._tight = bool(tight)
2847 
2848         x_stickies = y_stickies = np.array([])
2849         if self.use_sticky_edges:
2850             if self._xmargin and scalex and self.get_autoscalex_on():
2851                 x_stickies = np.sort(np.concatenate([
2852                     artist.sticky_edges.x
2853                     for ax in self._shared_axes["x"].get_siblings(self)
2854                     for artist in ax.get_children()]))
2855             if self._ymargin and scaley and self.get_autoscaley_on():
2856                 y_stickies = np.sort(np.concatenate([
2857                     artist.sticky_edges.y
2858                     for ax in self._shared_axes["y"].get_siblings(self)
2859                     for artist in ax.get_children()]))
2860         if self.get_xscale() == 'log':
2861             x_stickies = x_stickies[x_stickies > 0]
2862         if self.get_yscale() == 'log':
2863             y_stickies = y_stickies[y_stickies > 0]
2864 
2865         def handle_single_axis(
2866                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2867 
2868             if not (scale and axis._get_autoscale_on()):
2869                 return  # nothing to do...
2870 
2871             shared = shared_axes.get_siblings(self)
2872             # Base autoscaling on finite data limits when there is at least one
2873             # finite data limit among all the shared_axes and intervals.
2874             values = [val for ax in shared
2875                       for val in getattr(ax.dataLim, f"interval{name}")
2876                       if np.isfinite(val)]
2877             if values:
2878                 x0, x1 = (min(values), max(values))
2879             elif getattr(self._viewLim, f"mutated{name}")():
2880                 # No data, but explicit viewLims already set:
2881                 # in mutatedx or mutatedy.
2882                 return
2883             else:
2884                 x0, x1 = (-np.inf, np.inf)
2885             # If x0 and x1 are nonfinite, get default limits from the locator.
2886             locator = axis.get_major_locator()
2887             x0, x1 = locator.nonsingular(x0, x1)
2888             # Find the minimum minpos for use in the margin calculation.
2889             minimum_minpos = min(
2890                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2891 
2892             # Prevent margin addition from crossing a sticky value.  A small
2893             # tolerance must be added due to floating point issues with
2894             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2895             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2896             # datasets where all values are tiny (less than 1e-8).
2897             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2898             # Index of largest element < x0 + tol, if any.
2899             i0 = stickies.searchsorted(x0 + tol) - 1
2900             x0bound = stickies[i0] if i0 != -1 else None
2901             # Index of smallest element > x1 - tol, if any.
2902             i1 = stickies.searchsorted(x1 - tol)
2903             x1bound = stickies[i1] if i1 != len(stickies) else None
2904 
2905             # Add the margin in figure space and then transform back, to handle
2906             # non-linear scales.
2907             transform = axis.get_transform()
2908             inverse_trans = transform.inverted()
2909             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2910             x0t, x1t = transform.transform([x0, x1])
2911             delta = (x1t - x0t) * margin
2912             if not np.isfinite(delta):
2913                 delta = 0  # If a bound isn't finite, set margin to zero.
2914             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2915 
2916             # Apply sticky bounds.
2917             if x0bound is not None:
2918                 x0 = max(x0, x0bound)
2919             if x1bound is not None:
2920                 x1 = min(x1, x1bound)
2921 
2922             if not self._tight:
2923                 x0, x1 = locator.view_limits(x0, x1)
2924             set_bound(x0, x1)
2925             # End of definition of internal function 'handle_single_axis'.
2926 
2927         handle_single_axis(
2928             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2929             x_stickies, self.set_xbound)
2930         handle_single_axis(
2931             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2932             y_stickies, self.set_ybound)
2933 
2934     def _update_title_position(self, renderer):
2935         """
2936         Update the title position based on the bounding box enclosing
2937         all the ticklabels and x-axis spine and xlabel...
2938         """
2939         if self._autotitlepos is not None and not self._autotitlepos:
2940             _log.debug('title position was updated manually, not adjusting')
2941             return
2942 
2943         titles = (self.title, self._left_title, self._right_title)
2944 
2945         # Need to check all our twins too, and all the children as well.
2946         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2947         for ax in self.child_axes:  # Child positions must be updated first.
2948             locator = ax.get_axes_locator()
2949             ax.apply_aspect(locator(self, renderer) if locator else None)
2950 
2951         for title in titles:
2952             x, _ = title.get_position()
2953             # need to start again in case of window resizing
2954             title.set_position((x, 1.0))
2955             top = -np.inf
2956             for ax in axs:
2957                 bb = None
2958                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2959                         or ax.xaxis.get_label_position() == 'top'):
2960                     bb = ax.xaxis.get_tightbbox(renderer)
2961                 if bb is None:
2962                     if 'outline' in ax.spines:
2963                         # Special case for colorbars:
2964                         bb = ax.spines['outline'].get_window_extent()
2965                     else:
2966                         bb = ax.get_window_extent(renderer)
2967                 top = max(top, bb.ymax)
2968                 if title.get_text():
2969                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2970                     if ax.yaxis.offsetText.get_text():
2971                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2972                         if bb.intersection(title.get_tightbbox(renderer), bb):
2973                             top = bb.ymax
2974             if top < 0:
2975                 # the top of Axes is not even on the figure, so don't try and
2976                 # automatically place it.
2977                 _log.debug('top of Axes not in the figure, so title not moved')
2978                 return
2979             if title.get_window_extent(renderer).ymin < top:
2980                 _, y = self.transAxes.inverted().transform((0, top))
2981                 title.set_position((x, y))
2982                 # empirically, this doesn't always get the min to top,
2983                 # so we need to adjust again.
2984                 if title.get_window_extent(renderer).ymin < top:
2985                     _, y = self.transAxes.inverted().transform(
2986                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2987                     title.set_position((x, y))
2988 
2989         ymax = max(title.get_position()[1] for title in titles)
2990         for title in titles:
2991             # now line up all the titles at the highest baseline.
2992             x, _ = title.get_position()
2993             title.set_position((x, ymax))
2994 
2995     # Drawing
2996     @martist.allow_rasterization
2997     def draw(self, renderer):
2998         # docstring inherited
2999         if renderer is None:
3000             raise RuntimeError('No renderer defined')
3001         if not self.get_visible():
3002             return
3003         self._unstale_viewLim()
3004 
3005         renderer.open_group('axes', gid=self.get_gid())
3006 
3007         # prevent triggering call backs during the draw process
3008         self._stale = True
3009 
3010         # loop over self and child Axes...
3011         locator = self.get_axes_locator()
3012         self.apply_aspect(locator(self, renderer) if locator else None)
3013 
3014         artists = self.get_children()
3015         artists.remove(self.patch)
3016 
3017         # the frame draws the edges around the Axes patch -- we
3018         # decouple these so the patch can be in the background and the
3019         # frame in the foreground. Do this before drawing the axis
3020         # objects so that the spine has the opportunity to update them.
3021         if not (self.axison and self._frameon):
3022             for spine in self.spines.values():
3023                 artists.remove(spine)
3024 
3025         self._update_title_position(renderer)
3026 
3027         if not self.axison:
3028             for _axis in self._axis_map.values():
3029                 artists.remove(_axis)
3030 
3031         if not self.figure.canvas.is_saving():
3032             artists = [
3033                 a for a in artists
3034                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3035         artists = sorted(artists, key=attrgetter('zorder'))
3036 
3037         # rasterize artists with negative zorder
3038         # if the minimum zorder is negative, start rasterization
3039         rasterization_zorder = self._rasterization_zorder
3040 
3041         if (rasterization_zorder is not None and
3042                 artists and artists[0].zorder < rasterization_zorder):
3043             split_index = np.searchsorted(
3044                 [art.zorder for art in artists],
3045                 rasterization_zorder, side='right'
3046             )
3047             artists_rasterized = artists[:split_index]
3048             artists = artists[split_index:]
3049         else:
3050             artists_rasterized = []
3051 
3052         if self.axison and self._frameon:
3053             if artists_rasterized:
3054                 artists_rasterized = [self.patch] + artists_rasterized
3055             else:
3056                 artists = [self.patch] + artists
3057 
3058         if artists_rasterized:
3059             _draw_rasterized(self.figure, artists_rasterized, renderer)
3060 
3061         mimage._draw_list_compositing_images(
3062             renderer, self, artists, self.figure.suppressComposite)
3063 
3064         renderer.close_group('axes')
3065         self.stale = False
3066 
3067     def draw_artist(self, a):
3068         """
3069         Efficiently redraw a single artist.
3070         """
3071         a.draw(self.figure.canvas.get_renderer())
3072 
3073     def redraw_in_frame(self):
3074         """
3075         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3076         """
3077         with ExitStack() as stack:
3078             for artist in [*self._axis_map.values(),
3079                            self.title, self._left_title, self._right_title]:
3080                 stack.enter_context(artist._cm_set(visible=False))
3081             self.draw(self.figure.canvas.get_renderer())
3082 
3083     # Axes rectangle characteristics
3084 
3085     def get_frame_on(self):
3086         """Get whether the Axes rectangle patch is drawn."""
3087         return self._frameon
3088 
3089     def set_frame_on(self, b):
3090         """
3091         Set whether the Axes rectangle patch is drawn.
3092 
3093         Parameters
3094         ----------
3095         b : bool
3096         """
3097         self._frameon = b
3098         self.stale = True
3099 
3100     def get_axisbelow(self):
3101         """
3102         Get whether axis ticks and gridlines are above or below most artists.
3103 
3104         Returns
3105         -------
3106         bool or 'line'
3107 
3108         See Also
3109         --------
3110         set_axisbelow
3111         """
3112         return self._axisbelow
3113 
3114     def set_axisbelow(self, b):
3115         """
3116         Set whether axis ticks and gridlines are above or below most artists.
3117 
3118         This controls the zorder of the ticks and gridlines. For more
3119         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3120 
3121         Parameters
3122         ----------
3123         b : bool or 'line'
3124             Possible values:
3125 
3126             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3127             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3128               (e.g. rectangles, with default zorder = 1) but still below lines
3129               and markers (with their default zorder = 2).
3130             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3131               and lines / markers.
3132 
3133         See Also
3134         --------
3135         get_axisbelow
3136         """
3137         # Check that b is True, False or 'line'
3138         self._axisbelow = axisbelow = validate_axisbelow(b)
3139         zorder = {
3140             True: 0.5,
3141             'line': 1.5,
3142             False: 2.5,
3143         }[axisbelow]
3144         for axis in self._axis_map.values():
3145             axis.set_zorder(zorder)
3146         self.stale = True
3147 
3148     @_docstring.dedent_interpd
3149     def grid(self, visible=None, which='major', axis='both', **kwargs):
3150         """
3151         Configure the grid lines.
3152 
3153         Parameters
3154         ----------
3155         visible : bool or None, optional
3156             Whether to show the grid lines.  If any *kwargs* are supplied, it
3157             is assumed you want the grid on and *visible* will be set to True.
3158 
3159             If *visible* is *None* and there are no *kwargs*, this toggles the
3160             visibility of the lines.
3161 
3162         which : {'major', 'minor', 'both'}, optional
3163             The grid lines to apply the changes on.
3164 
3165         axis : {'both', 'x', 'y'}, optional
3166             The axis to apply the changes on.
3167 
3168         **kwargs : `.Line2D` properties
3169             Define the line properties of the grid, e.g.::
3170 
3171                 grid(color='r', linestyle='-', linewidth=2)
3172 
3173             Valid keyword arguments are:
3174 
3175             %(Line2D:kwdoc)s
3176 
3177         Notes
3178         -----
3179         The axis is drawn as a unit, so the effective zorder for drawing the
3180         grid is determined by the zorder of each axis, not by the zorder of the
3181         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3182         use `.set_axisbelow` or, for more control, call the
3183         `~.Artist.set_zorder` method of each axis.
3184         """
3185         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3186         if axis in ['x', 'both']:
3187             self.xaxis.grid(visible, which=which, **kwargs)
3188         if axis in ['y', 'both']:
3189             self.yaxis.grid(visible, which=which, **kwargs)
3190 
3191     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3192                          useOffset=None, useLocale=None, useMathText=None):
3193         r"""
3194         Configure the `.ScalarFormatter` used by default for linear Axes.
3195 
3196         If a parameter is not set, the corresponding property of the formatter
3197         is left unchanged.
3198 
3199         Parameters
3200         ----------
3201         axis : {'x', 'y', 'both'}, default: 'both'
3202             The axis to configure.  Only major ticks are affected.
3203 
3204         style : {'sci', 'scientific', 'plain'}
3205             Whether to use scientific notation.
3206             The formatter default is to use scientific notation.
3207 
3208         scilimits : pair of ints (m, n)
3209             Scientific notation is used only for numbers outside the range
3210             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3211             configured to use scientific notation at all).  Use (0, 0) to
3212             include all numbers.  Use (m, m) where m != 0 to fix the order of
3213             magnitude to 10\ :sup:`m`.
3214             The formatter default is :rc:`axes.formatter.limits`.
3215 
3216         useOffset : bool or float
3217             If True, the offset is calculated as needed.
3218             If False, no offset is used.
3219             If a numeric value, it sets the offset.
3220             The formatter default is :rc:`axes.formatter.useoffset`.
3221 
3222         useLocale : bool
3223             Whether to format the number using the current locale or using the
3224             C (English) locale.  This affects e.g. the decimal separator.  The
3225             formatter default is :rc:`axes.formatter.use_locale`.
3226 
3227         useMathText : bool
3228             Render the offset and scientific notation in mathtext.
3229             The formatter default is :rc:`axes.formatter.use_mathtext`.
3230 
3231         Raises
3232         ------
3233         AttributeError
3234             If the current formatter is not a `.ScalarFormatter`.
3235         """
3236         style = style.lower()
3237         axis = axis.lower()
3238         if scilimits is not None:
3239             try:
3240                 m, n = scilimits
3241                 m + n + 1  # check that both are numbers
3242             except (ValueError, TypeError) as err:
3243                 raise ValueError("scilimits must be a sequence of 2 integers"
3244                                  ) from err
3245         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3246         is_sci_style = _api.check_getitem(STYLES, style=style)
3247         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3248                     'both': list(self._axis_map.values())}
3249         axises = _api.check_getitem(axis_map, axis=axis)
3250         try:
3251             for axis in axises:
3252                 if is_sci_style is not None:
3253                     axis.major.formatter.set_scientific(is_sci_style)
3254                 if scilimits is not None:
3255                     axis.major.formatter.set_powerlimits(scilimits)
3256                 if useOffset is not None:
3257                     axis.major.formatter.set_useOffset(useOffset)
3258                 if useLocale is not None:
3259                     axis.major.formatter.set_useLocale(useLocale)
3260                 if useMathText is not None:
3261                     axis.major.formatter.set_useMathText(useMathText)
3262         except AttributeError as err:
3263             raise AttributeError(
3264                 "This method only works with the ScalarFormatter") from err
3265 
3266     def locator_params(self, axis='both', tight=None, **kwargs):
3267         """
3268         Control behavior of major tick locators.
3269 
3270         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3271         is called automatically after the parameters are changed.
3272 
3273         Parameters
3274         ----------
3275         axis : {'both', 'x', 'y'}, default: 'both'
3276             The axis on which to operate.  (For 3D Axes, *axis* can also be
3277             set to 'z', and 'both' refers to all three axes.)
3278         tight : bool or None, optional
3279             Parameter passed to `~.Axes.autoscale_view`.
3280             Default is None, for no change.
3281 
3282         Other Parameters
3283         ----------------
3284         **kwargs
3285             Remaining keyword arguments are passed to directly to the
3286             ``set_params()`` method of the locator. Supported keywords depend
3287             on the type of the locator. See for example
3288             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3289             used by default for linear.
3290 
3291         Examples
3292         --------
3293         When plotting small subplots, one might want to reduce the maximum
3294         number of ticks and use tight bounds, for example::
3295 
3296             ax.locator_params(tight=True, nbins=4)
3297 
3298         """
3299         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3300         for name in self._axis_names:
3301             if axis in [name, "both"]:
3302                 loc = self._axis_map[name].get_major_locator()
3303                 loc.set_params(**kwargs)
3304                 self._request_autoscale_view(name, tight=tight)
3305         self.stale = True
3306 
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)
3386 
3387     def set_axis_off(self):
3388         """
3389         Turn the x- and y-axis off.
3390 
3391         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3392         """
3393         self.axison = False
3394         self.stale = True
3395 
3396     def set_axis_on(self):
3397         """
3398         Turn the x- and y-axis on.
3399 
3400         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3401         """
3402         self.axison = True
3403         self.stale = True
3404 
3405     # data limits, ticks, tick labels, and formatting
3406 
3407     def get_xlabel(self):
3408         """
3409         Get the xlabel text string.
3410         """
3411         label = self.xaxis.get_label()
3412         return label.get_text()
3413 
3414     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3415                    loc=None, **kwargs):
3416         """
3417         Set the label for the x-axis.
3418 
3419         Parameters
3420         ----------
3421         xlabel : str
3422             The label text.
3423 
3424         labelpad : float, default: :rc:`axes.labelpad`
3425             Spacing in points from the Axes bounding box including ticks
3426             and tick labels.  If None, the previous value is left as is.
3427 
3428         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3429             The label position. This is a high-level alternative for passing
3430             parameters *x* and *horizontalalignment*.
3431 
3432         Other Parameters
3433         ----------------
3434         **kwargs : `.Text` properties
3435             `.Text` properties control the appearance of the label.
3436 
3437         See Also
3438         --------
3439         text : Documents the properties supported by `.Text`.
3440         """
3441         if labelpad is not None:
3442             self.xaxis.labelpad = labelpad
3443         protected_kw = ['x', 'horizontalalignment', 'ha']
3444         if {*kwargs} & {*protected_kw}:
3445             if loc is not None:
3446                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3447                                 f"its corresponding low level keyword "
3448                                 f"arguments ({protected_kw}) are also "
3449                                 f"supplied")
3450 
3451         else:
3452             loc = (loc if loc is not None
3453                    else mpl.rcParams['xaxis.labellocation'])
3454             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3455 
3456             x = {
3457                 'left': 0,
3458                 'center': 0.5,
3459                 'right': 1,
3460             }[loc]
3461             kwargs.update(x=x, horizontalalignment=loc)
3462 
3463         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3464 
3465     def invert_xaxis(self):
3466         """
3467         Invert the x-axis.
3468 
3469         See Also
3470         --------
3471         xaxis_inverted
3472         get_xlim, set_xlim
3473         get_xbound, set_xbound
3474         """
3475         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3476 
3477     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3478 
3479     def get_xbound(self):
3480         """
3481         Return the lower and upper x-axis bounds, in increasing order.
3482 
3483         See Also
3484         --------
3485         set_xbound
3486         get_xlim, set_xlim
3487         invert_xaxis, xaxis_inverted
3488         """
3489         left, right = self.get_xlim()
3490         if left < right:
3491             return left, right
3492         else:
3493             return right, left
3494 
3495     def set_xbound(self, lower=None, upper=None):
3496         """
3497         Set the lower and upper numerical bounds of the x-axis.
3498 
3499         This method will honor axis inversion regardless of parameter order.
3500         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3501 
3502         Parameters
3503         ----------
3504         lower, upper : float or None
3505             The lower and upper bounds. If *None*, the respective axis bound
3506             is not modified.
3507 
3508         See Also
3509         --------
3510         get_xbound
3511         get_xlim, set_xlim
3512         invert_xaxis, xaxis_inverted
3513         """
3514         if upper is None and np.iterable(lower):
3515             lower, upper = lower
3516 
3517         old_lower, old_upper = self.get_xbound()
3518         if lower is None:
3519             lower = old_lower
3520         if upper is None:
3521             upper = old_upper
3522 
3523         self.set_xlim(sorted((lower, upper),
3524                              reverse=bool(self.xaxis_inverted())),
3525                       auto=None)
3526 
3527     def get_xlim(self):
3528         """
3529         Return the x-axis view limits.
3530 
3531         Returns
3532         -------
3533         left, right : (float, float)
3534             The current x-axis limits in data coordinates.
3535 
3536         See Also
3537         --------
3538         .Axes.set_xlim
3539         set_xbound, get_xbound
3540         invert_xaxis, xaxis_inverted
3541 
3542         Notes
3543         -----
3544         The x-axis may be inverted, in which case the *left* value will
3545         be greater than the *right* value.
3546         """
3547         return tuple(self.viewLim.intervalx)
3548 
3549     def _validate_converted_limits(self, limit, convert):
3550         """
3551         Raise ValueError if converted limits are non-finite.
3552 
3553         Note that this function also accepts None as a limit argument.
3554 
3555         Returns
3556         -------
3557         The limit value after call to convert(), or None if limit is None.
3558         """
3559         if limit is not None:
3560             converted_limit = convert(limit)
3561             if (isinstance(converted_limit, Real)
3562                     and not np.isfinite(converted_limit)):
3563                 raise ValueError("Axis limits cannot be NaN or Inf")
3564             return converted_limit
3565 
3566     def set_xlim(self, left=None, right=None, *, emit=True, auto=False,
3567                  xmin=None, xmax=None):
3568         """
3569         Set the x-axis view limits.
3570 
3571         Parameters
3572         ----------
3573         left : float, optional
3574             The left xlim in data coordinates. Passing *None* leaves the
3575             limit unchanged.
3576 
3577             The left and right xlims may also be passed as the tuple
3578             (*left*, *right*) as the first positional argument (or as
3579             the *left* keyword argument).
3580 
3581             .. ACCEPTS: (bottom: float, top: float)
3582 
3583         right : float, optional
3584             The right xlim in data coordinates. Passing *None* leaves the
3585             limit unchanged.
3586 
3587         emit : bool, default: True
3588             Whether to notify observers of limit change.
3589 
3590         auto : bool or None, default: False
3591             Whether to turn on autoscaling of the x-axis. True turns on,
3592             False turns off, None leaves unchanged.
3593 
3594         xmin, xmax : float, optional
3595             They are equivalent to left and right respectively, and it is an
3596             error to pass both *xmin* and *left* or *xmax* and *right*.
3597 
3598         Returns
3599         -------
3600         left, right : (float, float)
3601             The new x-axis limits in data coordinates.
3602 
3603         See Also
3604         --------
3605         get_xlim
3606         set_xbound, get_xbound
3607         invert_xaxis, xaxis_inverted
3608 
3609         Notes
3610         -----
3611         The *left* value may be greater than the *right* value, in which
3612         case the x-axis values will decrease from left to right.
3613 
3614         Examples
3615         --------
3616         >>> set_xlim(left, right)
3617         >>> set_xlim((left, right))
3618         >>> left, right = set_xlim(left, right)
3619 
3620         One limit may be left unchanged.
3621 
3622         >>> set_xlim(right=right_lim)
3623 
3624         Limits may be passed in reverse order to flip the direction of
3625         the x-axis. For example, suppose *x* represents the number of
3626         years before present. The x-axis limits might be set like the
3627         following so 5000 years ago is on the left of the plot and the
3628         present is on the right.
3629 
3630         >>> set_xlim(5000, 0)
3631         """
3632         if right is None and np.iterable(left):
3633             left, right = left
3634         if xmin is not None:
3635             if left is not None:
3636                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3637             left = xmin
3638         if xmax is not None:
3639             if right is not None:
3640                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3641             right = xmax
3642         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3643 
3644     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3645     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3646     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3647     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3648     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3649     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3650     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3651     set_xticklabels = _axis_method_wrapper(
3652         "xaxis", "set_ticklabels",
3653         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3654 
3655     def get_ylabel(self):
3656         """
3657         Get the ylabel text string.
3658         """
3659         label = self.yaxis.get_label()
3660         return label.get_text()
3661 
3662     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3663                    loc=None, **kwargs):
3664         """
3665         Set the label for the y-axis.
3666 
3667         Parameters
3668         ----------
3669         ylabel : str
3670             The label text.
3671 
3672         labelpad : float, default: :rc:`axes.labelpad`
3673             Spacing in points from the Axes bounding box including ticks
3674             and tick labels.  If None, the previous value is left as is.
3675 
3676         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3677             The label position. This is a high-level alternative for passing
3678             parameters *y* and *horizontalalignment*.
3679 
3680         Other Parameters
3681         ----------------
3682         **kwargs : `.Text` properties
3683             `.Text` properties control the appearance of the label.
3684 
3685         See Also
3686         --------
3687         text : Documents the properties supported by `.Text`.
3688         """
3689         if labelpad is not None:
3690             self.yaxis.labelpad = labelpad
3691         protected_kw = ['y', 'horizontalalignment', 'ha']
3692         if {*kwargs} & {*protected_kw}:
3693             if loc is not None:
3694                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3695                                 f"its corresponding low level keyword "
3696                                 f"arguments ({protected_kw}) are also "
3697                                 f"supplied")
3698 
3699         else:
3700             loc = (loc if loc is not None
3701                    else mpl.rcParams['yaxis.labellocation'])
3702             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3703 
3704             y, ha = {
3705                 'bottom': (0, 'left'),
3706                 'center': (0.5, 'center'),
3707                 'top': (1, 'right')
3708             }[loc]
3709             kwargs.update(y=y, horizontalalignment=ha)
3710 
3711         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3712 
3713     def invert_yaxis(self):
3714         """
3715         Invert the y-axis.
3716 
3717         See Also
3718         --------
3719         yaxis_inverted
3720         get_ylim, set_ylim
3721         get_ybound, set_ybound
3722         """
3723         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3724 
3725     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3726 
3727     def get_ybound(self):
3728         """
3729         Return the lower and upper y-axis bounds, in increasing order.
3730 
3731         See Also
3732         --------
3733         set_ybound
3734         get_ylim, set_ylim
3735         invert_yaxis, yaxis_inverted
3736         """
3737         bottom, top = self.get_ylim()
3738         if bottom < top:
3739             return bottom, top
3740         else:
3741             return top, bottom
3742 
3743     def set_ybound(self, lower=None, upper=None):
3744         """
3745         Set the lower and upper numerical bounds of the y-axis.
3746 
3747         This method will honor axis inversion regardless of parameter order.
3748         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3749 
3750         Parameters
3751         ----------
3752         lower, upper : float or None
3753             The lower and upper bounds. If *None*, the respective axis bound
3754             is not modified.
3755 
3756         See Also
3757         --------
3758         get_ybound
3759         get_ylim, set_ylim
3760         invert_yaxis, yaxis_inverted
3761         """
3762         if upper is None and np.iterable(lower):
3763             lower, upper = lower
3764 
3765         old_lower, old_upper = self.get_ybound()
3766         if lower is None:
3767             lower = old_lower
3768         if upper is None:
3769             upper = old_upper
3770 
3771         self.set_ylim(sorted((lower, upper),
3772                              reverse=bool(self.yaxis_inverted())),
3773                       auto=None)
3774 
3775     def get_ylim(self):
3776         """
3777         Return the y-axis view limits.
3778 
3779         Returns
3780         -------
3781         bottom, top : (float, float)
3782             The current y-axis limits in data coordinates.
3783 
3784         See Also
3785         --------
3786         .Axes.set_ylim
3787         set_ybound, get_ybound
3788         invert_yaxis, yaxis_inverted
3789 
3790         Notes
3791         -----
3792         The y-axis may be inverted, in which case the *bottom* value
3793         will be greater than the *top* value.
3794         """
3795         return tuple(self.viewLim.intervaly)
3796 
3797     def set_ylim(self, bottom=None, top=None, *, emit=True, auto=False,
3798                  ymin=None, ymax=None):
3799         """
3800         Set the y-axis view limits.
3801 
3802         Parameters
3803         ----------
3804         bottom : float, optional
3805             The bottom ylim in data coordinates. Passing *None* leaves the
3806             limit unchanged.
3807 
3808             The bottom and top ylims may also be passed as the tuple
3809             (*bottom*, *top*) as the first positional argument (or as
3810             the *bottom* keyword argument).
3811 
3812             .. ACCEPTS: (bottom: float, top: float)
3813 
3814         top : float, optional
3815             The top ylim in data coordinates. Passing *None* leaves the
3816             limit unchanged.
3817 
3818         emit : bool, default: True
3819             Whether to notify observers of limit change.
3820 
3821         auto : bool or None, default: False
3822             Whether to turn on autoscaling of the y-axis. *True* turns on,
3823             *False* turns off, *None* leaves unchanged.
3824 
3825         ymin, ymax : float, optional
3826             They are equivalent to bottom and top respectively, and it is an
3827             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3828 
3829         Returns
3830         -------
3831         bottom, top : (float, float)
3832             The new y-axis limits in data coordinates.
3833 
3834         See Also
3835         --------
3836         get_ylim
3837         set_ybound, get_ybound
3838         invert_yaxis, yaxis_inverted
3839 
3840         Notes
3841         -----
3842         The *bottom* value may be greater than the *top* value, in which
3843         case the y-axis values will decrease from *bottom* to *top*.
3844 
3845         Examples
3846         --------
3847         >>> set_ylim(bottom, top)
3848         >>> set_ylim((bottom, top))
3849         >>> bottom, top = set_ylim(bottom, top)
3850 
3851         One limit may be left unchanged.
3852 
3853         >>> set_ylim(top=top_lim)
3854 
3855         Limits may be passed in reverse order to flip the direction of
3856         the y-axis. For example, suppose ``y`` represents depth of the
3857         ocean in m. The y-axis limits might be set like the following
3858         so 5000 m depth is at the bottom of the plot and the surface,
3859         0 m, is at the top.
3860 
3861         >>> set_ylim(5000, 0)
3862         """
3863         if top is None and np.iterable(bottom):
3864             bottom, top = bottom
3865         if ymin is not None:
3866             if bottom is not None:
3867                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3868             bottom = ymin
3869         if ymax is not None:
3870             if top is not None:
3871                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3872             top = ymax
3873         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3874 
3875     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3876     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3877     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3878     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3879     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3880     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3881     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3882     set_yticklabels = _axis_method_wrapper(
3883         "yaxis", "set_ticklabels",
3884         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3885 
3886     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3887     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3888 
3889     def format_xdata(self, x):
3890         """
3891         Return *x* formatted as an x-value.
3892 
3893         This function will use the `.fmt_xdata` attribute if it is not None,
3894         else will fall back on the xaxis major formatter.
3895         """
3896         return (self.fmt_xdata if self.fmt_xdata is not None
3897                 else self.xaxis.get_major_formatter().format_data_short)(x)
3898 
3899     def format_ydata(self, y):
3900         """
3901         Return *y* formatted as a y-value.
3902 
3903         This function will use the `.fmt_ydata` attribute if it is not None,
3904         else will fall back on the yaxis major formatter.
3905         """
3906         return (self.fmt_ydata if self.fmt_ydata is not None
3907                 else self.yaxis.get_major_formatter().format_data_short)(y)
3908 
3909     def format_coord(self, x, y):
3910         """Return a format string formatting the *x*, *y* coordinates."""
3911         return "x={} y={}".format(
3912             "???" if x is None else self.format_xdata(x),
3913             "???" if y is None else self.format_ydata(y),
3914         )
3915 
3916     def minorticks_on(self):
3917         """
3918         Display minor ticks on the Axes.
3919 
3920         Displaying minor ticks may reduce performance; you may turn them off
3921         using `minorticks_off()` if drawing speed is a problem.
3922         """
3923         for ax in (self.xaxis, self.yaxis):
3924             scale = ax.get_scale()
3925             if scale == 'log':
3926                 s = ax._scale
3927                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3928             elif scale == 'symlog':
3929                 s = ax._scale
3930                 ax.set_minor_locator(
3931                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3932             else:
3933                 ax.set_minor_locator(mticker.AutoMinorLocator())
3934 
3935     def minorticks_off(self):
3936         """Remove minor ticks from the Axes."""
3937         self.xaxis.set_minor_locator(mticker.NullLocator())
3938         self.yaxis.set_minor_locator(mticker.NullLocator())
3939 
3940     # Interactive manipulation
3941 
3942     def can_zoom(self):
3943         """
3944         Return whether this Axes supports the zoom box button functionality.
3945         """
3946         return True
3947 
3948     def can_pan(self):
3949         """
3950         Return whether this Axes supports any pan/zoom button functionality.
3951         """
3952         return True
3953 
3954     def get_navigate(self):
3955         """
3956         Get whether the Axes responds to navigation commands.
3957         """
3958         return self._navigate
3959 
3960     def set_navigate(self, b):
3961         """
3962         Set whether the Axes responds to navigation toolbar commands.
3963 
3964         Parameters
3965         ----------
3966         b : bool
3967         """
3968         self._navigate = b
3969 
3970     def get_navigate_mode(self):
3971         """
3972         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3973         """
3974         return self._navigate_mode
3975 
3976     def set_navigate_mode(self, b):
3977         """
3978         Set the navigation toolbar button status.
3979 
3980         .. warning::
3981             This is not a user-API function.
3982 
3983         """
3984         self._navigate_mode = b
3985 
3986     def _get_view(self):
3987         """
3988         Save information required to reproduce the current view.
3989 
3990         This method is called before a view is changed, such as during a pan or zoom
3991         initiated by the user.  It returns an opaque object that describes the current
3992         view, in a format compatible with :meth:`_set_view`.
3993 
3994         The default implementation saves the view limits and autoscaling state.
3995         Subclasses may override this as needed, as long as :meth:`_set_view` is also
3996         adjusted accordingly.
3997         """
3998         return {
3999             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
4000             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
4001         }
4002 
4003     def _set_view(self, view):
4004         """
4005         Apply a previously saved view.
4006 
4007         This method is called when restoring a view (with the return value of
4008         :meth:`_get_view` as argument), such as with the navigation buttons.
4009 
4010         Subclasses that override :meth:`_get_view` also need to override this method
4011         accordingly.
4012         """
4013         self.set(**view)
4014 
4015     def _prepare_view_from_bbox(self, bbox, direction='in',
4016                                 mode=None, twinx=False, twiny=False):
4017         """
4018         Helper function to prepare the new bounds from a bbox.
4019 
4020         This helper function returns the new x and y bounds from the zoom
4021         bbox. This a convenience method to abstract the bbox logic
4022         out of the base setter.
4023         """
4024         if len(bbox) == 3:
4025             xp, yp, scl = bbox  # Zooming code
4026             if scl == 0:  # Should not happen
4027                 scl = 1.
4028             if scl > 1:
4029                 direction = 'in'
4030             else:
4031                 direction = 'out'
4032                 scl = 1/scl
4033             # get the limits of the axes
4034             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4035                 np.transpose([self.get_xlim(), self.get_ylim()]))
4036             # set the range
4037             xwidth = xmax - xmin
4038             ywidth = ymax - ymin
4039             xcen = (xmax + xmin)*.5
4040             ycen = (ymax + ymin)*.5
4041             xzc = (xp*(scl - 1) + xcen)/scl
4042             yzc = (yp*(scl - 1) + ycen)/scl
4043             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4044                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4045         elif len(bbox) != 4:
4046             # should be len 3 or 4 but nothing else
4047             _api.warn_external(
4048                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4049                 "of length 3 or 4. Ignoring the view change.")
4050             return
4051 
4052         # Original limits.
4053         xmin0, xmax0 = self.get_xbound()
4054         ymin0, ymax0 = self.get_ybound()
4055         # The zoom box in screen coords.
4056         startx, starty, stopx, stopy = bbox
4057         # Convert to data coords.
4058         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4059             [(startx, starty), (stopx, stopy)])
4060         # Clip to axes limits.
4061         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4062         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4063         # Don't double-zoom twinned axes or if zooming only the other axis.
4064         if twinx or mode == "y":
4065             xmin, xmax = xmin0, xmax0
4066         if twiny or mode == "x":
4067             ymin, ymax = ymin0, ymax0
4068 
4069         if direction == "in":
4070             new_xbound = xmin, xmax
4071             new_ybound = ymin, ymax
4072 
4073         elif direction == "out":
4074             x_trf = self.xaxis.get_transform()
4075             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4076                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4077             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4078             # Move original bounds away by
4079             # (factor) x (distance between unzoom box and Axes bbox).
4080             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4081             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4082             # And back to data space.
4083             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4084 
4085             y_trf = self.yaxis.get_transform()
4086             symin0, symax0, symin, symax = y_trf.transform(
4087                 [ymin0, ymax0, ymin, ymax])
4088             factor = (symax0 - symin0) / (symax - symin)
4089             symin1 = symin0 - factor * (symin - symin0)
4090             symax1 = symax0 + factor * (symax0 - symax)
4091             new_ybound = y_trf.inverted().transform([symin1, symax1])
4092 
4093         return new_xbound, new_ybound
4094 
4095     def _set_view_from_bbox(self, bbox, direction='in',
4096                             mode=None, twinx=False, twiny=False):
4097         """
4098         Update view from a selection bbox.
4099 
4100         .. note::
4101 
4102             Intended to be overridden by new projection types, but if not, the
4103             default implementation sets the view limits to the bbox directly.
4104 
4105         Parameters
4106         ----------
4107         bbox : 4-tuple or 3 tuple
4108             * If bbox is a 4 tuple, it is the selected bounding box limits,
4109               in *display* coordinates.
4110             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4111               (xp, yp) is the center of zooming and scl the scale factor to
4112               zoom by.
4113 
4114         direction : str
4115             The direction to apply the bounding box.
4116                 * `'in'` - The bounding box describes the view directly, i.e.,
4117                            it zooms in.
4118                 * `'out'` - The bounding box describes the size to make the
4119                             existing view, i.e., it zooms out.
4120 
4121         mode : str or None
4122             The selection mode, whether to apply the bounding box in only the
4123             `'x'` direction, `'y'` direction or both (`None`).
4124 
4125         twinx : bool
4126             Whether this axis is twinned in the *x*-direction.
4127 
4128         twiny : bool
4129             Whether this axis is twinned in the *y*-direction.
4130         """
4131         new_xbound, new_ybound = self._prepare_view_from_bbox(
4132             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4133         if not twinx and mode != "y":
4134             self.set_xbound(new_xbound)
4135             self.set_autoscalex_on(False)
4136         if not twiny and mode != "x":
4137             self.set_ybound(new_ybound)
4138             self.set_autoscaley_on(False)
4139 
4140     def start_pan(self, x, y, button):
4141         """
4142         Called when a pan operation has started.
4143 
4144         Parameters
4145         ----------
4146         x, y : float
4147             The mouse coordinates in display coords.
4148         button : `.MouseButton`
4149             The pressed mouse button.
4150 
4151         Notes
4152         -----
4153         This is intended to be overridden by new projection types.
4154         """
4155         self._pan_start = types.SimpleNamespace(
4156             lim=self.viewLim.frozen(),
4157             trans=self.transData.frozen(),
4158             trans_inverse=self.transData.inverted().frozen(),
4159             bbox=self.bbox.frozen(),
4160             x=x,
4161             y=y)
4162 
4163     def end_pan(self):
4164         """
4165         Called when a pan operation completes (when the mouse button is up.)
4166 
4167         Notes
4168         -----
4169         This is intended to be overridden by new projection types.
4170         """
4171         del self._pan_start
4172 
4173     def _get_pan_points(self, button, key, x, y):
4174         """
4175         Helper function to return the new points after a pan.
4176 
4177         This helper function returns the points on the axis after a pan has
4178         occurred. This is a convenience method to abstract the pan logic
4179         out of the base setter.
4180         """
4181         def format_deltas(key, dx, dy):
4182             if key == 'control':
4183                 if abs(dx) > abs(dy):
4184                     dy = dx
4185                 else:
4186                     dx = dy
4187             elif key == 'x':
4188                 dy = 0
4189             elif key == 'y':
4190                 dx = 0
4191             elif key == 'shift':
4192                 if 2 * abs(dx) < abs(dy):
4193                     dx = 0
4194                 elif 2 * abs(dy) < abs(dx):
4195                     dy = 0
4196                 elif abs(dx) > abs(dy):
4197                     dy = dy / abs(dy) * abs(dx)
4198                 else:
4199                     dx = dx / abs(dx) * abs(dy)
4200             return dx, dy
4201 
4202         p = self._pan_start
4203         dx = x - p.x
4204         dy = y - p.y
4205         if dx == dy == 0:
4206             return
4207         if button == 1:
4208             dx, dy = format_deltas(key, dx, dy)
4209             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4210         elif button == 3:
4211             try:
4212                 dx = -dx / self.bbox.width
4213                 dy = -dy / self.bbox.height
4214                 dx, dy = format_deltas(key, dx, dy)
4215                 if self.get_aspect() != 'auto':
4216                     dx = dy = 0.5 * (dx + dy)
4217                 alpha = np.power(10.0, (dx, dy))
4218                 start = np.array([p.x, p.y])
4219                 oldpoints = p.lim.transformed(p.trans)
4220                 newpoints = start + alpha * (oldpoints - start)
4221                 result = (mtransforms.Bbox(newpoints)
4222                           .transformed(p.trans_inverse))
4223             except OverflowError:
4224                 _api.warn_external('Overflow while panning')
4225                 return
4226         else:
4227             return
4228 
4229         valid = np.isfinite(result.transformed(p.trans))
4230         points = result.get_points().astype(object)
4231         # Just ignore invalid limits (typically, underflow in log-scale).
4232         points[~valid] = None
4233         return points
4234 
4235     def drag_pan(self, button, key, x, y):
4236         """
4237         Called when the mouse moves during a pan operation.
4238 
4239         Parameters
4240         ----------
4241         button : `.MouseButton`
4242             The pressed mouse button.
4243         key : str or None
4244             The pressed key, if any.
4245         x, y : float
4246             The mouse coordinates in display coords.
4247 
4248         Notes
4249         -----
4250         This is intended to be overridden by new projection types.
4251         """
4252         points = self._get_pan_points(button, key, x, y)
4253         if points is not None:
4254             self.set_xlim(points[:, 0])
4255             self.set_ylim(points[:, 1])
4256 
4257     def get_children(self):
4258         # docstring inherited.
4259         return [
4260             *self._children,
4261             *self.spines.values(),
4262             *self._axis_map.values(),
4263             self.title, self._left_title, self._right_title,
4264             *self.child_axes,
4265             *([self.legend_] if self.legend_ is not None else []),
4266             self.patch,
4267         ]
4268 
4269     def contains(self, mouseevent):
4270         # docstring inherited.
4271         return self.patch.contains(mouseevent)
4272 
4273     def contains_point(self, point):
4274         """
4275         Return whether *point* (pair of pixel coordinates) is inside the Axes
4276         patch.
4277         """
4278         return self.patch.contains_point(point, radius=1.0)
4279 
4280     def get_default_bbox_extra_artists(self):
4281         """
4282         Return a default list of artists that are used for the bounding box
4283         calculation.
4284 
4285         Artists are excluded either by not being visible or
4286         ``artist.set_in_layout(False)``.
4287         """
4288 
4289         artists = self.get_children()
4290 
4291         for axis in self._axis_map.values():
4292             # axis tight bboxes are calculated separately inside
4293             # Axes.get_tightbbox() using for_layout_only=True
4294             artists.remove(axis)
4295         if not (self.axison and self._frameon):
4296             # don't do bbox on spines if frame not on.
4297             for spine in self.spines.values():
4298                 artists.remove(spine)
4299 
4300         artists.remove(self.title)
4301         artists.remove(self._left_title)
4302         artists.remove(self._right_title)
4303 
4304         # always include types that do not internally implement clipping
4305         # to Axes. may have clip_on set to True and clip_box equivalent
4306         # to ax.bbox but then ignore these properties during draws.
4307         noclip = (_AxesBase, maxis.Axis,
4308                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4309         return [a for a in artists if a.get_visible() and a.get_in_layout()
4310                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4311 
4312     @_api.make_keyword_only("3.8", "call_axes_locator")
4313     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4314                       bbox_extra_artists=None, *, for_layout_only=False):
4315         """
4316         Return the tight bounding box of the Axes, including axis and their
4317         decorators (xlabel, title, etc).
4318 
4319         Artists that have ``artist.set_in_layout(False)`` are not included
4320         in the bbox.
4321 
4322         Parameters
4323         ----------
4324         renderer : `.RendererBase` subclass
4325             renderer that will be used to draw the figures (i.e.
4326             ``fig.canvas.get_renderer()``)
4327 
4328         bbox_extra_artists : list of `.Artist` or ``None``
4329             List of artists to include in the tight bounding box.  If
4330             ``None`` (default), then all artist children of the Axes are
4331             included in the tight bounding box.
4332 
4333         call_axes_locator : bool, default: True
4334             If *call_axes_locator* is ``False``, it does not call the
4335             ``_axes_locator`` attribute, which is necessary to get the correct
4336             bounding box. ``call_axes_locator=False`` can be used if the
4337             caller is only interested in the relative size of the tightbbox
4338             compared to the Axes bbox.
4339 
4340         for_layout_only : default: False
4341             The bounding box will *not* include the x-extent of the title and
4342             the xlabel, or the y-extent of the ylabel.
4343 
4344         Returns
4345         -------
4346         `.BboxBase`
4347             Bounding box in figure pixel coordinates.
4348 
4349         See Also
4350         --------
4351         matplotlib.axes.Axes.get_window_extent
4352         matplotlib.axis.Axis.get_tightbbox
4353         matplotlib.spines.Spine.get_window_extent
4354         """
4355 
4356         bb = []
4357         if renderer is None:
4358             renderer = self.figure._get_renderer()
4359 
4360         if not self.get_visible():
4361             return None
4362 
4363         locator = self.get_axes_locator()
4364         self.apply_aspect(
4365             locator(self, renderer) if locator and call_axes_locator else None)
4366 
4367         for axis in self._axis_map.values():
4368             if self.axison and axis.get_visible():
4369                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4370                 if ba:
4371                     bb.append(ba)
4372         self._update_title_position(renderer)
4373         axbbox = self.get_window_extent(renderer)
4374         bb.append(axbbox)
4375 
4376         for title in [self.title, self._left_title, self._right_title]:
4377             if title.get_visible():
4378                 bt = title.get_window_extent(renderer)
4379                 if for_layout_only and bt.width > 0:
4380                     # make the title bbox 1 pixel wide so its width
4381                     # is not accounted for in bbox calculations in
4382                     # tight/constrained_layout
4383                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4384                     bt.x1 = bt.x0 + 1.0
4385                 bb.append(bt)
4386 
4387         bbox_artists = bbox_extra_artists
4388         if bbox_artists is None:
4389             bbox_artists = self.get_default_bbox_extra_artists()
4390 
4391         for a in bbox_artists:
4392             bbox = a.get_tightbbox(renderer)
4393             if (bbox is not None
4394                     and 0 < bbox.width < np.inf
4395                     and 0 < bbox.height < np.inf):
4396                 bb.append(bbox)
4397         return mtransforms.Bbox.union(
4398             [b for b in bb if b.width != 0 or b.height != 0])
4399 
4400     def _make_twin_axes(self, *args, **kwargs):
4401         """Make a twinx Axes of self. This is used for twinx and twiny."""
4402         if 'sharex' in kwargs and 'sharey' in kwargs:
4403             # The following line is added in v2.2 to avoid breaking Seaborn,
4404             # which currently uses this internal API.
4405             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4406                 raise ValueError("Twinned Axes may share only one axis")
4407         ss = self.get_subplotspec()
4408         if ss:
4409             twin = self.figure.add_subplot(ss, *args, **kwargs)
4410         else:
4411             twin = self.figure.add_axes(
4412                 self.get_position(True), *args, **kwargs,
4413                 axes_locator=_TransformedBoundsLocator(
4414                     [0, 0, 1, 1], self.transAxes))
4415         self.set_adjustable('datalim')
4416         twin.set_adjustable('datalim')
4417         self._twinned_axes.join(self, twin)
4418         return twin
4419 
4420     def twinx(self):
4421         """
4422         Create a twin Axes sharing the xaxis.
4423 
4424         Create a new Axes with an invisible x-axis and an independent
4425         y-axis positioned opposite to the original one (i.e. at right). The
4426         x-axis autoscale setting will be inherited from the original
4427         Axes.  To ensure that the tick marks of both y-axes align, see
4428         `~matplotlib.ticker.LinearLocator`.
4429 
4430         Returns
4431         -------
4432         Axes
4433             The newly created Axes instance
4434 
4435         Notes
4436         -----
4437         For those who are 'picking' artists while using twinx, pick
4438         events are only called for the artists in the top-most Axes.
4439         """
4440         ax2 = self._make_twin_axes(sharex=self)
4441         ax2.yaxis.tick_right()
4442         ax2.yaxis.set_label_position('right')
4443         ax2.yaxis.set_offset_position('right')
4444         ax2.set_autoscalex_on(self.get_autoscalex_on())
4445         self.yaxis.tick_left()
4446         ax2.xaxis.set_visible(False)
4447         ax2.patch.set_visible(False)
4448         return ax2
4449 
4450     def twiny(self):
4451         """
4452         Create a twin Axes sharing the yaxis.
4453 
4454         Create a new Axes with an invisible y-axis and an independent
4455         x-axis positioned opposite to the original one (i.e. at top). The
4456         y-axis autoscale setting will be inherited from the original Axes.
4457         To ensure that the tick marks of both x-axes align, see
4458         `~matplotlib.ticker.LinearLocator`.
4459 
4460         Returns
4461         -------
4462         Axes
4463             The newly created Axes instance
4464 
4465         Notes
4466         -----
4467         For those who are 'picking' artists while using twiny, pick
4468         events are only called for the artists in the top-most Axes.
4469         """
4470         ax2 = self._make_twin_axes(sharey=self)
4471         ax2.xaxis.tick_top()
4472         ax2.xaxis.set_label_position('top')
4473         ax2.set_autoscaley_on(self.get_autoscaley_on())
4474         self.xaxis.tick_bottom()
4475         ax2.yaxis.set_visible(False)
4476         ax2.patch.set_visible(False)
4477         return ax2
4478 
4479     def get_shared_x_axes(self):
4480         """Return an immutable view on the shared x-axes Grouper."""
4481         return cbook.GrouperView(self._shared_axes["x"])
4482 
4483     def get_shared_y_axes(self):
4484         """Return an immutable view on the shared y-axes Grouper."""
4485         return cbook.GrouperView(self._shared_axes["y"])
4486 
4487     def label_outer(self):
4488         """
4489         Only show "outer" labels and tick labels.
4490 
4491         x-labels are only kept for subplots on the last row (or first row, if
4492         labels are on the top side); y-labels only for subplots on the first
4493         column (or last column, if labels are on the right side).
4494         """
4495         self._label_outer_xaxis(check_patch=False)
4496         self._label_outer_yaxis(check_patch=False)
4497 
4498     def _label_outer_xaxis(self, *, check_patch):
4499         # see documentation in label_outer.
4500         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4501             return
4502         ss = self.get_subplotspec()
4503         if not ss:
4504             return
4505         label_position = self.xaxis.get_label_position()
4506         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4507             if label_position == "top":
4508                 self.set_xlabel("")
4509             self.xaxis.set_tick_params(which="both", labeltop=False)
4510             if self.xaxis.offsetText.get_position()[1] == 1:
4511                 self.xaxis.offsetText.set_visible(False)
4512         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4513             if label_position == "bottom":
4514                 self.set_xlabel("")
4515             self.xaxis.set_tick_params(which="both", labelbottom=False)
4516             if self.xaxis.offsetText.get_position()[1] == 0:
4517                 self.xaxis.offsetText.set_visible(False)
4518 
4519     def _label_outer_yaxis(self, *, check_patch):
4520         # see documentation in label_outer.
4521         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4522             return
4523         ss = self.get_subplotspec()
4524         if not ss:
4525             return
4526         label_position = self.yaxis.get_label_position()
4527         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4528             if label_position == "left":
4529                 self.set_ylabel("")
4530             self.yaxis.set_tick_params(which="both", labelleft=False)
4531             if self.yaxis.offsetText.get_position()[0] == 0:
4532                 self.yaxis.offsetText.set_visible(False)
4533         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4534             if label_position == "right":
4535                 self.set_ylabel("")
4536             self.yaxis.set_tick_params(which="both", labelright=False)
4537             if self.yaxis.offsetText.get_position()[0] == 1:
4538                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:47:10.281 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>tick_params</method>
<code>
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)

</code><intended_behavior>The `tick_params` method should be enhanced to support a new keyword argument `fontfamily`. This argument will allow users to specify the font family for tick labels directly within the `tick_params` call. The method should accept `fontfamily` as part of its `**kwargs`, implement logic to apply the `fontfamily` to tick labels, ensure the addition of `fontfamily` does not disrupt any existing functionality, and update the documentation to include `fontfamily`, specifying its usage.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     def get_window_extent(self, renderer=None):
800         """
801         Return the Axes bounding box in display space.
802 
803         This bounding box does not include the spines, ticks, ticklabels,
804         or other labels.  For a bounding box including these elements use
805         `~matplotlib.axes.Axes.get_tightbbox`.
806 
807         See Also
808         --------
809         matplotlib.axes.Axes.get_tightbbox
810         matplotlib.axis.Axis.get_tightbbox
811         matplotlib.spines.Spine.get_window_extent
812         """
813         return self.bbox
814 
815     def _init_axis(self):
816         # This is moved out of __init__ because non-separable axes don't use it
817         self.xaxis = maxis.XAxis(self)
818         self.spines.bottom.register_axis(self.xaxis)
819         self.spines.top.register_axis(self.xaxis)
820         self.yaxis = maxis.YAxis(self)
821         self.spines.left.register_axis(self.yaxis)
822         self.spines.right.register_axis(self.yaxis)
823 
824     def set_figure(self, fig):
825         # docstring inherited
826         super().set_figure(fig)
827 
828         self.bbox = mtransforms.TransformedBbox(self._position,
829                                                 fig.transSubfigure)
830         # these will be updated later as data is added
831         self.dataLim = mtransforms.Bbox.null()
832         self._viewLim = mtransforms.Bbox.unit()
833         self.transScale = mtransforms.TransformWrapper(
834             mtransforms.IdentityTransform())
835 
836         self._set_lim_and_transforms()
837 
838     def _unstale_viewLim(self):
839         # We should arrange to store this information once per share-group
840         # instead of on every axis.
841         need_scale = {
842             name: any(ax._stale_viewlims[name]
843                       for ax in self._shared_axes[name].get_siblings(self))
844             for name in self._axis_names}
845         if any(need_scale.values()):
846             for name in need_scale:
847                 for ax in self._shared_axes[name].get_siblings(self):
848                     ax._stale_viewlims[name] = False
849             self.autoscale_view(**{f"scale{name}": scale
850                                    for name, scale in need_scale.items()})
851 
852     @property
853     def viewLim(self):
854         self._unstale_viewLim()
855         return self._viewLim
856 
857     def _request_autoscale_view(self, axis="all", tight=None):
858         """
859         Mark a single axis, or all of them, as stale wrt. autoscaling.
860 
861         No computation is performed until the next autoscaling; thus, separate
862         calls to control individual axises incur negligible performance cost.
863 
864         Parameters
865         ----------
866         axis : str, default: "all"
867             Either an element of ``self._axis_names``, or "all".
868         tight : bool or None, default: None
869         """
870         axis_names = _api.check_getitem(
871             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
872             axis=axis)
873         for name in axis_names:
874             self._stale_viewlims[name] = True
875         if tight is not None:
876             self._tight = tight
877 
878     def _set_lim_and_transforms(self):
879         """
880         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
881         *transData*, *transLimits* and *transAxes* transformations.
882 
883         .. note::
884 
885             This method is primarily used by rectilinear projections of the
886             `~matplotlib.axes.Axes` class, and is meant to be overridden by
887             new kinds of projection Axes that need different transformations
888             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
889             example.)
890         """
891         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
892 
893         # Transforms the x and y axis separately by a scale factor.
894         # It is assumed that this part will have non-linear components
895         # (e.g., for a log scale).
896         self.transScale = mtransforms.TransformWrapper(
897             mtransforms.IdentityTransform())
898 
899         # An affine transformation on the data, generally to limit the
900         # range of the axes
901         self.transLimits = mtransforms.BboxTransformFrom(
902             mtransforms.TransformedBbox(self._viewLim, self.transScale))
903 
904         # The parentheses are important for efficiency here -- they
905         # group the last two (which are usually affines) separately
906         # from the first (which, with log-scaling can be non-affine).
907         self.transData = self.transScale + (self.transLimits + self.transAxes)
908 
909         self._xaxis_transform = mtransforms.blended_transform_factory(
910             self.transData, self.transAxes)
911         self._yaxis_transform = mtransforms.blended_transform_factory(
912             self.transAxes, self.transData)
913 
914     def get_xaxis_transform(self, which='grid'):
915         """
916         Get the transformation used for drawing x-axis labels, ticks
917         and gridlines.  The x-direction is in data coordinates and the
918         y-direction is in axis coordinates.
919 
920         .. note::
921 
922             This transformation is primarily used by the
923             `~matplotlib.axis.Axis` class, and is meant to be
924             overridden by new kinds of projections that may need to
925             place axis elements in different locations.
926 
927         Parameters
928         ----------
929         which : {'grid', 'tick1', 'tick2'}
930         """
931         if which == 'grid':
932             return self._xaxis_transform
933         elif which == 'tick1':
934             # for cartesian projection, this is bottom spine
935             return self.spines.bottom.get_spine_transform()
936         elif which == 'tick2':
937             # for cartesian projection, this is top spine
938             return self.spines.top.get_spine_transform()
939         else:
940             raise ValueError(f'unknown value for which: {which!r}')
941 
942     def get_xaxis_text1_transform(self, pad_points):
943         """
944         Returns
945         -------
946         transform : Transform
947             The transform used for drawing x-axis labels, which will add
948             *pad_points* of padding (in points) between the axis and the label.
949             The x-direction is in data coordinates and the y-direction is in
950             axis coordinates
951         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
952             The text vertical alignment.
953         halign : {'center', 'left', 'right'}
954             The text horizontal alignment.
955 
956         Notes
957         -----
958         This transformation is primarily used by the `~matplotlib.axis.Axis`
959         class, and is meant to be overridden by new kinds of projections that
960         may need to place axis elements in different locations.
961         """
962         labels_align = mpl.rcParams["xtick.alignment"]
963         return (self.get_xaxis_transform(which='tick1') +
964                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
965                                               self.figure.dpi_scale_trans),
966                 "top", labels_align)
967 
968     def get_xaxis_text2_transform(self, pad_points):
969         """
970         Returns
971         -------
972         transform : Transform
973             The transform used for drawing secondary x-axis labels, which will
974             add *pad_points* of padding (in points) between the axis and the
975             label.  The x-direction is in data coordinates and the y-direction
976             is in axis coordinates
977         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
978             The text vertical alignment.
979         halign : {'center', 'left', 'right'}
980             The text horizontal alignment.
981 
982         Notes
983         -----
984         This transformation is primarily used by the `~matplotlib.axis.Axis`
985         class, and is meant to be overridden by new kinds of projections that
986         may need to place axis elements in different locations.
987         """
988         labels_align = mpl.rcParams["xtick.alignment"]
989         return (self.get_xaxis_transform(which='tick2') +
990                 mtransforms.ScaledTranslation(0, pad_points / 72,
991                                               self.figure.dpi_scale_trans),
992                 "bottom", labels_align)
993 
994     def get_yaxis_transform(self, which='grid'):
995         """
996         Get the transformation used for drawing y-axis labels, ticks
997         and gridlines.  The x-direction is in axis coordinates and the
998         y-direction is in data coordinates.
999 
1000         .. note::
1001 
1002             This transformation is primarily used by the
1003             `~matplotlib.axis.Axis` class, and is meant to be
1004             overridden by new kinds of projections that may need to
1005             place axis elements in different locations.
1006 
1007         Parameters
1008         ----------
1009         which : {'grid', 'tick1', 'tick2'}
1010         """
1011         if which == 'grid':
1012             return self._yaxis_transform
1013         elif which == 'tick1':
1014             # for cartesian projection, this is bottom spine
1015             return self.spines.left.get_spine_transform()
1016         elif which == 'tick2':
1017             # for cartesian projection, this is top spine
1018             return self.spines.right.get_spine_transform()
1019         else:
1020             raise ValueError(f'unknown value for which: {which!r}')
1021 
1022     def get_yaxis_text1_transform(self, pad_points):
1023         """
1024         Returns
1025         -------
1026         transform : Transform
1027             The transform used for drawing y-axis labels, which will add
1028             *pad_points* of padding (in points) between the axis and the label.
1029             The x-direction is in axis coordinates and the y-direction is in
1030             data coordinates
1031         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1032             The text vertical alignment.
1033         halign : {'center', 'left', 'right'}
1034             The text horizontal alignment.
1035 
1036         Notes
1037         -----
1038         This transformation is primarily used by the `~matplotlib.axis.Axis`
1039         class, and is meant to be overridden by new kinds of projections that
1040         may need to place axis elements in different locations.
1041         """
1042         labels_align = mpl.rcParams["ytick.alignment"]
1043         return (self.get_yaxis_transform(which='tick1') +
1044                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1045                                               self.figure.dpi_scale_trans),
1046                 labels_align, "right")
1047 
1048     def get_yaxis_text2_transform(self, pad_points):
1049         """
1050         Returns
1051         -------
1052         transform : Transform
1053             The transform used for drawing secondart y-axis labels, which will
1054             add *pad_points* of padding (in points) between the axis and the
1055             label.  The x-direction is in axis coordinates and the y-direction
1056             is in data coordinates
1057         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1058             The text vertical alignment.
1059         halign : {'center', 'left', 'right'}
1060             The text horizontal alignment.
1061 
1062         Notes
1063         -----
1064         This transformation is primarily used by the `~matplotlib.axis.Axis`
1065         class, and is meant to be overridden by new kinds of projections that
1066         may need to place axis elements in different locations.
1067         """
1068         labels_align = mpl.rcParams["ytick.alignment"]
1069         return (self.get_yaxis_transform(which='tick2') +
1070                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1071                                               self.figure.dpi_scale_trans),
1072                 labels_align, "left")
1073 
1074     def _update_transScale(self):
1075         self.transScale.set(
1076             mtransforms.blended_transform_factory(
1077                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1078 
1079     def get_position(self, original=False):
1080         """
1081         Return the position of the Axes within the figure as a `.Bbox`.
1082 
1083         Parameters
1084         ----------
1085         original : bool
1086             If ``True``, return the original position. Otherwise, return the
1087             active position. For an explanation of the positions see
1088             `.set_position`.
1089 
1090         Returns
1091         -------
1092         `.Bbox`
1093 
1094         """
1095         if original:
1096             return self._originalPosition.frozen()
1097         else:
1098             locator = self.get_axes_locator()
1099             if not locator:
1100                 self.apply_aspect()
1101             return self._position.frozen()
1102 
1103     def set_position(self, pos, which='both'):
1104         """
1105         Set the Axes position.
1106 
1107         Axes have two position attributes. The 'original' position is the
1108         position allocated for the Axes. The 'active' position is the
1109         position the Axes is actually drawn at. These positions are usually
1110         the same unless a fixed aspect is set to the Axes. See
1111         `.Axes.set_aspect` for details.
1112 
1113         Parameters
1114         ----------
1115         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1116             The new position of the Axes in `.Figure` coordinates.
1117 
1118         which : {'both', 'active', 'original'}, default: 'both'
1119             Determines which position variables to change.
1120 
1121         See Also
1122         --------
1123         matplotlib.transforms.Bbox.from_bounds
1124         matplotlib.transforms.Bbox.from_extents
1125         """
1126         self._set_position(pos, which=which)
1127         # because this is being called externally to the library we
1128         # don't let it be in the layout.
1129         self.set_in_layout(False)
1130 
1131     def _set_position(self, pos, which='both'):
1132         """
1133         Private version of set_position.
1134 
1135         Call this internally to get the same functionality of `set_position`,
1136         but not to take the axis out of the constrained_layout hierarchy.
1137         """
1138         if not isinstance(pos, mtransforms.BboxBase):
1139             pos = mtransforms.Bbox.from_bounds(*pos)
1140         for ax in self._twinned_axes.get_siblings(self):
1141             if which in ('both', 'active'):
1142                 ax._position.set(pos)
1143             if which in ('both', 'original'):
1144                 ax._originalPosition.set(pos)
1145         self.stale = True
1146 
1147     def reset_position(self):
1148         """
1149         Reset the active position to the original position.
1150 
1151         This undoes changes to the active position (as defined in
1152         `.set_position`) which may have been performed to satisfy fixed-aspect
1153         constraints.
1154         """
1155         for ax in self._twinned_axes.get_siblings(self):
1156             pos = ax.get_position(original=True)
1157             ax.set_position(pos, which='active')
1158 
1159     def set_axes_locator(self, locator):
1160         """
1161         Set the Axes locator.
1162 
1163         Parameters
1164         ----------
1165         locator : Callable[[Axes, Renderer], Bbox]
1166         """
1167         self._axes_locator = locator
1168         self.stale = True
1169 
1170     def get_axes_locator(self):
1171         """
1172         Return the axes_locator.
1173         """
1174         return self._axes_locator
1175 
1176     def _set_artist_props(self, a):
1177         """Set the boilerplate props for artists added to Axes."""
1178         a.set_figure(self.figure)
1179         if not a.is_transform_set():
1180             a.set_transform(self.transData)
1181 
1182         a.axes = self
1183         if a.get_mouseover():
1184             self._mouseover_set.add(a)
1185 
1186     def _gen_axes_patch(self):
1187         """
1188         Returns
1189         -------
1190         Patch
1191             The patch used to draw the background of the Axes.  It is also used
1192             as the clipping path for any data elements on the Axes.
1193 
1194             In the standard Axes, this is a rectangle, but in other projections
1195             it may not be.
1196 
1197         Notes
1198         -----
1199         Intended to be overridden by new projection types.
1200         """
1201         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1202 
1203     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1204         """
1205         Returns
1206         -------
1207         dict
1208             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1209             used to draw Axes spines.
1210 
1211             In the standard Axes, spines are single line segments, but in other
1212             projections they may not be.
1213 
1214         Notes
1215         -----
1216         Intended to be overridden by new projection types.
1217         """
1218         return {side: mspines.Spine.linear_spine(self, side)
1219                 for side in ['left', 'right', 'bottom', 'top']}
1220 
1221     def sharex(self, other):
1222         """
1223         Share the x-axis with *other*.
1224 
1225         This is equivalent to passing ``sharex=other`` when constructing the
1226         Axes, and cannot be used if the x-axis is already being shared with
1227         another Axes.
1228         """
1229         _api.check_isinstance(_AxesBase, other=other)
1230         if self._sharex is not None and other is not self._sharex:
1231             raise ValueError("x-axis is already shared")
1232         self._shared_axes["x"].join(self, other)
1233         self._sharex = other
1234         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1235         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1236         x0, x1 = other.get_xlim()
1237         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1238         self.xaxis._scale = other.xaxis._scale
1239 
1240     def sharey(self, other):
1241         """
1242         Share the y-axis with *other*.
1243 
1244         This is equivalent to passing ``sharey=other`` when constructing the
1245         Axes, and cannot be used if the y-axis is already being shared with
1246         another Axes.
1247         """
1248         _api.check_isinstance(_AxesBase, other=other)
1249         if self._sharey is not None and other is not self._sharey:
1250             raise ValueError("y-axis is already shared")
1251         self._shared_axes["y"].join(self, other)
1252         self._sharey = other
1253         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1254         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1255         y0, y1 = other.get_ylim()
1256         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1257         self.yaxis._scale = other.yaxis._scale
1258 
1259     def __clear(self):
1260         """Clear the Axes."""
1261         # The actual implementation of clear() as long as clear() has to be
1262         # an adapter delegating to the correct implementation.
1263         # The implementation can move back into clear() when the
1264         # deprecation on cla() subclassing expires.
1265 
1266         # stash the current visibility state
1267         if hasattr(self, 'patch'):
1268             patch_visible = self.patch.get_visible()
1269         else:
1270             patch_visible = True
1271 
1272         xaxis_visible = self.xaxis.get_visible()
1273         yaxis_visible = self.yaxis.get_visible()
1274 
1275         for axis in self._axis_map.values():
1276             axis.clear()  # Also resets the scale to linear.
1277         for spine in self.spines.values():
1278             spine.clear()
1279 
1280         self.ignore_existing_data_limits = True
1281         self.callbacks = cbook.CallbackRegistry(
1282             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1283 
1284         # update the minor locator for x and y axis based on rcParams
1285         if mpl.rcParams['xtick.minor.visible']:
1286             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1287         if mpl.rcParams['ytick.minor.visible']:
1288             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1289 
1290         self._xmargin = mpl.rcParams['axes.xmargin']
1291         self._ymargin = mpl.rcParams['axes.ymargin']
1292         self._tight = None
1293         self._use_sticky_edges = True
1294 
1295         self._get_lines = _process_plot_var_args(self)
1296         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1297 
1298         self._gridOn = mpl.rcParams['axes.grid']
1299         old_children, self._children = self._children, []
1300         for chld in old_children:
1301             chld.axes = chld.figure = None
1302         self._mouseover_set = _OrderedSet()
1303         self.child_axes = []
1304         self._current_image = None  # strictly for pyplot via _sci, _gci
1305         self._projection_init = None  # strictly for pyplot.subplot
1306         self.legend_ = None
1307         self.containers = []
1308 
1309         self.grid(False)  # Disable grid on init to use rcParameter
1310         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1311                   axis=mpl.rcParams['axes.grid.axis'])
1312         props = font_manager.FontProperties(
1313             size=mpl.rcParams['axes.titlesize'],
1314             weight=mpl.rcParams['axes.titleweight'])
1315 
1316         y = mpl.rcParams['axes.titley']
1317         if y is None:
1318             y = 1.0
1319             self._autotitlepos = True
1320         else:
1321             self._autotitlepos = False
1322 
1323         self.title = mtext.Text(
1324             x=0.5, y=y, text='',
1325             fontproperties=props,
1326             verticalalignment='baseline',
1327             horizontalalignment='center',
1328             )
1329         self._left_title = mtext.Text(
1330             x=0.0, y=y, text='',
1331             fontproperties=props.copy(),
1332             verticalalignment='baseline',
1333             horizontalalignment='left', )
1334         self._right_title = mtext.Text(
1335             x=1.0, y=y, text='',
1336             fontproperties=props.copy(),
1337             verticalalignment='baseline',
1338             horizontalalignment='right',
1339             )
1340         title_offset_points = mpl.rcParams['axes.titlepad']
1341         # refactor this out so it can be called in ax.set_title if
1342         # pad argument used...
1343         self._set_title_offset_trans(title_offset_points)
1344 
1345         for _title in (self.title, self._left_title, self._right_title):
1346             self._set_artist_props(_title)
1347 
1348         # The patch draws the background of the Axes.  We want this to be below
1349         # the other artists.  We use the frame to draw the edges so we are
1350         # setting the edgecolor to None.
1351         self.patch = self._gen_axes_patch()
1352         self.patch.set_figure(self.figure)
1353         self.patch.set_facecolor(self._facecolor)
1354         self.patch.set_edgecolor('none')
1355         self.patch.set_linewidth(0)
1356         self.patch.set_transform(self.transAxes)
1357 
1358         self.set_axis_on()
1359 
1360         self.xaxis.set_clip_path(self.patch)
1361         self.yaxis.set_clip_path(self.patch)
1362 
1363         if self._sharex is not None:
1364             self.xaxis.set_visible(xaxis_visible)
1365             self.patch.set_visible(patch_visible)
1366         if self._sharey is not None:
1367             self.yaxis.set_visible(yaxis_visible)
1368             self.patch.set_visible(patch_visible)
1369 
1370         # This comes last, as the call to _set_lim may trigger an autoscale (in
1371         # case of shared axes), requiring children to be already set up.
1372         for name, axis in self._axis_map.items():
1373             share = getattr(self, f"_share{name}")
1374             if share is not None:
1375                 getattr(self, f"share{name}")(share)
1376             else:
1377                 axis._set_scale("linear")
1378                 axis._set_lim(0, 1, auto=True)
1379         self._update_transScale()
1380 
1381         self.stale = True
1382 
1383     def clear(self):
1384         """Clear the Axes."""
1385         # Act as an alias, or as the superclass implementation depending on the
1386         # subclass implementation.
1387         if self._subclass_uses_cla:
1388             self.cla()
1389         else:
1390             self.__clear()
1391 
1392     def cla(self):
1393         """Clear the Axes."""
1394         # Act as an alias, or as the superclass implementation depending on the
1395         # subclass implementation.
1396         if self._subclass_uses_cla:
1397             self.__clear()
1398         else:
1399             self.clear()
1400 
1401     class ArtistList(Sequence):
1402         """
1403         A sublist of Axes children based on their type.
1404 
1405         The type-specific children sublists were made immutable in Matplotlib
1406         3.7.  In the future these artist lists may be replaced by tuples. Use
1407         as if this is a tuple already.
1408         """
1409         def __init__(self, axes, prop_name,
1410                      valid_types=None, invalid_types=None):
1411             """
1412             Parameters
1413             ----------
1414             axes : `~matplotlib.axes.Axes`
1415                 The Axes from which this sublist will pull the children
1416                 Artists.
1417             prop_name : str
1418                 The property name used to access this sublist from the Axes;
1419                 used to generate deprecation warnings.
1420             valid_types : list of type, optional
1421                 A list of types that determine which children will be returned
1422                 by this sublist. If specified, then the Artists in the sublist
1423                 must be instances of any of these types. If unspecified, then
1424                 any type of Artist is valid (unless limited by
1425                 *invalid_types*.)
1426             invalid_types : tuple, optional
1427                 A list of types that determine which children will *not* be
1428                 returned by this sublist. If specified, then Artists in the
1429                 sublist will never be an instance of these types. Otherwise, no
1430                 types will be excluded.
1431             """
1432             self._axes = axes
1433             self._prop_name = prop_name
1434             self._type_check = lambda artist: (
1435                 (not valid_types or isinstance(artist, valid_types)) and
1436                 (not invalid_types or not isinstance(artist, invalid_types))
1437             )
1438 
1439         def __repr__(self):
1440             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1441 
1442         def __len__(self):
1443             return sum(self._type_check(artist)
1444                        for artist in self._axes._children)
1445 
1446         def __iter__(self):
1447             for artist in list(self._axes._children):
1448                 if self._type_check(artist):
1449                     yield artist
1450 
1451         def __getitem__(self, key):
1452             return [artist
1453                     for artist in self._axes._children
1454                     if self._type_check(artist)][key]
1455 
1456         def __add__(self, other):
1457             if isinstance(other, (list, _AxesBase.ArtistList)):
1458                 return [*self, *other]
1459             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1460                 return (*self, *other)
1461             return NotImplemented
1462 
1463         def __radd__(self, other):
1464             if isinstance(other, list):
1465                 return other + list(self)
1466             if isinstance(other, tuple):
1467                 return other + tuple(self)
1468             return NotImplemented
1469 
1470     @property
1471     def artists(self):
1472         return self.ArtistList(self, 'artists', invalid_types=(
1473             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1474             mtable.Table, mtext.Text))
1475 
1476     @property
1477     def collections(self):
1478         return self.ArtistList(self, 'collections',
1479                                valid_types=mcoll.Collection)
1480 
1481     @property
1482     def images(self):
1483         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1484 
1485     @property
1486     def lines(self):
1487         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1488 
1489     @property
1490     def patches(self):
1491         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1492 
1493     @property
1494     def tables(self):
1495         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1496 
1497     @property
1498     def texts(self):
1499         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1500 
1501     def get_facecolor(self):
1502         """Get the facecolor of the Axes."""
1503         return self.patch.get_facecolor()
1504 
1505     def set_facecolor(self, color):
1506         """
1507         Set the facecolor of the Axes.
1508 
1509         Parameters
1510         ----------
1511         color : color
1512         """
1513         self._facecolor = color
1514         self.stale = True
1515         return self.patch.set_facecolor(color)
1516 
1517     def _set_title_offset_trans(self, title_offset_points):
1518         """
1519         Set the offset for the title either from :rc:`axes.titlepad`
1520         or from set_title kwarg ``pad``.
1521         """
1522         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1523                 0.0, title_offset_points / 72,
1524                 self.figure.dpi_scale_trans)
1525         for _title in (self.title, self._left_title, self._right_title):
1526             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1527             _title.set_clip_box(None)
1528 
1529     def set_prop_cycle(self, *args, **kwargs):
1530         """
1531         Set the property cycle of the Axes.
1532 
1533         The property cycle controls the style properties such as color,
1534         marker and linestyle of future plot commands. The style properties
1535         of data already added to the Axes are not modified.
1536 
1537         Call signatures::
1538 
1539           set_prop_cycle(cycler)
1540           set_prop_cycle(label=values[, label2=values2[, ...]])
1541           set_prop_cycle(label, values)
1542 
1543         Form 1 sets given `~cycler.Cycler` object.
1544 
1545         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1546         properties simultaneously and set it as the property cycle of the
1547         Axes. If multiple properties are given, their value lists must have
1548         the same length. This is just a shortcut for explicitly creating a
1549         cycler and passing it to the function, i.e. it's short for
1550         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1551 
1552         Form 3 creates a `~cycler.Cycler` for a single property and set it
1553         as the property cycle of the Axes. This form exists for compatibility
1554         with the original `cycler.cycler` interface. Its use is discouraged
1555         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1556 
1557         Parameters
1558         ----------
1559         cycler : Cycler
1560             Set the given Cycler. *None* resets to the cycle defined by the
1561             current style.
1562 
1563         label : str
1564             The property key. Must be a valid `.Artist` property.
1565             For example, 'color' or 'linestyle'. Aliases are allowed,
1566             such as 'c' for 'color' and 'lw' for 'linewidth'.
1567 
1568         values : iterable
1569             Finite-length iterable of the property values. These values
1570             are validated and will raise a ValueError if invalid.
1571 
1572         See Also
1573         --------
1574         matplotlib.rcsetup.cycler
1575             Convenience function for creating validated cyclers for properties.
1576         cycler.cycler
1577             The original function for creating unvalidated cyclers.
1578 
1579         Examples
1580         --------
1581         Setting the property cycle for a single property:
1582 
1583         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1584 
1585         Setting the property cycle for simultaneously cycling over multiple
1586         properties (e.g. red circle, green plus, blue cross):
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1589         ...                   marker=['o', '+', 'x'])
1590 
1591         """
1592         if args and kwargs:
1593             raise TypeError("Cannot supply both positional and keyword "
1594                             "arguments to this method.")
1595         # Can't do `args == (None,)` as that crashes cycler.
1596         if len(args) == 1 and args[0] is None:
1597             prop_cycle = None
1598         else:
1599             prop_cycle = cycler(*args, **kwargs)
1600         self._get_lines.set_prop_cycle(prop_cycle)
1601         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1602 
1603     def get_aspect(self):
1604         """
1605         Return the aspect ratio of the axes scaling.
1606 
1607         This is either "auto" or a float giving the ratio of y/x-scale.
1608         """
1609         return self._aspect
1610 
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True
1682 
1683     def get_adjustable(self):
1684         """
1685         Return whether the Axes will adjust its physical dimension ('box') or
1686         its data limits ('datalim') to achieve the desired aspect ratio.
1687 
1688         See Also
1689         --------
1690         matplotlib.axes.Axes.set_adjustable
1691             Set how the Axes adjusts to achieve the required aspect ratio.
1692         matplotlib.axes.Axes.set_aspect
1693             For a description of aspect handling.
1694         """
1695         return self._adjustable
1696 
1697     def set_adjustable(self, adjustable, share=False):
1698         """
1699         Set how the Axes adjusts to achieve the required aspect ratio.
1700 
1701         Parameters
1702         ----------
1703         adjustable : {'box', 'datalim'}
1704             If 'box', change the physical dimensions of the Axes.
1705             If 'datalim', change the ``x`` or ``y`` data limits.
1706 
1707         share : bool, default: False
1708             If ``True``, apply the settings to all shared Axes.
1709 
1710         See Also
1711         --------
1712         matplotlib.axes.Axes.set_aspect
1713             For a description of aspect handling.
1714 
1715         Notes
1716         -----
1717         Shared Axes (of which twinned Axes are a special case)
1718         impose restrictions on how aspect ratios can be imposed.
1719         For twinned Axes, use 'datalim'.  For Axes that share both
1720         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1721         may be used.  These limitations are partly a requirement
1722         to avoid over-specification, and partly a result of the
1723         particular implementation we are currently using, in
1724         which the adjustments for aspect ratios are done sequentially
1725         and independently on each Axes as it is drawn.
1726         """
1727         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1728         if share:
1729             axs = {sibling for name in self._axis_names
1730                    for sibling in self._shared_axes[name].get_siblings(self)}
1731         else:
1732             axs = [self]
1733         if (adjustable == "datalim"
1734                 and any(getattr(ax.get_data_ratio, "__func__", None)
1735                         != _AxesBase.get_data_ratio
1736                         for ax in axs)):
1737             # Limits adjustment by apply_aspect assumes that the axes' aspect
1738             # ratio can be computed from the data limits and scales.
1739             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1740                              "Axes which override 'get_data_ratio'")
1741         for ax in axs:
1742             ax._adjustable = adjustable
1743         self.stale = True
1744 
1745     def get_box_aspect(self):
1746         """
1747         Return the Axes box aspect, i.e. the ratio of height to width.
1748 
1749         The box aspect is ``None`` (i.e. chosen depending on the available
1750         figure space) unless explicitly specified.
1751 
1752         See Also
1753         --------
1754         matplotlib.axes.Axes.set_box_aspect
1755             for a description of box aspect.
1756         matplotlib.axes.Axes.set_aspect
1757             for a description of aspect handling.
1758         """
1759         return self._box_aspect
1760 
1761     def set_box_aspect(self, aspect=None):
1762         """
1763         Set the Axes box aspect, i.e. the ratio of height to width.
1764 
1765         This defines the aspect of the Axes in figure space and is not to be
1766         confused with the data aspect (see `~.Axes.set_aspect`).
1767 
1768         Parameters
1769         ----------
1770         aspect : float or None
1771             Changes the physical dimensions of the Axes, such that the ratio
1772             of the Axes height to the Axes width in physical units is equal to
1773             *aspect*. Defining a box aspect will change the *adjustable*
1774             property to 'datalim' (see `~.Axes.set_adjustable`).
1775 
1776             *None* will disable a fixed box aspect so that height and width
1777             of the Axes are chosen independently.
1778 
1779         See Also
1780         --------
1781         matplotlib.axes.Axes.set_aspect
1782             for a description of aspect handling.
1783         """
1784         axs = {*self._twinned_axes.get_siblings(self),
1785                *self._twinned_axes.get_siblings(self)}
1786 
1787         if aspect is not None:
1788             aspect = float(aspect)
1789             # when box_aspect is set to other than None`,
1790             # adjustable must be "datalim"
1791             for ax in axs:
1792                 ax.set_adjustable("datalim")
1793 
1794         for ax in axs:
1795             ax._box_aspect = aspect
1796             ax.stale = True
1797 
1798     def get_anchor(self):
1799         """
1800         Get the anchor location.
1801 
1802         See Also
1803         --------
1804         matplotlib.axes.Axes.set_anchor
1805             for a description of the anchor.
1806         matplotlib.axes.Axes.set_aspect
1807             for a description of aspect handling.
1808         """
1809         return self._anchor
1810 
1811     def set_anchor(self, anchor, share=False):
1812         """
1813         Define the anchor location.
1814 
1815         The actual drawing area (active position) of the Axes may be smaller
1816         than the Bbox (original position) when a fixed aspect is required. The
1817         anchor defines where the drawing area will be located within the
1818         available space.
1819 
1820         Parameters
1821         ----------
1822         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1823             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1824             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1825             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1826             for (*x*, *y*) coordinates, as shown in the following diagram::
1827 
1828                
1829                 'NW' (0.0, 1.0)  'N' (0.5, 1.0)   'NE' (1.0, 1.0) 
1830                
1831                 'W'  (0.0, 0.5)  'C' (0.5, 0.5)   'E'  (1.0, 0.5) 
1832                
1833                 'SW' (0.0, 0.0)  'S' (0.5, 0.0)   'SE' (1.0, 0.0) 
1834                
1835 
1836         share : bool, default: False
1837             If ``True``, apply the settings to all shared Axes.
1838 
1839         See Also
1840         --------
1841         matplotlib.axes.Axes.set_aspect
1842             for a description of aspect handling.
1843         """
1844         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1845             raise ValueError('argument must be among %s' %
1846                              ', '.join(mtransforms.Bbox.coefs))
1847         if share:
1848             axes = {sibling for name in self._axis_names
1849                     for sibling in self._shared_axes[name].get_siblings(self)}
1850         else:
1851             axes = [self]
1852         for ax in axes:
1853             ax._anchor = anchor
1854 
1855         self.stale = True
1856 
1857     def get_data_ratio(self):
1858         """
1859         Return the aspect ratio of the scaled data.
1860 
1861         Notes
1862         -----
1863         This method is intended to be overridden by new projection types.
1864         """
1865         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1866         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1867         xsize = max(abs(txmax - txmin), 1e-30)
1868         ysize = max(abs(tymax - tymin), 1e-30)
1869         return ysize / xsize
1870 
1871     def apply_aspect(self, position=None):
1872         """
1873         Adjust the Axes for a specified data aspect ratio.
1874 
1875         Depending on `.get_adjustable` this will modify either the
1876         Axes box (position) or the view limits. In the former case,
1877         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1878 
1879         Parameters
1880         ----------
1881         position : None or .Bbox
1882             If not ``None``, this defines the position of the
1883             Axes within the figure as a Bbox. See `~.Axes.get_position`
1884             for further details.
1885 
1886         Notes
1887         -----
1888         This is called automatically when each Axes is drawn.  You may need
1889         to call it yourself if you need to update the Axes position and/or
1890         view limits before the Figure is drawn.
1891 
1892         See Also
1893         --------
1894         matplotlib.axes.Axes.set_aspect
1895             For a description of aspect ratio handling.
1896         matplotlib.axes.Axes.set_adjustable
1897             Set how the Axes adjusts to achieve the required aspect ratio.
1898         matplotlib.axes.Axes.set_anchor
1899             Set the position in case of extra space.
1900         """
1901         if position is None:
1902             position = self.get_position(original=True)
1903 
1904         aspect = self.get_aspect()
1905 
1906         if aspect == 'auto' and self._box_aspect is None:
1907             self._set_position(position, which='active')
1908             return
1909 
1910         trans = self.get_figure().transSubfigure
1911         bb = mtransforms.Bbox.unit().transformed(trans)
1912         # this is the physical aspect of the panel (or figure):
1913         fig_aspect = bb.height / bb.width
1914 
1915         if self._adjustable == 'box':
1916             if self in self._twinned_axes:
1917                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1918                                    "twinned Axes; use 'datalim' instead")
1919             box_aspect = aspect * self.get_data_ratio()
1920             pb = position.frozen()
1921             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1922             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1923             return
1924 
1925         # The following is only seen if self._adjustable == 'datalim'
1926         if self._box_aspect is not None:
1927             pb = position.frozen()
1928             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1929             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1930             if aspect == "auto":
1931                 return
1932 
1933         # reset active to original in case it had been changed by prior use
1934         # of 'box'
1935         if self._box_aspect is None:
1936             self._set_position(position, which='active')
1937         else:
1938             position = pb1.anchored(self.get_anchor(), pb)
1939 
1940         x_trf = self.xaxis.get_transform()
1941         y_trf = self.yaxis.get_transform()
1942         xmin, xmax = x_trf.transform(self.get_xbound())
1943         ymin, ymax = y_trf.transform(self.get_ybound())
1944         xsize = max(abs(xmax - xmin), 1e-30)
1945         ysize = max(abs(ymax - ymin), 1e-30)
1946 
1947         box_aspect = fig_aspect * (position.height / position.width)
1948         data_ratio = box_aspect / aspect
1949 
1950         y_expander = data_ratio * xsize / ysize - 1
1951         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1952         if abs(y_expander) < 0.005:
1953             return
1954 
1955         dL = self.dataLim
1956         x0, x1 = x_trf.transform(dL.intervalx)
1957         y0, y1 = y_trf.transform(dL.intervaly)
1958         xr = 1.05 * (x1 - x0)
1959         yr = 1.05 * (y1 - y0)
1960 
1961         xmarg = xsize - xr
1962         ymarg = ysize - yr
1963         Ysize = data_ratio * xsize
1964         Xsize = ysize / data_ratio
1965         Xmarg = Xsize - xr
1966         Ymarg = Ysize - yr
1967         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1968         xm = 0
1969         ym = 0
1970 
1971         shared_x = self in self._shared_axes["x"]
1972         shared_y = self in self._shared_axes["y"]
1973 
1974         if shared_x and shared_y:
1975             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1976                                "axis('equal') are not allowed when both axes "
1977                                "are shared.  Try set_aspect(..., "
1978                                "adjustable='box').")
1979 
1980         # If y is shared, then we are only allowed to change x, etc.
1981         if shared_y:
1982             adjust_y = False
1983         else:
1984             if xmarg > xm and ymarg > ym:
1985                 adjy = ((Ymarg > 0 and y_expander < 0) or
1986                         (Xmarg < 0 and y_expander > 0))
1987             else:
1988                 adjy = y_expander > 0
1989             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1990 
1991         if adjust_y:
1992             yc = 0.5 * (ymin + ymax)
1993             y0 = yc - Ysize / 2.0
1994             y1 = yc + Ysize / 2.0
1995             self.set_ybound(y_trf.inverted().transform([y0, y1]))
1996         else:
1997             xc = 0.5 * (xmin + xmax)
1998             x0 = xc - Xsize / 2.0
1999             x1 = xc + Xsize / 2.0
2000             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2001 
2002     def axis(self, arg=None, /, *, emit=True, **kwargs):
2003         """
2004         Convenience method to get or set some axis properties.
2005 
2006         Call signatures::
2007 
2008           xmin, xmax, ymin, ymax = axis()
2009           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2010           xmin, xmax, ymin, ymax = axis(option)
2011           xmin, xmax, ymin, ymax = axis(**kwargs)
2012 
2013         Parameters
2014         ----------
2015         xmin, xmax, ymin, ymax : float, optional
2016             The axis limits to be set.  This can also be achieved using ::
2017 
2018                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2019 
2020         option : bool or str
2021             If a bool, turns axis lines and labels on or off. If a string,
2022             possible values are:
2023 
2024             ======== ==========================================================
2025             Value    Description
2026             ======== ==========================================================
2027             'on'     Turn on axis lines and labels. Same as ``True``.
2028             'off'    Turn off axis lines and labels. Same as ``False``.
2029             'equal'  Set equal scaling (i.e., make circles circular) by
2030                      changing axis limits. This is the same as
2031                      ``ax.set_aspect('equal', adjustable='datalim')``.
2032                      Explicit data limits may not be respected in this case.
2033             'scaled' Set equal scaling (i.e., make circles circular) by
2034                      changing dimensions of the plot box. This is the same as
2035                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2036                      Additionally, further autoscaling will be disabled.
2037             'tight'  Set limits just large enough to show all data, then
2038                      disable further autoscaling.
2039             'auto'   Automatic scaling (fill plot box with data).
2040             'image'  'scaled' with axis limits equal to data limits.
2041             'square' Square plot; similar to 'scaled', but initially forcing
2042                      ``xmax-xmin == ymax-ymin``.
2043             ======== ==========================================================
2044 
2045         emit : bool, default: True
2046             Whether observers are notified of the axis limit change.
2047             This option is passed on to `~.Axes.set_xlim` and
2048             `~.Axes.set_ylim`.
2049 
2050         Returns
2051         -------
2052         xmin, xmax, ymin, ymax : float
2053             The axis limits.
2054 
2055         See Also
2056         --------
2057         matplotlib.axes.Axes.set_xlim
2058         matplotlib.axes.Axes.set_ylim
2059         """
2060         if isinstance(arg, (str, bool)):
2061             if arg is True:
2062                 arg = 'on'
2063             if arg is False:
2064                 arg = 'off'
2065             arg = arg.lower()
2066             if arg == 'on':
2067                 self.set_axis_on()
2068             elif arg == 'off':
2069                 self.set_axis_off()
2070             elif arg in [
2071                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2072                 self.set_autoscale_on(True)
2073                 self.set_aspect('auto')
2074                 self.autoscale_view(tight=False)
2075                 if arg == 'equal':
2076                     self.set_aspect('equal', adjustable='datalim')
2077                 elif arg == 'scaled':
2078                     self.set_aspect('equal', adjustable='box', anchor='C')
2079                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2080                 elif arg == 'tight':
2081                     self.autoscale_view(tight=True)
2082                     self.set_autoscale_on(False)
2083                 elif arg == 'image':
2084                     self.autoscale_view(tight=True)
2085                     self.set_autoscale_on(False)
2086                     self.set_aspect('equal', adjustable='box', anchor='C')
2087                 elif arg == 'square':
2088                     self.set_aspect('equal', adjustable='box', anchor='C')
2089                     self.set_autoscale_on(False)
2090                     xlim = self.get_xlim()
2091                     ylim = self.get_ylim()
2092                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2093                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2094                                   emit=emit, auto=False)
2095                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2096                                   emit=emit, auto=False)
2097             else:
2098                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2099                                  "try 'on' or 'off'")
2100         else:
2101             if arg is not None:
2102                 try:
2103                     xmin, xmax, ymin, ymax = arg
2104                 except (TypeError, ValueError) as err:
2105                     raise TypeError('the first argument to axis() must be an '
2106                                     'iterable of the form '
2107                                     '[xmin, xmax, ymin, ymax]') from err
2108             else:
2109                 xmin = kwargs.pop('xmin', None)
2110                 xmax = kwargs.pop('xmax', None)
2111                 ymin = kwargs.pop('ymin', None)
2112                 ymax = kwargs.pop('ymax', None)
2113             xauto = (None  # Keep autoscale state as is.
2114                      if xmin is None and xmax is None
2115                      else False)  # Turn off autoscale.
2116             yauto = (None
2117                      if ymin is None and ymax is None
2118                      else False)
2119             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2120             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2121         if kwargs:
2122             raise _api.kwarg_error("axis", kwargs)
2123         return (*self.get_xlim(), *self.get_ylim())
2124 
2125     def get_legend(self):
2126         """Return the `.Legend` instance, or None if no legend is defined."""
2127         return self.legend_
2128 
2129     def get_images(self):
2130         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2131         return cbook.silent_list('AxesImage', self.images)
2132 
2133     def get_lines(self):
2134         """Return a list of lines contained by the Axes."""
2135         return cbook.silent_list('Line2D', self.lines)
2136 
2137     def get_xaxis(self):
2138         """
2139         [*Discouraged*] Return the XAxis instance.
2140 
2141         .. admonition:: Discouraged
2142 
2143             The use of this function is discouraged. You should instead
2144             directly access the attribute ``ax.xaxis``.
2145         """
2146         return self.xaxis
2147 
2148     def get_yaxis(self):
2149         """
2150         [*Discouraged*] Return the YAxis instance.
2151 
2152         .. admonition:: Discouraged
2153 
2154             The use of this function is discouraged. You should instead
2155             directly access the attribute ``ax.yaxis``.
2156         """
2157         return self.yaxis
2158 
2159     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2160     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2161     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2162     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2163 
2164     # Adding and tracking artists
2165 
2166     def _sci(self, im):
2167         """
2168         Set the current image.
2169 
2170         This image will be the target of colormap functions like
2171         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2172         current image is an attribute of the current Axes.
2173         """
2174         _api.check_isinstance(
2175             (mpl.contour.ContourSet, mcoll.Collection, mimage.AxesImage),
2176             im=im)
2177         if isinstance(im, mpl.contour.ContourSet):
2178             if im.collections[0] not in self._children:
2179                 raise ValueError("ContourSet must be in current Axes")
2180         elif im not in self._children:
2181             raise ValueError("Argument must be an image, collection, or "
2182                              "ContourSet in this Axes")
2183         self._current_image = im
2184 
2185     def _gci(self):
2186         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2187         return self._current_image
2188 
2189     def has_data(self):
2190         """
2191         Return whether any artists have been added to the Axes.
2192 
2193         This should not be used to determine whether the *dataLim*
2194         need to be updated, and may not actually be useful for
2195         anything.
2196         """
2197         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2198                                   mlines.Line2D, mpatches.Patch))
2199                    for a in self._children)
2200 
2201     def add_artist(self, a):
2202         """
2203         Add an `.Artist` to the Axes; return the artist.
2204 
2205         Use `add_artist` only for artists for which there is no dedicated
2206         "add" method; and if necessary, use a method such as `update_datalim`
2207         to manually update the dataLim if the artist is to be included in
2208         autoscaling.
2209 
2210         If no ``transform`` has been specified when creating the artist (e.g.
2211         ``artist.get_transform() == None``) then the transform is set to
2212         ``ax.transData``.
2213         """
2214         a.axes = self
2215         self._children.append(a)
2216         a._remove_method = self._children.remove
2217         self._set_artist_props(a)
2218         if a.get_clip_path() is None:
2219             a.set_clip_path(self.patch)
2220         self.stale = True
2221         return a
2222 
2223     def add_child_axes(self, ax):
2224         """
2225         Add an `.AxesBase` to the Axes' children; return the child Axes.
2226 
2227         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2228         """
2229 
2230         # normally Axes have themselves as the Axes, but these need to have
2231         # their parent...
2232         # Need to bypass the getter...
2233         ax._axes = self
2234         ax.stale_callback = martist._stale_axes_callback
2235 
2236         self.child_axes.append(ax)
2237         ax._remove_method = self.child_axes.remove
2238         self.stale = True
2239         return ax
2240 
2241     def add_collection(self, collection, autolim=True):
2242         """
2243         Add a `.Collection` to the Axes; return the collection.
2244         """
2245         _api.check_isinstance(mcoll.Collection, collection=collection)
2246         label = collection.get_label()
2247         if not label:
2248             collection.set_label(f'_child{len(self._children)}')
2249         self._children.append(collection)
2250         collection._remove_method = self._children.remove
2251         self._set_artist_props(collection)
2252 
2253         if collection.get_clip_path() is None:
2254             collection.set_clip_path(self.patch)
2255 
2256         if autolim:
2257             # Make sure viewLim is not stale (mostly to match
2258             # pre-lazy-autoscale behavior, which is not really better).
2259             self._unstale_viewLim()
2260             datalim = collection.get_datalim(self.transData)
2261             points = datalim.get_points()
2262             if not np.isinf(datalim.minpos).all():
2263                 # By definition, if minpos (minimum positive value) is set
2264                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2265                 # and minpos would be superfluous. However, we add minpos to
2266                 # the call so that self.dataLim will update its own minpos.
2267                 # This ensures that log scales see the correct minimum.
2268                 points = np.concatenate([points, [datalim.minpos]])
2269             self.update_datalim(points)
2270 
2271         self.stale = True
2272         return collection
2273 
2274     def add_image(self, image):
2275         """
2276         Add an `.AxesImage` to the Axes; return the image.
2277         """
2278         _api.check_isinstance(mimage.AxesImage, image=image)
2279         self._set_artist_props(image)
2280         if not image.get_label():
2281             image.set_label(f'_child{len(self._children)}')
2282         self._children.append(image)
2283         image._remove_method = self._children.remove
2284         self.stale = True
2285         return image
2286 
2287     def _update_image_limits(self, image):
2288         xmin, xmax, ymin, ymax = image.get_extent()
2289         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2290 
2291     def add_line(self, line):
2292         """
2293         Add a `.Line2D` to the Axes; return the line.
2294         """
2295         _api.check_isinstance(mlines.Line2D, line=line)
2296         self._set_artist_props(line)
2297         if line.get_clip_path() is None:
2298             line.set_clip_path(self.patch)
2299 
2300         self._update_line_limits(line)
2301         if not line.get_label():
2302             line.set_label(f'_child{len(self._children)}')
2303         self._children.append(line)
2304         line._remove_method = self._children.remove
2305         self.stale = True
2306         return line
2307 
2308     def _add_text(self, txt):
2309         """
2310         Add a `.Text` to the Axes; return the text.
2311         """
2312         _api.check_isinstance(mtext.Text, txt=txt)
2313         self._set_artist_props(txt)
2314         self._children.append(txt)
2315         txt._remove_method = self._children.remove
2316         self.stale = True
2317         return txt
2318 
2319     def _update_line_limits(self, line):
2320         """
2321         Figures out the data limit of the given line, updating self.dataLim.
2322         """
2323         path = line.get_path()
2324         if path.vertices.size == 0:
2325             return
2326 
2327         line_trf = line.get_transform()
2328 
2329         if line_trf == self.transData:
2330             data_path = path
2331         elif any(line_trf.contains_branch_seperately(self.transData)):
2332             # Compute the transform from line coordinates to data coordinates.
2333             trf_to_data = line_trf - self.transData
2334             # If transData is affine we can use the cached non-affine component
2335             # of line's path (since the non-affine part of line_trf is
2336             # entirely encapsulated in trf_to_data).
2337             if self.transData.is_affine:
2338                 line_trans_path = line._get_transformed_path()
2339                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2340                 data_path = trf_to_data.transform_path_affine(na_path)
2341             else:
2342                 data_path = trf_to_data.transform_path(path)
2343         else:
2344             # For backwards compatibility we update the dataLim with the
2345             # coordinate range of the given path, even though the coordinate
2346             # systems are completely different. This may occur in situations
2347             # such as when ax.transAxes is passed through for absolute
2348             # positioning.
2349             data_path = path
2350 
2351         if not data_path.vertices.size:
2352             return
2353 
2354         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2355         if self.name != "rectilinear":
2356             # This block is mostly intended to handle axvline in polar plots,
2357             # for which updatey would otherwise be True.
2358             if updatex and line_trf == self.get_yaxis_transform():
2359                 updatex = False
2360             if updatey and line_trf == self.get_xaxis_transform():
2361                 updatey = False
2362         self.dataLim.update_from_path(data_path,
2363                                       self.ignore_existing_data_limits,
2364                                       updatex=updatex, updatey=updatey)
2365         self.ignore_existing_data_limits = False
2366 
2367     def add_patch(self, p):
2368         """
2369         Add a `.Patch` to the Axes; return the patch.
2370         """
2371         _api.check_isinstance(mpatches.Patch, p=p)
2372         self._set_artist_props(p)
2373         if p.get_clip_path() is None:
2374             p.set_clip_path(self.patch)
2375         self._update_patch_limits(p)
2376         self._children.append(p)
2377         p._remove_method = self._children.remove
2378         return p
2379 
2380     def _update_patch_limits(self, patch):
2381         """Update the data limits for the given patch."""
2382         # hist can add zero height Rectangles, which is useful to keep
2383         # the bins, counts and patches lined up, but it throws off log
2384         # scaling.  We'll ignore rects with zero height or width in
2385         # the auto-scaling
2386 
2387         # cannot check for '==0' since unitized data may not compare to zero
2388         # issue #2150 - we update the limits if patch has non zero width
2389         # or height.
2390         if (isinstance(patch, mpatches.Rectangle) and
2391                 ((not patch.get_width()) and (not patch.get_height()))):
2392             return
2393         p = patch.get_path()
2394         # Get all vertices on the path
2395         # Loop through each segment to get extrema for Bezier curve sections
2396         vertices = []
2397         for curve, code in p.iter_bezier(simplify=False):
2398             # Get distance along the curve of any extrema
2399             _, dzeros = curve.axis_aligned_extrema()
2400             # Calculate vertices of start, end and any extrema in between
2401             vertices.append(curve([0, *dzeros, 1]))
2402 
2403         if len(vertices):
2404             vertices = np.row_stack(vertices)
2405 
2406         patch_trf = patch.get_transform()
2407         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2408         if not (updatex or updatey):
2409             return
2410         if self.name != "rectilinear":
2411             # As in _update_line_limits, but for axvspan.
2412             if updatex and patch_trf == self.get_yaxis_transform():
2413                 updatex = False
2414             if updatey and patch_trf == self.get_xaxis_transform():
2415                 updatey = False
2416         trf_to_data = patch_trf - self.transData
2417         xys = trf_to_data.transform(vertices)
2418         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2419 
2420     def add_table(self, tab):
2421         """
2422         Add a `.Table` to the Axes; return the table.
2423         """
2424         _api.check_isinstance(mtable.Table, tab=tab)
2425         self._set_artist_props(tab)
2426         self._children.append(tab)
2427         if tab.get_clip_path() is None:
2428             tab.set_clip_path(self.patch)
2429         tab._remove_method = self._children.remove
2430         return tab
2431 
2432     def add_container(self, container):
2433         """
2434         Add a `.Container` to the Axes' containers; return the container.
2435         """
2436         label = container.get_label()
2437         if not label:
2438             container.set_label('_container%d' % len(self.containers))
2439         self.containers.append(container)
2440         container._remove_method = self.containers.remove
2441         return container
2442 
2443     def _unit_change_handler(self, axis_name, event=None):
2444         """
2445         Process axis units changes: requests updates to data and view limits.
2446         """
2447         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2448             return functools.partial(
2449                 self._unit_change_handler, axis_name, event=object())
2450         _api.check_in_list(self._axis_map, axis_name=axis_name)
2451         for line in self.lines:
2452             line.recache_always()
2453         self.relim()
2454         self._request_autoscale_view(axis_name)
2455 
2456     def relim(self, visible_only=False):
2457         """
2458         Recompute the data limits based on current artists.
2459 
2460         At present, `.Collection` instances are not supported.
2461 
2462         Parameters
2463         ----------
2464         visible_only : bool, default: False
2465             Whether to exclude invisible artists.
2466         """
2467         # Collections are deliberately not supported (yet); see
2468         # the TODO note in artists.py.
2469         self.dataLim.ignore(True)
2470         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2471         self.ignore_existing_data_limits = True
2472 
2473         for artist in self._children:
2474             if not visible_only or artist.get_visible():
2475                 if isinstance(artist, mlines.Line2D):
2476                     self._update_line_limits(artist)
2477                 elif isinstance(artist, mpatches.Patch):
2478                     self._update_patch_limits(artist)
2479                 elif isinstance(artist, mimage.AxesImage):
2480                     self._update_image_limits(artist)
2481 
2482     def update_datalim(self, xys, updatex=True, updatey=True):
2483         """
2484         Extend the `~.Axes.dataLim` Bbox to include the given points.
2485 
2486         If no data is set currently, the Bbox will ignore its limits and set
2487         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2488         compute the bounds of the union of its current data and the data in
2489         *xys*.
2490 
2491         Parameters
2492         ----------
2493         xys : 2D array-like
2494             The points to include in the data limits Bbox. This can be either
2495             a list of (x, y) tuples or a (N, 2) array.
2496 
2497         updatex, updatey : bool, default: True
2498             Whether to update the x/y limits.
2499         """
2500         xys = np.asarray(xys)
2501         if not np.any(np.isfinite(xys)):
2502             return
2503         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2504                                          updatex=updatex, updatey=updatey)
2505         self.ignore_existing_data_limits = False
2506 
2507     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2508         """
2509         Set axis units based on *datasets* and *kwargs*, and optionally apply
2510         unit conversions to *datasets*.
2511 
2512         Parameters
2513         ----------
2514         datasets : list
2515             List of (axis_name, dataset) pairs (where the axis name is defined
2516             as in `._axis_map`).  Individual datasets can also be None
2517             (which gets passed through).
2518         kwargs : dict
2519             Other parameters from which unit info (i.e., the *xunits*,
2520             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2521             polar) entries) is popped, if present.  Note that this dict is
2522             mutated in-place!
2523         convert : bool, default: True
2524             Whether to return the original datasets or the converted ones.
2525 
2526         Returns
2527         -------
2528         list
2529             Either the original datasets if *convert* is False, or the
2530             converted ones if *convert* is True (the default).
2531         """
2532         # The API makes datasets a list of pairs rather than an axis_name to
2533         # dataset mapping because it is sometimes necessary to process multiple
2534         # datasets for a single axis, and concatenating them may be tricky
2535         # (e.g. if some are scalars, etc.).
2536         datasets = datasets or []
2537         kwargs = kwargs or {}
2538         axis_map = self._axis_map
2539         for axis_name, data in datasets:
2540             try:
2541                 axis = axis_map[axis_name]
2542             except KeyError:
2543                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2544             # Update from data if axis is already set but no unit is set yet.
2545             if axis is not None and data is not None and not axis.have_units():
2546                 axis.update_units(data)
2547         for axis_name, axis in axis_map.items():
2548             # Return if no axis is set.
2549             if axis is None:
2550                 continue
2551             # Check for units in the kwargs, and if present update axis.
2552             units = kwargs.pop(f"{axis_name}units", axis.units)
2553             if self.name == "polar":
2554                 # Special case: polar supports "thetaunits"/"runits".
2555                 polar_units = {"x": "thetaunits", "y": "runits"}
2556                 units = kwargs.pop(polar_units[axis_name], units)
2557             if units != axis.units and units is not None:
2558                 axis.set_units(units)
2559                 # If the units being set imply a different converter,
2560                 # we need to update again.
2561                 for dataset_axis_name, data in datasets:
2562                     if dataset_axis_name == axis_name and data is not None:
2563                         axis.update_units(data)
2564         return [axis_map[axis_name].convert_units(data)
2565                 if convert and data is not None else data
2566                 for axis_name, data in datasets]
2567 
2568     def in_axes(self, mouseevent):
2569         """
2570         Return whether the given event (in display coords) is in the Axes.
2571         """
2572         return self.patch.contains(mouseevent)[0]
2573 
2574     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2575     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2576     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2577     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2578 
2579     def get_autoscale_on(self):
2580         """Return True if each axis is autoscaled, False otherwise."""
2581         return all(axis._get_autoscale_on()
2582                    for axis in self._axis_map.values())
2583 
2584     def set_autoscale_on(self, b):
2585         """
2586         Set whether autoscaling is applied to each axis on the next draw or
2587         call to `.Axes.autoscale_view`.
2588 
2589         Parameters
2590         ----------
2591         b : bool
2592         """
2593         for axis in self._axis_map.values():
2594             axis._set_autoscale_on(b)
2595 
2596     @property
2597     def use_sticky_edges(self):
2598         """
2599         When autoscaling, whether to obey all `Artist.sticky_edges`.
2600 
2601         Default is ``True``.
2602 
2603         Setting this to ``False`` ensures that the specified margins
2604         will be applied, even if the plot includes an image, for
2605         example, which would otherwise force a view limit to coincide
2606         with its data limit.
2607 
2608         The changing this property does not change the plot until
2609         `autoscale` or `autoscale_view` is called.
2610         """
2611         return self._use_sticky_edges
2612 
2613     @use_sticky_edges.setter
2614     def use_sticky_edges(self, b):
2615         self._use_sticky_edges = bool(b)
2616         # No effect until next autoscaling, which will mark the Axes as stale.
2617 
2618     def set_xmargin(self, m):
2619         """
2620         Set padding of X data limits prior to autoscaling.
2621 
2622         *m* times the data interval will be added to each end of that interval
2623         before it is used in autoscaling.  If *m* is negative, this will clip
2624         the data range instead of expanding it.
2625 
2626         For example, if your data is in the range [0, 2], a margin of 0.1 will
2627         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2628         of [0.2, 1.8].
2629 
2630         Parameters
2631         ----------
2632         m : float greater than -0.5
2633         """
2634         if m <= -0.5:
2635             raise ValueError("margin must be greater than -0.5")
2636         self._xmargin = m
2637         self._request_autoscale_view("x")
2638         self.stale = True
2639 
2640     def set_ymargin(self, m):
2641         """
2642         Set padding of Y data limits prior to autoscaling.
2643 
2644         *m* times the data interval will be added to each end of that interval
2645         before it is used in autoscaling.  If *m* is negative, this will clip
2646         the data range instead of expanding it.
2647 
2648         For example, if your data is in the range [0, 2], a margin of 0.1 will
2649         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2650         of [0.2, 1.8].
2651 
2652         Parameters
2653         ----------
2654         m : float greater than -0.5
2655         """
2656         if m <= -0.5:
2657             raise ValueError("margin must be greater than -0.5")
2658         self._ymargin = m
2659         self._request_autoscale_view("y")
2660         self.stale = True
2661 
2662     def margins(self, *margins, x=None, y=None, tight=True):
2663         """
2664         Set or retrieve autoscaling margins.
2665 
2666         The padding added to each limit of the Axes is the *margin*
2667         times the data interval. All input parameters must be floats
2668         within the range [0, 1]. Passing both positional and keyword
2669         arguments is invalid and will raise a TypeError. If no
2670         arguments (positional or otherwise) are provided, the current
2671         margins will remain in place and simply be returned.
2672 
2673         Specifying any margin changes only the autoscaling; for example,
2674         if *xmargin* is not None, then *xmargin* times the X data
2675         interval will be added to each end of that interval before
2676         it is used in autoscaling.
2677 
2678         Parameters
2679         ----------
2680         *margins : float, optional
2681             If a single positional argument is provided, it specifies
2682             both margins of the x-axis and y-axis limits. If two
2683             positional arguments are provided, they will be interpreted
2684             as *xmargin*, *ymargin*. If setting the margin on a single
2685             axis is desired, use the keyword arguments described below.
2686 
2687         x, y : float, optional
2688             Specific margin values for the x-axis and y-axis,
2689             respectively. These cannot be used with positional
2690             arguments, but can be used individually to alter on e.g.,
2691             only the y-axis.
2692 
2693         tight : bool or None, default: True
2694             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2695             which is executed after a margin is changed; the default
2696             here is *True*, on the assumption that when margins are
2697             specified, no additional padding to match tick marks is
2698             usually desired.  Setting *tight* to *None* preserves
2699             the previous setting.
2700 
2701         Returns
2702         -------
2703         xmargin, ymargin : float
2704 
2705         Notes
2706         -----
2707         If a previously used Axes method such as :meth:`pcolor` has set
2708         :attr:`use_sticky_edges` to `True`, only the limits not set by
2709         the "sticky artists" will be modified. To force all of the
2710         margins to be set, set :attr:`use_sticky_edges` to `False`
2711         before calling :meth:`margins`.
2712         """
2713 
2714         if margins and (x is not None or y is not None):
2715             raise TypeError('Cannot pass both positional and keyword '
2716                             'arguments for x and/or y.')
2717         elif len(margins) == 1:
2718             x = y = margins[0]
2719         elif len(margins) == 2:
2720             x, y = margins
2721         elif margins:
2722             raise TypeError('Must pass a single positional argument for all '
2723                             'margins, or one for each margin (x, y).')
2724 
2725         if x is None and y is None:
2726             if tight is not True:
2727                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2728             return self._xmargin, self._ymargin
2729 
2730         if tight is not None:
2731             self._tight = tight
2732         if x is not None:
2733             self.set_xmargin(x)
2734         if y is not None:
2735             self.set_ymargin(y)
2736 
2737     def set_rasterization_zorder(self, z):
2738         """
2739         Set the zorder threshold for rasterization for vector graphics output.
2740 
2741         All artists with a zorder below the given value will be rasterized if
2742         they support rasterization.
2743 
2744         This setting is ignored for pixel-based output.
2745 
2746         See also :doc:`/gallery/misc/rasterization_demo`.
2747 
2748         Parameters
2749         ----------
2750         z : float or None
2751             The zorder below which artists are rasterized.
2752             If ``None`` rasterization based on zorder is deactivated.
2753         """
2754         self._rasterization_zorder = z
2755         self.stale = True
2756 
2757     def get_rasterization_zorder(self):
2758         """Return the zorder value below which artists will be rasterized."""
2759         return self._rasterization_zorder
2760 
2761     def autoscale(self, enable=True, axis='both', tight=None):
2762         """
2763         Autoscale the axis view to the data (toggle).
2764 
2765         Convenience method for simple axis view autoscaling.
2766         It turns autoscaling on or off, and then,
2767         if autoscaling for either axis is on, it performs
2768         the autoscaling on the specified axis or Axes.
2769 
2770         Parameters
2771         ----------
2772         enable : bool or None, default: True
2773             True turns autoscaling on, False turns it off.
2774             None leaves the autoscaling state unchanged.
2775         axis : {'both', 'x', 'y'}, default: 'both'
2776             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2777             to 'z', and 'both' refers to all three axes.)
2778         tight : bool or None, default: None
2779             If True, first set the margins to zero.  Then, this argument is
2780             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2781             its value); see the description of its behavior there.
2782         """
2783         if enable is None:
2784             scalex = True
2785             scaley = True
2786         else:
2787             if axis in ['x', 'both']:
2788                 self.set_autoscalex_on(bool(enable))
2789                 scalex = self.get_autoscalex_on()
2790             else:
2791                 scalex = False
2792             if axis in ['y', 'both']:
2793                 self.set_autoscaley_on(bool(enable))
2794                 scaley = self.get_autoscaley_on()
2795             else:
2796                 scaley = False
2797         if tight and scalex:
2798             self._xmargin = 0
2799         if tight and scaley:
2800             self._ymargin = 0
2801         if scalex:
2802             self._request_autoscale_view("x", tight=tight)
2803         if scaley:
2804             self._request_autoscale_view("y", tight=tight)
2805 
2806     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2807         """
2808         Autoscale the view limits using the data limits.
2809 
2810         Parameters
2811         ----------
2812         tight : bool or None
2813             If *True*, only expand the axis limits using the margins.  Note
2814             that unlike for `autoscale`, ``tight=True`` does *not* set the
2815             margins to zero.
2816 
2817             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2818             after expansion by the margins, further expand the axis limits
2819             using the axis major locator.
2820 
2821             If None (the default), reuse the value set in the previous call to
2822             `autoscale_view` (the initial value is False, but the default style
2823             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2824             behaves like True).
2825 
2826         scalex : bool, default: True
2827             Whether to autoscale the x-axis.
2828 
2829         scaley : bool, default: True
2830             Whether to autoscale the y-axis.
2831 
2832         Notes
2833         -----
2834         The autoscaling preserves any preexisting axis direction reversal.
2835 
2836         The data limits are not updated automatically when artist data are
2837         changed after the artist has been added to an Axes instance.  In that
2838         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2839         autoscale_view.
2840 
2841         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2842         not be changed by autoscale_view().
2843         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2844         """
2845         if tight is not None:
2846             self._tight = bool(tight)
2847 
2848         x_stickies = y_stickies = np.array([])
2849         if self.use_sticky_edges:
2850             if self._xmargin and scalex and self.get_autoscalex_on():
2851                 x_stickies = np.sort(np.concatenate([
2852                     artist.sticky_edges.x
2853                     for ax in self._shared_axes["x"].get_siblings(self)
2854                     for artist in ax.get_children()]))
2855             if self._ymargin and scaley and self.get_autoscaley_on():
2856                 y_stickies = np.sort(np.concatenate([
2857                     artist.sticky_edges.y
2858                     for ax in self._shared_axes["y"].get_siblings(self)
2859                     for artist in ax.get_children()]))
2860         if self.get_xscale() == 'log':
2861             x_stickies = x_stickies[x_stickies > 0]
2862         if self.get_yscale() == 'log':
2863             y_stickies = y_stickies[y_stickies > 0]
2864 
2865         def handle_single_axis(
2866                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2867 
2868             if not (scale and axis._get_autoscale_on()):
2869                 return  # nothing to do...
2870 
2871             shared = shared_axes.get_siblings(self)
2872             # Base autoscaling on finite data limits when there is at least one
2873             # finite data limit among all the shared_axes and intervals.
2874             values = [val for ax in shared
2875                       for val in getattr(ax.dataLim, f"interval{name}")
2876                       if np.isfinite(val)]
2877             if values:
2878                 x0, x1 = (min(values), max(values))
2879             elif getattr(self._viewLim, f"mutated{name}")():
2880                 # No data, but explicit viewLims already set:
2881                 # in mutatedx or mutatedy.
2882                 return
2883             else:
2884                 x0, x1 = (-np.inf, np.inf)
2885             # If x0 and x1 are nonfinite, get default limits from the locator.
2886             locator = axis.get_major_locator()
2887             x0, x1 = locator.nonsingular(x0, x1)
2888             # Find the minimum minpos for use in the margin calculation.
2889             minimum_minpos = min(
2890                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2891 
2892             # Prevent margin addition from crossing a sticky value.  A small
2893             # tolerance must be added due to floating point issues with
2894             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2895             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2896             # datasets where all values are tiny (less than 1e-8).
2897             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2898             # Index of largest element < x0 + tol, if any.
2899             i0 = stickies.searchsorted(x0 + tol) - 1
2900             x0bound = stickies[i0] if i0 != -1 else None
2901             # Index of smallest element > x1 - tol, if any.
2902             i1 = stickies.searchsorted(x1 - tol)
2903             x1bound = stickies[i1] if i1 != len(stickies) else None
2904 
2905             # Add the margin in figure space and then transform back, to handle
2906             # non-linear scales.
2907             transform = axis.get_transform()
2908             inverse_trans = transform.inverted()
2909             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2910             x0t, x1t = transform.transform([x0, x1])
2911             delta = (x1t - x0t) * margin
2912             if not np.isfinite(delta):
2913                 delta = 0  # If a bound isn't finite, set margin to zero.
2914             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2915 
2916             # Apply sticky bounds.
2917             if x0bound is not None:
2918                 x0 = max(x0, x0bound)
2919             if x1bound is not None:
2920                 x1 = min(x1, x1bound)
2921 
2922             if not self._tight:
2923                 x0, x1 = locator.view_limits(x0, x1)
2924             set_bound(x0, x1)
2925             # End of definition of internal function 'handle_single_axis'.
2926 
2927         handle_single_axis(
2928             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2929             x_stickies, self.set_xbound)
2930         handle_single_axis(
2931             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2932             y_stickies, self.set_ybound)
2933 
2934     def _update_title_position(self, renderer):
2935         """
2936         Update the title position based on the bounding box enclosing
2937         all the ticklabels and x-axis spine and xlabel...
2938         """
2939         if self._autotitlepos is not None and not self._autotitlepos:
2940             _log.debug('title position was updated manually, not adjusting')
2941             return
2942 
2943         titles = (self.title, self._left_title, self._right_title)
2944 
2945         # Need to check all our twins too, and all the children as well.
2946         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2947         for ax in self.child_axes:  # Child positions must be updated first.
2948             locator = ax.get_axes_locator()
2949             ax.apply_aspect(locator(self, renderer) if locator else None)
2950 
2951         for title in titles:
2952             x, _ = title.get_position()
2953             # need to start again in case of window resizing
2954             title.set_position((x, 1.0))
2955             top = -np.inf
2956             for ax in axs:
2957                 bb = None
2958                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2959                         or ax.xaxis.get_label_position() == 'top'):
2960                     bb = ax.xaxis.get_tightbbox(renderer)
2961                 if bb is None:
2962                     if 'outline' in ax.spines:
2963                         # Special case for colorbars:
2964                         bb = ax.spines['outline'].get_window_extent()
2965                     else:
2966                         bb = ax.get_window_extent(renderer)
2967                 top = max(top, bb.ymax)
2968                 if title.get_text():
2969                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2970                     if ax.yaxis.offsetText.get_text():
2971                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2972                         if bb.intersection(title.get_tightbbox(renderer), bb):
2973                             top = bb.ymax
2974             if top < 0:
2975                 # the top of Axes is not even on the figure, so don't try and
2976                 # automatically place it.
2977                 _log.debug('top of Axes not in the figure, so title not moved')
2978                 return
2979             if title.get_window_extent(renderer).ymin < top:
2980                 _, y = self.transAxes.inverted().transform((0, top))
2981                 title.set_position((x, y))
2982                 # empirically, this doesn't always get the min to top,
2983                 # so we need to adjust again.
2984                 if title.get_window_extent(renderer).ymin < top:
2985                     _, y = self.transAxes.inverted().transform(
2986                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2987                     title.set_position((x, y))
2988 
2989         ymax = max(title.get_position()[1] for title in titles)
2990         for title in titles:
2991             # now line up all the titles at the highest baseline.
2992             x, _ = title.get_position()
2993             title.set_position((x, ymax))
2994 
2995     # Drawing
2996     @martist.allow_rasterization
2997     def draw(self, renderer):
2998         # docstring inherited
2999         if renderer is None:
3000             raise RuntimeError('No renderer defined')
3001         if not self.get_visible():
3002             return
3003         self._unstale_viewLim()
3004 
3005         renderer.open_group('axes', gid=self.get_gid())
3006 
3007         # prevent triggering call backs during the draw process
3008         self._stale = True
3009 
3010         # loop over self and child Axes...
3011         locator = self.get_axes_locator()
3012         self.apply_aspect(locator(self, renderer) if locator else None)
3013 
3014         artists = self.get_children()
3015         artists.remove(self.patch)
3016 
3017         # the frame draws the edges around the Axes patch -- we
3018         # decouple these so the patch can be in the background and the
3019         # frame in the foreground. Do this before drawing the axis
3020         # objects so that the spine has the opportunity to update them.
3021         if not (self.axison and self._frameon):
3022             for spine in self.spines.values():
3023                 artists.remove(spine)
3024 
3025         self._update_title_position(renderer)
3026 
3027         if not self.axison:
3028             for _axis in self._axis_map.values():
3029                 artists.remove(_axis)
3030 
3031         if not self.figure.canvas.is_saving():
3032             artists = [
3033                 a for a in artists
3034                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3035         artists = sorted(artists, key=attrgetter('zorder'))
3036 
3037         # rasterize artists with negative zorder
3038         # if the minimum zorder is negative, start rasterization
3039         rasterization_zorder = self._rasterization_zorder
3040 
3041         if (rasterization_zorder is not None and
3042                 artists and artists[0].zorder < rasterization_zorder):
3043             split_index = np.searchsorted(
3044                 [art.zorder for art in artists],
3045                 rasterization_zorder, side='right'
3046             )
3047             artists_rasterized = artists[:split_index]
3048             artists = artists[split_index:]
3049         else:
3050             artists_rasterized = []
3051 
3052         if self.axison and self._frameon:
3053             if artists_rasterized:
3054                 artists_rasterized = [self.patch] + artists_rasterized
3055             else:
3056                 artists = [self.patch] + artists
3057 
3058         if artists_rasterized:
3059             _draw_rasterized(self.figure, artists_rasterized, renderer)
3060 
3061         mimage._draw_list_compositing_images(
3062             renderer, self, artists, self.figure.suppressComposite)
3063 
3064         renderer.close_group('axes')
3065         self.stale = False
3066 
3067     def draw_artist(self, a):
3068         """
3069         Efficiently redraw a single artist.
3070         """
3071         a.draw(self.figure.canvas.get_renderer())
3072 
3073     def redraw_in_frame(self):
3074         """
3075         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3076         """
3077         with ExitStack() as stack:
3078             for artist in [*self._axis_map.values(),
3079                            self.title, self._left_title, self._right_title]:
3080                 stack.enter_context(artist._cm_set(visible=False))
3081             self.draw(self.figure.canvas.get_renderer())
3082 
3083     # Axes rectangle characteristics
3084 
3085     def get_frame_on(self):
3086         """Get whether the Axes rectangle patch is drawn."""
3087         return self._frameon
3088 
3089     def set_frame_on(self, b):
3090         """
3091         Set whether the Axes rectangle patch is drawn.
3092 
3093         Parameters
3094         ----------
3095         b : bool
3096         """
3097         self._frameon = b
3098         self.stale = True
3099 
3100     def get_axisbelow(self):
3101         """
3102         Get whether axis ticks and gridlines are above or below most artists.
3103 
3104         Returns
3105         -------
3106         bool or 'line'
3107 
3108         See Also
3109         --------
3110         set_axisbelow
3111         """
3112         return self._axisbelow
3113 
3114     def set_axisbelow(self, b):
3115         """
3116         Set whether axis ticks and gridlines are above or below most artists.
3117 
3118         This controls the zorder of the ticks and gridlines. For more
3119         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3120 
3121         Parameters
3122         ----------
3123         b : bool or 'line'
3124             Possible values:
3125 
3126             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3127             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3128               (e.g. rectangles, with default zorder = 1) but still below lines
3129               and markers (with their default zorder = 2).
3130             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3131               and lines / markers.
3132 
3133         See Also
3134         --------
3135         get_axisbelow
3136         """
3137         # Check that b is True, False or 'line'
3138         self._axisbelow = axisbelow = validate_axisbelow(b)
3139         zorder = {
3140             True: 0.5,
3141             'line': 1.5,
3142             False: 2.5,
3143         }[axisbelow]
3144         for axis in self._axis_map.values():
3145             axis.set_zorder(zorder)
3146         self.stale = True
3147 
3148     @_docstring.dedent_interpd
3149     def grid(self, visible=None, which='major', axis='both', **kwargs):
3150         """
3151         Configure the grid lines.
3152 
3153         Parameters
3154         ----------
3155         visible : bool or None, optional
3156             Whether to show the grid lines.  If any *kwargs* are supplied, it
3157             is assumed you want the grid on and *visible* will be set to True.
3158 
3159             If *visible* is *None* and there are no *kwargs*, this toggles the
3160             visibility of the lines.
3161 
3162         which : {'major', 'minor', 'both'}, optional
3163             The grid lines to apply the changes on.
3164 
3165         axis : {'both', 'x', 'y'}, optional
3166             The axis to apply the changes on.
3167 
3168         **kwargs : `.Line2D` properties
3169             Define the line properties of the grid, e.g.::
3170 
3171                 grid(color='r', linestyle='-', linewidth=2)
3172 
3173             Valid keyword arguments are:
3174 
3175             %(Line2D:kwdoc)s
3176 
3177         Notes
3178         -----
3179         The axis is drawn as a unit, so the effective zorder for drawing the
3180         grid is determined by the zorder of each axis, not by the zorder of the
3181         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3182         use `.set_axisbelow` or, for more control, call the
3183         `~.Artist.set_zorder` method of each axis.
3184         """
3185         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3186         if axis in ['x', 'both']:
3187             self.xaxis.grid(visible, which=which, **kwargs)
3188         if axis in ['y', 'both']:
3189             self.yaxis.grid(visible, which=which, **kwargs)
3190 
3191     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3192                          useOffset=None, useLocale=None, useMathText=None):
3193         r"""
3194         Configure the `.ScalarFormatter` used by default for linear Axes.
3195 
3196         If a parameter is not set, the corresponding property of the formatter
3197         is left unchanged.
3198 
3199         Parameters
3200         ----------
3201         axis : {'x', 'y', 'both'}, default: 'both'
3202             The axis to configure.  Only major ticks are affected.
3203 
3204         style : {'sci', 'scientific', 'plain'}
3205             Whether to use scientific notation.
3206             The formatter default is to use scientific notation.
3207 
3208         scilimits : pair of ints (m, n)
3209             Scientific notation is used only for numbers outside the range
3210             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3211             configured to use scientific notation at all).  Use (0, 0) to
3212             include all numbers.  Use (m, m) where m != 0 to fix the order of
3213             magnitude to 10\ :sup:`m`.
3214             The formatter default is :rc:`axes.formatter.limits`.
3215 
3216         useOffset : bool or float
3217             If True, the offset is calculated as needed.
3218             If False, no offset is used.
3219             If a numeric value, it sets the offset.
3220             The formatter default is :rc:`axes.formatter.useoffset`.
3221 
3222         useLocale : bool
3223             Whether to format the number using the current locale or using the
3224             C (English) locale.  This affects e.g. the decimal separator.  The
3225             formatter default is :rc:`axes.formatter.use_locale`.
3226 
3227         useMathText : bool
3228             Render the offset and scientific notation in mathtext.
3229             The formatter default is :rc:`axes.formatter.use_mathtext`.
3230 
3231         Raises
3232         ------
3233         AttributeError
3234             If the current formatter is not a `.ScalarFormatter`.
3235         """
3236         style = style.lower()
3237         axis = axis.lower()
3238         if scilimits is not None:
3239             try:
3240                 m, n = scilimits
3241                 m + n + 1  # check that both are numbers
3242             except (ValueError, TypeError) as err:
3243                 raise ValueError("scilimits must be a sequence of 2 integers"
3244                                  ) from err
3245         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3246         is_sci_style = _api.check_getitem(STYLES, style=style)
3247         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3248                     'both': list(self._axis_map.values())}
3249         axises = _api.check_getitem(axis_map, axis=axis)
3250         try:
3251             for axis in axises:
3252                 if is_sci_style is not None:
3253                     axis.major.formatter.set_scientific(is_sci_style)
3254                 if scilimits is not None:
3255                     axis.major.formatter.set_powerlimits(scilimits)
3256                 if useOffset is not None:
3257                     axis.major.formatter.set_useOffset(useOffset)
3258                 if useLocale is not None:
3259                     axis.major.formatter.set_useLocale(useLocale)
3260                 if useMathText is not None:
3261                     axis.major.formatter.set_useMathText(useMathText)
3262         except AttributeError as err:
3263             raise AttributeError(
3264                 "This method only works with the ScalarFormatter") from err
3265 
3266     def locator_params(self, axis='both', tight=None, **kwargs):
3267         """
3268         Control behavior of major tick locators.
3269 
3270         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3271         is called automatically after the parameters are changed.
3272 
3273         Parameters
3274         ----------
3275         axis : {'both', 'x', 'y'}, default: 'both'
3276             The axis on which to operate.  (For 3D Axes, *axis* can also be
3277             set to 'z', and 'both' refers to all three axes.)
3278         tight : bool or None, optional
3279             Parameter passed to `~.Axes.autoscale_view`.
3280             Default is None, for no change.
3281 
3282         Other Parameters
3283         ----------------
3284         **kwargs
3285             Remaining keyword arguments are passed to directly to the
3286             ``set_params()`` method of the locator. Supported keywords depend
3287             on the type of the locator. See for example
3288             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3289             used by default for linear.
3290 
3291         Examples
3292         --------
3293         When plotting small subplots, one might want to reduce the maximum
3294         number of ticks and use tight bounds, for example::
3295 
3296             ax.locator_params(tight=True, nbins=4)
3297 
3298         """
3299         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3300         for name in self._axis_names:
3301             if axis in [name, "both"]:
3302                 loc = self._axis_map[name].get_major_locator()
3303                 loc.set_params(**kwargs)
3304                 self._request_autoscale_view(name, tight=tight)
3305         self.stale = True
3306 
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)
3386 
3387     def set_axis_off(self):
3388         """
3389         Turn the x- and y-axis off.
3390 
3391         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3392         """
3393         self.axison = False
3394         self.stale = True
3395 
3396     def set_axis_on(self):
3397         """
3398         Turn the x- and y-axis on.
3399 
3400         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3401         """
3402         self.axison = True
3403         self.stale = True
3404 
3405     # data limits, ticks, tick labels, and formatting
3406 
3407     def get_xlabel(self):
3408         """
3409         Get the xlabel text string.
3410         """
3411         label = self.xaxis.get_label()
3412         return label.get_text()
3413 
3414     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3415                    loc=None, **kwargs):
3416         """
3417         Set the label for the x-axis.
3418 
3419         Parameters
3420         ----------
3421         xlabel : str
3422             The label text.
3423 
3424         labelpad : float, default: :rc:`axes.labelpad`
3425             Spacing in points from the Axes bounding box including ticks
3426             and tick labels.  If None, the previous value is left as is.
3427 
3428         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3429             The label position. This is a high-level alternative for passing
3430             parameters *x* and *horizontalalignment*.
3431 
3432         Other Parameters
3433         ----------------
3434         **kwargs : `.Text` properties
3435             `.Text` properties control the appearance of the label.
3436 
3437         See Also
3438         --------
3439         text : Documents the properties supported by `.Text`.
3440         """
3441         if labelpad is not None:
3442             self.xaxis.labelpad = labelpad
3443         protected_kw = ['x', 'horizontalalignment', 'ha']
3444         if {*kwargs} & {*protected_kw}:
3445             if loc is not None:
3446                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3447                                 f"its corresponding low level keyword "
3448                                 f"arguments ({protected_kw}) are also "
3449                                 f"supplied")
3450 
3451         else:
3452             loc = (loc if loc is not None
3453                    else mpl.rcParams['xaxis.labellocation'])
3454             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3455 
3456             x = {
3457                 'left': 0,
3458                 'center': 0.5,
3459                 'right': 1,
3460             }[loc]
3461             kwargs.update(x=x, horizontalalignment=loc)
3462 
3463         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3464 
3465     def invert_xaxis(self):
3466         """
3467         Invert the x-axis.
3468 
3469         See Also
3470         --------
3471         xaxis_inverted
3472         get_xlim, set_xlim
3473         get_xbound, set_xbound
3474         """
3475         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3476 
3477     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3478 
3479     def get_xbound(self):
3480         """
3481         Return the lower and upper x-axis bounds, in increasing order.
3482 
3483         See Also
3484         --------
3485         set_xbound
3486         get_xlim, set_xlim
3487         invert_xaxis, xaxis_inverted
3488         """
3489         left, right = self.get_xlim()
3490         if left < right:
3491             return left, right
3492         else:
3493             return right, left
3494 
3495     def set_xbound(self, lower=None, upper=None):
3496         """
3497         Set the lower and upper numerical bounds of the x-axis.
3498 
3499         This method will honor axis inversion regardless of parameter order.
3500         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3501 
3502         Parameters
3503         ----------
3504         lower, upper : float or None
3505             The lower and upper bounds. If *None*, the respective axis bound
3506             is not modified.
3507 
3508         See Also
3509         --------
3510         get_xbound
3511         get_xlim, set_xlim
3512         invert_xaxis, xaxis_inverted
3513         """
3514         if upper is None and np.iterable(lower):
3515             lower, upper = lower
3516 
3517         old_lower, old_upper = self.get_xbound()
3518         if lower is None:
3519             lower = old_lower
3520         if upper is None:
3521             upper = old_upper
3522 
3523         self.set_xlim(sorted((lower, upper),
3524                              reverse=bool(self.xaxis_inverted())),
3525                       auto=None)
3526 
3527     def get_xlim(self):
3528         """
3529         Return the x-axis view limits.
3530 
3531         Returns
3532         -------
3533         left, right : (float, float)
3534             The current x-axis limits in data coordinates.
3535 
3536         See Also
3537         --------
3538         .Axes.set_xlim
3539         set_xbound, get_xbound
3540         invert_xaxis, xaxis_inverted
3541 
3542         Notes
3543         -----
3544         The x-axis may be inverted, in which case the *left* value will
3545         be greater than the *right* value.
3546         """
3547         return tuple(self.viewLim.intervalx)
3548 
3549     def _validate_converted_limits(self, limit, convert):
3550         """
3551         Raise ValueError if converted limits are non-finite.
3552 
3553         Note that this function also accepts None as a limit argument.
3554 
3555         Returns
3556         -------
3557         The limit value after call to convert(), or None if limit is None.
3558         """
3559         if limit is not None:
3560             converted_limit = convert(limit)
3561             if (isinstance(converted_limit, Real)
3562                     and not np.isfinite(converted_limit)):
3563                 raise ValueError("Axis limits cannot be NaN or Inf")
3564             return converted_limit
3565 
3566     def set_xlim(self, left=None, right=None, *, emit=True, auto=False,
3567                  xmin=None, xmax=None):
3568         """
3569         Set the x-axis view limits.
3570 
3571         Parameters
3572         ----------
3573         left : float, optional
3574             The left xlim in data coordinates. Passing *None* leaves the
3575             limit unchanged.
3576 
3577             The left and right xlims may also be passed as the tuple
3578             (*left*, *right*) as the first positional argument (or as
3579             the *left* keyword argument).
3580 
3581             .. ACCEPTS: (bottom: float, top: float)
3582 
3583         right : float, optional
3584             The right xlim in data coordinates. Passing *None* leaves the
3585             limit unchanged.
3586 
3587         emit : bool, default: True
3588             Whether to notify observers of limit change.
3589 
3590         auto : bool or None, default: False
3591             Whether to turn on autoscaling of the x-axis. True turns on,
3592             False turns off, None leaves unchanged.
3593 
3594         xmin, xmax : float, optional
3595             They are equivalent to left and right respectively, and it is an
3596             error to pass both *xmin* and *left* or *xmax* and *right*.
3597 
3598         Returns
3599         -------
3600         left, right : (float, float)
3601             The new x-axis limits in data coordinates.
3602 
3603         See Also
3604         --------
3605         get_xlim
3606         set_xbound, get_xbound
3607         invert_xaxis, xaxis_inverted
3608 
3609         Notes
3610         -----
3611         The *left* value may be greater than the *right* value, in which
3612         case the x-axis values will decrease from left to right.
3613 
3614         Examples
3615         --------
3616         >>> set_xlim(left, right)
3617         >>> set_xlim((left, right))
3618         >>> left, right = set_xlim(left, right)
3619 
3620         One limit may be left unchanged.
3621 
3622         >>> set_xlim(right=right_lim)
3623 
3624         Limits may be passed in reverse order to flip the direction of
3625         the x-axis. For example, suppose *x* represents the number of
3626         years before present. The x-axis limits might be set like the
3627         following so 5000 years ago is on the left of the plot and the
3628         present is on the right.
3629 
3630         >>> set_xlim(5000, 0)
3631         """
3632         if right is None and np.iterable(left):
3633             left, right = left
3634         if xmin is not None:
3635             if left is not None:
3636                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3637             left = xmin
3638         if xmax is not None:
3639             if right is not None:
3640                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3641             right = xmax
3642         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3643 
3644     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3645     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3646     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3647     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3648     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3649     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3650     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3651     set_xticklabels = _axis_method_wrapper(
3652         "xaxis", "set_ticklabels",
3653         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3654 
3655     def get_ylabel(self):
3656         """
3657         Get the ylabel text string.
3658         """
3659         label = self.yaxis.get_label()
3660         return label.get_text()
3661 
3662     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3663                    loc=None, **kwargs):
3664         """
3665         Set the label for the y-axis.
3666 
3667         Parameters
3668         ----------
3669         ylabel : str
3670             The label text.
3671 
3672         labelpad : float, default: :rc:`axes.labelpad`
3673             Spacing in points from the Axes bounding box including ticks
3674             and tick labels.  If None, the previous value is left as is.
3675 
3676         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3677             The label position. This is a high-level alternative for passing
3678             parameters *y* and *horizontalalignment*.
3679 
3680         Other Parameters
3681         ----------------
3682         **kwargs : `.Text` properties
3683             `.Text` properties control the appearance of the label.
3684 
3685         See Also
3686         --------
3687         text : Documents the properties supported by `.Text`.
3688         """
3689         if labelpad is not None:
3690             self.yaxis.labelpad = labelpad
3691         protected_kw = ['y', 'horizontalalignment', 'ha']
3692         if {*kwargs} & {*protected_kw}:
3693             if loc is not None:
3694                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3695                                 f"its corresponding low level keyword "
3696                                 f"arguments ({protected_kw}) are also "
3697                                 f"supplied")
3698 
3699         else:
3700             loc = (loc if loc is not None
3701                    else mpl.rcParams['yaxis.labellocation'])
3702             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3703 
3704             y, ha = {
3705                 'bottom': (0, 'left'),
3706                 'center': (0.5, 'center'),
3707                 'top': (1, 'right')
3708             }[loc]
3709             kwargs.update(y=y, horizontalalignment=ha)
3710 
3711         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3712 
3713     def invert_yaxis(self):
3714         """
3715         Invert the y-axis.
3716 
3717         See Also
3718         --------
3719         yaxis_inverted
3720         get_ylim, set_ylim
3721         get_ybound, set_ybound
3722         """
3723         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3724 
3725     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3726 
3727     def get_ybound(self):
3728         """
3729         Return the lower and upper y-axis bounds, in increasing order.
3730 
3731         See Also
3732         --------
3733         set_ybound
3734         get_ylim, set_ylim
3735         invert_yaxis, yaxis_inverted
3736         """
3737         bottom, top = self.get_ylim()
3738         if bottom < top:
3739             return bottom, top
3740         else:
3741             return top, bottom
3742 
3743     def set_ybound(self, lower=None, upper=None):
3744         """
3745         Set the lower and upper numerical bounds of the y-axis.
3746 
3747         This method will honor axis inversion regardless of parameter order.
3748         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3749 
3750         Parameters
3751         ----------
3752         lower, upper : float or None
3753             The lower and upper bounds. If *None*, the respective axis bound
3754             is not modified.
3755 
3756         See Also
3757         --------
3758         get_ybound
3759         get_ylim, set_ylim
3760         invert_yaxis, yaxis_inverted
3761         """
3762         if upper is None and np.iterable(lower):
3763             lower, upper = lower
3764 
3765         old_lower, old_upper = self.get_ybound()
3766         if lower is None:
3767             lower = old_lower
3768         if upper is None:
3769             upper = old_upper
3770 
3771         self.set_ylim(sorted((lower, upper),
3772                              reverse=bool(self.yaxis_inverted())),
3773                       auto=None)
3774 
3775     def get_ylim(self):
3776         """
3777         Return the y-axis view limits.
3778 
3779         Returns
3780         -------
3781         bottom, top : (float, float)
3782             The current y-axis limits in data coordinates.
3783 
3784         See Also
3785         --------
3786         .Axes.set_ylim
3787         set_ybound, get_ybound
3788         invert_yaxis, yaxis_inverted
3789 
3790         Notes
3791         -----
3792         The y-axis may be inverted, in which case the *bottom* value
3793         will be greater than the *top* value.
3794         """
3795         return tuple(self.viewLim.intervaly)
3796 
3797     def set_ylim(self, bottom=None, top=None, *, emit=True, auto=False,
3798                  ymin=None, ymax=None):
3799         """
3800         Set the y-axis view limits.
3801 
3802         Parameters
3803         ----------
3804         bottom : float, optional
3805             The bottom ylim in data coordinates. Passing *None* leaves the
3806             limit unchanged.
3807 
3808             The bottom and top ylims may also be passed as the tuple
3809             (*bottom*, *top*) as the first positional argument (or as
3810             the *bottom* keyword argument).
3811 
3812             .. ACCEPTS: (bottom: float, top: float)
3813 
3814         top : float, optional
3815             The top ylim in data coordinates. Passing *None* leaves the
3816             limit unchanged.
3817 
3818         emit : bool, default: True
3819             Whether to notify observers of limit change.
3820 
3821         auto : bool or None, default: False
3822             Whether to turn on autoscaling of the y-axis. *True* turns on,
3823             *False* turns off, *None* leaves unchanged.
3824 
3825         ymin, ymax : float, optional
3826             They are equivalent to bottom and top respectively, and it is an
3827             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3828 
3829         Returns
3830         -------
3831         bottom, top : (float, float)
3832             The new y-axis limits in data coordinates.
3833 
3834         See Also
3835         --------
3836         get_ylim
3837         set_ybound, get_ybound
3838         invert_yaxis, yaxis_inverted
3839 
3840         Notes
3841         -----
3842         The *bottom* value may be greater than the *top* value, in which
3843         case the y-axis values will decrease from *bottom* to *top*.
3844 
3845         Examples
3846         --------
3847         >>> set_ylim(bottom, top)
3848         >>> set_ylim((bottom, top))
3849         >>> bottom, top = set_ylim(bottom, top)
3850 
3851         One limit may be left unchanged.
3852 
3853         >>> set_ylim(top=top_lim)
3854 
3855         Limits may be passed in reverse order to flip the direction of
3856         the y-axis. For example, suppose ``y`` represents depth of the
3857         ocean in m. The y-axis limits might be set like the following
3858         so 5000 m depth is at the bottom of the plot and the surface,
3859         0 m, is at the top.
3860 
3861         >>> set_ylim(5000, 0)
3862         """
3863         if top is None and np.iterable(bottom):
3864             bottom, top = bottom
3865         if ymin is not None:
3866             if bottom is not None:
3867                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3868             bottom = ymin
3869         if ymax is not None:
3870             if top is not None:
3871                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3872             top = ymax
3873         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3874 
3875     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3876     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3877     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3878     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3879     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3880     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3881     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3882     set_yticklabels = _axis_method_wrapper(
3883         "yaxis", "set_ticklabels",
3884         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3885 
3886     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3887     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3888 
3889     def format_xdata(self, x):
3890         """
3891         Return *x* formatted as an x-value.
3892 
3893         This function will use the `.fmt_xdata` attribute if it is not None,
3894         else will fall back on the xaxis major formatter.
3895         """
3896         return (self.fmt_xdata if self.fmt_xdata is not None
3897                 else self.xaxis.get_major_formatter().format_data_short)(x)
3898 
3899     def format_ydata(self, y):
3900         """
3901         Return *y* formatted as a y-value.
3902 
3903         This function will use the `.fmt_ydata` attribute if it is not None,
3904         else will fall back on the yaxis major formatter.
3905         """
3906         return (self.fmt_ydata if self.fmt_ydata is not None
3907                 else self.yaxis.get_major_formatter().format_data_short)(y)
3908 
3909     def format_coord(self, x, y):
3910         """Return a format string formatting the *x*, *y* coordinates."""
3911         return "x={} y={}".format(
3912             "???" if x is None else self.format_xdata(x),
3913             "???" if y is None else self.format_ydata(y),
3914         )
3915 
3916     def minorticks_on(self):
3917         """
3918         Display minor ticks on the Axes.
3919 
3920         Displaying minor ticks may reduce performance; you may turn them off
3921         using `minorticks_off()` if drawing speed is a problem.
3922         """
3923         for ax in (self.xaxis, self.yaxis):
3924             scale = ax.get_scale()
3925             if scale == 'log':
3926                 s = ax._scale
3927                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3928             elif scale == 'symlog':
3929                 s = ax._scale
3930                 ax.set_minor_locator(
3931                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3932             else:
3933                 ax.set_minor_locator(mticker.AutoMinorLocator())
3934 
3935     def minorticks_off(self):
3936         """Remove minor ticks from the Axes."""
3937         self.xaxis.set_minor_locator(mticker.NullLocator())
3938         self.yaxis.set_minor_locator(mticker.NullLocator())
3939 
3940     # Interactive manipulation
3941 
3942     def can_zoom(self):
3943         """
3944         Return whether this Axes supports the zoom box button functionality.
3945         """
3946         return True
3947 
3948     def can_pan(self):
3949         """
3950         Return whether this Axes supports any pan/zoom button functionality.
3951         """
3952         return True
3953 
3954     def get_navigate(self):
3955         """
3956         Get whether the Axes responds to navigation commands.
3957         """
3958         return self._navigate
3959 
3960     def set_navigate(self, b):
3961         """
3962         Set whether the Axes responds to navigation toolbar commands.
3963 
3964         Parameters
3965         ----------
3966         b : bool
3967         """
3968         self._navigate = b
3969 
3970     def get_navigate_mode(self):
3971         """
3972         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3973         """
3974         return self._navigate_mode
3975 
3976     def set_navigate_mode(self, b):
3977         """
3978         Set the navigation toolbar button status.
3979 
3980         .. warning::
3981             This is not a user-API function.
3982 
3983         """
3984         self._navigate_mode = b
3985 
3986     def _get_view(self):
3987         """
3988         Save information required to reproduce the current view.
3989 
3990         This method is called before a view is changed, such as during a pan or zoom
3991         initiated by the user.  It returns an opaque object that describes the current
3992         view, in a format compatible with :meth:`_set_view`.
3993 
3994         The default implementation saves the view limits and autoscaling state.
3995         Subclasses may override this as needed, as long as :meth:`_set_view` is also
3996         adjusted accordingly.
3997         """
3998         return {
3999             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
4000             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
4001         }
4002 
4003     def _set_view(self, view):
4004         """
4005         Apply a previously saved view.
4006 
4007         This method is called when restoring a view (with the return value of
4008         :meth:`_get_view` as argument), such as with the navigation buttons.
4009 
4010         Subclasses that override :meth:`_get_view` also need to override this method
4011         accordingly.
4012         """
4013         self.set(**view)
4014 
4015     def _prepare_view_from_bbox(self, bbox, direction='in',
4016                                 mode=None, twinx=False, twiny=False):
4017         """
4018         Helper function to prepare the new bounds from a bbox.
4019 
4020         This helper function returns the new x and y bounds from the zoom
4021         bbox. This a convenience method to abstract the bbox logic
4022         out of the base setter.
4023         """
4024         if len(bbox) == 3:
4025             xp, yp, scl = bbox  # Zooming code
4026             if scl == 0:  # Should not happen
4027                 scl = 1.
4028             if scl > 1:
4029                 direction = 'in'
4030             else:
4031                 direction = 'out'
4032                 scl = 1/scl
4033             # get the limits of the axes
4034             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4035                 np.transpose([self.get_xlim(), self.get_ylim()]))
4036             # set the range
4037             xwidth = xmax - xmin
4038             ywidth = ymax - ymin
4039             xcen = (xmax + xmin)*.5
4040             ycen = (ymax + ymin)*.5
4041             xzc = (xp*(scl - 1) + xcen)/scl
4042             yzc = (yp*(scl - 1) + ycen)/scl
4043             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4044                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4045         elif len(bbox) != 4:
4046             # should be len 3 or 4 but nothing else
4047             _api.warn_external(
4048                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4049                 "of length 3 or 4. Ignoring the view change.")
4050             return
4051 
4052         # Original limits.
4053         xmin0, xmax0 = self.get_xbound()
4054         ymin0, ymax0 = self.get_ybound()
4055         # The zoom box in screen coords.
4056         startx, starty, stopx, stopy = bbox
4057         # Convert to data coords.
4058         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4059             [(startx, starty), (stopx, stopy)])
4060         # Clip to axes limits.
4061         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4062         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4063         # Don't double-zoom twinned axes or if zooming only the other axis.
4064         if twinx or mode == "y":
4065             xmin, xmax = xmin0, xmax0
4066         if twiny or mode == "x":
4067             ymin, ymax = ymin0, ymax0
4068 
4069         if direction == "in":
4070             new_xbound = xmin, xmax
4071             new_ybound = ymin, ymax
4072 
4073         elif direction == "out":
4074             x_trf = self.xaxis.get_transform()
4075             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4076                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4077             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4078             # Move original bounds away by
4079             # (factor) x (distance between unzoom box and Axes bbox).
4080             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4081             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4082             # And back to data space.
4083             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4084 
4085             y_trf = self.yaxis.get_transform()
4086             symin0, symax0, symin, symax = y_trf.transform(
4087                 [ymin0, ymax0, ymin, ymax])
4088             factor = (symax0 - symin0) / (symax - symin)
4089             symin1 = symin0 - factor * (symin - symin0)
4090             symax1 = symax0 + factor * (symax0 - symax)
4091             new_ybound = y_trf.inverted().transform([symin1, symax1])
4092 
4093         return new_xbound, new_ybound
4094 
4095     def _set_view_from_bbox(self, bbox, direction='in',
4096                             mode=None, twinx=False, twiny=False):
4097         """
4098         Update view from a selection bbox.
4099 
4100         .. note::
4101 
4102             Intended to be overridden by new projection types, but if not, the
4103             default implementation sets the view limits to the bbox directly.
4104 
4105         Parameters
4106         ----------
4107         bbox : 4-tuple or 3 tuple
4108             * If bbox is a 4 tuple, it is the selected bounding box limits,
4109               in *display* coordinates.
4110             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4111               (xp, yp) is the center of zooming and scl the scale factor to
4112               zoom by.
4113 
4114         direction : str
4115             The direction to apply the bounding box.
4116                 * `'in'` - The bounding box describes the view directly, i.e.,
4117                            it zooms in.
4118                 * `'out'` - The bounding box describes the size to make the
4119                             existing view, i.e., it zooms out.
4120 
4121         mode : str or None
4122             The selection mode, whether to apply the bounding box in only the
4123             `'x'` direction, `'y'` direction or both (`None`).
4124 
4125         twinx : bool
4126             Whether this axis is twinned in the *x*-direction.
4127 
4128         twiny : bool
4129             Whether this axis is twinned in the *y*-direction.
4130         """
4131         new_xbound, new_ybound = self._prepare_view_from_bbox(
4132             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4133         if not twinx and mode != "y":
4134             self.set_xbound(new_xbound)
4135             self.set_autoscalex_on(False)
4136         if not twiny and mode != "x":
4137             self.set_ybound(new_ybound)
4138             self.set_autoscaley_on(False)
4139 
4140     def start_pan(self, x, y, button):
4141         """
4142         Called when a pan operation has started.
4143 
4144         Parameters
4145         ----------
4146         x, y : float
4147             The mouse coordinates in display coords.
4148         button : `.MouseButton`
4149             The pressed mouse button.
4150 
4151         Notes
4152         -----
4153         This is intended to be overridden by new projection types.
4154         """
4155         self._pan_start = types.SimpleNamespace(
4156             lim=self.viewLim.frozen(),
4157             trans=self.transData.frozen(),
4158             trans_inverse=self.transData.inverted().frozen(),
4159             bbox=self.bbox.frozen(),
4160             x=x,
4161             y=y)
4162 
4163     def end_pan(self):
4164         """
4165         Called when a pan operation completes (when the mouse button is up.)
4166 
4167         Notes
4168         -----
4169         This is intended to be overridden by new projection types.
4170         """
4171         del self._pan_start
4172 
4173     def _get_pan_points(self, button, key, x, y):
4174         """
4175         Helper function to return the new points after a pan.
4176 
4177         This helper function returns the points on the axis after a pan has
4178         occurred. This is a convenience method to abstract the pan logic
4179         out of the base setter.
4180         """
4181         def format_deltas(key, dx, dy):
4182             if key == 'control':
4183                 if abs(dx) > abs(dy):
4184                     dy = dx
4185                 else:
4186                     dx = dy
4187             elif key == 'x':
4188                 dy = 0
4189             elif key == 'y':
4190                 dx = 0
4191             elif key == 'shift':
4192                 if 2 * abs(dx) < abs(dy):
4193                     dx = 0
4194                 elif 2 * abs(dy) < abs(dx):
4195                     dy = 0
4196                 elif abs(dx) > abs(dy):
4197                     dy = dy / abs(dy) * abs(dx)
4198                 else:
4199                     dx = dx / abs(dx) * abs(dy)
4200             return dx, dy
4201 
4202         p = self._pan_start
4203         dx = x - p.x
4204         dy = y - p.y
4205         if dx == dy == 0:
4206             return
4207         if button == 1:
4208             dx, dy = format_deltas(key, dx, dy)
4209             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4210         elif button == 3:
4211             try:
4212                 dx = -dx / self.bbox.width
4213                 dy = -dy / self.bbox.height
4214                 dx, dy = format_deltas(key, dx, dy)
4215                 if self.get_aspect() != 'auto':
4216                     dx = dy = 0.5 * (dx + dy)
4217                 alpha = np.power(10.0, (dx, dy))
4218                 start = np.array([p.x, p.y])
4219                 oldpoints = p.lim.transformed(p.trans)
4220                 newpoints = start + alpha * (oldpoints - start)
4221                 result = (mtransforms.Bbox(newpoints)
4222                           .transformed(p.trans_inverse))
4223             except OverflowError:
4224                 _api.warn_external('Overflow while panning')
4225                 return
4226         else:
4227             return
4228 
4229         valid = np.isfinite(result.transformed(p.trans))
4230         points = result.get_points().astype(object)
4231         # Just ignore invalid limits (typically, underflow in log-scale).
4232         points[~valid] = None
4233         return points
4234 
4235     def drag_pan(self, button, key, x, y):
4236         """
4237         Called when the mouse moves during a pan operation.
4238 
4239         Parameters
4240         ----------
4241         button : `.MouseButton`
4242             The pressed mouse button.
4243         key : str or None
4244             The pressed key, if any.
4245         x, y : float
4246             The mouse coordinates in display coords.
4247 
4248         Notes
4249         -----
4250         This is intended to be overridden by new projection types.
4251         """
4252         points = self._get_pan_points(button, key, x, y)
4253         if points is not None:
4254             self.set_xlim(points[:, 0])
4255             self.set_ylim(points[:, 1])
4256 
4257     def get_children(self):
4258         # docstring inherited.
4259         return [
4260             *self._children,
4261             *self.spines.values(),
4262             *self._axis_map.values(),
4263             self.title, self._left_title, self._right_title,
4264             *self.child_axes,
4265             *([self.legend_] if self.legend_ is not None else []),
4266             self.patch,
4267         ]
4268 
4269     def contains(self, mouseevent):
4270         # docstring inherited.
4271         return self.patch.contains(mouseevent)
4272 
4273     def contains_point(self, point):
4274         """
4275         Return whether *point* (pair of pixel coordinates) is inside the Axes
4276         patch.
4277         """
4278         return self.patch.contains_point(point, radius=1.0)
4279 
4280     def get_default_bbox_extra_artists(self):
4281         """
4282         Return a default list of artists that are used for the bounding box
4283         calculation.
4284 
4285         Artists are excluded either by not being visible or
4286         ``artist.set_in_layout(False)``.
4287         """
4288 
4289         artists = self.get_children()
4290 
4291         for axis in self._axis_map.values():
4292             # axis tight bboxes are calculated separately inside
4293             # Axes.get_tightbbox() using for_layout_only=True
4294             artists.remove(axis)
4295         if not (self.axison and self._frameon):
4296             # don't do bbox on spines if frame not on.
4297             for spine in self.spines.values():
4298                 artists.remove(spine)
4299 
4300         artists.remove(self.title)
4301         artists.remove(self._left_title)
4302         artists.remove(self._right_title)
4303 
4304         # always include types that do not internally implement clipping
4305         # to Axes. may have clip_on set to True and clip_box equivalent
4306         # to ax.bbox but then ignore these properties during draws.
4307         noclip = (_AxesBase, maxis.Axis,
4308                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4309         return [a for a in artists if a.get_visible() and a.get_in_layout()
4310                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4311 
4312     @_api.make_keyword_only("3.8", "call_axes_locator")
4313     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4314                       bbox_extra_artists=None, *, for_layout_only=False):
4315         """
4316         Return the tight bounding box of the Axes, including axis and their
4317         decorators (xlabel, title, etc).
4318 
4319         Artists that have ``artist.set_in_layout(False)`` are not included
4320         in the bbox.
4321 
4322         Parameters
4323         ----------
4324         renderer : `.RendererBase` subclass
4325             renderer that will be used to draw the figures (i.e.
4326             ``fig.canvas.get_renderer()``)
4327 
4328         bbox_extra_artists : list of `.Artist` or ``None``
4329             List of artists to include in the tight bounding box.  If
4330             ``None`` (default), then all artist children of the Axes are
4331             included in the tight bounding box.
4332 
4333         call_axes_locator : bool, default: True
4334             If *call_axes_locator* is ``False``, it does not call the
4335             ``_axes_locator`` attribute, which is necessary to get the correct
4336             bounding box. ``call_axes_locator=False`` can be used if the
4337             caller is only interested in the relative size of the tightbbox
4338             compared to the Axes bbox.
4339 
4340         for_layout_only : default: False
4341             The bounding box will *not* include the x-extent of the title and
4342             the xlabel, or the y-extent of the ylabel.
4343 
4344         Returns
4345         -------
4346         `.BboxBase`
4347             Bounding box in figure pixel coordinates.
4348 
4349         See Also
4350         --------
4351         matplotlib.axes.Axes.get_window_extent
4352         matplotlib.axis.Axis.get_tightbbox
4353         matplotlib.spines.Spine.get_window_extent
4354         """
4355 
4356         bb = []
4357         if renderer is None:
4358             renderer = self.figure._get_renderer()
4359 
4360         if not self.get_visible():
4361             return None
4362 
4363         locator = self.get_axes_locator()
4364         self.apply_aspect(
4365             locator(self, renderer) if locator and call_axes_locator else None)
4366 
4367         for axis in self._axis_map.values():
4368             if self.axison and axis.get_visible():
4369                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4370                 if ba:
4371                     bb.append(ba)
4372         self._update_title_position(renderer)
4373         axbbox = self.get_window_extent(renderer)
4374         bb.append(axbbox)
4375 
4376         for title in [self.title, self._left_title, self._right_title]:
4377             if title.get_visible():
4378                 bt = title.get_window_extent(renderer)
4379                 if for_layout_only and bt.width > 0:
4380                     # make the title bbox 1 pixel wide so its width
4381                     # is not accounted for in bbox calculations in
4382                     # tight/constrained_layout
4383                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4384                     bt.x1 = bt.x0 + 1.0
4385                 bb.append(bt)
4386 
4387         bbox_artists = bbox_extra_artists
4388         if bbox_artists is None:
4389             bbox_artists = self.get_default_bbox_extra_artists()
4390 
4391         for a in bbox_artists:
4392             bbox = a.get_tightbbox(renderer)
4393             if (bbox is not None
4394                     and 0 < bbox.width < np.inf
4395                     and 0 < bbox.height < np.inf):
4396                 bb.append(bbox)
4397         return mtransforms.Bbox.union(
4398             [b for b in bb if b.width != 0 or b.height != 0])
4399 
4400     def _make_twin_axes(self, *args, **kwargs):
4401         """Make a twinx Axes of self. This is used for twinx and twiny."""
4402         if 'sharex' in kwargs and 'sharey' in kwargs:
4403             # The following line is added in v2.2 to avoid breaking Seaborn,
4404             # which currently uses this internal API.
4405             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4406                 raise ValueError("Twinned Axes may share only one axis")
4407         ss = self.get_subplotspec()
4408         if ss:
4409             twin = self.figure.add_subplot(ss, *args, **kwargs)
4410         else:
4411             twin = self.figure.add_axes(
4412                 self.get_position(True), *args, **kwargs,
4413                 axes_locator=_TransformedBoundsLocator(
4414                     [0, 0, 1, 1], self.transAxes))
4415         self.set_adjustable('datalim')
4416         twin.set_adjustable('datalim')
4417         self._twinned_axes.join(self, twin)
4418         return twin
4419 
4420     def twinx(self):
4421         """
4422         Create a twin Axes sharing the xaxis.
4423 
4424         Create a new Axes with an invisible x-axis and an independent
4425         y-axis positioned opposite to the original one (i.e. at right). The
4426         x-axis autoscale setting will be inherited from the original
4427         Axes.  To ensure that the tick marks of both y-axes align, see
4428         `~matplotlib.ticker.LinearLocator`.
4429 
4430         Returns
4431         -------
4432         Axes
4433             The newly created Axes instance
4434 
4435         Notes
4436         -----
4437         For those who are 'picking' artists while using twinx, pick
4438         events are only called for the artists in the top-most Axes.
4439         """
4440         ax2 = self._make_twin_axes(sharex=self)
4441         ax2.yaxis.tick_right()
4442         ax2.yaxis.set_label_position('right')
4443         ax2.yaxis.set_offset_position('right')
4444         ax2.set_autoscalex_on(self.get_autoscalex_on())
4445         self.yaxis.tick_left()
4446         ax2.xaxis.set_visible(False)
4447         ax2.patch.set_visible(False)
4448         return ax2
4449 
4450     def twiny(self):
4451         """
4452         Create a twin Axes sharing the yaxis.
4453 
4454         Create a new Axes with an invisible y-axis and an independent
4455         x-axis positioned opposite to the original one (i.e. at top). The
4456         y-axis autoscale setting will be inherited from the original Axes.
4457         To ensure that the tick marks of both x-axes align, see
4458         `~matplotlib.ticker.LinearLocator`.
4459 
4460         Returns
4461         -------
4462         Axes
4463             The newly created Axes instance
4464 
4465         Notes
4466         -----
4467         For those who are 'picking' artists while using twiny, pick
4468         events are only called for the artists in the top-most Axes.
4469         """
4470         ax2 = self._make_twin_axes(sharey=self)
4471         ax2.xaxis.tick_top()
4472         ax2.xaxis.set_label_position('top')
4473         ax2.set_autoscaley_on(self.get_autoscaley_on())
4474         self.xaxis.tick_bottom()
4475         ax2.yaxis.set_visible(False)
4476         ax2.patch.set_visible(False)
4477         return ax2
4478 
4479     def get_shared_x_axes(self):
4480         """Return an immutable view on the shared x-axes Grouper."""
4481         return cbook.GrouperView(self._shared_axes["x"])
4482 
4483     def get_shared_y_axes(self):
4484         """Return an immutable view on the shared y-axes Grouper."""
4485         return cbook.GrouperView(self._shared_axes["y"])
4486 
4487     def label_outer(self):
4488         """
4489         Only show "outer" labels and tick labels.
4490 
4491         x-labels are only kept for subplots on the last row (or first row, if
4492         labels are on the top side); y-labels only for subplots on the first
4493         column (or last column, if labels are on the right side).
4494         """
4495         self._label_outer_xaxis(check_patch=False)
4496         self._label_outer_yaxis(check_patch=False)
4497 
4498     def _label_outer_xaxis(self, *, check_patch):
4499         # see documentation in label_outer.
4500         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4501             return
4502         ss = self.get_subplotspec()
4503         if not ss:
4504             return
4505         label_position = self.xaxis.get_label_position()
4506         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4507             if label_position == "top":
4508                 self.set_xlabel("")
4509             self.xaxis.set_tick_params(which="both", labeltop=False)
4510             if self.xaxis.offsetText.get_position()[1] == 1:
4511                 self.xaxis.offsetText.set_visible(False)
4512         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4513             if label_position == "bottom":
4514                 self.set_xlabel("")
4515             self.xaxis.set_tick_params(which="both", labelbottom=False)
4516             if self.xaxis.offsetText.get_position()[1] == 0:
4517                 self.xaxis.offsetText.set_visible(False)
4518 
4519     def _label_outer_yaxis(self, *, check_patch):
4520         # see documentation in label_outer.
4521         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4522             return
4523         ss = self.get_subplotspec()
4524         if not ss:
4525             return
4526         label_position = self.yaxis.get_label_position()
4527         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4528             if label_position == "left":
4529                 self.set_ylabel("")
4530             self.yaxis.set_tick_params(which="both", labelleft=False)
4531             if self.yaxis.offsetText.get_position()[0] == 0:
4532                 self.yaxis.offsetText.set_visible(False)
4533         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4534             if label_position == "right":
4535                 self.set_ylabel("")
4536             self.yaxis.set_tick_params(which="both", labelright=False)
4537             if self.yaxis.offsetText.get_position()[0] == 1:
4538                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:47:10.282 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 14:47:10.282 | INFO     | Search-only: skipping patch selection
2025-10-17 14:47:10.413 | INFO     | Task matplotlib__matplotlib-25746 completed successfully.
2025-10-17 14:47:10.414 | INFO     | No patch generated. You can try running ACR again.
