[
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 164,
        "end": 190,
        "class_name": "MemcachedCache",
        "method_name": null,
        "code": "164 class MemcachedCache(BaseMemcachedCache):\n165     \"An implementation of a cache binding using python-memcached\"\n166     def __init__(self, server, params):\n167         # python-memcached \u2265 1.45 returns None for a nonexistent key in\n168         # incr/decr(), python-memcached < 1.45 raises ValueError.\n169         import memcache\n170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)\n171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}\n172 \n173     def get(self, key, default=None, version=None):\n174         key = self.make_key(key, version=version)\n175         self.validate_key(key)\n176         val = self._cache.get(key)\n177         # python-memcached doesn't support default values in get().\n178         # https://github.com/linsomniac/python-memcached/issues/159\n179         # Remove this method if that issue is fixed.\n180         if val is None:\n181             return default\n182         return val\n183 \n184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         self.validate_key(key)\n190         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n",
        "intended_behavior": "The `MemcachedCache` class should be marked as deprecated. This involves adding a deprecation warning that is triggered whenever an instance of `MemcachedCache` is initialized. The warning should inform users that `MemcachedCache` is deprecated as of Django 3.2 and will be removed in Django 4.1, advising users to switch to the `pymemcache` backend. This preserves the existing functionality for now while clearly communicating the future removal to developers. An example implementation might involve overriding the `__init__` method to include a call to the warnings module, specifically to emit a `RemovedInDjango41Warning` or a similarly purposed new warning if required by the project's deprecation policy."
    },
    {
        "rel_file_path": "django/utils/deprecation.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/utils/deprecation.py",
        "start": 1,
        "end": 147,
        "class_name": null,
        "method_name": null,
        "code": "1 import asyncio\n2 import inspect\n3 import warnings\n4 \n5 from asgiref.sync import sync_to_async\n6 \n7 \n8 class RemovedInDjango40Warning(DeprecationWarning):\n9     pass\n10 \n11 \n12 class RemovedInDjango41Warning(PendingDeprecationWarning):\n13     pass\n14 \n15 \n16 RemovedInNextVersionWarning = RemovedInDjango40Warning\n17 \n18 \n19 class warn_about_renamed_method:\n20     def __init__(self, class_name, old_method_name, new_method_name, deprecation_warning):\n21         self.class_name = class_name\n22         self.old_method_name = old_method_name\n23         self.new_method_name = new_method_name\n24         self.deprecation_warning = deprecation_warning\n25 \n26     def __call__(self, f):\n27         def wrapped(*args, **kwargs):\n28             warnings.warn(\n29                 \"`%s.%s` is deprecated, use `%s` instead.\" %\n30                 (self.class_name, self.old_method_name, self.new_method_name),\n31                 self.deprecation_warning, 2)\n32             return f(*args, **kwargs)\n33         return wrapped\n34 \n35 \n36 class RenameMethodsBase(type):\n37     \"\"\"\n38     Handles the deprecation paths when renaming a method.\n39 \n40     It does the following:\n41         1) Define the new method if missing and complain about it.\n42         2) Define the old method if missing.\n43         3) Complain whenever an old method is called.\n44 \n45     See #15363 for more details.\n46     \"\"\"\n47 \n48     renamed_methods = ()\n49 \n50     def __new__(cls, name, bases, attrs):\n51         new_class = super().__new__(cls, name, bases, attrs)\n52 \n53         for base in inspect.getmro(new_class):\n54             class_name = base.__name__\n55             for renamed_method in cls.renamed_methods:\n56                 old_method_name = renamed_method[0]\n57                 old_method = base.__dict__.get(old_method_name)\n58                 new_method_name = renamed_method[1]\n59                 new_method = base.__dict__.get(new_method_name)\n60                 deprecation_warning = renamed_method[2]\n61                 wrapper = warn_about_renamed_method(class_name, *renamed_method)\n62 \n63                 # Define the new method if missing and complain about it\n64                 if not new_method and old_method:\n65                     warnings.warn(\n66                         \"`%s.%s` method should be renamed `%s`.\" %\n67                         (class_name, old_method_name, new_method_name),\n68                         deprecation_warning, 2)\n69                     setattr(base, new_method_name, old_method)\n70                     setattr(base, old_method_name, wrapper(old_method))\n71 \n72                 # Define the old method as a wrapped call to the new method.\n73                 if not old_method and new_method:\n74                     setattr(base, old_method_name, wrapper(new_method))\n75 \n76         return new_class\n77 \n78 \n79 class DeprecationInstanceCheck(type):\n80     def __instancecheck__(self, instance):\n81         warnings.warn(\n82             \"`%s` is deprecated, use `%s` instead.\" % (self.__name__, self.alternative),\n83             self.deprecation_warning, 2\n84         )\n85         return super().__instancecheck__(instance)\n86 \n87 \n88 class MiddlewareMixin:\n89     sync_capable = True\n90     async_capable = True\n91 \n92     # RemovedInDjango40Warning: when the deprecation ends, replace with:\n93     #   def __init__(self, get_response):\n94     def __init__(self, get_response=None):\n95         self._get_response_none_deprecation(get_response)\n96         self.get_response = get_response\n97         self._async_check()\n98         super().__init__()\n99 \n100     def _async_check(self):\n101         \"\"\"\n102         If get_response is a coroutine function, turns us into async mode so\n103         a thread is not consumed during a whole request.\n104         \"\"\"\n105         if asyncio.iscoroutinefunction(self.get_response):\n106             # Mark the class as async-capable, but do the actual switch\n107             # inside __call__ to avoid swapping out dunder methods\n108             self._is_coroutine = asyncio.coroutines._is_coroutine\n109 \n110     def __call__(self, request):\n111         # Exit out to async mode, if needed\n112         if asyncio.iscoroutinefunction(self.get_response):\n113             return self.__acall__(request)\n114         response = None\n115         if hasattr(self, 'process_request'):\n116             response = self.process_request(request)\n117         response = response or self.get_response(request)\n118         if hasattr(self, 'process_response'):\n119             response = self.process_response(request, response)\n120         return response\n121 \n122     async def __acall__(self, request):\n123         \"\"\"\n124         Async version of __call__ that is swapped in when an async request\n125         is running.\n126         \"\"\"\n127         response = None\n128         if hasattr(self, 'process_request'):\n129             response = await sync_to_async(\n130                 self.process_request,\n131                 thread_sensitive=True,\n132             )(request)\n133         response = response or await self.get_response(request)\n134         if hasattr(self, 'process_response'):\n135             response = await sync_to_async(\n136                 self.process_response,\n137                 thread_sensitive=True,\n138             )(request, response)\n139         return response\n140 \n141     def _get_response_none_deprecation(self, get_response):\n142         if get_response is None:\n143             warnings.warn(\n144                 'Passing None for the middleware get_response argument is '\n145                 'deprecated.',\n146                 RemovedInDjango40Warning, stacklevel=3,\n147             )\n",
        "intended_behavior": "Ensure that there is a `DeprecatedInDjango32Warning` or similar if not already existing. If `RemovedInDjango41Warning` does not exist or if creating a new warning type is more appropriate (e.g., `DeprecatedInDjango32Warning` for marking things deprecated in Django 3.2 as opposed to removed in Django 4.1), define it here. The behavior of this warning should align with how Django typically notifies developers of deprecations, perhaps offering a more specific message that clearly states the deprecation version and the removal version."
    }
]