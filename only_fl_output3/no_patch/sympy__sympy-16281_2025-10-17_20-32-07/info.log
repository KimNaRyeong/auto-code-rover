2025-10-17 20:32:07.822 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 20:32:16.328 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=640, output_tokens=12, cost=0.006760
2025-10-17 20:32:28.689 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=820, output_tokens=477, cost=0.022510
2025-10-17 20:32:30.490 | INFO     | registered non reproducing test 0
2025-10-17 20:32:46.575 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1780, output_tokens=686, cost=0.038380
2025-10-17 20:32:47.833 | INFO     | registered non reproducing test 1
2025-10-17 20:33:05.426 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1871, output_tokens=764, cost=0.041630
2025-10-17 20:33:06.686 | INFO     | registered non reproducing test 2
2025-10-17 20:33:06.686 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 20:33:06.693 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:33:14.238 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=930, output_tokens=278, cost=0.017640
2025-10-17 20:33:14.245 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:33:16.653 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=632, output_tokens=28, cost=0.007160
2025-10-17 20:33:16.654 | DEBUG    | Extracted a valid json.
2025-10-17 20:33:16.655 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"Product\")", "search_method(\"pprint\")"],
    "bug_locations": []
}
2025-10-17 20:33:16.666 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:33:16.667 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:33:32.773 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1544, output_tokens=600, cost=0.033440
2025-10-17 20:33:32.787 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:33:39.551 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2360, output_tokens=246, cost=0.030980
2025-10-17 20:33:39.557 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:33:43.981 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=600, output_tokens=65, cost=0.007950
2025-10-17 20:33:43.982 | DEBUG    | Extracted a valid json.
2025-10-17 20:33:43.982 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"pretty_print\")",
        "search_code(\"pprint\")",
        "search_method_in_file(\"pretty\", \"sympy/concrete/products.py\")",
        "search_code(\"ExprWithIntLimits pretty\")"
    ],
    "bug_locations": []
}
2025-10-17 20:33:45.759 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:33:45.760 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:34:04.571 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3978, output_tokens=627, cost=0.058590
2025-10-17 20:34:04.577 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:34:16.965 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4821, output_tokens=368, cost=0.059250
2025-10-17 20:34:16.973 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:34:22.553 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=152, cost=0.011780
2025-10-17 20:34:22.555 | DEBUG    | Extracted a valid json.
2025-10-17 20:34:22.555 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file('pretty printing of `Product` instances', 'sympy/printing/pretty/pretty.py')"
    ],
    "bug_locations":[
        {
            "file": "sympy/printing/pretty/pretty.py",
            "class": "",
            "method": "",
            "intended_behavior": "Detect when a `Product` instance is being pretty-printed, adjust the rendering process to remove the extra line at the bottom of the output, refine the appearance to make the `Product` symbol less wide by adjusting spaces or line characters, and optionally extend the top bar only if it enhances clarity and aesthetic without compromising readability or consistency with other expressions."
        }
    ]
}
2025-10-17 20:34:22.560 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:34:22.561 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:34:37.303 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5351, output_tokens=577, cost=0.070820
2025-10-17 20:34:37.316 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:34:47.310 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6144, output_tokens=353, cost=0.072030
2025-10-17 20:34:47.317 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:34:54.166 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=707, output_tokens=230, cost=0.013970
2025-10-17 20:34:54.167 | DEBUG    | Extracted a valid json.
2025-10-17 20:34:54.167 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/pretty/pretty.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code within this file responsible for the pretty printing of `Product` instances needs to be modified or enhanced. This could involve adjusting the method(s) that generate the textual representation of mathematical products. Specifically, the modifications should aim to: - Remove the unnecessary empty line at the bottom of the product notation to make the presentation more compact and aligned with mathematical standards. - Adjust the width of the product notation to ensure it does not appear excessively broad ('too fat'), making it more in line with the visual aesthetics of related symbols and expressions. - Optionally extend the top bar of the product notation if such a change does not adversely affect the clarity or consistency of the representation, potentially making the notation more visually appealing and understandable. These adjustments should be carefully implemented to preserve the existing functionality of the pretty printing code, ensuring that all other expressions and symbols continue to be rendered correctly and without unintended modifications."
        }
    ]
}
2025-10-17 20:34:54.174 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/pretty/pretty.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 import itertools
4 
5 from sympy.core import S
6 from sympy.core.compatibility import range, string_types
7 from sympy.core.containers import Tuple
8 from sympy.core.function import _coeff_isneg
9 from sympy.core.mul import Mul
10 from sympy.core.numbers import Rational
11 from sympy.core.power import Pow
12 from sympy.core.relational import Equality
13 from sympy.core.symbol import Symbol
14 from sympy.core.sympify import SympifyError
15 from sympy.printing.conventions import requires_partial
16 from sympy.printing.precedence import PRECEDENCE, precedence, precedence_traditional
17 from sympy.printing.printer import Printer
18 from sympy.printing.str import sstr
19 from sympy.utilities import default_sort_key
20 from sympy.utilities.iterables import has_variety
21 
22 from sympy.printing.pretty.stringpict import prettyForm, stringPict
23 from sympy.printing.pretty.pretty_symbology import xstr, hobj, vobj, xobj, xsym, pretty_symbol, \
24     pretty_atom, pretty_use_unicode, pretty_try_use_unicode, greek_unicode, U, \
25     annotated
26 
27 # rename for usage from outside
28 pprint_use_unicode = pretty_use_unicode
29 pprint_try_use_unicode = pretty_try_use_unicode
30 
31 
32 class PrettyPrinter(Printer):
33     """Printer, which converts an expression into 2D ASCII-art figure."""
34     printmethod = "_pretty"
35 
36     _default_settings = {
37         "order": None,
38         "full_prec": "auto",
39         "use_unicode": None,
40         "wrap_line": True,
41         "num_columns": None,
42         "use_unicode_sqrt_char": True,
43         "root_notation": True,
44         "mat_symbol_style": "plain",
45         "imaginary_unit": "i",
46     }
47 
48     def __init__(self, settings=None):
49         Printer.__init__(self, settings)
50 
51         if not isinstance(self._settings['imaginary_unit'], string_types):
52             raise TypeError("'imaginary_unit' must a string, not {}".format(self._settings['imaginary_unit']))
53         elif self._settings['imaginary_unit'] not in ["i", "j"]:
54             raise ValueError("'imaginary_unit' must be either 'i' or 'j', not '{}'".format(self._settings['imaginary_unit']))
55         self.emptyPrinter = lambda x: prettyForm(xstr(x))
56 
57     @property
58     def _use_unicode(self):
59         if self._settings['use_unicode']:
60             return True
61         else:
62             return pretty_use_unicode()
63 
64     def doprint(self, expr):
65         return self._print(expr).render(**self._settings)
66 
67     # empty op so _print(stringPict) returns the same
68     def _print_stringPict(self, e):
69         return e
70 
71     def _print_basestring(self, e):
72         return prettyForm(e)
73 
74     def _print_atan2(self, e):
75         pform = prettyForm(*self._print_seq(e.args).parens())
76         pform = prettyForm(*pform.left('atan2'))
77         return pform
78 
79     def _print_Symbol(self, e, bold_name=False):
80         symb = pretty_symbol(e.name, bold_name)
81         return prettyForm(symb)
82     _print_RandomSymbol = _print_Symbol
83     def _print_MatrixSymbol(self, e):
84         return self._print_Symbol(e, self._settings['mat_symbol_style'] == "bold")
85 
86     def _print_Float(self, e):
87         # we will use StrPrinter's Float printer, but we need to handle the
88         # full_prec ourselves, according to the self._print_level
89         full_prec = self._settings["full_prec"]
90         if full_prec == "auto":
91             full_prec = self._print_level == 1
92         return prettyForm(sstr(e, full_prec=full_prec))
93 
94     def _print_Cross(self, e):
95         vec1 = e._expr1
96         vec2 = e._expr2
97         pform = self._print(vec2)
98         pform = prettyForm(*pform.left('('))
99         pform = prettyForm(*pform.right(')'))
100         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
101         pform = prettyForm(*pform.left(')'))
102         pform = prettyForm(*pform.left(self._print(vec1)))
103         pform = prettyForm(*pform.left('('))
104         return pform
105 
106     def _print_Curl(self, e):
107         vec = e._expr
108         pform = self._print(vec)
109         pform = prettyForm(*pform.left('('))
110         pform = prettyForm(*pform.right(')'))
111         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
112         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
113         return pform
114 
115     def _print_Divergence(self, e):
116         vec = e._expr
117         pform = self._print(vec)
118         pform = prettyForm(*pform.left('('))
119         pform = prettyForm(*pform.right(')'))
120         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
121         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
122         return pform
123 
124     def _print_Dot(self, e):
125         vec1 = e._expr1
126         vec2 = e._expr2
127         pform = self._print(vec2)
128         pform = prettyForm(*pform.left('('))
129         pform = prettyForm(*pform.right(')'))
130         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
131         pform = prettyForm(*pform.left(')'))
132         pform = prettyForm(*pform.left(self._print(vec1)))
133         pform = prettyForm(*pform.left('('))
134         return pform
135 
136     def _print_Gradient(self, e):
137         func = e._expr
138         pform = self._print(func)
139         pform = prettyForm(*pform.left('('))
140         pform = prettyForm(*pform.right(')'))
141         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
142         return pform
143 
144     def _print_Atom(self, e):
145         try:
146             # print atoms like Exp1 or Pi
147             return prettyForm(pretty_atom(e.__class__.__name__, printer=self))
148         except KeyError:
149             return self.emptyPrinter(e)
150 
151     # Infinity inherits from Number, so we have to override _print_XXX order
152     _print_Infinity = _print_Atom
153     _print_NegativeInfinity = _print_Atom
154     _print_EmptySet = _print_Atom
155     _print_Naturals = _print_Atom
156     _print_Naturals0 = _print_Atom
157     _print_Integers = _print_Atom
158     _print_Complexes = _print_Atom
159 
160     def _print_Reals(self, e):
161         if self._use_unicode:
162             return self._print_Atom(e)
163         else:
164             inf_list = ['-oo', 'oo']
165             return self._print_seq(inf_list, '(', ')')
166 
167     def _print_subfactorial(self, e):
168         x = e.args[0]
169         pform = self._print(x)
170         # Add parentheses if needed
171         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
172             pform = prettyForm(*pform.parens())
173         pform = prettyForm(*pform.left('!'))
174         return pform
175 
176     def _print_factorial(self, e):
177         x = e.args[0]
178         pform = self._print(x)
179         # Add parentheses if needed
180         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
181             pform = prettyForm(*pform.parens())
182         pform = prettyForm(*pform.right('!'))
183         return pform
184 
185     def _print_factorial2(self, e):
186         x = e.args[0]
187         pform = self._print(x)
188         # Add parentheses if needed
189         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
190             pform = prettyForm(*pform.parens())
191         pform = prettyForm(*pform.right('!!'))
192         return pform
193 
194     def _print_binomial(self, e):
195         n, k = e.args
196 
197         n_pform = self._print(n)
198         k_pform = self._print(k)
199 
200         bar = ' '*max(n_pform.width(), k_pform.width())
201 
202         pform = prettyForm(*k_pform.above(bar))
203         pform = prettyForm(*pform.above(n_pform))
204         pform = prettyForm(*pform.parens('(', ')'))
205 
206         pform.baseline = (pform.baseline + 1)//2
207 
208         return pform
209 
210     def _print_Relational(self, e):
211         op = prettyForm(' ' + xsym(e.rel_op) + ' ')
212 
213         l = self._print(e.lhs)
214         r = self._print(e.rhs)
215         pform = prettyForm(*stringPict.next(l, op, r))
216         return pform
217 
218     def _print_Not(self, e):
219         from sympy import Equivalent, Implies
220         if self._use_unicode:
221             arg = e.args[0]
222             pform = self._print(arg)
223             if isinstance(arg, Equivalent):
224                 return self._print_Equivalent(arg, altchar=u"\N{LEFT RIGHT DOUBLE ARROW WITH STROKE}")
225             if isinstance(arg, Implies):
226                 return self._print_Implies(arg, altchar=u"\N{RIGHTWARDS ARROW WITH STROKE}")
227 
228             if arg.is_Boolean and not arg.is_Not:
229                 pform = prettyForm(*pform.parens())
230 
231             return prettyForm(*pform.left(u"\N{NOT SIGN}"))
232         else:
233             return self._print_Function(e)
234 
235     def __print_Boolean(self, e, char, sort=True):
236         args = e.args
237         if sort:
238             args = sorted(e.args, key=default_sort_key)
239         arg = args[0]
240         pform = self._print(arg)
241 
242         if arg.is_Boolean and not arg.is_Not:
243             pform = prettyForm(*pform.parens())
244 
245         for arg in args[1:]:
246             pform_arg = self._print(arg)
247 
248             if arg.is_Boolean and not arg.is_Not:
249                 pform_arg = prettyForm(*pform_arg.parens())
250 
251             pform = prettyForm(*pform.right(u' %s ' % char))
252             pform = prettyForm(*pform.right(pform_arg))
253 
254         return pform
255 
256     def _print_And(self, e):
257         if self._use_unicode:
258             return self.__print_Boolean(e, u"\N{LOGICAL AND}")
259         else:
260             return self._print_Function(e, sort=True)
261 
262     def _print_Or(self, e):
263         if self._use_unicode:
264             return self.__print_Boolean(e, u"\N{LOGICAL OR}")
265         else:
266             return self._print_Function(e, sort=True)
267 
268     def _print_Xor(self, e):
269         if self._use_unicode:
270             return self.__print_Boolean(e, u"\N{XOR}")
271         else:
272             return self._print_Function(e, sort=True)
273 
274     def _print_Nand(self, e):
275         if self._use_unicode:
276             return self.__print_Boolean(e, u"\N{NAND}")
277         else:
278             return self._print_Function(e, sort=True)
279 
280     def _print_Nor(self, e):
281         if self._use_unicode:
282             return self.__print_Boolean(e, u"\N{NOR}")
283         else:
284             return self._print_Function(e, sort=True)
285 
286     def _print_Implies(self, e, altchar=None):
287         if self._use_unicode:
288             return self.__print_Boolean(e, altchar or u"\N{RIGHTWARDS ARROW}", sort=False)
289         else:
290             return self._print_Function(e)
291 
292     def _print_Equivalent(self, e, altchar=None):
293         if self._use_unicode:
294             return self.__print_Boolean(e, altchar or u"\N{LEFT RIGHT DOUBLE ARROW}")
295         else:
296             return self._print_Function(e, sort=True)
297 
298     def _print_conjugate(self, e):
299         pform = self._print(e.args[0])
300         return prettyForm( *pform.above( hobj('_', pform.width())) )
301 
302     def _print_Abs(self, e):
303         pform = self._print(e.args[0])
304         pform = prettyForm(*pform.parens('|', '|'))
305         return pform
306     _print_Determinant = _print_Abs
307 
308     def _print_floor(self, e):
309         if self._use_unicode:
310             pform = self._print(e.args[0])
311             pform = prettyForm(*pform.parens('lfloor', 'rfloor'))
312             return pform
313         else:
314             return self._print_Function(e)
315 
316     def _print_ceiling(self, e):
317         if self._use_unicode:
318             pform = self._print(e.args[0])
319             pform = prettyForm(*pform.parens('lceil', 'rceil'))
320             return pform
321         else:
322             return self._print_Function(e)
323 
324     def _print_Derivative(self, deriv):
325         if requires_partial(deriv) and self._use_unicode:
326             deriv_symbol = U('PARTIAL DIFFERENTIAL')
327         else:
328             deriv_symbol = r'd'
329         x = None
330         count_total_deriv = 0
331 
332         for sym, num in reversed(deriv.variable_count):
333             s = self._print(sym)
334             ds = prettyForm(*s.left(deriv_symbol))
335             count_total_deriv += num
336 
337             if (not num.is_Integer) or (num > 1):
338                 ds = ds**prettyForm(str(num))
339 
340             if x is None:
341                 x = ds
342             else:
343                 x = prettyForm(*x.right(' '))
344                 x = prettyForm(*x.right(ds))
345 
346         f = prettyForm(
347             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
348 
349         pform = prettyForm(deriv_symbol)
350 
351         if (count_total_deriv > 1) != False:
352             pform = pform**prettyForm(str(count_total_deriv))
353 
354         pform = prettyForm(*pform.below(stringPict.LINE, x))
355         pform.baseline = pform.baseline + 1
356         pform = prettyForm(*stringPict.next(pform, f))
357         pform.binding = prettyForm.MUL
358 
359         return pform
360 
361     def _print_Cycle(self, dc):
362         from sympy.combinatorics.permutations import Permutation, Cycle
363         # for Empty Cycle
364         if dc == Cycle():
365             cyc = stringPict('')
366             return prettyForm(*cyc.parens())
367 
368         dc_list = Permutation(dc.list()).cyclic_form
369         # for Identity Cycle
370         if dc_list == []:
371             cyc = self._print(dc.size - 1)
372             return prettyForm(*cyc.parens())
373 
374         cyc = stringPict('')
375         for i in dc_list:
376             l = self._print(str(tuple(i)).replace(',', ''))
377             cyc = prettyForm(*cyc.right(l))
378         return cyc
379 
380     def _print_PDF(self, pdf):
381         lim = self._print(pdf.pdf.args[0])
382         lim = prettyForm(*lim.right(', '))
383         lim = prettyForm(*lim.right(self._print(pdf.domain[0])))
384         lim = prettyForm(*lim.right(', '))
385         lim = prettyForm(*lim.right(self._print(pdf.domain[1])))
386         lim = prettyForm(*lim.parens())
387 
388         f = self._print(pdf.pdf.args[1])
389         f = prettyForm(*f.right(', '))
390         f = prettyForm(*f.right(lim))
391         f = prettyForm(*f.parens())
392 
393         pform = prettyForm('PDF')
394         pform = prettyForm(*pform.right(f))
395         return pform
396 
397     def _print_Integral(self, integral):
398         f = integral.function
399 
400         # Add parentheses if arg involves addition of terms and
401         # create a pretty form for the argument
402         prettyF = self._print(f)
403         # XXX generalize parens
404         if f.is_Add:
405             prettyF = prettyForm(*prettyF.parens())
406 
407         # dx dy dz ...
408         arg = prettyF
409         for x in integral.limits:
410             prettyArg = self._print(x[0])
411             # XXX qparens (parens if needs-parens)
412             if prettyArg.width() > 1:
413                 prettyArg = prettyForm(*prettyArg.parens())
414 
415             arg = prettyForm(*arg.right(' d', prettyArg))
416 
417         # \int \int \int ...
418         firstterm = True
419         s = None
420         for lim in integral.limits:
421             x = lim[0]
422             # Create bar based on the height of the argument
423             h = arg.height()
424             H = h + 2
425 
426             # XXX hack!
427             ascii_mode = not self._use_unicode
428             if ascii_mode:
429                 H += 2
430 
431             vint = vobj('int', H)
432 
433             # Construct the pretty form with the integral sign and the argument
434             pform = prettyForm(vint)
435             pform.baseline = arg.baseline + (
436                 H - h)//2    # covering the whole argument
437 
438             if len(lim) > 1:
439                 # Create pretty forms for endpoints, if definite integral.
440                 # Do not print empty endpoints.
441                 if len(lim) == 2:
442                     prettyA = prettyForm("")
443                     prettyB = self._print(lim[1])
444                 if len(lim) == 3:
445                     prettyA = self._print(lim[1])
446                     prettyB = self._print(lim[2])
447 
448                 if ascii_mode:  # XXX hack
449                     # Add spacing so that endpoint can more easily be
450                     # identified with the correct integral sign
451                     spc = max(1, 3 - prettyB.width())
452                     prettyB = prettyForm(*prettyB.left(' ' * spc))
453 
454                     spc = max(1, 4 - prettyA.width())
455                     prettyA = prettyForm(*prettyA.right(' ' * spc))
456 
457                 pform = prettyForm(*pform.above(prettyB))
458                 pform = prettyForm(*pform.below(prettyA))
459 
460             if not ascii_mode:  # XXX hack
461                 pform = prettyForm(*pform.right(' '))
462 
463             if firstterm:
464                 s = pform   # first term
465                 firstterm = False
466             else:
467                 s = prettyForm(*s.left(pform))
468 
469         pform = prettyForm(*arg.left(s))
470         pform.binding = prettyForm.MUL
471         return pform
472 
473     def _print_Product(self, expr):
474         func = expr.term
475         pretty_func = self._print(func)
476 
477         horizontal_chr = xobj('_', 1)
478         corner_chr = xobj('_', 1)
479         vertical_chr = xobj('|', 1)
480 
481         if self._use_unicode:
482             # use unicode corners
483             horizontal_chr = xobj('-', 1)
484             corner_chr = u'\N{BOX DRAWINGS LIGHT DOWN AND HORIZONTAL}'
485 
486         func_height = pretty_func.height()
487 
488         first = True
489         max_upper = 0
490         sign_height = 0
491 
492         for lim in expr.limits:
493             width = (func_height + 2) * 5 // 3 - 2
494             sign_lines = []
495             sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)
496             for i in range(func_height + 1):
497                 sign_lines.append(vertical_chr + (' '*width) + vertical_chr)
498 
499             pretty_sign = stringPict('')
500             pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))
501 
502             pretty_upper = self._print(lim[2])
503             pretty_lower = self._print(Equality(lim[0], lim[1]))
504 
505             max_upper = max(max_upper, pretty_upper.height())
506 
507             if first:
508                 sign_height = pretty_sign.height()
509 
510             pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))
511             pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))
512 
513             if first:
514                 pretty_func.baseline = 0
515                 first = False
516 
517             height = pretty_sign.height()
518             padding = stringPict('')
519             padding = prettyForm(*padding.stack(*[' ']*(height - 1)))
520             pretty_sign = prettyForm(*pretty_sign.right(padding))
521 
522             pretty_func = prettyForm(*pretty_sign.right(pretty_func))
523 
524         pretty_func.baseline = max_upper + sign_height//2
525         pretty_func.binding = prettyForm.MUL
526         return pretty_func
527 
528     def _print_Sum(self, expr):
529         ascii_mode = not self._use_unicode
530 
531         def asum(hrequired, lower, upper, use_ascii):
532             def adjust(s, wid=None, how='<^>'):
533                 if not wid or len(s) > wid:
534                     return s
535                 need = wid - len(s)
536                 if how == '<^>' or how == "<" or how not in list('<^>'):
537                     return s + ' '*need
538                 half = need//2
539                 lead = ' '*half
540                 if how == ">":
541                     return " "*need + s
542                 return lead + s + ' '*(need - len(lead))
543 
544             h = max(hrequired, 2)
545             d = h//2
546             w = d + 1
547             more = hrequired % 2
548 
549             lines = []
550             if use_ascii:
551                 lines.append("_"*(w) + ' ')
552                 lines.append(r"\%s`" % (' '*(w - 1)))
553                 for i in range(1, d):
554                     lines.append('%s\\%s' % (' '*i, ' '*(w - i)))
555                 if more:
556                     lines.append('%s)%s' % (' '*(d), ' '*(w - d)))
557                 for i in reversed(range(1, d)):
558                     lines.append('%s/%s' % (' '*i, ' '*(w - i)))
559                 lines.append("/" + "_"*(w - 1) + ',')
560                 return d, h + more, lines, 0
561             else:
562                 w = w + more
563                 d = d + more
564                 vsum = vobj('sum', 4)
565                 lines.append("_"*(w))
566                 for i in range(0, d):
567                     lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))
568                 for i in reversed(range(0, d)):
569                     lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))
570                 lines.append(vsum[8]*(w))
571                 return d, h + 2*more, lines, more
572 
573         f = expr.function
574 
575         prettyF = self._print(f)
576 
577         if f.is_Add:  # add parens
578             prettyF = prettyForm(*prettyF.parens())
579 
580         H = prettyF.height() + 2
581 
582         # \sum \sum \sum ...
583         first = True
584         max_upper = 0
585         sign_height = 0
586 
587         for lim in expr.limits:
588             if len(lim) == 3:
589                 prettyUpper = self._print(lim[2])
590                 prettyLower = self._print(Equality(lim[0], lim[1]))
591             elif len(lim) == 2:
592                 prettyUpper = self._print("")
593                 prettyLower = self._print(Equality(lim[0], lim[1]))
594             elif len(lim) == 1:
595                 prettyUpper = self._print("")
596                 prettyLower = self._print(lim[0])
597 
598             max_upper = max(max_upper, prettyUpper.height())
599 
600             # Create sum sign based on the height of the argument
601             d, h, slines, adjustment = asum(
602                 H, prettyLower.width(), prettyUpper.width(), ascii_mode)
603             prettySign = stringPict('')
604             prettySign = prettyForm(*prettySign.stack(*slines))
605 
606             if first:
607                 sign_height = prettySign.height()
608 
609             prettySign = prettyForm(*prettySign.above(prettyUpper))
610             prettySign = prettyForm(*prettySign.below(prettyLower))
611 
612             if first:
613                 # change F baseline so it centers on the sign
614                 prettyF.baseline -= d - (prettyF.height()//2 -
615                                          prettyF.baseline) - adjustment
616                 first = False
617 
618             # put padding to the right
619             pad = stringPict('')
620             pad = prettyForm(*pad.stack(*[' ']*h))
621             prettySign = prettyForm(*prettySign.right(pad))
622             # put the present prettyF to the right
623             prettyF = prettyForm(*prettySign.right(prettyF))
624 
625         prettyF.baseline = max_upper + sign_height//2
626         prettyF.binding = prettyForm.MUL
627         return prettyF
628 
629     def _print_Limit(self, l):
630         e, z, z0, dir = l.args
631 
632         E = self._print(e)
633         if precedence(e) <= PRECEDENCE["Mul"]:
634             E = prettyForm(*E.parens('(', ')'))
635         Lim = prettyForm('lim')
636 
637         LimArg = self._print(z)
638         if self._use_unicode:
639             LimArg = prettyForm(*LimArg.right(u'\N{BOX DRAWINGS LIGHT HORIZONTAL}\N{RIGHTWARDS ARROW}'))
640         else:
641             LimArg = prettyForm(*LimArg.right('->'))
642         LimArg = prettyForm(*LimArg.right(self._print(z0)))
643 
644         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
645             dir = ""
646         else:
647             if self._use_unicode:
648                 dir = u'\N{SUPERSCRIPT PLUS SIGN}' if str(dir) == "+" else u'\N{SUPERSCRIPT MINUS}'
649 
650         LimArg = prettyForm(*LimArg.right(self._print(dir)))
651 
652         Lim = prettyForm(*Lim.below(LimArg))
653         Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)
654 
655         return Lim
656 
657     def _print_matrix_contents(self, e):
658         """
659         This method factors out what is essentially grid printing.
660         """
661         M = e   # matrix
662         Ms = {}  # i,j -> pretty(M[i,j])
663         for i in range(M.rows):
664             for j in range(M.cols):
665                 Ms[i, j] = self._print(M[i, j])
666 
667         # h- and v- spacers
668         hsep = 2
669         vsep = 1
670 
671         # max width for columns
672         maxw = [-1] * M.cols
673 
674         for j in range(M.cols):
675             maxw[j] = max([Ms[i, j].width() for i in range(M.rows)] or [0])
676 
677         # drawing result
678         D = None
679 
680         for i in range(M.rows):
681 
682             D_row = None
683             for j in range(M.cols):
684                 s = Ms[i, j]
685 
686                 # reshape s to maxw
687                 # XXX this should be generalized, and go to stringPict.reshape ?
688                 assert s.width() <= maxw[j]
689 
690                 # hcenter it, +0.5 to the right                        2
691                 # ( it's better to align formula starts for say 0 and r )
692                 # XXX this is not good in all cases -- maybe introduce vbaseline?
693                 wdelta = maxw[j] - s.width()
694                 wleft = wdelta // 2
695                 wright = wdelta - wleft
696 
697                 s = prettyForm(*s.right(' '*wright))
698                 s = prettyForm(*s.left(' '*wleft))
699 
700                 # we don't need vcenter cells -- this is automatically done in
701                 # a pretty way because when their baselines are taking into
702                 # account in .right()
703 
704                 if D_row is None:
705                     D_row = s   # first box in a row
706                     continue
707 
708                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
709                 D_row = prettyForm(*D_row.right(s))
710 
711             if D is None:
712                 D = D_row       # first row in a picture
713                 continue
714 
715             # v-spacer
716             for _ in range(vsep):
717                 D = prettyForm(*D.below(' '))
718 
719             D = prettyForm(*D.below(D_row))
720 
721         if D is None:
722             D = prettyForm('')  # Empty Matrix
723 
724         return D
725 
726     def _print_MatrixBase(self, e):
727         D = self._print_matrix_contents(e)
728         D.baseline = D.height()//2
729         D = prettyForm(*D.parens('[', ']'))
730         return D
731     _print_ImmutableMatrix = _print_MatrixBase
732     _print_Matrix = _print_MatrixBase
733 
734     def _print_TensorProduct(self, expr):
735         # This should somehow share the code with _print_WedgeProduct:
736         circled_times = "\u2297"
737         return self._print_seq(expr.args, None, None, circled_times,
738             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
739 
740     def _print_WedgeProduct(self, expr):
741         # This should somehow share the code with _print_TensorProduct:
742         wedge_symbol = u"\u2227"
743         return self._print_seq(expr.args, None, None, wedge_symbol,
744             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
745 
746     def _print_Trace(self, e):
747         D = self._print(e.arg)
748         D = prettyForm(*D.parens('(',')'))
749         D.baseline = D.height()//2
750         D = prettyForm(*D.left('\n'*(0) + 'tr'))
751         return D
752 
753 
754     def _print_MatrixElement(self, expr):
755         from sympy.matrices import MatrixSymbol
756         from sympy import Symbol
757         if (isinstance(expr.parent, MatrixSymbol)
758                 and expr.i.is_number and expr.j.is_number):
759             return self._print(
760                     Symbol(expr.parent.name + '_%d%d' % (expr.i, expr.j)))
761         else:
762             prettyFunc = self._print(expr.parent)
763             prettyFunc = prettyForm(*prettyFunc.parens())
764             prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '
765                     ).parens(left='[', right=']')[0]
766             pform = prettyForm(binding=prettyForm.FUNC,
767                     *stringPict.next(prettyFunc, prettyIndices))
768 
769             # store pform parts so it can be reassembled e.g. when powered
770             pform.prettyFunc = prettyFunc
771             pform.prettyArgs = prettyIndices
772 
773             return pform
774 
775 
776     def _print_MatrixSlice(self, m):
777         # XXX works only for applied functions
778         prettyFunc = self._print(m.parent)
779         def ppslice(x):
780             x = list(x)
781             if x[2] == 1:
782                 del x[2]
783             if x[1] == x[0] + 1:
784                 del x[1]
785             if x[0] == 0:
786                 x[0] = ''
787             return prettyForm(*self._print_seq(x, delimiter=':'))
788         prettyArgs = self._print_seq((ppslice(m.rowslice),
789             ppslice(m.colslice)), delimiter=', ').parens(left='[', right=']')[0]
790 
791         pform = prettyForm(
792             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
793 
794         # store pform parts so it can be reassembled e.g. when powered
795         pform.prettyFunc = prettyFunc
796         pform.prettyArgs = prettyArgs
797 
798         return pform
799 
800     def _print_Transpose(self, expr):
801         pform = self._print(expr.arg)
802         from sympy.matrices import MatrixSymbol
803         if not isinstance(expr.arg, MatrixSymbol):
804             pform = prettyForm(*pform.parens())
805         pform = pform**(prettyForm('T'))
806         return pform
807 
808     def _print_Adjoint(self, expr):
809         pform = self._print(expr.arg)
810         if self._use_unicode:
811             dag = prettyForm(u'\N{DAGGER}')
812         else:
813             dag = prettyForm('+')
814         from sympy.matrices import MatrixSymbol
815         if not isinstance(expr.arg, MatrixSymbol):
816             pform = prettyForm(*pform.parens())
817         pform = pform**dag
818         return pform
819 
820     def _print_BlockMatrix(self, B):
821         if B.blocks.shape == (1, 1):
822             return self._print(B.blocks[0, 0])
823         return self._print(B.blocks)
824 
825     def _print_MatAdd(self, expr):
826         s = None
827         for item in expr.args:
828             pform = self._print(item)
829             if s is None:
830                 s = pform     # First element
831             else:
832                 coeff = item.as_coeff_mmul()[0]
833                 if _coeff_isneg(S(coeff)):
834                     s = prettyForm(*stringPict.next(s, ' '))
835                     pform = self._print(item)
836                 else:
837                     s = prettyForm(*stringPict.next(s, ' + '))
838                 s = prettyForm(*stringPict.next(s, pform))
839 
840         return s
841 
842     def _print_MatMul(self, expr):
843         args = list(expr.args)
844         from sympy import Add, MatAdd, HadamardProduct, KroneckerProduct
845         for i, a in enumerate(args):
846             if (isinstance(a, (Add, MatAdd, HadamardProduct, KroneckerProduct))
847                     and len(expr.args) > 1):
848                 args[i] = prettyForm(*self._print(a).parens())
849             else:
850                 args[i] = self._print(a)
851 
852         return prettyForm.__mul__(*args)
853 
854     def _print_DotProduct(self, expr):
855         args = list(expr.args)
856 
857         for i, a in enumerate(args):
858             args[i] = self._print(a)
859         return prettyForm.__mul__(*args)
860 
861     def _print_MatPow(self, expr):
862         pform = self._print(expr.base)
863         from sympy.matrices import MatrixSymbol
864         if not isinstance(expr.base, MatrixSymbol):
865             pform = prettyForm(*pform.parens())
866         pform = pform**(self._print(expr.exp))
867         return pform
868 
869     def _print_HadamardProduct(self, expr):
870         from sympy import MatAdd, MatMul
871         if self._use_unicode:
872             delim = pretty_atom('Ring')
873         else:
874             delim = '.*'
875         return self._print_seq(expr.args, None, None, delim,
876                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
877 
878     def _print_KroneckerProduct(self, expr):
879         from sympy import MatAdd, MatMul
880         if self._use_unicode:
881             delim = u' \N{N-ARY CIRCLED TIMES OPERATOR} '
882         else:
883             delim = ' x '
884         return self._print_seq(expr.args, None, None, delim,
885                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
886 
887     def _print_FunctionMatrix(self, X):
888         D = self._print(X.lamda.expr)
889         D = prettyForm(*D.parens('[', ']'))
890         return D
891 
892     def _print_BasisDependent(self, expr):
893         from sympy.vector import Vector
894 
895         if not self._use_unicode:
896             raise NotImplementedError("ASCII pretty printing of BasisDependent is not implemented")
897 
898         if expr == expr.zero:
899             return prettyForm(expr.zero._pretty_form)
900         o1 = []
901         vectstrs = []
902         if isinstance(expr, Vector):
903             items = expr.separate().items()
904         else:
905             items = [(0, expr)]
906         for system, vect in items:
907             inneritems = list(vect.components.items())
908             inneritems.sort(key = lambda x: x[0].__str__())
909             for k, v in inneritems:
910                 #if the coef of the basis vector is 1
911                 #we skip the 1
912                 if v == 1:
913                     o1.append(u"" +
914                               k._pretty_form)
915                 #Same for -1
916                 elif v == -1:
917                     o1.append(u"(-1) " +
918                               k._pretty_form)
919                 #For a general expr
920                 else:
921                     #We always wrap the measure numbers in
922                     #parentheses
923                     arg_str = self._print(
924                         v).parens()[0]
925 
926                     o1.append(arg_str + ' ' + k._pretty_form)
927                 vectstrs.append(k._pretty_form)
928 
929         #outstr = u("").join(o1)
930         if o1[0].startswith(u" + "):
931             o1[0] = o1[0][3:]
932         elif o1[0].startswith(" "):
933             o1[0] = o1[0][1:]
934         #Fixing the newlines
935         lengths = []
936         strs = ['']
937         flag = []
938         for i, partstr in enumerate(o1):
939             flag.append(0)
940             # XXX: What is this hack?
941             if '\n' in partstr:
942                 tempstr = partstr
943                 tempstr = tempstr.replace(vectstrs[i], '')
944                 if u'\N{right parenthesis extension}' in tempstr:   # If scalar is a fraction
945                     for paren in range(len(tempstr)):
946                         flag[i] = 1
947                         if tempstr[paren] == u'\N{right parenthesis extension}':
948                             tempstr = tempstr[:paren] + u'\N{right parenthesis extension}'\
949                                          + ' '  + vectstrs[i] + tempstr[paren + 1:]
950                             break
951                 elif u'\N{RIGHT PARENTHESIS LOWER HOOK}' in tempstr:
952                     flag[i] = 1
953                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS LOWER HOOK}',
954                                         u'\N{RIGHT PARENTHESIS LOWER HOOK}'
955                                         + ' ' + vectstrs[i])
956                 else:
957                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS UPPER HOOK}',
958                                         u'\N{RIGHT PARENTHESIS UPPER HOOK}'
959                                         + ' ' + vectstrs[i])
960                 o1[i] = tempstr
961 
962         o1 = [x.split('\n') for x in o1]
963         n_newlines = max([len(x) for x in o1])  # Width of part in its pretty form
964 
965         if 1 in flag:                           # If there was a fractional scalar
966             for i, parts in enumerate(o1):
967                 if len(parts) == 1:             # If part has no newline
968                     parts.insert(0, ' ' * (len(parts[0])))
969                     flag[i] = 1
970 
971         for i, parts in enumerate(o1):
972             lengths.append(len(parts[flag[i]]))
973             for j in range(n_newlines):
974                 if j+1 <= len(parts):
975                     if j >= len(strs):
976                         strs.append(' ' * (sum(lengths[:-1]) +
977                                            3*(len(lengths)-1)))
978                     if j == flag[i]:
979                         strs[flag[i]] += parts[flag[i]] + ' + '
980                     else:
981                         strs[j] += parts[j] + ' '*(lengths[-1] -
982                                                    len(parts[j])+
983                                                    3)
984                 else:
985                     if j >= len(strs):
986                         strs.append(' ' * (sum(lengths[:-1]) +
987                                            3*(len(lengths)-1)))
988                     strs[j] += ' '*(lengths[-1]+3)
989 
990         return prettyForm(u'\n'.join([s[:-3] for s in strs]))
991 
992     def _print_NDimArray(self, expr):
993         from sympy import ImmutableMatrix
994 
995         if expr.rank() == 0:
996             return self._print(expr[()])
997 
998         level_str = [[]] + [[] for i in range(expr.rank())]
999         shape_ranges = [list(range(i)) for i in expr.shape]
1000         for outer_i in itertools.product(*shape_ranges):
1001             level_str[-1].append(expr[outer_i])
1002             even = True
1003             for back_outer_i in range(expr.rank()-1, -1, -1):
1004                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1005                     break
1006                 if even:
1007                     level_str[back_outer_i].append(level_str[back_outer_i+1])
1008                 else:
1009                     level_str[back_outer_i].append(ImmutableMatrix(level_str[back_outer_i+1]))
1010                     if len(level_str[back_outer_i + 1]) == 1:
1011                         level_str[back_outer_i][-1] = ImmutableMatrix([[level_str[back_outer_i][-1]]])
1012                 even = not even
1013                 level_str[back_outer_i+1] = []
1014 
1015         out_expr = level_str[0][0]
1016         if expr.rank() % 2 == 1:
1017             out_expr = ImmutableMatrix([out_expr])
1018 
1019         return self._print(out_expr)
1020 
1021     _print_ImmutableDenseNDimArray = _print_NDimArray
1022     _print_ImmutableSparseNDimArray = _print_NDimArray
1023     _print_MutableDenseNDimArray = _print_NDimArray
1024     _print_MutableSparseNDimArray = _print_NDimArray
1025 
1026     def _printer_tensor_indices(self, name, indices, index_map={}):
1027         center = stringPict(name)
1028         top = stringPict(" "*center.width())
1029         bot = stringPict(" "*center.width())
1030 
1031         last_valence = None
1032         prev_map = None
1033 
1034         for i, index in enumerate(indices):
1035             indpic = self._print(index.args[0])
1036             if ((index in index_map) or prev_map) and last_valence == index.is_up:
1037                 if index.is_up:
1038                     top = prettyForm(*stringPict.next(top, ","))
1039                 else:
1040                     bot = prettyForm(*stringPict.next(bot, ","))
1041             if index in index_map:
1042                 indpic = prettyForm(*stringPict.next(indpic, "="))
1043                 indpic = prettyForm(*stringPict.next(indpic, self._print(index_map[index])))
1044                 prev_map = True
1045             else:
1046                 prev_map = False
1047             if index.is_up:
1048                 top = stringPict(*top.right(indpic))
1049                 center = stringPict(*center.right(" "*indpic.width()))
1050                 bot = stringPict(*bot.right(" "*indpic.width()))
1051             else:
1052                 bot = stringPict(*bot.right(indpic))
1053                 center = stringPict(*center.right(" "*indpic.width()))
1054                 top = stringPict(*top.right(" "*indpic.width()))
1055             last_valence = index.is_up
1056 
1057         pict = prettyForm(*center.above(top))
1058         pict = prettyForm(*pict.below(bot))
1059         return pict
1060 
1061     def _print_Tensor(self, expr):
1062         name = expr.args[0].name
1063         indices = expr.get_indices()
1064         return self._printer_tensor_indices(name, indices)
1065 
1066     def _print_TensorElement(self, expr):
1067         name = expr.expr.args[0].name
1068         indices = expr.expr.get_indices()
1069         index_map = expr.index_map
1070         return self._printer_tensor_indices(name, indices, index_map)
1071 
1072     def _print_TensMul(self, expr):
1073         sign, args = expr._get_args_for_traditional_printer()
1074         args = [
1075             prettyForm(*self._print(i).parens()) if
1076             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1077             for i in args
1078         ]
1079         pform = prettyForm.__mul__(*args)
1080         if sign:
1081             return prettyForm(*pform.left(sign))
1082         else:
1083             return pform
1084 
1085     def _print_TensAdd(self, expr):
1086         args = [
1087             prettyForm(*self._print(i).parens()) if
1088             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1089             for i in expr.args
1090         ]
1091         return prettyForm.__add__(*args)
1092 
1093     def _print_TensorIndex(self, expr):
1094         sym = expr.args[0]
1095         if not expr.is_up:
1096             sym = -sym
1097         return self._print(sym)
1098 
1099     def _print_PartialDerivative(self, deriv):
1100         if self._use_unicode:
1101             deriv_symbol = U('PARTIAL DIFFERENTIAL')
1102         else:
1103             deriv_symbol = r'd'
1104         x = None
1105 
1106         for variable in reversed(deriv.variables):
1107             s = self._print(variable)
1108             ds = prettyForm(*s.left(deriv_symbol))
1109 
1110             if x is None:
1111                 x = ds
1112             else:
1113                 x = prettyForm(*x.right(' '))
1114                 x = prettyForm(*x.right(ds))
1115 
1116         f = prettyForm(
1117             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
1118 
1119         pform = prettyForm(deriv_symbol)
1120 
1121         pform = prettyForm(*pform.below(stringPict.LINE, x))
1122         pform.baseline = pform.baseline + 1
1123         pform = prettyForm(*stringPict.next(pform, f))
1124         pform.binding = prettyForm.MUL
1125 
1126         return pform
1127 
1128     def _print_Piecewise(self, pexpr):
1129 
1130         P = {}
1131         for n, ec in enumerate(pexpr.args):
1132             P[n, 0] = self._print(ec.expr)
1133             if ec.cond == True:
1134                 P[n, 1] = prettyForm('otherwise')
1135             else:
1136                 P[n, 1] = prettyForm(
1137                     *prettyForm('for ').right(self._print(ec.cond)))
1138         hsep = 2
1139         vsep = 1
1140         len_args = len(pexpr.args)
1141 
1142         # max widths
1143         maxw = [max([P[i, j].width() for i in range(len_args)])
1144                 for j in range(2)]
1145 
1146         # FIXME: Refactor this code and matrix into some tabular environment.
1147         # drawing result
1148         D = None
1149 
1150         for i in range(len_args):
1151             D_row = None
1152             for j in range(2):
1153                 p = P[i, j]
1154                 assert p.width() <= maxw[j]
1155 
1156                 wdelta = maxw[j] - p.width()
1157                 wleft = wdelta // 2
1158                 wright = wdelta - wleft
1159 
1160                 p = prettyForm(*p.right(' '*wright))
1161                 p = prettyForm(*p.left(' '*wleft))
1162 
1163                 if D_row is None:
1164                     D_row = p
1165                     continue
1166 
1167                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
1168                 D_row = prettyForm(*D_row.right(p))
1169             if D is None:
1170                 D = D_row       # first row in a picture
1171                 continue
1172 
1173             # v-spacer
1174             for _ in range(vsep):
1175                 D = prettyForm(*D.below(' '))
1176 
1177             D = prettyForm(*D.below(D_row))
1178 
1179         D = prettyForm(*D.parens('{', ''))
1180         D.baseline = D.height()//2
1181         D.binding = prettyForm.OPEN
1182         return D
1183 
1184     def _print_ITE(self, ite):
1185         from sympy.functions.elementary.piecewise import Piecewise
1186         return self._print(ite.rewrite(Piecewise))
1187 
1188     def _hprint_vec(self, v):
1189         D = None
1190 
1191         for a in v:
1192             p = a
1193             if D is None:
1194                 D = p
1195             else:
1196                 D = prettyForm(*D.right(', '))
1197                 D = prettyForm(*D.right(p))
1198         if D is None:
1199             D = stringPict(' ')
1200 
1201         return D
1202 
1203     def _hprint_vseparator(self, p1, p2):
1204         tmp = prettyForm(*p1.right(p2))
1205         sep = stringPict(vobj('|', tmp.height()), baseline=tmp.baseline)
1206         return prettyForm(*p1.right(sep, p2))
1207 
1208     def _print_hyper(self, e):
1209         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1210         ap = [self._print(a) for a in e.ap]
1211         bq = [self._print(b) for b in e.bq]
1212 
1213         P = self._print(e.argument)
1214         P.baseline = P.height()//2
1215 
1216         # Drawing result - first create the ap, bq vectors
1217         D = None
1218         for v in [ap, bq]:
1219             D_row = self._hprint_vec(v)
1220             if D is None:
1221                 D = D_row       # first row in a picture
1222             else:
1223                 D = prettyForm(*D.below(' '))
1224                 D = prettyForm(*D.below(D_row))
1225 
1226         # make sure that the argument `z' is centred vertically
1227         D.baseline = D.height()//2
1228 
1229         # insert horizontal separator
1230         P = prettyForm(*P.left(' '))
1231         D = prettyForm(*D.right(' '))
1232 
1233         # insert separating `|`
1234         D = self._hprint_vseparator(D, P)
1235 
1236         # add parens
1237         D = prettyForm(*D.parens('(', ')'))
1238 
1239         # create the F symbol
1240         above = D.height()//2 - 1
1241         below = D.height() - above - 1
1242 
1243         sz, t, b, add, img = annotated('F')
1244         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1245                        baseline=above + sz)
1246         add = (sz + 1)//2
1247 
1248         F = prettyForm(*F.left(self._print(len(e.ap))))
1249         F = prettyForm(*F.right(self._print(len(e.bq))))
1250         F.baseline = above + add
1251 
1252         D = prettyForm(*F.right(' ', D))
1253 
1254         return D
1255 
1256     def _print_meijerg(self, e):
1257         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1258 
1259         v = {}
1260         v[(0, 0)] = [self._print(a) for a in e.an]
1261         v[(0, 1)] = [self._print(a) for a in e.aother]
1262         v[(1, 0)] = [self._print(b) for b in e.bm]
1263         v[(1, 1)] = [self._print(b) for b in e.bother]
1264 
1265         P = self._print(e.argument)
1266         P.baseline = P.height()//2
1267 
1268         vp = {}
1269         for idx in v:
1270             vp[idx] = self._hprint_vec(v[idx])
1271 
1272         for i in range(2):
1273             maxw = max(vp[(0, i)].width(), vp[(1, i)].width())
1274             for j in range(2):
1275                 s = vp[(j, i)]
1276                 left = (maxw - s.width()) // 2
1277                 right = maxw - left - s.width()
1278                 s = prettyForm(*s.left(' ' * left))
1279                 s = prettyForm(*s.right(' ' * right))
1280                 vp[(j, i)] = s
1281 
1282         D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))
1283         D1 = prettyForm(*D1.below(' '))
1284         D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))
1285         D = prettyForm(*D1.below(D2))
1286 
1287         # make sure that the argument `z' is centred vertically
1288         D.baseline = D.height()//2
1289 
1290         # insert horizontal separator
1291         P = prettyForm(*P.left(' '))
1292         D = prettyForm(*D.right(' '))
1293 
1294         # insert separating `|`
1295         D = self._hprint_vseparator(D, P)
1296 
1297         # add parens
1298         D = prettyForm(*D.parens('(', ')'))
1299 
1300         # create the G symbol
1301         above = D.height()//2 - 1
1302         below = D.height() - above - 1
1303 
1304         sz, t, b, add, img = annotated('G')
1305         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1306                        baseline=above + sz)
1307 
1308         pp = self._print(len(e.ap))
1309         pq = self._print(len(e.bq))
1310         pm = self._print(len(e.bm))
1311         pn = self._print(len(e.an))
1312 
1313         def adjust(p1, p2):
1314             diff = p1.width() - p2.width()
1315             if diff == 0:
1316                 return p1, p2
1317             elif diff > 0:
1318                 return p1, prettyForm(*p2.left(' '*diff))
1319             else:
1320                 return prettyForm(*p1.left(' '*-diff)), p2
1321         pp, pm = adjust(pp, pm)
1322         pq, pn = adjust(pq, pn)
1323         pu = prettyForm(*pm.right(', ', pn))
1324         pl = prettyForm(*pp.right(', ', pq))
1325 
1326         ht = F.baseline - above - 2
1327         if ht > 0:
1328             pu = prettyForm(*pu.below('\n'*ht))
1329         p = prettyForm(*pu.below(pl))
1330 
1331         F.baseline = above
1332         F = prettyForm(*F.right(p))
1333 
1334         F.baseline = above + add
1335 
1336         D = prettyForm(*F.right(' ', D))
1337 
1338         return D
1339 
1340     def _print_ExpBase(self, e):
1341         # TODO should exp_polar be printed differently?
1342         #      what about exp_polar(0), exp_polar(1)?
1343         base = prettyForm(pretty_atom('Exp1', 'e'))
1344         return base ** self._print(e.args[0])
1345 
1346     def _print_Function(self, e, sort=False, func_name=None):
1347         # optional argument func_name for supplying custom names
1348         # XXX works only for applied functions
1349         func = e.func
1350         args = e.args
1351         if sort:
1352             args = sorted(args, key=default_sort_key)
1353 
1354         if not func_name:
1355             func_name = func.__name__
1356 
1357         prettyFunc = self._print(Symbol(func_name))
1358         prettyArgs = prettyForm(*self._print_seq(args).parens())
1359 
1360         pform = prettyForm(
1361             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1362 
1363         # store pform parts so it can be reassembled e.g. when powered
1364         pform.prettyFunc = prettyFunc
1365         pform.prettyArgs = prettyArgs
1366 
1367         return pform
1368 
1369     @property
1370     def _special_function_classes(self):
1371         from sympy.functions.special.tensor_functions import KroneckerDelta
1372         from sympy.functions.special.gamma_functions import gamma, lowergamma
1373         from sympy.functions.special.zeta_functions import lerchphi
1374         from sympy.functions.special.beta_functions import beta
1375         from sympy.functions.special.delta_functions import DiracDelta
1376         from sympy.functions.special.error_functions import Chi
1377         return {KroneckerDelta: [greek_unicode['delta'], 'delta'],
1378                 gamma: [greek_unicode['Gamma'], 'Gamma'],
1379                 lerchphi: [greek_unicode['Phi'], 'lerchphi'],
1380                 lowergamma: [greek_unicode['gamma'], 'gamma'],
1381                 beta: [greek_unicode['Beta'], 'B'],
1382                 DiracDelta: [greek_unicode['delta'], 'delta'],
1383                 Chi: ['Chi', 'Chi']}
1384 
1385     def _print_FunctionClass(self, expr):
1386         for cls in self._special_function_classes:
1387             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
1388                 if self._use_unicode:
1389                     return prettyForm(self._special_function_classes[cls][0])
1390                 else:
1391                     return prettyForm(self._special_function_classes[cls][1])
1392         func_name = expr.__name__
1393         return prettyForm(pretty_symbol(func_name))
1394 
1395     def _print_GeometryEntity(self, expr):
1396         # GeometryEntity is based on Tuple but should not print like a Tuple
1397         return self.emptyPrinter(expr)
1398 
1399     def _print_lerchphi(self, e):
1400         func_name = greek_unicode['Phi'] if self._use_unicode else 'lerchphi'
1401         return self._print_Function(e, func_name=func_name)
1402 
1403     def _print_Lambda(self, e):
1404         vars, expr = e.args
1405         if self._use_unicode:
1406             arrow = u" \N{RIGHTWARDS ARROW FROM BAR} "
1407         else:
1408             arrow = " -> "
1409         if len(vars) == 1:
1410             var_form = self._print(vars[0])
1411         else:
1412             var_form = self._print(tuple(vars))
1413 
1414         return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)
1415 
1416     def _print_Order(self, expr):
1417         pform = self._print(expr.expr)
1418         if (expr.point and any(p != S.Zero for p in expr.point)) or \
1419            len(expr.variables) > 1:
1420             pform = prettyForm(*pform.right("; "))
1421             if len(expr.variables) > 1:
1422                 pform = prettyForm(*pform.right(self._print(expr.variables)))
1423             elif len(expr.variables):
1424                 pform = prettyForm(*pform.right(self._print(expr.variables[0])))
1425             if self._use_unicode:
1426                 pform = prettyForm(*pform.right(u" \N{RIGHTWARDS ARROW} "))
1427             else:
1428                 pform = prettyForm(*pform.right(" -> "))
1429             if len(expr.point) > 1:
1430                 pform = prettyForm(*pform.right(self._print(expr.point)))
1431             else:
1432                 pform = prettyForm(*pform.right(self._print(expr.point[0])))
1433         pform = prettyForm(*pform.parens())
1434         pform = prettyForm(*pform.left("O"))
1435         return pform
1436 
1437     def _print_SingularityFunction(self, e):
1438         if self._use_unicode:
1439             shift = self._print(e.args[0]-e.args[1])
1440             n = self._print(e.args[2])
1441             base = prettyForm("<")
1442             base = prettyForm(*base.right(shift))
1443             base = prettyForm(*base.right(">"))
1444             pform = base**n
1445             return pform
1446         else:
1447             n = self._print(e.args[2])
1448             shift = self._print(e.args[0]-e.args[1])
1449             base = self._print_seq(shift, "<", ">", ' ')
1450             return base**n
1451 
1452     def _print_beta(self, e):
1453         func_name = greek_unicode['Beta'] if self._use_unicode else 'B'
1454         return self._print_Function(e, func_name=func_name)
1455 
1456     def _print_gamma(self, e):
1457         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1458         return self._print_Function(e, func_name=func_name)
1459 
1460     def _print_uppergamma(self, e):
1461         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1462         return self._print_Function(e, func_name=func_name)
1463 
1464     def _print_lowergamma(self, e):
1465         func_name = greek_unicode['gamma'] if self._use_unicode else 'lowergamma'
1466         return self._print_Function(e, func_name=func_name)
1467 
1468     def _print_DiracDelta(self, e):
1469         if self._use_unicode:
1470             if len(e.args) == 2:
1471                 a = prettyForm(greek_unicode['delta'])
1472                 b = self._print(e.args[1])
1473                 b = prettyForm(*b.parens())
1474                 c = self._print(e.args[0])
1475                 c = prettyForm(*c.parens())
1476                 pform = a**b
1477                 pform = prettyForm(*pform.right(' '))
1478                 pform = prettyForm(*pform.right(c))
1479                 return pform
1480             pform = self._print(e.args[0])
1481             pform = prettyForm(*pform.parens())
1482             pform = prettyForm(*pform.left(greek_unicode['delta']))
1483             return pform
1484         else:
1485             return self._print_Function(e)
1486 
1487     def _print_expint(self, e):
1488         from sympy import Function
1489         if e.args[0].is_Integer and self._use_unicode:
1490             return self._print_Function(Function('E_%s' % e.args[0])(e.args[1]))
1491         return self._print_Function(e)
1492 
1493     def _print_Chi(self, e):
1494         # This needs a special case since otherwise it comes out as greek
1495         # letter chi...
1496         prettyFunc = prettyForm("Chi")
1497         prettyArgs = prettyForm(*self._print_seq(e.args).parens())
1498 
1499         pform = prettyForm(
1500             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1501 
1502         # store pform parts so it can be reassembled e.g. when powered
1503         pform.prettyFunc = prettyFunc
1504         pform.prettyArgs = prettyArgs
1505 
1506         return pform
1507 
1508     def _print_elliptic_e(self, e):
1509         pforma0 = self._print(e.args[0])
1510         if len(e.args) == 1:
1511             pform = pforma0
1512         else:
1513             pforma1 = self._print(e.args[1])
1514             pform = self._hprint_vseparator(pforma0, pforma1)
1515         pform = prettyForm(*pform.parens())
1516         pform = prettyForm(*pform.left('E'))
1517         return pform
1518 
1519     def _print_elliptic_k(self, e):
1520         pform = self._print(e.args[0])
1521         pform = prettyForm(*pform.parens())
1522         pform = prettyForm(*pform.left('K'))
1523         return pform
1524 
1525     def _print_elliptic_f(self, e):
1526         pforma0 = self._print(e.args[0])
1527         pforma1 = self._print(e.args[1])
1528         pform = self._hprint_vseparator(pforma0, pforma1)
1529         pform = prettyForm(*pform.parens())
1530         pform = prettyForm(*pform.left('F'))
1531         return pform
1532 
1533     def _print_elliptic_pi(self, e):
1534         name = greek_unicode['Pi'] if self._use_unicode else 'Pi'
1535         pforma0 = self._print(e.args[0])
1536         pforma1 = self._print(e.args[1])
1537         if len(e.args) == 2:
1538             pform = self._hprint_vseparator(pforma0, pforma1)
1539         else:
1540             pforma2 = self._print(e.args[2])
1541             pforma = self._hprint_vseparator(pforma1, pforma2)
1542             pforma = prettyForm(*pforma.left('; '))
1543             pform = prettyForm(*pforma.left(pforma0))
1544         pform = prettyForm(*pform.parens())
1545         pform = prettyForm(*pform.left(name))
1546         return pform
1547 
1548     def _print_GoldenRatio(self, expr):
1549         if self._use_unicode:
1550             return prettyForm(pretty_symbol('phi'))
1551         return self._print(Symbol("GoldenRatio"))
1552 
1553     def _print_EulerGamma(self, expr):
1554         if self._use_unicode:
1555             return prettyForm(pretty_symbol('gamma'))
1556         return self._print(Symbol("EulerGamma"))
1557 
1558     def _print_Mod(self, expr):
1559         pform = self._print(expr.args[0])
1560         if pform.binding > prettyForm.MUL:
1561             pform = prettyForm(*pform.parens())
1562         pform = prettyForm(*pform.right(' mod '))
1563         pform = prettyForm(*pform.right(self._print(expr.args[1])))
1564         pform.binding = prettyForm.OPEN
1565         return pform
1566 
1567     def _print_Add(self, expr, order=None):
1568         if self.order == 'none':
1569             terms = list(expr.args)
1570         else:
1571             terms = self._as_ordered_terms(expr, order=order)
1572         pforms, indices = [], []
1573 
1574         def pretty_negative(pform, index):
1575             """Prepend a minus sign to a pretty form. """
1576             #TODO: Move this code to prettyForm
1577             if index == 0:
1578                 if pform.height() > 1:
1579                     pform_neg = '- '
1580                 else:
1581                     pform_neg = '-'
1582             else:
1583                 pform_neg = ' - '
1584 
1585             if (pform.binding > prettyForm.NEG
1586                 or pform.binding == prettyForm.ADD):
1587                 p = stringPict(*pform.parens())
1588             else:
1589                 p = pform
1590             p = stringPict.next(pform_neg, p)
1591             # Lower the binding to NEG, even if it was higher. Otherwise, it
1592             # will print as a + ( - (b)), instead of a - (b).
1593             return prettyForm(binding=prettyForm.NEG, *p)
1594 
1595         for i, term in enumerate(terms):
1596             if term.is_Mul and _coeff_isneg(term):
1597                 coeff, other = term.as_coeff_mul(rational=False)
1598                 pform = self._print(Mul(-coeff, *other, evaluate=False))
1599                 pforms.append(pretty_negative(pform, i))
1600             elif term.is_Rational and term.q > 1:
1601                 pforms.append(None)
1602                 indices.append(i)
1603             elif term.is_Number and term < 0:
1604                 pform = self._print(-term)
1605                 pforms.append(pretty_negative(pform, i))
1606             elif term.is_Relational:
1607                 pforms.append(prettyForm(*self._print(term).parens()))
1608             else:
1609                 pforms.append(self._print(term))
1610 
1611         if indices:
1612             large = True
1613 
1614             for pform in pforms:
1615                 if pform is not None and pform.height() > 1:
1616                     break
1617             else:
1618                 large = False
1619 
1620             for i in indices:
1621                 term, negative = terms[i], False
1622 
1623                 if term < 0:
1624                     term, negative = -term, True
1625 
1626                 if large:
1627                     pform = prettyForm(str(term.p))/prettyForm(str(term.q))
1628                 else:
1629                     pform = self._print(term)
1630 
1631                 if negative:
1632                     pform = pretty_negative(pform, i)
1633 
1634                 pforms[i] = pform
1635 
1636         return prettyForm.__add__(*pforms)
1637 
1638     def _print_Mul(self, product):
1639         from sympy.physics.units import Quantity
1640         a = []  # items in the numerator
1641         b = []  # items that are in the denominator (if any)
1642 
1643         if self.order not in ('old', 'none'):
1644             args = product.as_ordered_factors()
1645         else:
1646             args = list(product.args)
1647 
1648         # If quantities are present append them at the back
1649         args = sorted(args, key=lambda x: isinstance(x, Quantity) or
1650                      (isinstance(x, Pow) and isinstance(x.base, Quantity)))
1651 
1652         # Gather terms for numerator/denominator
1653         for item in args:
1654             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
1655                 if item.exp != -1:
1656                     b.append(Pow(item.base, -item.exp, evaluate=False))
1657                 else:
1658                     b.append(Pow(item.base, -item.exp))
1659             elif item.is_Rational and item is not S.Infinity:
1660                 if item.p != 1:
1661                     a.append( Rational(item.p) )
1662                 if item.q != 1:
1663                     b.append( Rational(item.q) )
1664             else:
1665                 a.append(item)
1666 
1667         from sympy import Integral, Piecewise, Product, Sum
1668 
1669         # Convert to pretty forms. Add parens to Add instances if there
1670         # is more than one term in the numer/denom
1671         for i in range(0, len(a)):
1672             if (a[i].is_Add and len(a) > 1) or (i != len(a) - 1 and
1673                     isinstance(a[i], (Integral, Piecewise, Product, Sum))):
1674                 a[i] = prettyForm(*self._print(a[i]).parens())
1675             elif a[i].is_Relational:
1676                 a[i] = prettyForm(*self._print(a[i]).parens())
1677             else:
1678                 a[i] = self._print(a[i])
1679 
1680         for i in range(0, len(b)):
1681             if (b[i].is_Add and len(b) > 1) or (i != len(b) - 1 and
1682                     isinstance(b[i], (Integral, Piecewise, Product, Sum))):
1683                 b[i] = prettyForm(*self._print(b[i]).parens())
1684             else:
1685                 b[i] = self._print(b[i])
1686 
1687         # Construct a pretty form
1688         if len(b) == 0:
1689             return prettyForm.__mul__(*a)
1690         else:
1691             if len(a) == 0:
1692                 a.append( self._print(S.One) )
1693             return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)
1694 
1695     # A helper function for _print_Pow to print x**(1/n)
1696     def _print_nth_root(self, base, expt):
1697         bpretty = self._print(base)
1698 
1699         # In very simple cases, use a single-char root sign
1700         if (self._settings['use_unicode_sqrt_char'] and self._use_unicode
1701             and expt is S.Half and bpretty.height() == 1
1702             and (bpretty.width() == 1
1703                  or (base.is_Integer and base.is_nonnegative))):
1704             return prettyForm(*bpretty.left(u'\N{SQUARE ROOT}'))
1705 
1706         # Construct root sign, start with the \/ shape
1707         _zZ = xobj('/', 1)
1708         rootsign = xobj('\\', 1) + _zZ
1709         # Make exponent number to put above it
1710         if isinstance(expt, Rational):
1711             exp = str(expt.q)
1712             if exp == '2':
1713                 exp = ''
1714         else:
1715             exp = str(expt.args[0])
1716         exp = exp.ljust(2)
1717         if len(exp) > 2:
1718             rootsign = ' '*(len(exp) - 2) + rootsign
1719         # Stack the exponent
1720         rootsign = stringPict(exp + '\n' + rootsign)
1721         rootsign.baseline = 0
1722         # Diagonal: length is one less than height of base
1723         linelength = bpretty.height() - 1
1724         diagonal = stringPict('\n'.join(
1725             ' '*(linelength - i - 1) + _zZ + ' '*i
1726             for i in range(linelength)
1727         ))
1728         # Put baseline just below lowest line: next to exp
1729         diagonal.baseline = linelength - 1
1730         # Make the root symbol
1731         rootsign = prettyForm(*rootsign.right(diagonal))
1732         # Det the baseline to match contents to fix the height
1733         # but if the height of bpretty is one, the rootsign must be one higher
1734         rootsign.baseline = max(1, bpretty.baseline)
1735         #build result
1736         s = prettyForm(hobj('_', 2 + bpretty.width()))
1737         s = prettyForm(*bpretty.above(s))
1738         s = prettyForm(*s.left(rootsign))
1739         return s
1740 
1741     def _print_Pow(self, power):
1742         from sympy.simplify.simplify import fraction
1743         b, e = power.as_base_exp()
1744         if power.is_commutative:
1745             if e is S.NegativeOne:
1746                 return prettyForm("1")/self._print(b)
1747             n, d = fraction(e)
1748             if n is S.One and d.is_Atom and not e.is_Integer and self._settings['root_notation']:
1749                 return self._print_nth_root(b, e)
1750             if e.is_Rational and e < 0:
1751                 return prettyForm("1")/self._print(Pow(b, -e, evaluate=False))
1752 
1753         if b.is_Relational:
1754             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))
1755 
1756         return self._print(b)**self._print(e)
1757 
1758     def _print_UnevaluatedExpr(self, expr):
1759         return self._print(expr.args[0])
1760 
1761     def __print_numer_denom(self, p, q):
1762         if q == 1:
1763             if p < 0:
1764                 return prettyForm(str(p), binding=prettyForm.NEG)
1765             else:
1766                 return prettyForm(str(p))
1767         elif abs(p) >= 10 and abs(q) >= 10:
1768             # If more than one digit in numer and denom, print larger fraction
1769             if p < 0:
1770                 return prettyForm(str(p), binding=prettyForm.NEG)/prettyForm(str(q))
1771                 # Old printing method:
1772                 #pform = prettyForm(str(-p))/prettyForm(str(q))
1773                 #return prettyForm(binding=prettyForm.NEG, *pform.left('- '))
1774             else:
1775                 return prettyForm(str(p))/prettyForm(str(q))
1776         else:
1777             return None
1778 
1779     def _print_Rational(self, expr):
1780         result = self.__print_numer_denom(expr.p, expr.q)
1781 
1782         if result is not None:
1783             return result
1784         else:
1785             return self.emptyPrinter(expr)
1786 
1787     def _print_Fraction(self, expr):
1788         result = self.__print_numer_denom(expr.numerator, expr.denominator)
1789 
1790         if result is not None:
1791             return result
1792         else:
1793             return self.emptyPrinter(expr)
1794 
1795     def _print_ProductSet(self, p):
1796         if len(p.sets) > 1 and not has_variety(p.sets):
1797             from sympy import Pow
1798             return self._print(Pow(p.sets[0], len(p.sets), evaluate=False))
1799         else:
1800             prod_char = u"\N{MULTIPLICATION SIGN}" if self._use_unicode else 'x'
1801             return self._print_seq(p.sets, None, None, ' %s ' % prod_char,
1802                                    parenthesize=lambda set: set.is_Union or
1803                                    set.is_Intersection or set.is_ProductSet)
1804 
1805     def _print_FiniteSet(self, s):
1806         items = sorted(s.args, key=default_sort_key)
1807         return self._print_seq(items, '{', '}', ', ' )
1808 
1809     def _print_Range(self, s):
1810 
1811         if self._use_unicode:
1812             dots = u"\N{HORIZONTAL ELLIPSIS}"
1813         else:
1814             dots = '...'
1815 
1816         if s.start.is_infinite:
1817             printset = dots, s[-1] - s.step, s[-1]
1818         elif s.stop.is_infinite:
1819             it = iter(s)
1820             printset = next(it), next(it), dots
1821         elif len(s) > 4:
1822             it = iter(s)
1823             printset = next(it), next(it), dots, s[-1]
1824         else:
1825             printset = tuple(s)
1826 
1827         return self._print_seq(printset, '{', '}', ', ' )
1828 
1829     def _print_Interval(self, i):
1830         if i.start == i.end:
1831             return self._print_seq(i.args[:1], '{', '}')
1832 
1833         else:
1834             if i.left_open:
1835                 left = '('
1836             else:
1837                 left = '['
1838 
1839             if i.right_open:
1840                 right = ')'
1841             else:
1842                 right = ']'
1843 
1844             return self._print_seq(i.args[:2], left, right)
1845 
1846     def _print_AccumulationBounds(self, i):
1847         left = '<'
1848         right = '>'
1849 
1850         return self._print_seq(i.args[:2], left, right)
1851 
1852     def _print_Intersection(self, u):
1853 
1854         delimiter = ' %s ' % pretty_atom('Intersection', 'n')
1855 
1856         return self._print_seq(u.args, None, None, delimiter,
1857                                parenthesize=lambda set: set.is_ProductSet or
1858                                set.is_Union or set.is_Complement)
1859 
1860     def _print_Union(self, u):
1861 
1862         union_delimiter = ' %s ' % pretty_atom('Union', 'U')
1863 
1864         return self._print_seq(u.args, None, None, union_delimiter,
1865                                parenthesize=lambda set: set.is_ProductSet or
1866                                set.is_Intersection or set.is_Complement)
1867 
1868     def _print_SymmetricDifference(self, u):
1869         if not self._use_unicode:
1870             raise NotImplementedError("ASCII pretty printing of SymmetricDifference is not implemented")
1871 
1872         sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')
1873 
1874         return self._print_seq(u.args, None, None, sym_delimeter)
1875 
1876     def _print_Complement(self, u):
1877 
1878         delimiter = r' \ '
1879 
1880         return self._print_seq(u.args, None, None, delimiter,
1881              parenthesize=lambda set: set.is_ProductSet or set.is_Intersection
1882                                or set.is_Union)
1883 
1884     def _print_ImageSet(self, ts):
1885         if self._use_unicode:
1886             inn = u"\N{SMALL ELEMENT OF}"
1887         else:
1888             inn = 'in'
1889         variables = ts.lamda.variables
1890         expr = self._print(ts.lamda.expr)
1891         bar = self._print("|")
1892         sets = [self._print(i) for i in ts.args[1:]]
1893         if len(sets) == 1:
1894             return self._print_seq((expr, bar, variables[0], inn, sets[0]), "{", "}", ' ')
1895         else:
1896             pargs = tuple(j for var, setv in zip(variables, sets) for j in (var, inn, setv, ","))
1897             return self._print_seq((expr, bar) + pargs[:-1], "{", "}", ' ')
1898 
1899     def _print_ConditionSet(self, ts):
1900         if self._use_unicode:
1901             inn = u"\N{SMALL ELEMENT OF}"
1902             # using _and because and is a keyword and it is bad practice to
1903             # overwrite them
1904             _and = u"\N{LOGICAL AND}"
1905         else:
1906             inn = 'in'
1907             _and = 'and'
1908 
1909         variables = self._print_seq(Tuple(ts.sym))
1910         as_expr = getattr(ts.condition, 'as_expr', None)
1911         if as_expr is not None:
1912             cond = self._print(ts.condition.as_expr())
1913         else:
1914             cond = self._print(ts.condition)
1915             if self._use_unicode:
1916                 cond = self._print_seq(cond, "(", ")")
1917 
1918         bar = self._print("|")
1919 
1920         if ts.base_set is S.UniversalSet:
1921             return self._print_seq((variables, bar, cond), "{", "}", ' ')
1922 
1923         base = self._print(ts.base_set)
1924         return self._print_seq((variables, bar, variables, inn,
1925                                 base, _and, cond), "{", "}", ' ')
1926 
1927     def _print_ComplexRegion(self, ts):
1928         if self._use_unicode:
1929             inn = u"\N{SMALL ELEMENT OF}"
1930         else:
1931             inn = 'in'
1932         variables = self._print_seq(ts.variables)
1933         expr = self._print(ts.expr)
1934         bar = self._print("|")
1935         prodsets = self._print(ts.sets)
1936 
1937         return self._print_seq((expr, bar, variables, inn, prodsets), "{", "}", ' ')
1938 
1939     def _print_Contains(self, e):
1940         var, set = e.args
1941         if self._use_unicode:
1942             el = u" \N{ELEMENT OF} "
1943             return prettyForm(*stringPict.next(self._print(var),
1944                                                el, self._print(set)), binding=8)
1945         else:
1946             return prettyForm(sstr(e))
1947 
1948     def _print_FourierSeries(self, s):
1949         if self._use_unicode:
1950             dots = u"\N{HORIZONTAL ELLIPSIS}"
1951         else:
1952             dots = '...'
1953         return self._print_Add(s.truncate()) + self._print(dots)
1954 
1955     def _print_FormalPowerSeries(self, s):
1956         return self._print_Add(s.infinite)
1957 
1958     def _print_SetExpr(self, se):
1959         pretty_set = prettyForm(*self._print(se.set).parens())
1960         pretty_name = self._print(Symbol("SetExpr"))
1961         return prettyForm(*pretty_name.right(pretty_set))
1962 
1963     def _print_SeqFormula(self, s):
1964         if self._use_unicode:
1965             dots = u"\N{HORIZONTAL ELLIPSIS}"
1966         else:
1967             dots = '...'
1968 
1969         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
1970             raise NotImplementedError("Pretty printing of sequences with symbolic bound not implemented")
1971 
1972         if s.start is S.NegativeInfinity:
1973             stop = s.stop
1974             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
1975                 s.coeff(stop - 1), s.coeff(stop))
1976         elif s.stop is S.Infinity or s.length > 4:
1977             printset = s[:4]
1978             printset.append(dots)
1979             printset = tuple(printset)
1980         else:
1981             printset = tuple(s)
1982         return self._print_list(printset)
1983 
1984     _print_SeqPer = _print_SeqFormula
1985     _print_SeqAdd = _print_SeqFormula
1986     _print_SeqMul = _print_SeqFormula
1987 
1988     def _print_seq(self, seq, left=None, right=None, delimiter=', ',
1989             parenthesize=lambda x: False):
1990         s = None
1991         try:
1992             for item in seq:
1993                 pform = self._print(item)
1994 
1995                 if parenthesize(item):
1996                     pform = prettyForm(*pform.parens())
1997                 if s is None:
1998                     # first element
1999                     s = pform
2000                 else:
2001                     # XXX: Under the tests from #15686 this raises:
2002                     # AttributeError: 'Fake' object has no attribute 'baseline'
2003                     # This is caught below but that is not the right way to
2004                     # fix it.
2005                     s = prettyForm(*stringPict.next(s, delimiter))
2006                     s = prettyForm(*stringPict.next(s, pform))
2007 
2008             if s is None:
2009                 s = stringPict('')
2010 
2011         except AttributeError:
2012             s = None
2013             for item in seq:
2014                 pform = self.doprint(item)
2015                 if parenthesize(item):
2016                     pform = prettyForm(*pform.parens())
2017                 if s is None:
2018                     # first element
2019                     s = pform
2020                 else :
2021                     s = prettyForm(*stringPict.next(s, delimiter))
2022                     s = prettyForm(*stringPict.next(s, pform))
2023 
2024             if s is None:
2025                 s = stringPict('')
2026 
2027         s = prettyForm(*s.parens(left, right, ifascii_nougly=True))
2028         return s
2029 
2030     def join(self, delimiter, args):
2031         pform = None
2032 
2033         for arg in args:
2034             if pform is None:
2035                 pform = arg
2036             else:
2037                 pform = prettyForm(*pform.right(delimiter))
2038                 pform = prettyForm(*pform.right(arg))
2039 
2040         if pform is None:
2041             return prettyForm("")
2042         else:
2043             return pform
2044 
2045     def _print_list(self, l):
2046         return self._print_seq(l, '[', ']')
2047 
2048     def _print_tuple(self, t):
2049         if len(t) == 1:
2050             ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))
2051             return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))
2052         else:
2053             return self._print_seq(t, '(', ')')
2054 
2055     def _print_Tuple(self, expr):
2056         return self._print_tuple(expr)
2057 
2058     def _print_dict(self, d):
2059         keys = sorted(d.keys(), key=default_sort_key)
2060         items = []
2061 
2062         for k in keys:
2063             K = self._print(k)
2064             V = self._print(d[k])
2065             s = prettyForm(*stringPict.next(K, ': ', V))
2066 
2067             items.append(s)
2068 
2069         return self._print_seq(items, '{', '}')
2070 
2071     def _print_Dict(self, d):
2072         return self._print_dict(d)
2073 
2074     def _print_set(self, s):
2075         if not s:
2076             return prettyForm('set()')
2077         items = sorted(s, key=default_sort_key)
2078         pretty = self._print_seq(items)
2079         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2080         return pretty
2081 
2082     def _print_frozenset(self, s):
2083         if not s:
2084             return prettyForm('frozenset()')
2085         items = sorted(s, key=default_sort_key)
2086         pretty = self._print_seq(items)
2087         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2088         pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))
2089         pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))
2090         return pretty
2091 
2092     def _print_PolyRing(self, ring):
2093         return prettyForm(sstr(ring))
2094 
2095     def _print_FracField(self, field):
2096         return prettyForm(sstr(field))
2097 
2098     def _print_FreeGroupElement(self, elm):
2099         return prettyForm(str(elm))
2100 
2101     def _print_PolyElement(self, poly):
2102         return prettyForm(sstr(poly))
2103 
2104     def _print_FracElement(self, frac):
2105         return prettyForm(sstr(frac))
2106 
2107     def _print_AlgebraicNumber(self, expr):
2108         if expr.is_aliased:
2109             return self._print(expr.as_poly().as_expr())
2110         else:
2111             return self._print(expr.as_expr())
2112 
2113     def _print_ComplexRootOf(self, expr):
2114         args = [self._print_Add(expr.expr, order='lex'), expr.index]
2115         pform = prettyForm(*self._print_seq(args).parens())
2116         pform = prettyForm(*pform.left('CRootOf'))
2117         return pform
2118 
2119     def _print_RootSum(self, expr):
2120         args = [self._print_Add(expr.expr, order='lex')]
2121 
2122         if expr.fun is not S.IdentityFunction:
2123             args.append(self._print(expr.fun))
2124 
2125         pform = prettyForm(*self._print_seq(args).parens())
2126         pform = prettyForm(*pform.left('RootSum'))
2127 
2128         return pform
2129 
2130     def _print_FiniteField(self, expr):
2131         if self._use_unicode:
2132             form = u'\N{DOUBLE-STRUCK CAPITAL Z}_%d'
2133         else:
2134             form = 'GF(%d)'
2135 
2136         return prettyForm(pretty_symbol(form % expr.mod))
2137 
2138     def _print_IntegerRing(self, expr):
2139         if self._use_unicode:
2140             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Z}')
2141         else:
2142             return prettyForm('ZZ')
2143 
2144     def _print_RationalField(self, expr):
2145         if self._use_unicode:
2146             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Q}')
2147         else:
2148             return prettyForm('QQ')
2149 
2150     def _print_RealField(self, domain):
2151         if self._use_unicode:
2152             prefix = u'\N{DOUBLE-STRUCK CAPITAL R}'
2153         else:
2154             prefix = 'RR'
2155 
2156         if domain.has_default_precision:
2157             return prettyForm(prefix)
2158         else:
2159             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2160 
2161     def _print_ComplexField(self, domain):
2162         if self._use_unicode:
2163             prefix = u'\N{DOUBLE-STRUCK CAPITAL C}'
2164         else:
2165             prefix = 'CC'
2166 
2167         if domain.has_default_precision:
2168             return prettyForm(prefix)
2169         else:
2170             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2171 
2172     def _print_PolynomialRing(self, expr):
2173         args = list(expr.symbols)
2174 
2175         if not expr.order.is_default:
2176             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2177             args.append(order)
2178 
2179         pform = self._print_seq(args, '[', ']')
2180         pform = prettyForm(*pform.left(self._print(expr.domain)))
2181 
2182         return pform
2183 
2184     def _print_FractionField(self, expr):
2185         args = list(expr.symbols)
2186 
2187         if not expr.order.is_default:
2188             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2189             args.append(order)
2190 
2191         pform = self._print_seq(args, '(', ')')
2192         pform = prettyForm(*pform.left(self._print(expr.domain)))
2193 
2194         return pform
2195 
2196     def _print_PolynomialRingBase(self, expr):
2197         g = expr.symbols
2198         if str(expr.order) != str(expr.default_order):
2199             g = g + ("order=" + str(expr.order),)
2200         pform = self._print_seq(g, '[', ']')
2201         pform = prettyForm(*pform.left(self._print(expr.domain)))
2202 
2203         return pform
2204 
2205     def _print_GroebnerBasis(self, basis):
2206         exprs = [ self._print_Add(arg, order=basis.order)
2207                   for arg in basis.exprs ]
2208         exprs = prettyForm(*self.join(", ", exprs).parens(left="[", right="]"))
2209 
2210         gens = [ self._print(gen) for gen in basis.gens ]
2211 
2212         domain = prettyForm(
2213             *prettyForm("domain=").right(self._print(basis.domain)))
2214         order = prettyForm(
2215             *prettyForm("order=").right(self._print(basis.order)))
2216 
2217         pform = self.join(", ", [exprs] + gens + [domain, order])
2218 
2219         pform = prettyForm(*pform.parens())
2220         pform = prettyForm(*pform.left(basis.__class__.__name__))
2221 
2222         return pform
2223 
2224     def _print_Subs(self, e):
2225         pform = self._print(e.expr)
2226         pform = prettyForm(*pform.parens())
2227 
2228         h = pform.height() if pform.height() > 1 else 2
2229         rvert = stringPict(vobj('|', h), baseline=pform.baseline)
2230         pform = prettyForm(*pform.right(rvert))
2231 
2232         b = pform.baseline
2233         pform.baseline = pform.height() - 1
2234         pform = prettyForm(*pform.right(self._print_seq([
2235             self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),
2236                 delimiter='') for v in zip(e.variables, e.point) ])))
2237 
2238         pform.baseline = b
2239         return pform
2240 
2241     def _print_euler(self, e):
2242         pform = prettyForm("E")
2243         arg = self._print(e.args[0])
2244         pform_arg = prettyForm(" "*arg.width())
2245         pform_arg = prettyForm(*pform_arg.below(arg))
2246         pform = prettyForm(*pform.right(pform_arg))
2247         if len(e.args) == 1:
2248             return pform
2249         m, x = e.args
2250         # TODO: copy-pasted from _print_Function: can we do better?
2251         prettyFunc = pform
2252         prettyArgs = prettyForm(*self._print_seq([x]).parens())
2253         pform = prettyForm(
2254             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
2255         pform.prettyFunc = prettyFunc
2256         pform.prettyArgs = prettyArgs
2257         return pform
2258 
2259     def _print_catalan(self, e):
2260         pform = prettyForm("C")
2261         arg = self._print(e.args[0])
2262         pform_arg = prettyForm(" "*arg.width())
2263         pform_arg = prettyForm(*pform_arg.below(arg))
2264         pform = prettyForm(*pform.right(pform_arg))
2265         return pform
2266 
2267     def _print_KroneckerDelta(self, e):
2268         pform = self._print(e.args[0])
2269         pform = prettyForm(*pform.right((prettyForm(','))))
2270         pform = prettyForm(*pform.right((self._print(e.args[1]))))
2271         if self._use_unicode:
2272             a = stringPict(pretty_symbol('delta'))
2273         else:
2274             a = stringPict('d')
2275         b = pform
2276         top = stringPict(*b.left(' '*a.width()))
2277         bot = stringPict(*a.right(' '*b.width()))
2278         return prettyForm(binding=prettyForm.POW, *bot.below(top))
2279 
2280     def _print_RandomDomain(self, d):
2281         if hasattr(d, 'as_boolean'):
2282             pform = self._print('Domain: ')
2283             pform = prettyForm(*pform.right(self._print(d.as_boolean())))
2284             return pform
2285         elif hasattr(d, 'set'):
2286             pform = self._print('Domain: ')
2287             pform = prettyForm(*pform.right(self._print(d.symbols)))
2288             pform = prettyForm(*pform.right(self._print(' in ')))
2289             pform = prettyForm(*pform.right(self._print(d.set)))
2290             return pform
2291         elif hasattr(d, 'symbols'):
2292             pform = self._print('Domain on ')
2293             pform = prettyForm(*pform.right(self._print(d.symbols)))
2294             return pform
2295         else:
2296             return self._print(None)
2297 
2298     def _print_DMP(self, p):
2299         try:
2300             if p.ring is not None:
2301                 # TODO incorporate order
2302                 return self._print(p.ring.to_sympy(p))
2303         except SympifyError:
2304             pass
2305         return self._print(repr(p))
2306 
2307     def _print_DMF(self, p):
2308         return self._print_DMP(p)
2309 
2310     def _print_Object(self, object):
2311         return self._print(pretty_symbol(object.name))
2312 
2313     def _print_Morphism(self, morphism):
2314         arrow = xsym("-->")
2315 
2316         domain = self._print(morphism.domain)
2317         codomain = self._print(morphism.codomain)
2318         tail = domain.right(arrow, codomain)[0]
2319 
2320         return prettyForm(tail)
2321 
2322     def _print_NamedMorphism(self, morphism):
2323         pretty_name = self._print(pretty_symbol(morphism.name))
2324         pretty_morphism = self._print_Morphism(morphism)
2325         return prettyForm(pretty_name.right(":", pretty_morphism)[0])
2326 
2327     def _print_IdentityMorphism(self, morphism):
2328         from sympy.categories import NamedMorphism
2329         return self._print_NamedMorphism(
2330             NamedMorphism(morphism.domain, morphism.codomain, "id"))
2331 
2332     def _print_CompositeMorphism(self, morphism):
2333 
2334         circle = xsym(".")
2335 
2336         # All components of the morphism have names and it is thus
2337         # possible to build the name of the composite.
2338         component_names_list = [pretty_symbol(component.name) for
2339                                 component in morphism.components]
2340         component_names_list.reverse()
2341         component_names = circle.join(component_names_list) + ":"
2342 
2343         pretty_name = self._print(component_names)
2344         pretty_morphism = self._print_Morphism(morphism)
2345         return prettyForm(pretty_name.right(pretty_morphism)[0])
2346 
2347     def _print_Category(self, category):
2348         return self._print(pretty_symbol(category.name))
2349 
2350     def _print_Diagram(self, diagram):
2351         if not diagram.premises:
2352             # This is an empty diagram.
2353             return self._print(S.EmptySet)
2354 
2355         pretty_result = self._print(diagram.premises)
2356         if diagram.conclusions:
2357             results_arrow = " %s " % xsym("==>")
2358 
2359             pretty_conclusions = self._print(diagram.conclusions)[0]
2360             pretty_result = pretty_result.right(
2361                 results_arrow, pretty_conclusions)
2362 
2363         return prettyForm(pretty_result[0])
2364 
2365     def _print_DiagramGrid(self, grid):
2366         from sympy.matrices import Matrix
2367         from sympy import Symbol
2368         matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(" ")
2369                           for j in range(grid.width)]
2370                          for i in range(grid.height)])
2371         return self._print_matrix_contents(matrix)
2372 
2373     def _print_FreeModuleElement(self, m):
2374         # Print as row vector for convenience, for now.
2375         return self._print_seq(m, '[', ']')
2376 
2377     def _print_SubModule(self, M):
2378         return self._print_seq(M.gens, '<', '>')
2379 
2380     def _print_FreeModule(self, M):
2381         return self._print(M.ring)**self._print(M.rank)
2382 
2383     def _print_ModuleImplementedIdeal(self, M):
2384         return self._print_seq([x for [x] in M._module.gens], '<', '>')
2385 
2386     def _print_QuotientRing(self, R):
2387         return self._print(R.ring) / self._print(R.base_ideal)
2388 
2389     def _print_QuotientRingElement(self, R):
2390         return self._print(R.data) + self._print(R.ring.base_ideal)
2391 
2392     def _print_QuotientModuleElement(self, m):
2393         return self._print(m.data) + self._print(m.module.killed_module)
2394 
2395     def _print_QuotientModule(self, M):
2396         return self._print(M.base) / self._print(M.killed_module)
2397 
2398     def _print_MatrixHomomorphism(self, h):
2399         matrix = self._print(h._sympy_matrix())
2400         matrix.baseline = matrix.height() // 2
2401         pform = prettyForm(*matrix.right(' : ', self._print(h.domain),
2402             ' %s> ' % hobj('-', 2), self._print(h.codomain)))
2403         return pform
2404 
2405     def _print_BaseScalarField(self, field):
2406         string = field._coord_sys._names[field._index]
2407         return self._print(pretty_symbol(string))
2408 
2409     def _print_BaseVectorField(self, field):
2410         s = U('PARTIAL DIFFERENTIAL') + '_' + field._coord_sys._names[field._index]
2411         return self._print(pretty_symbol(s))
2412 
2413     def _print_Differential(self, diff):
2414         field = diff._form_field
2415         if hasattr(field, '_coord_sys'):
2416             string = field._coord_sys._names[field._index]
2417             return self._print(u'\N{DOUBLE-STRUCK ITALIC SMALL D} ' + pretty_symbol(string))
2418         else:
2419             pform = self._print(field)
2420             pform = prettyForm(*pform.parens())
2421             return prettyForm(*pform.left(u"\N{DOUBLE-STRUCK ITALIC SMALL D}"))
2422 
2423     def _print_Tr(self, p):
2424         #TODO: Handle indices
2425         pform = self._print(p.args[0])
2426         pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))
2427         pform = prettyForm(*pform.right(')'))
2428         return pform
2429 
2430     def _print_primenu(self, e):
2431         pform = self._print(e.args[0])
2432         pform = prettyForm(*pform.parens())
2433         if self._use_unicode:
2434             pform = prettyForm(*pform.left(greek_unicode['nu']))
2435         else:
2436             pform = prettyForm(*pform.left('nu'))
2437         return pform
2438 
2439     def _print_primeomega(self, e):
2440         pform = self._print(e.args[0])
2441         pform = prettyForm(*pform.parens())
2442         if self._use_unicode:
2443             pform = prettyForm(*pform.left(greek_unicode['Omega']))
2444         else:
2445             pform = prettyForm(*pform.left('Omega'))
2446         return pform
2447 
2448     def _print_Quantity(self, e):
2449         if e.name.name == 'degree':
2450             pform = self._print(u"\N{DEGREE SIGN}")
2451             return pform
2452         else:
2453             return self.emptyPrinter(e)
2454 
2455     def _print_AssignmentBase(self, e):
2456 
2457         op = prettyForm(' ' + xsym(e.op) + ' ')
2458 
2459         l = self._print(e.lhs)
2460         r = self._print(e.rhs)
2461         pform = prettyForm(*stringPict.next(l, op, r))
2462         return pform
2463 
2464 
2465 def pretty(expr, **settings):
2466     """Returns a string containing the prettified form of expr.
2467 
2468     For information on keyword arguments see pretty_print function.
2469 
2470     """
2471     pp = PrettyPrinter(settings)
2472 
2473     # XXX: this is an ugly hack, but at least it works
2474     use_unicode = pp._settings['use_unicode']
2475     uflag = pretty_use_unicode(use_unicode)
2476 
2477     try:
2478         return pp.doprint(expr)
2479     finally:
2480         pretty_use_unicode(uflag)
2481 
2482 
2483 def pretty_print(expr, wrap_line=True, num_columns=None, use_unicode=None,
2484                  full_prec="auto", order=None, use_unicode_sqrt_char=True,
2485                  root_notation = True, mat_symbol_style="plain", imaginary_unit="i"):
2486     """Prints expr in pretty form.
2487 
2488     pprint is just a shortcut for this function.
2489 
2490     Parameters
2491     ==========
2492 
2493     expr : expression
2494         The expression to print.
2495 
2496     wrap_line : bool, optional (default=True)
2497         Line wrapping enabled/disabled.
2498 
2499     num_columns : int or None, optional (default=None)
2500         Number of columns before line breaking (default to None which reads
2501         the terminal width), useful when using SymPy without terminal.
2502 
2503     use_unicode : bool or None, optional (default=None)
2504         Use unicode characters, such as the Greek letter pi instead of
2505         the string pi.
2506 
2507     full_prec : bool or string, optional (default="auto")
2508         Use full precision.
2509 
2510     order : bool or string, optional (default=None)
2511         Set to 'none' for long expressions if slow; default is None.
2512 
2513     use_unicode_sqrt_char : bool, optional (default=True)
2514         Use compact single-character square root symbol (when unambiguous).
2515 
2516     root_notation : bool, optional (default=True)
2517         Set to 'False' for printing exponents of the form 1/n in fractional form.
2518         By default exponent is printed in root form.
2519 
2520     mat_symbol_style : string, optional (default="plain")
2521         Set to "bold" for printing MatrixSymbols using a bold mathematical symbol face.
2522         By default the standard face is used.
2523 
2524     imaginary_unit : string, optional (default="i")
2525         Letter to use for imaginary unit when use_unicode is True.
2526         Can be "i" (default) or "j".
2527     """
2528     print(pretty(expr, wrap_line=wrap_line, num_columns=num_columns,
2529                  use_unicode=use_unicode, full_prec=full_prec, order=order,
2530                  use_unicode_sqrt_char=use_unicode_sqrt_char,
2531                  root_notation=root_notation, mat_symbol_style=mat_symbol_style,
2532                  imaginary_unit=imaginary_unit))
2533 
2534 pprint = pretty_print
2535 
2536 
2537 def pager_print(expr, **settings):
2538     """Prints expr using the pager, in pretty form.
2539 
2540     This invokes a pager command using pydoc. Lines are not wrapped
2541     automatically. This routine is meant to be used with a pager that allows
2542     sideways scrolling, like ``less -S``.
2543 
2544     Parameters are the same as for ``pretty_print``. If you wish to wrap lines,
2545     pass ``num_columns=None`` to auto-detect the width of the terminal.
2546 
2547     """
2548     from pydoc import pager
2549     from locale import getpreferredencoding
2550     if 'num_columns' not in settings:
2551         settings['num_columns'] = 500000  # disable line wrap
2552     pager(pretty(expr, **settings).encode(getpreferredencoding()))

</code><intended_behavior>The code within this file responsible for the pretty printing of `Product` instances needs to be modified or enhanced. This could involve adjusting the method(s) that generate the textual representation of mathematical products. Specifically, the modifications should aim to: - Remove the unnecessary empty line at the bottom of the product notation to make the presentation more compact and aligned with mathematical standards. - Adjust the width of the product notation to ensure it does not appear excessively broad ('too fat'), making it more in line with the visual aesthetics of related symbols and expressions. - Optionally extend the top bar of the product notation if such a change does not adversely affect the clarity or consistency of the representation, potentially making the notation more visually appealing and understandable. These adjustments should be carefully implemented to preserve the existing functionality of the pretty printing code, ensuring that all other expressions and symbols continue to be rendered correctly and without unintended modifications.</intended_behavior>]
2025-10-17 20:34:54.174 | INFO     | Search completed. Bug locations: [<file>sympy/printing/pretty/pretty.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 import itertools
4 
5 from sympy.core import S
6 from sympy.core.compatibility import range, string_types
7 from sympy.core.containers import Tuple
8 from sympy.core.function import _coeff_isneg
9 from sympy.core.mul import Mul
10 from sympy.core.numbers import Rational
11 from sympy.core.power import Pow
12 from sympy.core.relational import Equality
13 from sympy.core.symbol import Symbol
14 from sympy.core.sympify import SympifyError
15 from sympy.printing.conventions import requires_partial
16 from sympy.printing.precedence import PRECEDENCE, precedence, precedence_traditional
17 from sympy.printing.printer import Printer
18 from sympy.printing.str import sstr
19 from sympy.utilities import default_sort_key
20 from sympy.utilities.iterables import has_variety
21 
22 from sympy.printing.pretty.stringpict import prettyForm, stringPict
23 from sympy.printing.pretty.pretty_symbology import xstr, hobj, vobj, xobj, xsym, pretty_symbol, \
24     pretty_atom, pretty_use_unicode, pretty_try_use_unicode, greek_unicode, U, \
25     annotated
26 
27 # rename for usage from outside
28 pprint_use_unicode = pretty_use_unicode
29 pprint_try_use_unicode = pretty_try_use_unicode
30 
31 
32 class PrettyPrinter(Printer):
33     """Printer, which converts an expression into 2D ASCII-art figure."""
34     printmethod = "_pretty"
35 
36     _default_settings = {
37         "order": None,
38         "full_prec": "auto",
39         "use_unicode": None,
40         "wrap_line": True,
41         "num_columns": None,
42         "use_unicode_sqrt_char": True,
43         "root_notation": True,
44         "mat_symbol_style": "plain",
45         "imaginary_unit": "i",
46     }
47 
48     def __init__(self, settings=None):
49         Printer.__init__(self, settings)
50 
51         if not isinstance(self._settings['imaginary_unit'], string_types):
52             raise TypeError("'imaginary_unit' must a string, not {}".format(self._settings['imaginary_unit']))
53         elif self._settings['imaginary_unit'] not in ["i", "j"]:
54             raise ValueError("'imaginary_unit' must be either 'i' or 'j', not '{}'".format(self._settings['imaginary_unit']))
55         self.emptyPrinter = lambda x: prettyForm(xstr(x))
56 
57     @property
58     def _use_unicode(self):
59         if self._settings['use_unicode']:
60             return True
61         else:
62             return pretty_use_unicode()
63 
64     def doprint(self, expr):
65         return self._print(expr).render(**self._settings)
66 
67     # empty op so _print(stringPict) returns the same
68     def _print_stringPict(self, e):
69         return e
70 
71     def _print_basestring(self, e):
72         return prettyForm(e)
73 
74     def _print_atan2(self, e):
75         pform = prettyForm(*self._print_seq(e.args).parens())
76         pform = prettyForm(*pform.left('atan2'))
77         return pform
78 
79     def _print_Symbol(self, e, bold_name=False):
80         symb = pretty_symbol(e.name, bold_name)
81         return prettyForm(symb)
82     _print_RandomSymbol = _print_Symbol
83     def _print_MatrixSymbol(self, e):
84         return self._print_Symbol(e, self._settings['mat_symbol_style'] == "bold")
85 
86     def _print_Float(self, e):
87         # we will use StrPrinter's Float printer, but we need to handle the
88         # full_prec ourselves, according to the self._print_level
89         full_prec = self._settings["full_prec"]
90         if full_prec == "auto":
91             full_prec = self._print_level == 1
92         return prettyForm(sstr(e, full_prec=full_prec))
93 
94     def _print_Cross(self, e):
95         vec1 = e._expr1
96         vec2 = e._expr2
97         pform = self._print(vec2)
98         pform = prettyForm(*pform.left('('))
99         pform = prettyForm(*pform.right(')'))
100         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
101         pform = prettyForm(*pform.left(')'))
102         pform = prettyForm(*pform.left(self._print(vec1)))
103         pform = prettyForm(*pform.left('('))
104         return pform
105 
106     def _print_Curl(self, e):
107         vec = e._expr
108         pform = self._print(vec)
109         pform = prettyForm(*pform.left('('))
110         pform = prettyForm(*pform.right(')'))
111         pform = prettyForm(*pform.left(self._print(U('MULTIPLICATION SIGN'))))
112         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
113         return pform
114 
115     def _print_Divergence(self, e):
116         vec = e._expr
117         pform = self._print(vec)
118         pform = prettyForm(*pform.left('('))
119         pform = prettyForm(*pform.right(')'))
120         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
121         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
122         return pform
123 
124     def _print_Dot(self, e):
125         vec1 = e._expr1
126         vec2 = e._expr2
127         pform = self._print(vec2)
128         pform = prettyForm(*pform.left('('))
129         pform = prettyForm(*pform.right(')'))
130         pform = prettyForm(*pform.left(self._print(U('DOT OPERATOR'))))
131         pform = prettyForm(*pform.left(')'))
132         pform = prettyForm(*pform.left(self._print(vec1)))
133         pform = prettyForm(*pform.left('('))
134         return pform
135 
136     def _print_Gradient(self, e):
137         func = e._expr
138         pform = self._print(func)
139         pform = prettyForm(*pform.left('('))
140         pform = prettyForm(*pform.right(')'))
141         pform = prettyForm(*pform.left(self._print(U('NABLA'))))
142         return pform
143 
144     def _print_Atom(self, e):
145         try:
146             # print atoms like Exp1 or Pi
147             return prettyForm(pretty_atom(e.__class__.__name__, printer=self))
148         except KeyError:
149             return self.emptyPrinter(e)
150 
151     # Infinity inherits from Number, so we have to override _print_XXX order
152     _print_Infinity = _print_Atom
153     _print_NegativeInfinity = _print_Atom
154     _print_EmptySet = _print_Atom
155     _print_Naturals = _print_Atom
156     _print_Naturals0 = _print_Atom
157     _print_Integers = _print_Atom
158     _print_Complexes = _print_Atom
159 
160     def _print_Reals(self, e):
161         if self._use_unicode:
162             return self._print_Atom(e)
163         else:
164             inf_list = ['-oo', 'oo']
165             return self._print_seq(inf_list, '(', ')')
166 
167     def _print_subfactorial(self, e):
168         x = e.args[0]
169         pform = self._print(x)
170         # Add parentheses if needed
171         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
172             pform = prettyForm(*pform.parens())
173         pform = prettyForm(*pform.left('!'))
174         return pform
175 
176     def _print_factorial(self, e):
177         x = e.args[0]
178         pform = self._print(x)
179         # Add parentheses if needed
180         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
181             pform = prettyForm(*pform.parens())
182         pform = prettyForm(*pform.right('!'))
183         return pform
184 
185     def _print_factorial2(self, e):
186         x = e.args[0]
187         pform = self._print(x)
188         # Add parentheses if needed
189         if not ((x.is_Integer and x.is_nonnegative) or x.is_Symbol):
190             pform = prettyForm(*pform.parens())
191         pform = prettyForm(*pform.right('!!'))
192         return pform
193 
194     def _print_binomial(self, e):
195         n, k = e.args
196 
197         n_pform = self._print(n)
198         k_pform = self._print(k)
199 
200         bar = ' '*max(n_pform.width(), k_pform.width())
201 
202         pform = prettyForm(*k_pform.above(bar))
203         pform = prettyForm(*pform.above(n_pform))
204         pform = prettyForm(*pform.parens('(', ')'))
205 
206         pform.baseline = (pform.baseline + 1)//2
207 
208         return pform
209 
210     def _print_Relational(self, e):
211         op = prettyForm(' ' + xsym(e.rel_op) + ' ')
212 
213         l = self._print(e.lhs)
214         r = self._print(e.rhs)
215         pform = prettyForm(*stringPict.next(l, op, r))
216         return pform
217 
218     def _print_Not(self, e):
219         from sympy import Equivalent, Implies
220         if self._use_unicode:
221             arg = e.args[0]
222             pform = self._print(arg)
223             if isinstance(arg, Equivalent):
224                 return self._print_Equivalent(arg, altchar=u"\N{LEFT RIGHT DOUBLE ARROW WITH STROKE}")
225             if isinstance(arg, Implies):
226                 return self._print_Implies(arg, altchar=u"\N{RIGHTWARDS ARROW WITH STROKE}")
227 
228             if arg.is_Boolean and not arg.is_Not:
229                 pform = prettyForm(*pform.parens())
230 
231             return prettyForm(*pform.left(u"\N{NOT SIGN}"))
232         else:
233             return self._print_Function(e)
234 
235     def __print_Boolean(self, e, char, sort=True):
236         args = e.args
237         if sort:
238             args = sorted(e.args, key=default_sort_key)
239         arg = args[0]
240         pform = self._print(arg)
241 
242         if arg.is_Boolean and not arg.is_Not:
243             pform = prettyForm(*pform.parens())
244 
245         for arg in args[1:]:
246             pform_arg = self._print(arg)
247 
248             if arg.is_Boolean and not arg.is_Not:
249                 pform_arg = prettyForm(*pform_arg.parens())
250 
251             pform = prettyForm(*pform.right(u' %s ' % char))
252             pform = prettyForm(*pform.right(pform_arg))
253 
254         return pform
255 
256     def _print_And(self, e):
257         if self._use_unicode:
258             return self.__print_Boolean(e, u"\N{LOGICAL AND}")
259         else:
260             return self._print_Function(e, sort=True)
261 
262     def _print_Or(self, e):
263         if self._use_unicode:
264             return self.__print_Boolean(e, u"\N{LOGICAL OR}")
265         else:
266             return self._print_Function(e, sort=True)
267 
268     def _print_Xor(self, e):
269         if self._use_unicode:
270             return self.__print_Boolean(e, u"\N{XOR}")
271         else:
272             return self._print_Function(e, sort=True)
273 
274     def _print_Nand(self, e):
275         if self._use_unicode:
276             return self.__print_Boolean(e, u"\N{NAND}")
277         else:
278             return self._print_Function(e, sort=True)
279 
280     def _print_Nor(self, e):
281         if self._use_unicode:
282             return self.__print_Boolean(e, u"\N{NOR}")
283         else:
284             return self._print_Function(e, sort=True)
285 
286     def _print_Implies(self, e, altchar=None):
287         if self._use_unicode:
288             return self.__print_Boolean(e, altchar or u"\N{RIGHTWARDS ARROW}", sort=False)
289         else:
290             return self._print_Function(e)
291 
292     def _print_Equivalent(self, e, altchar=None):
293         if self._use_unicode:
294             return self.__print_Boolean(e, altchar or u"\N{LEFT RIGHT DOUBLE ARROW}")
295         else:
296             return self._print_Function(e, sort=True)
297 
298     def _print_conjugate(self, e):
299         pform = self._print(e.args[0])
300         return prettyForm( *pform.above( hobj('_', pform.width())) )
301 
302     def _print_Abs(self, e):
303         pform = self._print(e.args[0])
304         pform = prettyForm(*pform.parens('|', '|'))
305         return pform
306     _print_Determinant = _print_Abs
307 
308     def _print_floor(self, e):
309         if self._use_unicode:
310             pform = self._print(e.args[0])
311             pform = prettyForm(*pform.parens('lfloor', 'rfloor'))
312             return pform
313         else:
314             return self._print_Function(e)
315 
316     def _print_ceiling(self, e):
317         if self._use_unicode:
318             pform = self._print(e.args[0])
319             pform = prettyForm(*pform.parens('lceil', 'rceil'))
320             return pform
321         else:
322             return self._print_Function(e)
323 
324     def _print_Derivative(self, deriv):
325         if requires_partial(deriv) and self._use_unicode:
326             deriv_symbol = U('PARTIAL DIFFERENTIAL')
327         else:
328             deriv_symbol = r'd'
329         x = None
330         count_total_deriv = 0
331 
332         for sym, num in reversed(deriv.variable_count):
333             s = self._print(sym)
334             ds = prettyForm(*s.left(deriv_symbol))
335             count_total_deriv += num
336 
337             if (not num.is_Integer) or (num > 1):
338                 ds = ds**prettyForm(str(num))
339 
340             if x is None:
341                 x = ds
342             else:
343                 x = prettyForm(*x.right(' '))
344                 x = prettyForm(*x.right(ds))
345 
346         f = prettyForm(
347             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
348 
349         pform = prettyForm(deriv_symbol)
350 
351         if (count_total_deriv > 1) != False:
352             pform = pform**prettyForm(str(count_total_deriv))
353 
354         pform = prettyForm(*pform.below(stringPict.LINE, x))
355         pform.baseline = pform.baseline + 1
356         pform = prettyForm(*stringPict.next(pform, f))
357         pform.binding = prettyForm.MUL
358 
359         return pform
360 
361     def _print_Cycle(self, dc):
362         from sympy.combinatorics.permutations import Permutation, Cycle
363         # for Empty Cycle
364         if dc == Cycle():
365             cyc = stringPict('')
366             return prettyForm(*cyc.parens())
367 
368         dc_list = Permutation(dc.list()).cyclic_form
369         # for Identity Cycle
370         if dc_list == []:
371             cyc = self._print(dc.size - 1)
372             return prettyForm(*cyc.parens())
373 
374         cyc = stringPict('')
375         for i in dc_list:
376             l = self._print(str(tuple(i)).replace(',', ''))
377             cyc = prettyForm(*cyc.right(l))
378         return cyc
379 
380     def _print_PDF(self, pdf):
381         lim = self._print(pdf.pdf.args[0])
382         lim = prettyForm(*lim.right(', '))
383         lim = prettyForm(*lim.right(self._print(pdf.domain[0])))
384         lim = prettyForm(*lim.right(', '))
385         lim = prettyForm(*lim.right(self._print(pdf.domain[1])))
386         lim = prettyForm(*lim.parens())
387 
388         f = self._print(pdf.pdf.args[1])
389         f = prettyForm(*f.right(', '))
390         f = prettyForm(*f.right(lim))
391         f = prettyForm(*f.parens())
392 
393         pform = prettyForm('PDF')
394         pform = prettyForm(*pform.right(f))
395         return pform
396 
397     def _print_Integral(self, integral):
398         f = integral.function
399 
400         # Add parentheses if arg involves addition of terms and
401         # create a pretty form for the argument
402         prettyF = self._print(f)
403         # XXX generalize parens
404         if f.is_Add:
405             prettyF = prettyForm(*prettyF.parens())
406 
407         # dx dy dz ...
408         arg = prettyF
409         for x in integral.limits:
410             prettyArg = self._print(x[0])
411             # XXX qparens (parens if needs-parens)
412             if prettyArg.width() > 1:
413                 prettyArg = prettyForm(*prettyArg.parens())
414 
415             arg = prettyForm(*arg.right(' d', prettyArg))
416 
417         # \int \int \int ...
418         firstterm = True
419         s = None
420         for lim in integral.limits:
421             x = lim[0]
422             # Create bar based on the height of the argument
423             h = arg.height()
424             H = h + 2
425 
426             # XXX hack!
427             ascii_mode = not self._use_unicode
428             if ascii_mode:
429                 H += 2
430 
431             vint = vobj('int', H)
432 
433             # Construct the pretty form with the integral sign and the argument
434             pform = prettyForm(vint)
435             pform.baseline = arg.baseline + (
436                 H - h)//2    # covering the whole argument
437 
438             if len(lim) > 1:
439                 # Create pretty forms for endpoints, if definite integral.
440                 # Do not print empty endpoints.
441                 if len(lim) == 2:
442                     prettyA = prettyForm("")
443                     prettyB = self._print(lim[1])
444                 if len(lim) == 3:
445                     prettyA = self._print(lim[1])
446                     prettyB = self._print(lim[2])
447 
448                 if ascii_mode:  # XXX hack
449                     # Add spacing so that endpoint can more easily be
450                     # identified with the correct integral sign
451                     spc = max(1, 3 - prettyB.width())
452                     prettyB = prettyForm(*prettyB.left(' ' * spc))
453 
454                     spc = max(1, 4 - prettyA.width())
455                     prettyA = prettyForm(*prettyA.right(' ' * spc))
456 
457                 pform = prettyForm(*pform.above(prettyB))
458                 pform = prettyForm(*pform.below(prettyA))
459 
460             if not ascii_mode:  # XXX hack
461                 pform = prettyForm(*pform.right(' '))
462 
463             if firstterm:
464                 s = pform   # first term
465                 firstterm = False
466             else:
467                 s = prettyForm(*s.left(pform))
468 
469         pform = prettyForm(*arg.left(s))
470         pform.binding = prettyForm.MUL
471         return pform
472 
473     def _print_Product(self, expr):
474         func = expr.term
475         pretty_func = self._print(func)
476 
477         horizontal_chr = xobj('_', 1)
478         corner_chr = xobj('_', 1)
479         vertical_chr = xobj('|', 1)
480 
481         if self._use_unicode:
482             # use unicode corners
483             horizontal_chr = xobj('-', 1)
484             corner_chr = u'\N{BOX DRAWINGS LIGHT DOWN AND HORIZONTAL}'
485 
486         func_height = pretty_func.height()
487 
488         first = True
489         max_upper = 0
490         sign_height = 0
491 
492         for lim in expr.limits:
493             width = (func_height + 2) * 5 // 3 - 2
494             sign_lines = []
495             sign_lines.append(corner_chr + (horizontal_chr*width) + corner_chr)
496             for i in range(func_height + 1):
497                 sign_lines.append(vertical_chr + (' '*width) + vertical_chr)
498 
499             pretty_sign = stringPict('')
500             pretty_sign = prettyForm(*pretty_sign.stack(*sign_lines))
501 
502             pretty_upper = self._print(lim[2])
503             pretty_lower = self._print(Equality(lim[0], lim[1]))
504 
505             max_upper = max(max_upper, pretty_upper.height())
506 
507             if first:
508                 sign_height = pretty_sign.height()
509 
510             pretty_sign = prettyForm(*pretty_sign.above(pretty_upper))
511             pretty_sign = prettyForm(*pretty_sign.below(pretty_lower))
512 
513             if first:
514                 pretty_func.baseline = 0
515                 first = False
516 
517             height = pretty_sign.height()
518             padding = stringPict('')
519             padding = prettyForm(*padding.stack(*[' ']*(height - 1)))
520             pretty_sign = prettyForm(*pretty_sign.right(padding))
521 
522             pretty_func = prettyForm(*pretty_sign.right(pretty_func))
523 
524         pretty_func.baseline = max_upper + sign_height//2
525         pretty_func.binding = prettyForm.MUL
526         return pretty_func
527 
528     def _print_Sum(self, expr):
529         ascii_mode = not self._use_unicode
530 
531         def asum(hrequired, lower, upper, use_ascii):
532             def adjust(s, wid=None, how='<^>'):
533                 if not wid or len(s) > wid:
534                     return s
535                 need = wid - len(s)
536                 if how == '<^>' or how == "<" or how not in list('<^>'):
537                     return s + ' '*need
538                 half = need//2
539                 lead = ' '*half
540                 if how == ">":
541                     return " "*need + s
542                 return lead + s + ' '*(need - len(lead))
543 
544             h = max(hrequired, 2)
545             d = h//2
546             w = d + 1
547             more = hrequired % 2
548 
549             lines = []
550             if use_ascii:
551                 lines.append("_"*(w) + ' ')
552                 lines.append(r"\%s`" % (' '*(w - 1)))
553                 for i in range(1, d):
554                     lines.append('%s\\%s' % (' '*i, ' '*(w - i)))
555                 if more:
556                     lines.append('%s)%s' % (' '*(d), ' '*(w - d)))
557                 for i in reversed(range(1, d)):
558                     lines.append('%s/%s' % (' '*i, ' '*(w - i)))
559                 lines.append("/" + "_"*(w - 1) + ',')
560                 return d, h + more, lines, 0
561             else:
562                 w = w + more
563                 d = d + more
564                 vsum = vobj('sum', 4)
565                 lines.append("_"*(w))
566                 for i in range(0, d):
567                     lines.append('%s%s%s' % (' '*i, vsum[2], ' '*(w - i - 1)))
568                 for i in reversed(range(0, d)):
569                     lines.append('%s%s%s' % (' '*i, vsum[4], ' '*(w - i - 1)))
570                 lines.append(vsum[8]*(w))
571                 return d, h + 2*more, lines, more
572 
573         f = expr.function
574 
575         prettyF = self._print(f)
576 
577         if f.is_Add:  # add parens
578             prettyF = prettyForm(*prettyF.parens())
579 
580         H = prettyF.height() + 2
581 
582         # \sum \sum \sum ...
583         first = True
584         max_upper = 0
585         sign_height = 0
586 
587         for lim in expr.limits:
588             if len(lim) == 3:
589                 prettyUpper = self._print(lim[2])
590                 prettyLower = self._print(Equality(lim[0], lim[1]))
591             elif len(lim) == 2:
592                 prettyUpper = self._print("")
593                 prettyLower = self._print(Equality(lim[0], lim[1]))
594             elif len(lim) == 1:
595                 prettyUpper = self._print("")
596                 prettyLower = self._print(lim[0])
597 
598             max_upper = max(max_upper, prettyUpper.height())
599 
600             # Create sum sign based on the height of the argument
601             d, h, slines, adjustment = asum(
602                 H, prettyLower.width(), prettyUpper.width(), ascii_mode)
603             prettySign = stringPict('')
604             prettySign = prettyForm(*prettySign.stack(*slines))
605 
606             if first:
607                 sign_height = prettySign.height()
608 
609             prettySign = prettyForm(*prettySign.above(prettyUpper))
610             prettySign = prettyForm(*prettySign.below(prettyLower))
611 
612             if first:
613                 # change F baseline so it centers on the sign
614                 prettyF.baseline -= d - (prettyF.height()//2 -
615                                          prettyF.baseline) - adjustment
616                 first = False
617 
618             # put padding to the right
619             pad = stringPict('')
620             pad = prettyForm(*pad.stack(*[' ']*h))
621             prettySign = prettyForm(*prettySign.right(pad))
622             # put the present prettyF to the right
623             prettyF = prettyForm(*prettySign.right(prettyF))
624 
625         prettyF.baseline = max_upper + sign_height//2
626         prettyF.binding = prettyForm.MUL
627         return prettyF
628 
629     def _print_Limit(self, l):
630         e, z, z0, dir = l.args
631 
632         E = self._print(e)
633         if precedence(e) <= PRECEDENCE["Mul"]:
634             E = prettyForm(*E.parens('(', ')'))
635         Lim = prettyForm('lim')
636 
637         LimArg = self._print(z)
638         if self._use_unicode:
639             LimArg = prettyForm(*LimArg.right(u'\N{BOX DRAWINGS LIGHT HORIZONTAL}\N{RIGHTWARDS ARROW}'))
640         else:
641             LimArg = prettyForm(*LimArg.right('->'))
642         LimArg = prettyForm(*LimArg.right(self._print(z0)))
643 
644         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
645             dir = ""
646         else:
647             if self._use_unicode:
648                 dir = u'\N{SUPERSCRIPT PLUS SIGN}' if str(dir) == "+" else u'\N{SUPERSCRIPT MINUS}'
649 
650         LimArg = prettyForm(*LimArg.right(self._print(dir)))
651 
652         Lim = prettyForm(*Lim.below(LimArg))
653         Lim = prettyForm(*Lim.right(E), binding=prettyForm.MUL)
654 
655         return Lim
656 
657     def _print_matrix_contents(self, e):
658         """
659         This method factors out what is essentially grid printing.
660         """
661         M = e   # matrix
662         Ms = {}  # i,j -> pretty(M[i,j])
663         for i in range(M.rows):
664             for j in range(M.cols):
665                 Ms[i, j] = self._print(M[i, j])
666 
667         # h- and v- spacers
668         hsep = 2
669         vsep = 1
670 
671         # max width for columns
672         maxw = [-1] * M.cols
673 
674         for j in range(M.cols):
675             maxw[j] = max([Ms[i, j].width() for i in range(M.rows)] or [0])
676 
677         # drawing result
678         D = None
679 
680         for i in range(M.rows):
681 
682             D_row = None
683             for j in range(M.cols):
684                 s = Ms[i, j]
685 
686                 # reshape s to maxw
687                 # XXX this should be generalized, and go to stringPict.reshape ?
688                 assert s.width() <= maxw[j]
689 
690                 # hcenter it, +0.5 to the right                        2
691                 # ( it's better to align formula starts for say 0 and r )
692                 # XXX this is not good in all cases -- maybe introduce vbaseline?
693                 wdelta = maxw[j] - s.width()
694                 wleft = wdelta // 2
695                 wright = wdelta - wleft
696 
697                 s = prettyForm(*s.right(' '*wright))
698                 s = prettyForm(*s.left(' '*wleft))
699 
700                 # we don't need vcenter cells -- this is automatically done in
701                 # a pretty way because when their baselines are taking into
702                 # account in .right()
703 
704                 if D_row is None:
705                     D_row = s   # first box in a row
706                     continue
707 
708                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
709                 D_row = prettyForm(*D_row.right(s))
710 
711             if D is None:
712                 D = D_row       # first row in a picture
713                 continue
714 
715             # v-spacer
716             for _ in range(vsep):
717                 D = prettyForm(*D.below(' '))
718 
719             D = prettyForm(*D.below(D_row))
720 
721         if D is None:
722             D = prettyForm('')  # Empty Matrix
723 
724         return D
725 
726     def _print_MatrixBase(self, e):
727         D = self._print_matrix_contents(e)
728         D.baseline = D.height()//2
729         D = prettyForm(*D.parens('[', ']'))
730         return D
731     _print_ImmutableMatrix = _print_MatrixBase
732     _print_Matrix = _print_MatrixBase
733 
734     def _print_TensorProduct(self, expr):
735         # This should somehow share the code with _print_WedgeProduct:
736         circled_times = "\u2297"
737         return self._print_seq(expr.args, None, None, circled_times,
738             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
739 
740     def _print_WedgeProduct(self, expr):
741         # This should somehow share the code with _print_TensorProduct:
742         wedge_symbol = u"\u2227"
743         return self._print_seq(expr.args, None, None, wedge_symbol,
744             parenthesize=lambda x: precedence_traditional(x) <= PRECEDENCE["Mul"])
745 
746     def _print_Trace(self, e):
747         D = self._print(e.arg)
748         D = prettyForm(*D.parens('(',')'))
749         D.baseline = D.height()//2
750         D = prettyForm(*D.left('\n'*(0) + 'tr'))
751         return D
752 
753 
754     def _print_MatrixElement(self, expr):
755         from sympy.matrices import MatrixSymbol
756         from sympy import Symbol
757         if (isinstance(expr.parent, MatrixSymbol)
758                 and expr.i.is_number and expr.j.is_number):
759             return self._print(
760                     Symbol(expr.parent.name + '_%d%d' % (expr.i, expr.j)))
761         else:
762             prettyFunc = self._print(expr.parent)
763             prettyFunc = prettyForm(*prettyFunc.parens())
764             prettyIndices = self._print_seq((expr.i, expr.j), delimiter=', '
765                     ).parens(left='[', right=']')[0]
766             pform = prettyForm(binding=prettyForm.FUNC,
767                     *stringPict.next(prettyFunc, prettyIndices))
768 
769             # store pform parts so it can be reassembled e.g. when powered
770             pform.prettyFunc = prettyFunc
771             pform.prettyArgs = prettyIndices
772 
773             return pform
774 
775 
776     def _print_MatrixSlice(self, m):
777         # XXX works only for applied functions
778         prettyFunc = self._print(m.parent)
779         def ppslice(x):
780             x = list(x)
781             if x[2] == 1:
782                 del x[2]
783             if x[1] == x[0] + 1:
784                 del x[1]
785             if x[0] == 0:
786                 x[0] = ''
787             return prettyForm(*self._print_seq(x, delimiter=':'))
788         prettyArgs = self._print_seq((ppslice(m.rowslice),
789             ppslice(m.colslice)), delimiter=', ').parens(left='[', right=']')[0]
790 
791         pform = prettyForm(
792             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
793 
794         # store pform parts so it can be reassembled e.g. when powered
795         pform.prettyFunc = prettyFunc
796         pform.prettyArgs = prettyArgs
797 
798         return pform
799 
800     def _print_Transpose(self, expr):
801         pform = self._print(expr.arg)
802         from sympy.matrices import MatrixSymbol
803         if not isinstance(expr.arg, MatrixSymbol):
804             pform = prettyForm(*pform.parens())
805         pform = pform**(prettyForm('T'))
806         return pform
807 
808     def _print_Adjoint(self, expr):
809         pform = self._print(expr.arg)
810         if self._use_unicode:
811             dag = prettyForm(u'\N{DAGGER}')
812         else:
813             dag = prettyForm('+')
814         from sympy.matrices import MatrixSymbol
815         if not isinstance(expr.arg, MatrixSymbol):
816             pform = prettyForm(*pform.parens())
817         pform = pform**dag
818         return pform
819 
820     def _print_BlockMatrix(self, B):
821         if B.blocks.shape == (1, 1):
822             return self._print(B.blocks[0, 0])
823         return self._print(B.blocks)
824 
825     def _print_MatAdd(self, expr):
826         s = None
827         for item in expr.args:
828             pform = self._print(item)
829             if s is None:
830                 s = pform     # First element
831             else:
832                 coeff = item.as_coeff_mmul()[0]
833                 if _coeff_isneg(S(coeff)):
834                     s = prettyForm(*stringPict.next(s, ' '))
835                     pform = self._print(item)
836                 else:
837                     s = prettyForm(*stringPict.next(s, ' + '))
838                 s = prettyForm(*stringPict.next(s, pform))
839 
840         return s
841 
842     def _print_MatMul(self, expr):
843         args = list(expr.args)
844         from sympy import Add, MatAdd, HadamardProduct, KroneckerProduct
845         for i, a in enumerate(args):
846             if (isinstance(a, (Add, MatAdd, HadamardProduct, KroneckerProduct))
847                     and len(expr.args) > 1):
848                 args[i] = prettyForm(*self._print(a).parens())
849             else:
850                 args[i] = self._print(a)
851 
852         return prettyForm.__mul__(*args)
853 
854     def _print_DotProduct(self, expr):
855         args = list(expr.args)
856 
857         for i, a in enumerate(args):
858             args[i] = self._print(a)
859         return prettyForm.__mul__(*args)
860 
861     def _print_MatPow(self, expr):
862         pform = self._print(expr.base)
863         from sympy.matrices import MatrixSymbol
864         if not isinstance(expr.base, MatrixSymbol):
865             pform = prettyForm(*pform.parens())
866         pform = pform**(self._print(expr.exp))
867         return pform
868 
869     def _print_HadamardProduct(self, expr):
870         from sympy import MatAdd, MatMul
871         if self._use_unicode:
872             delim = pretty_atom('Ring')
873         else:
874             delim = '.*'
875         return self._print_seq(expr.args, None, None, delim,
876                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
877 
878     def _print_KroneckerProduct(self, expr):
879         from sympy import MatAdd, MatMul
880         if self._use_unicode:
881             delim = u' \N{N-ARY CIRCLED TIMES OPERATOR} '
882         else:
883             delim = ' x '
884         return self._print_seq(expr.args, None, None, delim,
885                 parenthesize=lambda x: isinstance(x, (MatAdd, MatMul)))
886 
887     def _print_FunctionMatrix(self, X):
888         D = self._print(X.lamda.expr)
889         D = prettyForm(*D.parens('[', ']'))
890         return D
891 
892     def _print_BasisDependent(self, expr):
893         from sympy.vector import Vector
894 
895         if not self._use_unicode:
896             raise NotImplementedError("ASCII pretty printing of BasisDependent is not implemented")
897 
898         if expr == expr.zero:
899             return prettyForm(expr.zero._pretty_form)
900         o1 = []
901         vectstrs = []
902         if isinstance(expr, Vector):
903             items = expr.separate().items()
904         else:
905             items = [(0, expr)]
906         for system, vect in items:
907             inneritems = list(vect.components.items())
908             inneritems.sort(key = lambda x: x[0].__str__())
909             for k, v in inneritems:
910                 #if the coef of the basis vector is 1
911                 #we skip the 1
912                 if v == 1:
913                     o1.append(u"" +
914                               k._pretty_form)
915                 #Same for -1
916                 elif v == -1:
917                     o1.append(u"(-1) " +
918                               k._pretty_form)
919                 #For a general expr
920                 else:
921                     #We always wrap the measure numbers in
922                     #parentheses
923                     arg_str = self._print(
924                         v).parens()[0]
925 
926                     o1.append(arg_str + ' ' + k._pretty_form)
927                 vectstrs.append(k._pretty_form)
928 
929         #outstr = u("").join(o1)
930         if o1[0].startswith(u" + "):
931             o1[0] = o1[0][3:]
932         elif o1[0].startswith(" "):
933             o1[0] = o1[0][1:]
934         #Fixing the newlines
935         lengths = []
936         strs = ['']
937         flag = []
938         for i, partstr in enumerate(o1):
939             flag.append(0)
940             # XXX: What is this hack?
941             if '\n' in partstr:
942                 tempstr = partstr
943                 tempstr = tempstr.replace(vectstrs[i], '')
944                 if u'\N{right parenthesis extension}' in tempstr:   # If scalar is a fraction
945                     for paren in range(len(tempstr)):
946                         flag[i] = 1
947                         if tempstr[paren] == u'\N{right parenthesis extension}':
948                             tempstr = tempstr[:paren] + u'\N{right parenthesis extension}'\
949                                          + ' '  + vectstrs[i] + tempstr[paren + 1:]
950                             break
951                 elif u'\N{RIGHT PARENTHESIS LOWER HOOK}' in tempstr:
952                     flag[i] = 1
953                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS LOWER HOOK}',
954                                         u'\N{RIGHT PARENTHESIS LOWER HOOK}'
955                                         + ' ' + vectstrs[i])
956                 else:
957                     tempstr = tempstr.replace(u'\N{RIGHT PARENTHESIS UPPER HOOK}',
958                                         u'\N{RIGHT PARENTHESIS UPPER HOOK}'
959                                         + ' ' + vectstrs[i])
960                 o1[i] = tempstr
961 
962         o1 = [x.split('\n') for x in o1]
963         n_newlines = max([len(x) for x in o1])  # Width of part in its pretty form
964 
965         if 1 in flag:                           # If there was a fractional scalar
966             for i, parts in enumerate(o1):
967                 if len(parts) == 1:             # If part has no newline
968                     parts.insert(0, ' ' * (len(parts[0])))
969                     flag[i] = 1
970 
971         for i, parts in enumerate(o1):
972             lengths.append(len(parts[flag[i]]))
973             for j in range(n_newlines):
974                 if j+1 <= len(parts):
975                     if j >= len(strs):
976                         strs.append(' ' * (sum(lengths[:-1]) +
977                                            3*(len(lengths)-1)))
978                     if j == flag[i]:
979                         strs[flag[i]] += parts[flag[i]] + ' + '
980                     else:
981                         strs[j] += parts[j] + ' '*(lengths[-1] -
982                                                    len(parts[j])+
983                                                    3)
984                 else:
985                     if j >= len(strs):
986                         strs.append(' ' * (sum(lengths[:-1]) +
987                                            3*(len(lengths)-1)))
988                     strs[j] += ' '*(lengths[-1]+3)
989 
990         return prettyForm(u'\n'.join([s[:-3] for s in strs]))
991 
992     def _print_NDimArray(self, expr):
993         from sympy import ImmutableMatrix
994 
995         if expr.rank() == 0:
996             return self._print(expr[()])
997 
998         level_str = [[]] + [[] for i in range(expr.rank())]
999         shape_ranges = [list(range(i)) for i in expr.shape]
1000         for outer_i in itertools.product(*shape_ranges):
1001             level_str[-1].append(expr[outer_i])
1002             even = True
1003             for back_outer_i in range(expr.rank()-1, -1, -1):
1004                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1005                     break
1006                 if even:
1007                     level_str[back_outer_i].append(level_str[back_outer_i+1])
1008                 else:
1009                     level_str[back_outer_i].append(ImmutableMatrix(level_str[back_outer_i+1]))
1010                     if len(level_str[back_outer_i + 1]) == 1:
1011                         level_str[back_outer_i][-1] = ImmutableMatrix([[level_str[back_outer_i][-1]]])
1012                 even = not even
1013                 level_str[back_outer_i+1] = []
1014 
1015         out_expr = level_str[0][0]
1016         if expr.rank() % 2 == 1:
1017             out_expr = ImmutableMatrix([out_expr])
1018 
1019         return self._print(out_expr)
1020 
1021     _print_ImmutableDenseNDimArray = _print_NDimArray
1022     _print_ImmutableSparseNDimArray = _print_NDimArray
1023     _print_MutableDenseNDimArray = _print_NDimArray
1024     _print_MutableSparseNDimArray = _print_NDimArray
1025 
1026     def _printer_tensor_indices(self, name, indices, index_map={}):
1027         center = stringPict(name)
1028         top = stringPict(" "*center.width())
1029         bot = stringPict(" "*center.width())
1030 
1031         last_valence = None
1032         prev_map = None
1033 
1034         for i, index in enumerate(indices):
1035             indpic = self._print(index.args[0])
1036             if ((index in index_map) or prev_map) and last_valence == index.is_up:
1037                 if index.is_up:
1038                     top = prettyForm(*stringPict.next(top, ","))
1039                 else:
1040                     bot = prettyForm(*stringPict.next(bot, ","))
1041             if index in index_map:
1042                 indpic = prettyForm(*stringPict.next(indpic, "="))
1043                 indpic = prettyForm(*stringPict.next(indpic, self._print(index_map[index])))
1044                 prev_map = True
1045             else:
1046                 prev_map = False
1047             if index.is_up:
1048                 top = stringPict(*top.right(indpic))
1049                 center = stringPict(*center.right(" "*indpic.width()))
1050                 bot = stringPict(*bot.right(" "*indpic.width()))
1051             else:
1052                 bot = stringPict(*bot.right(indpic))
1053                 center = stringPict(*center.right(" "*indpic.width()))
1054                 top = stringPict(*top.right(" "*indpic.width()))
1055             last_valence = index.is_up
1056 
1057         pict = prettyForm(*center.above(top))
1058         pict = prettyForm(*pict.below(bot))
1059         return pict
1060 
1061     def _print_Tensor(self, expr):
1062         name = expr.args[0].name
1063         indices = expr.get_indices()
1064         return self._printer_tensor_indices(name, indices)
1065 
1066     def _print_TensorElement(self, expr):
1067         name = expr.expr.args[0].name
1068         indices = expr.expr.get_indices()
1069         index_map = expr.index_map
1070         return self._printer_tensor_indices(name, indices, index_map)
1071 
1072     def _print_TensMul(self, expr):
1073         sign, args = expr._get_args_for_traditional_printer()
1074         args = [
1075             prettyForm(*self._print(i).parens()) if
1076             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1077             for i in args
1078         ]
1079         pform = prettyForm.__mul__(*args)
1080         if sign:
1081             return prettyForm(*pform.left(sign))
1082         else:
1083             return pform
1084 
1085     def _print_TensAdd(self, expr):
1086         args = [
1087             prettyForm(*self._print(i).parens()) if
1088             precedence_traditional(i) < PRECEDENCE["Mul"] else self._print(i)
1089             for i in expr.args
1090         ]
1091         return prettyForm.__add__(*args)
1092 
1093     def _print_TensorIndex(self, expr):
1094         sym = expr.args[0]
1095         if not expr.is_up:
1096             sym = -sym
1097         return self._print(sym)
1098 
1099     def _print_PartialDerivative(self, deriv):
1100         if self._use_unicode:
1101             deriv_symbol = U('PARTIAL DIFFERENTIAL')
1102         else:
1103             deriv_symbol = r'd'
1104         x = None
1105 
1106         for variable in reversed(deriv.variables):
1107             s = self._print(variable)
1108             ds = prettyForm(*s.left(deriv_symbol))
1109 
1110             if x is None:
1111                 x = ds
1112             else:
1113                 x = prettyForm(*x.right(' '))
1114                 x = prettyForm(*x.right(ds))
1115 
1116         f = prettyForm(
1117             binding=prettyForm.FUNC, *self._print(deriv.expr).parens())
1118 
1119         pform = prettyForm(deriv_symbol)
1120 
1121         pform = prettyForm(*pform.below(stringPict.LINE, x))
1122         pform.baseline = pform.baseline + 1
1123         pform = prettyForm(*stringPict.next(pform, f))
1124         pform.binding = prettyForm.MUL
1125 
1126         return pform
1127 
1128     def _print_Piecewise(self, pexpr):
1129 
1130         P = {}
1131         for n, ec in enumerate(pexpr.args):
1132             P[n, 0] = self._print(ec.expr)
1133             if ec.cond == True:
1134                 P[n, 1] = prettyForm('otherwise')
1135             else:
1136                 P[n, 1] = prettyForm(
1137                     *prettyForm('for ').right(self._print(ec.cond)))
1138         hsep = 2
1139         vsep = 1
1140         len_args = len(pexpr.args)
1141 
1142         # max widths
1143         maxw = [max([P[i, j].width() for i in range(len_args)])
1144                 for j in range(2)]
1145 
1146         # FIXME: Refactor this code and matrix into some tabular environment.
1147         # drawing result
1148         D = None
1149 
1150         for i in range(len_args):
1151             D_row = None
1152             for j in range(2):
1153                 p = P[i, j]
1154                 assert p.width() <= maxw[j]
1155 
1156                 wdelta = maxw[j] - p.width()
1157                 wleft = wdelta // 2
1158                 wright = wdelta - wleft
1159 
1160                 p = prettyForm(*p.right(' '*wright))
1161                 p = prettyForm(*p.left(' '*wleft))
1162 
1163                 if D_row is None:
1164                     D_row = p
1165                     continue
1166 
1167                 D_row = prettyForm(*D_row.right(' '*hsep))  # h-spacer
1168                 D_row = prettyForm(*D_row.right(p))
1169             if D is None:
1170                 D = D_row       # first row in a picture
1171                 continue
1172 
1173             # v-spacer
1174             for _ in range(vsep):
1175                 D = prettyForm(*D.below(' '))
1176 
1177             D = prettyForm(*D.below(D_row))
1178 
1179         D = prettyForm(*D.parens('{', ''))
1180         D.baseline = D.height()//2
1181         D.binding = prettyForm.OPEN
1182         return D
1183 
1184     def _print_ITE(self, ite):
1185         from sympy.functions.elementary.piecewise import Piecewise
1186         return self._print(ite.rewrite(Piecewise))
1187 
1188     def _hprint_vec(self, v):
1189         D = None
1190 
1191         for a in v:
1192             p = a
1193             if D is None:
1194                 D = p
1195             else:
1196                 D = prettyForm(*D.right(', '))
1197                 D = prettyForm(*D.right(p))
1198         if D is None:
1199             D = stringPict(' ')
1200 
1201         return D
1202 
1203     def _hprint_vseparator(self, p1, p2):
1204         tmp = prettyForm(*p1.right(p2))
1205         sep = stringPict(vobj('|', tmp.height()), baseline=tmp.baseline)
1206         return prettyForm(*p1.right(sep, p2))
1207 
1208     def _print_hyper(self, e):
1209         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1210         ap = [self._print(a) for a in e.ap]
1211         bq = [self._print(b) for b in e.bq]
1212 
1213         P = self._print(e.argument)
1214         P.baseline = P.height()//2
1215 
1216         # Drawing result - first create the ap, bq vectors
1217         D = None
1218         for v in [ap, bq]:
1219             D_row = self._hprint_vec(v)
1220             if D is None:
1221                 D = D_row       # first row in a picture
1222             else:
1223                 D = prettyForm(*D.below(' '))
1224                 D = prettyForm(*D.below(D_row))
1225 
1226         # make sure that the argument `z' is centred vertically
1227         D.baseline = D.height()//2
1228 
1229         # insert horizontal separator
1230         P = prettyForm(*P.left(' '))
1231         D = prettyForm(*D.right(' '))
1232 
1233         # insert separating `|`
1234         D = self._hprint_vseparator(D, P)
1235 
1236         # add parens
1237         D = prettyForm(*D.parens('(', ')'))
1238 
1239         # create the F symbol
1240         above = D.height()//2 - 1
1241         below = D.height() - above - 1
1242 
1243         sz, t, b, add, img = annotated('F')
1244         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1245                        baseline=above + sz)
1246         add = (sz + 1)//2
1247 
1248         F = prettyForm(*F.left(self._print(len(e.ap))))
1249         F = prettyForm(*F.right(self._print(len(e.bq))))
1250         F.baseline = above + add
1251 
1252         D = prettyForm(*F.right(' ', D))
1253 
1254         return D
1255 
1256     def _print_meijerg(self, e):
1257         # FIXME refactor Matrix, Piecewise, and this into a tabular environment
1258 
1259         v = {}
1260         v[(0, 0)] = [self._print(a) for a in e.an]
1261         v[(0, 1)] = [self._print(a) for a in e.aother]
1262         v[(1, 0)] = [self._print(b) for b in e.bm]
1263         v[(1, 1)] = [self._print(b) for b in e.bother]
1264 
1265         P = self._print(e.argument)
1266         P.baseline = P.height()//2
1267 
1268         vp = {}
1269         for idx in v:
1270             vp[idx] = self._hprint_vec(v[idx])
1271 
1272         for i in range(2):
1273             maxw = max(vp[(0, i)].width(), vp[(1, i)].width())
1274             for j in range(2):
1275                 s = vp[(j, i)]
1276                 left = (maxw - s.width()) // 2
1277                 right = maxw - left - s.width()
1278                 s = prettyForm(*s.left(' ' * left))
1279                 s = prettyForm(*s.right(' ' * right))
1280                 vp[(j, i)] = s
1281 
1282         D1 = prettyForm(*vp[(0, 0)].right('  ', vp[(0, 1)]))
1283         D1 = prettyForm(*D1.below(' '))
1284         D2 = prettyForm(*vp[(1, 0)].right('  ', vp[(1, 1)]))
1285         D = prettyForm(*D1.below(D2))
1286 
1287         # make sure that the argument `z' is centred vertically
1288         D.baseline = D.height()//2
1289 
1290         # insert horizontal separator
1291         P = prettyForm(*P.left(' '))
1292         D = prettyForm(*D.right(' '))
1293 
1294         # insert separating `|`
1295         D = self._hprint_vseparator(D, P)
1296 
1297         # add parens
1298         D = prettyForm(*D.parens('(', ')'))
1299 
1300         # create the G symbol
1301         above = D.height()//2 - 1
1302         below = D.height() - above - 1
1303 
1304         sz, t, b, add, img = annotated('G')
1305         F = prettyForm('\n' * (above - t) + img + '\n' * (below - b),
1306                        baseline=above + sz)
1307 
1308         pp = self._print(len(e.ap))
1309         pq = self._print(len(e.bq))
1310         pm = self._print(len(e.bm))
1311         pn = self._print(len(e.an))
1312 
1313         def adjust(p1, p2):
1314             diff = p1.width() - p2.width()
1315             if diff == 0:
1316                 return p1, p2
1317             elif diff > 0:
1318                 return p1, prettyForm(*p2.left(' '*diff))
1319             else:
1320                 return prettyForm(*p1.left(' '*-diff)), p2
1321         pp, pm = adjust(pp, pm)
1322         pq, pn = adjust(pq, pn)
1323         pu = prettyForm(*pm.right(', ', pn))
1324         pl = prettyForm(*pp.right(', ', pq))
1325 
1326         ht = F.baseline - above - 2
1327         if ht > 0:
1328             pu = prettyForm(*pu.below('\n'*ht))
1329         p = prettyForm(*pu.below(pl))
1330 
1331         F.baseline = above
1332         F = prettyForm(*F.right(p))
1333 
1334         F.baseline = above + add
1335 
1336         D = prettyForm(*F.right(' ', D))
1337 
1338         return D
1339 
1340     def _print_ExpBase(self, e):
1341         # TODO should exp_polar be printed differently?
1342         #      what about exp_polar(0), exp_polar(1)?
1343         base = prettyForm(pretty_atom('Exp1', 'e'))
1344         return base ** self._print(e.args[0])
1345 
1346     def _print_Function(self, e, sort=False, func_name=None):
1347         # optional argument func_name for supplying custom names
1348         # XXX works only for applied functions
1349         func = e.func
1350         args = e.args
1351         if sort:
1352             args = sorted(args, key=default_sort_key)
1353 
1354         if not func_name:
1355             func_name = func.__name__
1356 
1357         prettyFunc = self._print(Symbol(func_name))
1358         prettyArgs = prettyForm(*self._print_seq(args).parens())
1359 
1360         pform = prettyForm(
1361             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1362 
1363         # store pform parts so it can be reassembled e.g. when powered
1364         pform.prettyFunc = prettyFunc
1365         pform.prettyArgs = prettyArgs
1366 
1367         return pform
1368 
1369     @property
1370     def _special_function_classes(self):
1371         from sympy.functions.special.tensor_functions import KroneckerDelta
1372         from sympy.functions.special.gamma_functions import gamma, lowergamma
1373         from sympy.functions.special.zeta_functions import lerchphi
1374         from sympy.functions.special.beta_functions import beta
1375         from sympy.functions.special.delta_functions import DiracDelta
1376         from sympy.functions.special.error_functions import Chi
1377         return {KroneckerDelta: [greek_unicode['delta'], 'delta'],
1378                 gamma: [greek_unicode['Gamma'], 'Gamma'],
1379                 lerchphi: [greek_unicode['Phi'], 'lerchphi'],
1380                 lowergamma: [greek_unicode['gamma'], 'gamma'],
1381                 beta: [greek_unicode['Beta'], 'B'],
1382                 DiracDelta: [greek_unicode['delta'], 'delta'],
1383                 Chi: ['Chi', 'Chi']}
1384 
1385     def _print_FunctionClass(self, expr):
1386         for cls in self._special_function_classes:
1387             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
1388                 if self._use_unicode:
1389                     return prettyForm(self._special_function_classes[cls][0])
1390                 else:
1391                     return prettyForm(self._special_function_classes[cls][1])
1392         func_name = expr.__name__
1393         return prettyForm(pretty_symbol(func_name))
1394 
1395     def _print_GeometryEntity(self, expr):
1396         # GeometryEntity is based on Tuple but should not print like a Tuple
1397         return self.emptyPrinter(expr)
1398 
1399     def _print_lerchphi(self, e):
1400         func_name = greek_unicode['Phi'] if self._use_unicode else 'lerchphi'
1401         return self._print_Function(e, func_name=func_name)
1402 
1403     def _print_Lambda(self, e):
1404         vars, expr = e.args
1405         if self._use_unicode:
1406             arrow = u" \N{RIGHTWARDS ARROW FROM BAR} "
1407         else:
1408             arrow = " -> "
1409         if len(vars) == 1:
1410             var_form = self._print(vars[0])
1411         else:
1412             var_form = self._print(tuple(vars))
1413 
1414         return prettyForm(*stringPict.next(var_form, arrow, self._print(expr)), binding=8)
1415 
1416     def _print_Order(self, expr):
1417         pform = self._print(expr.expr)
1418         if (expr.point and any(p != S.Zero for p in expr.point)) or \
1419            len(expr.variables) > 1:
1420             pform = prettyForm(*pform.right("; "))
1421             if len(expr.variables) > 1:
1422                 pform = prettyForm(*pform.right(self._print(expr.variables)))
1423             elif len(expr.variables):
1424                 pform = prettyForm(*pform.right(self._print(expr.variables[0])))
1425             if self._use_unicode:
1426                 pform = prettyForm(*pform.right(u" \N{RIGHTWARDS ARROW} "))
1427             else:
1428                 pform = prettyForm(*pform.right(" -> "))
1429             if len(expr.point) > 1:
1430                 pform = prettyForm(*pform.right(self._print(expr.point)))
1431             else:
1432                 pform = prettyForm(*pform.right(self._print(expr.point[0])))
1433         pform = prettyForm(*pform.parens())
1434         pform = prettyForm(*pform.left("O"))
1435         return pform
1436 
1437     def _print_SingularityFunction(self, e):
1438         if self._use_unicode:
1439             shift = self._print(e.args[0]-e.args[1])
1440             n = self._print(e.args[2])
1441             base = prettyForm("<")
1442             base = prettyForm(*base.right(shift))
1443             base = prettyForm(*base.right(">"))
1444             pform = base**n
1445             return pform
1446         else:
1447             n = self._print(e.args[2])
1448             shift = self._print(e.args[0]-e.args[1])
1449             base = self._print_seq(shift, "<", ">", ' ')
1450             return base**n
1451 
1452     def _print_beta(self, e):
1453         func_name = greek_unicode['Beta'] if self._use_unicode else 'B'
1454         return self._print_Function(e, func_name=func_name)
1455 
1456     def _print_gamma(self, e):
1457         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1458         return self._print_Function(e, func_name=func_name)
1459 
1460     def _print_uppergamma(self, e):
1461         func_name = greek_unicode['Gamma'] if self._use_unicode else 'Gamma'
1462         return self._print_Function(e, func_name=func_name)
1463 
1464     def _print_lowergamma(self, e):
1465         func_name = greek_unicode['gamma'] if self._use_unicode else 'lowergamma'
1466         return self._print_Function(e, func_name=func_name)
1467 
1468     def _print_DiracDelta(self, e):
1469         if self._use_unicode:
1470             if len(e.args) == 2:
1471                 a = prettyForm(greek_unicode['delta'])
1472                 b = self._print(e.args[1])
1473                 b = prettyForm(*b.parens())
1474                 c = self._print(e.args[0])
1475                 c = prettyForm(*c.parens())
1476                 pform = a**b
1477                 pform = prettyForm(*pform.right(' '))
1478                 pform = prettyForm(*pform.right(c))
1479                 return pform
1480             pform = self._print(e.args[0])
1481             pform = prettyForm(*pform.parens())
1482             pform = prettyForm(*pform.left(greek_unicode['delta']))
1483             return pform
1484         else:
1485             return self._print_Function(e)
1486 
1487     def _print_expint(self, e):
1488         from sympy import Function
1489         if e.args[0].is_Integer and self._use_unicode:
1490             return self._print_Function(Function('E_%s' % e.args[0])(e.args[1]))
1491         return self._print_Function(e)
1492 
1493     def _print_Chi(self, e):
1494         # This needs a special case since otherwise it comes out as greek
1495         # letter chi...
1496         prettyFunc = prettyForm("Chi")
1497         prettyArgs = prettyForm(*self._print_seq(e.args).parens())
1498 
1499         pform = prettyForm(
1500             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
1501 
1502         # store pform parts so it can be reassembled e.g. when powered
1503         pform.prettyFunc = prettyFunc
1504         pform.prettyArgs = prettyArgs
1505 
1506         return pform
1507 
1508     def _print_elliptic_e(self, e):
1509         pforma0 = self._print(e.args[0])
1510         if len(e.args) == 1:
1511             pform = pforma0
1512         else:
1513             pforma1 = self._print(e.args[1])
1514             pform = self._hprint_vseparator(pforma0, pforma1)
1515         pform = prettyForm(*pform.parens())
1516         pform = prettyForm(*pform.left('E'))
1517         return pform
1518 
1519     def _print_elliptic_k(self, e):
1520         pform = self._print(e.args[0])
1521         pform = prettyForm(*pform.parens())
1522         pform = prettyForm(*pform.left('K'))
1523         return pform
1524 
1525     def _print_elliptic_f(self, e):
1526         pforma0 = self._print(e.args[0])
1527         pforma1 = self._print(e.args[1])
1528         pform = self._hprint_vseparator(pforma0, pforma1)
1529         pform = prettyForm(*pform.parens())
1530         pform = prettyForm(*pform.left('F'))
1531         return pform
1532 
1533     def _print_elliptic_pi(self, e):
1534         name = greek_unicode['Pi'] if self._use_unicode else 'Pi'
1535         pforma0 = self._print(e.args[0])
1536         pforma1 = self._print(e.args[1])
1537         if len(e.args) == 2:
1538             pform = self._hprint_vseparator(pforma0, pforma1)
1539         else:
1540             pforma2 = self._print(e.args[2])
1541             pforma = self._hprint_vseparator(pforma1, pforma2)
1542             pforma = prettyForm(*pforma.left('; '))
1543             pform = prettyForm(*pforma.left(pforma0))
1544         pform = prettyForm(*pform.parens())
1545         pform = prettyForm(*pform.left(name))
1546         return pform
1547 
1548     def _print_GoldenRatio(self, expr):
1549         if self._use_unicode:
1550             return prettyForm(pretty_symbol('phi'))
1551         return self._print(Symbol("GoldenRatio"))
1552 
1553     def _print_EulerGamma(self, expr):
1554         if self._use_unicode:
1555             return prettyForm(pretty_symbol('gamma'))
1556         return self._print(Symbol("EulerGamma"))
1557 
1558     def _print_Mod(self, expr):
1559         pform = self._print(expr.args[0])
1560         if pform.binding > prettyForm.MUL:
1561             pform = prettyForm(*pform.parens())
1562         pform = prettyForm(*pform.right(' mod '))
1563         pform = prettyForm(*pform.right(self._print(expr.args[1])))
1564         pform.binding = prettyForm.OPEN
1565         return pform
1566 
1567     def _print_Add(self, expr, order=None):
1568         if self.order == 'none':
1569             terms = list(expr.args)
1570         else:
1571             terms = self._as_ordered_terms(expr, order=order)
1572         pforms, indices = [], []
1573 
1574         def pretty_negative(pform, index):
1575             """Prepend a minus sign to a pretty form. """
1576             #TODO: Move this code to prettyForm
1577             if index == 0:
1578                 if pform.height() > 1:
1579                     pform_neg = '- '
1580                 else:
1581                     pform_neg = '-'
1582             else:
1583                 pform_neg = ' - '
1584 
1585             if (pform.binding > prettyForm.NEG
1586                 or pform.binding == prettyForm.ADD):
1587                 p = stringPict(*pform.parens())
1588             else:
1589                 p = pform
1590             p = stringPict.next(pform_neg, p)
1591             # Lower the binding to NEG, even if it was higher. Otherwise, it
1592             # will print as a + ( - (b)), instead of a - (b).
1593             return prettyForm(binding=prettyForm.NEG, *p)
1594 
1595         for i, term in enumerate(terms):
1596             if term.is_Mul and _coeff_isneg(term):
1597                 coeff, other = term.as_coeff_mul(rational=False)
1598                 pform = self._print(Mul(-coeff, *other, evaluate=False))
1599                 pforms.append(pretty_negative(pform, i))
1600             elif term.is_Rational and term.q > 1:
1601                 pforms.append(None)
1602                 indices.append(i)
1603             elif term.is_Number and term < 0:
1604                 pform = self._print(-term)
1605                 pforms.append(pretty_negative(pform, i))
1606             elif term.is_Relational:
1607                 pforms.append(prettyForm(*self._print(term).parens()))
1608             else:
1609                 pforms.append(self._print(term))
1610 
1611         if indices:
1612             large = True
1613 
1614             for pform in pforms:
1615                 if pform is not None and pform.height() > 1:
1616                     break
1617             else:
1618                 large = False
1619 
1620             for i in indices:
1621                 term, negative = terms[i], False
1622 
1623                 if term < 0:
1624                     term, negative = -term, True
1625 
1626                 if large:
1627                     pform = prettyForm(str(term.p))/prettyForm(str(term.q))
1628                 else:
1629                     pform = self._print(term)
1630 
1631                 if negative:
1632                     pform = pretty_negative(pform, i)
1633 
1634                 pforms[i] = pform
1635 
1636         return prettyForm.__add__(*pforms)
1637 
1638     def _print_Mul(self, product):
1639         from sympy.physics.units import Quantity
1640         a = []  # items in the numerator
1641         b = []  # items that are in the denominator (if any)
1642 
1643         if self.order not in ('old', 'none'):
1644             args = product.as_ordered_factors()
1645         else:
1646             args = list(product.args)
1647 
1648         # If quantities are present append them at the back
1649         args = sorted(args, key=lambda x: isinstance(x, Quantity) or
1650                      (isinstance(x, Pow) and isinstance(x.base, Quantity)))
1651 
1652         # Gather terms for numerator/denominator
1653         for item in args:
1654             if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:
1655                 if item.exp != -1:
1656                     b.append(Pow(item.base, -item.exp, evaluate=False))
1657                 else:
1658                     b.append(Pow(item.base, -item.exp))
1659             elif item.is_Rational and item is not S.Infinity:
1660                 if item.p != 1:
1661                     a.append( Rational(item.p) )
1662                 if item.q != 1:
1663                     b.append( Rational(item.q) )
1664             else:
1665                 a.append(item)
1666 
1667         from sympy import Integral, Piecewise, Product, Sum
1668 
1669         # Convert to pretty forms. Add parens to Add instances if there
1670         # is more than one term in the numer/denom
1671         for i in range(0, len(a)):
1672             if (a[i].is_Add and len(a) > 1) or (i != len(a) - 1 and
1673                     isinstance(a[i], (Integral, Piecewise, Product, Sum))):
1674                 a[i] = prettyForm(*self._print(a[i]).parens())
1675             elif a[i].is_Relational:
1676                 a[i] = prettyForm(*self._print(a[i]).parens())
1677             else:
1678                 a[i] = self._print(a[i])
1679 
1680         for i in range(0, len(b)):
1681             if (b[i].is_Add and len(b) > 1) or (i != len(b) - 1 and
1682                     isinstance(b[i], (Integral, Piecewise, Product, Sum))):
1683                 b[i] = prettyForm(*self._print(b[i]).parens())
1684             else:
1685                 b[i] = self._print(b[i])
1686 
1687         # Construct a pretty form
1688         if len(b) == 0:
1689             return prettyForm.__mul__(*a)
1690         else:
1691             if len(a) == 0:
1692                 a.append( self._print(S.One) )
1693             return prettyForm.__mul__(*a)/prettyForm.__mul__(*b)
1694 
1695     # A helper function for _print_Pow to print x**(1/n)
1696     def _print_nth_root(self, base, expt):
1697         bpretty = self._print(base)
1698 
1699         # In very simple cases, use a single-char root sign
1700         if (self._settings['use_unicode_sqrt_char'] and self._use_unicode
1701             and expt is S.Half and bpretty.height() == 1
1702             and (bpretty.width() == 1
1703                  or (base.is_Integer and base.is_nonnegative))):
1704             return prettyForm(*bpretty.left(u'\N{SQUARE ROOT}'))
1705 
1706         # Construct root sign, start with the \/ shape
1707         _zZ = xobj('/', 1)
1708         rootsign = xobj('\\', 1) + _zZ
1709         # Make exponent number to put above it
1710         if isinstance(expt, Rational):
1711             exp = str(expt.q)
1712             if exp == '2':
1713                 exp = ''
1714         else:
1715             exp = str(expt.args[0])
1716         exp = exp.ljust(2)
1717         if len(exp) > 2:
1718             rootsign = ' '*(len(exp) - 2) + rootsign
1719         # Stack the exponent
1720         rootsign = stringPict(exp + '\n' + rootsign)
1721         rootsign.baseline = 0
1722         # Diagonal: length is one less than height of base
1723         linelength = bpretty.height() - 1
1724         diagonal = stringPict('\n'.join(
1725             ' '*(linelength - i - 1) + _zZ + ' '*i
1726             for i in range(linelength)
1727         ))
1728         # Put baseline just below lowest line: next to exp
1729         diagonal.baseline = linelength - 1
1730         # Make the root symbol
1731         rootsign = prettyForm(*rootsign.right(diagonal))
1732         # Det the baseline to match contents to fix the height
1733         # but if the height of bpretty is one, the rootsign must be one higher
1734         rootsign.baseline = max(1, bpretty.baseline)
1735         #build result
1736         s = prettyForm(hobj('_', 2 + bpretty.width()))
1737         s = prettyForm(*bpretty.above(s))
1738         s = prettyForm(*s.left(rootsign))
1739         return s
1740 
1741     def _print_Pow(self, power):
1742         from sympy.simplify.simplify import fraction
1743         b, e = power.as_base_exp()
1744         if power.is_commutative:
1745             if e is S.NegativeOne:
1746                 return prettyForm("1")/self._print(b)
1747             n, d = fraction(e)
1748             if n is S.One and d.is_Atom and not e.is_Integer and self._settings['root_notation']:
1749                 return self._print_nth_root(b, e)
1750             if e.is_Rational and e < 0:
1751                 return prettyForm("1")/self._print(Pow(b, -e, evaluate=False))
1752 
1753         if b.is_Relational:
1754             return prettyForm(*self._print(b).parens()).__pow__(self._print(e))
1755 
1756         return self._print(b)**self._print(e)
1757 
1758     def _print_UnevaluatedExpr(self, expr):
1759         return self._print(expr.args[0])
1760 
1761     def __print_numer_denom(self, p, q):
1762         if q == 1:
1763             if p < 0:
1764                 return prettyForm(str(p), binding=prettyForm.NEG)
1765             else:
1766                 return prettyForm(str(p))
1767         elif abs(p) >= 10 and abs(q) >= 10:
1768             # If more than one digit in numer and denom, print larger fraction
1769             if p < 0:
1770                 return prettyForm(str(p), binding=prettyForm.NEG)/prettyForm(str(q))
1771                 # Old printing method:
1772                 #pform = prettyForm(str(-p))/prettyForm(str(q))
1773                 #return prettyForm(binding=prettyForm.NEG, *pform.left('- '))
1774             else:
1775                 return prettyForm(str(p))/prettyForm(str(q))
1776         else:
1777             return None
1778 
1779     def _print_Rational(self, expr):
1780         result = self.__print_numer_denom(expr.p, expr.q)
1781 
1782         if result is not None:
1783             return result
1784         else:
1785             return self.emptyPrinter(expr)
1786 
1787     def _print_Fraction(self, expr):
1788         result = self.__print_numer_denom(expr.numerator, expr.denominator)
1789 
1790         if result is not None:
1791             return result
1792         else:
1793             return self.emptyPrinter(expr)
1794 
1795     def _print_ProductSet(self, p):
1796         if len(p.sets) > 1 and not has_variety(p.sets):
1797             from sympy import Pow
1798             return self._print(Pow(p.sets[0], len(p.sets), evaluate=False))
1799         else:
1800             prod_char = u"\N{MULTIPLICATION SIGN}" if self._use_unicode else 'x'
1801             return self._print_seq(p.sets, None, None, ' %s ' % prod_char,
1802                                    parenthesize=lambda set: set.is_Union or
1803                                    set.is_Intersection or set.is_ProductSet)
1804 
1805     def _print_FiniteSet(self, s):
1806         items = sorted(s.args, key=default_sort_key)
1807         return self._print_seq(items, '{', '}', ', ' )
1808 
1809     def _print_Range(self, s):
1810 
1811         if self._use_unicode:
1812             dots = u"\N{HORIZONTAL ELLIPSIS}"
1813         else:
1814             dots = '...'
1815 
1816         if s.start.is_infinite:
1817             printset = dots, s[-1] - s.step, s[-1]
1818         elif s.stop.is_infinite:
1819             it = iter(s)
1820             printset = next(it), next(it), dots
1821         elif len(s) > 4:
1822             it = iter(s)
1823             printset = next(it), next(it), dots, s[-1]
1824         else:
1825             printset = tuple(s)
1826 
1827         return self._print_seq(printset, '{', '}', ', ' )
1828 
1829     def _print_Interval(self, i):
1830         if i.start == i.end:
1831             return self._print_seq(i.args[:1], '{', '}')
1832 
1833         else:
1834             if i.left_open:
1835                 left = '('
1836             else:
1837                 left = '['
1838 
1839             if i.right_open:
1840                 right = ')'
1841             else:
1842                 right = ']'
1843 
1844             return self._print_seq(i.args[:2], left, right)
1845 
1846     def _print_AccumulationBounds(self, i):
1847         left = '<'
1848         right = '>'
1849 
1850         return self._print_seq(i.args[:2], left, right)
1851 
1852     def _print_Intersection(self, u):
1853 
1854         delimiter = ' %s ' % pretty_atom('Intersection', 'n')
1855 
1856         return self._print_seq(u.args, None, None, delimiter,
1857                                parenthesize=lambda set: set.is_ProductSet or
1858                                set.is_Union or set.is_Complement)
1859 
1860     def _print_Union(self, u):
1861 
1862         union_delimiter = ' %s ' % pretty_atom('Union', 'U')
1863 
1864         return self._print_seq(u.args, None, None, union_delimiter,
1865                                parenthesize=lambda set: set.is_ProductSet or
1866                                set.is_Intersection or set.is_Complement)
1867 
1868     def _print_SymmetricDifference(self, u):
1869         if not self._use_unicode:
1870             raise NotImplementedError("ASCII pretty printing of SymmetricDifference is not implemented")
1871 
1872         sym_delimeter = ' %s ' % pretty_atom('SymmetricDifference')
1873 
1874         return self._print_seq(u.args, None, None, sym_delimeter)
1875 
1876     def _print_Complement(self, u):
1877 
1878         delimiter = r' \ '
1879 
1880         return self._print_seq(u.args, None, None, delimiter,
1881              parenthesize=lambda set: set.is_ProductSet or set.is_Intersection
1882                                or set.is_Union)
1883 
1884     def _print_ImageSet(self, ts):
1885         if self._use_unicode:
1886             inn = u"\N{SMALL ELEMENT OF}"
1887         else:
1888             inn = 'in'
1889         variables = ts.lamda.variables
1890         expr = self._print(ts.lamda.expr)
1891         bar = self._print("|")
1892         sets = [self._print(i) for i in ts.args[1:]]
1893         if len(sets) == 1:
1894             return self._print_seq((expr, bar, variables[0], inn, sets[0]), "{", "}", ' ')
1895         else:
1896             pargs = tuple(j for var, setv in zip(variables, sets) for j in (var, inn, setv, ","))
1897             return self._print_seq((expr, bar) + pargs[:-1], "{", "}", ' ')
1898 
1899     def _print_ConditionSet(self, ts):
1900         if self._use_unicode:
1901             inn = u"\N{SMALL ELEMENT OF}"
1902             # using _and because and is a keyword and it is bad practice to
1903             # overwrite them
1904             _and = u"\N{LOGICAL AND}"
1905         else:
1906             inn = 'in'
1907             _and = 'and'
1908 
1909         variables = self._print_seq(Tuple(ts.sym))
1910         as_expr = getattr(ts.condition, 'as_expr', None)
1911         if as_expr is not None:
1912             cond = self._print(ts.condition.as_expr())
1913         else:
1914             cond = self._print(ts.condition)
1915             if self._use_unicode:
1916                 cond = self._print_seq(cond, "(", ")")
1917 
1918         bar = self._print("|")
1919 
1920         if ts.base_set is S.UniversalSet:
1921             return self._print_seq((variables, bar, cond), "{", "}", ' ')
1922 
1923         base = self._print(ts.base_set)
1924         return self._print_seq((variables, bar, variables, inn,
1925                                 base, _and, cond), "{", "}", ' ')
1926 
1927     def _print_ComplexRegion(self, ts):
1928         if self._use_unicode:
1929             inn = u"\N{SMALL ELEMENT OF}"
1930         else:
1931             inn = 'in'
1932         variables = self._print_seq(ts.variables)
1933         expr = self._print(ts.expr)
1934         bar = self._print("|")
1935         prodsets = self._print(ts.sets)
1936 
1937         return self._print_seq((expr, bar, variables, inn, prodsets), "{", "}", ' ')
1938 
1939     def _print_Contains(self, e):
1940         var, set = e.args
1941         if self._use_unicode:
1942             el = u" \N{ELEMENT OF} "
1943             return prettyForm(*stringPict.next(self._print(var),
1944                                                el, self._print(set)), binding=8)
1945         else:
1946             return prettyForm(sstr(e))
1947 
1948     def _print_FourierSeries(self, s):
1949         if self._use_unicode:
1950             dots = u"\N{HORIZONTAL ELLIPSIS}"
1951         else:
1952             dots = '...'
1953         return self._print_Add(s.truncate()) + self._print(dots)
1954 
1955     def _print_FormalPowerSeries(self, s):
1956         return self._print_Add(s.infinite)
1957 
1958     def _print_SetExpr(self, se):
1959         pretty_set = prettyForm(*self._print(se.set).parens())
1960         pretty_name = self._print(Symbol("SetExpr"))
1961         return prettyForm(*pretty_name.right(pretty_set))
1962 
1963     def _print_SeqFormula(self, s):
1964         if self._use_unicode:
1965             dots = u"\N{HORIZONTAL ELLIPSIS}"
1966         else:
1967             dots = '...'
1968 
1969         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
1970             raise NotImplementedError("Pretty printing of sequences with symbolic bound not implemented")
1971 
1972         if s.start is S.NegativeInfinity:
1973             stop = s.stop
1974             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
1975                 s.coeff(stop - 1), s.coeff(stop))
1976         elif s.stop is S.Infinity or s.length > 4:
1977             printset = s[:4]
1978             printset.append(dots)
1979             printset = tuple(printset)
1980         else:
1981             printset = tuple(s)
1982         return self._print_list(printset)
1983 
1984     _print_SeqPer = _print_SeqFormula
1985     _print_SeqAdd = _print_SeqFormula
1986     _print_SeqMul = _print_SeqFormula
1987 
1988     def _print_seq(self, seq, left=None, right=None, delimiter=', ',
1989             parenthesize=lambda x: False):
1990         s = None
1991         try:
1992             for item in seq:
1993                 pform = self._print(item)
1994 
1995                 if parenthesize(item):
1996                     pform = prettyForm(*pform.parens())
1997                 if s is None:
1998                     # first element
1999                     s = pform
2000                 else:
2001                     # XXX: Under the tests from #15686 this raises:
2002                     # AttributeError: 'Fake' object has no attribute 'baseline'
2003                     # This is caught below but that is not the right way to
2004                     # fix it.
2005                     s = prettyForm(*stringPict.next(s, delimiter))
2006                     s = prettyForm(*stringPict.next(s, pform))
2007 
2008             if s is None:
2009                 s = stringPict('')
2010 
2011         except AttributeError:
2012             s = None
2013             for item in seq:
2014                 pform = self.doprint(item)
2015                 if parenthesize(item):
2016                     pform = prettyForm(*pform.parens())
2017                 if s is None:
2018                     # first element
2019                     s = pform
2020                 else :
2021                     s = prettyForm(*stringPict.next(s, delimiter))
2022                     s = prettyForm(*stringPict.next(s, pform))
2023 
2024             if s is None:
2025                 s = stringPict('')
2026 
2027         s = prettyForm(*s.parens(left, right, ifascii_nougly=True))
2028         return s
2029 
2030     def join(self, delimiter, args):
2031         pform = None
2032 
2033         for arg in args:
2034             if pform is None:
2035                 pform = arg
2036             else:
2037                 pform = prettyForm(*pform.right(delimiter))
2038                 pform = prettyForm(*pform.right(arg))
2039 
2040         if pform is None:
2041             return prettyForm("")
2042         else:
2043             return pform
2044 
2045     def _print_list(self, l):
2046         return self._print_seq(l, '[', ']')
2047 
2048     def _print_tuple(self, t):
2049         if len(t) == 1:
2050             ptuple = prettyForm(*stringPict.next(self._print(t[0]), ','))
2051             return prettyForm(*ptuple.parens('(', ')', ifascii_nougly=True))
2052         else:
2053             return self._print_seq(t, '(', ')')
2054 
2055     def _print_Tuple(self, expr):
2056         return self._print_tuple(expr)
2057 
2058     def _print_dict(self, d):
2059         keys = sorted(d.keys(), key=default_sort_key)
2060         items = []
2061 
2062         for k in keys:
2063             K = self._print(k)
2064             V = self._print(d[k])
2065             s = prettyForm(*stringPict.next(K, ': ', V))
2066 
2067             items.append(s)
2068 
2069         return self._print_seq(items, '{', '}')
2070 
2071     def _print_Dict(self, d):
2072         return self._print_dict(d)
2073 
2074     def _print_set(self, s):
2075         if not s:
2076             return prettyForm('set()')
2077         items = sorted(s, key=default_sort_key)
2078         pretty = self._print_seq(items)
2079         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2080         return pretty
2081 
2082     def _print_frozenset(self, s):
2083         if not s:
2084             return prettyForm('frozenset()')
2085         items = sorted(s, key=default_sort_key)
2086         pretty = self._print_seq(items)
2087         pretty = prettyForm(*pretty.parens('{', '}', ifascii_nougly=True))
2088         pretty = prettyForm(*pretty.parens('(', ')', ifascii_nougly=True))
2089         pretty = prettyForm(*stringPict.next(type(s).__name__, pretty))
2090         return pretty
2091 
2092     def _print_PolyRing(self, ring):
2093         return prettyForm(sstr(ring))
2094 
2095     def _print_FracField(self, field):
2096         return prettyForm(sstr(field))
2097 
2098     def _print_FreeGroupElement(self, elm):
2099         return prettyForm(str(elm))
2100 
2101     def _print_PolyElement(self, poly):
2102         return prettyForm(sstr(poly))
2103 
2104     def _print_FracElement(self, frac):
2105         return prettyForm(sstr(frac))
2106 
2107     def _print_AlgebraicNumber(self, expr):
2108         if expr.is_aliased:
2109             return self._print(expr.as_poly().as_expr())
2110         else:
2111             return self._print(expr.as_expr())
2112 
2113     def _print_ComplexRootOf(self, expr):
2114         args = [self._print_Add(expr.expr, order='lex'), expr.index]
2115         pform = prettyForm(*self._print_seq(args).parens())
2116         pform = prettyForm(*pform.left('CRootOf'))
2117         return pform
2118 
2119     def _print_RootSum(self, expr):
2120         args = [self._print_Add(expr.expr, order='lex')]
2121 
2122         if expr.fun is not S.IdentityFunction:
2123             args.append(self._print(expr.fun))
2124 
2125         pform = prettyForm(*self._print_seq(args).parens())
2126         pform = prettyForm(*pform.left('RootSum'))
2127 
2128         return pform
2129 
2130     def _print_FiniteField(self, expr):
2131         if self._use_unicode:
2132             form = u'\N{DOUBLE-STRUCK CAPITAL Z}_%d'
2133         else:
2134             form = 'GF(%d)'
2135 
2136         return prettyForm(pretty_symbol(form % expr.mod))
2137 
2138     def _print_IntegerRing(self, expr):
2139         if self._use_unicode:
2140             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Z}')
2141         else:
2142             return prettyForm('ZZ')
2143 
2144     def _print_RationalField(self, expr):
2145         if self._use_unicode:
2146             return prettyForm(u'\N{DOUBLE-STRUCK CAPITAL Q}')
2147         else:
2148             return prettyForm('QQ')
2149 
2150     def _print_RealField(self, domain):
2151         if self._use_unicode:
2152             prefix = u'\N{DOUBLE-STRUCK CAPITAL R}'
2153         else:
2154             prefix = 'RR'
2155 
2156         if domain.has_default_precision:
2157             return prettyForm(prefix)
2158         else:
2159             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2160 
2161     def _print_ComplexField(self, domain):
2162         if self._use_unicode:
2163             prefix = u'\N{DOUBLE-STRUCK CAPITAL C}'
2164         else:
2165             prefix = 'CC'
2166 
2167         if domain.has_default_precision:
2168             return prettyForm(prefix)
2169         else:
2170             return self._print(pretty_symbol(prefix + "_" + str(domain.precision)))
2171 
2172     def _print_PolynomialRing(self, expr):
2173         args = list(expr.symbols)
2174 
2175         if not expr.order.is_default:
2176             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2177             args.append(order)
2178 
2179         pform = self._print_seq(args, '[', ']')
2180         pform = prettyForm(*pform.left(self._print(expr.domain)))
2181 
2182         return pform
2183 
2184     def _print_FractionField(self, expr):
2185         args = list(expr.symbols)
2186 
2187         if not expr.order.is_default:
2188             order = prettyForm(*prettyForm("order=").right(self._print(expr.order)))
2189             args.append(order)
2190 
2191         pform = self._print_seq(args, '(', ')')
2192         pform = prettyForm(*pform.left(self._print(expr.domain)))
2193 
2194         return pform
2195 
2196     def _print_PolynomialRingBase(self, expr):
2197         g = expr.symbols
2198         if str(expr.order) != str(expr.default_order):
2199             g = g + ("order=" + str(expr.order),)
2200         pform = self._print_seq(g, '[', ']')
2201         pform = prettyForm(*pform.left(self._print(expr.domain)))
2202 
2203         return pform
2204 
2205     def _print_GroebnerBasis(self, basis):
2206         exprs = [ self._print_Add(arg, order=basis.order)
2207                   for arg in basis.exprs ]
2208         exprs = prettyForm(*self.join(", ", exprs).parens(left="[", right="]"))
2209 
2210         gens = [ self._print(gen) for gen in basis.gens ]
2211 
2212         domain = prettyForm(
2213             *prettyForm("domain=").right(self._print(basis.domain)))
2214         order = prettyForm(
2215             *prettyForm("order=").right(self._print(basis.order)))
2216 
2217         pform = self.join(", ", [exprs] + gens + [domain, order])
2218 
2219         pform = prettyForm(*pform.parens())
2220         pform = prettyForm(*pform.left(basis.__class__.__name__))
2221 
2222         return pform
2223 
2224     def _print_Subs(self, e):
2225         pform = self._print(e.expr)
2226         pform = prettyForm(*pform.parens())
2227 
2228         h = pform.height() if pform.height() > 1 else 2
2229         rvert = stringPict(vobj('|', h), baseline=pform.baseline)
2230         pform = prettyForm(*pform.right(rvert))
2231 
2232         b = pform.baseline
2233         pform.baseline = pform.height() - 1
2234         pform = prettyForm(*pform.right(self._print_seq([
2235             self._print_seq((self._print(v[0]), xsym('=='), self._print(v[1])),
2236                 delimiter='') for v in zip(e.variables, e.point) ])))
2237 
2238         pform.baseline = b
2239         return pform
2240 
2241     def _print_euler(self, e):
2242         pform = prettyForm("E")
2243         arg = self._print(e.args[0])
2244         pform_arg = prettyForm(" "*arg.width())
2245         pform_arg = prettyForm(*pform_arg.below(arg))
2246         pform = prettyForm(*pform.right(pform_arg))
2247         if len(e.args) == 1:
2248             return pform
2249         m, x = e.args
2250         # TODO: copy-pasted from _print_Function: can we do better?
2251         prettyFunc = pform
2252         prettyArgs = prettyForm(*self._print_seq([x]).parens())
2253         pform = prettyForm(
2254             binding=prettyForm.FUNC, *stringPict.next(prettyFunc, prettyArgs))
2255         pform.prettyFunc = prettyFunc
2256         pform.prettyArgs = prettyArgs
2257         return pform
2258 
2259     def _print_catalan(self, e):
2260         pform = prettyForm("C")
2261         arg = self._print(e.args[0])
2262         pform_arg = prettyForm(" "*arg.width())
2263         pform_arg = prettyForm(*pform_arg.below(arg))
2264         pform = prettyForm(*pform.right(pform_arg))
2265         return pform
2266 
2267     def _print_KroneckerDelta(self, e):
2268         pform = self._print(e.args[0])
2269         pform = prettyForm(*pform.right((prettyForm(','))))
2270         pform = prettyForm(*pform.right((self._print(e.args[1]))))
2271         if self._use_unicode:
2272             a = stringPict(pretty_symbol('delta'))
2273         else:
2274             a = stringPict('d')
2275         b = pform
2276         top = stringPict(*b.left(' '*a.width()))
2277         bot = stringPict(*a.right(' '*b.width()))
2278         return prettyForm(binding=prettyForm.POW, *bot.below(top))
2279 
2280     def _print_RandomDomain(self, d):
2281         if hasattr(d, 'as_boolean'):
2282             pform = self._print('Domain: ')
2283             pform = prettyForm(*pform.right(self._print(d.as_boolean())))
2284             return pform
2285         elif hasattr(d, 'set'):
2286             pform = self._print('Domain: ')
2287             pform = prettyForm(*pform.right(self._print(d.symbols)))
2288             pform = prettyForm(*pform.right(self._print(' in ')))
2289             pform = prettyForm(*pform.right(self._print(d.set)))
2290             return pform
2291         elif hasattr(d, 'symbols'):
2292             pform = self._print('Domain on ')
2293             pform = prettyForm(*pform.right(self._print(d.symbols)))
2294             return pform
2295         else:
2296             return self._print(None)
2297 
2298     def _print_DMP(self, p):
2299         try:
2300             if p.ring is not None:
2301                 # TODO incorporate order
2302                 return self._print(p.ring.to_sympy(p))
2303         except SympifyError:
2304             pass
2305         return self._print(repr(p))
2306 
2307     def _print_DMF(self, p):
2308         return self._print_DMP(p)
2309 
2310     def _print_Object(self, object):
2311         return self._print(pretty_symbol(object.name))
2312 
2313     def _print_Morphism(self, morphism):
2314         arrow = xsym("-->")
2315 
2316         domain = self._print(morphism.domain)
2317         codomain = self._print(morphism.codomain)
2318         tail = domain.right(arrow, codomain)[0]
2319 
2320         return prettyForm(tail)
2321 
2322     def _print_NamedMorphism(self, morphism):
2323         pretty_name = self._print(pretty_symbol(morphism.name))
2324         pretty_morphism = self._print_Morphism(morphism)
2325         return prettyForm(pretty_name.right(":", pretty_morphism)[0])
2326 
2327     def _print_IdentityMorphism(self, morphism):
2328         from sympy.categories import NamedMorphism
2329         return self._print_NamedMorphism(
2330             NamedMorphism(morphism.domain, morphism.codomain, "id"))
2331 
2332     def _print_CompositeMorphism(self, morphism):
2333 
2334         circle = xsym(".")
2335 
2336         # All components of the morphism have names and it is thus
2337         # possible to build the name of the composite.
2338         component_names_list = [pretty_symbol(component.name) for
2339                                 component in morphism.components]
2340         component_names_list.reverse()
2341         component_names = circle.join(component_names_list) + ":"
2342 
2343         pretty_name = self._print(component_names)
2344         pretty_morphism = self._print_Morphism(morphism)
2345         return prettyForm(pretty_name.right(pretty_morphism)[0])
2346 
2347     def _print_Category(self, category):
2348         return self._print(pretty_symbol(category.name))
2349 
2350     def _print_Diagram(self, diagram):
2351         if not diagram.premises:
2352             # This is an empty diagram.
2353             return self._print(S.EmptySet)
2354 
2355         pretty_result = self._print(diagram.premises)
2356         if diagram.conclusions:
2357             results_arrow = " %s " % xsym("==>")
2358 
2359             pretty_conclusions = self._print(diagram.conclusions)[0]
2360             pretty_result = pretty_result.right(
2361                 results_arrow, pretty_conclusions)
2362 
2363         return prettyForm(pretty_result[0])
2364 
2365     def _print_DiagramGrid(self, grid):
2366         from sympy.matrices import Matrix
2367         from sympy import Symbol
2368         matrix = Matrix([[grid[i, j] if grid[i, j] else Symbol(" ")
2369                           for j in range(grid.width)]
2370                          for i in range(grid.height)])
2371         return self._print_matrix_contents(matrix)
2372 
2373     def _print_FreeModuleElement(self, m):
2374         # Print as row vector for convenience, for now.
2375         return self._print_seq(m, '[', ']')
2376 
2377     def _print_SubModule(self, M):
2378         return self._print_seq(M.gens, '<', '>')
2379 
2380     def _print_FreeModule(self, M):
2381         return self._print(M.ring)**self._print(M.rank)
2382 
2383     def _print_ModuleImplementedIdeal(self, M):
2384         return self._print_seq([x for [x] in M._module.gens], '<', '>')
2385 
2386     def _print_QuotientRing(self, R):
2387         return self._print(R.ring) / self._print(R.base_ideal)
2388 
2389     def _print_QuotientRingElement(self, R):
2390         return self._print(R.data) + self._print(R.ring.base_ideal)
2391 
2392     def _print_QuotientModuleElement(self, m):
2393         return self._print(m.data) + self._print(m.module.killed_module)
2394 
2395     def _print_QuotientModule(self, M):
2396         return self._print(M.base) / self._print(M.killed_module)
2397 
2398     def _print_MatrixHomomorphism(self, h):
2399         matrix = self._print(h._sympy_matrix())
2400         matrix.baseline = matrix.height() // 2
2401         pform = prettyForm(*matrix.right(' : ', self._print(h.domain),
2402             ' %s> ' % hobj('-', 2), self._print(h.codomain)))
2403         return pform
2404 
2405     def _print_BaseScalarField(self, field):
2406         string = field._coord_sys._names[field._index]
2407         return self._print(pretty_symbol(string))
2408 
2409     def _print_BaseVectorField(self, field):
2410         s = U('PARTIAL DIFFERENTIAL') + '_' + field._coord_sys._names[field._index]
2411         return self._print(pretty_symbol(s))
2412 
2413     def _print_Differential(self, diff):
2414         field = diff._form_field
2415         if hasattr(field, '_coord_sys'):
2416             string = field._coord_sys._names[field._index]
2417             return self._print(u'\N{DOUBLE-STRUCK ITALIC SMALL D} ' + pretty_symbol(string))
2418         else:
2419             pform = self._print(field)
2420             pform = prettyForm(*pform.parens())
2421             return prettyForm(*pform.left(u"\N{DOUBLE-STRUCK ITALIC SMALL D}"))
2422 
2423     def _print_Tr(self, p):
2424         #TODO: Handle indices
2425         pform = self._print(p.args[0])
2426         pform = prettyForm(*pform.left('%s(' % (p.__class__.__name__)))
2427         pform = prettyForm(*pform.right(')'))
2428         return pform
2429 
2430     def _print_primenu(self, e):
2431         pform = self._print(e.args[0])
2432         pform = prettyForm(*pform.parens())
2433         if self._use_unicode:
2434             pform = prettyForm(*pform.left(greek_unicode['nu']))
2435         else:
2436             pform = prettyForm(*pform.left('nu'))
2437         return pform
2438 
2439     def _print_primeomega(self, e):
2440         pform = self._print(e.args[0])
2441         pform = prettyForm(*pform.parens())
2442         if self._use_unicode:
2443             pform = prettyForm(*pform.left(greek_unicode['Omega']))
2444         else:
2445             pform = prettyForm(*pform.left('Omega'))
2446         return pform
2447 
2448     def _print_Quantity(self, e):
2449         if e.name.name == 'degree':
2450             pform = self._print(u"\N{DEGREE SIGN}")
2451             return pform
2452         else:
2453             return self.emptyPrinter(e)
2454 
2455     def _print_AssignmentBase(self, e):
2456 
2457         op = prettyForm(' ' + xsym(e.op) + ' ')
2458 
2459         l = self._print(e.lhs)
2460         r = self._print(e.rhs)
2461         pform = prettyForm(*stringPict.next(l, op, r))
2462         return pform
2463 
2464 
2465 def pretty(expr, **settings):
2466     """Returns a string containing the prettified form of expr.
2467 
2468     For information on keyword arguments see pretty_print function.
2469 
2470     """
2471     pp = PrettyPrinter(settings)
2472 
2473     # XXX: this is an ugly hack, but at least it works
2474     use_unicode = pp._settings['use_unicode']
2475     uflag = pretty_use_unicode(use_unicode)
2476 
2477     try:
2478         return pp.doprint(expr)
2479     finally:
2480         pretty_use_unicode(uflag)
2481 
2482 
2483 def pretty_print(expr, wrap_line=True, num_columns=None, use_unicode=None,
2484                  full_prec="auto", order=None, use_unicode_sqrt_char=True,
2485                  root_notation = True, mat_symbol_style="plain", imaginary_unit="i"):
2486     """Prints expr in pretty form.
2487 
2488     pprint is just a shortcut for this function.
2489 
2490     Parameters
2491     ==========
2492 
2493     expr : expression
2494         The expression to print.
2495 
2496     wrap_line : bool, optional (default=True)
2497         Line wrapping enabled/disabled.
2498 
2499     num_columns : int or None, optional (default=None)
2500         Number of columns before line breaking (default to None which reads
2501         the terminal width), useful when using SymPy without terminal.
2502 
2503     use_unicode : bool or None, optional (default=None)
2504         Use unicode characters, such as the Greek letter pi instead of
2505         the string pi.
2506 
2507     full_prec : bool or string, optional (default="auto")
2508         Use full precision.
2509 
2510     order : bool or string, optional (default=None)
2511         Set to 'none' for long expressions if slow; default is None.
2512 
2513     use_unicode_sqrt_char : bool, optional (default=True)
2514         Use compact single-character square root symbol (when unambiguous).
2515 
2516     root_notation : bool, optional (default=True)
2517         Set to 'False' for printing exponents of the form 1/n in fractional form.
2518         By default exponent is printed in root form.
2519 
2520     mat_symbol_style : string, optional (default="plain")
2521         Set to "bold" for printing MatrixSymbols using a bold mathematical symbol face.
2522         By default the standard face is used.
2523 
2524     imaginary_unit : string, optional (default="i")
2525         Letter to use for imaginary unit when use_unicode is True.
2526         Can be "i" (default) or "j".
2527     """
2528     print(pretty(expr, wrap_line=wrap_line, num_columns=num_columns,
2529                  use_unicode=use_unicode, full_prec=full_prec, order=order,
2530                  use_unicode_sqrt_char=use_unicode_sqrt_char,
2531                  root_notation=root_notation, mat_symbol_style=mat_symbol_style,
2532                  imaginary_unit=imaginary_unit))
2533 
2534 pprint = pretty_print
2535 
2536 
2537 def pager_print(expr, **settings):
2538     """Prints expr using the pager, in pretty form.
2539 
2540     This invokes a pager command using pydoc. Lines are not wrapped
2541     automatically. This routine is meant to be used with a pager that allows
2542     sideways scrolling, like ``less -S``.
2543 
2544     Parameters are the same as for ``pretty_print``. If you wish to wrap lines,
2545     pass ``num_columns=None`` to auto-detect the width of the terminal.
2546 
2547     """
2548     from pydoc import pager
2549     from locale import getpreferredencoding
2550     if 'num_columns' not in settings:
2551         settings['num_columns'] = 500000  # disable line wrap
2552     pager(pretty(expr, **settings).encode(getpreferredencoding()))

</code><intended_behavior>The code within this file responsible for the pretty printing of `Product` instances needs to be modified or enhanced. This could involve adjusting the method(s) that generate the textual representation of mathematical products. Specifically, the modifications should aim to: - Remove the unnecessary empty line at the bottom of the product notation to make the presentation more compact and aligned with mathematical standards. - Adjust the width of the product notation to ensure it does not appear excessively broad ('too fat'), making it more in line with the visual aesthetics of related symbols and expressions. - Optionally extend the top bar of the product notation if such a change does not adversely affect the clarity or consistency of the representation, potentially making the notation more visually appealing and understandable. These adjustments should be carefully implemented to preserve the existing functionality of the pretty printing code, ensuring that all other expressions and symbols continue to be rendered correctly and without unintended modifications.</intended_behavior>]
2025-10-17 20:34:54.175 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 20:34:54.175 | INFO     | Search-only: skipping patch selection
2025-10-17 20:34:54.271 | INFO     | Task sympy__sympy-16281 completed successfully.
2025-10-17 20:34:54.272 | INFO     | No patch generated. You can try running ACR again.
