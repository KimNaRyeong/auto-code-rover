[
    {
        "rel_file_path": "doc/conf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.2/doc/conf.py",
        "start": 1,
        "end": 161,
        "class_name": null,
        "method_name": null,
        "code": "1 # Sphinx documentation build configuration file\n2 \n3 import re\n4 \n5 import sphinx\n6 \n7 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',\n8               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',\n9               'sphinx.ext.intersphinx',\n10               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']\n11 \n12 root_doc = 'contents'\n13 templates_path = ['_templates']\n14 exclude_patterns = ['_build']\n15 \n16 project = 'Sphinx'\n17 copyright = '2007-2021, Georg Brandl and the Sphinx team'\n18 version = sphinx.__display_version__\n19 release = version\n20 show_authors = True\n21 \n22 html_theme = 'sphinx13'\n23 html_theme_path = ['_themes']\n24 modindex_common_prefix = ['sphinx.']\n25 html_static_path = ['_static']\n26 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}\n27 html_title = 'Sphinx documentation'\n28 html_additional_pages = {'index': 'index.html'}\n29 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'\n30 html_baseurl = 'https://www.sphinx-doc.org/en/master/'\n31 html_favicon = '_static/favicon.svg'\n32 \n33 htmlhelp_basename = 'Sphinxdoc'\n34 \n35 epub_theme = 'epub'\n36 epub_basename = 'sphinx'\n37 epub_author = 'Georg Brandl'\n38 epub_publisher = 'https://sphinx-doc.org/'\n39 epub_uid = 'web-site'\n40 epub_scheme = 'url'\n41 epub_identifier = epub_publisher\n42 epub_pre_files = [('index.xhtml', 'Welcome')]\n43 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),\n44                    ('develop.xhtml', 'Sphinx development')]\n45 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',\n46                       '_static/jquery.js', '_static/searchtools.js',\n47                       '_static/underscore.js', '_static/basic.css',\n48                       '_static/language_data.js',\n49                       'search.html', '_static/websupport.js']\n50 epub_fix_images = False\n51 epub_max_image_width = 0\n52 epub_show_urls = 'inline'\n53 epub_use_index = False\n54 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)\n55 epub_description = 'Sphinx documentation generator system manual'\n56 \n57 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',\n58                     'Georg Brandl', 'manual', 1)]\n59 latex_logo = '_static/sphinx.png'\n60 latex_elements = {\n61     'fontenc': r'\\usepackage[LGR,X2,T1]{fontenc}',\n62     'passoptionstopackages': r'''\n63 \\PassOptionsToPackage{svgnames}{xcolor}\n64 ''',\n65     'preamble': r'''\n66 \\DeclareUnicodeCharacter{229E}{\\ensuremath{\\boxplus}}\n67 \\setcounter{tocdepth}{3}%    depth of what main TOC shows (3=subsubsection)\n68 \\setcounter{secnumdepth}{1}% depth of section numbering\n69 ''',\n70     # fix missing index entry due to RTD doing only once pdflatex after makeindex\n71     'printindex': r'''\n72 \\IfFileExists{\\jobname.ind}\n73              {\\footnotesize\\raggedright\\printindex}\n74              {\\begin{sphinxtheindex}\\end{sphinxtheindex}}\n75 ''',\n76 }\n77 latex_show_urls = 'footnote'\n78 latex_use_xindy = True\n79 \n80 autodoc_member_order = 'groupwise'\n81 autosummary_generate = False\n82 todo_include_todos = True\n83 extlinks = {'duref': ('https://docutils.sourceforge.io/docs/ref/rst/'\n84                       'restructuredtext.html#%s', ''),\n85             'durole': ('https://docutils.sourceforge.io/docs/ref/rst/'\n86                        'roles.html#%s', ''),\n87             'dudir': ('https://docutils.sourceforge.io/docs/ref/rst/'\n88                       'directives.html#%s', '')}\n89 \n90 man_pages = [\n91     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',\n92      'Georg Brandl', 1),\n93     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',\n94      '', 1),\n95     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '\n96      'template generator', '', 1),\n97     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',\n98      '', 1),\n99     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',\n100      '', 1),\n101 ]\n102 \n103 texinfo_documents = [\n104     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',\n105      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',\n106      1),\n107 ]\n108 \n109 intersphinx_mapping = {\n110     'python': ('https://docs.python.org/3/', None),\n111     'requests': ('https://requests.readthedocs.io/en/master', None),\n112 }\n113 \n114 # Sphinx document translation with sphinx gettext feature uses these settings:\n115 locale_dirs = ['locale/']\n116 gettext_compact = False\n117 \n118 \n119 # -- Extension interface -------------------------------------------------------\n120 \n121 from sphinx import addnodes  # noqa\n122 \n123 event_sig_re = re.compile(r'([a-zA-Z-]+)\\s*\\((.*)\\)')\n124 \n125 \n126 def parse_event(env, sig, signode):\n127     m = event_sig_re.match(sig)\n128     if not m:\n129         signode += addnodes.desc_name(sig, sig)\n130         return sig\n131     name, args = m.groups()\n132     signode += addnodes.desc_name(name, name)\n133     plist = addnodes.desc_parameterlist()\n134     for arg in args.split(','):\n135         arg = arg.strip()\n136         plist += addnodes.desc_parameter(arg, arg)\n137     signode += plist\n138     return name\n139 \n140 \n141 def setup(app):\n142     from sphinx.ext.autodoc import cut_lines\n143     from sphinx.util.docfields import GroupedField\n144     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n145     app.add_object_type('confval', 'confval',\n146                         objname='configuration value',\n147                         indextemplate='pair: %s; configuration value')\n148     app.add_object_type('setuptools-confval', 'setuptools-confval',\n149                         objname='setuptools configuration value',\n150                         indextemplate='pair: %s; setuptools configuration value')\n151     fdesc = GroupedField('parameter', label='Parameters',\n152                          names=['param'], can_collapse=True)\n153     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,\n154                         doc_field_types=[fdesc])\n155 \n156     # workaround for RTD\n157     from sphinx.util import logging\n158     logger = logging.getLogger(__name__)\n159     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)\n160     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)\n161     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)\n",
        "intended_behavior": "Configure `autodoc` and possibly `autosummary` to recognize and properly document methods decorated with `@classmethod` and `@property`. This may involve setting `autodoc` flags to more aggressively document class attributes or using a custom Sphinx extension to correctly handle these decorators."
    },
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__4.2/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 2784,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import re\n14 import warnings\n15 from inspect import Parameter, Signature\n16 from types import ModuleType\n17 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Sequence,\n18                     Set, Tuple, Type, TypeVar, Union)\n19 \n20 from docutils.statemachine import StringList\n21 \n22 import sphinx\n23 from sphinx.application import Sphinx\n24 from sphinx.config import ENUM, Config\n25 from sphinx.deprecation import RemovedInSphinx50Warning, RemovedInSphinx60Warning\n26 from sphinx.environment import BuildEnvironment\n27 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,\n28                                          import_object)\n29 from sphinx.ext.autodoc.mock import ismock, mock, undecorate\n30 from sphinx.locale import _, __\n31 from sphinx.pycode import ModuleAnalyzer, PycodeError\n32 from sphinx.util import inspect, logging\n33 from sphinx.util.docstrings import prepare_docstring, separate_metadata\n34 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n35                                  stringify_signature)\n36 from sphinx.util.typing import OptionSpec, get_type_hints, restify\n37 from sphinx.util.typing import stringify as stringify_typehint\n38 \n39 if TYPE_CHECKING:\n40     from sphinx.ext.autodoc.directive import DocumenterBridge\n41 \n42 \n43 logger = logging.getLogger(__name__)\n44 \n45 \n46 # This type isn't exposed directly in any modules, but can be found\n47 # here in most Python versions\n48 MethodDescriptorType = type(type.__subclasses__)\n49 \n50 \n51 #: extended signature RE: with explicit module name separated by ::\n52 py_ext_sig_re = re.compile(\n53     r'''^ ([\\w.]+::)?            # explicit module name\n54           ([\\w.]+\\.)?            # module and/or class name(s)\n55           (\\w+)  \\s*             # thing name\n56           (?: \\((.*)\\)           # optional: arguments\n57            (?:\\s* -> \\s* (.*))?  #           return annotation\n58           )? $                   # and nothing more\n59           ''', re.VERBOSE)\n60 special_member_re = re.compile(r'^__\\S+__$')\n61 \n62 \n63 def identity(x: Any) -> Any:\n64     return x\n65 \n66 \n67 class _All:\n68     \"\"\"A special value for :*-members: that matches to any member.\"\"\"\n69 \n70     def __contains__(self, item: Any) -> bool:\n71         return True\n72 \n73     def append(self, item: Any) -> None:\n74         pass  # nothing\n75 \n76 \n77 class _Empty:\n78     \"\"\"A special value for :exclude-members: that never matches to any member.\"\"\"\n79 \n80     def __contains__(self, item: Any) -> bool:\n81         return False\n82 \n83 \n84 ALL = _All()\n85 EMPTY = _Empty()\n86 UNINITIALIZED_ATTR = object()\n87 INSTANCEATTR = object()\n88 SLOTSATTR = object()\n89 \n90 \n91 def members_option(arg: Any) -> Union[object, List[str]]:\n92     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n93     if arg in (None, True):\n94         return ALL\n95     elif arg is False:\n96         return None\n97     else:\n98         return [x.strip() for x in arg.split(',') if x.strip()]\n99 \n100 \n101 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n102     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n103     warnings.warn(\"members_set_option() is deprecated.\",\n104                   RemovedInSphinx50Warning, stacklevel=2)\n105     if arg is None:\n106         return ALL\n107     return {x.strip() for x in arg.split(',') if x.strip()}\n108 \n109 \n110 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n111     \"\"\"Used to convert the :exclude-members: option.\"\"\"\n112     if arg in (None, True):\n113         return EMPTY\n114     return {x.strip() for x in arg.split(',') if x.strip()}\n115 \n116 \n117 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n118     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n119     if arg in (None, True):\n120         return 'object'\n121     else:\n122         return arg\n123 \n124 \n125 def member_order_option(arg: Any) -> Optional[str]:\n126     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n127     if arg in (None, True):\n128         return None\n129     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n130         return arg\n131     else:\n132         raise ValueError(__('invalid value for member-order option: %s') % arg)\n133 \n134 \n135 def class_doc_from_option(arg: Any) -> Optional[str]:\n136     \"\"\"Used to convert the :class-doc-from: option to autoclass directives.\"\"\"\n137     if arg in ('both', 'class', 'init'):\n138         return arg\n139     else:\n140         raise ValueError(__('invalid value for class-doc-from option: %s') % arg)\n141 \n142 \n143 SUPPRESS = object()\n144 \n145 \n146 def annotation_option(arg: Any) -> Any:\n147     if arg in (None, True):\n148         # suppress showing the representation of the object\n149         return SUPPRESS\n150     else:\n151         return arg\n152 \n153 \n154 def bool_option(arg: Any) -> bool:\n155     \"\"\"Used to convert flag options to auto directives.  (Instead of\n156     directives.flag(), which returns None).\n157     \"\"\"\n158     return True\n159 \n160 \n161 def merge_special_members_option(options: Dict) -> None:\n162     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n163     warnings.warn(\"merge_special_members_option() is deprecated.\",\n164                   RemovedInSphinx50Warning, stacklevel=2)\n165     if 'special-members' in options and options['special-members'] is not ALL:\n166         if options.get('members') is ALL:\n167             pass\n168         elif options.get('members'):\n169             for member in options['special-members']:\n170                 if member not in options['members']:\n171                     options['members'].append(member)\n172         else:\n173             options['members'] = options['special-members']\n174 \n175 \n176 def merge_members_option(options: Dict) -> None:\n177     \"\"\"Merge :*-members: option to the :members: option.\"\"\"\n178     if options.get('members') is ALL:\n179         # merging is not needed when members: ALL\n180         return\n181 \n182     members = options.setdefault('members', [])\n183     for key in {'private-members', 'special-members'}:\n184         if key in options and options[key] not in (ALL, None):\n185             for member in options[key]:\n186                 if member not in members:\n187                     members.append(member)\n188 \n189 \n190 # Some useful event listener factories for autodoc-process-docstring.\n191 \n192 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n193     \"\"\"Return a listener that removes the first *pre* and last *post*\n194     lines of every docstring.  If *what* is a sequence of strings,\n195     only docstrings of a type in *what* will be processed.\n196 \n197     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n198 \n199        from sphinx.ext.autodoc import cut_lines\n200        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n201 \n202     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n203     \"\"\"\n204     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n205                 ) -> None:\n206         if what and what_ not in what:\n207             return\n208         del lines[:pre]\n209         if post:\n210             # remove one trailing blank line.\n211             if lines and not lines[-1]:\n212                 lines.pop(-1)\n213             del lines[-post:]\n214         # make sure there is a blank line at the end\n215         if lines and lines[-1]:\n216             lines.append('')\n217     return process\n218 \n219 \n220 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n221             exclude: bool = False) -> Callable:\n222     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n223     lines between lines that match the *marker* regular expression.  If no line\n224     matches, the resulting docstring would be empty, so no change will be made\n225     unless *keepempty* is true.\n226 \n227     If *what* is a sequence of strings, only docstrings of a type in *what* will\n228     be processed.\n229     \"\"\"\n230     marker_re = re.compile(marker)\n231 \n232     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n233                 ) -> None:\n234         if what and what_ not in what:\n235             return\n236         deleted = 0\n237         delete = not exclude\n238         orig_lines = lines[:]\n239         for i, line in enumerate(orig_lines):\n240             if delete:\n241                 lines.pop(i - deleted)\n242                 deleted += 1\n243             if marker_re.match(line):\n244                 delete = not delete\n245                 if delete:\n246                     lines.pop(i - deleted)\n247                     deleted += 1\n248         if not lines and not keepempty:\n249             lines[:] = orig_lines\n250         # make sure there is a blank line at the end\n251         if lines and lines[-1]:\n252             lines.append('')\n253     return process\n254 \n255 \n256 # This class is used only in ``sphinx.ext.autodoc.directive``,\n257 # But we define this class here to keep compatibility (see #4538)\n258 class Options(dict):\n259     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n260     def __getattr__(self, name: str) -> Any:\n261         try:\n262             return self[name.replace('_', '-')]\n263         except KeyError:\n264             return None\n265 \n266 \n267 class ObjectMember(tuple):\n268     \"\"\"A member of object.\n269 \n270     This is used for the result of `Documenter.get_object_members()` to\n271     represent each member of the object.\n272 \n273     .. Note::\n274 \n275        An instance of this class behaves as a tuple of (name, object)\n276        for compatibility to old Sphinx.  The behavior will be dropped\n277        in the future.  Therefore extensions should not use the tuple\n278        interface.\n279     \"\"\"\n280 \n281     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:\n282         return super().__new__(cls, (name, obj))  # type: ignore\n283 \n284     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,\n285                  class_: Any = None, skipped: bool = False) -> None:\n286         self.__name__ = name\n287         self.object = obj\n288         self.docstring = docstring\n289         self.skipped = skipped\n290         self.class_ = class_\n291 \n292 \n293 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n294 \n295 \n296 class Documenter:\n297     \"\"\"\n298     A Documenter knows how to autodocument a single object type.  When\n299     registered with the AutoDirective, it will be used to document objects\n300     of that type when needed by autodoc.\n301 \n302     Its *objtype* attribute selects what auto directive it is assigned to\n303     (the directive name is 'auto' + objtype), and what directive it generates\n304     by default, though that can be overridden by an attribute called\n305     *directivetype*.\n306 \n307     A Documenter has an *option_spec* that works like a docutils directive's;\n308     in fact, it will be used to parse an auto directive's options that matches\n309     the documenter.\n310     \"\"\"\n311     #: name by which the directive is called (auto...) and the default\n312     #: generated directive name\n313     objtype = 'object'\n314     #: indentation by which to indent the directive content\n315     content_indent = '   '\n316     #: priority if multiple documenters return True from can_document_member\n317     priority = 0\n318     #: order if autodoc_member_order is set to 'groupwise'\n319     member_order = 0\n320     #: true if the generated content may contain titles\n321     titles_allowed = False\n322 \n323     option_spec: OptionSpec = {\n324         'noindex': bool_option\n325     }\n326 \n327     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n328         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n329         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n330 \n331     @classmethod\n332     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n333                             ) -> bool:\n334         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n335         raise NotImplementedError('must be implemented in subclasses')\n336 \n337     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n338         self.directive = directive\n339         self.config: Config = directive.env.config\n340         self.env: BuildEnvironment = directive.env\n341         self.options = directive.genopt\n342         self.name = name\n343         self.indent = indent\n344         # the module and object path within the module, and the fully\n345         # qualified name (all set after resolve_name succeeds)\n346         self.modname: str = None\n347         self.module: ModuleType = None\n348         self.objpath: List[str] = None\n349         self.fullname: str = None\n350         # extra signature items (arguments and return annotation,\n351         # also set after resolve_name succeeds)\n352         self.args: str = None\n353         self.retann: str = None\n354         # the object to document (set after import_object succeeds)\n355         self.object: Any = None\n356         self.object_name: str = None\n357         # the parent/owner of the object to document\n358         self.parent: Any = None\n359         # the module analyzer to get at attribute docs, or None\n360         self.analyzer: ModuleAnalyzer = None\n361 \n362     @property\n363     def documenters(self) -> Dict[str, Type[\"Documenter\"]]:\n364         \"\"\"Returns registered Documenter classes\"\"\"\n365         return self.env.app.registry.documenters\n366 \n367     def add_line(self, line: str, source: str, *lineno: int) -> None:\n368         \"\"\"Append one line of generated reST to the output.\"\"\"\n369         if line.strip():  # not a blank line\n370             self.directive.result.append(self.indent + line, source, *lineno)\n371         else:\n372             self.directive.result.append('', source, *lineno)\n373 \n374     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n375                      ) -> Tuple[str, List[str]]:\n376         \"\"\"Resolve the module and name of the object to document given by the\n377         arguments and the current module/class.\n378 \n379         Must return a pair of the module name and a chain of attributes; for\n380         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n381         ``zipfile.ZipFile.open`` method.\n382         \"\"\"\n383         raise NotImplementedError('must be implemented in subclasses')\n384 \n385     def parse_name(self) -> bool:\n386         \"\"\"Determine what module to import and what attribute to document.\n387 \n388         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n389         *self.args* and *self.retann* if parsing and resolving was successful.\n390         \"\"\"\n391         # first, parse the definition -- auto directives for classes and\n392         # functions can contain a signature which is then used instead of\n393         # an autogenerated one\n394         try:\n395             matched = py_ext_sig_re.match(self.name)\n396             explicit_modname, path, base, args, retann = matched.groups()\n397         except AttributeError:\n398             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n399                            type='autodoc')\n400             return False\n401 \n402         # support explicit module and class name separation via ::\n403         if explicit_modname is not None:\n404             modname = explicit_modname[:-2]\n405             parents = path.rstrip('.').split('.') if path else []\n406         else:\n407             modname = None\n408             parents = []\n409 \n410         with mock(self.config.autodoc_mock_imports):\n411             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n412 \n413         if not self.modname:\n414             return False\n415 \n416         self.args = args\n417         self.retann = retann\n418         self.fullname = ((self.modname or '') +\n419                          ('.' + '.'.join(self.objpath) if self.objpath else ''))\n420         return True\n421 \n422     def import_object(self, raiseerror: bool = False) -> bool:\n423         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n424         it as *self.object*.\n425 \n426         Returns True if successful, False if an error occurred.\n427         \"\"\"\n428         with mock(self.config.autodoc_mock_imports):\n429             try:\n430                 ret = import_object(self.modname, self.objpath, self.objtype,\n431                                     attrgetter=self.get_attr,\n432                                     warningiserror=self.config.autodoc_warningiserror)\n433                 self.module, self.parent, self.object_name, self.object = ret\n434                 if ismock(self.object):\n435                     self.object = undecorate(self.object)\n436                 return True\n437             except ImportError as exc:\n438                 if raiseerror:\n439                     raise\n440                 else:\n441                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n442                     self.env.note_reread()\n443                     return False\n444 \n445     def get_real_modname(self) -> str:\n446         \"\"\"Get the real module name of an object to document.\n447 \n448         It can differ from the name of the module through which the object was\n449         imported.\n450         \"\"\"\n451         return self.get_attr(self.object, '__module__', None) or self.modname\n452 \n453     def check_module(self) -> bool:\n454         \"\"\"Check if *self.object* is really defined in the module given by\n455         *self.modname*.\n456         \"\"\"\n457         if self.options.imported_members:\n458             return True\n459 \n460         subject = inspect.unpartial(self.object)\n461         modname = self.get_attr(subject, '__module__', None)\n462         if modname and modname != self.modname:\n463             return False\n464         return True\n465 \n466     def format_args(self, **kwargs: Any) -> str:\n467         \"\"\"Format the argument signature of *self.object*.\n468 \n469         Should return None if the object does not have a signature.\n470         \"\"\"\n471         return None\n472 \n473     def format_name(self) -> str:\n474         \"\"\"Format the name of *self.object*.\n475 \n476         This normally should be something that can be parsed by the generated\n477         directive, but doesn't need to be (Sphinx will display it unparsed\n478         then).\n479         \"\"\"\n480         # normally the name doesn't contain the module (except for module\n481         # directives of course)\n482         return '.'.join(self.objpath) or self.modname\n483 \n484     def _call_format_args(self, **kwargs: Any) -> str:\n485         if kwargs:\n486             try:\n487                 return self.format_args(**kwargs)\n488             except TypeError:\n489                 # avoid chaining exceptions, by putting nothing here\n490                 pass\n491 \n492         # retry without arguments for old documenters\n493         return self.format_args()\n494 \n495     def format_signature(self, **kwargs: Any) -> str:\n496         \"\"\"Format the signature (arguments and return annotation) of the object.\n497 \n498         Let the user process it via the ``autodoc-process-signature`` event.\n499         \"\"\"\n500         if self.args is not None:\n501             # signature given explicitly\n502             args = \"(%s)\" % self.args\n503             retann = self.retann\n504         else:\n505             # try to introspect the signature\n506             try:\n507                 retann = None\n508                 args = self._call_format_args(**kwargs)\n509                 if args:\n510                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n511                     if matched:\n512                         args = matched.group(1)\n513                         retann = matched.group(2)\n514             except Exception as exc:\n515                 logger.warning(__('error while formatting arguments for %s: %s'),\n516                                self.fullname, exc, type='autodoc')\n517                 args = None\n518 \n519         result = self.env.events.emit_firstresult('autodoc-process-signature',\n520                                                   self.objtype, self.fullname,\n521                                                   self.object, self.options, args, retann)\n522         if result:\n523             args, retann = result\n524 \n525         if args is not None:\n526             return args + ((' -> %s' % retann) if retann else '')\n527         else:\n528             return ''\n529 \n530     def add_directive_header(self, sig: str) -> None:\n531         \"\"\"Add the directive header and options to the generated content.\"\"\"\n532         domain = getattr(self, 'domain', 'py')\n533         directive = getattr(self, 'directivetype', self.objtype)\n534         name = self.format_name()\n535         sourcename = self.get_sourcename()\n536 \n537         # one signature per line, indented by column\n538         prefix = '.. %s:%s:: ' % (domain, directive)\n539         for i, sig_line in enumerate(sig.split(\"\\n\")):\n540             self.add_line('%s%s%s' % (prefix, name, sig_line),\n541                           sourcename)\n542             if i == 0:\n543                 prefix = \" \" * len(prefix)\n544 \n545         if self.options.noindex:\n546             self.add_line('   :noindex:', sourcename)\n547         if self.objpath:\n548             # Be explicit about the module, this is necessary since .. class::\n549             # etc. don't support a prepended module name\n550             self.add_line('   :module: %s' % self.modname, sourcename)\n551 \n552     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n553         \"\"\"Decode and return lines of the docstring(s) for the object.\n554 \n555         When it returns None value, autodoc-process-docstring will not be called for this\n556         object.\n557         \"\"\"\n558         if ignore is not None:\n559             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n560                           % self.__class__.__name__,\n561                           RemovedInSphinx50Warning, stacklevel=2)\n562         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n563                            self.parent, self.object_name)\n564         if docstring:\n565             tab_width = self.directive.state.document.settings.tab_width\n566             return [prepare_docstring(docstring, ignore, tab_width)]\n567         return []\n568 \n569     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n570         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n571         for docstringlines in docstrings:\n572             if self.env.app:\n573                 # let extensions preprocess docstrings\n574                 self.env.app.emit('autodoc-process-docstring',\n575                                   self.objtype, self.fullname, self.object,\n576                                   self.options, docstringlines)\n577 \n578                 if docstringlines and docstringlines[-1] != '':\n579                     # append a blank line to the end of the docstring\n580                     docstringlines.append('')\n581 \n582             yield from docstringlines\n583 \n584     def get_sourcename(self) -> str:\n585         if (getattr(self.object, '__module__', None) and\n586                 getattr(self.object, '__qualname__', None)):\n587             # Get the correct location of docstring from self.object\n588             # to support inherited methods\n589             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)\n590         else:\n591             fullname = self.fullname\n592 \n593         if self.analyzer:\n594             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)\n595         else:\n596             return 'docstring of %s' % fullname\n597 \n598     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n599                     ) -> None:\n600         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n601         if no_docstring:\n602             warnings.warn(\"The 'no_docstring' argument to %s.add_content() is deprecated.\"\n603                           % self.__class__.__name__,\n604                           RemovedInSphinx50Warning, stacklevel=2)\n605 \n606         # set sourcename and add content from attribute documentation\n607         sourcename = self.get_sourcename()\n608         if self.analyzer:\n609             attr_docs = self.analyzer.find_attr_docs()\n610             if self.objpath:\n611                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n612                 if key in attr_docs:\n613                     no_docstring = True\n614                     # make a copy of docstring for attributes to avoid cache\n615                     # the change of autodoc-process-docstring event.\n616                     docstrings = [list(attr_docs[key])]\n617 \n618                     for i, line in enumerate(self.process_doc(docstrings)):\n619                         self.add_line(line, sourcename, i)\n620 \n621         # add content from docstrings\n622         if not no_docstring:\n623             docstrings = self.get_doc()\n624             if docstrings is None:\n625                 # Do not call autodoc-process-docstring on get_doc() returns None.\n626                 pass\n627             else:\n628                 if not docstrings:\n629                     # append at least a dummy docstring, so that the event\n630                     # autodoc-process-docstring is fired and can add some\n631                     # content if desired\n632                     docstrings.append([])\n633                 for i, line in enumerate(self.process_doc(docstrings)):\n634                     self.add_line(line, sourcename, i)\n635 \n636         # add additional content (e.g. from document), if present\n637         if more_content:\n638             for line, src in zip(more_content.data, more_content.items):\n639                 self.add_line(line, src[0], src[1])\n640 \n641     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n642         \"\"\"Return `(members_check_module, members)` where `members` is a\n643         list of `(membername, member)` pairs of the members of *self.object*.\n644 \n645         If *want_all* is True, return all members.  Else, only return those\n646         members given by *self.options.members* (which may also be none).\n647         \"\"\"\n648         warnings.warn('The implementation of Documenter.get_object_members() will be '\n649                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)\n650         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n651         if not want_all:\n652             if not self.options.members:\n653                 return False, []  # type: ignore\n654             # specific members given\n655             selected = []\n656             for name in self.options.members:  # type: str\n657                 if name in members:\n658                     selected.append((name, members[name].value))\n659                 else:\n660                     logger.warning(__('missing attribute %s in object %s') %\n661                                    (name, self.fullname), type='autodoc')\n662             return False, selected\n663         elif self.options.inherited_members:\n664             return False, [(m.name, m.value) for m in members.values()]\n665         else:\n666             return False, [(m.name, m.value) for m in members.values()\n667                            if m.directly_defined]\n668 \n669     def filter_members(self, members: ObjectMembers, want_all: bool\n670                        ) -> List[Tuple[str, Any, bool]]:\n671         \"\"\"Filter the given member list.\n672 \n673         Members are skipped if\n674 \n675         - they are private (except if given explicitly or the private-members\n676           option is set)\n677         - they are special methods (except if given explicitly or the\n678           special-members option is set)\n679         - they are undocumented (except if the undoc-members option is set)\n680 \n681         The user can override the skipping decision by connecting to the\n682         ``autodoc-skip-member`` event.\n683         \"\"\"\n684         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n685             if inspect.isclass(self.object):\n686                 for cls in self.object.__mro__:\n687                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n688                         # given member is a member of specified *super class*\n689                         return True\n690                     elif name in cls.__dict__:\n691                         return False\n692                     elif name in self.get_attr(cls, '__annotations__', {}):\n693                         return False\n694                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n695                         return False\n696 \n697             return False\n698 \n699         ret = []\n700 \n701         # search for members in source code too\n702         namespace = '.'.join(self.objpath)  # will be empty for modules\n703 \n704         if self.analyzer:\n705             attr_docs = self.analyzer.find_attr_docs()\n706         else:\n707             attr_docs = {}\n708 \n709         # process members and determine which to skip\n710         for obj in members:\n711             membername, member = obj\n712             # if isattr is True, the member is documented as an attribute\n713             if member is INSTANCEATTR:\n714                 isattr = True\n715             elif (namespace, membername) in attr_docs:\n716                 isattr = True\n717             else:\n718                 isattr = False\n719 \n720             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n721                          self.parent, self.object_name)\n722             if not isinstance(doc, str):\n723                 # Ignore non-string __doc__\n724                 doc = None\n725 \n726             # if the member __doc__ is the same as self's __doc__, it's just\n727             # inherited and therefore not the member's doc\n728             cls = self.get_attr(member, '__class__', None)\n729             if cls:\n730                 cls_doc = self.get_attr(cls, '__doc__', None)\n731                 if cls_doc == doc:\n732                     doc = None\n733 \n734             if isinstance(obj, ObjectMember) and obj.docstring:\n735                 # hack for ClassDocumenter to inject docstring via ObjectMember\n736                 doc = obj.docstring\n737 \n738             doc, metadata = separate_metadata(doc)\n739             has_doc = bool(doc)\n740 \n741             if 'private' in metadata:\n742                 # consider a member private if docstring has \"private\" metadata\n743                 isprivate = True\n744             elif 'public' in metadata:\n745                 # consider a member public if docstring has \"public\" metadata\n746                 isprivate = False\n747             else:\n748                 isprivate = membername.startswith('_')\n749 \n750             keep = False\n751             if ismock(member):\n752                 # mocked module or object\n753                 pass\n754             elif self.options.exclude_members and membername in self.options.exclude_members:\n755                 # remove members given by exclude-members\n756                 keep = False\n757             elif want_all and special_member_re.match(membername):\n758                 # special __methods__\n759                 if self.options.special_members and membername in self.options.special_members:\n760                     if membername == '__doc__':\n761                         keep = False\n762                     elif is_filtered_inherited_member(membername, obj):\n763                         keep = False\n764                     else:\n765                         keep = has_doc or self.options.undoc_members\n766                 else:\n767                     keep = False\n768             elif (namespace, membername) in attr_docs:\n769                 if want_all and isprivate:\n770                     if self.options.private_members is None:\n771                         keep = False\n772                     else:\n773                         keep = membername in self.options.private_members\n774                 else:\n775                     # keep documented attributes\n776                     keep = True\n777             elif want_all and isprivate:\n778                 if has_doc or self.options.undoc_members:\n779                     if self.options.private_members is None:\n780                         keep = False\n781                     elif is_filtered_inherited_member(membername, obj):\n782                         keep = False\n783                     else:\n784                         keep = membername in self.options.private_members\n785                 else:\n786                     keep = False\n787             else:\n788                 if (self.options.members is ALL and\n789                         is_filtered_inherited_member(membername, obj)):\n790                     keep = False\n791                 else:\n792                     # ignore undocumented members if :undoc-members: is not given\n793                     keep = has_doc or self.options.undoc_members\n794 \n795             if isinstance(obj, ObjectMember) and obj.skipped:\n796                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n797                 keep = False\n798 \n799             # give the user a chance to decide whether this member\n800             # should be skipped\n801             if self.env.app:\n802                 # let extensions preprocess docstrings\n803                 try:\n804                     skip_user = self.env.app.emit_firstresult(\n805                         'autodoc-skip-member', self.objtype, membername, member,\n806                         not keep, self.options)\n807                     if skip_user is not None:\n808                         keep = not skip_user\n809                 except Exception as exc:\n810                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n811                                       'the following exception was raised:\\n%s'),\n812                                    member, exc, type='autodoc')\n813                     keep = False\n814 \n815             if keep:\n816                 ret.append((membername, member, isattr))\n817 \n818         return ret\n819 \n820     def document_members(self, all_members: bool = False) -> None:\n821         \"\"\"Generate reST for member documentation.\n822 \n823         If *all_members* is True, do all members, else those given by\n824         *self.options.members*.\n825         \"\"\"\n826         # set current namespace for finding members\n827         self.env.temp_data['autodoc:module'] = self.modname\n828         if self.objpath:\n829             self.env.temp_data['autodoc:class'] = self.objpath[0]\n830 \n831         want_all = (all_members or\n832                     self.options.inherited_members or\n833                     self.options.members is ALL)\n834         # find out which members are documentable\n835         members_check_module, members = self.get_object_members(want_all)\n836 \n837         # document non-skipped members\n838         memberdocumenters: List[Tuple[Documenter, bool]] = []\n839         for (mname, member, isattr) in self.filter_members(members, want_all):\n840             classes = [cls for cls in self.documenters.values()\n841                        if cls.can_document_member(member, mname, isattr, self)]\n842             if not classes:\n843                 # don't know how to document this member\n844                 continue\n845             # prefer the documenter with the highest priority\n846             classes.sort(key=lambda cls: cls.priority)\n847             # give explicitly separated module name, so that members\n848             # of inner classes can be documented\n849             full_mname = self.modname + '::' + '.'.join(self.objpath + [mname])\n850             documenter = classes[-1](self.directive, full_mname, self.indent)\n851             memberdocumenters.append((documenter, isattr))\n852 \n853         member_order = self.options.member_order or self.config.autodoc_member_order\n854         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n855 \n856         for documenter, isattr in memberdocumenters:\n857             documenter.generate(\n858                 all_members=True, real_modname=self.real_modname,\n859                 check_module=members_check_module and not isattr)\n860 \n861         # reset current objects\n862         self.env.temp_data['autodoc:module'] = None\n863         self.env.temp_data['autodoc:class'] = None\n864 \n865     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n866                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n867         \"\"\"Sort the given member list.\"\"\"\n868         if order == 'groupwise':\n869             # sort by group; alphabetically within groups\n870             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n871         elif order == 'bysource':\n872             if self.analyzer:\n873                 # sort by source order, by virtue of the module analyzer\n874                 tagorder = self.analyzer.tagorder\n875 \n876                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n877                     fullname = entry[0].name.split('::')[1]\n878                     return tagorder.get(fullname, len(tagorder))\n879                 documenters.sort(key=keyfunc)\n880             else:\n881                 # Assume that member discovery order matches source order.\n882                 # This is a reasonable assumption in Python 3.6 and up, where\n883                 # module.__dict__ is insertion-ordered.\n884                 pass\n885         else:  # alphabetical\n886             documenters.sort(key=lambda e: e[0].name)\n887 \n888         return documenters\n889 \n890     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n891                  check_module: bool = False, all_members: bool = False) -> None:\n892         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n893         its members.\n894 \n895         If *more_content* is given, include that content. If *real_modname* is\n896         given, use that module name to find attribute docs. If *check_module* is\n897         True, only generate if the object is defined in the module name it is\n898         imported from. If *all_members* is True, document all members.\n899         \"\"\"\n900         if not self.parse_name():\n901             # need a module to import\n902             logger.warning(\n903                 __('don\\'t know which module to import for autodocumenting '\n904                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n905                    'in the document, or giving an explicit module name)') %\n906                 self.name, type='autodoc')\n907             return\n908 \n909         # now, import the module and get object to document\n910         if not self.import_object():\n911             return\n912 \n913         # If there is no real module defined, figure out which to use.\n914         # The real module is used in the module analyzer to look up the module\n915         # where the attribute documentation would actually be found in.\n916         # This is used for situations where you have a module that collects the\n917         # functions and classes of internal submodules.\n918         guess_modname = self.get_real_modname()\n919         self.real_modname: str = real_modname or guess_modname\n920 \n921         # try to also get a source code analyzer for attribute docs\n922         try:\n923             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n924             # parse right now, to get PycodeErrors on parsing (results will\n925             # be cached anyway)\n926             self.analyzer.find_attr_docs()\n927         except PycodeError as exc:\n928             logger.debug('[autodoc] module analyzer failed: %s', exc)\n929             # no source file -- e.g. for builtin and C modules\n930             self.analyzer = None\n931             # at least add the module.__file__ as a dependency\n932             if hasattr(self.module, '__file__') and self.module.__file__:\n933                 self.directive.record_dependencies.add(self.module.__file__)\n934         else:\n935             self.directive.record_dependencies.add(self.analyzer.srcname)\n936 \n937         if self.real_modname != guess_modname:\n938             # Add module to dependency list if target object is defined in other module.\n939             try:\n940                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n941                 self.directive.record_dependencies.add(analyzer.srcname)\n942             except PycodeError:\n943                 pass\n944 \n945         # check __module__ of object (for members not given explicitly)\n946         if check_module:\n947             if not self.check_module():\n948                 return\n949 \n950         sourcename = self.get_sourcename()\n951 \n952         # make sure that the result starts with an empty line.  This is\n953         # necessary for some situations where another directive preprocesses\n954         # reST and no starting newline is present\n955         self.add_line('', sourcename)\n956 \n957         # format the object's signature, if any\n958         try:\n959             sig = self.format_signature()\n960         except Exception as exc:\n961             logger.warning(__('error while formatting signature for %s: %s'),\n962                            self.fullname, exc, type='autodoc')\n963             return\n964 \n965         # generate the directive header and options, if applicable\n966         self.add_directive_header(sig)\n967         self.add_line('', sourcename)\n968 \n969         # e.g. the module directive doesn't have content\n970         self.indent += self.content_indent\n971 \n972         # add all content (from docstrings, attribute docs etc.)\n973         self.add_content(more_content)\n974 \n975         # document members, if possible\n976         self.document_members(all_members)\n977 \n978 \n979 class ModuleDocumenter(Documenter):\n980     \"\"\"\n981     Specialized Documenter subclass for modules.\n982     \"\"\"\n983     objtype = 'module'\n984     content_indent = ''\n985     titles_allowed = True\n986 \n987     option_spec: OptionSpec = {\n988         'members': members_option, 'undoc-members': bool_option,\n989         'noindex': bool_option, 'inherited-members': inherited_members_option,\n990         'show-inheritance': bool_option, 'synopsis': identity,\n991         'platform': identity, 'deprecated': bool_option,\n992         'member-order': member_order_option, 'exclude-members': exclude_members_option,\n993         'private-members': members_option, 'special-members': members_option,\n994         'imported-members': bool_option, 'ignore-module-all': bool_option\n995     }\n996 \n997     def __init__(self, *args: Any) -> None:\n998         super().__init__(*args)\n999         merge_members_option(self.options)\n1000         self.__all__: Optional[Sequence[str]] = None\n1001 \n1002     @classmethod\n1003     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1004                             ) -> bool:\n1005         # don't document submodules automatically\n1006         return False\n1007 \n1008     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1009                      ) -> Tuple[str, List[str]]:\n1010         if modname is not None:\n1011             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n1012                            type='autodoc')\n1013         return (path or '') + base, []\n1014 \n1015     def parse_name(self) -> bool:\n1016         ret = super().parse_name()\n1017         if self.args or self.retann:\n1018             logger.warning(__('signature arguments or return annotation '\n1019                               'given for automodule %s') % self.fullname,\n1020                            type='autodoc')\n1021         return ret\n1022 \n1023     def import_object(self, raiseerror: bool = False) -> bool:\n1024         ret = super().import_object(raiseerror)\n1025 \n1026         try:\n1027             if not self.options.ignore_module_all:\n1028                 self.__all__ = inspect.getall(self.object)\n1029         except ValueError as exc:\n1030             # invalid __all__ found.\n1031             logger.warning(__('__all__ should be a list of strings, not %r '\n1032                               '(in module %s) -- ignoring __all__') %\n1033                            (exc.args[0], self.fullname), type='autodoc')\n1034 \n1035         return ret\n1036 \n1037     def add_directive_header(self, sig: str) -> None:\n1038         Documenter.add_directive_header(self, sig)\n1039 \n1040         sourcename = self.get_sourcename()\n1041 \n1042         # add some module-specific options\n1043         if self.options.synopsis:\n1044             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n1045         if self.options.platform:\n1046             self.add_line('   :platform: ' + self.options.platform, sourcename)\n1047         if self.options.deprecated:\n1048             self.add_line('   :deprecated:', sourcename)\n1049 \n1050     def get_module_members(self) -> Dict[str, ObjectMember]:\n1051         \"\"\"Get members of target module.\"\"\"\n1052         if self.analyzer:\n1053             attr_docs = self.analyzer.attr_docs\n1054         else:\n1055             attr_docs = {}\n1056 \n1057         members: Dict[str, ObjectMember] = {}\n1058         for name in dir(self.object):\n1059             try:\n1060                 value = safe_getattr(self.object, name, None)\n1061                 if ismock(value):\n1062                     value = undecorate(value)\n1063                 docstring = attr_docs.get(('', name), [])\n1064                 members[name] = ObjectMember(name, value, docstring=\"\\n\".join(docstring))\n1065             except AttributeError:\n1066                 continue\n1067 \n1068         # annotation only member (ex. attr: int)\n1069         for name in inspect.getannotations(self.object):\n1070             if name not in members:\n1071                 docstring = attr_docs.get(('', name), [])\n1072                 members[name] = ObjectMember(name, INSTANCEATTR,\n1073                                              docstring=\"\\n\".join(docstring))\n1074 \n1075         return members\n1076 \n1077     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1078         members = self.get_module_members()\n1079         if want_all:\n1080             if self.__all__ is None:\n1081                 # for implicit module members, check __module__ to avoid\n1082                 # documenting imported objects\n1083                 return True, list(members.values())\n1084             else:\n1085                 for member in members.values():\n1086                     if member.__name__ not in self.__all__:\n1087                         member.skipped = True\n1088 \n1089                 return False, list(members.values())\n1090         else:\n1091             memberlist = self.options.members or []\n1092             ret = []\n1093             for name in memberlist:\n1094                 if name in members:\n1095                     ret.append(members[name])\n1096                 else:\n1097                     logger.warning(__('missing attribute mentioned in :members: option: '\n1098                                       'module %s, attribute %s') %\n1099                                    (safe_getattr(self.object, '__name__', '???'), name),\n1100                                    type='autodoc')\n1101             return False, ret\n1102 \n1103     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n1104                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n1105         if order == 'bysource' and self.__all__:\n1106             # Sort alphabetically first (for members not listed on the __all__)\n1107             documenters.sort(key=lambda e: e[0].name)\n1108 \n1109             # Sort by __all__\n1110             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n1111                 name = entry[0].name.split('::')[1]\n1112                 if self.__all__ and name in self.__all__:\n1113                     return self.__all__.index(name)\n1114                 else:\n1115                     return len(self.__all__)\n1116             documenters.sort(key=keyfunc)\n1117 \n1118             return documenters\n1119         else:\n1120             return super().sort_members(documenters, order)\n1121 \n1122 \n1123 class ModuleLevelDocumenter(Documenter):\n1124     \"\"\"\n1125     Specialized Documenter subclass for objects on module level (functions,\n1126     classes, data/constants).\n1127     \"\"\"\n1128     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1129                      ) -> Tuple[str, List[str]]:\n1130         if modname is None:\n1131             if path:\n1132                 modname = path.rstrip('.')\n1133             else:\n1134                 # if documenting a toplevel object without explicit module,\n1135                 # it can be contained in another auto directive ...\n1136                 modname = self.env.temp_data.get('autodoc:module')\n1137                 # ... or in the scope of a module directive\n1138                 if not modname:\n1139                     modname = self.env.ref_context.get('py:module')\n1140                 # ... else, it stays None, which means invalid\n1141         return modname, parents + [base]\n1142 \n1143 \n1144 class ClassLevelDocumenter(Documenter):\n1145     \"\"\"\n1146     Specialized Documenter subclass for objects on class level (methods,\n1147     attributes).\n1148     \"\"\"\n1149     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1150                      ) -> Tuple[str, List[str]]:\n1151         if modname is None:\n1152             if path:\n1153                 mod_cls = path.rstrip('.')\n1154             else:\n1155                 mod_cls = None\n1156                 # if documenting a class-level object without path,\n1157                 # there must be a current class, either from a parent\n1158                 # auto directive ...\n1159                 mod_cls = self.env.temp_data.get('autodoc:class')\n1160                 # ... or from a class directive\n1161                 if mod_cls is None:\n1162                     mod_cls = self.env.ref_context.get('py:class')\n1163                 # ... if still None, there's no way to know\n1164                 if mod_cls is None:\n1165                     return None, []\n1166             modname, sep, cls = mod_cls.rpartition('.')\n1167             parents = [cls]\n1168             # if the module name is still missing, get it like above\n1169             if not modname:\n1170                 modname = self.env.temp_data.get('autodoc:module')\n1171             if not modname:\n1172                 modname = self.env.ref_context.get('py:module')\n1173             # ... else, it stays None, which means invalid\n1174         return modname, parents + [base]\n1175 \n1176 \n1177 class DocstringSignatureMixin:\n1178     \"\"\"\n1179     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1180     feature of reading the signature from the docstring.\n1181     \"\"\"\n1182     _new_docstrings: List[List[str]] = None\n1183     _signatures: List[str] = None\n1184 \n1185     def _find_signature(self) -> Tuple[str, str]:\n1186         # candidates of the object name\n1187         valid_names = [self.objpath[-1]]  # type: ignore\n1188         if isinstance(self, ClassDocumenter):\n1189             valid_names.append('__init__')\n1190             if hasattr(self.object, '__mro__'):\n1191                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1192 \n1193         docstrings = self.get_doc()\n1194         if docstrings is None:\n1195             return None, None\n1196         self._new_docstrings = docstrings[:]\n1197         self._signatures = []\n1198         result = None\n1199         for i, doclines in enumerate(docstrings):\n1200             for j, line in enumerate(doclines):\n1201                 if not line:\n1202                     # no lines in docstring, no match\n1203                     break\n1204 \n1205                 if line.endswith('\\\\'):\n1206                     line = line.rstrip('\\\\').rstrip()\n1207 \n1208                 # match first line of docstring against signature RE\n1209                 match = py_ext_sig_re.match(line)\n1210                 if not match:\n1211                     break\n1212                 exmod, path, base, args, retann = match.groups()\n1213 \n1214                 # the base name must match ours\n1215                 if base not in valid_names:\n1216                     break\n1217 \n1218                 # re-prepare docstring to ignore more leading indentation\n1219                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1220                 self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n1221                                                             tabsize=tab_width)\n1222 \n1223                 if result is None:\n1224                     # first signature\n1225                     result = args, retann\n1226                 else:\n1227                     # subsequent signatures\n1228                     self._signatures.append(\"(%s) -> %s\" % (args, retann))\n1229 \n1230             if result:\n1231                 # finish the loop when signature found\n1232                 break\n1233 \n1234         return result\n1235 \n1236     def get_doc(self, ignore: int = None) -> List[List[str]]:\n1237         if self._new_docstrings is not None:\n1238             return self._new_docstrings\n1239         return super().get_doc(ignore)  # type: ignore\n1240 \n1241     def format_signature(self, **kwargs: Any) -> str:\n1242         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1243             # only act if a signature is not explicitly given already, and if\n1244             # the feature is enabled\n1245             result = self._find_signature()\n1246             if result is not None:\n1247                 self.args, self.retann = result\n1248         sig = super().format_signature(**kwargs)  # type: ignore\n1249         if self._signatures:\n1250             return \"\\n\".join([sig] + self._signatures)\n1251         else:\n1252             return sig\n1253 \n1254 \n1255 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1256     \"\"\"\n1257     Mixin for AttributeDocumenter to provide the\n1258     feature of stripping any function signature from the docstring.\n1259     \"\"\"\n1260     def format_signature(self, **kwargs: Any) -> str:\n1261         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1262             # only act if a signature is not explicitly given already, and if\n1263             # the feature is enabled\n1264             result = self._find_signature()\n1265             if result is not None:\n1266                 # Discarding _args is a only difference with\n1267                 # DocstringSignatureMixin.format_signature.\n1268                 # Documenter.format_signature use self.args value to format.\n1269                 _args, self.retann = result\n1270         return super().format_signature(**kwargs)\n1271 \n1272 \n1273 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1274     \"\"\"\n1275     Specialized Documenter subclass for functions.\n1276     \"\"\"\n1277     objtype = 'function'\n1278     member_order = 30\n1279 \n1280     @classmethod\n1281     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1282                             ) -> bool:\n1283         # supports functions, builtins and bound methods exported at the module level\n1284         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1285                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1286 \n1287     def format_args(self, **kwargs: Any) -> str:\n1288         if self.config.autodoc_typehints in ('none', 'description'):\n1289             kwargs.setdefault('show_annotation', False)\n1290 \n1291         try:\n1292             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1293             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n1294             args = stringify_signature(sig, **kwargs)\n1295         except TypeError as exc:\n1296             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1297                            self.fullname, exc)\n1298             return None\n1299         except ValueError:\n1300             args = ''\n1301 \n1302         if self.config.strip_signature_backslash:\n1303             # escape backslashes for reST\n1304             args = args.replace('\\\\', '\\\\\\\\')\n1305         return args\n1306 \n1307     def document_members(self, all_members: bool = False) -> None:\n1308         pass\n1309 \n1310     def add_directive_header(self, sig: str) -> None:\n1311         sourcename = self.get_sourcename()\n1312         super().add_directive_header(sig)\n1313 \n1314         if inspect.iscoroutinefunction(self.object):\n1315             self.add_line('   :async:', sourcename)\n1316 \n1317     def format_signature(self, **kwargs: Any) -> str:\n1318         sigs = []\n1319         if (self.analyzer and\n1320                 '.'.join(self.objpath) in self.analyzer.overloads and\n1321                 self.config.autodoc_typehints != 'none'):\n1322             # Use signatures for overloaded functions instead of the implementation function.\n1323             overloaded = True\n1324         else:\n1325             overloaded = False\n1326             sig = super().format_signature(**kwargs)\n1327             sigs.append(sig)\n1328 \n1329         if inspect.is_singledispatch_function(self.object):\n1330             # append signature of singledispatch'ed functions\n1331             for typ, func in self.object.registry.items():\n1332                 if typ is object:\n1333                     pass  # default implementation. skipped.\n1334                 else:\n1335                     dispatchfunc = self.annotate_to_first_argument(func, typ)\n1336                     if dispatchfunc:\n1337                         documenter = FunctionDocumenter(self.directive, '')\n1338                         documenter.object = dispatchfunc\n1339                         documenter.objpath = [None]\n1340                         sigs.append(documenter.format_signature())\n1341         if overloaded:\n1342             actual = inspect.signature(self.object,\n1343                                        type_aliases=self.config.autodoc_type_aliases)\n1344             __globals__ = safe_getattr(self.object, '__globals__', {})\n1345             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1346                 overload = self.merge_default_value(actual, overload)\n1347                 overload = evaluate_signature(overload, __globals__,\n1348                                               self.config.autodoc_type_aliases)\n1349 \n1350                 sig = stringify_signature(overload, **kwargs)\n1351                 sigs.append(sig)\n1352 \n1353         return \"\\n\".join(sigs)\n1354 \n1355     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n1356         \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n1357         parameters = list(overload.parameters.values())\n1358         for i, param in enumerate(parameters):\n1359             actual_param = actual.parameters.get(param.name)\n1360             if actual_param and param.default == '...':\n1361                 parameters[i] = param.replace(default=actual_param.default)\n1362 \n1363         return overload.replace(parameters=parameters)\n1364 \n1365     def annotate_to_first_argument(self, func: Callable, typ: Type) -> Optional[Callable]:\n1366         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1367         try:\n1368             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n1369         except TypeError as exc:\n1370             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1371                            self.fullname, exc)\n1372             return None\n1373         except ValueError:\n1374             return None\n1375 \n1376         if len(sig.parameters) == 0:\n1377             return None\n1378 \n1379         def dummy():\n1380             pass\n1381 \n1382         params = list(sig.parameters.values())\n1383         if params[0].annotation is Parameter.empty:\n1384             params[0] = params[0].replace(annotation=typ)\n1385             try:\n1386                 dummy.__signature__ = sig.replace(parameters=params)  # type: ignore\n1387                 return dummy\n1388             except (AttributeError, TypeError):\n1389                 # failed to update signature (ex. built-in or extension types)\n1390                 return None\n1391         else:\n1392             return None\n1393 \n1394 \n1395 class DecoratorDocumenter(FunctionDocumenter):\n1396     \"\"\"\n1397     Specialized Documenter subclass for decorator functions.\n1398     \"\"\"\n1399     objtype = 'decorator'\n1400 \n1401     # must be lower than FunctionDocumenter\n1402     priority = -1\n1403 \n1404     def format_args(self, **kwargs: Any) -> Any:\n1405         args = super().format_args(**kwargs)\n1406         if ',' in args:\n1407             return args\n1408         else:\n1409             return None\n1410 \n1411 \n1412 # Types which have confusing metaclass signatures it would be best not to show.\n1413 # These are listed by name, rather than storing the objects themselves, to avoid\n1414 # needing to import the modules.\n1415 _METACLASS_CALL_BLACKLIST = [\n1416     'enum.EnumMeta.__call__',\n1417 ]\n1418 \n1419 \n1420 # Types whose __new__ signature is a pass-thru.\n1421 _CLASS_NEW_BLACKLIST = [\n1422     'typing.Generic.__new__',\n1423 ]\n1424 \n1425 \n1426 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1427     \"\"\"\n1428     Specialized Documenter subclass for classes.\n1429     \"\"\"\n1430     objtype = 'class'\n1431     member_order = 20\n1432     option_spec: OptionSpec = {\n1433         'members': members_option, 'undoc-members': bool_option,\n1434         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1435         'show-inheritance': bool_option, 'member-order': member_order_option,\n1436         'exclude-members': exclude_members_option,\n1437         'private-members': members_option, 'special-members': members_option,\n1438         'class-doc-from': class_doc_from_option,\n1439     }\n1440 \n1441     _signature_class: Any = None\n1442     _signature_method_name: str = None\n1443 \n1444     def __init__(self, *args: Any) -> None:\n1445         super().__init__(*args)\n1446 \n1447         if self.config.autodoc_class_signature == 'separated':\n1448             # show __init__() method\n1449             if self.options.special_members is None:\n1450                 self.options['special-members'] = {'__new__', '__init__'}\n1451             else:\n1452                 self.options.special_members.append('__new__')\n1453                 self.options.special_members.append('__init__')\n1454 \n1455         merge_members_option(self.options)\n1456 \n1457     @classmethod\n1458     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1459                             ) -> bool:\n1460         return isinstance(member, type)\n1461 \n1462     def import_object(self, raiseerror: bool = False) -> bool:\n1463         ret = super().import_object(raiseerror)\n1464         # if the class is documented under another name, document it\n1465         # as data/attribute\n1466         if ret:\n1467             if hasattr(self.object, '__name__'):\n1468                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1469             else:\n1470                 self.doc_as_attr = True\n1471         return ret\n1472 \n1473     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n1474         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1475             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1476             if inspect.is_builtin_class_method(obj, attr):\n1477                 return None\n1478             attr = self.get_attr(obj, attr, None)\n1479             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1480                 return None\n1481             return attr\n1482 \n1483         # This sequence is copied from inspect._signature_from_callable.\n1484         # ValueError means that no signature could be found, so we keep going.\n1485 \n1486         # First, we check the obj has a __signature__ attribute\n1487         if (hasattr(self.object, '__signature__') and\n1488                 isinstance(self.object.__signature__, Signature)):\n1489             return None, None, self.object.__signature__\n1490 \n1491         # Next, let's see if it has an overloaded __call__ defined\n1492         # in its metaclass\n1493         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1494 \n1495         if call is not None:\n1496             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1497                 call = None\n1498 \n1499         if call is not None:\n1500             self.env.app.emit('autodoc-before-process-signature', call, True)\n1501             try:\n1502                 sig = inspect.signature(call, bound_method=True,\n1503                                         type_aliases=self.config.autodoc_type_aliases)\n1504                 return type(self.object), '__call__', sig\n1505             except ValueError:\n1506                 pass\n1507 \n1508         # Now we check if the 'obj' class has a '__new__' method\n1509         new = get_user_defined_function_or_method(self.object, '__new__')\n1510 \n1511         if new is not None:\n1512             if \"{0.__module__}.{0.__qualname__}\".format(new) in _CLASS_NEW_BLACKLIST:\n1513                 new = None\n1514 \n1515         if new is not None:\n1516             self.env.app.emit('autodoc-before-process-signature', new, True)\n1517             try:\n1518                 sig = inspect.signature(new, bound_method=True,\n1519                                         type_aliases=self.config.autodoc_type_aliases)\n1520                 return self.object, '__new__', sig\n1521             except ValueError:\n1522                 pass\n1523 \n1524         # Finally, we should have at least __init__ implemented\n1525         init = get_user_defined_function_or_method(self.object, '__init__')\n1526         if init is not None:\n1527             self.env.app.emit('autodoc-before-process-signature', init, True)\n1528             try:\n1529                 sig = inspect.signature(init, bound_method=True,\n1530                                         type_aliases=self.config.autodoc_type_aliases)\n1531                 return self.object, '__init__', sig\n1532             except ValueError:\n1533                 pass\n1534 \n1535         # None of the attributes are user-defined, so fall back to let inspect\n1536         # handle it.\n1537         # We don't know the exact method that inspect.signature will read\n1538         # the signature from, so just pass the object itself to our hook.\n1539         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1540         try:\n1541             sig = inspect.signature(self.object, bound_method=False,\n1542                                     type_aliases=self.config.autodoc_type_aliases)\n1543             return None, None, sig\n1544         except ValueError:\n1545             pass\n1546 \n1547         # Still no signature: happens e.g. for old-style classes\n1548         # with __init__ in C and no `__text_signature__`.\n1549         return None, None, None\n1550 \n1551     def format_args(self, **kwargs: Any) -> str:\n1552         if self.config.autodoc_typehints in ('none', 'description'):\n1553             kwargs.setdefault('show_annotation', False)\n1554 \n1555         try:\n1556             self._signature_class, self._signature_method_name, sig = self._get_signature()\n1557         except TypeError as exc:\n1558             # __signature__ attribute contained junk\n1559             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1560                            self.fullname, exc)\n1561             return None\n1562 \n1563         if sig is None:\n1564             return None\n1565 \n1566         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1567 \n1568     def format_signature(self, **kwargs: Any) -> str:\n1569         if self.doc_as_attr:\n1570             return ''\n1571         if self.config.autodoc_class_signature == 'separated':\n1572             # do not show signatures\n1573             return ''\n1574 \n1575         sig = super().format_signature()\n1576         sigs = []\n1577 \n1578         overloads = self.get_overloaded_signatures()\n1579         if overloads and self.config.autodoc_typehints != 'none':\n1580             # Use signatures for overloaded methods instead of the implementation method.\n1581             method = safe_getattr(self._signature_class, self._signature_method_name, None)\n1582             __globals__ = safe_getattr(method, '__globals__', {})\n1583             for overload in overloads:\n1584                 overload = evaluate_signature(overload, __globals__,\n1585                                               self.config.autodoc_type_aliases)\n1586 \n1587                 parameters = list(overload.parameters.values())\n1588                 overload = overload.replace(parameters=parameters[1:],\n1589                                             return_annotation=Parameter.empty)\n1590                 sig = stringify_signature(overload, **kwargs)\n1591                 sigs.append(sig)\n1592         else:\n1593             sigs.append(sig)\n1594 \n1595         return \"\\n\".join(sigs)\n1596 \n1597     def get_overloaded_signatures(self) -> List[Signature]:\n1598         if self._signature_class and self._signature_method_name:\n1599             for cls in self._signature_class.__mro__:\n1600                 try:\n1601                     analyzer = ModuleAnalyzer.for_module(cls.__module__)\n1602                     analyzer.analyze()\n1603                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])\n1604                     if qualname in analyzer.overloads:\n1605                         return analyzer.overloads.get(qualname)\n1606                     elif qualname in analyzer.tagorder:\n1607                         # the constructor is defined in the class, but not overrided.\n1608                         return []\n1609                 except PycodeError:\n1610                     pass\n1611 \n1612         return []\n1613 \n1614     def get_canonical_fullname(self) -> Optional[str]:\n1615         __modname__ = safe_getattr(self.object, '__module__', self.modname)\n1616         __qualname__ = safe_getattr(self.object, '__qualname__', None)\n1617         if __qualname__ is None:\n1618             __qualname__ = safe_getattr(self.object, '__name__', None)\n1619         if __qualname__ and '<locals>' in __qualname__:\n1620             # No valid qualname found if the object is defined as locals\n1621             __qualname__ = None\n1622 \n1623         if __modname__ and __qualname__:\n1624             return '.'.join([__modname__, __qualname__])\n1625         else:\n1626             return None\n1627 \n1628     def add_directive_header(self, sig: str) -> None:\n1629         sourcename = self.get_sourcename()\n1630 \n1631         if self.doc_as_attr:\n1632             self.directivetype = 'attribute'\n1633         super().add_directive_header(sig)\n1634 \n1635         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1636             self.add_line('   :final:', sourcename)\n1637 \n1638         canonical_fullname = self.get_canonical_fullname()\n1639         if not self.doc_as_attr and canonical_fullname and self.fullname != canonical_fullname:\n1640             self.add_line('   :canonical: %s' % canonical_fullname, sourcename)\n1641 \n1642         # add inheritance info, if wanted\n1643         if not self.doc_as_attr and self.options.show_inheritance:\n1644             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):\n1645                 # A subclass of generic types\n1646                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>\n1647                 bases = list(self.object.__orig_bases__)\n1648             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1649                 # A normal class\n1650                 bases = list(self.object.__bases__)\n1651             else:\n1652                 bases = []\n1653 \n1654             self.env.events.emit('autodoc-process-bases',\n1655                                  self.fullname, self.object, self.options, bases)\n1656 \n1657             base_classes = [restify(cls) for cls in bases]\n1658             sourcename = self.get_sourcename()\n1659             self.add_line('', sourcename)\n1660             self.add_line('   ' + _('Bases: %s') % ', '.join(base_classes), sourcename)\n1661 \n1662     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1663         members = get_class_members(self.object, self.objpath, self.get_attr)\n1664         if not want_all:\n1665             if not self.options.members:\n1666                 return False, []  # type: ignore\n1667             # specific members given\n1668             selected = []\n1669             for name in self.options.members:  # type: str\n1670                 if name in members:\n1671                     selected.append(members[name])\n1672                 else:\n1673                     logger.warning(__('missing attribute %s in object %s') %\n1674                                    (name, self.fullname), type='autodoc')\n1675             return False, selected\n1676         elif self.options.inherited_members:\n1677             return False, list(members.values())\n1678         else:\n1679             return False, [m for m in members.values() if m.class_ == self.object]\n1680 \n1681     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n1682         if self.doc_as_attr:\n1683             # Don't show the docstring of the class when it is an alias.\n1684             comment = self.get_variable_comment()\n1685             if comment:\n1686                 return []\n1687             else:\n1688                 return None\n1689 \n1690         lines = getattr(self, '_new_docstrings', None)\n1691         if lines is not None:\n1692             return lines\n1693 \n1694         classdoc_from = self.options.get('class-doc-from', self.config.autoclass_content)\n1695 \n1696         docstrings = []\n1697         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1698         if attrdocstring:\n1699             docstrings.append(attrdocstring)\n1700 \n1701         # for classes, what the \"docstring\" is can be controlled via a\n1702         # config value; the default is only the class docstring\n1703         if classdoc_from in ('both', 'init'):\n1704             __init__ = self.get_attr(self.object, '__init__', None)\n1705             initdocstring = getdoc(__init__, self.get_attr,\n1706                                    self.config.autodoc_inherit_docstrings,\n1707                                    self.object, '__init__')\n1708             # for new-style classes, no __init__ means default __init__\n1709             if (initdocstring is not None and\n1710                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1711                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1712                 initdocstring = None\n1713             if not initdocstring:\n1714                 # try __new__\n1715                 __new__ = self.get_attr(self.object, '__new__', None)\n1716                 initdocstring = getdoc(__new__, self.get_attr,\n1717                                        self.config.autodoc_inherit_docstrings,\n1718                                        self.object, '__new__')\n1719                 # for new-style classes, no __new__ means default __new__\n1720                 if (initdocstring is not None and\n1721                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1722                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1723                     initdocstring = None\n1724             if initdocstring:\n1725                 if classdoc_from == 'init':\n1726                     docstrings = [initdocstring]\n1727                 else:\n1728                     docstrings.append(initdocstring)\n1729 \n1730         tab_width = self.directive.state.document.settings.tab_width\n1731         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1732 \n1733     def get_variable_comment(self) -> Optional[List[str]]:\n1734         try:\n1735             key = ('', '.'.join(self.objpath))\n1736             analyzer = ModuleAnalyzer.for_module(self.get_real_modname())\n1737             analyzer.analyze()\n1738             return list(self.analyzer.attr_docs.get(key, []))\n1739         except PycodeError:\n1740             return None\n1741 \n1742     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1743                     ) -> None:\n1744         if self.doc_as_attr and not self.get_variable_comment():\n1745             try:\n1746                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n1747             except AttributeError:\n1748                 pass  # Invalid class object is passed.\n1749 \n1750         super().add_content(more_content)\n1751 \n1752     def document_members(self, all_members: bool = False) -> None:\n1753         if self.doc_as_attr:\n1754             return\n1755         super().document_members(all_members)\n1756 \n1757     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n1758                  check_module: bool = False, all_members: bool = False) -> None:\n1759         # Do not pass real_modname and use the name from the __module__\n1760         # attribute of the class.\n1761         # If a class gets imported into the module real_modname\n1762         # the analyzer won't find the source of the class, if\n1763         # it looks in real_modname.\n1764         return super().generate(more_content=more_content,\n1765                                 check_module=check_module,\n1766                                 all_members=all_members)\n1767 \n1768 \n1769 class ExceptionDocumenter(ClassDocumenter):\n1770     \"\"\"\n1771     Specialized ClassDocumenter subclass for exceptions.\n1772     \"\"\"\n1773     objtype = 'exception'\n1774     member_order = 10\n1775 \n1776     # needs a higher priority than ClassDocumenter\n1777     priority = 10\n1778 \n1779     @classmethod\n1780     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1781                             ) -> bool:\n1782         return isinstance(member, type) and issubclass(member, BaseException)\n1783 \n1784 \n1785 class DataDocumenterMixinBase:\n1786     # define types of instance variables\n1787     config: Config = None\n1788     env: BuildEnvironment = None\n1789     modname: str = None\n1790     parent: Any = None\n1791     object: Any = None\n1792     objpath: List[str] = None\n1793 \n1794     def should_suppress_directive_header(self) -> bool:\n1795         \"\"\"Check directive header should be suppressed.\"\"\"\n1796         return False\n1797 \n1798     def should_suppress_value_header(self) -> bool:\n1799         \"\"\"Check :value: header should be suppressed.\"\"\"\n1800         return False\n1801 \n1802     def update_content(self, more_content: StringList) -> None:\n1803         \"\"\"Update docstring for the NewType object.\"\"\"\n1804         pass\n1805 \n1806 \n1807 class GenericAliasMixin(DataDocumenterMixinBase):\n1808     \"\"\"\n1809     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1810     supporting GenericAliases.\n1811     \"\"\"\n1812 \n1813     def should_suppress_directive_header(self) -> bool:\n1814         return (inspect.isgenericalias(self.object) or\n1815                 super().should_suppress_directive_header())\n1816 \n1817     def update_content(self, more_content: StringList) -> None:\n1818         if inspect.isgenericalias(self.object):\n1819             more_content.append(_('alias of %s') % restify(self.object), '')\n1820             more_content.append('', '')\n1821 \n1822         super().update_content(more_content)\n1823 \n1824 \n1825 class NewTypeMixin(DataDocumenterMixinBase):\n1826     \"\"\"\n1827     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1828     supporting NewTypes.\n1829     \"\"\"\n1830 \n1831     def should_suppress_directive_header(self) -> bool:\n1832         return (inspect.isNewType(self.object) or\n1833                 super().should_suppress_directive_header())\n1834 \n1835     def update_content(self, more_content: StringList) -> None:\n1836         if inspect.isNewType(self.object):\n1837             supertype = restify(self.object.__supertype__)\n1838             more_content.append(_('alias of %s') % supertype, '')\n1839             more_content.append('', '')\n1840 \n1841         super().update_content(more_content)\n1842 \n1843 \n1844 class TypeVarMixin(DataDocumenterMixinBase):\n1845     \"\"\"\n1846     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1847     supporting TypeVars.\n1848     \"\"\"\n1849 \n1850     def should_suppress_directive_header(self) -> bool:\n1851         return (isinstance(self.object, TypeVar) or\n1852                 super().should_suppress_directive_header())\n1853 \n1854     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n1855         if ignore is not None:\n1856             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1857                           % self.__class__.__name__,\n1858                           RemovedInSphinx50Warning, stacklevel=2)\n1859 \n1860         if isinstance(self.object, TypeVar):\n1861             if self.object.__doc__ != TypeVar.__doc__:\n1862                 return super().get_doc()  # type: ignore\n1863             else:\n1864                 return []\n1865         else:\n1866             return super().get_doc()  # type: ignore\n1867 \n1868     def update_content(self, more_content: StringList) -> None:\n1869         if isinstance(self.object, TypeVar):\n1870             attrs = [repr(self.object.__name__)]\n1871             for constraint in self.object.__constraints__:\n1872                 attrs.append(stringify_typehint(constraint))\n1873             if self.object.__bound__:\n1874                 attrs.append(r\"bound=\\ \" + restify(self.object.__bound__))\n1875             if self.object.__covariant__:\n1876                 attrs.append(\"covariant=True\")\n1877             if self.object.__contravariant__:\n1878                 attrs.append(\"contravariant=True\")\n1879 \n1880             more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n1881             more_content.append('', '')\n1882 \n1883         super().update_content(more_content)\n1884 \n1885 \n1886 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\n1887     \"\"\"\n1888     Mixin for DataDocumenter to provide the feature for supporting uninitialized\n1889     (type annotation only) global variables.\n1890     \"\"\"\n1891 \n1892     def import_object(self, raiseerror: bool = False) -> bool:\n1893         try:\n1894             return super().import_object(raiseerror=True)  # type: ignore\n1895         except ImportError as exc:\n1896             # annotation only instance variable (PEP-526)\n1897             try:\n1898                 with mock(self.config.autodoc_mock_imports):\n1899                     parent = import_module(self.modname, self.config.autodoc_warningiserror)\n1900                     annotations = get_type_hints(parent, None,\n1901                                                  self.config.autodoc_type_aliases)\n1902                     if self.objpath[-1] in annotations:\n1903                         self.object = UNINITIALIZED_ATTR\n1904                         self.parent = parent\n1905                         return True\n1906             except ImportError:\n1907                 pass\n1908 \n1909             if raiseerror:\n1910                 raise\n1911             else:\n1912                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n1913                 self.env.note_reread()\n1914                 return False\n1915 \n1916     def should_suppress_value_header(self) -> bool:\n1917         return (self.object is UNINITIALIZED_ATTR or\n1918                 super().should_suppress_value_header())\n1919 \n1920     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n1921         if self.object is UNINITIALIZED_ATTR:\n1922             return []\n1923         else:\n1924             return super().get_doc(ignore)  # type: ignore\n1925 \n1926 \n1927 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,\n1928                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\n1929     \"\"\"\n1930     Specialized Documenter subclass for data items.\n1931     \"\"\"\n1932     objtype = 'data'\n1933     member_order = 40\n1934     priority = -10\n1935     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)\n1936     option_spec[\"annotation\"] = annotation_option\n1937     option_spec[\"no-value\"] = bool_option\n1938 \n1939     @classmethod\n1940     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1941                             ) -> bool:\n1942         return isinstance(parent, ModuleDocumenter) and isattr\n1943 \n1944     def update_annotations(self, parent: Any) -> None:\n1945         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n1946         annotations = dict(inspect.getannotations(parent))\n1947         parent.__annotations__ = annotations\n1948 \n1949         try:\n1950             analyzer = ModuleAnalyzer.for_module(self.modname)\n1951             analyzer.analyze()\n1952             for (classname, attrname), annotation in analyzer.annotations.items():\n1953                 if classname == '' and attrname not in annotations:\n1954                     annotations[attrname] = annotation\n1955         except PycodeError:\n1956             pass\n1957 \n1958     def import_object(self, raiseerror: bool = False) -> bool:\n1959         ret = super().import_object(raiseerror)\n1960         if self.parent:\n1961             self.update_annotations(self.parent)\n1962 \n1963         return ret\n1964 \n1965     def should_suppress_value_header(self) -> bool:\n1966         if super().should_suppress_value_header():\n1967             return True\n1968         else:\n1969             doc = self.get_doc()\n1970             docstring, metadata = separate_metadata('\\n'.join(sum(doc, [])))\n1971             if 'hide-value' in metadata:\n1972                 return True\n1973 \n1974         return False\n1975 \n1976     def add_directive_header(self, sig: str) -> None:\n1977         super().add_directive_header(sig)\n1978         sourcename = self.get_sourcename()\n1979         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n1980             pass\n1981         elif self.options.annotation:\n1982             self.add_line('   :annotation: %s' % self.options.annotation,\n1983                           sourcename)\n1984         else:\n1985             if self.config.autodoc_typehints != 'none':\n1986                 # obtain annotation for this data\n1987                 annotations = get_type_hints(self.parent, None,\n1988                                              self.config.autodoc_type_aliases)\n1989                 if self.objpath[-1] in annotations:\n1990                     objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1991                     self.add_line('   :type: ' + objrepr, sourcename)\n1992 \n1993             try:\n1994                 if self.options.no_value or self.should_suppress_value_header():\n1995                     pass\n1996                 else:\n1997                     objrepr = object_description(self.object)\n1998                     self.add_line('   :value: ' + objrepr, sourcename)\n1999             except ValueError:\n2000                 pass\n2001 \n2002     def document_members(self, all_members: bool = False) -> None:\n2003         pass\n2004 \n2005     def get_real_modname(self) -> str:\n2006         real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n2007         return real_modname or self.modname\n2008 \n2009     def get_module_comment(self, attrname: str) -> Optional[List[str]]:\n2010         try:\n2011             analyzer = ModuleAnalyzer.for_module(self.modname)\n2012             analyzer.analyze()\n2013             key = ('', attrname)\n2014             if key in analyzer.attr_docs:\n2015                 return list(analyzer.attr_docs[key])\n2016         except PycodeError:\n2017             pass\n2018 \n2019         return None\n2020 \n2021     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2022         # Check the variable has a docstring-comment\n2023         comment = self.get_module_comment(self.objpath[-1])\n2024         if comment:\n2025             return [comment]\n2026         else:\n2027             return super().get_doc(ignore)\n2028 \n2029     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n2030                     ) -> None:\n2031         # Disable analyzing variable comment on Documenter.add_content() to control it on\n2032         # DataDocumenter.add_content()\n2033         self.analyzer = None\n2034 \n2035         if not more_content:\n2036             more_content = StringList()\n2037 \n2038         self.update_content(more_content)\n2039         super().add_content(more_content, no_docstring=no_docstring)\n2040 \n2041 \n2042 class NewTypeDataDocumenter(DataDocumenter):\n2043     \"\"\"\n2044     Specialized Documenter subclass for NewTypes.\n2045 \n2046     Note: This must be invoked before FunctionDocumenter because NewType is a kind of\n2047     function object.\n2048     \"\"\"\n2049 \n2050     objtype = 'newtypedata'\n2051     directivetype = 'data'\n2052     priority = FunctionDocumenter.priority + 1\n2053 \n2054     @classmethod\n2055     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2056                             ) -> bool:\n2057         return inspect.isNewType(member) and isattr\n2058 \n2059 \n2060 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2061     \"\"\"\n2062     Specialized Documenter subclass for methods (normal, static and class).\n2063     \"\"\"\n2064     objtype = 'method'\n2065     directivetype = 'method'\n2066     member_order = 50\n2067     priority = 1  # must be more than FunctionDocumenter\n2068 \n2069     @classmethod\n2070     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2071                             ) -> bool:\n2072         return inspect.isroutine(member) and not isinstance(parent, ModuleDocumenter)\n2073 \n2074     def import_object(self, raiseerror: bool = False) -> bool:\n2075         ret = super().import_object(raiseerror)\n2076         if not ret:\n2077             return ret\n2078 \n2079         # to distinguish classmethod/staticmethod\n2080         obj = self.parent.__dict__.get(self.object_name)\n2081         if obj is None:\n2082             obj = self.object\n2083 \n2084         if (inspect.isclassmethod(obj) or\n2085                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n2086             # document class and static members before ordinary ones\n2087             self.member_order = self.member_order - 1\n2088 \n2089         return ret\n2090 \n2091     def format_args(self, **kwargs: Any) -> str:\n2092         if self.config.autodoc_typehints in ('none', 'description'):\n2093             kwargs.setdefault('show_annotation', False)\n2094 \n2095         try:\n2096             if self.object == object.__init__ and self.parent != object:\n2097                 # Classes not having own __init__() method are shown as no arguments.\n2098                 #\n2099                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n2100                 #       But it makes users confused.\n2101                 args = '()'\n2102             else:\n2103                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n2104                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n2105                     sig = inspect.signature(self.object, bound_method=False,\n2106                                             type_aliases=self.config.autodoc_type_aliases)\n2107                 else:\n2108                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n2109                     sig = inspect.signature(self.object, bound_method=True,\n2110                                             type_aliases=self.config.autodoc_type_aliases)\n2111                 args = stringify_signature(sig, **kwargs)\n2112         except TypeError as exc:\n2113             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2114                            self.fullname, exc)\n2115             return None\n2116         except ValueError:\n2117             args = ''\n2118 \n2119         if self.config.strip_signature_backslash:\n2120             # escape backslashes for reST\n2121             args = args.replace('\\\\', '\\\\\\\\')\n2122         return args\n2123 \n2124     def add_directive_header(self, sig: str) -> None:\n2125         super().add_directive_header(sig)\n2126 \n2127         sourcename = self.get_sourcename()\n2128         obj = self.parent.__dict__.get(self.object_name, self.object)\n2129         if inspect.isabstractmethod(obj):\n2130             self.add_line('   :abstractmethod:', sourcename)\n2131         if inspect.iscoroutinefunction(obj):\n2132             self.add_line('   :async:', sourcename)\n2133         if inspect.isclassmethod(obj):\n2134             self.add_line('   :classmethod:', sourcename)\n2135         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n2136             self.add_line('   :staticmethod:', sourcename)\n2137         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n2138             self.add_line('   :final:', sourcename)\n2139 \n2140     def document_members(self, all_members: bool = False) -> None:\n2141         pass\n2142 \n2143     def format_signature(self, **kwargs: Any) -> str:\n2144         sigs = []\n2145         if (self.analyzer and\n2146                 '.'.join(self.objpath) in self.analyzer.overloads and\n2147                 self.config.autodoc_typehints != 'none'):\n2148             # Use signatures for overloaded methods instead of the implementation method.\n2149             overloaded = True\n2150         else:\n2151             overloaded = False\n2152             sig = super().format_signature(**kwargs)\n2153             sigs.append(sig)\n2154 \n2155         meth = self.parent.__dict__.get(self.objpath[-1])\n2156         if inspect.is_singledispatch_method(meth):\n2157             # append signature of singledispatch'ed functions\n2158             for typ, func in meth.dispatcher.registry.items():\n2159                 if typ is object:\n2160                     pass  # default implementation. skipped.\n2161                 else:\n2162                     dispatchmeth = self.annotate_to_first_argument(func, typ)\n2163                     if dispatchmeth:\n2164                         documenter = MethodDocumenter(self.directive, '')\n2165                         documenter.parent = self.parent\n2166                         documenter.object = dispatchmeth\n2167                         documenter.objpath = [None]\n2168                         sigs.append(documenter.format_signature())\n2169         if overloaded:\n2170             if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n2171                 actual = inspect.signature(self.object, bound_method=False,\n2172                                            type_aliases=self.config.autodoc_type_aliases)\n2173             else:\n2174                 actual = inspect.signature(self.object, bound_method=True,\n2175                                            type_aliases=self.config.autodoc_type_aliases)\n2176 \n2177             __globals__ = safe_getattr(self.object, '__globals__', {})\n2178             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n2179                 overload = self.merge_default_value(actual, overload)\n2180                 overload = evaluate_signature(overload, __globals__,\n2181                                               self.config.autodoc_type_aliases)\n2182 \n2183                 if not inspect.isstaticmethod(self.object, cls=self.parent,\n2184                                               name=self.object_name):\n2185                     parameters = list(overload.parameters.values())\n2186                     overload = overload.replace(parameters=parameters[1:])\n2187                 sig = stringify_signature(overload, **kwargs)\n2188                 sigs.append(sig)\n2189 \n2190         return \"\\n\".join(sigs)\n2191 \n2192     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:\n2193         \"\"\"Merge default values of actual implementation to the overload variants.\"\"\"\n2194         parameters = list(overload.parameters.values())\n2195         for i, param in enumerate(parameters):\n2196             actual_param = actual.parameters.get(param.name)\n2197             if actual_param and param.default == '...':\n2198                 parameters[i] = param.replace(default=actual_param.default)\n2199 \n2200         return overload.replace(parameters=parameters)\n2201 \n2202     def annotate_to_first_argument(self, func: Callable, typ: Type) -> Optional[Callable]:\n2203         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n2204         try:\n2205             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n2206         except TypeError as exc:\n2207             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2208                            self.fullname, exc)\n2209             return None\n2210         except ValueError:\n2211             return None\n2212 \n2213         if len(sig.parameters) == 1:\n2214             return None\n2215 \n2216         def dummy():\n2217             pass\n2218 \n2219         params = list(sig.parameters.values())\n2220         if params[1].annotation is Parameter.empty:\n2221             params[1] = params[1].replace(annotation=typ)\n2222             try:\n2223                 dummy.__signature__ = sig.replace(parameters=params)  # type: ignore\n2224                 return dummy\n2225             except (AttributeError, TypeError):\n2226                 # failed to update signature (ex. built-in or extension types)\n2227                 return None\n2228         else:\n2229             return None\n2230 \n2231     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2232         if self.objpath[-1] == '__init__':\n2233             docstring = getdoc(self.object, self.get_attr,\n2234                                self.config.autodoc_inherit_docstrings,\n2235                                self.parent, self.object_name)\n2236             if (docstring is not None and\n2237                 (docstring == object.__init__.__doc__ or  # for pypy\n2238                  docstring.strip() == object.__init__.__doc__)):  # for !pypy\n2239                 docstring = None\n2240             if docstring:\n2241                 tab_width = self.directive.state.document.settings.tab_width\n2242                 return [prepare_docstring(docstring, tabsize=tab_width)]\n2243             else:\n2244                 return []\n2245         elif self.objpath[-1] == '__new__':\n2246             __new__ = self.get_attr(self.object, '__new__', None)\n2247             if __new__:\n2248                 docstring = getdoc(__new__, self.get_attr,\n2249                                    self.config.autodoc_inherit_docstrings,\n2250                                    self.parent, self.object_name)\n2251                 if (docstring is not None and\n2252                     (docstring == object.__new__.__doc__ or  # for pypy\n2253                      docstring.strip() == object.__new__.__doc__)):  # for !pypy\n2254                     docstring = None\n2255             if docstring:\n2256                 tab_width = self.directive.state.document.settings.tab_width\n2257                 return [prepare_docstring(docstring, tabsize=tab_width)]\n2258             else:\n2259                 return []\n2260         else:\n2261             return super().get_doc()\n2262 \n2263 \n2264 class NonDataDescriptorMixin(DataDocumenterMixinBase):\n2265     \"\"\"\n2266     Mixin for AttributeDocumenter to provide the feature for supporting non\n2267     data-descriptors.\n2268 \n2269     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring\n2270               and :value: header will be suppressed unexpectedly.\n2271     \"\"\"\n2272 \n2273     def import_object(self, raiseerror: bool = False) -> bool:\n2274         ret = super().import_object(raiseerror)  # type: ignore\n2275         if ret and not inspect.isattributedescriptor(self.object):\n2276             self.non_data_descriptor = True\n2277         else:\n2278             self.non_data_descriptor = False\n2279 \n2280         return ret\n2281 \n2282     def should_suppress_value_header(self) -> bool:\n2283         return (not getattr(self, 'non_data_descriptor', False) or\n2284                 super().should_suppress_directive_header())\n2285 \n2286     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2287         if getattr(self, 'non_data_descriptor', False):\n2288             # the docstring of non datadescriptor is very probably the wrong thing\n2289             # to display\n2290             return None\n2291         else:\n2292             return super().get_doc(ignore)  # type: ignore\n2293 \n2294 \n2295 class SlotsMixin(DataDocumenterMixinBase):\n2296     \"\"\"\n2297     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.\n2298     \"\"\"\n2299 \n2300     def isslotsattribute(self) -> bool:\n2301         \"\"\"Check the subject is an attribute in __slots__.\"\"\"\n2302         try:\n2303             __slots__ = inspect.getslots(self.parent)\n2304             if __slots__ and self.objpath[-1] in __slots__:\n2305                 return True\n2306             else:\n2307                 return False\n2308         except (ValueError, TypeError):\n2309             return False\n2310 \n2311     def import_object(self, raiseerror: bool = False) -> bool:\n2312         ret = super().import_object(raiseerror)  # type: ignore\n2313         if self.isslotsattribute():\n2314             self.object = SLOTSATTR\n2315 \n2316         return ret\n2317 \n2318     def should_suppress_directive_header(self) -> bool:\n2319         if self.object is SLOTSATTR:\n2320             self._datadescriptor = True\n2321             return True\n2322         else:\n2323             return super().should_suppress_directive_header()\n2324 \n2325     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2326         if self.object is SLOTSATTR:\n2327             try:\n2328                 __slots__ = inspect.getslots(self.parent)\n2329                 if __slots__ and __slots__.get(self.objpath[-1]):\n2330                     docstring = prepare_docstring(__slots__[self.objpath[-1]])\n2331                     return [docstring]\n2332                 else:\n2333                     return []\n2334             except ValueError as exc:\n2335                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),\n2336                                (self.parent.__qualname__, exc), type='autodoc')\n2337                 return []\n2338         else:\n2339             return super().get_doc(ignore)  # type: ignore\n2340 \n2341 \n2342 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):\n2343     \"\"\"\n2344     Mixin for AttributeDocumenter to provide the feature for supporting runtime\n2345     instance attributes (that are defined in __init__() methods with doc-comments).\n2346 \n2347     Example:\n2348 \n2349         class Foo:\n2350             def __init__(self):\n2351                 self.attr = None  #: This is a target of this mix-in.\n2352     \"\"\"\n2353 \n2354     RUNTIME_INSTANCE_ATTRIBUTE = object()\n2355 \n2356     def is_runtime_instance_attribute(self, parent: Any) -> bool:\n2357         \"\"\"Check the subject is an attribute defined in __init__().\"\"\"\n2358         # An instance variable defined in __init__().\n2359         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore\n2360             return True\n2361         elif self.is_runtime_instance_attribute_not_commented(parent):\n2362             return True\n2363         else:\n2364             return False\n2365 \n2366     def is_runtime_instance_attribute_not_commented(self, parent: Any) -> bool:\n2367         \"\"\"Check the subject is an attribute defined in __init__() without comment.\"\"\"\n2368         for cls in inspect.getmro(parent):\n2369             try:\n2370                 module = safe_getattr(cls, '__module__')\n2371                 qualname = safe_getattr(cls, '__qualname__')\n2372 \n2373                 analyzer = ModuleAnalyzer.for_module(module)\n2374                 analyzer.analyze()\n2375                 if qualname and self.objpath:\n2376                     key = '.'.join([qualname, self.objpath[-1]])\n2377                     if key in analyzer.tagorder:\n2378                         return True\n2379             except (AttributeError, PycodeError):\n2380                 pass\n2381 \n2382         return None\n2383 \n2384     def import_object(self, raiseerror: bool = False) -> bool:\n2385         \"\"\"Check the existence of runtime instance attribute when failed to import the\n2386         attribute.\"\"\"\n2387         try:\n2388             return super().import_object(raiseerror=True)  # type: ignore\n2389         except ImportError as exc:\n2390             try:\n2391                 with mock(self.config.autodoc_mock_imports):\n2392                     ret = import_object(self.modname, self.objpath[:-1], 'class',\n2393                                         attrgetter=self.get_attr,  # type: ignore\n2394                                         warningiserror=self.config.autodoc_warningiserror)\n2395                     parent = ret[3]\n2396                     if self.is_runtime_instance_attribute(parent):\n2397                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE\n2398                         self.parent = parent\n2399                         return True\n2400             except ImportError:\n2401                 pass\n2402 \n2403             if raiseerror:\n2404                 raise\n2405             else:\n2406                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2407                 self.env.note_reread()\n2408                 return False\n2409 \n2410     def should_suppress_value_header(self) -> bool:\n2411         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or\n2412                 super().should_suppress_value_header())\n2413 \n2414     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2415         if (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE and\n2416                 self.is_runtime_instance_attribute_not_commented(self.parent)):\n2417             return None\n2418         else:\n2419             return super().get_doc(ignore)  # type: ignore\n2420 \n2421 \n2422 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\n2423     \"\"\"\n2424     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized\n2425     instance attributes (PEP-526 styled, annotation only attributes).\n2426 \n2427     Example:\n2428 \n2429         class Foo:\n2430             attr: int  #: This is a target of this mix-in.\n2431     \"\"\"\n2432 \n2433     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:\n2434         \"\"\"Check the subject is an annotation only attribute.\"\"\"\n2435         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)\n2436         if self.objpath[-1] in annotations:\n2437             return True\n2438         else:\n2439             return False\n2440 \n2441     def import_object(self, raiseerror: bool = False) -> bool:\n2442         \"\"\"Check the exisitence of uninitialized instance attribute when failed to import\n2443         the attribute.\"\"\"\n2444         try:\n2445             return super().import_object(raiseerror=True)  # type: ignore\n2446         except ImportError as exc:\n2447             try:\n2448                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2449                                     attrgetter=self.get_attr,  # type: ignore\n2450                                     warningiserror=self.config.autodoc_warningiserror)\n2451                 parent = ret[3]\n2452                 if self.is_uninitialized_instance_attribute(parent):\n2453                     self.object = UNINITIALIZED_ATTR\n2454                     self.parent = parent\n2455                     return True\n2456             except ImportError:\n2457                 pass\n2458 \n2459             if raiseerror:\n2460                 raise\n2461             else:\n2462                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2463                 self.env.note_reread()\n2464                 return False\n2465 \n2466     def should_suppress_value_header(self) -> bool:\n2467         return (self.object is UNINITIALIZED_ATTR or\n2468                 super().should_suppress_value_header())\n2469 \n2470     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2471         if self.object is UNINITIALIZED_ATTR:\n2472             return None\n2473         else:\n2474             return super().get_doc(ignore)  # type: ignore\n2475 \n2476 \n2477 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore\n2478                           TypeVarMixin, RuntimeInstanceAttributeMixin,\n2479                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,\n2480                           DocstringStripSignatureMixin, ClassLevelDocumenter):\n2481     \"\"\"\n2482     Specialized Documenter subclass for attributes.\n2483     \"\"\"\n2484     objtype = 'attribute'\n2485     member_order = 60\n2486     option_spec: OptionSpec = dict(ModuleLevelDocumenter.option_spec)\n2487     option_spec[\"annotation\"] = annotation_option\n2488     option_spec[\"no-value\"] = bool_option\n2489 \n2490     # must be higher than the MethodDocumenter, else it will recognize\n2491     # some non-data descriptors as methods\n2492     priority = 10\n2493 \n2494     @staticmethod\n2495     def is_function_or_method(obj: Any) -> bool:\n2496         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n2497 \n2498     @classmethod\n2499     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2500                             ) -> bool:\n2501         if inspect.isattributedescriptor(member):\n2502             return True\n2503         elif (not isinstance(parent, ModuleDocumenter) and\n2504               not inspect.isroutine(member) and\n2505               not isinstance(member, type)):\n2506             return True\n2507         else:\n2508             return False\n2509 \n2510     def document_members(self, all_members: bool = False) -> None:\n2511         pass\n2512 \n2513     def isinstanceattribute(self) -> bool:\n2514         \"\"\"Check the subject is an instance attribute.\"\"\"\n2515         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',\n2516                       RemovedInSphinx50Warning)\n2517         # uninitialized instance variable (PEP-526)\n2518         with mock(self.config.autodoc_mock_imports):\n2519             try:\n2520                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2521                                     attrgetter=self.get_attr,\n2522                                     warningiserror=self.config.autodoc_warningiserror)\n2523                 self.parent = ret[3]\n2524                 annotations = get_type_hints(self.parent, None,\n2525                                              self.config.autodoc_type_aliases)\n2526                 if self.objpath[-1] in annotations:\n2527                     self.object = UNINITIALIZED_ATTR\n2528                     return True\n2529             except ImportError:\n2530                 pass\n2531 \n2532         return False\n2533 \n2534     def update_annotations(self, parent: Any) -> None:\n2535         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n2536         try:\n2537             annotations = dict(inspect.getannotations(parent))\n2538             parent.__annotations__ = annotations\n2539 \n2540             for cls in inspect.getmro(parent):\n2541                 try:\n2542                     module = safe_getattr(cls, '__module__')\n2543                     qualname = safe_getattr(cls, '__qualname__')\n2544 \n2545                     analyzer = ModuleAnalyzer.for_module(module)\n2546                     analyzer.analyze()\n2547                     for (classname, attrname), annotation in analyzer.annotations.items():\n2548                         if classname == qualname and attrname not in annotations:\n2549                             annotations[attrname] = annotation\n2550                 except (AttributeError, PycodeError):\n2551                     pass\n2552         except (AttributeError, TypeError):\n2553             # Failed to set __annotations__ (built-in, extensions, etc.)\n2554             pass\n2555 \n2556     def import_object(self, raiseerror: bool = False) -> bool:\n2557         ret = super().import_object(raiseerror)\n2558         if inspect.isenumattribute(self.object):\n2559             self.object = self.object.value\n2560         if self.parent:\n2561             self.update_annotations(self.parent)\n2562 \n2563         return ret\n2564 \n2565     def get_real_modname(self) -> str:\n2566         real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n2567         return real_modname or self.modname\n2568 \n2569     def should_suppress_value_header(self) -> bool:\n2570         if super().should_suppress_value_header():\n2571             return True\n2572         else:\n2573             doc = self.get_doc()\n2574             if doc:\n2575                 docstring, metadata = separate_metadata('\\n'.join(sum(doc, [])))\n2576                 if 'hide-value' in metadata:\n2577                     return True\n2578 \n2579         return False\n2580 \n2581     def add_directive_header(self, sig: str) -> None:\n2582         super().add_directive_header(sig)\n2583         sourcename = self.get_sourcename()\n2584         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n2585             pass\n2586         elif self.options.annotation:\n2587             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n2588         else:\n2589             if self.config.autodoc_typehints != 'none':\n2590                 # obtain type annotation for this attribute\n2591                 annotations = get_type_hints(self.parent, None,\n2592                                              self.config.autodoc_type_aliases)\n2593                 if self.objpath[-1] in annotations:\n2594                     objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n2595                     self.add_line('   :type: ' + objrepr, sourcename)\n2596 \n2597             try:\n2598                 if self.options.no_value or self.should_suppress_value_header():\n2599                     pass\n2600                 else:\n2601                     objrepr = object_description(self.object)\n2602                     self.add_line('   :value: ' + objrepr, sourcename)\n2603             except ValueError:\n2604                 pass\n2605 \n2606     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:\n2607         for cls in inspect.getmro(parent):\n2608             try:\n2609                 module = safe_getattr(cls, '__module__')\n2610                 qualname = safe_getattr(cls, '__qualname__')\n2611 \n2612                 analyzer = ModuleAnalyzer.for_module(module)\n2613                 analyzer.analyze()\n2614                 if qualname and self.objpath:\n2615                     key = (qualname, attrname)\n2616                     if key in analyzer.attr_docs:\n2617                         return list(analyzer.attr_docs[key])\n2618             except (AttributeError, PycodeError):\n2619                 pass\n2620 \n2621         return None\n2622 \n2623     def get_doc(self, ignore: int = None) -> Optional[List[List[str]]]:\n2624         # Check the attribute has a docstring-comment\n2625         comment = self.get_attribute_comment(self.parent, self.objpath[-1])\n2626         if comment:\n2627             return [comment]\n2628 \n2629         try:\n2630             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n2631             # a docstring from the value which descriptor returns unexpectedly.\n2632             # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n2633             orig = self.config.autodoc_inherit_docstrings\n2634             self.config.autodoc_inherit_docstrings = False  # type: ignore\n2635             return super().get_doc(ignore)\n2636         finally:\n2637             self.config.autodoc_inherit_docstrings = orig  # type: ignore\n2638 \n2639     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n2640                     ) -> None:\n2641         # Disable analyzing attribute comment on Documenter.add_content() to control it on\n2642         # AttributeDocumenter.add_content()\n2643         self.analyzer = None\n2644 \n2645         if more_content is None:\n2646             more_content = StringList()\n2647         self.update_content(more_content)\n2648         super().add_content(more_content, no_docstring)\n2649 \n2650 \n2651 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2652     \"\"\"\n2653     Specialized Documenter subclass for properties.\n2654     \"\"\"\n2655     objtype = 'property'\n2656     member_order = 60\n2657 \n2658     # before AttributeDocumenter\n2659     priority = AttributeDocumenter.priority + 1\n2660 \n2661     @classmethod\n2662     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2663                             ) -> bool:\n2664         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n2665 \n2666     def document_members(self, all_members: bool = False) -> None:\n2667         pass\n2668 \n2669     def get_real_modname(self) -> str:\n2670         real_modname = self.get_attr(self.parent or self.object, '__module__', None)\n2671         return real_modname or self.modname\n2672 \n2673     def add_directive_header(self, sig: str) -> None:\n2674         super().add_directive_header(sig)\n2675         sourcename = self.get_sourcename()\n2676         if inspect.isabstractmethod(self.object):\n2677             self.add_line('   :abstractmethod:', sourcename)\n2678 \n2679         if safe_getattr(self.object, 'fget', None) and self.config.autodoc_typehints != 'none':\n2680             try:\n2681                 signature = inspect.signature(self.object.fget,\n2682                                               type_aliases=self.config.autodoc_type_aliases)\n2683                 if signature.return_annotation is not Parameter.empty:\n2684                     objrepr = stringify_typehint(signature.return_annotation)\n2685                     self.add_line('   :type: ' + objrepr, sourcename)\n2686             except TypeError as exc:\n2687                 logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n2688                                self.fullname, exc)\n2689                 return None\n2690             except ValueError:\n2691                 return None\n2692 \n2693 \n2694 class NewTypeAttributeDocumenter(AttributeDocumenter):\n2695     \"\"\"\n2696     Specialized Documenter subclass for NewTypes.\n2697 \n2698     Note: This must be invoked before MethodDocumenter because NewType is a kind of\n2699     function object.\n2700     \"\"\"\n2701 \n2702     objtype = 'newvarattribute'\n2703     directivetype = 'attribute'\n2704     priority = MethodDocumenter.priority + 1\n2705 \n2706     @classmethod\n2707     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2708                             ) -> bool:\n2709         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)\n2710 \n2711 \n2712 def get_documenters(app: Sphinx) -> Dict[str, Type[Documenter]]:\n2713     \"\"\"Returns registered Documenter classes\"\"\"\n2714     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n2715     return app.registry.documenters\n2716 \n2717 \n2718 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n2719     \"\"\"Alternative getattr() for types\"\"\"\n2720     for typ, func in app.registry.autodoc_attrgettrs.items():\n2721         if isinstance(obj, typ):\n2722             return func(obj, name, *defargs)\n2723 \n2724     return safe_getattr(obj, name, *defargs)\n2725 \n2726 \n2727 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n2728     if config.autodoc_member_order == 'alphabetic':\n2729         # RemovedInSphinx50Warning\n2730         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n2731                           'instead of \"alphabetic\". Please update your setting.'))\n2732         config.autodoc_member_order = 'alphabetical'  # type: ignore\n2733 \n2734 \n2735 # for compatibility\n2736 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n2737 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n2738 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n2739 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n2740 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n2741 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n2742 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n2743 \n2744 \n2745 def setup(app: Sphinx) -> Dict[str, Any]:\n2746     app.add_autodocumenter(ModuleDocumenter)\n2747     app.add_autodocumenter(ClassDocumenter)\n2748     app.add_autodocumenter(ExceptionDocumenter)\n2749     app.add_autodocumenter(DataDocumenter)\n2750     app.add_autodocumenter(NewTypeDataDocumenter)\n2751     app.add_autodocumenter(FunctionDocumenter)\n2752     app.add_autodocumenter(DecoratorDocumenter)\n2753     app.add_autodocumenter(MethodDocumenter)\n2754     app.add_autodocumenter(AttributeDocumenter)\n2755     app.add_autodocumenter(PropertyDocumenter)\n2756     app.add_autodocumenter(NewTypeAttributeDocumenter)\n2757 \n2758     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n2759     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n2760                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n2761     app.add_config_value('autodoc_class_signature', 'mixed', True, ENUM('mixed', 'separated'))\n2762     app.add_config_value('autodoc_default_options', {}, True)\n2763     app.add_config_value('autodoc_docstring_signature', True, True)\n2764     app.add_config_value('autodoc_mock_imports', [], True)\n2765     app.add_config_value('autodoc_typehints', \"signature\", True,\n2766                          ENUM(\"signature\", \"description\", \"none\", \"both\"))\n2767     app.add_config_value('autodoc_typehints_description_target', 'all', True,\n2768                          ENUM('all', 'documented'))\n2769     app.add_config_value('autodoc_type_aliases', {}, True)\n2770     app.add_config_value('autodoc_warningiserror', True, True)\n2771     app.add_config_value('autodoc_inherit_docstrings', True, True)\n2772     app.add_event('autodoc-before-process-signature')\n2773     app.add_event('autodoc-process-docstring')\n2774     app.add_event('autodoc-process-signature')\n2775     app.add_event('autodoc-skip-member')\n2776     app.add_event('autodoc-process-bases')\n2777 \n2778     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n2779 \n2780     app.setup_extension('sphinx.ext.autodoc.preserve_defaults')\n2781     app.setup_extension('sphinx.ext.autodoc.type_comment')\n2782     app.setup_extension('sphinx.ext.autodoc.typehints')\n2783 \n2784     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "Ensure that the logic within this module accounts for Python\u2019s changed behavior in 3.10 regarding attribute inheritance by `@staticmethod` and `@classmethod`, which affects documentation. A patch here might explicitly handle or better recognize `@classmethod` combined with `@property`."
    }
]