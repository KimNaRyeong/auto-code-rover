2025-10-17 14:41:40.343 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 14:41:44.040 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2789, output_tokens=12, cost=0.028250
2025-10-17 14:41:56.975 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2969, output_tokens=515, cost=0.045140
2025-10-17 14:41:58.299 | INFO     | registered non reproducing test 0
2025-10-17 14:42:14.948 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3758, output_tokens=645, cost=0.056930
2025-10-17 14:42:16.247 | INFO     | registered non reproducing test 1
2025-10-17 14:42:30.638 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3888, output_tokens=631, cost=0.057810
2025-10-17 14:42:31.935 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:42:39.509 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2927, output_tokens=294, cost=0.038090
2025-10-17 14:42:39.516 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:42:41.757 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=648, output_tokens=31, cost=0.007410
2025-10-17 14:42:41.758 | DEBUG    | Extracted a valid json.
2025-10-17 14:42:41.764 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"to_rgba\")", "search_method(\"_upcast_err\")"],
    "bug_locations": []
}
2025-10-17 14:42:41.828 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:42:41.829 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:43:01.424 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6452, output_tokens=712, cost=0.085880
2025-10-17 14:43:01.437 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:43:11.590 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7380, output_tokens=342, cost=0.084060
2025-10-17 14:43:11.598 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:43:19.534 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=696, output_tokens=315, cost=0.016410
2025-10-17 14:43:19.535 | DEBUG    | Extracted a valid json.
2025-10-17 14:43:19.535 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/colors.py",
            "class": "",
            "method": "to_rgba",
            "intended_behavior": "The method should include a more explicit handling or normalization of NaN values to ensure consistent behavior across different inputs. Specifically, it should ensure that when a color value (input) is entirely NaN, it is treated the same way as when only some of the values are NaN, possibly by setting a default behavior that does not raise warnings or errors unexpectedly. This involves checking inputs for being all NaN and deciding how to represent them as RGBA values without causing numpy or matplotlib internal functions to emit warnings."
        },
        {
            "file": "lib/matplotlib/axes/_axes.py",
            "class": "Axes",
            "method": "_upcast_err",
            "intended_behavior": "This method needs to handle the scenario where all error values (`yerr` or `xerr`) are NaN, without raising a `StopIteration` exception. Instead of attempting to find a first non-NaN value directly (which fails for all-NaN inputs), the method could first check if the iterable contains only NaN values and handle this case appropriately. For instance, it could default to treating the input as if no error was specified or represent the error in a consistent manner that does not depend on finding a non-NaN value. This way, the method preserves functionality for valid inputs while gracefully managing edge cases involving NaN values."
        }
    ]
}
2025-10-17 14:43:19.565 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>to_rgba</method>
<code>
266 def to_rgba(c, alpha=None):
267     """
268     Convert *c* to an RGBA color.
269 
270     Parameters
271     ----------
272     c : Matplotlib color or ``np.ma.masked``
273 
274     alpha : float, optional
275         If *alpha* is given, force the alpha value of the returned RGBA tuple
276         to *alpha*.
277 
278         If None, the alpha value from *c* is used. If *c* does not have an
279         alpha channel, then alpha defaults to 1.
280 
281         *alpha* is ignored for the color value ``"none"`` (case-insensitive),
282         which always maps to ``(0, 0, 0, 0)``.
283 
284     Returns
285     -------
286     tuple
287         Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
288         alpha) can assume values between 0 and 1.
289     """
290     # Special-case nth color syntax because it should not be cached.
291     if _is_nth_color(c):
292         prop_cycler = mpl.rcParams['axes.prop_cycle']
293         colors = prop_cycler.by_key().get('color', ['k'])
294         c = colors[int(c[1:]) % len(colors)]
295     try:
296         rgba = _colors_full_map.cache[c, alpha]
297     except (KeyError, TypeError):  # Not in cache, or unhashable.
298         rgba = None
299     if rgba is None:  # Suppress exception chaining of cache lookup failure.
300         rgba = _to_rgba_no_colorcycle(c, alpha)
301         try:
302             _colors_full_map.cache[c, alpha] = rgba
303         except TypeError:
304             pass
305     return rgba

</code><intended_behavior>The method should include a more explicit handling or normalization of NaN values to ensure consistent behavior across different inputs. Specifically, it should ensure that when a color value (input) is entirely NaN, it is treated the same way as when only some of the values are NaN, possibly by setting a default behavior that does not raise warnings or errors unexpectedly. This involves checking inputs for being all NaN and deciding how to represent them as RGBA values without causing numpy or matplotlib internal functions to emit warnings.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>_upcast_err</method>
<code>
3468         def _upcast_err(err):
3469             """
3470             Safely handle tuple of containers that carry units.
3471 
3472             This function covers the case where the input to the xerr/yerr is a
3473             length 2 tuple of equal length ndarray-subclasses that carry the
3474             unit information in the container.
3475 
3476             If we have a tuple of nested numpy array (subclasses), we defer
3477             coercing the units to be consistent to the underlying unit
3478             library (and implicitly the broadcasting).
3479 
3480             Otherwise, fallback to casting to an object array.
3481             """
3482 
3483             if (
3484                     # make sure it is not a scalar
3485                     np.iterable(err) and
3486                     # and it is not empty
3487                     len(err) > 0 and
3488                     # and the first element is an array sub-class use
3489                     # safe_first_element because getitem is index-first not
3490                     # location first on pandas objects so err[0] almost always
3491                     # fails.
3492                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3493             ):
3494                 # Get the type of the first element
3495                 atype = type(cbook._safe_first_finite(err))
3496                 # Promote the outer container to match the inner container
3497                 if atype is np.ndarray:
3498                     # Converts using np.asarray, because data cannot
3499                     # be directly passed to init of np.ndarray
3500                     return np.asarray(err, dtype=object)
3501                 # If atype is not np.ndarray, directly pass data to init.
3502                 # This works for types such as unyts and astropy units
3503                 return atype(err)
3504             # Otherwise wrap it in an object array
3505             return np.asarray(err, dtype=object)

</code><intended_behavior>This method needs to handle the scenario where all error values (`yerr` or `xerr`) are NaN, without raising a `StopIteration` exception. Instead of attempting to find a first non-NaN value directly (which fails for all-NaN inputs), the method could first check if the iterable contains only NaN values and handle this case appropriately. For instance, it could default to treating the input as if no error was specified or represent the error in a consistent manner that does not depend on finding a non-NaN value. This way, the method preserves functionality for valid inputs while gracefully managing edge cases involving NaN values.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119             A dictionary controlling the appearance of the title text,
120             the default *fontdict* is::
121 
122                {'fontsize': rcParams['axes.titlesize'],
123                 'fontweight': rcParams['axes.titleweight'],
124                 'color': rcParams['axes.titlecolor'],
125                 'verticalalignment': 'baseline',
126                 'horizontalalignment': loc}
127 
128         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
129             Which title to set.
130 
131         y : float, default: :rc:`axes.titley`
132             Vertical Axes location for the title (1.0 is the top).  If
133             None (the default) and :rc:`axes.titley` is also None, y is
134             determined automatically to avoid decorators on the Axes.
135 
136         pad : float, default: :rc:`axes.titlepad`
137             The offset of the title from the top of the Axes, in points.
138 
139         Returns
140         -------
141         `.Text`
142             The matplotlib text instance representing the title
143 
144         Other Parameters
145         ----------------
146         **kwargs : `.Text` properties
147             Other keyword arguments are text properties, see `.Text` for a list
148             of valid text properties.
149         """
150         if loc is None:
151             loc = mpl.rcParams['axes.titlelocation']
152 
153         if y is None:
154             y = mpl.rcParams['axes.titley']
155         if y is None:
156             y = 1.0
157         else:
158             self._autotitlepos = False
159         kwargs['y'] = y
160 
161         titles = {'left': self._left_title,
162                   'center': self.title,
163                   'right': self._right_title}
164         title = _api.check_getitem(titles, loc=loc.lower())
165         default = {
166             'fontsize': mpl.rcParams['axes.titlesize'],
167             'fontweight': mpl.rcParams['axes.titleweight'],
168             'verticalalignment': 'baseline',
169             'horizontalalignment': loc.lower()}
170         titlecolor = mpl.rcParams['axes.titlecolor']
171         if not cbook._str_lower_equal(titlecolor, 'auto'):
172             default["color"] = titlecolor
173         if pad is None:
174             pad = mpl.rcParams['axes.titlepad']
175         self._set_title_offset_trans(float(pad))
176         title.set_text(label)
177         title.update(default)
178         if fontdict is not None:
179             title.update(fontdict)
180         title._internal_update(kwargs)
181         return title
182 
183     def get_legend_handles_labels(self, legend_handler_map=None):
184         """
185         Return handles and labels for legend
186 
187         ``ax.legend()`` is equivalent to ::
188 
189           h, l = ax.get_legend_handles_labels()
190           ax.legend(h, l)
191         """
192         # pass through to legend.
193         handles, labels = mlegend._get_legend_handles_labels(
194             [self], legend_handler_map)
195         return handles, labels
196 
197     @_docstring.dedent_interpd
198     def legend(self, *args, **kwargs):
199         """
200         Place a legend on the Axes.
201 
202         Call signatures::
203 
204             legend()
205             legend(handles, labels)
206             legend(handles=handles)
207             legend(labels)
208 
209         The call signatures correspond to the following different ways to use
210         this method:
211 
212         **1. Automatic detection of elements to be shown in the legend**
213 
214         The elements to be added to the legend are automatically determined,
215         when you do not pass in any extra arguments.
216 
217         In this case, the labels are taken from the artist. You can specify
218         them either at artist creation or by calling the
219         :meth:`~.Artist.set_label` method on the artist::
220 
221             ax.plot([1, 2, 3], label='Inline label')
222             ax.legend()
223 
224         or::
225 
226             line, = ax.plot([1, 2, 3])
227             line.set_label('Label via method')
228             ax.legend()
229 
230         .. note::
231             Specific artists can be excluded from the automatic legend element
232             selection by using a label starting with an underscore, "_".
233             A string starting with an underscore is the default label for all
234             artists, so calling `.Axes.legend` without any arguments and
235             without setting the labels manually will result in no legend being
236             drawn.
237 
238 
239         **2. Explicitly listing the artists and labels in the legend**
240 
241         For full control of which artists have a legend entry, it is possible
242         to pass an iterable of legend artists followed by an iterable of
243         legend labels respectively::
244 
245             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
246 
247 
248         **3. Explicitly listing the artists in the legend**
249 
250         This is similar to 2, but the labels are taken from the artists'
251         label properties. Example::
252 
253             line1, = ax.plot([1, 2, 3], label='label1')
254             line2, = ax.plot([1, 2, 3], label='label2')
255             ax.legend(handles=[line1, line2])
256 
257 
258         **4. Labeling existing plot elements**
259 
260         .. admonition:: Discouraged
261 
262             This call signature is discouraged, because the relation between
263             plot elements and labels is only implicit by their order and can
264             easily be mixed up.
265 
266         To make a legend for all artists on an Axes, call this function with
267         an iterable of strings, one for each legend item. For example::
268 
269             ax.plot([1, 2, 3])
270             ax.plot([5, 6, 7])
271             ax.legend(['First line', 'Second line'])
272 
273 
274         Parameters
275         ----------
276         handles : sequence of `.Artist`, optional
277             A list of Artists (lines, patches) to be added to the legend.
278             Use this together with *labels*, if you need full control on what
279             is shown in the legend and the automatic mechanism described above
280             is not sufficient.
281 
282             The length of handles and labels should be the same in this
283             case. If they are not, they are truncated to the smaller length.
284 
285         labels : list of str, optional
286             A list of labels to show next to the artists.
287             Use this together with *handles*, if you need full control on what
288             is shown in the legend and the automatic mechanism described above
289             is not sufficient.
290 
291         Returns
292         -------
293         `~matplotlib.legend.Legend`
294 
295         Other Parameters
296         ----------------
297         %(_legend_kw_axes)s
298 
299         See Also
300         --------
301         .Figure.legend
302 
303         Notes
304         -----
305         Some artists are not supported by this function.  See
306         :ref:`legend_guide` for details.
307 
308         Examples
309         --------
310         .. plot:: gallery/text_labels_and_annotations/legend.py
311         """
312         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
313                 [self],
314                 *args,
315                 **kwargs)
316         if len(extra_args):
317             _api.nargs_error('legend', '0-2', len(args))
318         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
319         self.legend_._remove_method = self._remove_legend
320         return self.legend_
321 
322     def _remove_legend(self, legend):
323         self.legend_ = None
324 
325     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
326         """
327         Add a child inset Axes to this existing Axes.
328 
329         Warnings
330         --------
331         This method is experimental as of 3.0, and the API may change.
332 
333         Parameters
334         ----------
335         bounds : [x0, y0, width, height]
336             Lower-left corner of inset Axes, and its width and height.
337 
338         transform : `.Transform`
339             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
340             Axes-relative coordinates.
341 
342         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
343 'polar', 'rectilinear', str}, optional
344             The projection type of the inset `~.axes.Axes`. *str* is the name
345             of a custom projection, see `~matplotlib.projections`. The default
346             None results in a 'rectilinear' projection.
347 
348         polar : bool, default: False
349             If True, equivalent to projection='polar'.
350 
351         axes_class : subclass type of `~.axes.Axes`, optional
352             The `.axes.Axes` subclass that is instantiated.  This parameter
353             is incompatible with *projection* and *polar*.  See
354             :ref:`axisartist_users-guide-index` for examples.
355 
356         zorder : number
357             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
358             to change whether it is above or below data plotted on the
359             parent Axes.
360 
361         **kwargs
362             Other keyword arguments are passed on to the inset Axes class.
363 
364         Returns
365         -------
366         ax
367             The created `~.axes.Axes` instance.
368 
369         Examples
370         --------
371         This example makes two inset Axes, the first is in Axes-relative
372         coordinates, and the second in data-coordinates::
373 
374             fig, ax = plt.subplots()
375             ax.plot(range(10))
376             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
377             axin2 = ax.inset_axes(
378                     [5, 7, 2.3, 2.3], transform=ax.transData)
379 
380         """
381         if transform is None:
382             transform = self.transAxes
383         kwargs.setdefault('label', 'inset_axes')
384 
385         # This puts the rectangle into figure-relative coordinates.
386         inset_locator = _TransformedBoundsLocator(bounds, transform)
387         bounds = inset_locator(self, None).bounds
388         projection_class, pkw = self.figure._process_projection_requirements(
389                 bounds, **kwargs)
390         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
391 
392         # this locator lets the axes move if in data coordinates.
393         # it gets called in `ax.apply_aspect() (of all places)
394         inset_ax.set_axes_locator(inset_locator)
395 
396         self.add_child_axes(inset_ax)
397 
398         return inset_ax
399 
400     @_docstring.dedent_interpd
401     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
402                        facecolor='none', edgecolor='0.5', alpha=0.5,
403                        zorder=4.99, **kwargs):
404         """
405         Add an inset indicator to the Axes.  This is a rectangle on the plot
406         at the position indicated by *bounds* that optionally has lines that
407         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
408 
409         Warnings
410         --------
411         This method is experimental as of 3.0, and the API may change.
412 
413         Parameters
414         ----------
415         bounds : [x0, y0, width, height]
416             Lower-left corner of rectangle to be marked, and its width
417             and height.
418 
419         inset_ax : `.Axes`
420             An optional inset Axes to draw connecting lines to.  Two lines are
421             drawn connecting the indicator box to the inset Axes on corners
422             chosen so as to not overlap with the indicator box.
423 
424         transform : `.Transform`
425             Transform for the rectangle coordinates. Defaults to
426             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
427             coordinates.
428 
429         facecolor : color, default: 'none'
430             Facecolor of the rectangle.
431 
432         edgecolor : color, default: '0.5'
433             Color of the rectangle and color of the connecting lines.
434 
435         alpha : float, default: 0.5
436             Transparency of the rectangle and connector lines.
437 
438         zorder : float, default: 4.99
439             Drawing order of the rectangle and connector lines.  The default,
440             4.99, is just below the default level of inset Axes.
441 
442         **kwargs
443             Other keyword arguments are passed on to the `.Rectangle` patch:
444 
445             %(Rectangle:kwdoc)s
446 
447         Returns
448         -------
449         rectangle_patch : `.patches.Rectangle`
450              The indicator frame.
451 
452         connector_lines : 4-tuple of `.patches.ConnectionPatch`
453             The four connector lines connecting to (lower_left, upper_left,
454             lower_right upper_right) corners of *inset_ax*. Two lines are
455             set with visibility to *False*,  but the user can set the
456             visibility to True if the automatic choice is not deemed correct.
457 
458         """
459         # to make the axes connectors work, we need to apply the aspect to
460         # the parent axes.
461         self.apply_aspect()
462 
463         if transform is None:
464             transform = self.transData
465         kwargs.setdefault('label', '_indicate_inset')
466 
467         x, y, width, height = bounds
468         rectangle_patch = mpatches.Rectangle(
469             (x, y), width, height,
470             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
471             zorder=zorder, transform=transform, **kwargs)
472         self.add_patch(rectangle_patch)
473 
474         connects = []
475 
476         if inset_ax is not None:
477             # connect the inset_axes to the rectangle
478             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
479                 # inset_ax positions are in axes coordinates
480                 # The 0, 1 values define the four edges if the inset_ax
481                 # lower_left, upper_left, lower_right upper_right.
482                 ex, ey = xy_inset_ax
483                 if self.xaxis.get_inverted():
484                     ex = 1 - ex
485                 if self.yaxis.get_inverted():
486                     ey = 1 - ey
487                 xy_data = x + ex * width, y + ey * height
488                 p = mpatches.ConnectionPatch(
489                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
490                     xyB=xy_data, coordsB=self.transData,
491                     arrowstyle="-", zorder=zorder,
492                     edgecolor=edgecolor, alpha=alpha)
493                 connects.append(p)
494                 self.add_patch(p)
495 
496             # decide which two of the lines to keep visible....
497             pos = inset_ax.get_position()
498             bboxins = pos.transformed(self.figure.transSubfigure)
499             rectbbox = mtransforms.Bbox.from_bounds(
500                 *bounds
501             ).transformed(transform)
502             x0 = rectbbox.x0 < bboxins.x0
503             x1 = rectbbox.x1 < bboxins.x1
504             y0 = rectbbox.y0 < bboxins.y0
505             y1 = rectbbox.y1 < bboxins.y1
506             connects[0].set_visible(x0 ^ y0)
507             connects[1].set_visible(x0 == y1)
508             connects[2].set_visible(x1 == y0)
509             connects[3].set_visible(x1 ^ y1)
510 
511         return rectangle_patch, tuple(connects) if connects else None
512 
513     def indicate_inset_zoom(self, inset_ax, **kwargs):
514         """
515         Add an inset indicator rectangle to the Axes based on the axis
516         limits for an *inset_ax* and draw connectors between *inset_ax*
517         and the rectangle.
518 
519         Warnings
520         --------
521         This method is experimental as of 3.0, and the API may change.
522 
523         Parameters
524         ----------
525         inset_ax : `.Axes`
526             Inset Axes to draw connecting lines to.  Two lines are
527             drawn connecting the indicator box to the inset Axes on corners
528             chosen so as to not overlap with the indicator box.
529 
530         **kwargs
531             Other keyword arguments are passed on to `.Axes.indicate_inset`
532 
533         Returns
534         -------
535         rectangle_patch : `.patches.Rectangle`
536              Rectangle artist.
537 
538         connector_lines : 4-tuple of `.patches.ConnectionPatch`
539             Each of four connector lines coming from the rectangle drawn on
540             this axis, in the order lower left, upper left, lower right,
541             upper right.
542             Two are set with visibility to *False*,  but the user can
543             set the visibility to *True* if the automatic choice is not deemed
544             correct.
545         """
546 
547         xlim = inset_ax.get_xlim()
548         ylim = inset_ax.get_ylim()
549         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
550         return self.indicate_inset(rect, inset_ax, **kwargs)
551 
552     @_docstring.dedent_interpd
553     def secondary_xaxis(self, location, *, functions=None, **kwargs):
554         """
555         Add a second x-axis to this `~.axes.Axes`.
556 
557         For example if we want to have a second scale for the data plotted on
558         the xaxis.
559 
560         %(_secax_docstring)s
561 
562         Examples
563         --------
564         The main axis shows frequency, and the secondary axis shows period.
565 
566         .. plot::
567 
568             fig, ax = plt.subplots()
569             ax.loglog(range(1, 360, 5), range(1, 360, 5))
570             ax.set_xlabel('frequency [Hz]')
571 
572             def invert(x):
573                 # 1/x with special treatment of x == 0
574                 x = np.array(x).astype(float)
575                 near_zero = np.isclose(x, 0)
576                 x[near_zero] = np.inf
577                 x[~near_zero] = 1 / x[~near_zero]
578                 return x
579 
580             # the inverse of 1/x is itself
581             secax = ax.secondary_xaxis('top', functions=(invert, invert))
582             secax.set_xlabel('Period [s]')
583             plt.show()
584         """
585         if location in ['top', 'bottom'] or isinstance(location, Real):
586             secondary_ax = SecondaryAxis(self, 'x', location, functions,
587                                          **kwargs)
588             self.add_child_axes(secondary_ax)
589             return secondary_ax
590         else:
591             raise ValueError('secondary_xaxis location must be either '
592                              'a float or "top"/"bottom"')
593 
594     @_docstring.dedent_interpd
595     def secondary_yaxis(self, location, *, functions=None, **kwargs):
596         """
597         Add a second y-axis to this `~.axes.Axes`.
598 
599         For example if we want to have a second scale for the data plotted on
600         the yaxis.
601 
602         %(_secax_docstring)s
603 
604         Examples
605         --------
606         Add a secondary Axes that converts from radians to degrees
607 
608         .. plot::
609 
610             fig, ax = plt.subplots()
611             ax.plot(range(1, 360, 5), range(1, 360, 5))
612             ax.set_ylabel('degrees')
613             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
614                                                            np.rad2deg))
615             secax.set_ylabel('radians')
616         """
617         if location in ['left', 'right'] or isinstance(location, Real):
618             secondary_ax = SecondaryAxis(self, 'y', location,
619                                          functions, **kwargs)
620             self.add_child_axes(secondary_ax)
621             return secondary_ax
622         else:
623             raise ValueError('secondary_yaxis location must be either '
624                              'a float or "left"/"right"')
625 
626     @_docstring.dedent_interpd
627     def text(self, x, y, s, fontdict=None, **kwargs):
628         """
629         Add text to the Axes.
630 
631         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
632 
633         Parameters
634         ----------
635         x, y : float
636             The position to place the text. By default, this is in data
637             coordinates. The coordinate system can be changed using the
638             *transform* parameter.
639 
640         s : str
641             The text.
642 
643         fontdict : dict, default: None
644             A dictionary to override the default text properties. If fontdict
645             is None, the defaults are determined by `.rcParams`.
646 
647         Returns
648         -------
649         `.Text`
650             The created `.Text` instance.
651 
652         Other Parameters
653         ----------------
654         **kwargs : `~matplotlib.text.Text` properties.
655             Other miscellaneous text parameters.
656 
657             %(Text:kwdoc)s
658 
659         Examples
660         --------
661         Individual keyword arguments can be used to override any given
662         parameter::
663 
664             >>> text(x, y, s, fontsize=12)
665 
666         The default transform specifies that text is in data coords,
667         alternatively, you can specify text in axis coords ((0, 0) is
668         lower-left and (1, 1) is upper-right).  The example below places
669         text in the center of the Axes::
670 
671             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
672             ...      verticalalignment='center', transform=ax.transAxes)
673 
674         You can put a rectangular box around the text instance (e.g., to
675         set a background color) by using the keyword *bbox*.  *bbox* is
676         a dictionary of `~matplotlib.patches.Rectangle`
677         properties.  For example::
678 
679             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
680         """
681         effective_kwargs = {
682             'verticalalignment': 'baseline',
683             'horizontalalignment': 'left',
684             'transform': self.transData,
685             'clip_on': False,
686             **(fontdict if fontdict is not None else {}),
687             **kwargs,
688         }
689         t = mtext.Text(x, y, text=s, **effective_kwargs)
690         if t.get_clip_path() is None:
691             t.set_clip_path(self.patch)
692         self._add_text(t)
693         return t
694 
695     @_docstring.dedent_interpd
696     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
697                  arrowprops=None, annotation_clip=None, **kwargs):
698         # Signature must match Annotation. This is verified in
699         # test_annotate_signature().
700         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
701                              textcoords=textcoords, arrowprops=arrowprops,
702                              annotation_clip=annotation_clip, **kwargs)
703         a.set_transform(mtransforms.IdentityTransform())
704         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
705             a.set_clip_path(self.patch)
706         self._add_text(a)
707         return a
708     annotate.__doc__ = mtext.Annotation.__init__.__doc__
709     #### Lines and spans
710 
711     @_docstring.dedent_interpd
712     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
713         """
714         Add a horizontal line across the Axes.
715 
716         Parameters
717         ----------
718         y : float, default: 0
719             y position in data coordinates of the horizontal line.
720 
721         xmin : float, default: 0
722             Should be between 0 and 1, 0 being the far left of the plot, 1 the
723             far right of the plot.
724 
725         xmax : float, default: 1
726             Should be between 0 and 1, 0 being the far left of the plot, 1 the
727             far right of the plot.
728 
729         Returns
730         -------
731         `~matplotlib.lines.Line2D`
732 
733         Other Parameters
734         ----------------
735         **kwargs
736             Valid keyword arguments are `.Line2D` properties, except for
737             'transform':
738 
739             %(Line2D:kwdoc)s
740 
741         See Also
742         --------
743         hlines : Add horizontal lines in data coordinates.
744         axhspan : Add a horizontal span (rectangle) across the axis.
745         axline : Add a line with an arbitrary slope.
746 
747         Examples
748         --------
749         * draw a thick red hline at 'y' = 0 that spans the xrange::
750 
751             >>> axhline(linewidth=4, color='r')
752 
753         * draw a default hline at 'y' = 1 that spans the xrange::
754 
755             >>> axhline(y=1)
756 
757         * draw a default hline at 'y' = .5 that spans the middle half of
758           the xrange::
759 
760             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
761         """
762         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
763         if "transform" in kwargs:
764             raise ValueError("'transform' is not allowed as a keyword "
765                              "argument; axhline generates its own transform.")
766         ymin, ymax = self.get_ybound()
767 
768         # Strip away the units for comparison with non-unitized bounds.
769         yy, = self._process_unit_info([("y", y)], kwargs)
770         scaley = (yy < ymin) or (yy > ymax)
771 
772         trans = self.get_yaxis_transform(which='grid')
773         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
774         self.add_line(l)
775         if scaley:
776             self._request_autoscale_view("y")
777         return l
778 
779     @_docstring.dedent_interpd
780     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
781         """
782         Add a vertical line across the Axes.
783 
784         Parameters
785         ----------
786         x : float, default: 0
787             x position in data coordinates of the vertical line.
788 
789         ymin : float, default: 0
790             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
791             top of the plot.
792 
793         ymax : float, default: 1
794             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
795             top of the plot.
796 
797         Returns
798         -------
799         `~matplotlib.lines.Line2D`
800 
801         Other Parameters
802         ----------------
803         **kwargs
804             Valid keyword arguments are `.Line2D` properties, except for
805             'transform':
806 
807             %(Line2D:kwdoc)s
808 
809         See Also
810         --------
811         vlines : Add vertical lines in data coordinates.
812         axvspan : Add a vertical span (rectangle) across the axis.
813         axline : Add a line with an arbitrary slope.
814 
815         Examples
816         --------
817         * draw a thick red vline at *x* = 0 that spans the yrange::
818 
819             >>> axvline(linewidth=4, color='r')
820 
821         * draw a default vline at *x* = 1 that spans the yrange::
822 
823             >>> axvline(x=1)
824 
825         * draw a default vline at *x* = .5 that spans the middle half of
826           the yrange::
827 
828             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
829         """
830         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
831         if "transform" in kwargs:
832             raise ValueError("'transform' is not allowed as a keyword "
833                              "argument; axvline generates its own transform.")
834         xmin, xmax = self.get_xbound()
835 
836         # Strip away the units for comparison with non-unitized bounds.
837         xx, = self._process_unit_info([("x", x)], kwargs)
838         scalex = (xx < xmin) or (xx > xmax)
839 
840         trans = self.get_xaxis_transform(which='grid')
841         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
842         self.add_line(l)
843         if scalex:
844             self._request_autoscale_view("x")
845         return l
846 
847     @staticmethod
848     def _check_no_units(vals, names):
849         # Helper method to check that vals are not unitized
850         for val, name in zip(vals, names):
851             if not munits._is_natively_supported(val):
852                 raise ValueError(f"{name} must be a single scalar value, "
853                                  f"but got {val}")
854 
855     @_docstring.dedent_interpd
856     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
857         """
858         Add an infinitely long straight line.
859 
860         The line can be defined either by two points *xy1* and *xy2*, or
861         by one point *xy1* and a *slope*.
862 
863         This draws a straight line "on the screen", regardless of the x and y
864         scales, and is thus also suitable for drawing exponential decays in
865         semilog plots, power laws in loglog plots, etc. However, *slope*
866         should only be used with linear scales; It has no clear meaning for
867         all other scales, and thus the behavior is undefined. Please specify
868         the line using the points *xy1*, *xy2* for non-linear scales.
869 
870         The *transform* keyword argument only applies to the points *xy1*,
871         *xy2*. The *slope* (if given) is always in data coordinates. This can
872         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
873         slope.
874 
875         Parameters
876         ----------
877         xy1, xy2 : (float, float)
878             Points for the line to pass through.
879             Either *xy2* or *slope* has to be given.
880         slope : float, optional
881             The slope of the line. Either *xy2* or *slope* has to be given.
882 
883         Returns
884         -------
885         `.Line2D`
886 
887         Other Parameters
888         ----------------
889         **kwargs
890             Valid kwargs are `.Line2D` properties
891 
892             %(Line2D:kwdoc)s
893 
894         See Also
895         --------
896         axhline : for horizontal lines
897         axvline : for vertical lines
898 
899         Examples
900         --------
901         Draw a thick red line passing through (0, 0) and (1, 1)::
902 
903             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
904         """
905         if slope is not None and (self.get_xscale() != 'linear' or
906                                   self.get_yscale() != 'linear'):
907             raise TypeError("'slope' cannot be used with non-linear scales")
908 
909         datalim = [xy1] if xy2 is None else [xy1, xy2]
910         if "transform" in kwargs:
911             # if a transform is passed (i.e. line points not in data space),
912             # data limits should not be adjusted.
913             datalim = []
914 
915         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
916         # Like add_line, but correctly handling data limits.
917         self._set_artist_props(line)
918         if line.get_clip_path() is None:
919             line.set_clip_path(self.patch)
920         if not line.get_label():
921             line.set_label(f"_child{len(self._children)}")
922         self._children.append(line)
923         line._remove_method = self._children.remove
924         self.update_datalim(datalim)
925 
926         self._request_autoscale_view()
927         return line
928 
929     @_docstring.dedent_interpd
930     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
931         """
932         Add a horizontal span (rectangle) across the Axes.
933 
934         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
935         the whole x-axis horizontally.  The x-span can be set using *xmin*
936         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
937         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
938         the limits set by `~.Axes.set_xlim`.
939 
940         Parameters
941         ----------
942         ymin : float
943             Lower y-coordinate of the span, in data units.
944         ymax : float
945             Upper y-coordinate of the span, in data units.
946         xmin : float, default: 0
947             Lower x-coordinate of the span, in x-axis (0-1) units.
948         xmax : float, default: 1
949             Upper x-coordinate of the span, in x-axis (0-1) units.
950 
951         Returns
952         -------
953         `~matplotlib.patches.Polygon`
954             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
955 
956         Other Parameters
957         ----------------
958         **kwargs : `~matplotlib.patches.Polygon` properties
959 
960         %(Polygon:kwdoc)s
961 
962         See Also
963         --------
964         axvspan : Add a vertical span across the Axes.
965         """
966         # Strip units away.
967         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
968         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
969 
970         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
971         p = mpatches.Polygon(verts, **kwargs)
972         p.set_transform(self.get_yaxis_transform(which="grid"))
973         self.add_patch(p)
974         self._request_autoscale_view("y")
975         return p
976 
977     @_docstring.dedent_interpd
978     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
979         """
980         Add a vertical span (rectangle) across the Axes.
981 
982         The rectangle spans from *xmin* to *xmax* horizontally, and, by
983         default, the whole y-axis vertically.  The y-span can be set using
984         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
985         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
986         regardless of the limits set by `~.Axes.set_ylim`.
987 
988         Parameters
989         ----------
990         xmin : float
991             Lower x-coordinate of the span, in data units.
992         xmax : float
993             Upper x-coordinate of the span, in data units.
994         ymin : float, default: 0
995             Lower y-coordinate of the span, in y-axis units (0-1).
996         ymax : float, default: 1
997             Upper y-coordinate of the span, in y-axis units (0-1).
998 
999         Returns
1000         -------
1001         `~matplotlib.patches.Polygon`
1002             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1003 
1004         Other Parameters
1005         ----------------
1006         **kwargs : `~matplotlib.patches.Polygon` properties
1007 
1008         %(Polygon:kwdoc)s
1009 
1010         See Also
1011         --------
1012         axhspan : Add a horizontal span across the Axes.
1013 
1014         Examples
1015         --------
1016         Draw a vertical, green, translucent rectangle from x = 1.25 to
1017         x = 1.55 that spans the yrange of the Axes.
1018 
1019         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1020 
1021         """
1022         # Strip units away.
1023         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1024         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1025 
1026         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1027         p = mpatches.Polygon(verts, **kwargs)
1028         p.set_transform(self.get_xaxis_transform(which="grid"))
1029         p.get_path()._interpolation_steps = 100
1030         self.add_patch(p)
1031         self._request_autoscale_view("x")
1032         return p
1033 
1034     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1035                       label_namer="y")
1036     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1037                label='', **kwargs):
1038         """
1039         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1040 
1041         Parameters
1042         ----------
1043         y : float or array-like
1044             y-indexes where to plot the lines.
1045 
1046         xmin, xmax : float or array-like
1047             Respective beginning and end of each line. If scalars are
1048             provided, all lines will have the same length.
1049 
1050         colors : list of colors, default: :rc:`lines.color`
1051 
1052         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1053 
1054         label : str, default: ''
1055 
1056         Returns
1057         -------
1058         `~matplotlib.collections.LineCollection`
1059 
1060         Other Parameters
1061         ----------------
1062         data : indexable object, optional
1063             DATA_PARAMETER_PLACEHOLDER
1064         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1065 
1066         See Also
1067         --------
1068         vlines : vertical lines
1069         axhline : horizontal line across the Axes
1070         """
1071 
1072         # We do the conversion first since not all unitized data is uniform
1073         xmin, xmax, y = self._process_unit_info(
1074             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1075 
1076         if not np.iterable(y):
1077             y = [y]
1078         if not np.iterable(xmin):
1079             xmin = [xmin]
1080         if not np.iterable(xmax):
1081             xmax = [xmax]
1082 
1083         # Create and combine masked_arrays from input
1084         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1085         y = np.ravel(y)
1086         xmin = np.ravel(xmin)
1087         xmax = np.ravel(xmax)
1088 
1089         masked_verts = np.ma.empty((len(y), 2, 2))
1090         masked_verts[:, 0, 0] = xmin
1091         masked_verts[:, 0, 1] = y
1092         masked_verts[:, 1, 0] = xmax
1093         masked_verts[:, 1, 1] = y
1094 
1095         lines = mcoll.LineCollection(masked_verts, colors=colors,
1096                                      linestyles=linestyles, label=label)
1097         self.add_collection(lines, autolim=False)
1098         lines._internal_update(kwargs)
1099 
1100         if len(y) > 0:
1101             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1102             # the case of y being a masked *object* array (as can be generated
1103             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1104             minx = np.nanmin(masked_verts[..., 0])
1105             maxx = np.nanmax(masked_verts[..., 0])
1106             miny = np.nanmin(masked_verts[..., 1])
1107             maxy = np.nanmax(masked_verts[..., 1])
1108             corners = (minx, miny), (maxx, maxy)
1109             self.update_datalim(corners)
1110             self._request_autoscale_view()
1111 
1112         return lines
1113 
1114     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1115                       label_namer="x")
1116     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1117                label='', **kwargs):
1118         """
1119         Plot vertical lines at each *x* from *ymin* to *ymax*.
1120 
1121         Parameters
1122         ----------
1123         x : float or array-like
1124             x-indexes where to plot the lines.
1125 
1126         ymin, ymax : float or array-like
1127             Respective beginning and end of each line. If scalars are
1128             provided, all lines will have the same length.
1129 
1130         colors : list of colors, default: :rc:`lines.color`
1131 
1132         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1133 
1134         label : str, default: ''
1135 
1136         Returns
1137         -------
1138         `~matplotlib.collections.LineCollection`
1139 
1140         Other Parameters
1141         ----------------
1142         data : indexable object, optional
1143             DATA_PARAMETER_PLACEHOLDER
1144         **kwargs : `~matplotlib.collections.LineCollection` properties.
1145 
1146         See Also
1147         --------
1148         hlines : horizontal lines
1149         axvline : vertical line across the Axes
1150         """
1151 
1152         # We do the conversion first since not all unitized data is uniform
1153         x, ymin, ymax = self._process_unit_info(
1154             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1155 
1156         if not np.iterable(x):
1157             x = [x]
1158         if not np.iterable(ymin):
1159             ymin = [ymin]
1160         if not np.iterable(ymax):
1161             ymax = [ymax]
1162 
1163         # Create and combine masked_arrays from input
1164         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1165         x = np.ravel(x)
1166         ymin = np.ravel(ymin)
1167         ymax = np.ravel(ymax)
1168 
1169         masked_verts = np.ma.empty((len(x), 2, 2))
1170         masked_verts[:, 0, 0] = x
1171         masked_verts[:, 0, 1] = ymin
1172         masked_verts[:, 1, 0] = x
1173         masked_verts[:, 1, 1] = ymax
1174 
1175         lines = mcoll.LineCollection(masked_verts, colors=colors,
1176                                      linestyles=linestyles, label=label)
1177         self.add_collection(lines, autolim=False)
1178         lines._internal_update(kwargs)
1179 
1180         if len(x) > 0:
1181             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1182             # the case of x being a masked *object* array (as can be generated
1183             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1184             minx = np.nanmin(masked_verts[..., 0])
1185             maxx = np.nanmax(masked_verts[..., 0])
1186             miny = np.nanmin(masked_verts[..., 1])
1187             maxy = np.nanmax(masked_verts[..., 1])
1188             corners = (minx, miny), (maxx, maxy)
1189             self.update_datalim(corners)
1190             self._request_autoscale_view()
1191 
1192         return lines
1193 
1194     @_preprocess_data(replace_names=["positions", "lineoffsets",
1195                                      "linelengths", "linewidths",
1196                                      "colors", "linestyles"])
1197     @_docstring.dedent_interpd
1198     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1199                   linelengths=1, linewidths=None, colors=None, alpha=None,
1200                   linestyles='solid', **kwargs):
1201         """
1202         Plot identical parallel lines at the given positions.
1203 
1204         This type of plot is commonly used in neuroscience for representing
1205         neural events, where it is usually called a spike raster, dot raster,
1206         or raster plot.
1207 
1208         However, it is useful in any situation where you wish to show the
1209         timing or position of multiple sets of discrete events, such as the
1210         arrival times of people to a business on each day of the month or the
1211         date of hurricanes each year of the last century.
1212 
1213         Parameters
1214         ----------
1215         positions : array-like or list of array-like
1216             A 1D array-like defines the positions of one sequence of events.
1217 
1218             Multiple groups of events may be passed as a list of array-likes.
1219             Each group can be styled independently by passing lists of values
1220             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1221             *linestyles*.
1222 
1223             Note that *positions* can be a 2D array, but in practice different
1224             event groups usually have different counts so that one will use a
1225             list of different-length arrays rather than a 2D array.
1226 
1227         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1228             The direction of the event sequence:
1229 
1230             - 'horizontal': the events are arranged horizontally.
1231               The indicator lines are vertical.
1232             - 'vertical': the events are arranged vertically.
1233               The indicator lines are horizontal.
1234 
1235         lineoffsets : float or array-like, default: 1
1236             The offset of the center of the lines from the origin, in the
1237             direction orthogonal to *orientation*.
1238 
1239             If *positions* is 2D, this can be a sequence with length matching
1240             the length of *positions*.
1241 
1242         linelengths : float or array-like, default: 1
1243             The total height of the lines (i.e. the lines stretches from
1244             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1245 
1246             If *positions* is 2D, this can be a sequence with length matching
1247             the length of *positions*.
1248 
1249         linewidths : float or array-like, default: :rc:`lines.linewidth`
1250             The line width(s) of the event lines, in points.
1251 
1252             If *positions* is 2D, this can be a sequence with length matching
1253             the length of *positions*.
1254 
1255         colors : color or list of colors, default: :rc:`lines.color`
1256             The color(s) of the event lines.
1257 
1258             If *positions* is 2D, this can be a sequence with length matching
1259             the length of *positions*.
1260 
1261         alpha : float or array-like, default: 1
1262             The alpha blending value(s), between 0 (transparent) and 1
1263             (opaque).
1264 
1265             If *positions* is 2D, this can be a sequence with length matching
1266             the length of *positions*.
1267 
1268         linestyles : str or tuple or list of such values, default: 'solid'
1269             Default is 'solid'. Valid strings are ['solid', 'dashed',
1270             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1271             should be of the form::
1272 
1273                 (offset, onoffseq),
1274 
1275             where *onoffseq* is an even length tuple of on and off ink
1276             in points.
1277 
1278             If *positions* is 2D, this can be a sequence with length matching
1279             the length of *positions*.
1280 
1281         data : indexable object, optional
1282             DATA_PARAMETER_PLACEHOLDER
1283 
1284         **kwargs
1285             Other keyword arguments are line collection properties.  See
1286             `.LineCollection` for a list of the valid properties.
1287 
1288         Returns
1289         -------
1290         list of `.EventCollection`
1291             The `.EventCollection` that were added.
1292 
1293         Notes
1294         -----
1295         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1296         only a single value is given, that value is applied to all lines. If an
1297         array-like is given, it must have the same length as *positions*, and
1298         each value will be applied to the corresponding row of the array.
1299 
1300         Examples
1301         --------
1302         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1303         """
1304 
1305         lineoffsets, linelengths = self._process_unit_info(
1306                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1307 
1308         # fix positions, noting that it can be a list of lists:
1309         if not np.iterable(positions):
1310             positions = [positions]
1311         elif any(np.iterable(position) for position in positions):
1312             positions = [np.asanyarray(position) for position in positions]
1313         else:
1314             positions = [np.asanyarray(positions)]
1315 
1316         if len(positions) == 0:
1317             return []
1318 
1319         poss = []
1320         for position in positions:
1321             poss += self._process_unit_info([("x", position)], kwargs)
1322         positions = poss
1323 
1324         # prevent 'singular' keys from **kwargs dict from overriding the effect
1325         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1326         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1327         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1328         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1329 
1330         if not np.iterable(lineoffsets):
1331             lineoffsets = [lineoffsets]
1332         if not np.iterable(linelengths):
1333             linelengths = [linelengths]
1334         if not np.iterable(linewidths):
1335             linewidths = [linewidths]
1336         if not np.iterable(colors):
1337             colors = [colors]
1338         if not np.iterable(alpha):
1339             alpha = [alpha]
1340         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1341             linestyles = [linestyles]
1342 
1343         lineoffsets = np.asarray(lineoffsets)
1344         linelengths = np.asarray(linelengths)
1345         linewidths = np.asarray(linewidths)
1346 
1347         if len(lineoffsets) == 0:
1348             lineoffsets = [None]
1349         if len(linelengths) == 0:
1350             linelengths = [None]
1351         if len(linewidths) == 0:
1352             lineoffsets = [None]
1353         if len(linewidths) == 0:
1354             lineoffsets = [None]
1355         if len(colors) == 0:
1356             colors = [None]
1357         try:
1358             # Early conversion of the colors into RGBA values to take care
1359             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1360             colors = mcolors.to_rgba_array(colors)
1361         except ValueError:
1362             # Will fail if any element of *colors* is None. But as long
1363             # as len(colors) == 1 or len(positions), the rest of the
1364             # code should process *colors* properly.
1365             pass
1366 
1367         if len(lineoffsets) == 1 and len(positions) != 1:
1368             lineoffsets = np.tile(lineoffsets, len(positions))
1369             lineoffsets[0] = 0
1370             lineoffsets = np.cumsum(lineoffsets)
1371         if len(linelengths) == 1:
1372             linelengths = np.tile(linelengths, len(positions))
1373         if len(linewidths) == 1:
1374             linewidths = np.tile(linewidths, len(positions))
1375         if len(colors) == 1:
1376             colors = list(colors) * len(positions)
1377         if len(alpha) == 1:
1378             alpha = list(alpha) * len(positions)
1379         if len(linestyles) == 1:
1380             linestyles = [linestyles] * len(positions)
1381 
1382         if len(lineoffsets) != len(positions):
1383             raise ValueError('lineoffsets and positions are unequal sized '
1384                              'sequences')
1385         if len(linelengths) != len(positions):
1386             raise ValueError('linelengths and positions are unequal sized '
1387                              'sequences')
1388         if len(linewidths) != len(positions):
1389             raise ValueError('linewidths and positions are unequal sized '
1390                              'sequences')
1391         if len(colors) != len(positions):
1392             raise ValueError('colors and positions are unequal sized '
1393                              'sequences')
1394         if len(alpha) != len(positions):
1395             raise ValueError('alpha and positions are unequal sized '
1396                              'sequences')
1397         if len(linestyles) != len(positions):
1398             raise ValueError('linestyles and positions are unequal sized '
1399                              'sequences')
1400 
1401         colls = []
1402         for position, lineoffset, linelength, linewidth, color, alpha_, \
1403             linestyle in \
1404                 zip(positions, lineoffsets, linelengths, linewidths,
1405                     colors, alpha, linestyles):
1406             coll = mcoll.EventCollection(position,
1407                                          orientation=orientation,
1408                                          lineoffset=lineoffset,
1409                                          linelength=linelength,
1410                                          linewidth=linewidth,
1411                                          color=color,
1412                                          alpha=alpha_,
1413                                          linestyle=linestyle)
1414             self.add_collection(coll, autolim=False)
1415             coll._internal_update(kwargs)
1416             colls.append(coll)
1417 
1418         if len(positions) > 0:
1419             # try to get min/max
1420             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1421                        if len(_p) > 0]
1422             # if we have any non-empty positions, try to autoscale
1423             if len(min_max) > 0:
1424                 mins, maxes = zip(*min_max)
1425                 minpos = np.min(mins)
1426                 maxpos = np.max(maxes)
1427 
1428                 minline = (lineoffsets - linelengths).min()
1429                 maxline = (lineoffsets + linelengths).max()
1430 
1431                 if orientation == "vertical":
1432                     corners = (minline, minpos), (maxline, maxpos)
1433                 else:  # "horizontal"
1434                     corners = (minpos, minline), (maxpos, maxline)
1435                 self.update_datalim(corners)
1436                 self._request_autoscale_view()
1437 
1438         return colls
1439 
1440     #### Basic plotting
1441 
1442     # Uses a custom implementation of data-kwarg handling in
1443     # _process_plot_var_args.
1444     @_docstring.dedent_interpd
1445     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1446         """
1447         Plot y versus x as lines and/or markers.
1448 
1449         Call signatures::
1450 
1451             plot([x], y, [fmt], *, data=None, **kwargs)
1452             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1453 
1454         The coordinates of the points or line nodes are given by *x*, *y*.
1455 
1456         The optional parameter *fmt* is a convenient way for defining basic
1457         formatting like color, marker and linestyle. It's a shortcut string
1458         notation described in the *Notes* section below.
1459 
1460         >>> plot(x, y)        # plot x and y using default line style and color
1461         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1462         >>> plot(y)           # plot y using x as index array 0..N-1
1463         >>> plot(y, 'r+')     # ditto, but with red plusses
1464 
1465         You can use `.Line2D` properties as keyword arguments for more
1466         control on the appearance. Line properties and *fmt* can be mixed.
1467         The following two calls yield identical results:
1468 
1469         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1470         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1471         ...      linewidth=2, markersize=12)
1472 
1473         When conflicting with *fmt*, keyword arguments take precedence.
1474 
1475 
1476         **Plotting labelled data**
1477 
1478         There's a convenient way for plotting objects with labelled data (i.e.
1479         data that can be accessed by index ``obj['y']``). Instead of giving
1480         the data in *x* and *y*, you can provide the object in the *data*
1481         parameter and just give the labels for *x* and *y*::
1482 
1483         >>> plot('xlabel', 'ylabel', data=obj)
1484 
1485         All indexable objects are supported. This could e.g. be a `dict`, a
1486         `pandas.DataFrame` or a structured numpy array.
1487 
1488 
1489         **Plotting multiple sets of data**
1490 
1491         There are various ways to plot multiple sets of data.
1492 
1493         - The most straight forward way is just to call `plot` multiple times.
1494           Example:
1495 
1496           >>> plot(x1, y1, 'bo')
1497           >>> plot(x2, y2, 'go')
1498 
1499         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1500           for every column. If both *x* and *y* are 2D, they must have the
1501           same shape. If only one of them is 2D with shape (N, m) the other
1502           must have length N and will be used for every data set m.
1503 
1504           Example:
1505 
1506           >>> x = [1, 2, 3]
1507           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1508           >>> plot(x, y)
1509 
1510           is equivalent to:
1511 
1512           >>> for col in range(y.shape[1]):
1513           ...     plot(x, y[:, col])
1514 
1515         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1516           groups::
1517 
1518           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1519 
1520           In this case, any additional keyword argument applies to all
1521           datasets. Also, this syntax cannot be combined with the *data*
1522           parameter.
1523 
1524         By default, each line is assigned a different style specified by a
1525         'style cycle'. The *fmt* and line property parameters are only
1526         necessary if you want explicit deviations from these defaults.
1527         Alternatively, you can also change the style cycle using
1528         :rc:`axes.prop_cycle`.
1529 
1530 
1531         Parameters
1532         ----------
1533         x, y : array-like or scalar
1534             The horizontal / vertical coordinates of the data points.
1535             *x* values are optional and default to ``range(len(y))``.
1536 
1537             Commonly, these parameters are 1D arrays.
1538 
1539             They can also be scalars, or two-dimensional (in that case, the
1540             columns represent separate data sets).
1541 
1542             These arguments cannot be passed as keywords.
1543 
1544         fmt : str, optional
1545             A format string, e.g. 'ro' for red circles. See the *Notes*
1546             section for a full description of the format strings.
1547 
1548             Format strings are just an abbreviation for quickly setting
1549             basic line properties. All of these and more can also be
1550             controlled by keyword arguments.
1551 
1552             This argument cannot be passed as keyword.
1553 
1554         data : indexable object, optional
1555             An object with labelled data. If given, provide the label names to
1556             plot in *x* and *y*.
1557 
1558             .. note::
1559                 Technically there's a slight ambiguity in calls where the
1560                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1561                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1562                 the former interpretation is chosen, but a warning is issued.
1563                 You may suppress the warning by adding an empty format string
1564                 ``plot('n', 'o', '', data=obj)``.
1565 
1566         Returns
1567         -------
1568         list of `.Line2D`
1569             A list of lines representing the plotted data.
1570 
1571         Other Parameters
1572         ----------------
1573         scalex, scaley : bool, default: True
1574             These parameters determine if the view limits are adapted to the
1575             data limits. The values are passed on to
1576             `~.axes.Axes.autoscale_view`.
1577 
1578         **kwargs : `.Line2D` properties, optional
1579             *kwargs* are used to specify properties like a line label (for
1580             auto legends), linewidth, antialiasing, marker face color.
1581             Example::
1582 
1583             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1584             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1585 
1586             If you specify multiple lines with one plot call, the kwargs apply
1587             to all those lines. In case the label object is iterable, each
1588             element is used as labels for each set of data.
1589 
1590             Here is a list of available `.Line2D` properties:
1591 
1592             %(Line2D:kwdoc)s
1593 
1594         See Also
1595         --------
1596         scatter : XY scatter plot with markers of varying size and/or color (
1597             sometimes also called bubble chart).
1598 
1599         Notes
1600         -----
1601         **Format Strings**
1602 
1603         A format string consists of a part for color, marker and line::
1604 
1605             fmt = '[marker][line][color]'
1606 
1607         Each of them is optional. If not provided, the value from the style
1608         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1609         the data will be a line without markers.
1610 
1611         Other combinations such as ``[color][marker][line]`` are also
1612         supported, but note that their parsing may be ambiguous.
1613 
1614         **Markers**
1615 
1616         =============   ===============================
1617         character       description
1618         =============   ===============================
1619         ``'.'``         point marker
1620         ``','``         pixel marker
1621         ``'o'``         circle marker
1622         ``'v'``         triangle_down marker
1623         ``'^'``         triangle_up marker
1624         ``'<'``         triangle_left marker
1625         ``'>'``         triangle_right marker
1626         ``'1'``         tri_down marker
1627         ``'2'``         tri_up marker
1628         ``'3'``         tri_left marker
1629         ``'4'``         tri_right marker
1630         ``'8'``         octagon marker
1631         ``'s'``         square marker
1632         ``'p'``         pentagon marker
1633         ``'P'``         plus (filled) marker
1634         ``'*'``         star marker
1635         ``'h'``         hexagon1 marker
1636         ``'H'``         hexagon2 marker
1637         ``'+'``         plus marker
1638         ``'x'``         x marker
1639         ``'X'``         x (filled) marker
1640         ``'D'``         diamond marker
1641         ``'d'``         thin_diamond marker
1642         ``'|'``         vline marker
1643         ``'_'``         hline marker
1644         =============   ===============================
1645 
1646         **Line Styles**
1647 
1648         =============    ===============================
1649         character        description
1650         =============    ===============================
1651         ``'-'``          solid line style
1652         ``'--'``         dashed line style
1653         ``'-.'``         dash-dot line style
1654         ``':'``          dotted line style
1655         =============    ===============================
1656 
1657         Example format strings::
1658 
1659             'b'    # blue markers with default shape
1660             'or'   # red circles
1661             '-g'   # green solid line
1662             '--'   # dashed line with default color
1663             '^k:'  # black triangle_up markers connected by a dotted line
1664 
1665         **Colors**
1666 
1667         The supported color abbreviations are the single letter codes
1668 
1669         =============    ===============================
1670         character        color
1671         =============    ===============================
1672         ``'b'``          blue
1673         ``'g'``          green
1674         ``'r'``          red
1675         ``'c'``          cyan
1676         ``'m'``          magenta
1677         ``'y'``          yellow
1678         ``'k'``          black
1679         ``'w'``          white
1680         =============    ===============================
1681 
1682         and the ``'CN'`` colors that index into the default property cycle.
1683 
1684         If the color is the only part of the format string, you can
1685         additionally use any  `matplotlib.colors` spec, e.g. full names
1686         (``'green'``) or hex strings (``'#008000'``).
1687         """
1688         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1689         lines = [*self._get_lines(*args, data=data, **kwargs)]
1690         for line in lines:
1691             self.add_line(line)
1692         if scalex:
1693             self._request_autoscale_view("x")
1694         if scaley:
1695             self._request_autoscale_view("y")
1696         return lines
1697 
1698     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1699     @_docstring.dedent_interpd
1700     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1701                   **kwargs):
1702         """
1703         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1704 
1705         .. admonition:: Discouraged
1706 
1707             This method exists for historic reasons and will be deprecated in
1708             the future.
1709 
1710             - ``datetime``-like data should directly be plotted using
1711               `~.Axes.plot`.
1712             -  If you need to plot plain numeric data as :ref:`date-format` or
1713                need to set a timezone, call ``ax.xaxis.axis_date`` /
1714                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1715                `.Axis.axis_date`.
1716 
1717         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1718         However, the axis labels are formatted as dates depending on *xdate*
1719         and *ydate*.  Note that `.plot` will work with `datetime` and
1720         `numpy.datetime64` objects without resorting to this method.
1721 
1722         Parameters
1723         ----------
1724         x, y : array-like
1725             The coordinates of the data points. If *xdate* or *ydate* is
1726             *True*, the respective values *x* or *y* are interpreted as
1727             :ref:`Matplotlib dates <date-format>`.
1728 
1729         fmt : str, optional
1730             The plot format string. For details, see the corresponding
1731             parameter in `.plot`.
1732 
1733         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1734             The time zone to use in labeling dates.
1735 
1736         xdate : bool, default: True
1737             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1738 
1739         ydate : bool, default: False
1740             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1741 
1742         Returns
1743         -------
1744         list of `.Line2D`
1745             Objects representing the plotted data.
1746 
1747         Other Parameters
1748         ----------------
1749         data : indexable object, optional
1750             DATA_PARAMETER_PLACEHOLDER
1751         **kwargs
1752             Keyword arguments control the `.Line2D` properties:
1753 
1754             %(Line2D:kwdoc)s
1755 
1756         See Also
1757         --------
1758         matplotlib.dates : Helper functions on dates.
1759         matplotlib.dates.date2num : Convert dates to num.
1760         matplotlib.dates.num2date : Convert num to dates.
1761         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1762 
1763         Notes
1764         -----
1765         If you are using custom date tickers and formatters, it may be
1766         necessary to set the formatters/locators after the call to
1767         `.plot_date`. `.plot_date` will set the default tick locator to
1768         `.AutoDateLocator` (if the tick locator is not already set to a
1769         `.DateLocator` instance) and the default tick formatter to
1770         `.AutoDateFormatter` (if the tick formatter is not already set to a
1771         `.DateFormatter` instance).
1772         """
1773         if xdate:
1774             self.xaxis_date(tz)
1775         if ydate:
1776             self.yaxis_date(tz)
1777         return self.plot(x, y, fmt, **kwargs)
1778 
1779     # @_preprocess_data() # let 'plot' do the unpacking..
1780     @_docstring.dedent_interpd
1781     def loglog(self, *args, **kwargs):
1782         """
1783         Make a plot with log scaling on both the x- and y-axis.
1784 
1785         Call signatures::
1786 
1787             loglog([x], y, [fmt], data=None, **kwargs)
1788             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1789 
1790         This is just a thin wrapper around `.plot` which additionally changes
1791         both the x-axis and the y-axis to log scaling. All the concepts and
1792         parameters of plot can be used here as well.
1793 
1794         The additional parameters *base*, *subs* and *nonpositive* control the
1795         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1796         `.Axes.set_yscale`. To use different properties on the x-axis and the
1797         y-axis, use e.g.
1798         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1799 
1800         Parameters
1801         ----------
1802         base : float, default: 10
1803             Base of the logarithm.
1804 
1805         subs : sequence, optional
1806             The location of the minor ticks. If *None*, reasonable locations
1807             are automatically chosen depending on the number of decades in the
1808             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1809 
1810         nonpositive : {'mask', 'clip'}, default: 'mask'
1811             Non-positive values can be masked as invalid, or clipped to a very
1812             small positive number.
1813 
1814         **kwargs
1815             All parameters supported by `.plot`.
1816 
1817         Returns
1818         -------
1819         list of `.Line2D`
1820             Objects representing the plotted data.
1821         """
1822         dx = {k: v for k, v in kwargs.items()
1823               if k in ['base', 'subs', 'nonpositive',
1824                        'basex', 'subsx', 'nonposx']}
1825         self.set_xscale('log', **dx)
1826         dy = {k: v for k, v in kwargs.items()
1827               if k in ['base', 'subs', 'nonpositive',
1828                        'basey', 'subsy', 'nonposy']}
1829         self.set_yscale('log', **dy)
1830         return self.plot(
1831             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1832 
1833     # @_preprocess_data() # let 'plot' do the unpacking..
1834     @_docstring.dedent_interpd
1835     def semilogx(self, *args, **kwargs):
1836         """
1837         Make a plot with log scaling on the x-axis.
1838 
1839         Call signatures::
1840 
1841             semilogx([x], y, [fmt], data=None, **kwargs)
1842             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1843 
1844         This is just a thin wrapper around `.plot` which additionally changes
1845         the x-axis to log scaling. All the concepts and parameters of plot can
1846         be used here as well.
1847 
1848         The additional parameters *base*, *subs*, and *nonpositive* control the
1849         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1850 
1851         Parameters
1852         ----------
1853         base : float, default: 10
1854             Base of the x logarithm.
1855 
1856         subs : array-like, optional
1857             The location of the minor xticks. If *None*, reasonable locations
1858             are automatically chosen depending on the number of decades in the
1859             plot. See `.Axes.set_xscale` for details.
1860 
1861         nonpositive : {'mask', 'clip'}, default: 'mask'
1862             Non-positive values in x can be masked as invalid, or clipped to a
1863             very small positive number.
1864 
1865         **kwargs
1866             All parameters supported by `.plot`.
1867 
1868         Returns
1869         -------
1870         list of `.Line2D`
1871             Objects representing the plotted data.
1872         """
1873         d = {k: v for k, v in kwargs.items()
1874              if k in ['base', 'subs', 'nonpositive',
1875                       'basex', 'subsx', 'nonposx']}
1876         self.set_xscale('log', **d)
1877         return self.plot(
1878             *args, **{k: v for k, v in kwargs.items() if k not in d})
1879 
1880     # @_preprocess_data() # let 'plot' do the unpacking..
1881     @_docstring.dedent_interpd
1882     def semilogy(self, *args, **kwargs):
1883         """
1884         Make a plot with log scaling on the y-axis.
1885 
1886         Call signatures::
1887 
1888             semilogy([x], y, [fmt], data=None, **kwargs)
1889             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1890 
1891         This is just a thin wrapper around `.plot` which additionally changes
1892         the y-axis to log scaling. All the concepts and parameters of plot can
1893         be used here as well.
1894 
1895         The additional parameters *base*, *subs*, and *nonpositive* control the
1896         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1897 
1898         Parameters
1899         ----------
1900         base : float, default: 10
1901             Base of the y logarithm.
1902 
1903         subs : array-like, optional
1904             The location of the minor yticks. If *None*, reasonable locations
1905             are automatically chosen depending on the number of decades in the
1906             plot. See `.Axes.set_yscale` for details.
1907 
1908         nonpositive : {'mask', 'clip'}, default: 'mask'
1909             Non-positive values in y can be masked as invalid, or clipped to a
1910             very small positive number.
1911 
1912         **kwargs
1913             All parameters supported by `.plot`.
1914 
1915         Returns
1916         -------
1917         list of `.Line2D`
1918             Objects representing the plotted data.
1919         """
1920         d = {k: v for k, v in kwargs.items()
1921              if k in ['base', 'subs', 'nonpositive',
1922                       'basey', 'subsy', 'nonposy']}
1923         self.set_yscale('log', **d)
1924         return self.plot(
1925             *args, **{k: v for k, v in kwargs.items() if k not in d})
1926 
1927     @_preprocess_data(replace_names=["x"], label_namer="x")
1928     def acorr(self, x, **kwargs):
1929         """
1930         Plot the autocorrelation of *x*.
1931 
1932         Parameters
1933         ----------
1934         x : array-like
1935 
1936         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1937             A detrending function applied to *x*.  It must have the
1938             signature ::
1939 
1940                 detrend(x: np.ndarray) -> np.ndarray
1941 
1942         normed : bool, default: True
1943             If ``True``, input vectors are normalised to unit length.
1944 
1945         usevlines : bool, default: True
1946             Determines the plot style.
1947 
1948             If ``True``, vertical lines are plotted from 0 to the acorr value
1949             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1950             at y=0 using `.Axes.axhline`.
1951 
1952             If ``False``, markers are plotted at the acorr values using
1953             `.Axes.plot`.
1954 
1955         maxlags : int, default: 10
1956             Number of lags to show. If ``None``, will return all
1957             ``2 * len(x) - 1`` lags.
1958 
1959         Returns
1960         -------
1961         lags : array (length ``2*maxlags+1``)
1962             The lag vector.
1963         c : array  (length ``2*maxlags+1``)
1964             The auto correlation vector.
1965         line : `.LineCollection` or `.Line2D`
1966             `.Artist` added to the Axes of the correlation:
1967 
1968             - `.LineCollection` if *usevlines* is True.
1969             - `.Line2D` if *usevlines* is False.
1970         b : `.Line2D` or None
1971             Horizontal line at 0 if *usevlines* is True
1972             None *usevlines* is False.
1973 
1974         Other Parameters
1975         ----------------
1976         linestyle : `.Line2D` property, optional
1977             The linestyle for plotting the data points.
1978             Only used if *usevlines* is ``False``.
1979 
1980         marker : str, default: 'o'
1981             The marker for plotting the data points.
1982             Only used if *usevlines* is ``False``.
1983 
1984         data : indexable object, optional
1985             DATA_PARAMETER_PLACEHOLDER
1986 
1987         **kwargs
1988             Additional parameters are passed to `.Axes.vlines` and
1989             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
1990             passed to `.Axes.plot`.
1991 
1992         Notes
1993         -----
1994         The cross correlation is performed with `numpy.correlate` with
1995         ``mode = "full"``.
1996         """
1997         return self.xcorr(x, x, **kwargs)
1998 
1999     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2000     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2001               usevlines=True, maxlags=10, **kwargs):
2002         r"""
2003         Plot the cross correlation between *x* and *y*.
2004 
2005         The correlation with lag k is defined as
2006         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2007         conjugate of :math:`y`.
2008 
2009         Parameters
2010         ----------
2011         x, y : array-like of length n
2012 
2013         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2014             A detrending function applied to *x* and *y*.  It must have the
2015             signature ::
2016 
2017                 detrend(x: np.ndarray) -> np.ndarray
2018 
2019         normed : bool, default: True
2020             If ``True``, input vectors are normalised to unit length.
2021 
2022         usevlines : bool, default: True
2023             Determines the plot style.
2024 
2025             If ``True``, vertical lines are plotted from 0 to the xcorr value
2026             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2027             at y=0 using `.Axes.axhline`.
2028 
2029             If ``False``, markers are plotted at the xcorr values using
2030             `.Axes.plot`.
2031 
2032         maxlags : int, default: 10
2033             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2034             lags.
2035 
2036         Returns
2037         -------
2038         lags : array (length ``2*maxlags+1``)
2039             The lag vector.
2040         c : array  (length ``2*maxlags+1``)
2041             The auto correlation vector.
2042         line : `.LineCollection` or `.Line2D`
2043             `.Artist` added to the Axes of the correlation:
2044 
2045             - `.LineCollection` if *usevlines* is True.
2046             - `.Line2D` if *usevlines* is False.
2047         b : `.Line2D` or None
2048             Horizontal line at 0 if *usevlines* is True
2049             None *usevlines* is False.
2050 
2051         Other Parameters
2052         ----------------
2053         linestyle : `.Line2D` property, optional
2054             The linestyle for plotting the data points.
2055             Only used if *usevlines* is ``False``.
2056 
2057         marker : str, default: 'o'
2058             The marker for plotting the data points.
2059             Only used if *usevlines* is ``False``.
2060 
2061         data : indexable object, optional
2062             DATA_PARAMETER_PLACEHOLDER
2063 
2064         **kwargs
2065             Additional parameters are passed to `.Axes.vlines` and
2066             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2067             passed to `.Axes.plot`.
2068 
2069         Notes
2070         -----
2071         The cross correlation is performed with `numpy.correlate` with
2072         ``mode = "full"``.
2073         """
2074         Nx = len(x)
2075         if Nx != len(y):
2076             raise ValueError('x and y must be equal length')
2077 
2078         x = detrend(np.asarray(x))
2079         y = detrend(np.asarray(y))
2080 
2081         correls = np.correlate(x, y, mode="full")
2082 
2083         if normed:
2084             correls /= np.sqrt(np.dot(x, x) * np.dot(y, y))
2085 
2086         if maxlags is None:
2087             maxlags = Nx - 1
2088 
2089         if maxlags >= Nx or maxlags < 1:
2090             raise ValueError('maxlags must be None or strictly '
2091                              'positive < %d' % Nx)
2092 
2093         lags = np.arange(-maxlags, maxlags + 1)
2094         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2095 
2096         if usevlines:
2097             a = self.vlines(lags, [0], correls, **kwargs)
2098             # Make label empty so only vertical lines get a legend entry
2099             kwargs.pop('label', '')
2100             b = self.axhline(**kwargs)
2101         else:
2102             kwargs.setdefault('marker', 'o')
2103             kwargs.setdefault('linestyle', 'None')
2104             a, = self.plot(lags, correls, **kwargs)
2105             b = None
2106         return lags, correls, a, b
2107 
2108     #### Specialized plotting
2109 
2110     # @_preprocess_data() # let 'plot' do the unpacking..
2111     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2112         """
2113         Make a step plot.
2114 
2115         Call signatures::
2116 
2117             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2118             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2119 
2120         This is just a thin wrapper around `.plot` which changes some
2121         formatting options. Most of the concepts and parameters of plot can be
2122         used here as well.
2123 
2124         .. note::
2125 
2126             This method uses a standard plot with a step drawstyle: The *x*
2127             values are the reference positions and steps extend left/right/both
2128             directions depending on *where*.
2129 
2130             For the common case where you know the values and edges of the
2131             steps, use `~.Axes.stairs` instead.
2132 
2133         Parameters
2134         ----------
2135         x : array-like
2136             1D sequence of x positions. It is assumed, but not checked, that
2137             it is uniformly increasing.
2138 
2139         y : array-like
2140             1D sequence of y levels.
2141 
2142         fmt : str, optional
2143             A format string, e.g. 'g' for a green line. See `.plot` for a more
2144             detailed description.
2145 
2146             Note: While full format strings are accepted, it is recommended to
2147             only specify the color. Line styles are currently ignored (use
2148             the keyword argument *linestyle* instead). Markers are accepted
2149             and plotted on the given positions, however, this is a rarely
2150             needed feature for step plots.
2151 
2152         where : {'pre', 'post', 'mid'}, default: 'pre'
2153             Define where the steps should be placed:
2154 
2155             - 'pre': The y value is continued constantly to the left from
2156               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2157               value ``y[i]``.
2158             - 'post': The y value is continued constantly to the right from
2159               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2160               value ``y[i]``.
2161             - 'mid': Steps occur half-way between the *x* positions.
2162 
2163         data : indexable object, optional
2164             An object with labelled data. If given, provide the label names to
2165             plot in *x* and *y*.
2166 
2167         **kwargs
2168             Additional parameters are the same as those for `.plot`.
2169 
2170         Returns
2171         -------
2172         list of `.Line2D`
2173             Objects representing the plotted data.
2174         """
2175         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2176         kwargs['drawstyle'] = 'steps-' + where
2177         return self.plot(x, y, *args, data=data, **kwargs)
2178 
2179     @staticmethod
2180     def _convert_dx(dx, x0, xconv, convert):
2181         """
2182         Small helper to do logic of width conversion flexibly.
2183 
2184         *dx* and *x0* have units, but *xconv* has already been converted
2185         to unitless (and is an ndarray).  This allows the *dx* to have units
2186         that are different from *x0*, but are still accepted by the
2187         ``__add__`` operator of *x0*.
2188         """
2189 
2190         # x should be an array...
2191         assert type(xconv) is np.ndarray
2192 
2193         if xconv.size == 0:
2194             # xconv has already been converted, but maybe empty...
2195             return convert(dx)
2196 
2197         try:
2198             # attempt to add the width to x0; this works for
2199             # datetime+timedelta, for instance
2200 
2201             # only use the first element of x and x0.  This saves
2202             # having to be sure addition works across the whole
2203             # vector.  This is particularly an issue if
2204             # x0 and dx are lists so x0 + dx just concatenates the lists.
2205             # We can't just cast x0 and dx to numpy arrays because that
2206             # removes the units from unit packages like `pint` that
2207             # wrap numpy arrays.
2208             try:
2209                 x0 = cbook._safe_first_finite(x0)
2210             except (TypeError, IndexError, KeyError):
2211                 pass
2212             except StopIteration:
2213                 # this means we found no finite element, fall back to first
2214                 # element unconditionally
2215                 x0 = cbook.safe_first_element(x0)
2216 
2217             try:
2218                 x = cbook._safe_first_finite(xconv)
2219             except (TypeError, IndexError, KeyError):
2220                 x = xconv
2221             except StopIteration:
2222                 # this means we found no finite element, fall back to first
2223                 # element unconditionally
2224                 x = cbook.safe_first_element(xconv)
2225 
2226             delist = False
2227             if not np.iterable(dx):
2228                 dx = [dx]
2229                 delist = True
2230             dx = [convert(x0 + ddx) - x for ddx in dx]
2231             if delist:
2232                 dx = dx[0]
2233         except (ValueError, TypeError, AttributeError):
2234             # if the above fails (for any reason) just fallback to what
2235             # we do by default and convert dx by itself.
2236             dx = convert(dx)
2237         return dx
2238 
2239     @_preprocess_data()
2240     @_docstring.dedent_interpd
2241     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2242             **kwargs):
2243         r"""
2244         Make a bar plot.
2245 
2246         The bars are positioned at *x* with the given *align*\ment. Their
2247         dimensions are given by *height* and *width*. The vertical baseline
2248         is *bottom* (default 0).
2249 
2250         Many parameters can take either a single value applying to all bars
2251         or a sequence of values, one for each bar.
2252 
2253         Parameters
2254         ----------
2255         x : float or array-like
2256             The x coordinates of the bars. See also *align* for the
2257             alignment of the bars to the coordinates.
2258 
2259         height : float or array-like
2260             The height(s) of the bars.
2261 
2262         width : float or array-like, default: 0.8
2263             The width(s) of the bars.
2264 
2265         bottom : float or array-like, default: 0
2266             The y coordinate(s) of the bottom side(s) of the bars.
2267 
2268         align : {'center', 'edge'}, default: 'center'
2269             Alignment of the bars to the *x* coordinates:
2270 
2271             - 'center': Center the base on the *x* positions.
2272             - 'edge': Align the left edges of the bars with the *x* positions.
2273 
2274             To align the bars on the right edge pass a negative *width* and
2275             ``align='edge'``.
2276 
2277         Returns
2278         -------
2279         `.BarContainer`
2280             Container with all the bars and optionally errorbars.
2281 
2282         Other Parameters
2283         ----------------
2284         color : color or list of color, optional
2285             The colors of the bar faces.
2286 
2287         edgecolor : color or list of color, optional
2288             The colors of the bar edges.
2289 
2290         linewidth : float or array-like, optional
2291             Width of the bar edge(s). If 0, don't draw edges.
2292 
2293         tick_label : str or list of str, optional
2294             The tick labels of the bars.
2295             Default: None (Use default numeric labels.)
2296 
2297         label : str or list of str, optional
2298             A single label is attached to the resulting `.BarContainer` as a
2299             label for the whole dataset.
2300             If a list is provided, it must be the same length as *x* and
2301             labels the individual bars. Repeated labels are not de-duplicated
2302             and will cause repeated label entries, so this is best used when
2303             bars also differ in style (e.g., by passing a list to *color*.)
2304 
2305         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2306             If not *None*, add horizontal / vertical errorbars to the bar tips.
2307             The values are +/- sizes relative to the data:
2308 
2309             - scalar: symmetric +/- values for all bars
2310             - shape(N,): symmetric +/- values for each bar
2311             - shape(2, N): Separate - and + values for each bar. First row
2312               contains the lower errors, the second row contains the upper
2313               errors.
2314             - *None*: No errorbar. (Default)
2315 
2316             See :doc:`/gallery/statistics/errorbar_features` for an example on
2317             the usage of *xerr* and *yerr*.
2318 
2319         ecolor : color or list of color, default: 'black'
2320             The line color of the errorbars.
2321 
2322         capsize : float, default: :rc:`errorbar.capsize`
2323            The length of the error bar caps in points.
2324 
2325         error_kw : dict, optional
2326             Dictionary of keyword arguments to be passed to the
2327             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2328             here take precedence over the independent keyword arguments.
2329 
2330         log : bool, default: False
2331             If *True*, set the y-axis to be log scale.
2332 
2333         data : indexable object, optional
2334             DATA_PARAMETER_PLACEHOLDER
2335 
2336         **kwargs : `.Rectangle` properties
2337 
2338         %(Rectangle:kwdoc)s
2339 
2340         See Also
2341         --------
2342         barh : Plot a horizontal bar plot.
2343 
2344         Notes
2345         -----
2346         Stacked bars can be achieved by passing individual *bottom* values per
2347         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2348         """
2349         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2350         color = kwargs.pop('color', None)
2351         if color is None:
2352             color = self._get_patches_for_fill.get_next_color()
2353         edgecolor = kwargs.pop('edgecolor', None)
2354         linewidth = kwargs.pop('linewidth', None)
2355         hatch = kwargs.pop('hatch', None)
2356 
2357         # Because xerr and yerr will be passed to errorbar, most dimension
2358         # checking and processing will be left to the errorbar method.
2359         xerr = kwargs.pop('xerr', None)
2360         yerr = kwargs.pop('yerr', None)
2361         error_kw = kwargs.pop('error_kw', {})
2362         ezorder = error_kw.pop('zorder', None)
2363         if ezorder is None:
2364             ezorder = kwargs.get('zorder', None)
2365             if ezorder is not None:
2366                 # If using the bar zorder, increment slightly to make sure
2367                 # errorbars are drawn on top of bars
2368                 ezorder += 0.01
2369         error_kw.setdefault('zorder', ezorder)
2370         ecolor = kwargs.pop('ecolor', 'k')
2371         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2372         error_kw.setdefault('ecolor', ecolor)
2373         error_kw.setdefault('capsize', capsize)
2374 
2375         # The keyword argument *orientation* is used by barh() to defer all
2376         # logic and drawing to bar(). It is considered internal and is
2377         # intentionally not mentioned in the docstring.
2378         orientation = kwargs.pop('orientation', 'vertical')
2379         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2380         log = kwargs.pop('log', False)
2381         label = kwargs.pop('label', '')
2382         tick_labels = kwargs.pop('tick_label', None)
2383 
2384         y = bottom  # Matches barh call signature.
2385         if orientation == 'vertical':
2386             if y is None:
2387                 y = 0
2388         else:  # horizontal
2389             if x is None:
2390                 x = 0
2391 
2392         if orientation == 'vertical':
2393             self._process_unit_info(
2394                 [("x", x), ("y", height)], kwargs, convert=False)
2395             if log:
2396                 self.set_yscale('log', nonpositive='clip')
2397         else:  # horizontal
2398             self._process_unit_info(
2399                 [("x", width), ("y", y)], kwargs, convert=False)
2400             if log:
2401                 self.set_xscale('log', nonpositive='clip')
2402 
2403         # lets do some conversions now since some types cannot be
2404         # subtracted uniformly
2405         if self.xaxis is not None:
2406             x0 = x
2407             x = np.asarray(self.convert_xunits(x))
2408             width = self._convert_dx(width, x0, x, self.convert_xunits)
2409             if xerr is not None:
2410                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2411         if self.yaxis is not None:
2412             y0 = y
2413             y = np.asarray(self.convert_yunits(y))
2414             height = self._convert_dx(height, y0, y, self.convert_yunits)
2415             if yerr is not None:
2416                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2417 
2418         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2419             # Make args iterable too.
2420             np.atleast_1d(x), height, width, y, linewidth, hatch)
2421 
2422         # Now that units have been converted, set the tick locations.
2423         if orientation == 'vertical':
2424             tick_label_axis = self.xaxis
2425             tick_label_position = x
2426         else:  # horizontal
2427             tick_label_axis = self.yaxis
2428             tick_label_position = y
2429 
2430         if not isinstance(label, str) and np.iterable(label):
2431             bar_container_label = '_nolegend_'
2432             patch_labels = label
2433         else:
2434             bar_container_label = label
2435             patch_labels = ['_nolegend_'] * len(x)
2436         if len(patch_labels) != len(x):
2437             raise ValueError(f'number of labels ({len(patch_labels)}) '
2438                              f'does not match number of bars ({len(x)}).')
2439 
2440         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2441         hatch = itertools.cycle(np.atleast_1d(hatch))
2442         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2443                                 # Fallback if color == "none".
2444                                 itertools.repeat('none'))
2445         if edgecolor is None:
2446             edgecolor = itertools.repeat(None)
2447         else:
2448             edgecolor = itertools.chain(
2449                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2450                 # Fallback if edgecolor == "none".
2451                 itertools.repeat('none'))
2452 
2453         # We will now resolve the alignment and really have
2454         # left, bottom, width, height vectors
2455         _api.check_in_list(['center', 'edge'], align=align)
2456         if align == 'center':
2457             if orientation == 'vertical':
2458                 try:
2459                     left = x - width / 2
2460                 except TypeError as e:
2461                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2462                                     f'and width ({width.dtype}) '
2463                                     f'are incompatible') from e
2464                 bottom = y
2465             else:  # horizontal
2466                 try:
2467                     bottom = y - height / 2
2468                 except TypeError as e:
2469                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2470                                     f'and height ({height.dtype}) '
2471                                     f'are incompatible') from e
2472                 left = x
2473         else:  # edge
2474             left = x
2475             bottom = y
2476 
2477         patches = []
2478         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2479                    hatch, patch_labels)
2480         for l, b, w, h, c, e, lw, htch, lbl in args:
2481             r = mpatches.Rectangle(
2482                 xy=(l, b), width=w, height=h,
2483                 facecolor=c,
2484                 edgecolor=e,
2485                 linewidth=lw,
2486                 label=lbl,
2487                 hatch=htch,
2488                 )
2489             r._internal_update(kwargs)
2490             r.get_path()._interpolation_steps = 100
2491             if orientation == 'vertical':
2492                 r.sticky_edges.y.append(b)
2493             else:  # horizontal
2494                 r.sticky_edges.x.append(l)
2495             self.add_patch(r)
2496             patches.append(r)
2497 
2498         if xerr is not None or yerr is not None:
2499             if orientation == 'vertical':
2500                 # using list comps rather than arrays to preserve unit info
2501                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2502                 ey = [b + h for b, h in zip(bottom, height)]
2503 
2504             else:  # horizontal
2505                 # using list comps rather than arrays to preserve unit info
2506                 ex = [l + w for l, w in zip(left, width)]
2507                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2508 
2509             error_kw.setdefault("label", '_nolegend_')
2510 
2511             errorbar = self.errorbar(ex, ey,
2512                                      yerr=yerr, xerr=xerr,
2513                                      fmt='none', **error_kw)
2514         else:
2515             errorbar = None
2516 
2517         self._request_autoscale_view()
2518 
2519         if orientation == 'vertical':
2520             datavalues = height
2521         else:  # horizontal
2522             datavalues = width
2523 
2524         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2525                                      orientation=orientation,
2526                                      label=bar_container_label)
2527         self.add_container(bar_container)
2528 
2529         if tick_labels is not None:
2530             tick_labels = np.broadcast_to(tick_labels, len(patches))
2531             tick_label_axis.set_ticks(tick_label_position)
2532             tick_label_axis.set_ticklabels(tick_labels)
2533 
2534         return bar_container
2535 
2536     # @_preprocess_data() # let 'bar' do the unpacking..
2537     @_docstring.dedent_interpd
2538     def barh(self, y, width, height=0.8, left=None, *, align="center",
2539              data=None, **kwargs):
2540         r"""
2541         Make a horizontal bar plot.
2542 
2543         The bars are positioned at *y* with the given *align*\ment. Their
2544         dimensions are given by *width* and *height*. The horizontal baseline
2545         is *left* (default 0).
2546 
2547         Many parameters can take either a single value applying to all bars
2548         or a sequence of values, one for each bar.
2549 
2550         Parameters
2551         ----------
2552         y : float or array-like
2553             The y coordinates of the bars. See also *align* for the
2554             alignment of the bars to the coordinates.
2555 
2556         width : float or array-like
2557             The width(s) of the bars.
2558 
2559         height : float or array-like, default: 0.8
2560             The heights of the bars.
2561 
2562         left : float or array-like, default: 0
2563             The x coordinates of the left side(s) of the bars.
2564 
2565         align : {'center', 'edge'}, default: 'center'
2566             Alignment of the base to the *y* coordinates*:
2567 
2568             - 'center': Center the bars on the *y* positions.
2569             - 'edge': Align the bottom edges of the bars with the *y*
2570               positions.
2571 
2572             To align the bars on the top edge pass a negative *height* and
2573             ``align='edge'``.
2574 
2575         Returns
2576         -------
2577         `.BarContainer`
2578             Container with all the bars and optionally errorbars.
2579 
2580         Other Parameters
2581         ----------------
2582         color : color or list of color, optional
2583             The colors of the bar faces.
2584 
2585         edgecolor : color or list of color, optional
2586             The colors of the bar edges.
2587 
2588         linewidth : float or array-like, optional
2589             Width of the bar edge(s). If 0, don't draw edges.
2590 
2591         tick_label : str or list of str, optional
2592             The tick labels of the bars.
2593             Default: None (Use default numeric labels.)
2594 
2595         label : str or list of str, optional
2596             A single label is attached to the resulting `.BarContainer` as a
2597             label for the whole dataset.
2598             If a list is provided, it must be the same length as *y* and
2599             labels the individual bars. Repeated labels are not de-duplicated
2600             and will cause repeated label entries, so this is best used when
2601             bars also differ in style (e.g., by passing a list to *color*.)
2602 
2603         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2604             If not *None*, add horizontal / vertical errorbars to the bar tips.
2605             The values are +/- sizes relative to the data:
2606 
2607             - scalar: symmetric +/- values for all bars
2608             - shape(N,): symmetric +/- values for each bar
2609             - shape(2, N): Separate - and + values for each bar. First row
2610               contains the lower errors, the second row contains the upper
2611               errors.
2612             - *None*: No errorbar. (default)
2613 
2614             See :doc:`/gallery/statistics/errorbar_features` for an example on
2615             the usage of *xerr* and *yerr*.
2616 
2617         ecolor : color or list of color, default: 'black'
2618             The line color of the errorbars.
2619 
2620         capsize : float, default: :rc:`errorbar.capsize`
2621            The length of the error bar caps in points.
2622 
2623         error_kw : dict, optional
2624             Dictionary of keyword arguments to be passed to the
2625             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2626             here take precedence over the independent keyword arguments.
2627 
2628         log : bool, default: False
2629             If ``True``, set the x-axis to be log scale.
2630 
2631         data : indexable object, optional
2632             If given, all parameters also accept a string ``s``, which is
2633             interpreted as ``data[s]`` (unless this raises an exception).
2634 
2635         **kwargs : `.Rectangle` properties
2636 
2637         %(Rectangle:kwdoc)s
2638 
2639         See Also
2640         --------
2641         bar : Plot a vertical bar plot.
2642 
2643         Notes
2644         -----
2645         Stacked bars can be achieved by passing individual *left* values per
2646         bar. See
2647         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2648         """
2649         kwargs.setdefault('orientation', 'horizontal')
2650         patches = self.bar(x=left, height=height, width=width, bottom=y,
2651                            align=align, data=data, **kwargs)
2652         return patches
2653 
2654     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2655                   padding=0, **kwargs):
2656         """
2657         Label a bar plot.
2658 
2659         Adds labels to bars in the given `.BarContainer`.
2660         You may need to adjust the axis limits to fit the labels.
2661 
2662         Parameters
2663         ----------
2664         container : `.BarContainer`
2665             Container with all the bars and optionally errorbars, likely
2666             returned from `.bar` or `.barh`.
2667 
2668         labels : array-like, optional
2669             A list of label texts, that should be displayed. If not given, the
2670             label texts will be the data values formatted with *fmt*.
2671 
2672         fmt : str or callable, default: '%g'
2673             An unnamed %-style or {}-style format string for the label or a
2674             function to call with the value as the first argument.
2675             When *fmt* is a string and can be interpreted in both formats,
2676             %-style takes precedence over {}-style.
2677 
2678             .. versionadded:: 3.7
2679                Support for {}-style format string and callables.
2680 
2681         label_type : {'edge', 'center'}, default: 'edge'
2682             The label type. Possible values:
2683 
2684             - 'edge': label placed at the end-point of the bar segment, and the
2685               value displayed will be the position of that end-point.
2686             - 'center': label placed in the center of the bar segment, and the
2687               value displayed will be the length of that segment.
2688               (useful for stacked bars, i.e.,
2689               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2690 
2691         padding : float, default: 0
2692             Distance of label from the end of the bar, in points.
2693 
2694         **kwargs
2695             Any remaining keyword arguments are passed through to
2696             `.Axes.annotate`. The alignment parameters (
2697             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2698             not supported because the labels are automatically aligned to
2699             the bars.
2700 
2701         Returns
2702         -------
2703         list of `.Text`
2704             A list of `.Text` instances for the labels.
2705         """
2706         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2707             if key in kwargs:
2708                 raise ValueError(
2709                     f"Passing {key!r} to bar_label() is not supported.")
2710 
2711         a, b = self.yaxis.get_view_interval()
2712         y_inverted = a > b
2713         c, d = self.xaxis.get_view_interval()
2714         x_inverted = c > d
2715 
2716         # want to know whether to put label on positive or negative direction
2717         # cannot use np.sign here because it will return 0 if x == 0
2718         def sign(x):
2719             return 1 if x >= 0 else -1
2720 
2721         _api.check_in_list(['edge', 'center'], label_type=label_type)
2722 
2723         bars = container.patches
2724         errorbar = container.errorbar
2725         datavalues = container.datavalues
2726         orientation = container.orientation
2727 
2728         if errorbar:
2729             # check "ErrorbarContainer" for the definition of these elements
2730             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2731             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2732             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2733             errs = barlinecol.get_segments()
2734         else:
2735             errs = []
2736 
2737         if labels is None:
2738             labels = []
2739 
2740         annotations = []
2741 
2742         for bar, err, dat, lbl in itertools.zip_longest(
2743                 bars, errs, datavalues, labels
2744         ):
2745             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2746             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2747 
2748             if orientation == "vertical":
2749                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2750                 length = abs(y0 - y1)
2751             else:  # horizontal
2752                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2753                 length = abs(x0 - x1)
2754 
2755             if err is None or np.size(err) == 0:
2756                 endpt = extrema
2757             elif orientation == "vertical":
2758                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2759             else:  # horizontal
2760                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2761 
2762             if label_type == "center":
2763                 value = sign(dat) * length
2764             else:  # edge
2765                 value = extrema
2766 
2767             if label_type == "center":
2768                 xy = (0.5, 0.5)
2769                 kwargs["xycoords"] = (
2770                     lambda r, b=bar:
2771                         mtransforms.Bbox.intersection(
2772                             b.get_window_extent(r), b.get_clip_box()
2773                         )
2774                 )
2775             else:  # edge
2776                 if orientation == "vertical":
2777                     xy = xc, endpt
2778                 else:  # horizontal
2779                     xy = endpt, yc
2780 
2781             if orientation == "vertical":
2782                 y_direction = -1 if y_inverted else 1
2783                 xytext = 0, y_direction * sign(dat) * padding
2784             else:  # horizontal
2785                 x_direction = -1 if x_inverted else 1
2786                 xytext = x_direction * sign(dat) * padding, 0
2787 
2788             if label_type == "center":
2789                 ha, va = "center", "center"
2790             else:  # edge
2791                 if orientation == "vertical":
2792                     ha = 'center'
2793                     if y_inverted:
2794                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2795                     else:
2796                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2797                 else:  # horizontal
2798                     if x_inverted:
2799                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2800                     else:
2801                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2802                     va = 'center'
2803 
2804             if np.isnan(dat):
2805                 lbl = ''
2806 
2807             if lbl is None:
2808                 if isinstance(fmt, str):
2809                     lbl = cbook._auto_format_str(fmt, value)
2810                 elif callable(fmt):
2811                     lbl = fmt(value)
2812                 else:
2813                     raise TypeError("fmt must be a str or callable")
2814             annotation = self.annotate(lbl,
2815                                        xy, xytext, textcoords="offset points",
2816                                        ha=ha, va=va, **kwargs)
2817             annotations.append(annotation)
2818 
2819         return annotations
2820 
2821     @_preprocess_data()
2822     @_docstring.dedent_interpd
2823     def broken_barh(self, xranges, yrange, **kwargs):
2824         """
2825         Plot a horizontal sequence of rectangles.
2826 
2827         A rectangle is drawn for each element of *xranges*. All rectangles
2828         have the same vertical position and size defined by *yrange*.
2829 
2830         Parameters
2831         ----------
2832         xranges : sequence of tuples (*xmin*, *xwidth*)
2833             The x-positions and extents of the rectangles. For each tuple
2834             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2835             *xwidth*.
2836         yrange : (*ymin*, *yheight*)
2837             The y-position and extent for all the rectangles.
2838 
2839         Returns
2840         -------
2841         `~.collections.PolyCollection`
2842 
2843         Other Parameters
2844         ----------------
2845         data : indexable object, optional
2846             DATA_PARAMETER_PLACEHOLDER
2847         **kwargs : `.PolyCollection` properties
2848 
2849             Each *kwarg* can be either a single argument applying to all
2850             rectangles, e.g.::
2851 
2852                 facecolors='black'
2853 
2854             or a sequence of arguments over which is cycled, e.g.::
2855 
2856                 facecolors=('black', 'blue')
2857 
2858             would create interleaving black and blue rectangles.
2859 
2860             Supported keywords:
2861 
2862             %(PolyCollection:kwdoc)s
2863         """
2864         # process the unit information
2865         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2866         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2867         self._process_unit_info(
2868             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2869 
2870         vertices = []
2871         y0, dy = yrange
2872         y0, y1 = self.convert_yunits((y0, y0 + dy))
2873         for xr in xranges:  # convert the absolute values, not the x and dx
2874             try:
2875                 x0, dx = xr
2876             except Exception:
2877                 raise ValueError(
2878                     "each range in xrange must be a sequence with two "
2879                     "elements (i.e. xrange must be an (N, 2) array)") from None
2880             x0, x1 = self.convert_xunits((x0, x0 + dx))
2881             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2882 
2883         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2884         self.add_collection(col, autolim=True)
2885         self._request_autoscale_view()
2886 
2887         return col
2888 
2889     @_preprocess_data()
2890     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2891              label=None, orientation='vertical'):
2892         """
2893         Create a stem plot.
2894 
2895         A stem plot draws lines perpendicular to a baseline at each location
2896         *locs* from the baseline to *heads*, and places a marker there. For
2897         vertical stem plots (the default), the *locs* are *x* positions, and
2898         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2899         *y* positions, and the *heads* are *x* values.
2900 
2901         Call signature::
2902 
2903           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2904 
2905         The *locs*-positions are optional. *linefmt* may be provided as
2906         positional, but all other formats must be provided as keyword
2907         arguments.
2908 
2909         Parameters
2910         ----------
2911         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2912             For vertical stem plots, the x-positions of the stems.
2913             For horizontal stem plots, the y-positions of the stems.
2914 
2915         heads : array-like
2916             For vertical stem plots, the y-values of the stem heads.
2917             For horizontal stem plots, the x-values of the stem heads.
2918 
2919         linefmt : str, optional
2920             A string defining the color and/or linestyle of the vertical lines:
2921 
2922             =========  =============
2923             Character  Line Style
2924             =========  =============
2925             ``'-'``    solid line
2926             ``'--'``   dashed line
2927             ``'-.'``   dash-dot line
2928             ``':'``    dotted line
2929             =========  =============
2930 
2931             Default: 'C0-', i.e. solid line with the first color of the color
2932             cycle.
2933 
2934             Note: Markers specified through this parameter (e.g. 'x') will be
2935             silently ignored. Instead, markers should be specified using
2936             *markerfmt*.
2937 
2938         markerfmt : str, optional
2939             A string defining the color and/or shape of the markers at the stem
2940             heads. If the marker is not given, use the marker 'o', i.e. filled
2941             circles. If the color is not given, use the color from *linefmt*.
2942 
2943         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2944             A format string defining the properties of the baseline.
2945 
2946         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2947             If 'vertical', will produce a plot with stems oriented vertically,
2948             If 'horizontal', the stems will be oriented horizontally.
2949 
2950         bottom : float, default: 0
2951             The y/x-position of the baseline (depending on orientation).
2952 
2953         label : str, default: None
2954             The label to use for the stems in legends.
2955 
2956         data : indexable object, optional
2957             DATA_PARAMETER_PLACEHOLDER
2958 
2959         Returns
2960         -------
2961         `.StemContainer`
2962             The container may be treated like a tuple
2963             (*markerline*, *stemlines*, *baseline*)
2964 
2965         Notes
2966         -----
2967         .. seealso::
2968             The MATLAB function
2969             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2970             which inspired this method.
2971         """
2972         if not 1 <= len(args) <= 3:
2973             _api.nargs_error('stem', '1-3', len(args))
2974         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
2975 
2976         if len(args) == 1:
2977             heads, = args
2978             locs = np.arange(len(heads))
2979             args = ()
2980         elif isinstance(args[1], str):
2981             heads, *args = args
2982             locs = np.arange(len(heads))
2983         else:
2984             locs, heads, *args = args
2985 
2986         if orientation == 'vertical':
2987             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
2988         else:  # horizontal
2989             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
2990 
2991         # resolve line format
2992         if linefmt is None:
2993             linefmt = args[0] if len(args) > 0 else "C0-"
2994         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
2995 
2996         # resolve marker format
2997         if markerfmt is None:
2998             # if not given as kwarg, fall back to 'o'
2999             markerfmt = "o"
3000         if markerfmt == '':
3001             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3002         markerstyle, markermarker, markercolor = \
3003             _process_plot_format(markerfmt)
3004         if markermarker is None:
3005             markermarker = 'o'
3006         if markerstyle is None:
3007             markerstyle = 'None'
3008         if markercolor is None:
3009             markercolor = linecolor
3010 
3011         # resolve baseline format
3012         if basefmt is None:
3013             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3014                        "C3-")
3015         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3016 
3017         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3018         if linestyle is None:
3019             linestyle = mpl.rcParams['lines.linestyle']
3020         xlines = self.vlines if orientation == "vertical" else self.hlines
3021         stemlines = xlines(
3022             locs, bottom, heads,
3023             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3024 
3025         if orientation == 'horizontal':
3026             marker_x = heads
3027             marker_y = locs
3028             baseline_x = [bottom, bottom]
3029             baseline_y = [np.min(locs), np.max(locs)]
3030         else:
3031             marker_x = locs
3032             marker_y = heads
3033             baseline_x = [np.min(locs), np.max(locs)]
3034             baseline_y = [bottom, bottom]
3035 
3036         markerline, = self.plot(marker_x, marker_y,
3037                                 color=markercolor, linestyle=markerstyle,
3038                                 marker=markermarker, label="_nolegend_")
3039 
3040         baseline, = self.plot(baseline_x, baseline_y,
3041                               color=basecolor, linestyle=basestyle,
3042                               marker=basemarker, label="_nolegend_")
3043 
3044         stem_container = StemContainer((markerline, stemlines, baseline),
3045                                        label=label)
3046         self.add_container(stem_container)
3047         return stem_container
3048 
3049     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3050     def pie(self, x, explode=None, labels=None, colors=None,
3051             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3052             startangle=0, radius=1, counterclock=True,
3053             wedgeprops=None, textprops=None, center=(0, 0),
3054             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3055         """
3056         Plot a pie chart.
3057 
3058         Make a pie chart of array *x*.  The fractional area of each wedge is
3059         given by ``x/sum(x)``.
3060 
3061         The wedges are plotted counterclockwise, by default starting from the
3062         x-axis.
3063 
3064         Parameters
3065         ----------
3066         x : 1D array-like
3067             The wedge sizes.
3068 
3069         explode : array-like, default: None
3070             If not *None*, is a ``len(x)`` array which specifies the fraction
3071             of the radius with which to offset each wedge.
3072 
3073         labels : list, default: None
3074             A sequence of strings providing the labels for each wedge
3075 
3076         colors : array-like, default: None
3077             A sequence of colors through which the pie chart will cycle.  If
3078             *None*, will use the colors in the currently active cycle.
3079 
3080         hatch : str or list, default: None
3081             Hatching pattern applied to all pie wedges or sequence of patterns
3082             through which the chart will cycle. For a list of valid patterns,
3083             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3084 
3085             .. versionadded:: 3.7
3086 
3087         autopct : None or str or callable, default: None
3088             If not *None*, *autopct* is a string or function used to label the
3089             wedges with their numeric value. The label will be placed inside
3090             the wedge. If *autopct* is a format string, the label will be
3091             ``fmt % pct``. If *autopct* is a function, then it will be called.
3092 
3093         pctdistance : float, default: 0.6
3094             The relative distance along the radius at which the text
3095             generated by *autopct* is drawn. To draw the text outside the pie,
3096             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3097             ``None``.
3098 
3099         labeldistance : float or None, default: 1.1
3100             The relative distance along the radius at which the labels are
3101             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3102             If set to ``None``, labels are not drawn but are still stored for
3103             use in `.legend`.
3104 
3105         shadow : bool, default: False
3106             Draw a shadow beneath the pie.
3107 
3108         startangle : float, default: 0 degrees
3109             The angle by which the start of the pie is rotated,
3110             counterclockwise from the x-axis.
3111 
3112         radius : float, default: 1
3113             The radius of the pie.
3114 
3115         counterclock : bool, default: True
3116             Specify fractions direction, clockwise or counterclockwise.
3117 
3118         wedgeprops : dict, default: None
3119             Dict of arguments passed to each `.patches.Wedge` of the pie.
3120             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3121             the wedge border lines equal to 3. By default, ``clip_on=False``.
3122             When there is a conflict between these properties and other
3123             keywords, properties passed to *wedgeprops* take precedence.
3124 
3125         textprops : dict, default: None
3126             Dict of arguments to pass to the text objects.
3127 
3128         center : (float, float), default: (0, 0)
3129             The coordinates of the center of the chart.
3130 
3131         frame : bool, default: False
3132             Plot Axes frame with the chart if true.
3133 
3134         rotatelabels : bool, default: False
3135             Rotate each label to the angle of the corresponding slice if true.
3136 
3137         normalize : bool, default: True
3138             When *True*, always make a full pie by normalizing x so that
3139             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3140             and raises a `ValueError` for ``sum(x) > 1``.
3141 
3142         data : indexable object, optional
3143             DATA_PARAMETER_PLACEHOLDER
3144 
3145         Returns
3146         -------
3147         patches : list
3148             A sequence of `matplotlib.patches.Wedge` instances
3149 
3150         texts : list
3151             A list of the label `.Text` instances.
3152 
3153         autotexts : list
3154             A list of `.Text` instances for the numeric labels. This will only
3155             be returned if the parameter *autopct* is not *None*.
3156 
3157         Notes
3158         -----
3159         The pie chart will probably look best if the figure and Axes are
3160         square, or the Axes aspect is equal.
3161         This method sets the aspect ratio of the axis to "equal".
3162         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3163         """
3164         self.set_aspect('equal')
3165         # The use of float32 is "historical", but can't be changed without
3166         # regenerating the test baselines.
3167         x = np.asarray(x, np.float32)
3168         if x.ndim > 1:
3169             raise ValueError("x must be 1D")
3170 
3171         if np.any(x < 0):
3172             raise ValueError("Wedge sizes 'x' must be non negative values")
3173 
3174         sx = x.sum()
3175 
3176         if normalize:
3177             x = x / sx
3178         elif sx > 1:
3179             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3180         if labels is None:
3181             labels = [''] * len(x)
3182         if explode is None:
3183             explode = [0] * len(x)
3184         if len(x) != len(labels):
3185             raise ValueError("'label' must be of length 'x'")
3186         if len(x) != len(explode):
3187             raise ValueError("'explode' must be of length 'x'")
3188         if colors is None:
3189             get_next_color = self._get_patches_for_fill.get_next_color
3190         else:
3191             color_cycle = itertools.cycle(colors)
3192 
3193             def get_next_color():
3194                 return next(color_cycle)
3195 
3196         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3197 
3198         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3199         if radius <= 0:
3200             raise ValueError(f'radius must be a positive number, not {radius}')
3201 
3202         # Starting theta1 is the start fraction of the circle
3203         theta1 = startangle / 360
3204 
3205         if wedgeprops is None:
3206             wedgeprops = {}
3207         if textprops is None:
3208             textprops = {}
3209 
3210         texts = []
3211         slices = []
3212         autotexts = []
3213 
3214         for frac, label, expl in zip(x, labels, explode):
3215             x, y = center
3216             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3217             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3218             x += expl * math.cos(thetam)
3219             y += expl * math.sin(thetam)
3220 
3221             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3222                                360. * max(theta1, theta2),
3223                                facecolor=get_next_color(),
3224                                hatch=next(hatch_cycle),
3225                                clip_on=False,
3226                                label=label)
3227             w.set(**wedgeprops)
3228             slices.append(w)
3229             self.add_patch(w)
3230 
3231             if shadow:
3232                 # Make sure to add a shadow after the call to add_patch so the
3233                 # figure and transform props will be set.
3234                 shad = mpatches.Shadow(w, -0.02, -0.02, label='_nolegend_')
3235                 self.add_patch(shad)
3236 
3237             if labeldistance is not None:
3238                 xt = x + labeldistance * radius * math.cos(thetam)
3239                 yt = y + labeldistance * radius * math.sin(thetam)
3240                 label_alignment_h = 'left' if xt > 0 else 'right'
3241                 label_alignment_v = 'center'
3242                 label_rotation = 'horizontal'
3243                 if rotatelabels:
3244                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3245                     label_rotation = (np.rad2deg(thetam)
3246                                       + (0 if xt > 0 else 180))
3247                 t = self.text(xt, yt, label,
3248                               clip_on=False,
3249                               horizontalalignment=label_alignment_h,
3250                               verticalalignment=label_alignment_v,
3251                               rotation=label_rotation,
3252                               size=mpl.rcParams['xtick.labelsize'])
3253                 t.set(**textprops)
3254                 texts.append(t)
3255 
3256             if autopct is not None:
3257                 xt = x + pctdistance * radius * math.cos(thetam)
3258                 yt = y + pctdistance * radius * math.sin(thetam)
3259                 if isinstance(autopct, str):
3260                     s = autopct % (100. * frac)
3261                 elif callable(autopct):
3262                     s = autopct(100. * frac)
3263                 else:
3264                     raise TypeError(
3265                         'autopct must be callable or a format string')
3266                 t = self.text(xt, yt, s,
3267                               clip_on=False,
3268                               horizontalalignment='center',
3269                               verticalalignment='center')
3270                 t.set(**textprops)
3271                 autotexts.append(t)
3272 
3273             theta1 = theta2
3274 
3275         if frame:
3276             self._request_autoscale_view()
3277         else:
3278             self.set(frame_on=False, xticks=[], yticks=[],
3279                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3280                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3281 
3282         if autopct is None:
3283             return slices, texts
3284         else:
3285             return slices, texts, autotexts
3286 
3287     @staticmethod
3288     def _errorevery_to_mask(x, errorevery):
3289         """
3290         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3291 
3292         This function is split out to be usable both by 2D and 3D errorbars.
3293         """
3294         if isinstance(errorevery, Integral):
3295             errorevery = (0, errorevery)
3296         if isinstance(errorevery, tuple):
3297             if (len(errorevery) == 2 and
3298                     isinstance(errorevery[0], Integral) and
3299                     isinstance(errorevery[1], Integral)):
3300                 errorevery = slice(errorevery[0], None, errorevery[1])
3301             else:
3302                 raise ValueError(
3303                     f'{errorevery=!r} is a not a tuple of two integers')
3304         elif isinstance(errorevery, slice):
3305             pass
3306         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3307             try:
3308                 x[errorevery]  # fancy indexing
3309             except (ValueError, IndexError) as err:
3310                 raise ValueError(
3311                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3312                     "index to match 'xerr'/'yerr'") from err
3313         else:
3314             raise ValueError(f"{errorevery=!r} is not a recognized value")
3315         everymask = np.zeros(len(x), bool)
3316         everymask[errorevery] = True
3317         return everymask
3318 
3319     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3320                       label_namer="y")
3321     @_docstring.dedent_interpd
3322     def errorbar(self, x, y, yerr=None, xerr=None,
3323                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3324                  barsabove=False, lolims=False, uplims=False,
3325                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3326                  **kwargs):
3327         """
3328         Plot y versus x as lines and/or markers with attached errorbars.
3329 
3330         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3331         sizes. By default, this draws the data markers/lines as well the
3332         errorbars. Use fmt='none' to draw errorbars without any data markers.
3333 
3334         .. versionadded:: 3.7
3335            Caps and error lines are drawn in polar coordinates on polar plots.
3336 
3337 
3338         Parameters
3339         ----------
3340         x, y : float or array-like
3341             The data positions.
3342 
3343         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3344             The errorbar sizes:
3345 
3346             - scalar: Symmetric +/- values for all data points.
3347             - shape(N,): Symmetric +/-values for each data point.
3348             - shape(2, N): Separate - and + values for each bar. First row
3349               contains the lower errors, the second row contains the upper
3350               errors.
3351             - *None*: No errorbar.
3352 
3353             All values must be >= 0.
3354 
3355             See :doc:`/gallery/statistics/errorbar_features`
3356             for an example on the usage of ``xerr`` and ``yerr``.
3357 
3358         fmt : str, default: ''
3359             The format for the data points / data lines. See `.plot` for
3360             details.
3361 
3362             Use 'none' (case-insensitive) to plot errorbars without any data
3363             markers.
3364 
3365         ecolor : color, default: None
3366             The color of the errorbar lines.  If None, use the color of the
3367             line connecting the markers.
3368 
3369         elinewidth : float, default: None
3370             The linewidth of the errorbar lines. If None, the linewidth of
3371             the current style is used.
3372 
3373         capsize : float, default: :rc:`errorbar.capsize`
3374             The length of the error bar caps in points.
3375 
3376         capthick : float, default: None
3377             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3378             This setting is a more sensible name for the property that
3379             controls the thickness of the error bar cap in points. For
3380             backwards compatibility, if *mew* or *markeredgewidth* are given,
3381             then they will over-ride *capthick*. This may change in future
3382             releases.
3383 
3384         barsabove : bool, default: False
3385             If True, will plot the errorbars above the plot
3386             symbols. Default is below.
3387 
3388         lolims, uplims, xlolims, xuplims : bool, default: False
3389             These arguments can be used to indicate that a value gives only
3390             upper/lower limits.  In that case a caret symbol is used to
3391             indicate this. *lims*-arguments may be scalars, or array-likes of
3392             the same length as *xerr* and *yerr*.  To use limits with inverted
3393             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3394             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3395             *lolims* to True means that the y-value is a *lower* limit of the
3396             True value, so, only an *upward*-pointing arrow will be drawn!
3397 
3398         errorevery : int or (int, int), default: 1
3399             draws error bars on a subset of the data. *errorevery* =N draws
3400             error bars on the points (x[::N], y[::N]).
3401             *errorevery* =(start, N) draws error bars on the points
3402             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3403             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3404             Used to avoid overlapping error bars when two series share x-axis
3405             values.
3406 
3407         Returns
3408         -------
3409         `.ErrorbarContainer`
3410             The container contains:
3411 
3412             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3413             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3414             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3415               vertical error ranges.
3416 
3417         Other Parameters
3418         ----------------
3419         data : indexable object, optional
3420             DATA_PARAMETER_PLACEHOLDER
3421 
3422         **kwargs
3423             All other keyword arguments are passed on to the `~.Axes.plot` call
3424             drawing the markers. For example, this code makes big red squares
3425             with thick green edges::
3426 
3427                 x, y, yerr = rand(3, 10)
3428                 errorbar(x, y, yerr, marker='s', mfc='red',
3429                          mec='green', ms=20, mew=4)
3430 
3431             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3432             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3433             and *markeredgewidth*.
3434 
3435             Valid kwargs for the marker properties are:
3436 
3437             - *dashes*
3438             - *dash_capstyle*
3439             - *dash_joinstyle*
3440             - *drawstyle*
3441             - *fillstyle*
3442             - *linestyle*
3443             - *marker*
3444             - *markeredgecolor*
3445             - *markeredgewidth*
3446             - *markerfacecolor*
3447             - *markerfacecoloralt*
3448             - *markersize*
3449             - *markevery*
3450             - *solid_capstyle*
3451             - *solid_joinstyle*
3452 
3453             Refer to the corresponding `.Line2D` property for more details:
3454 
3455             %(Line2D:kwdoc)s
3456         """
3457         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3458         # Drop anything that comes in as None to use the default instead.
3459         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3460         kwargs.setdefault('zorder', 2)
3461 
3462         # Casting to object arrays preserves units.
3463         if not isinstance(x, np.ndarray):
3464             x = np.asarray(x, dtype=object)
3465         if not isinstance(y, np.ndarray):
3466             y = np.asarray(y, dtype=object)
3467 
3468         def _upcast_err(err):
3469             """
3470             Safely handle tuple of containers that carry units.
3471 
3472             This function covers the case where the input to the xerr/yerr is a
3473             length 2 tuple of equal length ndarray-subclasses that carry the
3474             unit information in the container.
3475 
3476             If we have a tuple of nested numpy array (subclasses), we defer
3477             coercing the units to be consistent to the underlying unit
3478             library (and implicitly the broadcasting).
3479 
3480             Otherwise, fallback to casting to an object array.
3481             """
3482 
3483             if (
3484                     # make sure it is not a scalar
3485                     np.iterable(err) and
3486                     # and it is not empty
3487                     len(err) > 0 and
3488                     # and the first element is an array sub-class use
3489                     # safe_first_element because getitem is index-first not
3490                     # location first on pandas objects so err[0] almost always
3491                     # fails.
3492                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3493             ):
3494                 # Get the type of the first element
3495                 atype = type(cbook._safe_first_finite(err))
3496                 # Promote the outer container to match the inner container
3497                 if atype is np.ndarray:
3498                     # Converts using np.asarray, because data cannot
3499                     # be directly passed to init of np.ndarray
3500                     return np.asarray(err, dtype=object)
3501                 # If atype is not np.ndarray, directly pass data to init.
3502                 # This works for types such as unyts and astropy units
3503                 return atype(err)
3504             # Otherwise wrap it in an object array
3505             return np.asarray(err, dtype=object)
3506 
3507         if xerr is not None and not isinstance(xerr, np.ndarray):
3508             xerr = _upcast_err(xerr)
3509         if yerr is not None and not isinstance(yerr, np.ndarray):
3510             yerr = _upcast_err(yerr)
3511         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3512         if len(x) != len(y):
3513             raise ValueError("'x' and 'y' must have the same size")
3514 
3515         everymask = self._errorevery_to_mask(x, errorevery)
3516 
3517         label = kwargs.pop("label", None)
3518         kwargs['label'] = '_nolegend_'
3519 
3520         # Create the main line and determine overall kwargs for child artists.
3521         # We avoid calling self.plot() directly, or self._get_lines(), because
3522         # that would call self._process_unit_info again, and do other indirect
3523         # data processing.
3524         (data_line, base_style), = self._get_lines._plot_args(
3525             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3526 
3527         # Do this after creating `data_line` to avoid modifying `base_style`.
3528         if barsabove:
3529             data_line.set_zorder(kwargs['zorder'] - .1)
3530         else:
3531             data_line.set_zorder(kwargs['zorder'] + .1)
3532 
3533         # Add line to plot, or throw it away and use it to determine kwargs.
3534         if fmt.lower() != 'none':
3535             self.add_line(data_line)
3536         else:
3537             data_line = None
3538             # Remove alpha=0 color that _get_lines._plot_args returns for
3539             # 'none' format, and replace it with user-specified color, if
3540             # supplied.
3541             base_style.pop('color')
3542             if 'color' in kwargs:
3543                 base_style['color'] = kwargs.pop('color')
3544 
3545         if 'color' not in base_style:
3546             base_style['color'] = 'C0'
3547         if ecolor is None:
3548             ecolor = base_style['color']
3549 
3550         # Eject any line-specific information from format string, as it's not
3551         # needed for bars or caps.
3552         for key in ['marker', 'markersize', 'markerfacecolor',
3553                     'markerfacecoloralt',
3554                     'markeredgewidth', 'markeredgecolor', 'markevery',
3555                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3556                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3557                     'dashes']:
3558             base_style.pop(key, None)
3559 
3560         # Make the style dict for the line collections (the bars).
3561         eb_lines_style = {**base_style, 'color': ecolor}
3562 
3563         if elinewidth is not None:
3564             eb_lines_style['linewidth'] = elinewidth
3565         elif 'linewidth' in kwargs:
3566             eb_lines_style['linewidth'] = kwargs['linewidth']
3567 
3568         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3569             if key in kwargs:
3570                 eb_lines_style[key] = kwargs[key]
3571 
3572         # Make the style dict for caps (the "hats").
3573         eb_cap_style = {**base_style, 'linestyle': 'none'}
3574         if capsize is None:
3575             capsize = mpl.rcParams["errorbar.capsize"]
3576         if capsize > 0:
3577             eb_cap_style['markersize'] = 2. * capsize
3578         if capthick is not None:
3579             eb_cap_style['markeredgewidth'] = capthick
3580 
3581         # For backwards-compat, allow explicit setting of
3582         # 'markeredgewidth' to over-ride capthick.
3583         for key in ('markeredgewidth', 'transform', 'alpha',
3584                     'zorder', 'rasterized'):
3585             if key in kwargs:
3586                 eb_cap_style[key] = kwargs[key]
3587         eb_cap_style['color'] = ecolor
3588 
3589         barcols = []
3590         caplines = {'x': [], 'y': []}
3591 
3592         # Vectorized fancy-indexer.
3593         def apply_mask(arrays, mask):
3594             return [array[mask] for array in arrays]
3595 
3596         # dep: dependent dataset, indep: independent dataset
3597         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3598              marker, lomarker, himarker) in [
3599                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3600                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3601                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3602                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3603         ]:
3604             if err is None:
3605                 continue
3606             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3607             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3608             try:
3609                 np.broadcast_to(err, (2, len(dep)))
3610             except ValueError:
3611                 raise ValueError(
3612                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3613                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3614                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3615             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3616             if np.any(np.less(err, -err, out=res, where=(err == err))):
3617                 # like err<0, but also works for timedelta and nan.
3618                 raise ValueError(
3619                     f"'{dep_axis}err' must not contain negative values")
3620             # This is like
3621             #     elow, ehigh = np.broadcast_to(...)
3622             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3623             # except that broadcast_to would strip units.
3624             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3625             barcols.append(lines_func(
3626                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3627             if self.name == "polar" and dep_axis == "x":
3628                 for b in barcols:
3629                     for p in b.get_paths():
3630                         p._interpolation_steps = 2
3631             # Normal errorbars for points without upper/lower limits.
3632             nolims = ~(lolims | uplims)
3633             if nolims.any() and capsize > 0:
3634                 indep_masked, lo_masked, hi_masked = apply_mask(
3635                     [indep, low, high], nolims & everymask)
3636                 for lh_masked in [lo_masked, hi_masked]:
3637                     # Since this has to work for x and y as dependent data, we
3638                     # first set both x and y to the independent variable and
3639                     # overwrite the respective dependent data in a second step.
3640                     line = mlines.Line2D(indep_masked, indep_masked,
3641                                          marker=marker, **eb_cap_style)
3642                     line.set(**{f"{dep_axis}data": lh_masked})
3643                     caplines[dep_axis].append(line)
3644             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3645                 if not lims.any():
3646                     continue
3647                 hlmarker = (
3648                     himarker
3649                     if self._axis_map[dep_axis].get_inverted() ^ idx
3650                     else lomarker)
3651                 x_masked, y_masked, hl_masked = apply_mask(
3652                     [x, y, hl], lims & everymask)
3653                 # As above, we set the dependent data in a second step.
3654                 line = mlines.Line2D(x_masked, y_masked,
3655                                      marker=hlmarker, **eb_cap_style)
3656                 line.set(**{f"{dep_axis}data": hl_masked})
3657                 caplines[dep_axis].append(line)
3658                 if capsize > 0:
3659                     caplines[dep_axis].append(mlines.Line2D(
3660                         x_masked, y_masked, marker=marker, **eb_cap_style))
3661         if self.name == 'polar':
3662             for axis in caplines:
3663                 for l in caplines[axis]:
3664                     # Rotate caps to be perpendicular to the error bars
3665                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3666                         rotation = mtransforms.Affine2D().rotate(theta)
3667                         if axis == 'y':
3668                             rotation.rotate(-np.pi / 2)
3669                         ms = mmarkers.MarkerStyle(marker=marker,
3670                                                   transform=rotation)
3671                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3672                                                     **eb_cap_style))
3673         else:
3674             for axis in caplines:
3675                 for l in caplines[axis]:
3676                     self.add_line(l)
3677 
3678         self._request_autoscale_view()
3679         caplines = caplines['x'] + caplines['y']
3680         errorbar_container = ErrorbarContainer(
3681             (data_line, tuple(caplines), tuple(barcols)),
3682             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3683             label=label)
3684         self.containers.append(errorbar_container)
3685 
3686         return errorbar_container  # (l0, caplines, barcols)
3687 
3688     @_preprocess_data()
3689     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3690                 positions=None, widths=None, patch_artist=None,
3691                 bootstrap=None, usermedians=None, conf_intervals=None,
3692                 meanline=None, showmeans=None, showcaps=None,
3693                 showbox=None, showfliers=None, boxprops=None,
3694                 labels=None, flierprops=None, medianprops=None,
3695                 meanprops=None, capprops=None, whiskerprops=None,
3696                 manage_ticks=True, autorange=False, zorder=None,
3697                 capwidths=None):
3698         """
3699         Draw a box and whisker plot.
3700 
3701         The box extends from the first quartile (Q1) to the third
3702         quartile (Q3) of the data, with a line at the median.
3703         The whiskers extend from the box to the farthest data point
3704         lying within 1.5x the inter-quartile range (IQR) from the box.
3705         Flier points are those past the end of the whiskers.
3706         See https://en.wikipedia.org/wiki/Box_plot for reference.
3707 
3708         .. code-block:: none
3709 
3710                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3711                                |-----:-----|
3712                o      |--------|     :     |--------|    o  o
3713                                |-----:-----|
3714              flier             <----------->            fliers
3715                                     IQR
3716 
3717 
3718         Parameters
3719         ----------
3720         x : Array or a sequence of vectors.
3721             The input data.  If a 2D array, a boxplot is drawn for each column
3722             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3723             array in *x*.
3724 
3725         notch : bool, default: False
3726             Whether to draw a notched boxplot (`True`), or a rectangular
3727             boxplot (`False`).  The notches represent the confidence interval
3728             (CI) around the median.  The documentation for *bootstrap*
3729             describes how the locations of the notches are computed by
3730             default, but their locations may also be overridden by setting the
3731             *conf_intervals* parameter.
3732 
3733             .. note::
3734 
3735                 In cases where the values of the CI are less than the
3736                 lower quartile or greater than the upper quartile, the
3737                 notches will extend beyond the box, giving it a
3738                 distinctive "flipped" appearance. This is expected
3739                 behavior and consistent with other statistical
3740                 visualization packages.
3741 
3742         sym : str, optional
3743             The default symbol for flier points.  An empty string ('') hides
3744             the fliers.  If `None`, then the fliers default to 'b+'.  More
3745             control is provided by the *flierprops* parameter.
3746 
3747         vert : bool, default: True
3748             If `True`, draws vertical boxes.
3749             If `False`, draw horizontal boxes.
3750 
3751         whis : float or (float, float), default: 1.5
3752             The position of the whiskers.
3753 
3754             If a float, the lower whisker is at the lowest datum above
3755             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3756             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3757             third quartiles.  The default value of ``whis = 1.5`` corresponds
3758             to Tukey's original definition of boxplots.
3759 
3760             If a pair of floats, they indicate the percentiles at which to
3761             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3762             (0, 100) results in whiskers covering the whole range of the data.
3763 
3764             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3765             to (0, 100) (cover the whole range of the data) if *autorange* is
3766             True.
3767 
3768             Beyond the whiskers, data are considered outliers and are plotted
3769             as individual points.
3770 
3771         bootstrap : int, optional
3772             Specifies whether to bootstrap the confidence intervals
3773             around the median for notched boxplots. If *bootstrap* is
3774             None, no bootstrapping is performed, and notches are
3775             calculated using a Gaussian-based asymptotic approximation
3776             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3777             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3778             the number of times to bootstrap the median to determine its
3779             95% confidence intervals. Values between 1000 and 10000 are
3780             recommended.
3781 
3782         usermedians : 1D array-like, optional
3783             A 1D array-like of length ``len(x)``.  Each entry that is not
3784             `None` forces the value of the median for the corresponding
3785             dataset.  For entries that are `None`, the medians are computed
3786             by Matplotlib as normal.
3787 
3788         conf_intervals : array-like, optional
3789             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3790             None forces the location of the corresponding notch (which is
3791             only drawn if *notch* is `True`).  For entries that are `None`,
3792             the notches are computed by the method specified by the other
3793             parameters (e.g., *bootstrap*).
3794 
3795         positions : array-like, optional
3796             The positions of the boxes. The ticks and limits are
3797             automatically set to match the positions. Defaults to
3798             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3799 
3800         widths : float or array-like
3801             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3802             between extreme positions)``, if that is smaller.
3803 
3804         patch_artist : bool, default: False
3805             If `False` produces boxes with the Line2D artist. Otherwise,
3806             boxes are drawn with Patch artists.
3807 
3808         labels : sequence, optional
3809             Labels for each dataset (one per dataset).
3810 
3811         manage_ticks : bool, default: True
3812             If True, the tick locations and labels will be adjusted to match
3813             the boxplot positions.
3814 
3815         autorange : bool, default: False
3816             When `True` and the data are distributed such that the 25th and
3817             75th percentiles are equal, *whis* is set to (0, 100) such
3818             that the whisker ends are at the minimum and maximum of the data.
3819 
3820         meanline : bool, default: False
3821             If `True` (and *showmeans* is `True`), will try to render the
3822             mean as a line spanning the full width of the box according to
3823             *meanprops* (see below).  Not recommended if *shownotches* is also
3824             True.  Otherwise, means will be shown as points.
3825 
3826         zorder : float, default: ``Line2D.zorder = 2``
3827             The zorder of the boxplot.
3828 
3829         Returns
3830         -------
3831         dict
3832           A dictionary mapping each component of the boxplot to a list
3833           of the `.Line2D` instances created. That dictionary has the
3834           following keys (assuming vertical boxplots):
3835 
3836           - ``boxes``: the main body of the boxplot showing the
3837             quartiles and the median's confidence intervals if
3838             enabled.
3839 
3840           - ``medians``: horizontal lines at the median of each box.
3841 
3842           - ``whiskers``: the vertical lines extending to the most
3843             extreme, non-outlier data points.
3844 
3845           - ``caps``: the horizontal lines at the ends of the
3846             whiskers.
3847 
3848           - ``fliers``: points representing data that extend beyond
3849             the whiskers (fliers).
3850 
3851           - ``means``: points or lines representing the means.
3852 
3853         Other Parameters
3854         ----------------
3855         showcaps : bool, default: True
3856             Show the caps on the ends of whiskers.
3857         showbox : bool, default: True
3858             Show the central box.
3859         showfliers : bool, default: True
3860             Show the outliers beyond the caps.
3861         showmeans : bool, default: False
3862             Show the arithmetic means.
3863         capprops : dict, default: None
3864             The style of the caps.
3865         capwidths : float or array, default: None
3866             The widths of the caps.
3867         boxprops : dict, default: None
3868             The style of the box.
3869         whiskerprops : dict, default: None
3870             The style of the whiskers.
3871         flierprops : dict, default: None
3872             The style of the fliers.
3873         medianprops : dict, default: None
3874             The style of the median.
3875         meanprops : dict, default: None
3876             The style of the mean.
3877         data : indexable object, optional
3878             DATA_PARAMETER_PLACEHOLDER
3879 
3880         See Also
3881         --------
3882         violinplot : Draw an estimate of the probability density function.
3883         """
3884 
3885         # Missing arguments default to rcParams.
3886         if whis is None:
3887             whis = mpl.rcParams['boxplot.whiskers']
3888         if bootstrap is None:
3889             bootstrap = mpl.rcParams['boxplot.bootstrap']
3890 
3891         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3892                                        labels=labels, autorange=autorange)
3893         if notch is None:
3894             notch = mpl.rcParams['boxplot.notch']
3895         if vert is None:
3896             vert = mpl.rcParams['boxplot.vertical']
3897         if patch_artist is None:
3898             patch_artist = mpl.rcParams['boxplot.patchartist']
3899         if meanline is None:
3900             meanline = mpl.rcParams['boxplot.meanline']
3901         if showmeans is None:
3902             showmeans = mpl.rcParams['boxplot.showmeans']
3903         if showcaps is None:
3904             showcaps = mpl.rcParams['boxplot.showcaps']
3905         if showbox is None:
3906             showbox = mpl.rcParams['boxplot.showbox']
3907         if showfliers is None:
3908             showfliers = mpl.rcParams['boxplot.showfliers']
3909 
3910         if boxprops is None:
3911             boxprops = {}
3912         if whiskerprops is None:
3913             whiskerprops = {}
3914         if capprops is None:
3915             capprops = {}
3916         if medianprops is None:
3917             medianprops = {}
3918         if meanprops is None:
3919             meanprops = {}
3920         if flierprops is None:
3921             flierprops = {}
3922 
3923         if patch_artist:
3924             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3925             if 'color' in boxprops:
3926                 boxprops['edgecolor'] = boxprops.pop('color')
3927 
3928         # if non-default sym value, put it into the flier dictionary
3929         # the logic for providing the default symbol ('b+') now lives
3930         # in bxp in the initial value of flierkw
3931         # handle all of the *sym* related logic here so we only have to pass
3932         # on the flierprops dict.
3933         if sym is not None:
3934             # no-flier case, which should really be done with
3935             # 'showfliers=False' but none-the-less deal with it to keep back
3936             # compatibility
3937             if sym == '':
3938                 # blow away existing dict and make one for invisible markers
3939                 flierprops = dict(linestyle='none', marker='', color='none')
3940                 # turn the fliers off just to be safe
3941                 showfliers = False
3942             # now process the symbol string
3943             else:
3944                 # process the symbol string
3945                 # discarded linestyle
3946                 _, marker, color = _process_plot_format(sym)
3947                 # if we have a marker, use it
3948                 if marker is not None:
3949                     flierprops['marker'] = marker
3950                 # if we have a color, use it
3951                 if color is not None:
3952                     # assume that if color is passed in the user want
3953                     # filled symbol, if the users want more control use
3954                     # flierprops
3955                     flierprops['color'] = color
3956                     flierprops['markerfacecolor'] = color
3957                     flierprops['markeredgecolor'] = color
3958 
3959         # replace medians if necessary:
3960         if usermedians is not None:
3961             if (len(np.ravel(usermedians)) != len(bxpstats) or
3962                     np.shape(usermedians)[0] != len(bxpstats)):
3963                 raise ValueError(
3964                     "'usermedians' and 'x' have different lengths")
3965             else:
3966                 # reassign medians as necessary
3967                 for stats, med in zip(bxpstats, usermedians):
3968                     if med is not None:
3969                         stats['med'] = med
3970 
3971         if conf_intervals is not None:
3972             if len(conf_intervals) != len(bxpstats):
3973                 raise ValueError(
3974                     "'conf_intervals' and 'x' have different lengths")
3975             else:
3976                 for stats, ci in zip(bxpstats, conf_intervals):
3977                     if ci is not None:
3978                         if len(ci) != 2:
3979                             raise ValueError('each confidence interval must '
3980                                              'have two values')
3981                         else:
3982                             if ci[0] is not None:
3983                                 stats['cilo'] = ci[0]
3984                             if ci[1] is not None:
3985                                 stats['cihi'] = ci[1]
3986 
3987         artists = self.bxp(bxpstats, positions=positions, widths=widths,
3988                            vert=vert, patch_artist=patch_artist,
3989                            shownotches=notch, showmeans=showmeans,
3990                            showcaps=showcaps, showbox=showbox,
3991                            boxprops=boxprops, flierprops=flierprops,
3992                            medianprops=medianprops, meanprops=meanprops,
3993                            meanline=meanline, showfliers=showfliers,
3994                            capprops=capprops, whiskerprops=whiskerprops,
3995                            manage_ticks=manage_ticks, zorder=zorder,
3996                            capwidths=capwidths)
3997         return artists
3998 
3999     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4000             patch_artist=False, shownotches=False, showmeans=False,
4001             showcaps=True, showbox=True, showfliers=True,
4002             boxprops=None, whiskerprops=None, flierprops=None,
4003             medianprops=None, capprops=None, meanprops=None,
4004             meanline=False, manage_ticks=True, zorder=None,
4005             capwidths=None):
4006         """
4007         Drawing function for box and whisker plots.
4008 
4009         Make a box and whisker plot for each column of *x* or each
4010         vector in sequence *x*.  The box extends from the lower to
4011         upper quartile values of the data, with a line at the median.
4012         The whiskers extend from the box to show the range of the
4013         data.  Flier points are those past the end of the whiskers.
4014 
4015         Parameters
4016         ----------
4017         bxpstats : list of dicts
4018           A list of dictionaries containing stats for each boxplot.
4019           Required keys are:
4020 
4021           - ``med``: Median (scalar).
4022           - ``q1``, ``q3``: First & third quartiles (scalars).
4023           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4024 
4025           Optional keys are:
4026 
4027           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4028           - ``fliers``: Data beyond the whiskers (array-like).
4029             Needed if ``showfliers=True``.
4030           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4031             about the median. Needed if ``shownotches=True``.
4032           - ``label``: Name of the dataset (str).  If available,
4033             this will be used a tick label for the boxplot
4034 
4035         positions : array-like, default: [1, 2, ..., n]
4036           The positions of the boxes. The ticks and limits
4037           are automatically set to match the positions.
4038 
4039         widths : float or array-like, default: None
4040           The widths of the boxes.  The default is
4041           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4042 
4043         capwidths : float or array-like, default: None
4044           Either a scalar or a vector and sets the width of each cap.
4045           The default is ``0.5*(with of the box)``, see *widths*.
4046 
4047         vert : bool, default: True
4048           If `True` (default), makes the boxes vertical.
4049           If `False`, makes horizontal boxes.
4050 
4051         patch_artist : bool, default: False
4052           If `False` produces boxes with the `.Line2D` artist.
4053           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4054 
4055         shownotches, showmeans, showcaps, showbox, showfliers : bool
4056           Whether to draw the CI notches, the mean value (both default to
4057           False), the caps, the box, and the fliers (all three default to
4058           True).
4059 
4060         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4061  dict, optional
4062           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4063           means.
4064 
4065         meanline : bool, default: False
4066           If `True` (and *showmeans* is `True`), will try to render the mean
4067           as a line spanning the full width of the box according to
4068           *meanprops*. Not recommended if *shownotches* is also True.
4069           Otherwise, means will be shown as points.
4070 
4071         manage_ticks : bool, default: True
4072           If True, the tick locations and labels will be adjusted to match the
4073           boxplot positions.
4074 
4075         zorder : float, default: ``Line2D.zorder = 2``
4076           The zorder of the resulting boxplot.
4077 
4078         Returns
4079         -------
4080         dict
4081           A dictionary mapping each component of the boxplot to a list
4082           of the `.Line2D` instances created. That dictionary has the
4083           following keys (assuming vertical boxplots):
4084 
4085           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4086             the median's confidence intervals if enabled.
4087           - ``medians``: horizontal lines at the median of each box.
4088           - ``whiskers``: vertical lines up to the last non-outlier data.
4089           - ``caps``: horizontal lines at the ends of the whiskers.
4090           - ``fliers``: points representing data beyond the whiskers (fliers).
4091           - ``means``: points or lines representing the means.
4092 
4093         Examples
4094         --------
4095         .. plot:: gallery/statistics/bxp.py
4096         """
4097 
4098         # lists of artists to be output
4099         whiskers = []
4100         caps = []
4101         boxes = []
4102         medians = []
4103         means = []
4104         fliers = []
4105 
4106         # empty list of xticklabels
4107         datalabels = []
4108 
4109         # Use default zorder if none specified
4110         if zorder is None:
4111             zorder = mlines.Line2D.zorder
4112 
4113         zdelta = 0.1
4114 
4115         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4116             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4117                  if k.startswith(f'boxplot.{subkey}props')}
4118             d['zorder'] = zorder + zdelta
4119             if not usemarker:
4120                 d['marker'] = ''
4121             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4122             return d
4123 
4124         box_kw = {
4125             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4126             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4127             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4128             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4129                           else mpl.rcParams['patch.facecolor']),
4130             'zorder': zorder,
4131             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4132         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4133         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4134         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4135         flier_kw = merge_kw_rc('flier', flierprops)
4136         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4137         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4138         removed_prop = 'marker' if meanline else 'linestyle'
4139         # Only remove the property if it's not set explicitly as a parameter.
4140         if meanprops is None or removed_prop not in meanprops:
4141             mean_kw[removed_prop] = ''
4142 
4143         # vertical or horizontal plot?
4144         maybe_swap = slice(None) if vert else slice(None, None, -1)
4145 
4146         def do_plot(xs, ys, **kwargs):
4147             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4148 
4149         def do_patch(xs, ys, **kwargs):
4150             path = mpath.Path._create_closed(
4151                 np.column_stack([xs, ys][maybe_swap]))
4152             patch = mpatches.PathPatch(path, **kwargs)
4153             self.add_artist(patch)
4154             return patch
4155 
4156         # input validation
4157         N = len(bxpstats)
4158         datashape_message = ("List of boxplot statistics and `{0}` "
4159                              "values must have same the length")
4160         # check position
4161         if positions is None:
4162             positions = list(range(1, N + 1))
4163         elif len(positions) != N:
4164             raise ValueError(datashape_message.format("positions"))
4165 
4166         positions = np.array(positions)
4167         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4168             raise TypeError("positions should be an iterable of numbers")
4169 
4170         # width
4171         if widths is None:
4172             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4173         elif np.isscalar(widths):
4174             widths = [widths] * N
4175         elif len(widths) != N:
4176             raise ValueError(datashape_message.format("widths"))
4177 
4178         # capwidth
4179         if capwidths is None:
4180             capwidths = 0.5 * np.array(widths)
4181         elif np.isscalar(capwidths):
4182             capwidths = [capwidths] * N
4183         elif len(capwidths) != N:
4184             raise ValueError(datashape_message.format("capwidths"))
4185 
4186         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4187                                                capwidths):
4188             # try to find a new label
4189             datalabels.append(stats.get('label', pos))
4190 
4191             # whisker coords
4192             whis_x = [pos, pos]
4193             whislo_y = [stats['q1'], stats['whislo']]
4194             whishi_y = [stats['q3'], stats['whishi']]
4195             # cap coords
4196             cap_left = pos - capwidth * 0.5
4197             cap_right = pos + capwidth * 0.5
4198             cap_x = [cap_left, cap_right]
4199             cap_lo = np.full(2, stats['whislo'])
4200             cap_hi = np.full(2, stats['whishi'])
4201             # box and median coords
4202             box_left = pos - width * 0.5
4203             box_right = pos + width * 0.5
4204             med_y = [stats['med'], stats['med']]
4205             # notched boxes
4206             if shownotches:
4207                 notch_left = pos - width * 0.25
4208                 notch_right = pos + width * 0.25
4209                 box_x = [box_left, box_right, box_right, notch_right,
4210                          box_right, box_right, box_left, box_left, notch_left,
4211                          box_left, box_left]
4212                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4213                          stats['med'], stats['cihi'], stats['q3'],
4214                          stats['q3'], stats['cihi'], stats['med'],
4215                          stats['cilo'], stats['q1']]
4216                 med_x = [notch_left, notch_right]
4217             # plain boxes
4218             else:
4219                 box_x = [box_left, box_right, box_right, box_left, box_left]
4220                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4221                          stats['q1']]
4222                 med_x = [box_left, box_right]
4223 
4224             # maybe draw the box
4225             if showbox:
4226                 do_box = do_patch if patch_artist else do_plot
4227                 boxes.append(do_box(box_x, box_y, **box_kw))
4228             # draw the whiskers
4229             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4230             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4231             # maybe draw the caps
4232             if showcaps:
4233                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4234                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4235             # draw the medians
4236             medians.append(do_plot(med_x, med_y, **median_kw))
4237             # maybe draw the means
4238             if showmeans:
4239                 if meanline:
4240                     means.append(do_plot(
4241                         [box_left, box_right], [stats['mean'], stats['mean']],
4242                         **mean_kw
4243                     ))
4244                 else:
4245                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4246             # maybe draw the fliers
4247             if showfliers:
4248                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4249                 flier_y = stats['fliers']
4250                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4251 
4252         if manage_ticks:
4253             axis_name = "x" if vert else "y"
4254             interval = getattr(self.dataLim, f"interval{axis_name}")
4255             axis = self._axis_map[axis_name]
4256             positions = axis.convert_units(positions)
4257             # The 0.5 additional padding ensures reasonable-looking boxes
4258             # even when drawing a single box.  We set the sticky edge to
4259             # prevent margins expansion, in order to match old behavior (back
4260             # when separate calls to boxplot() would completely reset the axis
4261             # limits regardless of what was drawn before).  The sticky edges
4262             # are attached to the median lines, as they are always present.
4263             interval[:] = (min(interval[0], min(positions) - .5),
4264                            max(interval[1], max(positions) + .5))
4265             for median, position in zip(medians, positions):
4266                 getattr(median.sticky_edges, axis_name).extend(
4267                     [position - .5, position + .5])
4268             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4269             locator = axis.get_major_locator()
4270             if not isinstance(axis.get_major_locator(),
4271                               mticker.FixedLocator):
4272                 locator = mticker.FixedLocator([])
4273                 axis.set_major_locator(locator)
4274             locator.locs = np.array([*locator.locs, *positions])
4275             formatter = axis.get_major_formatter()
4276             if not isinstance(axis.get_major_formatter(),
4277                               mticker.FixedFormatter):
4278                 formatter = mticker.FixedFormatter([])
4279                 axis.set_major_formatter(formatter)
4280             formatter.seq = [*formatter.seq, *datalabels]
4281 
4282             self._request_autoscale_view()
4283 
4284         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4285                     medians=medians, fliers=fliers, means=means)
4286 
4287     @staticmethod
4288     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4289                                   get_next_color_func):
4290         """
4291         Helper function to process color related arguments of `.Axes.scatter`.
4292 
4293         Argument precedence for facecolors:
4294 
4295         - c (if not None)
4296         - kwargs['facecolor']
4297         - kwargs['facecolors']
4298         - kwargs['color'] (==kwcolor)
4299         - 'b' if in classic mode else the result of ``get_next_color_func()``
4300 
4301         Argument precedence for edgecolors:
4302 
4303         - kwargs['edgecolor']
4304         - edgecolors (is an explicit kw argument in scatter())
4305         - kwargs['color'] (==kwcolor)
4306         - 'face' if not in classic mode else None
4307 
4308         Parameters
4309         ----------
4310         c : color or sequence or sequence of color or None
4311             See argument description of `.Axes.scatter`.
4312         edgecolors : color or sequence of color or {'face', 'none'} or None
4313             See argument description of `.Axes.scatter`.
4314         kwargs : dict
4315             Additional kwargs. If these keys exist, we pop and process them:
4316             'facecolors', 'facecolor', 'edgecolor', 'color'
4317             Note: The dict is modified by this function.
4318         xsize : int
4319             The size of the x and y arrays passed to `.Axes.scatter`.
4320         get_next_color_func : callable
4321             A callable that returns a color. This color is used as facecolor
4322             if no other color is provided.
4323 
4324             Note, that this is a function rather than a fixed color value to
4325             support conditional evaluation of the next color.  As of the
4326             current implementation obtaining the next color from the
4327             property cycle advances the cycle. This must only happen if we
4328             actually use the color, which will only be decided within this
4329             method.
4330 
4331         Returns
4332         -------
4333         c
4334             The input *c* if it was not *None*, else a color derived from the
4335             other inputs or defaults.
4336         colors : array(N, 4) or None
4337             The facecolors as RGBA values, or *None* if a colormap is used.
4338         edgecolors
4339             The edgecolor.
4340 
4341         """
4342         facecolors = kwargs.pop('facecolors', None)
4343         facecolors = kwargs.pop('facecolor', facecolors)
4344         edgecolors = kwargs.pop('edgecolor', edgecolors)
4345 
4346         kwcolor = kwargs.pop('color', None)
4347 
4348         if kwcolor is not None and c is not None:
4349             raise ValueError("Supply a 'c' argument or a 'color'"
4350                              " kwarg but not both; they differ but"
4351                              " their functionalities overlap.")
4352 
4353         if kwcolor is not None:
4354             try:
4355                 mcolors.to_rgba_array(kwcolor)
4356             except ValueError as err:
4357                 raise ValueError(
4358                     "'color' kwarg must be a color or sequence of color "
4359                     "specs.  For a sequence of values to be color-mapped, use "
4360                     "the 'c' argument instead.") from err
4361             if edgecolors is None:
4362                 edgecolors = kwcolor
4363             if facecolors is None:
4364                 facecolors = kwcolor
4365 
4366         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4367             edgecolors = mpl.rcParams['scatter.edgecolors']
4368 
4369         c_was_none = c is None
4370         if c is None:
4371             c = (facecolors if facecolors is not None
4372                  else "b" if mpl.rcParams['_internal.classic_mode']
4373                  else get_next_color_func())
4374         c_is_string_or_strings = (
4375             isinstance(c, str)
4376             or (np.iterable(c) and len(c) > 0
4377                 and isinstance(cbook._safe_first_finite(c), str)))
4378 
4379         def invalid_shape_exception(csize, xsize):
4380             return ValueError(
4381                 f"'c' argument has {csize} elements, which is inconsistent "
4382                 f"with 'x' and 'y' with size {xsize}.")
4383 
4384         c_is_mapped = False  # Unless proven otherwise below.
4385         valid_shape = True  # Unless proven otherwise below.
4386         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4387             try:  # First, does 'c' look suitable for value-mapping?
4388                 c = np.asanyarray(c, dtype=float)
4389             except ValueError:
4390                 pass  # Failed to convert to float array; must be color specs.
4391             else:
4392                 # handle the documented special case of a 2D array with 1
4393                 # row which as RGB(A) to broadcast.
4394                 if c.shape == (1, 4) or c.shape == (1, 3):
4395                     c_is_mapped = False
4396                     if c.size != xsize:
4397                         valid_shape = False
4398                 # If c can be either mapped values or an RGB(A) color, prefer
4399                 # the former if shapes match, the latter otherwise.
4400                 elif c.size == xsize:
4401                     c = c.ravel()
4402                     c_is_mapped = True
4403                 else:  # Wrong size; it must not be intended for mapping.
4404                     if c.shape in ((3,), (4,)):
4405                         _api.warn_external(
4406                             "*c* argument looks like a single numeric RGB or "
4407                             "RGBA sequence, which should be avoided as value-"
4408                             "mapping will have precedence in case its length "
4409                             "matches with *x* & *y*.  Please use the *color* "
4410                             "keyword-argument or provide a 2D array "
4411                             "with a single row if you intend to specify "
4412                             "the same RGB or RGBA value for all points.")
4413                     valid_shape = False
4414         if not c_is_mapped:
4415             try:  # Is 'c' acceptable as PathCollection facecolors?
4416                 colors = mcolors.to_rgba_array(c)
4417             except (TypeError, ValueError) as err:
4418                 if "RGBA values should be within 0-1 range" in str(err):
4419                     raise
4420                 else:
4421                     if not valid_shape:
4422                         raise invalid_shape_exception(c.size, xsize) from err
4423                     # Both the mapping *and* the RGBA conversion failed: pretty
4424                     # severe failure => one may appreciate a verbose feedback.
4425                     raise ValueError(
4426                         f"'c' argument must be a color, a sequence of colors, "
4427                         f"or a sequence of numbers, not {c!r}") from err
4428             else:
4429                 if len(colors) not in (0, 1, xsize):
4430                     # NB: remember that a single color is also acceptable.
4431                     # Besides *colors* will be an empty array if c == 'none'.
4432                     raise invalid_shape_exception(len(colors), xsize)
4433         else:
4434             colors = None  # use cmap, norm after collection is created
4435         return c, colors, edgecolors
4436 
4437     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4438                                      "edgecolors", "c", "facecolor",
4439                                      "facecolors", "color"],
4440                       label_namer="y")
4441     @_docstring.interpd
4442     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4443                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4444                 edgecolors=None, plotnonfinite=False, **kwargs):
4445         """
4446         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4447 
4448         Parameters
4449         ----------
4450         x, y : float or array-like, shape (n, )
4451             The data positions.
4452 
4453         s : float or array-like, shape (n, ), optional
4454             The marker size in points**2 (typographic points are 1/72 in.).
4455             Default is ``rcParams['lines.markersize'] ** 2``.
4456 
4457             The linewidth and edgecolor can visually interact with the marker
4458             size, and can lead to artifacts if the marker size is smaller than
4459             the linewidth.
4460 
4461             If the linewidth is greater than 0 and the edgecolor is anything
4462             but *'none'*, then the effective size of the marker will be
4463             increased by half the linewidth because the stroke will be centered
4464             on the edge of the shape.
4465 
4466             To eliminate the marker edge either set *linewidth=0* or
4467             *edgecolor='none'*.
4468 
4469         c : array-like or list of colors or color, optional
4470             The marker colors. Possible values:
4471 
4472             - A scalar or sequence of n numbers to be mapped to colors using
4473               *cmap* and *norm*.
4474             - A 2D array in which the rows are RGB or RGBA.
4475             - A sequence of colors of length n.
4476             - A single color format string.
4477 
4478             Note that *c* should not be a single numeric RGB or RGBA sequence
4479             because that is indistinguishable from an array of values to be
4480             colormapped. If you want to specify the same RGB or RGBA value for
4481             all points, use a 2D array with a single row.  Otherwise,
4482             value-matching will have precedence in case of a size matching with
4483             *x* and *y*.
4484 
4485             If you wish to specify a single color for all points
4486             prefer the *color* keyword argument.
4487 
4488             Defaults to `None`. In that case the marker color is determined
4489             by the value of *color*, *facecolor* or *facecolors*. In case
4490             those are not specified or `None`, the marker color is determined
4491             by the next color of the ``Axes``' current "shape and fill" color
4492             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4493 
4494         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4495             The marker style. *marker* can be either an instance of the class
4496             or the text shorthand for a particular marker.
4497             See :mod:`matplotlib.markers` for more information about marker
4498             styles.
4499 
4500         %(cmap_doc)s
4501 
4502             This parameter is ignored if *c* is RGB(A).
4503 
4504         %(norm_doc)s
4505 
4506             This parameter is ignored if *c* is RGB(A).
4507 
4508         %(vmin_vmax_doc)s
4509 
4510             This parameter is ignored if *c* is RGB(A).
4511 
4512         alpha : float, default: None
4513             The alpha blending value, between 0 (transparent) and 1 (opaque).
4514 
4515         linewidths : float or array-like, default: :rc:`lines.linewidth`
4516             The linewidth of the marker edges. Note: The default *edgecolors*
4517             is 'face'. You may want to change this as well.
4518 
4519         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4520 default: :rc:`scatter.edgecolors`
4521             The edge color of the marker. Possible values:
4522 
4523             - 'face': The edge color will always be the same as the face color.
4524             - 'none': No patch boundary will be drawn.
4525             - A color or sequence of colors.
4526 
4527             For non-filled markers, *edgecolors* is ignored. Instead, the color
4528             is determined like with 'face', i.e. from *c*, *colors*, or
4529             *facecolors*.
4530 
4531         plotnonfinite : bool, default: False
4532             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4533             or ``nan``). If ``True`` the points are drawn with the *bad*
4534             colormap color (see `.Colormap.set_bad`).
4535 
4536         Returns
4537         -------
4538         `~matplotlib.collections.PathCollection`
4539 
4540         Other Parameters
4541         ----------------
4542         data : indexable object, optional
4543             DATA_PARAMETER_PLACEHOLDER
4544         **kwargs : `~matplotlib.collections.Collection` properties
4545 
4546         See Also
4547         --------
4548         plot : To plot scatter plots when markers are identical in size and
4549             color.
4550 
4551         Notes
4552         -----
4553         * The `.plot` function will be faster for scatterplots where markers
4554           don't vary in size or color.
4555 
4556         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4557           case all masks will be combined and only unmasked points will be
4558           plotted.
4559 
4560         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4561           may be input as N-D arrays, but within scatter they will be
4562           flattened. The exception is *c*, which will be flattened only if its
4563           size matches the size of *x* and *y*.
4564 
4565         """
4566         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4567         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4568         # np.ma.ravel yields an ndarray, not a masked array,
4569         # unless its argument is a masked array.
4570         x = np.ma.ravel(x)
4571         y = np.ma.ravel(y)
4572         if x.size != y.size:
4573             raise ValueError("x and y must be the same size")
4574 
4575         if s is None:
4576             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4577                  mpl.rcParams['lines.markersize'] ** 2.0)
4578         s = np.ma.ravel(s)
4579         if (len(s) not in (1, x.size) or
4580                 (not np.issubdtype(s.dtype, np.floating) and
4581                  not np.issubdtype(s.dtype, np.integer))):
4582             raise ValueError(
4583                 "s must be a scalar, "
4584                 "or float array-like with the same size as x and y")
4585 
4586         # get the original edgecolor the user passed before we normalize
4587         orig_edgecolor = edgecolors
4588         if edgecolors is None:
4589             orig_edgecolor = kwargs.get('edgecolor', None)
4590         c, colors, edgecolors = \
4591             self._parse_scatter_color_args(
4592                 c, edgecolors, kwargs, x.size,
4593                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4594 
4595         if plotnonfinite and colors is None:
4596             c = np.ma.masked_invalid(c)
4597             x, y, s, edgecolors, linewidths = \
4598                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4599         else:
4600             x, y, s, c, colors, edgecolors, linewidths = \
4601                 cbook._combine_masks(
4602                     x, y, s, c, colors, edgecolors, linewidths)
4603         # Unmask edgecolors if it was actually a single RGB or RGBA.
4604         if (x.size in (3, 4)
4605                 and np.ma.is_masked(edgecolors)
4606                 and not np.ma.is_masked(orig_edgecolor)):
4607             edgecolors = edgecolors.data
4608 
4609         scales = s   # Renamed for readability below.
4610 
4611         # load default marker from rcParams
4612         if marker is None:
4613             marker = mpl.rcParams['scatter.marker']
4614 
4615         if isinstance(marker, mmarkers.MarkerStyle):
4616             marker_obj = marker
4617         else:
4618             marker_obj = mmarkers.MarkerStyle(marker)
4619 
4620         path = marker_obj.get_path().transformed(
4621             marker_obj.get_transform())
4622         if not marker_obj.is_filled():
4623             if orig_edgecolor is not None:
4624                 _api.warn_external(
4625                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4626                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4627                     "ignoring the edgecolor in favor of the facecolor.  This "
4628                     "behavior may change in the future."
4629                 )
4630             # We need to handle markers that can not be filled (like
4631             # '+' and 'x') differently than markers that can be
4632             # filled, but have their fillstyle set to 'none'.  This is
4633             # to get:
4634             #
4635             #  - respecting the fillestyle if set
4636             #  - maintaining back-compatibility for querying the facecolor of
4637             #    the un-fillable markers.
4638             #
4639             # While not an ideal situation, but is better than the
4640             # alternatives.
4641             if marker_obj.get_fillstyle() == 'none':
4642                 # promote the facecolor to be the edgecolor
4643                 edgecolors = colors
4644                 # set the facecolor to 'none' (at the last chance) because
4645                 # we can not fill a path if the facecolor is non-null
4646                 # (which is defendable at the renderer level).
4647                 colors = 'none'
4648             else:
4649                 # if we are not nulling the face color we can do this
4650                 # simpler
4651                 edgecolors = 'face'
4652 
4653             if linewidths is None:
4654                 linewidths = mpl.rcParams['lines.linewidth']
4655             elif np.iterable(linewidths):
4656                 linewidths = [
4657                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4658                     for lw in linewidths]
4659 
4660         offsets = np.ma.column_stack([x, y])
4661 
4662         collection = mcoll.PathCollection(
4663             (path,), scales,
4664             facecolors=colors,
4665             edgecolors=edgecolors,
4666             linewidths=linewidths,
4667             offsets=offsets,
4668             offset_transform=kwargs.pop('transform', self.transData),
4669             alpha=alpha,
4670         )
4671         collection.set_transform(mtransforms.IdentityTransform())
4672         if colors is None:
4673             collection.set_array(c)
4674             collection.set_cmap(cmap)
4675             collection.set_norm(norm)
4676             collection._scale_norm(norm, vmin, vmax)
4677         else:
4678             extra_kwargs = {
4679                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4680                     }
4681             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4682             if any(extra_keys):
4683                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4684                 _api.warn_external(
4685                     "No data for colormapping provided via 'c'. "
4686                     f"Parameters {keys_str} will be ignored")
4687         collection._internal_update(kwargs)
4688 
4689         # Classic mode only:
4690         # ensure there are margins to allow for the
4691         # finite size of the symbols.  In v2.x, margins
4692         # are present by default, so we disable this
4693         # scatter-specific override.
4694         if mpl.rcParams['_internal.classic_mode']:
4695             if self._xmargin < 0.05 and x.size > 0:
4696                 self.set_xmargin(0.05)
4697             if self._ymargin < 0.05 and x.size > 0:
4698                 self.set_ymargin(0.05)
4699 
4700         self.add_collection(collection)
4701         self._request_autoscale_view()
4702 
4703         return collection
4704 
4705     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4706     @_docstring.dedent_interpd
4707     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4708                xscale='linear', yscale='linear', extent=None,
4709                cmap=None, norm=None, vmin=None, vmax=None,
4710                alpha=None, linewidths=None, edgecolors='face',
4711                reduce_C_function=np.mean, mincnt=None, marginals=False,
4712                **kwargs):
4713         """
4714         Make a 2D hexagonal binning plot of points *x*, *y*.
4715 
4716         If *C* is *None*, the value of the hexagon is determined by the number
4717         of points in the hexagon. Otherwise, *C* specifies values at the
4718         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4719         using *reduce_C_function*.
4720 
4721         Parameters
4722         ----------
4723         x, y : array-like
4724             The data positions. *x* and *y* must be of the same length.
4725 
4726         C : array-like, optional
4727             If given, these values are accumulated in the bins. Otherwise,
4728             every point has a value of 1. Must be of the same length as *x*
4729             and *y*.
4730 
4731         gridsize : int or (int, int), default: 100
4732             If a single int, the number of hexagons in the *x*-direction.
4733             The number of hexagons in the *y*-direction is chosen such that
4734             the hexagons are approximately regular.
4735 
4736             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4737             in the *x*-direction and the *y*-direction. In the
4738             *y*-direction, counting is done along vertically aligned
4739             hexagons, not along the zig-zag chains of hexagons; see the
4740             following illustration.
4741 
4742             .. plot::
4743 
4744                import numpy
4745                import matplotlib.pyplot as plt
4746 
4747                np.random.seed(19680801)
4748                n= 300
4749                x = np.random.standard_normal(n)
4750                y = np.random.standard_normal(n)
4751 
4752                fig, ax = plt.subplots(figsize=(4, 4))
4753                h = ax.hexbin(x, y, gridsize=(5, 3))
4754                hx, hy = h.get_offsets().T
4755                ax.plot(hx[24::3], hy[24::3], 'ro-')
4756                ax.plot(hx[-3:], hy[-3:], 'ro-')
4757                ax.set_title('gridsize=(5, 3)')
4758                ax.axis('off')
4759 
4760             To get approximately regular hexagons, choose
4761             :math:`n_x = \\sqrt{3}\\,n_y`.
4762 
4763         bins : 'log' or int or sequence, default: None
4764             Discretization of the hexagon values.
4765 
4766             - If *None*, no binning is applied; the color of each hexagon
4767               directly corresponds to its count value.
4768             - If 'log', use a logarithmic scale for the colormap.
4769               Internally, :math:`log_{10}(i+1)` is used to determine the
4770               hexagon color. This is equivalent to ``norm=LogNorm()``.
4771             - If an integer, divide the counts in the specified number
4772               of bins, and color the hexagons accordingly.
4773             - If a sequence of values, the values of the lower bound of
4774               the bins to be used.
4775 
4776         xscale : {'linear', 'log'}, default: 'linear'
4777             Use a linear or log10 scale on the horizontal axis.
4778 
4779         yscale : {'linear', 'log'}, default: 'linear'
4780             Use a linear or log10 scale on the vertical axis.
4781 
4782         mincnt : int > 0, default: *None*
4783             If not *None*, only display cells with more than *mincnt*
4784             number of points in the cell.
4785 
4786         marginals : bool, default: *False*
4787             If marginals is *True*, plot the marginal density as
4788             colormapped rectangles along the bottom of the x-axis and
4789             left of the y-axis.
4790 
4791         extent : 4-tuple of float, default: *None*
4792             The limits of the bins (xmin, xmax, ymin, ymax).
4793             The default assigns the limits based on
4794             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4795 
4796             If *xscale* or *yscale* is set to 'log', the limits are
4797             expected to be the exponent for a power of 10. E.g. for
4798             x-limits of 1 and 50 in 'linear' scale and y-limits
4799             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4800 
4801         Returns
4802         -------
4803         `~matplotlib.collections.PolyCollection`
4804             A `.PolyCollection` defining the hexagonal bins.
4805 
4806             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4807               the x, y positions of the M hexagon centers.
4808             - `.PolyCollection.get_array` contains the values of the M
4809               hexagons.
4810 
4811             If *marginals* is *True*, horizontal
4812             bar and vertical bar (both PolyCollections) will be attached
4813             to the return collection as attributes *hbar* and *vbar*.
4814 
4815         Other Parameters
4816         ----------------
4817         %(cmap_doc)s
4818 
4819         %(norm_doc)s
4820 
4821         %(vmin_vmax_doc)s
4822 
4823         alpha : float between 0 and 1, optional
4824             The alpha blending value, between 0 (transparent) and 1 (opaque).
4825 
4826         linewidths : float, default: *None*
4827             If *None*, defaults to 1.0.
4828 
4829         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4830             The color of the hexagon edges. Possible values are:
4831 
4832             - 'face': Draw the edges in the same color as the fill color.
4833             - 'none': No edges are drawn. This can sometimes lead to unsightly
4834               unpainted pixels between the hexagons.
4835             - *None*: Draw outlines in the default color.
4836             - An explicit color.
4837 
4838         reduce_C_function : callable, default: `numpy.mean`
4839             The function to aggregate *C* within the bins. It is ignored if
4840             *C* is not given. This must have the signature::
4841 
4842                 def reduce_C_function(C: array) -> float
4843 
4844             Commonly used functions are:
4845 
4846             - `numpy.mean`: average of the points
4847             - `numpy.sum`: integral of the point values
4848             - `numpy.amax`: value taken from the largest point
4849 
4850         data : indexable object, optional
4851             DATA_PARAMETER_PLACEHOLDER
4852 
4853         **kwargs : `~matplotlib.collections.PolyCollection` properties
4854             All other keyword arguments are passed on to `.PolyCollection`:
4855 
4856             %(PolyCollection:kwdoc)s
4857 
4858         See Also
4859         --------
4860         hist2d : 2D histogram rectangular bins
4861         """
4862         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4863 
4864         x, y, C = cbook.delete_masked_points(x, y, C)
4865 
4866         # Set the size of the hexagon grid
4867         if np.iterable(gridsize):
4868             nx, ny = gridsize
4869         else:
4870             nx = gridsize
4871             ny = int(nx / math.sqrt(3))
4872         # Count the number of data in each hexagon
4873         x = np.asarray(x, float)
4874         y = np.asarray(y, float)
4875 
4876         # Will be log()'d if necessary, and then rescaled.
4877         tx = x
4878         ty = y
4879 
4880         if xscale == 'log':
4881             if np.any(x <= 0.0):
4882                 raise ValueError("x contains non-positive values, so can not "
4883                                  "be log-scaled")
4884             tx = np.log10(tx)
4885         if yscale == 'log':
4886             if np.any(y <= 0.0):
4887                 raise ValueError("y contains non-positive values, so can not "
4888                                  "be log-scaled")
4889             ty = np.log10(ty)
4890         if extent is not None:
4891             xmin, xmax, ymin, ymax = extent
4892         else:
4893             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4894             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4895 
4896             # to avoid issues with singular data, expand the min/max pairs
4897             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4898             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4899 
4900         nx1 = nx + 1
4901         ny1 = ny + 1
4902         nx2 = nx
4903         ny2 = ny
4904         n = nx1 * ny1 + nx2 * ny2
4905 
4906         # In the x-direction, the hexagons exactly cover the region from
4907         # xmin to xmax. Need some padding to avoid roundoff errors.
4908         padding = 1.e-9 * (xmax - xmin)
4909         xmin -= padding
4910         xmax += padding
4911         sx = (xmax - xmin) / nx
4912         sy = (ymax - ymin) / ny
4913         # Positions in hexagon index coordinates.
4914         ix = (tx - xmin) / sx
4915         iy = (ty - ymin) / sy
4916         ix1 = np.round(ix).astype(int)
4917         iy1 = np.round(iy).astype(int)
4918         ix2 = np.floor(ix).astype(int)
4919         iy2 = np.floor(iy).astype(int)
4920         # flat indices, plus one so that out-of-range points go to position 0.
4921         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4922                       ix1 * ny1 + iy1 + 1, 0)
4923         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4924                       ix2 * ny2 + iy2 + 1, 0)
4925 
4926         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4927         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4928         bdist = (d1 < d2)
4929 
4930         if C is None:  # [1:] drops out-of-range points.
4931             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4932             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4933             accum = np.concatenate([counts1, counts2]).astype(float)
4934             if mincnt is not None:
4935                 accum[accum < mincnt] = np.nan
4936             C = np.ones(len(x))
4937         else:
4938             # store the C values in a list per hexagon index
4939             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4940             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4941             for i in range(len(x)):
4942                 if bdist[i]:
4943                     Cs_at_i1[i1[i]].append(C[i])
4944                 else:
4945                     Cs_at_i2[i2[i]].append(C[i])
4946             if mincnt is None:
4947                 mincnt = 0
4948             accum = np.array(
4949                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4950                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4951                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4952                 float)
4953 
4954         good_idxs = ~np.isnan(accum)
4955 
4956         offsets = np.zeros((n, 2), float)
4957         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4958         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4959         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4960         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4961         offsets[:, 0] *= sx
4962         offsets[:, 1] *= sy
4963         offsets[:, 0] += xmin
4964         offsets[:, 1] += ymin
4965         # remove accumulation bins with no data
4966         offsets = offsets[good_idxs, :]
4967         accum = accum[good_idxs]
4968 
4969         polygon = [sx, sy / 3] * np.array(
4970             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
4971 
4972         if linewidths is None:
4973             linewidths = [1.0]
4974 
4975         if xscale == 'log' or yscale == 'log':
4976             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
4977             if xscale == 'log':
4978                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
4979                 xmin = 10.0 ** xmin
4980                 xmax = 10.0 ** xmax
4981                 self.set_xscale(xscale)
4982             if yscale == 'log':
4983                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
4984                 ymin = 10.0 ** ymin
4985                 ymax = 10.0 ** ymax
4986                 self.set_yscale(yscale)
4987             collection = mcoll.PolyCollection(
4988                 polygons,
4989                 edgecolors=edgecolors,
4990                 linewidths=linewidths,
4991                 )
4992         else:
4993             collection = mcoll.PolyCollection(
4994                 [polygon],
4995                 edgecolors=edgecolors,
4996                 linewidths=linewidths,
4997                 offsets=offsets,
4998                 offset_transform=mtransforms.AffineDeltaTransform(
4999                     self.transData),
5000             )
5001 
5002         # Set normalizer if bins is 'log'
5003         if bins == 'log':
5004             if norm is not None:
5005                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5006                                    f"can be supplied, ignoring bins={bins}")
5007             else:
5008                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5009                 vmin = vmax = None
5010             bins = None
5011 
5012         # autoscale the norm with current accum values if it hasn't been set
5013         if norm is not None:
5014             if norm.vmin is None and norm.vmax is None:
5015                 norm.autoscale(accum)
5016 
5017         if bins is not None:
5018             if not np.iterable(bins):
5019                 minimum, maximum = min(accum), max(accum)
5020                 bins -= 1  # one less edge than bins
5021                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5022             bins = np.sort(bins)
5023             accum = bins.searchsorted(accum)
5024 
5025         collection.set_array(accum)
5026         collection.set_cmap(cmap)
5027         collection.set_norm(norm)
5028         collection.set_alpha(alpha)
5029         collection._internal_update(kwargs)
5030         collection._scale_norm(norm, vmin, vmax)
5031 
5032         corners = ((xmin, ymin), (xmax, ymax))
5033         self.update_datalim(corners)
5034         self._request_autoscale_view(tight=True)
5035 
5036         # add the collection last
5037         self.add_collection(collection, autolim=False)
5038         if not marginals:
5039             return collection
5040 
5041         # Process marginals
5042         bars = []
5043         for zname, z, zmin, zmax, zscale, nbins in [
5044                 ("x", x, xmin, xmax, xscale, nx),
5045                 ("y", y, ymin, ymax, yscale, 2 * ny),
5046         ]:
5047 
5048             if zscale == "log":
5049                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5050             else:
5051                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5052 
5053             verts = np.empty((nbins, 4, 2))
5054             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5055             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5056             verts[:, 0, 1] = verts[:, 3, 1] = .00
5057             verts[:, 1, 1] = verts[:, 2, 1] = .05
5058             if zname == "y":
5059                 verts = verts[:, :, ::-1]  # Swap x and y.
5060 
5061             # Sort z-values into bins defined by bin_edges.
5062             bin_idxs = np.searchsorted(bin_edges, z) - 1
5063             values = np.empty(nbins)
5064             for i in range(nbins):
5065                 # Get C-values for each bin, and compute bin value with
5066                 # reduce_C_function.
5067                 ci = C[bin_idxs == i]
5068                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5069 
5070             mask = ~np.isnan(values)
5071             verts = verts[mask]
5072             values = values[mask]
5073 
5074             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5075             bar = mcoll.PolyCollection(
5076                 verts, transform=trans, edgecolors="face")
5077             bar.set_array(values)
5078             bar.set_cmap(cmap)
5079             bar.set_norm(norm)
5080             bar.set_alpha(alpha)
5081             bar._internal_update(kwargs)
5082             bars.append(self.add_collection(bar, autolim=False))
5083 
5084         collection.hbar, collection.vbar = bars
5085 
5086         def on_changed(collection):
5087             collection.hbar.set_cmap(collection.get_cmap())
5088             collection.hbar.set_cmap(collection.get_cmap())
5089             collection.vbar.set_clim(collection.get_clim())
5090             collection.vbar.set_clim(collection.get_clim())
5091 
5092         collection.callbacks.connect('changed', on_changed)
5093 
5094         return collection
5095 
5096     @_docstring.dedent_interpd
5097     def arrow(self, x, y, dx, dy, **kwargs):
5098         """
5099         Add an arrow to the Axes.
5100 
5101         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5102 
5103         Parameters
5104         ----------
5105         %(FancyArrow)s
5106 
5107         Returns
5108         -------
5109         `.FancyArrow`
5110             The created `.FancyArrow` object.
5111 
5112         Notes
5113         -----
5114         The resulting arrow is affected by the Axes aspect ratio and limits.
5115         This may produce an arrow whose head is not square with its stem. To
5116         create an arrow whose head is square with its stem,
5117         use :meth:`annotate` for example:
5118 
5119         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5120         ...             arrowprops=dict(arrowstyle="->"))
5121 
5122         """
5123         # Strip away units for the underlying patch since units
5124         # do not make sense to most patch-like code
5125         x = self.convert_xunits(x)
5126         y = self.convert_yunits(y)
5127         dx = self.convert_xunits(dx)
5128         dy = self.convert_yunits(dy)
5129 
5130         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5131         self.add_patch(a)
5132         self._request_autoscale_view()
5133         return a
5134 
5135     @_docstring.copy(mquiver.QuiverKey.__init__)
5136     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5137         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5138         self.add_artist(qk)
5139         return qk
5140 
5141     # Handle units for x and y, if they've been passed
5142     def _quiver_units(self, args, kwargs):
5143         if len(args) > 3:
5144             x, y = args[0:2]
5145             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5146             return (x, y) + args[2:]
5147         return args
5148 
5149     # args can be a combination of X, Y, U, V, C and all should be replaced
5150     @_preprocess_data()
5151     @_docstring.dedent_interpd
5152     def quiver(self, *args, **kwargs):
5153         """%(quiver_doc)s"""
5154         # Make sure units are handled for x and y values
5155         args = self._quiver_units(args, kwargs)
5156         q = mquiver.Quiver(self, *args, **kwargs)
5157         self.add_collection(q, autolim=True)
5158         self._request_autoscale_view()
5159         return q
5160 
5161     # args can be some combination of X, Y, U, V, C and all should be replaced
5162     @_preprocess_data()
5163     @_docstring.dedent_interpd
5164     def barbs(self, *args, **kwargs):
5165         """%(barbs_doc)s"""
5166         # Make sure units are handled for x and y values
5167         args = self._quiver_units(args, kwargs)
5168         b = mquiver.Barbs(self, *args, **kwargs)
5169         self.add_collection(b, autolim=True)
5170         self._request_autoscale_view()
5171         return b
5172 
5173     # Uses a custom implementation of data-kwarg handling in
5174     # _process_plot_var_args.
5175     def fill(self, *args, data=None, **kwargs):
5176         """
5177         Plot filled polygons.
5178 
5179         Parameters
5180         ----------
5181         *args : sequence of x, y, [color]
5182             Each polygon is defined by the lists of *x* and *y* positions of
5183             its nodes, optionally followed by a *color* specifier. See
5184             :mod:`matplotlib.colors` for supported color specifiers. The
5185             standard color cycle is used for polygons without a color
5186             specifier.
5187 
5188             You can plot multiple polygons by providing multiple *x*, *y*,
5189             *[color]* groups.
5190 
5191             For example, each of the following is legal::
5192 
5193                 ax.fill(x, y)                    # a polygon with default color
5194                 ax.fill(x, y, "b")               # a blue polygon
5195                 ax.fill(x, y, x2, y2)            # two polygons
5196                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5197 
5198         data : indexable object, optional
5199             An object with labelled data. If given, provide the label names to
5200             plot in *x* and *y*, e.g.::
5201 
5202                 ax.fill("time", "signal",
5203                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5204 
5205         Returns
5206         -------
5207         list of `~matplotlib.patches.Polygon`
5208 
5209         Other Parameters
5210         ----------------
5211         **kwargs : `~matplotlib.patches.Polygon` properties
5212 
5213         Notes
5214         -----
5215         Use :meth:`fill_between` if you would like to fill the region between
5216         two curves.
5217         """
5218         # For compatibility(!), get aliases from Line2D rather than Patch.
5219         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5220         # _get_patches_for_fill returns a generator, convert it to a list.
5221         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5222         for poly in patches:
5223             self.add_patch(poly)
5224         self._request_autoscale_view()
5225         return patches
5226 
5227     def _fill_between_x_or_y(
5228             self, ind_dir, ind, dep1, dep2=0, *,
5229             where=None, interpolate=False, step=None, **kwargs):
5230         # Common implementation between fill_between (*ind_dir*="x") and
5231         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5232         # *dep* the dependent variable.  The docstring below is interpolated
5233         # to generate both methods' docstrings.
5234         """
5235         Fill the area between two {dir} curves.
5236 
5237         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5238         *{dep}2*).  This creates one or multiple polygons describing the filled
5239         area.
5240 
5241         You may exclude some {dir} sections from filling using *where*.
5242 
5243         By default, the edges connect the given points directly.  Use *step*
5244         if the filling should be a step function, i.e. constant in between
5245         *{ind}*.
5246 
5247         Parameters
5248         ----------
5249         {ind} : array (length N)
5250             The {ind} coordinates of the nodes defining the curves.
5251 
5252         {dep}1 : array (length N) or scalar
5253             The {dep} coordinates of the nodes defining the first curve.
5254 
5255         {dep}2 : array (length N) or scalar, default: 0
5256             The {dep} coordinates of the nodes defining the second curve.
5257 
5258         where : array of bool (length N), optional
5259             Define *where* to exclude some {dir} regions from being filled.
5260             The filled regions are defined by the coordinates ``{ind}[where]``.
5261             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5262             ``where[i] and where[i+1]``.  Note that this definition implies
5263             that an isolated *True* value between two *False* values in *where*
5264             will not result in filling.  Both sides of the *True* position
5265             remain unfilled due to the adjacent *False* values.
5266 
5267         interpolate : bool, default: False
5268             This option is only relevant if *where* is used and the two curves
5269             are crossing each other.
5270 
5271             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5272             similar.  By default, the nodes of the polygon defining the filled
5273             region will only be placed at the positions in the *{ind}* array.
5274             Such a polygon cannot describe the above semantics close to the
5275             intersection.  The {ind}-sections containing the intersection are
5276             simply clipped.
5277 
5278             Setting *interpolate* to *True* will calculate the actual
5279             intersection point and extend the filled region up to this point.
5280 
5281         step : {{'pre', 'post', 'mid'}}, optional
5282             Define *step* if the filling should be a step function,
5283             i.e. constant in between *{ind}*.  The value determines where the
5284             step will occur:
5285 
5286             - 'pre': The y value is continued constantly to the left from
5287               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5288               value ``y[i]``.
5289             - 'post': The y value is continued constantly to the right from
5290               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5291               value ``y[i]``.
5292             - 'mid': Steps occur half-way between the *x* positions.
5293 
5294         Returns
5295         -------
5296         `.PolyCollection`
5297             A `.PolyCollection` containing the plotted polygons.
5298 
5299         Other Parameters
5300         ----------------
5301         data : indexable object, optional
5302             DATA_PARAMETER_PLACEHOLDER
5303 
5304         **kwargs
5305             All other keyword arguments are passed on to `.PolyCollection`.
5306             They control the `.Polygon` properties:
5307 
5308             %(PolyCollection:kwdoc)s
5309 
5310         See Also
5311         --------
5312         fill_between : Fill between two sets of y-values.
5313         fill_betweenx : Fill between two sets of x-values.
5314         """
5315 
5316         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5317 
5318         if not mpl.rcParams["_internal.classic_mode"]:
5319             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5320             if not any(c in kwargs for c in ("color", "facecolor")):
5321                 kwargs["facecolor"] = \
5322                     self._get_patches_for_fill.get_next_color()
5323 
5324         # Handle united data, such as dates
5325         ind, dep1, dep2 = map(
5326             ma.masked_invalid, self._process_unit_info(
5327                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5328 
5329         for name, array in [
5330                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5331             if array.ndim > 1:
5332                 raise ValueError(f"{name!r} is not 1-dimensional")
5333 
5334         if where is None:
5335             where = True
5336         else:
5337             where = np.asarray(where, dtype=bool)
5338             if where.size != ind.size:
5339                 raise ValueError(f"where size ({where.size}) does not match "
5340                                  f"{ind_dir} size ({ind.size})")
5341         where = where & ~functools.reduce(
5342             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5343 
5344         ind, dep1, dep2 = np.broadcast_arrays(
5345             np.atleast_1d(ind), dep1, dep2, subok=True)
5346 
5347         polys = []
5348         for idx0, idx1 in cbook.contiguous_regions(where):
5349             indslice = ind[idx0:idx1]
5350             dep1slice = dep1[idx0:idx1]
5351             dep2slice = dep2[idx0:idx1]
5352             if step is not None:
5353                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5354                 indslice, dep1slice, dep2slice = \
5355                     step_func(indslice, dep1slice, dep2slice)
5356 
5357             if not len(indslice):
5358                 continue
5359 
5360             N = len(indslice)
5361             pts = np.zeros((2 * N + 2, 2))
5362 
5363             if interpolate:
5364                 def get_interp_point(idx):
5365                     im1 = max(idx - 1, 0)
5366                     ind_values = ind[im1:idx+1]
5367                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5368                     dep1_values = dep1[im1:idx+1]
5369 
5370                     if len(diff_values) == 2:
5371                         if np.ma.is_masked(diff_values[1]):
5372                             return ind[im1], dep1[im1]
5373                         elif np.ma.is_masked(diff_values[0]):
5374                             return ind[idx], dep1[idx]
5375 
5376                     diff_order = diff_values.argsort()
5377                     diff_root_ind = np.interp(
5378                         0, diff_values[diff_order], ind_values[diff_order])
5379                     ind_order = ind_values.argsort()
5380                     diff_root_dep = np.interp(
5381                         diff_root_ind,
5382                         ind_values[ind_order], dep1_values[ind_order])
5383                     return diff_root_ind, diff_root_dep
5384 
5385                 start = get_interp_point(idx0)
5386                 end = get_interp_point(idx1)
5387             else:
5388                 # Handle scalar dep2 (e.g. 0): the fill should go all
5389                 # the way down to 0 even if none of the dep1 sample points do.
5390                 start = indslice[0], dep2slice[0]
5391                 end = indslice[-1], dep2slice[-1]
5392 
5393             pts[0] = start
5394             pts[N + 1] = end
5395 
5396             pts[1:N+1, 0] = indslice
5397             pts[1:N+1, 1] = dep1slice
5398             pts[N+2:, 0] = indslice[::-1]
5399             pts[N+2:, 1] = dep2slice[::-1]
5400 
5401             if ind_dir == "y":
5402                 pts = pts[:, ::-1]
5403 
5404             polys.append(pts)
5405 
5406         collection = mcoll.PolyCollection(polys, **kwargs)
5407 
5408         # now update the datalim and autoscale
5409         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5410                             np.column_stack([ind[where], dep2[where]])])
5411         if ind_dir == "y":
5412             pts = pts[:, ::-1]
5413         self.update_datalim(pts, updatex=True, updatey=True)
5414         self.add_collection(collection, autolim=False)
5415         self._request_autoscale_view()
5416         return collection
5417 
5418     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5419                      step=None, **kwargs):
5420         return self._fill_between_x_or_y(
5421             "x", x, y1, y2,
5422             where=where, interpolate=interpolate, step=step, **kwargs)
5423 
5424     if _fill_between_x_or_y.__doc__:
5425         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5426             dir="horizontal", ind="x", dep="y"
5427         )
5428     fill_between = _preprocess_data(
5429         _docstring.dedent_interpd(fill_between),
5430         replace_names=["x", "y1", "y2", "where"])
5431 
5432     def fill_betweenx(self, y, x1, x2=0, where=None,
5433                       step=None, interpolate=False, **kwargs):
5434         return self._fill_between_x_or_y(
5435             "y", y, x1, x2,
5436             where=where, interpolate=interpolate, step=step, **kwargs)
5437 
5438     if _fill_between_x_or_y.__doc__:
5439         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5440             dir="vertical", ind="y", dep="x"
5441         )
5442     fill_betweenx = _preprocess_data(
5443         _docstring.dedent_interpd(fill_betweenx),
5444         replace_names=["y", "x1", "x2", "where"])
5445 
5446     #### plotting z(x, y): imshow, pcolor and relatives, contour
5447 
5448     @_preprocess_data()
5449     @_docstring.interpd
5450     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5451                interpolation=None, alpha=None,
5452                vmin=None, vmax=None, origin=None, extent=None,
5453                interpolation_stage=None, filternorm=True, filterrad=4.0,
5454                resample=None, url=None, **kwargs):
5455         """
5456         Display data as an image, i.e., on a 2D regular raster.
5457 
5458         The input may either be actual RGB(A) data, or 2D scalar data, which
5459         will be rendered as a pseudocolor image. For displaying a grayscale
5460         image set up the colormapping using the parameters
5461         ``cmap='gray', vmin=0, vmax=255``.
5462 
5463         The number of pixels used to render an image is set by the Axes size
5464         and the *dpi* of the figure. This can lead to aliasing artifacts when
5465         the image is resampled because the displayed image size will usually
5466         not match the size of *X* (see
5467         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5468         The resampling can be controlled via the *interpolation* parameter
5469         and/or :rc:`image.interpolation`.
5470 
5471         Parameters
5472         ----------
5473         X : array-like or PIL image
5474             The image data. Supported array shapes are:
5475 
5476             - (M, N): an image with scalar data. The values are mapped to
5477               colors using normalization and a colormap. See parameters *norm*,
5478               *cmap*, *vmin*, *vmax*.
5479             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5480             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5481               i.e. including transparency.
5482 
5483             The first two dimensions (M, N) define the rows and columns of
5484             the image.
5485 
5486             Out-of-range RGB(A) values are clipped.
5487 
5488         %(cmap_doc)s
5489 
5490             This parameter is ignored if *X* is RGB(A).
5491 
5492         %(norm_doc)s
5493 
5494             This parameter is ignored if *X* is RGB(A).
5495 
5496         %(vmin_vmax_doc)s
5497 
5498             This parameter is ignored if *X* is RGB(A).
5499 
5500         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5501             The aspect ratio of the Axes.  This parameter is particularly
5502             relevant for images since it determines whether data pixels are
5503             square.
5504 
5505             This parameter is a shortcut for explicitly calling
5506             `.Axes.set_aspect`. See there for further details.
5507 
5508             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5509               (unless pixel sizes are explicitly made non-square in data
5510               coordinates using *extent*).
5511             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5512               that the data fit in the Axes. In general, this will result in
5513               non-square pixels.
5514 
5515         interpolation : str, default: :rc:`image.interpolation`
5516             The interpolation method used.
5517 
5518             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5519             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5520             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5521             'sinc', 'lanczos', 'blackman'.
5522 
5523             The data *X* is resampled to the pixel size of the image on the
5524             figure canvas, using the interpolation method to either up- or
5525             downsample the data.
5526 
5527             If *interpolation* is 'none', then for the ps, pdf, and svg
5528             backends no down- or upsampling occurs, and the image data is
5529             passed to the backend as a native image.  Note that different ps,
5530             pdf, and svg viewers may display these raw pixels differently. On
5531             other backends, 'none' is the same as 'nearest'.
5532 
5533             If *interpolation* is the default 'antialiased', then 'nearest'
5534             interpolation is used if the image is upsampled by more than a
5535             factor of three (i.e. the number of display pixels is at least
5536             three times the size of the data array).  If the upsampling rate is
5537             smaller than 3, or the image is downsampled, then 'hanning'
5538             interpolation is used to act as an anti-aliasing filter, unless the
5539             image happens to be upsampled by exactly a factor of two or one.
5540 
5541             See
5542             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5543             for an overview of the supported interpolation methods, and
5544             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5545             a discussion of image antialiasing.
5546 
5547             Some interpolation methods require an additional radius parameter,
5548             which can be set by *filterrad*. Additionally, the antigrain image
5549             resize filter is controlled by the parameter *filternorm*.
5550 
5551         interpolation_stage : {'data', 'rgba'}, default: 'data'
5552             If 'data', interpolation
5553             is carried out on the data provided by the user.  If 'rgba', the
5554             interpolation is carried out after the colormapping has been
5555             applied (visual interpolation).
5556 
5557         alpha : float or array-like, optional
5558             The alpha blending value, between 0 (transparent) and 1 (opaque).
5559             If *alpha* is an array, the alpha blending values are applied pixel
5560             by pixel, and *alpha* must have the same shape as *X*.
5561 
5562         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5563             Place the [0, 0] index of the array in the upper left or lower
5564             left corner of the Axes. The convention (the default) 'upper' is
5565             typically used for matrices and images.
5566 
5567             Note that the vertical axis points upward for 'lower'
5568             but downward for 'upper'.
5569 
5570             See the :ref:`imshow_extent` tutorial for
5571             examples and a more detailed description.
5572 
5573         extent : floats (left, right, bottom, top), optional
5574             The bounding box in data coordinates that the image will fill.
5575             These values may be unitful and match the units of the Axes.
5576             The image is stretched individually along x and y to fill the box.
5577 
5578             The default extent is determined by the following conditions.
5579             Pixels have unit size in data coordinates. Their centers are on
5580             integer coordinates, and their center coordinates range from 0 to
5581             columns-1 horizontally and from 0 to rows-1 vertically.
5582 
5583             Note that the direction of the vertical axis and thus the default
5584             values for top and bottom depend on *origin*:
5585 
5586             - For ``origin == 'upper'`` the default is
5587               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5588             - For ``origin == 'lower'`` the default is
5589               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5590 
5591             See the :ref:`imshow_extent` tutorial for
5592             examples and a more detailed description.
5593 
5594         filternorm : bool, default: True
5595             A parameter for the antigrain image resize filter (see the
5596             antigrain documentation).  If *filternorm* is set, the filter
5597             normalizes integer values and corrects the rounding errors. It
5598             doesn't do anything with the source floating point values, it
5599             corrects only integers according to the rule of 1.0 which means
5600             that any sum of pixel weights must be equal to 1.0.  So, the
5601             filter function must produce a graph of the proper shape.
5602 
5603         filterrad : float > 0, default: 4.0
5604             The filter radius for filters that have a radius parameter, i.e.
5605             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5606 
5607         resample : bool, default: :rc:`image.resample`
5608             When *True*, use a full resampling method.  When *False*, only
5609             resample when the output image is larger than the input image.
5610 
5611         url : str, optional
5612             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5613 
5614         Returns
5615         -------
5616         `~matplotlib.image.AxesImage`
5617 
5618         Other Parameters
5619         ----------------
5620         data : indexable object, optional
5621             DATA_PARAMETER_PLACEHOLDER
5622 
5623         **kwargs : `~matplotlib.artist.Artist` properties
5624             These parameters are passed on to the constructor of the
5625             `.AxesImage` artist.
5626 
5627         See Also
5628         --------
5629         matshow : Plot a matrix or an array as an image.
5630 
5631         Notes
5632         -----
5633         Unless *extent* is used, pixel centers will be located at integer
5634         coordinates. In other words: the origin will coincide with the center
5635         of pixel (0, 0).
5636 
5637         There are two common representations for RGB images with an alpha
5638         channel:
5639 
5640         -   Straight (unassociated) alpha: R, G, and B channels represent the
5641             color of the pixel, disregarding its opacity.
5642         -   Premultiplied (associated) alpha: R, G, and B channels represent
5643             the color of the pixel, adjusted for its opacity by multiplication.
5644 
5645         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5646         (unassociated) alpha representation.
5647         """
5648         if aspect is None:
5649             aspect = mpl.rcParams['image.aspect']
5650         self.set_aspect(aspect)
5651         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5652                               interpolation=interpolation, origin=origin,
5653                               extent=extent, filternorm=filternorm,
5654                               filterrad=filterrad, resample=resample,
5655                               interpolation_stage=interpolation_stage,
5656                               **kwargs)
5657 
5658         im.set_data(X)
5659         im.set_alpha(alpha)
5660         if im.get_clip_path() is None:
5661             # image does not already have clipping set, clip to axes patch
5662             im.set_clip_path(self.patch)
5663         im._scale_norm(norm, vmin, vmax)
5664         im.set_url(url)
5665 
5666         # update ax.dataLim, and, if autoscaling, set viewLim
5667         # to tightly fit the image, regardless of dataLim.
5668         im.set_extent(im.get_extent())
5669 
5670         self.add_image(im)
5671         return im
5672 
5673     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5674         # - create X and Y if not present;
5675         # - reshape X and Y as needed if they are 1-D;
5676         # - check for proper sizes based on `shading` kwarg;
5677         # - reset shading if shading='auto' to flat or nearest
5678         #   depending on size;
5679 
5680         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5681         try:
5682             _api.check_in_list(_valid_shading, shading=shading)
5683         except ValueError:
5684             _api.warn_external(f"shading value '{shading}' not in list of "
5685                                f"valid values {_valid_shading}. Setting "
5686                                "shading='auto'.")
5687             shading = 'auto'
5688 
5689         if len(args) == 1:
5690             C = np.asanyarray(args[0])
5691             nrows, ncols = C.shape[:2]
5692             if shading in ['gouraud', 'nearest']:
5693                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5694             else:
5695                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5696                 shading = 'flat'
5697             C = cbook.safe_masked_invalid(C)
5698             return X, Y, C, shading
5699 
5700         if len(args) == 3:
5701             # Check x and y for bad data...
5702             C = np.asanyarray(args[2])
5703             # unit conversion allows e.g. datetime objects as axis values
5704             X, Y = args[:2]
5705             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5706             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5707 
5708             if funcname == 'pcolormesh':
5709                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5710                     raise ValueError(
5711                         'x and y arguments to pcolormesh cannot have '
5712                         'non-finite values or be of type '
5713                         'numpy.ma.core.MaskedArray with masked values')
5714                 # safe_masked_invalid() returns an ndarray for dtypes other
5715                 # than floating point.
5716                 if isinstance(X, np.ma.core.MaskedArray):
5717                     X = X.data  # strip mask as downstream doesn't like it...
5718                 if isinstance(Y, np.ma.core.MaskedArray):
5719                     Y = Y.data
5720             nrows, ncols = C.shape[:2]
5721         else:
5722             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5723 
5724         Nx = X.shape[-1]
5725         Ny = Y.shape[0]
5726         if X.ndim != 2 or X.shape[0] == 1:
5727             x = X.reshape(1, Nx)
5728             X = x.repeat(Ny, axis=0)
5729         if Y.ndim != 2 or Y.shape[1] == 1:
5730             y = Y.reshape(Ny, 1)
5731             Y = y.repeat(Nx, axis=1)
5732         if X.shape != Y.shape:
5733             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5734                             f'see help({funcname})')
5735 
5736         if shading == 'auto':
5737             if ncols == Nx and nrows == Ny:
5738                 shading = 'nearest'
5739             else:
5740                 shading = 'flat'
5741 
5742         if shading == 'flat':
5743             if (Nx, Ny) != (ncols + 1, nrows + 1):
5744                 raise TypeError(f"Dimensions of C {C.shape} should"
5745                                 f" be one smaller than X({Nx}) and Y({Ny})"
5746                                 f" while using shading='flat'"
5747                                 f" see help({funcname})")
5748         else:    # ['nearest', 'gouraud']:
5749             if (Nx, Ny) != (ncols, nrows):
5750                 raise TypeError('Dimensions of C %s are incompatible with'
5751                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5752                                     C.shape, Nx, Ny, funcname))
5753             if shading == 'nearest':
5754                 # grid is specified at the center, so define corners
5755                 # at the midpoints between the grid centers and then use the
5756                 # flat algorithm.
5757                 def _interp_grid(X):
5758                     # helper for below
5759                     if np.shape(X)[1] > 1:
5760                         dX = np.diff(X, axis=1)/2.
5761                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5762                             _api.warn_external(
5763                                 f"The input coordinates to {funcname} are "
5764                                 "interpreted as cell centers, but are not "
5765                                 "monotonically increasing or decreasing. "
5766                                 "This may lead to incorrectly calculated cell "
5767                                 "edges, in which case, please supply "
5768                                 f"explicit cell edges to {funcname}.")
5769                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5770                                        X[:, :-1] + dX,
5771                                        X[:, [-1]] + dX[:, [-1]]))
5772                     else:
5773                         # This is just degenerate, but we can't reliably guess
5774                         # a dX if there is just one value.
5775                         X = np.hstack((X, X))
5776                     return X
5777 
5778                 if ncols == Nx:
5779                     X = _interp_grid(X)
5780                     Y = _interp_grid(Y)
5781                 if nrows == Ny:
5782                     X = _interp_grid(X.T).T
5783                     Y = _interp_grid(Y.T).T
5784                 shading = 'flat'
5785 
5786         C = cbook.safe_masked_invalid(C)
5787         return X, Y, C, shading
5788 
5789     @_preprocess_data()
5790     @_docstring.dedent_interpd
5791     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5792                vmin=None, vmax=None, **kwargs):
5793         r"""
5794         Create a pseudocolor plot with a non-regular rectangular grid.
5795 
5796         Call signature::
5797 
5798             pcolor([X, Y,] C, **kwargs)
5799 
5800         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5801 
5802         .. hint::
5803 
5804             ``pcolor()`` can be very slow for large arrays. In most
5805             cases you should use the similar but much faster
5806             `~.Axes.pcolormesh` instead. See
5807             :ref:`Differences between pcolor() and pcolormesh()
5808             <differences-pcolor-pcolormesh>` for a discussion of the
5809             differences.
5810 
5811         Parameters
5812         ----------
5813         C : 2D array-like
5814             The color-mapped values.  Color-mapping is controlled by *cmap*,
5815             *norm*, *vmin*, and *vmax*.
5816 
5817         X, Y : array-like, optional
5818             The coordinates of the corners of quadrilaterals of a pcolormesh::
5819 
5820                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5821                                       
5822                                            
5823                                       
5824                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5825 
5826             Note that the column index corresponds to the x-coordinate, and
5827             the row index corresponds to y. For details, see the
5828             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5829 
5830             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5831             greater than those of *C*, and the quadrilateral is colored due
5832             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5833             dimensions, a warning will be raised and the last row and column
5834             of *C* will be ignored.
5835 
5836             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5837             the same as those of *C* (if not, a ValueError will be raised). The
5838             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5839 
5840             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5841             expanded as needed into the appropriate 2D arrays, making a
5842             rectangular grid.
5843 
5844         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5845             The fill style for the quadrilateral. Possible values:
5846 
5847             - 'flat': A solid color is used for each quad. The color of the
5848               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5849               ``C[i, j]``. The dimensions of *X* and *Y* should be
5850               one greater than those of *C*; if they are the same as *C*,
5851               then a deprecation warning is raised, and the last row
5852               and column of *C* are dropped.
5853             - 'nearest': Each grid point will have a color centered on it,
5854               extending halfway between the adjacent grid centers.  The
5855               dimensions of *X* and *Y* must be the same as *C*.
5856             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5857               larger than *C*.  Choose 'nearest' if dimensions are the same.
5858 
5859             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5860             for more description.
5861 
5862         %(cmap_doc)s
5863 
5864         %(norm_doc)s
5865 
5866         %(vmin_vmax_doc)s
5867 
5868         edgecolors : {'none', None, 'face', color, color sequence}, optional
5869             The color of the edges. Defaults to 'none'. Possible values:
5870 
5871             - 'none' or '': No edge.
5872             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5873               :rc:`patch.force_edgecolor` has to be True for this to work.
5874             - 'face': Use the adjacent face color.
5875             - A color or sequence of colors will set the edge color.
5876 
5877             The singular form *edgecolor* works as an alias.
5878 
5879         alpha : float, default: None
5880             The alpha blending value of the face color, between 0 (transparent)
5881             and 1 (opaque). Note: The edgecolor is currently not affected by
5882             this.
5883 
5884         snap : bool, default: False
5885             Whether to snap the mesh to pixel boundaries.
5886 
5887         Returns
5888         -------
5889         `matplotlib.collections.Collection`
5890 
5891         Other Parameters
5892         ----------------
5893         antialiaseds : bool, default: False
5894             The default *antialiaseds* is False if the default
5895             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5896             at patch boundaries, and works regardless of the value of alpha.
5897             If *edgecolors* is not "none", then the default *antialiaseds*
5898             is taken from :rc:`patch.antialiased`.
5899             Stroking the edges may be preferred if *alpha* is 1, but will
5900             cause artifacts otherwise.
5901 
5902         data : indexable object, optional
5903             DATA_PARAMETER_PLACEHOLDER
5904 
5905         **kwargs
5906             Additionally, the following arguments are allowed. They are passed
5907             along to the `~matplotlib.collections.PolyCollection` constructor:
5908 
5909         %(PolyCollection:kwdoc)s
5910 
5911         See Also
5912         --------
5913         pcolormesh : for an explanation of the differences between
5914             pcolor and pcolormesh.
5915         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5916             faster alternative.
5917 
5918         Notes
5919         -----
5920         **Masked arrays**
5921 
5922         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5923         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5924         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5925         plotted.
5926 
5927         .. _axes-pcolor-grid-orientation:
5928 
5929         **Grid orientation**
5930 
5931         The grid orientation follows the standard matrix convention: An array
5932         *C* with shape (nrows, ncolumns) is plotted with the column number as
5933         *X* and the row number as *Y*.
5934         """
5935 
5936         if shading is None:
5937             shading = mpl.rcParams['pcolor.shading']
5938         shading = shading.lower()
5939         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5940                                             kwargs=kwargs)
5941         Ny, Nx = X.shape
5942 
5943         # convert to MA, if necessary.
5944         C = ma.asarray(C)
5945         X = ma.asarray(X)
5946         Y = ma.asarray(Y)
5947 
5948         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5949         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5950                   mask[0:-1, 1:] + mask[1:, 0:-1])
5951         # don't plot if C or any of the surrounding vertices are masked.
5952         mask = ma.getmaskarray(C) + xymask
5953 
5954         unmask = ~mask
5955         X1 = ma.filled(X[:-1, :-1])[unmask]
5956         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5957         X2 = ma.filled(X[1:, :-1])[unmask]
5958         Y2 = ma.filled(Y[1:, :-1])[unmask]
5959         X3 = ma.filled(X[1:, 1:])[unmask]
5960         Y3 = ma.filled(Y[1:, 1:])[unmask]
5961         X4 = ma.filled(X[:-1, 1:])[unmask]
5962         Y4 = ma.filled(Y[:-1, 1:])[unmask]
5963         npoly = len(X1)
5964 
5965         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
5966         verts = xy.reshape((npoly, 5, 2))
5967 
5968         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
5969 
5970         linewidths = (0.25,)
5971         if 'linewidth' in kwargs:
5972             kwargs['linewidths'] = kwargs.pop('linewidth')
5973         kwargs.setdefault('linewidths', linewidths)
5974 
5975         if 'edgecolor' in kwargs:
5976             kwargs['edgecolors'] = kwargs.pop('edgecolor')
5977         ec = kwargs.setdefault('edgecolors', 'none')
5978 
5979         # aa setting will default via collections to patch.antialiased
5980         # unless the boundary is not stroked, in which case the
5981         # default will be False; with unstroked boundaries, aa
5982         # makes artifacts that are often disturbing.
5983         if 'antialiased' in kwargs:
5984             kwargs['antialiaseds'] = kwargs.pop('antialiased')
5985         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
5986             kwargs['antialiaseds'] = False
5987 
5988         kwargs.setdefault('snap', False)
5989 
5990         collection = mcoll.PolyCollection(
5991             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
5992         collection._scale_norm(norm, vmin, vmax)
5993 
5994         x = X.compressed()
5995         y = Y.compressed()
5996 
5997         # Transform from native to data coordinates?
5998         t = collection._transform
5999         if (not isinstance(t, mtransforms.Transform) and
6000                 hasattr(t, '_as_mpl_transform')):
6001             t = t._as_mpl_transform(self.axes)
6002 
6003         if t and any(t.contains_branch_seperately(self.transData)):
6004             trans_to_data = t - self.transData
6005             pts = np.vstack([x, y]).T.astype(float)
6006             transformed_pts = trans_to_data.transform(pts)
6007             x = transformed_pts[..., 0]
6008             y = transformed_pts[..., 1]
6009 
6010         self.add_collection(collection, autolim=False)
6011 
6012         minx = np.min(x)
6013         maxx = np.max(x)
6014         miny = np.min(y)
6015         maxy = np.max(y)
6016         collection.sticky_edges.x[:] = [minx, maxx]
6017         collection.sticky_edges.y[:] = [miny, maxy]
6018         corners = (minx, miny), (maxx, maxy)
6019         self.update_datalim(corners)
6020         self._request_autoscale_view()
6021         return collection
6022 
6023     @_preprocess_data()
6024     @_docstring.dedent_interpd
6025     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6026                    vmax=None, shading=None, antialiased=False, **kwargs):
6027         """
6028         Create a pseudocolor plot with a non-regular rectangular grid.
6029 
6030         Call signature::
6031 
6032             pcolormesh([X, Y,] C, **kwargs)
6033 
6034         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6035 
6036         .. hint::
6037 
6038            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6039            and preferred in most cases. For a detailed discussion on the
6040            differences see :ref:`Differences between pcolor() and pcolormesh()
6041            <differences-pcolor-pcolormesh>`.
6042 
6043         Parameters
6044         ----------
6045         C : array-like
6046             The mesh data. Supported array shapes are:
6047 
6048             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6049               colors using normalization and a colormap. See parameters *norm*,
6050               *cmap*, *vmin*, *vmax*.
6051             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6052             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6053               i.e. including transparency.
6054 
6055             The first two dimensions (M, N) define the rows and columns of
6056             the mesh data.
6057 
6058         X, Y : array-like, optional
6059             The coordinates of the corners of quadrilaterals of a pcolormesh::
6060 
6061                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6062                                       
6063                                            
6064                                       
6065                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6066 
6067             Note that the column index corresponds to the x-coordinate, and
6068             the row index corresponds to y. For details, see the
6069             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6070 
6071             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6072             greater than those of *C*, and the quadrilateral is colored due
6073             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6074             dimensions, a warning will be raised and the last row and column
6075             of *C* will be ignored.
6076 
6077             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6078             and *Y* should be the same as those of *C* (if not, a ValueError
6079             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6080             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6081             interpolation is caried out between the quadrilateral corners.
6082 
6083             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6084             expanded as needed into the appropriate 2D arrays, making a
6085             rectangular grid.
6086 
6087         %(cmap_doc)s
6088 
6089         %(norm_doc)s
6090 
6091         %(vmin_vmax_doc)s
6092 
6093         edgecolors : {'none', None, 'face', color, color sequence}, optional
6094             The color of the edges. Defaults to 'none'. Possible values:
6095 
6096             - 'none' or '': No edge.
6097             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6098               :rc:`patch.force_edgecolor` has to be True for this to work.
6099             - 'face': Use the adjacent face color.
6100             - A color or sequence of colors will set the edge color.
6101 
6102             The singular form *edgecolor* works as an alias.
6103 
6104         alpha : float, default: None
6105             The alpha blending value, between 0 (transparent) and 1 (opaque).
6106 
6107         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6108             The fill style for the quadrilateral; defaults to
6109             :rc:`pcolor.shading`. Possible values:
6110 
6111             - 'flat': A solid color is used for each quad. The color of the
6112               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6113               ``C[i, j]``. The dimensions of *X* and *Y* should be
6114               one greater than those of *C*; if they are the same as *C*,
6115               then a deprecation warning is raised, and the last row
6116               and column of *C* are dropped.
6117             - 'nearest': Each grid point will have a color centered on it,
6118               extending halfway between the adjacent grid centers.  The
6119               dimensions of *X* and *Y* must be the same as *C*.
6120             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6121               corners (i', j') are given by ``C[i', j']``. The color values of
6122               the area in between is interpolated from the corner values.
6123               The dimensions of *X* and *Y* must be the same as *C*. When
6124               Gouraud shading is used, *edgecolors* is ignored.
6125             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6126               larger than *C*.  Choose 'nearest' if dimensions are the same.
6127 
6128             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6129             for more description.
6130 
6131         snap : bool, default: False
6132             Whether to snap the mesh to pixel boundaries.
6133 
6134         rasterized : bool, optional
6135             Rasterize the pcolormesh when drawing vector graphics.  This can
6136             speed up rendering and produce smaller files for large data sets.
6137             See also :doc:`/gallery/misc/rasterization_demo`.
6138 
6139         Returns
6140         -------
6141         `matplotlib.collections.QuadMesh`
6142 
6143         Other Parameters
6144         ----------------
6145         data : indexable object, optional
6146             DATA_PARAMETER_PLACEHOLDER
6147 
6148         **kwargs
6149             Additionally, the following arguments are allowed. They are passed
6150             along to the `~matplotlib.collections.QuadMesh` constructor:
6151 
6152         %(QuadMesh:kwdoc)s
6153 
6154         See Also
6155         --------
6156         pcolor : An alternative implementation with slightly different
6157             features. For a detailed discussion on the differences see
6158             :ref:`Differences between pcolor() and pcolormesh()
6159             <differences-pcolor-pcolormesh>`.
6160         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6161             faster alternative.
6162 
6163         Notes
6164         -----
6165         **Masked arrays**
6166 
6167         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6168         quadrilateral will be transparent. Masking of *X* and *Y* is not
6169         supported. Use `~.Axes.pcolor` if you need this functionality.
6170 
6171         .. _axes-pcolormesh-grid-orientation:
6172 
6173         **Grid orientation**
6174 
6175         The grid orientation follows the standard matrix convention: An array
6176         *C* with shape (nrows, ncolumns) is plotted with the column number as
6177         *X* and the row number as *Y*.
6178 
6179         .. _differences-pcolor-pcolormesh:
6180 
6181         **Differences between pcolor() and pcolormesh()**
6182 
6183         Both methods are used to create a pseudocolor plot of a 2D array
6184         using quadrilaterals.
6185 
6186         The main difference lies in the created object and internal data
6187         handling:
6188         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6189         returns a `.QuadMesh`. The latter is more specialized for the given
6190         purpose and thus is faster. It should almost always be preferred.
6191 
6192         There is also a slight difference in the handling of masked arrays.
6193         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6194         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6195         and *Y*. The reason lies in the internal handling of the masked values.
6196         `~.Axes.pcolor` leaves out the respective polygons from the
6197         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6198         elements to transparent. You can see the difference when using
6199         edgecolors. While all edges are drawn irrespective of masking in a
6200         QuadMesh, the edge between two adjacent masked quadrilaterals in
6201         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6202         exist in the PolyCollection.
6203 
6204         Another difference is the support of Gouraud shading in
6205         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6206 
6207         """
6208         if shading is None:
6209             shading = mpl.rcParams['pcolor.shading']
6210         shading = shading.lower()
6211         kwargs.setdefault('edgecolors', 'none')
6212 
6213         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6214                                             shading=shading, kwargs=kwargs)
6215         coords = np.stack([X, Y], axis=-1)
6216 
6217         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6218 
6219         collection = mcoll.QuadMesh(
6220             coords, antialiased=antialiased, shading=shading,
6221             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6222         collection._scale_norm(norm, vmin, vmax)
6223 
6224         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6225 
6226         # Transform from native to data coordinates?
6227         t = collection._transform
6228         if (not isinstance(t, mtransforms.Transform) and
6229                 hasattr(t, '_as_mpl_transform')):
6230             t = t._as_mpl_transform(self.axes)
6231 
6232         if t and any(t.contains_branch_seperately(self.transData)):
6233             trans_to_data = t - self.transData
6234             coords = trans_to_data.transform(coords)
6235 
6236         self.add_collection(collection, autolim=False)
6237 
6238         minx, miny = np.min(coords, axis=0)
6239         maxx, maxy = np.max(coords, axis=0)
6240         collection.sticky_edges.x[:] = [minx, maxx]
6241         collection.sticky_edges.y[:] = [miny, maxy]
6242         corners = (minx, miny), (maxx, maxy)
6243         self.update_datalim(corners)
6244         self._request_autoscale_view()
6245         return collection
6246 
6247     @_preprocess_data()
6248     @_docstring.dedent_interpd
6249     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6250                    vmax=None, **kwargs):
6251         """
6252         Create a pseudocolor plot with a non-regular rectangular grid.
6253 
6254         Call signature::
6255 
6256           ax.pcolorfast([X, Y], C, /, **kwargs)
6257 
6258         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6259         It's designed to provide the fastest pcolor-type plotting with the
6260         Agg backend. To achieve this, it uses different algorithms internally
6261         depending on the complexity of the input grid (regular rectangular,
6262         non-regular rectangular or arbitrary quadrilateral).
6263 
6264         .. warning::
6265 
6266            This method is experimental. Compared to `~.Axes.pcolor` or
6267            `~.Axes.pcolormesh` it has some limitations:
6268 
6269            - It supports only flat shading (no outlines)
6270            - It lacks support for log scaling of the axes.
6271            - It does not have a pyplot wrapper.
6272 
6273         Parameters
6274         ----------
6275         C : array-like
6276             The image data. Supported array shapes are:
6277 
6278             - (M, N): an image with scalar data.  Color-mapping is controlled
6279               by *cmap*, *norm*, *vmin*, and *vmax*.
6280             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6281             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6282               i.e. including transparency.
6283 
6284             The first two dimensions (M, N) define the rows and columns of
6285             the image.
6286 
6287             This parameter can only be passed positionally.
6288 
6289         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6290             *X* and *Y* are used to specify the coordinates of the
6291             quadrilaterals. There are different ways to do this:
6292 
6293             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6294               a *uniform rectangular grid*.
6295 
6296               The tuples define the outer edges of the grid. All individual
6297               quadrilaterals will be of the same size. This is the fastest
6298               version.
6299 
6300             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6301               grid*.
6302 
6303               In this case *X* and *Y* have to be monotonic 1D arrays of length
6304               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6305 
6306               The speed is intermediate. Note: The grid is checked, and if
6307               found to be uniform the fast version is used.
6308 
6309             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6310               grid* (i.e. if the quadrilaterals are not rectangular).
6311 
6312               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6313               specifying the x and y coordinates of the corners of the colored
6314               quadrilaterals.
6315 
6316               This is the most general, but the slowest to render.  It may
6317               produce faster and more compact output using ps, pdf, and
6318               svg backends, however.
6319 
6320             These arguments can only be passed positionally.
6321 
6322         %(cmap_doc)s
6323 
6324             This parameter is ignored if *C* is RGB(A).
6325 
6326         %(norm_doc)s
6327 
6328             This parameter is ignored if *C* is RGB(A).
6329 
6330         %(vmin_vmax_doc)s
6331 
6332             This parameter is ignored if *C* is RGB(A).
6333 
6334         alpha : float, default: None
6335             The alpha blending value, between 0 (transparent) and 1 (opaque).
6336 
6337         snap : bool, default: False
6338             Whether to snap the mesh to pixel boundaries.
6339 
6340         Returns
6341         -------
6342         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6343             The return type depends on the type of grid:
6344 
6345             - `.AxesImage` for a regular rectangular grid.
6346             - `.PcolorImage` for a non-regular rectangular grid.
6347             - `.QuadMesh` for a non-rectangular grid.
6348 
6349         Other Parameters
6350         ----------------
6351         data : indexable object, optional
6352             DATA_PARAMETER_PLACEHOLDER
6353 
6354         **kwargs
6355             Supported additional parameters depend on the type of grid.
6356             See return types of *image* for further description.
6357         """
6358 
6359         C = args[-1]
6360         nr, nc = np.shape(C)[:2]
6361         if len(args) == 1:
6362             style = "image"
6363             x = [0, nc]
6364             y = [0, nr]
6365         elif len(args) == 3:
6366             x, y = args[:2]
6367             x = np.asarray(x)
6368             y = np.asarray(y)
6369             if x.ndim == 1 and y.ndim == 1:
6370                 if x.size == 2 and y.size == 2:
6371                     style = "image"
6372                 else:
6373                     dx = np.diff(x)
6374                     dy = np.diff(y)
6375                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6376                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6377                         style = "image"
6378                     else:
6379                         style = "pcolorimage"
6380             elif x.ndim == 2 and y.ndim == 2:
6381                 style = "quadmesh"
6382             else:
6383                 raise TypeError("arguments do not match valid signatures")
6384         else:
6385             _api.nargs_error('pcolorfast', '1 or 3', len(args))
6386 
6387         if style == "quadmesh":
6388             # data point in each cell is value at lower left corner
6389             coords = np.stack([x, y], axis=-1)
6390             if np.ndim(C) not in {2, 3}:
6391                 raise ValueError("C must be 2D or 3D")
6392             collection = mcoll.QuadMesh(
6393                 coords, array=C,
6394                 alpha=alpha, cmap=cmap, norm=norm,
6395                 antialiased=False, edgecolors="none")
6396             self.add_collection(collection, autolim=False)
6397             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6398             ret = collection
6399 
6400         else:  # It's one of the two image styles.
6401             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6402             if style == "image":
6403                 im = mimage.AxesImage(
6404                     self, cmap=cmap, norm=norm,
6405                     data=C, alpha=alpha, extent=extent,
6406                     interpolation='nearest', origin='lower',
6407                     **kwargs)
6408             elif style == "pcolorimage":
6409                 im = mimage.PcolorImage(
6410                     self, x, y, C,
6411                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6412                     **kwargs)
6413             self.add_image(im)
6414             ret = im
6415 
6416         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6417             ret._scale_norm(norm, vmin, vmax)
6418 
6419         if ret.get_clip_path() is None:
6420             # image does not already have clipping set, clip to axes patch
6421             ret.set_clip_path(self.patch)
6422 
6423         ret.sticky_edges.x[:] = [xl, xr]
6424         ret.sticky_edges.y[:] = [yb, yt]
6425         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6426         self._request_autoscale_view(tight=True)
6427         return ret
6428 
6429     @_preprocess_data()
6430     @_docstring.dedent_interpd
6431     def contour(self, *args, **kwargs):
6432         """
6433         Plot contour lines.
6434 
6435         Call signature::
6436 
6437             contour([X, Y,] Z, [levels], **kwargs)
6438         %(contour_doc)s
6439         """
6440         kwargs['filled'] = False
6441         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6442         self._request_autoscale_view()
6443         return contours
6444 
6445     @_preprocess_data()
6446     @_docstring.dedent_interpd
6447     def contourf(self, *args, **kwargs):
6448         """
6449         Plot filled contours.
6450 
6451         Call signature::
6452 
6453             contourf([X, Y,] Z, [levels], **kwargs)
6454         %(contour_doc)s
6455         """
6456         kwargs['filled'] = True
6457         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6458         self._request_autoscale_view()
6459         return contours
6460 
6461     def clabel(self, CS, levels=None, **kwargs):
6462         """
6463         Label a contour plot.
6464 
6465         Adds labels to line contours in given `.ContourSet`.
6466 
6467         Parameters
6468         ----------
6469         CS : `.ContourSet` instance
6470             Line contours to label.
6471 
6472         levels : array-like, optional
6473             A list of level values, that should be labeled. The list must be
6474             a subset of ``CS.levels``. If not given, all levels are labeled.
6475 
6476         **kwargs
6477             All other parameters are documented in `~.ContourLabeler.clabel`.
6478         """
6479         return CS.clabel(levels, **kwargs)
6480 
6481     #### Data analysis
6482 
6483     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6484     def hist(self, x, bins=None, range=None, density=False, weights=None,
6485              cumulative=False, bottom=None, histtype='bar', align='mid',
6486              orientation='vertical', rwidth=None, log=False,
6487              color=None, label=None, stacked=False, **kwargs):
6488         """
6489         Compute and plot a histogram.
6490 
6491         This method uses `numpy.histogram` to bin the data in *x* and count the
6492         number of values in each bin, then draws the distribution either as a
6493         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6494         *weights* parameters are forwarded to `numpy.histogram`.
6495 
6496         If the data has already been binned and counted, use `~.bar` or
6497         `~.stairs` to plot the distribution::
6498 
6499             counts, bins = np.histogram(x)
6500             plt.stairs(counts, bins)
6501 
6502         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6503         treating each bin as a single point with a weight equal to its count::
6504 
6505             plt.hist(bins[:-1], bins, weights=counts)
6506 
6507         The data input *x* can be a singular array, a list of datasets of
6508         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6509         which each column is a dataset. Note that the ndarray form is
6510         transposed relative to the list form. If the input is an array, then
6511         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6512         sequence of arrays, then the return value is a tuple
6513         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6514 
6515         Masked arrays are not supported.
6516 
6517         Parameters
6518         ----------
6519         x : (n,) array or sequence of (n,) arrays
6520             Input values, this takes either a single array or a sequence of
6521             arrays which are not required to be of the same length.
6522 
6523         bins : int or sequence or str, default: :rc:`hist.bins`
6524             If *bins* is an integer, it defines the number of equal-width bins
6525             in the range.
6526 
6527             If *bins* is a sequence, it defines the bin edges, including the
6528             left edge of the first bin and the right edge of the last bin;
6529             in this case, bins may be unequally spaced.  All but the last
6530             (righthand-most) bin is half-open.  In other words, if *bins* is::
6531 
6532                 [1, 2, 3, 4]
6533 
6534             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6535             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6536             *includes* 4.
6537 
6538             If *bins* is a string, it is one of the binning strategies
6539             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6540             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6541 
6542         range : tuple or None, default: None
6543             The lower and upper range of the bins. Lower and upper outliers
6544             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6545             Range has no effect if *bins* is a sequence.
6546 
6547             If *bins* is a sequence or *range* is specified, autoscaling
6548             is based on the specified bin range instead of the
6549             range of x.
6550 
6551         density : bool, default: False
6552             If ``True``, draw and return a probability density: each bin
6553             will display the bin's raw count divided by the total number of
6554             counts *and the bin width*
6555             (``density = counts / (sum(counts) * np.diff(bins))``),
6556             so that the area under the histogram integrates to 1
6557             (``np.sum(density * np.diff(bins)) == 1``).
6558 
6559             If *stacked* is also ``True``, the sum of the histograms is
6560             normalized to 1.
6561 
6562         weights : (n,) array-like or None, default: None
6563             An array of weights, of the same shape as *x*.  Each value in
6564             *x* only contributes its associated weight towards the bin count
6565             (instead of 1).  If *density* is ``True``, the weights are
6566             normalized, so that the integral of the density over the range
6567             remains 1.
6568 
6569         cumulative : bool or -1, default: False
6570             If ``True``, then a histogram is computed where each bin gives the
6571             counts in that bin plus all bins for smaller values. The last bin
6572             gives the total number of datapoints.
6573 
6574             If *density* is also ``True`` then the histogram is normalized such
6575             that the last bin equals 1.
6576 
6577             If *cumulative* is a number less than 0 (e.g., -1), the direction
6578             of accumulation is reversed.  In this case, if *density* is also
6579             ``True``, then the histogram is normalized such that the first bin
6580             equals 1.
6581 
6582         bottom : array-like, scalar, or None, default: None
6583             Location of the bottom of each bin, i.e. bins are drawn from
6584             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6585             of each bin is shifted by the same amount. If an array, each bin
6586             is shifted independently and the length of bottom must match the
6587             number of bins. If None, defaults to 0.
6588 
6589         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6590             The type of histogram to draw.
6591 
6592             - 'bar' is a traditional bar-type histogram.  If multiple data
6593               are given the bars are arranged side by side.
6594             - 'barstacked' is a bar-type histogram where multiple
6595               data are stacked on top of each other.
6596             - 'step' generates a lineplot that is by default unfilled.
6597             - 'stepfilled' generates a lineplot that is by default filled.
6598 
6599         align : {'left', 'mid', 'right'}, default: 'mid'
6600             The horizontal alignment of the histogram bars.
6601 
6602             - 'left': bars are centered on the left bin edges.
6603             - 'mid': bars are centered between the bin edges.
6604             - 'right': bars are centered on the right bin edges.
6605 
6606         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6607             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6608             and the *bottom* kwarg will be the left edges.
6609 
6610         rwidth : float or None, default: None
6611             The relative width of the bars as a fraction of the bin width.  If
6612             ``None``, automatically compute the width.
6613 
6614             Ignored if *histtype* is 'step' or 'stepfilled'.
6615 
6616         log : bool, default: False
6617             If ``True``, the histogram axis will be set to a log scale.
6618 
6619         color : color or array-like of colors or None, default: None
6620             Color or sequence of colors, one per dataset.  Default (``None``)
6621             uses the standard line color sequence.
6622 
6623         label : str or None, default: None
6624             String, or sequence of strings to match multiple datasets.  Bar
6625             charts yield multiple patches per dataset, but only the first gets
6626             the label, so that `~.Axes.legend` will work as expected.
6627 
6628         stacked : bool, default: False
6629             If ``True``, multiple data are stacked on top of each other If
6630             ``False`` multiple data are arranged side by side if histtype is
6631             'bar' or on top of each other if histtype is 'step'
6632 
6633         Returns
6634         -------
6635         n : array or list of arrays
6636             The values of the histogram bins. See *density* and *weights* for a
6637             description of the possible semantics.  If input *x* is an array,
6638             then this is an array of length *nbins*. If input is a sequence of
6639             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6640             the values of the histograms for each of the arrays in the same
6641             order.  The dtype of the array *n* (or of its element arrays) will
6642             always be float even if no weighting or normalization is used.
6643 
6644         bins : array
6645             The edges of the bins. Length nbins + 1 (nbins left edges and right
6646             edge of last bin).  Always a single array even when multiple data
6647             sets are passed in.
6648 
6649         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6650 such objects
6651             Container of individual artists used to create the histogram
6652             or list of such containers if there are multiple input datasets.
6653 
6654         Other Parameters
6655         ----------------
6656         data : indexable object, optional
6657             DATA_PARAMETER_PLACEHOLDER
6658 
6659         **kwargs
6660             `~matplotlib.patches.Patch` properties
6661 
6662         See Also
6663         --------
6664         hist2d : 2D histogram with rectangular bins
6665         hexbin : 2D histogram with hexagonal bins
6666 
6667         Notes
6668         -----
6669         For large numbers of bins (>1000), plotting can be significantly faster
6670         if *histtype* is set to 'step' or 'stepfilled' rather than 'bar' or
6671         'barstacked'.
6672         """
6673         # Avoid shadowing the builtin.
6674         bin_range = range
6675         from builtins import range
6676 
6677         if np.isscalar(x):
6678             x = [x]
6679 
6680         if bins is None:
6681             bins = mpl.rcParams['hist.bins']
6682 
6683         # Validate string inputs here to avoid cluttering subsequent code.
6684         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6685                            histtype=histtype)
6686         _api.check_in_list(['left', 'mid', 'right'], align=align)
6687         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6688 
6689         if histtype == 'barstacked' and not stacked:
6690             stacked = True
6691 
6692         # Massage 'x' for processing.
6693         x = cbook._reshape_2D(x, 'x')
6694         nx = len(x)  # number of datasets
6695 
6696         # Process unit information.  _process_unit_info sets the unit and
6697         # converts the first dataset; then we convert each following dataset
6698         # one at a time.
6699         if orientation == "vertical":
6700             convert_units = self.convert_xunits
6701             x = [*self._process_unit_info([("x", x[0])], kwargs),
6702                  *map(convert_units, x[1:])]
6703         else:  # horizontal
6704             convert_units = self.convert_yunits
6705             x = [*self._process_unit_info([("y", x[0])], kwargs),
6706                  *map(convert_units, x[1:])]
6707 
6708         if bin_range is not None:
6709             bin_range = convert_units(bin_range)
6710 
6711         if not cbook.is_scalar_or_string(bins):
6712             bins = convert_units(bins)
6713 
6714         # We need to do to 'weights' what was done to 'x'
6715         if weights is not None:
6716             w = cbook._reshape_2D(weights, 'weights')
6717         else:
6718             w = [None] * nx
6719 
6720         if len(w) != nx:
6721             raise ValueError('weights should have the same shape as x')
6722 
6723         input_empty = True
6724         for xi, wi in zip(x, w):
6725             len_xi = len(xi)
6726             if wi is not None and len(wi) != len_xi:
6727                 raise ValueError('weights should have the same shape as x')
6728             if len_xi:
6729                 input_empty = False
6730 
6731         if color is None:
6732             colors = [self._get_lines.get_next_color() for i in range(nx)]
6733         else:
6734             colors = mcolors.to_rgba_array(color)
6735             if len(colors) != nx:
6736                 raise ValueError(f"The 'color' keyword argument must have one "
6737                                  f"color per dataset, but {nx} datasets and "
6738                                  f"{len(colors)} colors were provided")
6739 
6740         hist_kwargs = dict()
6741 
6742         # if the bin_range is not given, compute without nan numpy
6743         # does not do this for us when guessing the range (but will
6744         # happily ignore nans when computing the histogram).
6745         if bin_range is None:
6746             xmin = np.inf
6747             xmax = -np.inf
6748             for xi in x:
6749                 if len(xi):
6750                     # python's min/max ignore nan,
6751                     # np.minnan returns nan for all nan input
6752                     xmin = min(xmin, np.nanmin(xi))
6753                     xmax = max(xmax, np.nanmax(xi))
6754             if xmin <= xmax:  # Only happens if we have seen a finite value.
6755                 bin_range = (xmin, xmax)
6756 
6757         # If bins are not specified either explicitly or via range,
6758         # we need to figure out the range required for all datasets,
6759         # and supply that to np.histogram.
6760         if not input_empty and len(x) > 1:
6761             if weights is not None:
6762                 _w = np.concatenate(w)
6763             else:
6764                 _w = None
6765             bins = np.histogram_bin_edges(
6766                 np.concatenate(x), bins, bin_range, _w)
6767         else:
6768             hist_kwargs['range'] = bin_range
6769 
6770         density = bool(density)
6771         if density and not stacked:
6772             hist_kwargs['density'] = density
6773 
6774         # List to store all the top coordinates of the histograms
6775         tops = []  # Will have shape (n_datasets, n_bins).
6776         # Loop through datasets
6777         for i in range(nx):
6778             # this will automatically overwrite bins,
6779             # so that each histogram uses the same bins
6780             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6781             tops.append(m)
6782         tops = np.array(tops, float)  # causes problems later if it's an int
6783         bins = np.array(bins, float)  # causes problems if float16
6784         if stacked:
6785             tops = tops.cumsum(axis=0)
6786             # If a stacked density plot, normalize so the area of all the
6787             # stacked histograms together is 1
6788             if density:
6789                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6790         if cumulative:
6791             slc = slice(None)
6792             if isinstance(cumulative, Number) and cumulative < 0:
6793                 slc = slice(None, None, -1)
6794             if density:
6795                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6796             else:
6797                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6798 
6799         patches = []
6800 
6801         if histtype.startswith('bar'):
6802 
6803             totwidth = np.diff(bins)
6804 
6805             if rwidth is not None:
6806                 dr = np.clip(rwidth, 0, 1)
6807             elif (len(tops) > 1 and
6808                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6809                 dr = 0.8
6810             else:
6811                 dr = 1.0
6812 
6813             if histtype == 'bar' and not stacked:
6814                 width = dr * totwidth / nx
6815                 dw = width
6816                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6817             elif histtype == 'barstacked' or stacked:
6818                 width = dr * totwidth
6819                 boffset, dw = 0.0, 0.0
6820 
6821             if align == 'mid':
6822                 boffset += 0.5 * totwidth
6823             elif align == 'right':
6824                 boffset += totwidth
6825 
6826             if orientation == 'horizontal':
6827                 _barfunc = self.barh
6828                 bottom_kwarg = 'left'
6829             else:  # orientation == 'vertical'
6830                 _barfunc = self.bar
6831                 bottom_kwarg = 'bottom'
6832 
6833             for top, color in zip(tops, colors):
6834                 if bottom is None:
6835                     bottom = np.zeros(len(top))
6836                 if stacked:
6837                     height = top - bottom
6838                 else:
6839                     height = top
6840                 bars = _barfunc(bins[:-1]+boffset, height, width,
6841                                 align='center', log=log,
6842                                 color=color, **{bottom_kwarg: bottom})
6843                 patches.append(bars)
6844                 if stacked:
6845                     bottom = top
6846                 boffset += dw
6847             # Remove stickies from all bars but the lowest ones, as otherwise
6848             # margin expansion would be unable to cross the stickies in the
6849             # middle of the bars.
6850             for bars in patches[1:]:
6851                 for patch in bars:
6852                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6853 
6854         elif histtype.startswith('step'):
6855             # these define the perimeter of the polygon
6856             x = np.zeros(4 * len(bins) - 3)
6857             y = np.zeros(4 * len(bins) - 3)
6858 
6859             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6860             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6861 
6862             if bottom is None:
6863                 bottom = 0
6864 
6865             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6866             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6867 
6868             if log:
6869                 if orientation == 'horizontal':
6870                     self.set_xscale('log', nonpositive='clip')
6871                 else:  # orientation == 'vertical'
6872                     self.set_yscale('log', nonpositive='clip')
6873 
6874             if align == 'left':
6875                 x -= 0.5*(bins[1]-bins[0])
6876             elif align == 'right':
6877                 x += 0.5*(bins[1]-bins[0])
6878 
6879             # If fill kwarg is set, it will be passed to the patch collection,
6880             # overriding this
6881             fill = (histtype == 'stepfilled')
6882 
6883             xvals, yvals = [], []
6884             for top in tops:
6885                 if stacked:
6886                     # top of the previous polygon becomes the bottom
6887                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6888                 # set the top of this polygon
6889                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6890 
6891                 # The starting point of the polygon has not yet been
6892                 # updated. So far only the endpoint was adjusted. This
6893                 # assignment closes the polygon. The redundant endpoint is
6894                 # later discarded (for step and stepfilled).
6895                 y[0] = y[-1]
6896 
6897                 if orientation == 'horizontal':
6898                     xvals.append(y.copy())
6899                     yvals.append(x.copy())
6900                 else:
6901                     xvals.append(x.copy())
6902                     yvals.append(y.copy())
6903 
6904             # stepfill is closed, step is not
6905             split = -1 if fill else 2 * len(bins)
6906             # add patches in reverse order so that when stacking,
6907             # items lower in the stack are plotted on top of
6908             # items higher in the stack
6909             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6910                 patches.append(self.fill(
6911                     x[:split], y[:split],
6912                     closed=True if fill else None,
6913                     facecolor=color,
6914                     edgecolor=None if fill else color,
6915                     fill=fill if fill else None,
6916                     zorder=None if fill else mlines.Line2D.zorder))
6917             for patch_list in patches:
6918                 for patch in patch_list:
6919                     if orientation == 'vertical':
6920                         patch.sticky_edges.y.append(0)
6921                     elif orientation == 'horizontal':
6922                         patch.sticky_edges.x.append(0)
6923 
6924             # we return patches, so put it back in the expected order
6925             patches.reverse()
6926 
6927         # If None, make all labels None (via zip_longest below); otherwise,
6928         # cast each element to str, but keep a single str as it.
6929         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6930         for patch, lbl in itertools.zip_longest(patches, labels):
6931             if patch:
6932                 p = patch[0]
6933                 p._internal_update(kwargs)
6934                 if lbl is not None:
6935                     p.set_label(lbl)
6936                 for p in patch[1:]:
6937                     p._internal_update(kwargs)
6938                     p.set_label('_nolegend_')
6939 
6940         if nx == 1:
6941             return tops[0], bins, patches[0]
6942         else:
6943             patch_type = ("BarContainer" if histtype.startswith("bar")
6944                           else "list[Polygon]")
6945             return tops, bins, cbook.silent_list(patch_type, patches)
6946 
6947     @_preprocess_data()
6948     def stairs(self, values, edges=None, *,
6949                orientation='vertical', baseline=0, fill=False, **kwargs):
6950         """
6951         A stepwise constant function as a line with bounding edges
6952         or a filled plot.
6953 
6954         Parameters
6955         ----------
6956         values : array-like
6957             The step heights.
6958 
6959         edges : array-like
6960             The edge positions, with ``len(edges) == len(vals) + 1``,
6961             between which the curve takes on vals values.
6962 
6963         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6964             The direction of the steps. Vertical means that *values* are along
6965             the y-axis, and edges are along the x-axis.
6966 
6967         baseline : float, array-like or None, default: 0
6968             The bottom value of the bounding edges or when
6969             ``fill=True``, position of lower edge. If *fill* is
6970             True or an array is passed to *baseline*, a closed
6971             path is drawn.
6972 
6973         fill : bool, default: False
6974             Whether the area under the step curve should be filled.
6975 
6976         Returns
6977         -------
6978         StepPatch : `matplotlib.patches.StepPatch`
6979 
6980         Other Parameters
6981         ----------------
6982         data : indexable object, optional
6983             DATA_PARAMETER_PLACEHOLDER
6984 
6985         **kwargs
6986             `~matplotlib.patches.StepPatch` properties
6987 
6988         """
6989 
6990         if 'color' in kwargs:
6991             _color = kwargs.pop('color')
6992         else:
6993             _color = self._get_lines.get_next_color()
6994         if fill:
6995             kwargs.setdefault('linewidth', 0)
6996             kwargs.setdefault('facecolor', _color)
6997         else:
6998             kwargs.setdefault('edgecolor', _color)
6999 
7000         if edges is None:
7001             edges = np.arange(len(values) + 1)
7002 
7003         edges, values, baseline = self._process_unit_info(
7004             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7005 
7006         patch = mpatches.StepPatch(values,
7007                                    edges,
7008                                    baseline=baseline,
7009                                    orientation=orientation,
7010                                    fill=fill,
7011                                    **kwargs)
7012         self.add_patch(patch)
7013         if baseline is None:
7014             baseline = 0
7015         if orientation == 'vertical':
7016             patch.sticky_edges.y.append(np.min(baseline))
7017             self.update_datalim([(edges[0], np.min(baseline))])
7018         else:
7019             patch.sticky_edges.x.append(np.min(baseline))
7020             self.update_datalim([(np.min(baseline), edges[0])])
7021         self._request_autoscale_view()
7022         return patch
7023 
7024     @_preprocess_data(replace_names=["x", "y", "weights"])
7025     @_docstring.dedent_interpd
7026     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7027                cmin=None, cmax=None, **kwargs):
7028         """
7029         Make a 2D histogram plot.
7030 
7031         Parameters
7032         ----------
7033         x, y : array-like, shape (n, )
7034             Input values
7035 
7036         bins : None or int or [int, int] or array-like or [array, array]
7037 
7038             The bin specification:
7039 
7040             - If int, the number of bins for the two dimensions
7041               (nx=ny=bins).
7042             - If ``[int, int]``, the number of bins in each dimension
7043               (nx, ny = bins).
7044             - If array-like, the bin edges for the two dimensions
7045               (x_edges=y_edges=bins).
7046             - If ``[array, array]``, the bin edges in each dimension
7047               (x_edges, y_edges = bins).
7048 
7049             The default value is 10.
7050 
7051         range : array-like shape(2, 2), optional
7052             The leftmost and rightmost edges of the bins along each dimension
7053             (if not specified explicitly in the bins parameters): ``[[xmin,
7054             xmax], [ymin, ymax]]``. All values outside of this range will be
7055             considered outliers and not tallied in the histogram.
7056 
7057         density : bool, default: False
7058             Normalize histogram.  See the documentation for the *density*
7059             parameter of `~.Axes.hist` for more details.
7060 
7061         weights : array-like, shape (n, ), optional
7062             An array of values w_i weighing each sample (x_i, y_i).
7063 
7064         cmin, cmax : float, default: None
7065             All bins that has count less than *cmin* or more than *cmax* will
7066             not be displayed (set to NaN before passing to imshow) and these
7067             count values in the return value count histogram will also be set
7068             to nan upon return.
7069 
7070         Returns
7071         -------
7072         h : 2D array
7073             The bi-dimensional histogram of samples x and y. Values in x are
7074             histogrammed along the first dimension and values in y are
7075             histogrammed along the second dimension.
7076         xedges : 1D array
7077             The bin edges along the x-axis.
7078         yedges : 1D array
7079             The bin edges along the y-axis.
7080         image : `~.matplotlib.collections.QuadMesh`
7081 
7082         Other Parameters
7083         ----------------
7084         %(cmap_doc)s
7085 
7086         %(norm_doc)s
7087 
7088         %(vmin_vmax_doc)s
7089 
7090         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7091             The alpha blending value.
7092 
7093         data : indexable object, optional
7094             DATA_PARAMETER_PLACEHOLDER
7095 
7096         **kwargs
7097             Additional parameters are passed along to the
7098             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7099             constructor.
7100 
7101         See Also
7102         --------
7103         hist : 1D histogram plotting
7104         hexbin : 2D histogram with hexagonal bins
7105 
7106         Notes
7107         -----
7108         - Currently ``hist2d`` calculates its own axis limits, and any limits
7109           previously set are ignored.
7110         - Rendering the histogram with a logarithmic color scale is
7111           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7112           keyword argument. Likewise, power-law normalization (similar
7113           in effect to gamma correction) can be accomplished with
7114           `.colors.PowerNorm`.
7115         """
7116 
7117         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7118                                            density=density, weights=weights)
7119 
7120         if cmin is not None:
7121             h[h < cmin] = None
7122         if cmax is not None:
7123             h[h > cmax] = None
7124 
7125         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7126         self.set_xlim(xedges[0], xedges[-1])
7127         self.set_ylim(yedges[0], yedges[-1])
7128 
7129         return h, xedges, yedges, pc
7130 
7131     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7132     @_docstring.dedent_interpd
7133     def ecdf(self, x, weights=None, *, complementary=False,
7134              orientation="vertical", compress=False, **kwargs):
7135         """
7136         Compute and plot the empirical cumulative distribution function of *x*.
7137 
7138         .. versionadded:: 3.8
7139 
7140         Parameters
7141         ----------
7142         x : 1d array-like
7143             The input data.  Infinite entries are kept (and move the relevant
7144             end of the ecdf from 0/1), but NaNs and masked values are errors.
7145 
7146         weights : 1d array-like or None, default: None
7147             The weights of the entries; must have the same shape as *x*.
7148             Weights corresponding to NaN data points are dropped, and then the
7149             remaining weights are normalized to sum to 1.  If unset, all
7150             entries have the same weight.
7151 
7152         complementary : bool, default: False
7153             Whether to plot a cumulative distribution function, which increases
7154             from 0 to 1 (the default), or a complementary cumulative
7155             distribution function, which decreases from 1 to 0.
7156 
7157         orientation : {"vertical", "horizontal"}, default: "vertical"
7158             Whether the entries are plotted along the x-axis ("vertical", the
7159             default) or the y-axis ("horizontal").  This parameter takes the
7160             same values as in `~.Axes.hist`.
7161 
7162         compress : bool, default: False
7163             Whether multiple entries with the same values are grouped together
7164             (with a summed weight) before plotting.  This is mainly useful if
7165             *x* contains many identical data points, to decrease the rendering
7166             complexity of the plot. If *x* contains no duplicate points, this
7167             has no effect and just uses some time and memory.
7168 
7169         Other Parameters
7170         ----------------
7171         data : indexable object, optional
7172             DATA_PARAMETER_PLACEHOLDER
7173 
7174         **kwargs
7175             Keyword arguments control the `.Line2D` properties:
7176 
7177             %(Line2D:kwdoc)s
7178 
7179         Returns
7180         -------
7181         `.Line2D`
7182 
7183         Notes
7184         -----
7185         The ecdf plot can be thought of as a cumulative histogram with one bin
7186         per data entry; i.e. it reports on the entire dataset without any
7187         arbitrary binning.
7188 
7189         If *x* contains NaNs or masked entries, either remove them first from
7190         the array (if they should not taken into account), or replace them by
7191         -inf or +inf (if they should be sorted at the beginning or the end of
7192         the array).
7193         """
7194         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7195         if "drawstyle" in kwargs or "ds" in kwargs:
7196             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7197         if np.ma.getmask(x).any():
7198             raise ValueError("ecdf() does not support masked entries")
7199         x = np.asarray(x)
7200         if np.isnan(x).any():
7201             raise ValueError("ecdf() does not support NaNs")
7202         argsort = np.argsort(x)
7203         x = x[argsort]
7204         if weights is None:
7205             # Ensure that we end at exactly 1, avoiding floating point errors.
7206             cum_weights = (1 + np.arange(len(x))) / len(x)
7207         else:
7208             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7209             cum_weights = np.cumsum(weights / np.sum(weights))
7210         if compress:
7211             # Get indices of unique x values.
7212             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7213             x = x[compress_idxs]
7214             cum_weights = cum_weights[compress_idxs]
7215         if orientation == "vertical":
7216             if not complementary:
7217                 line, = self.plot([x[0], *x], [0, *cum_weights],
7218                                   drawstyle="steps-post", **kwargs)
7219             else:
7220                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7221                                   drawstyle="steps-pre", **kwargs)
7222             line.sticky_edges.y[:] = [0, 1]
7223         else:  # orientation == "horizontal":
7224             if not complementary:
7225                 line, = self.plot([0, *cum_weights], [x[0], *x],
7226                                   drawstyle="steps-pre", **kwargs)
7227             else:
7228                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7229                                   drawstyle="steps-post", **kwargs)
7230             line.sticky_edges.x[:] = [0, 1]
7231         return line
7232 
7233     @_preprocess_data(replace_names=["x"])
7234     @_docstring.dedent_interpd
7235     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7236             window=None, noverlap=None, pad_to=None,
7237             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7238         r"""
7239         Plot the power spectral density.
7240 
7241         The power spectral density :math:`P_{xx}` by Welch's average
7242         periodogram method.  The vector *x* is divided into *NFFT* length
7243         segments.  Each segment is detrended by function *detrend* and
7244         windowed by function *window*.  *noverlap* gives the length of
7245         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7246         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7247         with a scaling to correct for power loss due to windowing.
7248 
7249         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7250 
7251         Parameters
7252         ----------
7253         x : 1-D array or sequence
7254             Array or sequence containing the data
7255 
7256         %(Spectral)s
7257 
7258         %(PSD)s
7259 
7260         noverlap : int, default: 0 (no overlap)
7261             The number of points of overlap between segments.
7262 
7263         Fc : int, default: 0
7264             The center frequency of *x*, which offsets the x extents of the
7265             plot to reflect the frequency range used when a signal is acquired
7266             and then filtered and downsampled to baseband.
7267 
7268         return_line : bool, default: False
7269             Whether to include the line object plotted in the returned values.
7270 
7271         Returns
7272         -------
7273         Pxx : 1-D array
7274             The values for the power spectrum :math:`P_{xx}` before scaling
7275             (real valued).
7276 
7277         freqs : 1-D array
7278             The frequencies corresponding to the elements in *Pxx*.
7279 
7280         line : `~matplotlib.lines.Line2D`
7281             The line created by this function.
7282             Only returned if *return_line* is True.
7283 
7284         Other Parameters
7285         ----------------
7286         data : indexable object, optional
7287             DATA_PARAMETER_PLACEHOLDER
7288 
7289         **kwargs
7290             Keyword arguments control the `.Line2D` properties:
7291 
7292             %(Line2D:kwdoc)s
7293 
7294         See Also
7295         --------
7296         specgram
7297             Differs in the default overlap; in not returning the mean of the
7298             segment periodograms; in returning the times of the segments; and
7299             in plotting a colormap instead of a line.
7300         magnitude_spectrum
7301             Plots the magnitude spectrum.
7302         csd
7303             Plots the spectral density between two signals.
7304 
7305         Notes
7306         -----
7307         For plotting, the power is plotted as
7308         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7309         is returned.
7310 
7311         References
7312         ----------
7313         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7314         John Wiley & Sons (1986)
7315         """
7316         if Fc is None:
7317             Fc = 0
7318 
7319         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7320                               window=window, noverlap=noverlap, pad_to=pad_to,
7321                               sides=sides, scale_by_freq=scale_by_freq)
7322         freqs += Fc
7323 
7324         if scale_by_freq in (None, True):
7325             psd_units = 'dB/Hz'
7326         else:
7327             psd_units = 'dB'
7328 
7329         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7330         self.set_xlabel('Frequency')
7331         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7332         self.grid(True)
7333 
7334         vmin, vmax = self.get_ybound()
7335         step = max(10 * int(np.log10(vmax - vmin)), 1)
7336         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7337         self.set_yticks(ticks)
7338 
7339         if return_line is None or not return_line:
7340             return pxx, freqs
7341         else:
7342             return pxx, freqs, line
7343 
7344     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7345     @_docstring.dedent_interpd
7346     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7347             window=None, noverlap=None, pad_to=None,
7348             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7349         r"""
7350         Plot the cross-spectral density.
7351 
7352         The cross spectral density :math:`P_{xy}` by Welch's average
7353         periodogram method.  The vectors *x* and *y* are divided into
7354         *NFFT* length segments.  Each segment is detrended by function
7355         *detrend* and windowed by function *window*.  *noverlap* gives
7356         the length of the overlap between segments.  The product of
7357         the direct FFTs of *x* and *y* are averaged over each segment
7358         to compute :math:`P_{xy}`, with a scaling to correct for power
7359         loss due to windowing.
7360 
7361         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7362         padded to *NFFT*.
7363 
7364         Parameters
7365         ----------
7366         x, y : 1-D arrays or sequences
7367             Arrays or sequences containing the data.
7368 
7369         %(Spectral)s
7370 
7371         %(PSD)s
7372 
7373         noverlap : int, default: 0 (no overlap)
7374             The number of points of overlap between segments.
7375 
7376         Fc : int, default: 0
7377             The center frequency of *x*, which offsets the x extents of the
7378             plot to reflect the frequency range used when a signal is acquired
7379             and then filtered and downsampled to baseband.
7380 
7381         return_line : bool, default: False
7382             Whether to include the line object plotted in the returned values.
7383 
7384         Returns
7385         -------
7386         Pxy : 1-D array
7387             The values for the cross spectrum :math:`P_{xy}` before scaling
7388             (complex valued).
7389 
7390         freqs : 1-D array
7391             The frequencies corresponding to the elements in *Pxy*.
7392 
7393         line : `~matplotlib.lines.Line2D`
7394             The line created by this function.
7395             Only returned if *return_line* is True.
7396 
7397         Other Parameters
7398         ----------------
7399         data : indexable object, optional
7400             DATA_PARAMETER_PLACEHOLDER
7401 
7402         **kwargs
7403             Keyword arguments control the `.Line2D` properties:
7404 
7405             %(Line2D:kwdoc)s
7406 
7407         See Also
7408         --------
7409         psd : is equivalent to setting ``y = x``.
7410 
7411         Notes
7412         -----
7413         For plotting, the power is plotted as
7414         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7415         is returned.
7416 
7417         References
7418         ----------
7419         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7420         John Wiley & Sons (1986)
7421         """
7422         if Fc is None:
7423             Fc = 0
7424 
7425         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7426                               window=window, noverlap=noverlap, pad_to=pad_to,
7427                               sides=sides, scale_by_freq=scale_by_freq)
7428         # pxy is complex
7429         freqs += Fc
7430 
7431         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7432         self.set_xlabel('Frequency')
7433         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7434         self.grid(True)
7435 
7436         vmin, vmax = self.get_ybound()
7437         step = max(10 * int(np.log10(vmax - vmin)), 1)
7438         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7439         self.set_yticks(ticks)
7440 
7441         if return_line is None or not return_line:
7442             return pxy, freqs
7443         else:
7444             return pxy, freqs, line
7445 
7446     @_preprocess_data(replace_names=["x"])
7447     @_docstring.dedent_interpd
7448     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7449                            pad_to=None, sides=None, scale=None,
7450                            **kwargs):
7451         """
7452         Plot the magnitude spectrum.
7453 
7454         Compute the magnitude spectrum of *x*.  Data is padded to a
7455         length of *pad_to* and the windowing function *window* is applied to
7456         the signal.
7457 
7458         Parameters
7459         ----------
7460         x : 1-D array or sequence
7461             Array or sequence containing the data.
7462 
7463         %(Spectral)s
7464 
7465         %(Single_Spectrum)s
7466 
7467         scale : {'default', 'linear', 'dB'}
7468             The scaling of the values in the *spec*.  'linear' is no scaling.
7469             'dB' returns the values in dB scale, i.e., the dB amplitude
7470             (20 * log10). 'default' is 'linear'.
7471 
7472         Fc : int, default: 0
7473             The center frequency of *x*, which offsets the x extents of the
7474             plot to reflect the frequency range used when a signal is acquired
7475             and then filtered and downsampled to baseband.
7476 
7477         Returns
7478         -------
7479         spectrum : 1-D array
7480             The values for the magnitude spectrum before scaling (real valued).
7481 
7482         freqs : 1-D array
7483             The frequencies corresponding to the elements in *spectrum*.
7484 
7485         line : `~matplotlib.lines.Line2D`
7486             The line created by this function.
7487 
7488         Other Parameters
7489         ----------------
7490         data : indexable object, optional
7491             DATA_PARAMETER_PLACEHOLDER
7492 
7493         **kwargs
7494             Keyword arguments control the `.Line2D` properties:
7495 
7496             %(Line2D:kwdoc)s
7497 
7498         See Also
7499         --------
7500         psd
7501             Plots the power spectral density.
7502         angle_spectrum
7503             Plots the angles of the corresponding frequencies.
7504         phase_spectrum
7505             Plots the phase (unwrapped angle) of the corresponding frequencies.
7506         specgram
7507             Can plot the magnitude spectrum of segments within the signal in a
7508             colormap.
7509         """
7510         if Fc is None:
7511             Fc = 0
7512 
7513         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7514                                               pad_to=pad_to, sides=sides)
7515         freqs += Fc
7516 
7517         yunits = _api.check_getitem(
7518             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7519              'dB': 'dB'},
7520             scale=scale)
7521         if yunits == 'energy':
7522             Z = spec
7523         else:  # yunits == 'dB'
7524             Z = 20. * np.log10(spec)
7525 
7526         line, = self.plot(freqs, Z, **kwargs)
7527         self.set_xlabel('Frequency')
7528         self.set_ylabel('Magnitude (%s)' % yunits)
7529 
7530         return spec, freqs, line
7531 
7532     @_preprocess_data(replace_names=["x"])
7533     @_docstring.dedent_interpd
7534     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7535                        pad_to=None, sides=None, **kwargs):
7536         """
7537         Plot the angle spectrum.
7538 
7539         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7540         Data is padded to a length of *pad_to* and the windowing function
7541         *window* is applied to the signal.
7542 
7543         Parameters
7544         ----------
7545         x : 1-D array or sequence
7546             Array or sequence containing the data.
7547 
7548         %(Spectral)s
7549 
7550         %(Single_Spectrum)s
7551 
7552         Fc : int, default: 0
7553             The center frequency of *x*, which offsets the x extents of the
7554             plot to reflect the frequency range used when a signal is acquired
7555             and then filtered and downsampled to baseband.
7556 
7557         Returns
7558         -------
7559         spectrum : 1-D array
7560             The values for the angle spectrum in radians (real valued).
7561 
7562         freqs : 1-D array
7563             The frequencies corresponding to the elements in *spectrum*.
7564 
7565         line : `~matplotlib.lines.Line2D`
7566             The line created by this function.
7567 
7568         Other Parameters
7569         ----------------
7570         data : indexable object, optional
7571             DATA_PARAMETER_PLACEHOLDER
7572 
7573         **kwargs
7574             Keyword arguments control the `.Line2D` properties:
7575 
7576             %(Line2D:kwdoc)s
7577 
7578         See Also
7579         --------
7580         magnitude_spectrum
7581             Plots the magnitudes of the corresponding frequencies.
7582         phase_spectrum
7583             Plots the unwrapped version of this function.
7584         specgram
7585             Can plot the angle spectrum of segments within the signal in a
7586             colormap.
7587         """
7588         if Fc is None:
7589             Fc = 0
7590 
7591         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7592                                           pad_to=pad_to, sides=sides)
7593         freqs += Fc
7594 
7595         lines = self.plot(freqs, spec, **kwargs)
7596         self.set_xlabel('Frequency')
7597         self.set_ylabel('Angle (radians)')
7598 
7599         return spec, freqs, lines[0]
7600 
7601     @_preprocess_data(replace_names=["x"])
7602     @_docstring.dedent_interpd
7603     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7604                        pad_to=None, sides=None, **kwargs):
7605         """
7606         Plot the phase spectrum.
7607 
7608         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7609         Data is padded to a length of *pad_to* and the windowing function
7610         *window* is applied to the signal.
7611 
7612         Parameters
7613         ----------
7614         x : 1-D array or sequence
7615             Array or sequence containing the data
7616 
7617         %(Spectral)s
7618 
7619         %(Single_Spectrum)s
7620 
7621         Fc : int, default: 0
7622             The center frequency of *x*, which offsets the x extents of the
7623             plot to reflect the frequency range used when a signal is acquired
7624             and then filtered and downsampled to baseband.
7625 
7626         Returns
7627         -------
7628         spectrum : 1-D array
7629             The values for the phase spectrum in radians (real valued).
7630 
7631         freqs : 1-D array
7632             The frequencies corresponding to the elements in *spectrum*.
7633 
7634         line : `~matplotlib.lines.Line2D`
7635             The line created by this function.
7636 
7637         Other Parameters
7638         ----------------
7639         data : indexable object, optional
7640             DATA_PARAMETER_PLACEHOLDER
7641 
7642         **kwargs
7643             Keyword arguments control the `.Line2D` properties:
7644 
7645             %(Line2D:kwdoc)s
7646 
7647         See Also
7648         --------
7649         magnitude_spectrum
7650             Plots the magnitudes of the corresponding frequencies.
7651         angle_spectrum
7652             Plots the wrapped version of this function.
7653         specgram
7654             Can plot the phase spectrum of segments within the signal in a
7655             colormap.
7656         """
7657         if Fc is None:
7658             Fc = 0
7659 
7660         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7661                                           pad_to=pad_to, sides=sides)
7662         freqs += Fc
7663 
7664         lines = self.plot(freqs, spec, **kwargs)
7665         self.set_xlabel('Frequency')
7666         self.set_ylabel('Phase (radians)')
7667 
7668         return spec, freqs, lines[0]
7669 
7670     @_preprocess_data(replace_names=["x", "y"])
7671     @_docstring.dedent_interpd
7672     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7673                window=mlab.window_hanning, noverlap=0, pad_to=None,
7674                sides='default', scale_by_freq=None, **kwargs):
7675         r"""
7676         Plot the coherence between *x* and *y*.
7677 
7678         Coherence is the normalized cross spectral density:
7679 
7680         .. math::
7681 
7682           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7683 
7684         Parameters
7685         ----------
7686         %(Spectral)s
7687 
7688         %(PSD)s
7689 
7690         noverlap : int, default: 0 (no overlap)
7691             The number of points of overlap between blocks.
7692 
7693         Fc : int, default: 0
7694             The center frequency of *x*, which offsets the x extents of the
7695             plot to reflect the frequency range used when a signal is acquired
7696             and then filtered and downsampled to baseband.
7697 
7698         Returns
7699         -------
7700         Cxy : 1-D array
7701             The coherence vector.
7702 
7703         freqs : 1-D array
7704             The frequencies for the elements in *Cxy*.
7705 
7706         Other Parameters
7707         ----------------
7708         data : indexable object, optional
7709             DATA_PARAMETER_PLACEHOLDER
7710 
7711         **kwargs
7712             Keyword arguments control the `.Line2D` properties:
7713 
7714             %(Line2D:kwdoc)s
7715 
7716         References
7717         ----------
7718         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7719         John Wiley & Sons (1986)
7720         """
7721         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7722                                  window=window, noverlap=noverlap,
7723                                  scale_by_freq=scale_by_freq, sides=sides,
7724                                  pad_to=pad_to)
7725         freqs += Fc
7726 
7727         self.plot(freqs, cxy, **kwargs)
7728         self.set_xlabel('Frequency')
7729         self.set_ylabel('Coherence')
7730         self.grid(True)
7731 
7732         return cxy, freqs
7733 
7734     @_preprocess_data(replace_names=["x"])
7735     @_docstring.dedent_interpd
7736     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7737                  window=None, noverlap=None,
7738                  cmap=None, xextent=None, pad_to=None, sides=None,
7739                  scale_by_freq=None, mode=None, scale=None,
7740                  vmin=None, vmax=None, **kwargs):
7741         """
7742         Plot a spectrogram.
7743 
7744         Compute and plot a spectrogram of data in *x*.  Data are split into
7745         *NFFT* length segments and the spectrum of each section is
7746         computed.  The windowing function *window* is applied to each
7747         segment, and the amount of overlap of each segment is
7748         specified with *noverlap*. The spectrogram is plotted as a colormap
7749         (using imshow).
7750 
7751         Parameters
7752         ----------
7753         x : 1-D array or sequence
7754             Array or sequence containing the data.
7755 
7756         %(Spectral)s
7757 
7758         %(PSD)s
7759 
7760         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7761             What sort of spectrum to use.  Default is 'psd', which takes the
7762             power spectral density.  'magnitude' returns the magnitude
7763             spectrum.  'angle' returns the phase spectrum without unwrapping.
7764             'phase' returns the phase spectrum with unwrapping.
7765 
7766         noverlap : int, default: 128
7767             The number of points of overlap between blocks.
7768 
7769         scale : {'default', 'linear', 'dB'}
7770             The scaling of the values in the *spec*.  'linear' is no scaling.
7771             'dB' returns the values in dB scale.  When *mode* is 'psd',
7772             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7773             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7774             'magnitude' and 'linear' otherwise.  This must be 'linear'
7775             if *mode* is 'angle' or 'phase'.
7776 
7777         Fc : int, default: 0
7778             The center frequency of *x*, which offsets the x extents of the
7779             plot to reflect the frequency range used when a signal is acquired
7780             and then filtered and downsampled to baseband.
7781 
7782         cmap : `.Colormap`, default: :rc:`image.cmap`
7783 
7784         xextent : *None* or (xmin, xmax)
7785             The image extent along the x-axis. The default sets *xmin* to the
7786             left border of the first bin (*spectrum* column) and *xmax* to the
7787             right border of the last bin. Note that for *noverlap>0* the width
7788             of the bins is smaller than those of the segments.
7789 
7790         data : indexable object, optional
7791             DATA_PARAMETER_PLACEHOLDER
7792 
7793         **kwargs
7794             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7795             which makes the specgram image. The origin keyword argument
7796             is not supported.
7797 
7798         Returns
7799         -------
7800         spectrum : 2D array
7801             Columns are the periodograms of successive segments.
7802 
7803         freqs : 1-D array
7804             The frequencies corresponding to the rows in *spectrum*.
7805 
7806         t : 1-D array
7807             The times corresponding to midpoints of segments (i.e., the columns
7808             in *spectrum*).
7809 
7810         im : `.AxesImage`
7811             The image created by imshow containing the spectrogram.
7812 
7813         See Also
7814         --------
7815         psd
7816             Differs in the default overlap; in returning the mean of the
7817             segment periodograms; in not returning times; and in generating a
7818             line plot instead of colormap.
7819         magnitude_spectrum
7820             A single spectrum, similar to having a single segment when *mode*
7821             is 'magnitude'. Plots a line instead of a colormap.
7822         angle_spectrum
7823             A single spectrum, similar to having a single segment when *mode*
7824             is 'angle'. Plots a line instead of a colormap.
7825         phase_spectrum
7826             A single spectrum, similar to having a single segment when *mode*
7827             is 'phase'. Plots a line instead of a colormap.
7828 
7829         Notes
7830         -----
7831         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7832         is set to 'psd'.
7833         """
7834         if NFFT is None:
7835             NFFT = 256  # same default as in mlab.specgram()
7836         if Fc is None:
7837             Fc = 0  # same default as in mlab._spectral_helper()
7838         if noverlap is None:
7839             noverlap = 128  # same default as in mlab.specgram()
7840         if Fs is None:
7841             Fs = 2  # same default as in mlab._spectral_helper()
7842 
7843         if mode == 'complex':
7844             raise ValueError('Cannot plot a complex specgram')
7845 
7846         if scale is None or scale == 'default':
7847             if mode in ['angle', 'phase']:
7848                 scale = 'linear'
7849             else:
7850                 scale = 'dB'
7851         elif mode in ['angle', 'phase'] and scale == 'dB':
7852             raise ValueError('Cannot use dB scale with angle or phase mode')
7853 
7854         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7855                                        detrend=detrend, window=window,
7856                                        noverlap=noverlap, pad_to=pad_to,
7857                                        sides=sides,
7858                                        scale_by_freq=scale_by_freq,
7859                                        mode=mode)
7860 
7861         if scale == 'linear':
7862             Z = spec
7863         elif scale == 'dB':
7864             if mode is None or mode == 'default' or mode == 'psd':
7865                 Z = 10. * np.log10(spec)
7866             else:
7867                 Z = 20. * np.log10(spec)
7868         else:
7869             raise ValueError(f'Unknown scale {scale!r}')
7870 
7871         Z = np.flipud(Z)
7872 
7873         if xextent is None:
7874             # padding is needed for first and last segment:
7875             pad_xextent = (NFFT-noverlap) / Fs / 2
7876             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7877         xmin, xmax = xextent
7878         freqs += Fc
7879         extent = xmin, xmax, freqs[0], freqs[-1]
7880 
7881         if 'origin' in kwargs:
7882             raise _api.kwarg_error("specgram", "origin")
7883 
7884         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7885                          origin='upper', **kwargs)
7886         self.axis('auto')
7887 
7888         return spec, freqs, t, im
7889 
7890     @_docstring.dedent_interpd
7891     def spy(self, Z, precision=0, marker=None, markersize=None,
7892             aspect='equal', origin="upper", **kwargs):
7893         """
7894         Plot the sparsity pattern of a 2D array.
7895 
7896         This visualizes the non-zero values of the array.
7897 
7898         Two plotting styles are available: image and marker. Both
7899         are available for full arrays, but only the marker style
7900         works for `scipy.sparse.spmatrix` instances.
7901 
7902         **Image style**
7903 
7904         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7905         extra remaining keyword arguments are passed to this method.
7906 
7907         **Marker style**
7908 
7909         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7910         *None*, a `.Line2D` object will be returned with the value of marker
7911         determining the marker type, and any remaining keyword arguments
7912         passed to `~.Axes.plot`.
7913 
7914         Parameters
7915         ----------
7916         Z : (M, N) array-like
7917             The array to be plotted.
7918 
7919         precision : float or 'present', default: 0
7920             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7921             values of :math:`|Z| > precision` will be plotted.
7922 
7923             For `scipy.sparse.spmatrix` instances, you can also
7924             pass 'present'. In this case any value present in the array
7925             will be plotted, even if it is identically zero.
7926 
7927         aspect : {'equal', 'auto', None} or float, default: 'equal'
7928             The aspect ratio of the Axes.  This parameter is particularly
7929             relevant for images since it determines whether data pixels are
7930             square.
7931 
7932             This parameter is a shortcut for explicitly calling
7933             `.Axes.set_aspect`. See there for further details.
7934 
7935             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7936             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7937               that the data fit in the Axes. In general, this will result in
7938               non-square pixels.
7939             - *None*: Use :rc:`image.aspect`.
7940 
7941         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7942             Place the [0, 0] index of the array in the upper left or lower left
7943             corner of the Axes. The convention 'upper' is typically used for
7944             matrices and images.
7945 
7946         Returns
7947         -------
7948         `~matplotlib.image.AxesImage` or `.Line2D`
7949             The return type depends on the plotting style (see above).
7950 
7951         Other Parameters
7952         ----------------
7953         **kwargs
7954             The supported additional parameters depend on the plotting style.
7955 
7956             For the image style, you can pass the following additional
7957             parameters of `~.Axes.imshow`:
7958 
7959             - *cmap*
7960             - *alpha*
7961             - *url*
7962             - any `.Artist` properties (passed on to the `.AxesImage`)
7963 
7964             For the marker style, you can pass any `.Line2D` property except
7965             for *linestyle*:
7966 
7967             %(Line2D:kwdoc)s
7968         """
7969         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
7970             marker = 's'
7971         _api.check_in_list(["upper", "lower"], origin=origin)
7972         if marker is None and markersize is None:
7973             Z = np.asarray(Z)
7974             mask = np.abs(Z) > precision
7975 
7976             if 'cmap' not in kwargs:
7977                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
7978                                                         name='binary')
7979             if 'interpolation' in kwargs:
7980                 raise _api.kwarg_error("spy", "interpolation")
7981             if 'norm' not in kwargs:
7982                 kwargs['norm'] = mcolors.NoNorm()
7983             ret = self.imshow(mask, interpolation='nearest',
7984                               aspect=aspect, origin=origin,
7985                               **kwargs)
7986         else:
7987             if hasattr(Z, 'tocoo'):
7988                 c = Z.tocoo()
7989                 if precision == 'present':
7990                     y = c.row
7991                     x = c.col
7992                 else:
7993                     nonzero = np.abs(c.data) > precision
7994                     y = c.row[nonzero]
7995                     x = c.col[nonzero]
7996             else:
7997                 Z = np.asarray(Z)
7998                 nonzero = np.abs(Z) > precision
7999                 y, x = np.nonzero(nonzero)
8000             if marker is None:
8001                 marker = 's'
8002             if markersize is None:
8003                 markersize = 10
8004             if 'linestyle' in kwargs:
8005                 raise _api.kwarg_error("spy", "linestyle")
8006             ret = mlines.Line2D(
8007                 x, y, linestyle='None', marker=marker, markersize=markersize,
8008                 **kwargs)
8009             self.add_line(ret)
8010             nr, nc = Z.shape
8011             self.set_xlim(-0.5, nc - 0.5)
8012             if origin == "upper":
8013                 self.set_ylim(nr - 0.5, -0.5)
8014             else:
8015                 self.set_ylim(-0.5, nr - 0.5)
8016             self.set_aspect(aspect)
8017         self.title.set_y(1.05)
8018         if origin == "upper":
8019             self.xaxis.tick_top()
8020         else:  # lower
8021             self.xaxis.tick_bottom()
8022         self.xaxis.set_ticks_position('both')
8023         self.xaxis.set_major_locator(
8024             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8025         self.yaxis.set_major_locator(
8026             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8027         return ret
8028 
8029     def matshow(self, Z, **kwargs):
8030         """
8031         Plot the values of a 2D matrix or array as color-coded image.
8032 
8033         The matrix will be shown the way it would be printed, with the first
8034         row at the top.  Row and column numbering is zero-based.
8035 
8036         Parameters
8037         ----------
8038         Z : (M, N) array-like
8039             The matrix to be displayed.
8040 
8041         Returns
8042         -------
8043         `~matplotlib.image.AxesImage`
8044 
8045         Other Parameters
8046         ----------------
8047         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8048 
8049         See Also
8050         --------
8051         imshow : More general function to plot data on a 2D regular raster.
8052 
8053         Notes
8054         -----
8055         This is just a convenience function wrapping `.imshow` to set useful
8056         defaults for displaying a matrix. In particular:
8057 
8058         - Set ``origin='upper'``.
8059         - Set ``interpolation='nearest'``.
8060         - Set ``aspect='equal'``.
8061         - Ticks are placed to the left and above.
8062         - Ticks are formatted to show integer indices.
8063 
8064         """
8065         Z = np.asanyarray(Z)
8066         kw = {'origin': 'upper',
8067               'interpolation': 'nearest',
8068               'aspect': 'equal',          # (already the imshow default)
8069               **kwargs}
8070         im = self.imshow(Z, **kw)
8071         self.title.set_y(1.05)
8072         self.xaxis.tick_top()
8073         self.xaxis.set_ticks_position('both')
8074         self.xaxis.set_major_locator(
8075             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8076         self.yaxis.set_major_locator(
8077             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8078         return im
8079 
8080     @_preprocess_data(replace_names=["dataset"])
8081     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8082                    showmeans=False, showextrema=True, showmedians=False,
8083                    quantiles=None, points=100, bw_method=None):
8084         """
8085         Make a violin plot.
8086 
8087         Make a violin plot for each column of *dataset* or each vector in
8088         sequence *dataset*.  Each filled area extends to represent the
8089         entire data range, with optional lines at the mean, the median,
8090         the minimum, the maximum, and user-specified quantiles.
8091 
8092         Parameters
8093         ----------
8094         dataset : Array or a sequence of vectors.
8095           The input data.
8096 
8097         positions : array-like, default: [1, 2, ..., n]
8098           The positions of the violins. The ticks and limits are
8099           automatically set to match the positions.
8100 
8101         vert : bool, default: True.
8102           If true, creates a vertical violin plot.
8103           Otherwise, creates a horizontal violin plot.
8104 
8105         widths : array-like, default: 0.5
8106           Either a scalar or a vector that sets the maximal width of
8107           each violin. The default is 0.5, which uses about half of the
8108           available horizontal space.
8109 
8110         showmeans : bool, default: False
8111           If `True`, will toggle rendering of the means.
8112 
8113         showextrema : bool, default: True
8114           If `True`, will toggle rendering of the extrema.
8115 
8116         showmedians : bool, default: False
8117           If `True`, will toggle rendering of the medians.
8118 
8119         quantiles : array-like, default: None
8120           If not None, set a list of floats in interval [0, 1] for each violin,
8121           which stands for the quantiles that will be rendered for that
8122           violin.
8123 
8124         points : int, default: 100
8125           Defines the number of points to evaluate each of the
8126           gaussian kernel density estimations at.
8127 
8128         bw_method : str, scalar or callable, optional
8129           The method used to calculate the estimator bandwidth.  This can be
8130           'scott', 'silverman', a scalar constant or a callable.  If a
8131           scalar, this will be used directly as `kde.factor`.  If a
8132           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8133           its only parameter and return a scalar. If None (default), 'scott'
8134           is used.
8135 
8136         data : indexable object, optional
8137             DATA_PARAMETER_PLACEHOLDER
8138 
8139         Returns
8140         -------
8141         dict
8142           A dictionary mapping each component of the violinplot to a
8143           list of the corresponding collection instances created. The
8144           dictionary has the following keys:
8145 
8146           - ``bodies``: A list of the `~.collections.PolyCollection`
8147             instances containing the filled area of each violin.
8148 
8149           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8150             the mean values of each of the violin's distribution.
8151 
8152           - ``cmins``: A `~.collections.LineCollection` instance that marks
8153             the bottom of each violin's distribution.
8154 
8155           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8156             the top of each violin's distribution.
8157 
8158           - ``cbars``: A `~.collections.LineCollection` instance that marks
8159             the centers of each violin's distribution.
8160 
8161           - ``cmedians``: A `~.collections.LineCollection` instance that
8162             marks the median values of each of the violin's distribution.
8163 
8164           - ``cquantiles``: A `~.collections.LineCollection` instance created
8165             to identify the quantile values of each of the violin's
8166             distribution.
8167 
8168         """
8169 
8170         def _kde_method(X, coords):
8171             # Unpack in case of e.g. Pandas or xarray object
8172             X = cbook._unpack_to_numpy(X)
8173             # fallback gracefully if the vector contains only one value
8174             if np.all(X[0] == X):
8175                 return (X[0] == coords).astype(float)
8176             kde = mlab.GaussianKDE(X, bw_method)
8177             return kde.evaluate(coords)
8178 
8179         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8180                                      quantiles=quantiles)
8181         return self.violin(vpstats, positions=positions, vert=vert,
8182                            widths=widths, showmeans=showmeans,
8183                            showextrema=showextrema, showmedians=showmedians)
8184 
8185     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8186                showmeans=False, showextrema=True, showmedians=False):
8187         """
8188         Drawing function for violin plots.
8189 
8190         Draw a violin plot for each column of *vpstats*. Each filled area
8191         extends to represent the entire data range, with optional lines at the
8192         mean, the median, the minimum, the maximum, and the quantiles values.
8193 
8194         Parameters
8195         ----------
8196         vpstats : list of dicts
8197           A list of dictionaries containing stats for each violin plot.
8198           Required keys are:
8199 
8200           - ``coords``: A list of scalars containing the coordinates that
8201             the violin's kernel density estimate were evaluated at.
8202 
8203           - ``vals``: A list of scalars containing the values of the
8204             kernel density estimate at each of the coordinates given
8205             in *coords*.
8206 
8207           - ``mean``: The mean value for this violin's dataset.
8208 
8209           - ``median``: The median value for this violin's dataset.
8210 
8211           - ``min``: The minimum value for this violin's dataset.
8212 
8213           - ``max``: The maximum value for this violin's dataset.
8214 
8215           Optional keys are:
8216 
8217           - ``quantiles``: A list of scalars containing the quantile values
8218             for this violin's dataset.
8219 
8220         positions : array-like, default: [1, 2, ..., n]
8221           The positions of the violins. The ticks and limits are
8222           automatically set to match the positions.
8223 
8224         vert : bool, default: True.
8225           If true, plots the violins vertically.
8226           Otherwise, plots the violins horizontally.
8227 
8228         widths : array-like, default: 0.5
8229           Either a scalar or a vector that sets the maximal width of
8230           each violin. The default is 0.5, which uses about half of the
8231           available horizontal space.
8232 
8233         showmeans : bool, default: False
8234           If true, will toggle rendering of the means.
8235 
8236         showextrema : bool, default: True
8237           If true, will toggle rendering of the extrema.
8238 
8239         showmedians : bool, default: False
8240           If true, will toggle rendering of the medians.
8241 
8242         Returns
8243         -------
8244         dict
8245           A dictionary mapping each component of the violinplot to a
8246           list of the corresponding collection instances created. The
8247           dictionary has the following keys:
8248 
8249           - ``bodies``: A list of the `~.collections.PolyCollection`
8250             instances containing the filled area of each violin.
8251 
8252           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8253             the mean values of each of the violin's distribution.
8254 
8255           - ``cmins``: A `~.collections.LineCollection` instance that marks
8256             the bottom of each violin's distribution.
8257 
8258           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8259             the top of each violin's distribution.
8260 
8261           - ``cbars``: A `~.collections.LineCollection` instance that marks
8262             the centers of each violin's distribution.
8263 
8264           - ``cmedians``: A `~.collections.LineCollection` instance that
8265             marks the median values of each of the violin's distribution.
8266 
8267           - ``cquantiles``: A `~.collections.LineCollection` instance created
8268             to identify the quantiles values of each of the violin's
8269             distribution.
8270         """
8271 
8272         # Statistical quantities to be plotted on the violins
8273         means = []
8274         mins = []
8275         maxes = []
8276         medians = []
8277         quantiles = []
8278 
8279         qlens = []  # Number of quantiles in each dataset.
8280 
8281         artists = {}  # Collections to be returned
8282 
8283         N = len(vpstats)
8284         datashape_message = ("List of violinplot statistics and `{0}` "
8285                              "values must have the same length")
8286 
8287         # Validate positions
8288         if positions is None:
8289             positions = range(1, N + 1)
8290         elif len(positions) != N:
8291             raise ValueError(datashape_message.format("positions"))
8292 
8293         # Validate widths
8294         if np.isscalar(widths):
8295             widths = [widths] * N
8296         elif len(widths) != N:
8297             raise ValueError(datashape_message.format("widths"))
8298 
8299         # Calculate ranges for statistics lines (shape (2, N)).
8300         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8301 
8302         # Colors.
8303         if mpl.rcParams['_internal.classic_mode']:
8304             fillcolor = 'y'
8305             linecolor = 'r'
8306         else:
8307             fillcolor = linecolor = self._get_lines.get_next_color()
8308 
8309         # Check whether we are rendering vertically or horizontally
8310         if vert:
8311             fill = self.fill_betweenx
8312             perp_lines = functools.partial(self.hlines, colors=linecolor)
8313             par_lines = functools.partial(self.vlines, colors=linecolor)
8314         else:
8315             fill = self.fill_between
8316             perp_lines = functools.partial(self.vlines, colors=linecolor)
8317             par_lines = functools.partial(self.hlines, colors=linecolor)
8318 
8319         # Render violins
8320         bodies = []
8321         for stats, pos, width in zip(vpstats, positions, widths):
8322             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8323             vals = np.array(stats['vals'])
8324             vals = 0.5 * width * vals / vals.max()
8325             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8326                             facecolor=fillcolor, alpha=0.3)]
8327             means.append(stats['mean'])
8328             mins.append(stats['min'])
8329             maxes.append(stats['max'])
8330             medians.append(stats['median'])
8331             q = stats.get('quantiles')  # a list of floats, or None
8332             if q is None:
8333                 q = []
8334             quantiles.extend(q)
8335             qlens.append(len(q))
8336         artists['bodies'] = bodies
8337 
8338         if showmeans:  # Render means
8339             artists['cmeans'] = perp_lines(means, *line_ends)
8340         if showextrema:  # Render extrema
8341             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8342             artists['cmins'] = perp_lines(mins, *line_ends)
8343             artists['cbars'] = par_lines(positions, mins, maxes)
8344         if showmedians:  # Render medians
8345             artists['cmedians'] = perp_lines(medians, *line_ends)
8346         if quantiles:  # Render quantiles: each width is repeated qlen times.
8347             artists['cquantiles'] = perp_lines(
8348                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8349 
8350         return artists
8351 
8352     # Methods that are entirely implemented in other modules.
8353 
8354     table = mtable.table
8355 
8356     # args can be either Y or y1, y2, ... and all should be replaced
8357     stackplot = _preprocess_data()(mstack.stackplot)
8358 
8359     streamplot = _preprocess_data(
8360         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8361 
8362     tricontour = mtri.tricontour
8363     tricontourf = mtri.tricontourf
8364     tripcolor = mtri.tripcolor
8365     triplot = mtri.triplot
8366 
8367     def _get_aspect_ratio(self):
8368         """
8369         Convenience method to calculate the aspect ratio of the axes in
8370         the display coordinate system.
8371         """
8372         figure_size = self.get_figure().get_size_inches()
8373         ll, ur = self.get_position() * figure_size
8374         width, height = ur - ll
8375         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:43:19.567 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/colors.py</file>
<class>None</class>
<method>to_rgba</method>
<code>
266 def to_rgba(c, alpha=None):
267     """
268     Convert *c* to an RGBA color.
269 
270     Parameters
271     ----------
272     c : Matplotlib color or ``np.ma.masked``
273 
274     alpha : float, optional
275         If *alpha* is given, force the alpha value of the returned RGBA tuple
276         to *alpha*.
277 
278         If None, the alpha value from *c* is used. If *c* does not have an
279         alpha channel, then alpha defaults to 1.
280 
281         *alpha* is ignored for the color value ``"none"`` (case-insensitive),
282         which always maps to ``(0, 0, 0, 0)``.
283 
284     Returns
285     -------
286     tuple
287         Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,
288         alpha) can assume values between 0 and 1.
289     """
290     # Special-case nth color syntax because it should not be cached.
291     if _is_nth_color(c):
292         prop_cycler = mpl.rcParams['axes.prop_cycle']
293         colors = prop_cycler.by_key().get('color', ['k'])
294         c = colors[int(c[1:]) % len(colors)]
295     try:
296         rgba = _colors_full_map.cache[c, alpha]
297     except (KeyError, TypeError):  # Not in cache, or unhashable.
298         rgba = None
299     if rgba is None:  # Suppress exception chaining of cache lookup failure.
300         rgba = _to_rgba_no_colorcycle(c, alpha)
301         try:
302             _colors_full_map.cache[c, alpha] = rgba
303         except TypeError:
304             pass
305     return rgba

</code><intended_behavior>The method should include a more explicit handling or normalization of NaN values to ensure consistent behavior across different inputs. Specifically, it should ensure that when a color value (input) is entirely NaN, it is treated the same way as when only some of the values are NaN, possibly by setting a default behavior that does not raise warnings or errors unexpectedly. This involves checking inputs for being all NaN and deciding how to represent them as RGBA values without causing numpy or matplotlib internal functions to emit warnings.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>_upcast_err</method>
<code>
3468         def _upcast_err(err):
3469             """
3470             Safely handle tuple of containers that carry units.
3471 
3472             This function covers the case where the input to the xerr/yerr is a
3473             length 2 tuple of equal length ndarray-subclasses that carry the
3474             unit information in the container.
3475 
3476             If we have a tuple of nested numpy array (subclasses), we defer
3477             coercing the units to be consistent to the underlying unit
3478             library (and implicitly the broadcasting).
3479 
3480             Otherwise, fallback to casting to an object array.
3481             """
3482 
3483             if (
3484                     # make sure it is not a scalar
3485                     np.iterable(err) and
3486                     # and it is not empty
3487                     len(err) > 0 and
3488                     # and the first element is an array sub-class use
3489                     # safe_first_element because getitem is index-first not
3490                     # location first on pandas objects so err[0] almost always
3491                     # fails.
3492                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3493             ):
3494                 # Get the type of the first element
3495                 atype = type(cbook._safe_first_finite(err))
3496                 # Promote the outer container to match the inner container
3497                 if atype is np.ndarray:
3498                     # Converts using np.asarray, because data cannot
3499                     # be directly passed to init of np.ndarray
3500                     return np.asarray(err, dtype=object)
3501                 # If atype is not np.ndarray, directly pass data to init.
3502                 # This works for types such as unyts and astropy units
3503                 return atype(err)
3504             # Otherwise wrap it in an object array
3505             return np.asarray(err, dtype=object)

</code><intended_behavior>This method needs to handle the scenario where all error values (`yerr` or `xerr`) are NaN, without raising a `StopIteration` exception. Instead of attempting to find a first non-NaN value directly (which fails for all-NaN inputs), the method could first check if the iterable contains only NaN values and handle this case appropriately. For instance, it could default to treating the input as if no error was specified or represent the error in a consistent manner that does not depend on finding a non-NaN value. This way, the method preserves functionality for valid inputs while gracefully managing edge cases involving NaN values.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119             A dictionary controlling the appearance of the title text,
120             the default *fontdict* is::
121 
122                {'fontsize': rcParams['axes.titlesize'],
123                 'fontweight': rcParams['axes.titleweight'],
124                 'color': rcParams['axes.titlecolor'],
125                 'verticalalignment': 'baseline',
126                 'horizontalalignment': loc}
127 
128         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
129             Which title to set.
130 
131         y : float, default: :rc:`axes.titley`
132             Vertical Axes location for the title (1.0 is the top).  If
133             None (the default) and :rc:`axes.titley` is also None, y is
134             determined automatically to avoid decorators on the Axes.
135 
136         pad : float, default: :rc:`axes.titlepad`
137             The offset of the title from the top of the Axes, in points.
138 
139         Returns
140         -------
141         `.Text`
142             The matplotlib text instance representing the title
143 
144         Other Parameters
145         ----------------
146         **kwargs : `.Text` properties
147             Other keyword arguments are text properties, see `.Text` for a list
148             of valid text properties.
149         """
150         if loc is None:
151             loc = mpl.rcParams['axes.titlelocation']
152 
153         if y is None:
154             y = mpl.rcParams['axes.titley']
155         if y is None:
156             y = 1.0
157         else:
158             self._autotitlepos = False
159         kwargs['y'] = y
160 
161         titles = {'left': self._left_title,
162                   'center': self.title,
163                   'right': self._right_title}
164         title = _api.check_getitem(titles, loc=loc.lower())
165         default = {
166             'fontsize': mpl.rcParams['axes.titlesize'],
167             'fontweight': mpl.rcParams['axes.titleweight'],
168             'verticalalignment': 'baseline',
169             'horizontalalignment': loc.lower()}
170         titlecolor = mpl.rcParams['axes.titlecolor']
171         if not cbook._str_lower_equal(titlecolor, 'auto'):
172             default["color"] = titlecolor
173         if pad is None:
174             pad = mpl.rcParams['axes.titlepad']
175         self._set_title_offset_trans(float(pad))
176         title.set_text(label)
177         title.update(default)
178         if fontdict is not None:
179             title.update(fontdict)
180         title._internal_update(kwargs)
181         return title
182 
183     def get_legend_handles_labels(self, legend_handler_map=None):
184         """
185         Return handles and labels for legend
186 
187         ``ax.legend()`` is equivalent to ::
188 
189           h, l = ax.get_legend_handles_labels()
190           ax.legend(h, l)
191         """
192         # pass through to legend.
193         handles, labels = mlegend._get_legend_handles_labels(
194             [self], legend_handler_map)
195         return handles, labels
196 
197     @_docstring.dedent_interpd
198     def legend(self, *args, **kwargs):
199         """
200         Place a legend on the Axes.
201 
202         Call signatures::
203 
204             legend()
205             legend(handles, labels)
206             legend(handles=handles)
207             legend(labels)
208 
209         The call signatures correspond to the following different ways to use
210         this method:
211 
212         **1. Automatic detection of elements to be shown in the legend**
213 
214         The elements to be added to the legend are automatically determined,
215         when you do not pass in any extra arguments.
216 
217         In this case, the labels are taken from the artist. You can specify
218         them either at artist creation or by calling the
219         :meth:`~.Artist.set_label` method on the artist::
220 
221             ax.plot([1, 2, 3], label='Inline label')
222             ax.legend()
223 
224         or::
225 
226             line, = ax.plot([1, 2, 3])
227             line.set_label('Label via method')
228             ax.legend()
229 
230         .. note::
231             Specific artists can be excluded from the automatic legend element
232             selection by using a label starting with an underscore, "_".
233             A string starting with an underscore is the default label for all
234             artists, so calling `.Axes.legend` without any arguments and
235             without setting the labels manually will result in no legend being
236             drawn.
237 
238 
239         **2. Explicitly listing the artists and labels in the legend**
240 
241         For full control of which artists have a legend entry, it is possible
242         to pass an iterable of legend artists followed by an iterable of
243         legend labels respectively::
244 
245             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
246 
247 
248         **3. Explicitly listing the artists in the legend**
249 
250         This is similar to 2, but the labels are taken from the artists'
251         label properties. Example::
252 
253             line1, = ax.plot([1, 2, 3], label='label1')
254             line2, = ax.plot([1, 2, 3], label='label2')
255             ax.legend(handles=[line1, line2])
256 
257 
258         **4. Labeling existing plot elements**
259 
260         .. admonition:: Discouraged
261 
262             This call signature is discouraged, because the relation between
263             plot elements and labels is only implicit by their order and can
264             easily be mixed up.
265 
266         To make a legend for all artists on an Axes, call this function with
267         an iterable of strings, one for each legend item. For example::
268 
269             ax.plot([1, 2, 3])
270             ax.plot([5, 6, 7])
271             ax.legend(['First line', 'Second line'])
272 
273 
274         Parameters
275         ----------
276         handles : sequence of `.Artist`, optional
277             A list of Artists (lines, patches) to be added to the legend.
278             Use this together with *labels*, if you need full control on what
279             is shown in the legend and the automatic mechanism described above
280             is not sufficient.
281 
282             The length of handles and labels should be the same in this
283             case. If they are not, they are truncated to the smaller length.
284 
285         labels : list of str, optional
286             A list of labels to show next to the artists.
287             Use this together with *handles*, if you need full control on what
288             is shown in the legend and the automatic mechanism described above
289             is not sufficient.
290 
291         Returns
292         -------
293         `~matplotlib.legend.Legend`
294 
295         Other Parameters
296         ----------------
297         %(_legend_kw_axes)s
298 
299         See Also
300         --------
301         .Figure.legend
302 
303         Notes
304         -----
305         Some artists are not supported by this function.  See
306         :ref:`legend_guide` for details.
307 
308         Examples
309         --------
310         .. plot:: gallery/text_labels_and_annotations/legend.py
311         """
312         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
313                 [self],
314                 *args,
315                 **kwargs)
316         if len(extra_args):
317             _api.nargs_error('legend', '0-2', len(args))
318         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
319         self.legend_._remove_method = self._remove_legend
320         return self.legend_
321 
322     def _remove_legend(self, legend):
323         self.legend_ = None
324 
325     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
326         """
327         Add a child inset Axes to this existing Axes.
328 
329         Warnings
330         --------
331         This method is experimental as of 3.0, and the API may change.
332 
333         Parameters
334         ----------
335         bounds : [x0, y0, width, height]
336             Lower-left corner of inset Axes, and its width and height.
337 
338         transform : `.Transform`
339             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
340             Axes-relative coordinates.
341 
342         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
343 'polar', 'rectilinear', str}, optional
344             The projection type of the inset `~.axes.Axes`. *str* is the name
345             of a custom projection, see `~matplotlib.projections`. The default
346             None results in a 'rectilinear' projection.
347 
348         polar : bool, default: False
349             If True, equivalent to projection='polar'.
350 
351         axes_class : subclass type of `~.axes.Axes`, optional
352             The `.axes.Axes` subclass that is instantiated.  This parameter
353             is incompatible with *projection* and *polar*.  See
354             :ref:`axisartist_users-guide-index` for examples.
355 
356         zorder : number
357             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
358             to change whether it is above or below data plotted on the
359             parent Axes.
360 
361         **kwargs
362             Other keyword arguments are passed on to the inset Axes class.
363 
364         Returns
365         -------
366         ax
367             The created `~.axes.Axes` instance.
368 
369         Examples
370         --------
371         This example makes two inset Axes, the first is in Axes-relative
372         coordinates, and the second in data-coordinates::
373 
374             fig, ax = plt.subplots()
375             ax.plot(range(10))
376             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
377             axin2 = ax.inset_axes(
378                     [5, 7, 2.3, 2.3], transform=ax.transData)
379 
380         """
381         if transform is None:
382             transform = self.transAxes
383         kwargs.setdefault('label', 'inset_axes')
384 
385         # This puts the rectangle into figure-relative coordinates.
386         inset_locator = _TransformedBoundsLocator(bounds, transform)
387         bounds = inset_locator(self, None).bounds
388         projection_class, pkw = self.figure._process_projection_requirements(
389                 bounds, **kwargs)
390         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
391 
392         # this locator lets the axes move if in data coordinates.
393         # it gets called in `ax.apply_aspect() (of all places)
394         inset_ax.set_axes_locator(inset_locator)
395 
396         self.add_child_axes(inset_ax)
397 
398         return inset_ax
399 
400     @_docstring.dedent_interpd
401     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
402                        facecolor='none', edgecolor='0.5', alpha=0.5,
403                        zorder=4.99, **kwargs):
404         """
405         Add an inset indicator to the Axes.  This is a rectangle on the plot
406         at the position indicated by *bounds* that optionally has lines that
407         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
408 
409         Warnings
410         --------
411         This method is experimental as of 3.0, and the API may change.
412 
413         Parameters
414         ----------
415         bounds : [x0, y0, width, height]
416             Lower-left corner of rectangle to be marked, and its width
417             and height.
418 
419         inset_ax : `.Axes`
420             An optional inset Axes to draw connecting lines to.  Two lines are
421             drawn connecting the indicator box to the inset Axes on corners
422             chosen so as to not overlap with the indicator box.
423 
424         transform : `.Transform`
425             Transform for the rectangle coordinates. Defaults to
426             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
427             coordinates.
428 
429         facecolor : color, default: 'none'
430             Facecolor of the rectangle.
431 
432         edgecolor : color, default: '0.5'
433             Color of the rectangle and color of the connecting lines.
434 
435         alpha : float, default: 0.5
436             Transparency of the rectangle and connector lines.
437 
438         zorder : float, default: 4.99
439             Drawing order of the rectangle and connector lines.  The default,
440             4.99, is just below the default level of inset Axes.
441 
442         **kwargs
443             Other keyword arguments are passed on to the `.Rectangle` patch:
444 
445             %(Rectangle:kwdoc)s
446 
447         Returns
448         -------
449         rectangle_patch : `.patches.Rectangle`
450              The indicator frame.
451 
452         connector_lines : 4-tuple of `.patches.ConnectionPatch`
453             The four connector lines connecting to (lower_left, upper_left,
454             lower_right upper_right) corners of *inset_ax*. Two lines are
455             set with visibility to *False*,  but the user can set the
456             visibility to True if the automatic choice is not deemed correct.
457 
458         """
459         # to make the axes connectors work, we need to apply the aspect to
460         # the parent axes.
461         self.apply_aspect()
462 
463         if transform is None:
464             transform = self.transData
465         kwargs.setdefault('label', '_indicate_inset')
466 
467         x, y, width, height = bounds
468         rectangle_patch = mpatches.Rectangle(
469             (x, y), width, height,
470             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
471             zorder=zorder, transform=transform, **kwargs)
472         self.add_patch(rectangle_patch)
473 
474         connects = []
475 
476         if inset_ax is not None:
477             # connect the inset_axes to the rectangle
478             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
479                 # inset_ax positions are in axes coordinates
480                 # The 0, 1 values define the four edges if the inset_ax
481                 # lower_left, upper_left, lower_right upper_right.
482                 ex, ey = xy_inset_ax
483                 if self.xaxis.get_inverted():
484                     ex = 1 - ex
485                 if self.yaxis.get_inverted():
486                     ey = 1 - ey
487                 xy_data = x + ex * width, y + ey * height
488                 p = mpatches.ConnectionPatch(
489                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
490                     xyB=xy_data, coordsB=self.transData,
491                     arrowstyle="-", zorder=zorder,
492                     edgecolor=edgecolor, alpha=alpha)
493                 connects.append(p)
494                 self.add_patch(p)
495 
496             # decide which two of the lines to keep visible....
497             pos = inset_ax.get_position()
498             bboxins = pos.transformed(self.figure.transSubfigure)
499             rectbbox = mtransforms.Bbox.from_bounds(
500                 *bounds
501             ).transformed(transform)
502             x0 = rectbbox.x0 < bboxins.x0
503             x1 = rectbbox.x1 < bboxins.x1
504             y0 = rectbbox.y0 < bboxins.y0
505             y1 = rectbbox.y1 < bboxins.y1
506             connects[0].set_visible(x0 ^ y0)
507             connects[1].set_visible(x0 == y1)
508             connects[2].set_visible(x1 == y0)
509             connects[3].set_visible(x1 ^ y1)
510 
511         return rectangle_patch, tuple(connects) if connects else None
512 
513     def indicate_inset_zoom(self, inset_ax, **kwargs):
514         """
515         Add an inset indicator rectangle to the Axes based on the axis
516         limits for an *inset_ax* and draw connectors between *inset_ax*
517         and the rectangle.
518 
519         Warnings
520         --------
521         This method is experimental as of 3.0, and the API may change.
522 
523         Parameters
524         ----------
525         inset_ax : `.Axes`
526             Inset Axes to draw connecting lines to.  Two lines are
527             drawn connecting the indicator box to the inset Axes on corners
528             chosen so as to not overlap with the indicator box.
529 
530         **kwargs
531             Other keyword arguments are passed on to `.Axes.indicate_inset`
532 
533         Returns
534         -------
535         rectangle_patch : `.patches.Rectangle`
536              Rectangle artist.
537 
538         connector_lines : 4-tuple of `.patches.ConnectionPatch`
539             Each of four connector lines coming from the rectangle drawn on
540             this axis, in the order lower left, upper left, lower right,
541             upper right.
542             Two are set with visibility to *False*,  but the user can
543             set the visibility to *True* if the automatic choice is not deemed
544             correct.
545         """
546 
547         xlim = inset_ax.get_xlim()
548         ylim = inset_ax.get_ylim()
549         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
550         return self.indicate_inset(rect, inset_ax, **kwargs)
551 
552     @_docstring.dedent_interpd
553     def secondary_xaxis(self, location, *, functions=None, **kwargs):
554         """
555         Add a second x-axis to this `~.axes.Axes`.
556 
557         For example if we want to have a second scale for the data plotted on
558         the xaxis.
559 
560         %(_secax_docstring)s
561 
562         Examples
563         --------
564         The main axis shows frequency, and the secondary axis shows period.
565 
566         .. plot::
567 
568             fig, ax = plt.subplots()
569             ax.loglog(range(1, 360, 5), range(1, 360, 5))
570             ax.set_xlabel('frequency [Hz]')
571 
572             def invert(x):
573                 # 1/x with special treatment of x == 0
574                 x = np.array(x).astype(float)
575                 near_zero = np.isclose(x, 0)
576                 x[near_zero] = np.inf
577                 x[~near_zero] = 1 / x[~near_zero]
578                 return x
579 
580             # the inverse of 1/x is itself
581             secax = ax.secondary_xaxis('top', functions=(invert, invert))
582             secax.set_xlabel('Period [s]')
583             plt.show()
584         """
585         if location in ['top', 'bottom'] or isinstance(location, Real):
586             secondary_ax = SecondaryAxis(self, 'x', location, functions,
587                                          **kwargs)
588             self.add_child_axes(secondary_ax)
589             return secondary_ax
590         else:
591             raise ValueError('secondary_xaxis location must be either '
592                              'a float or "top"/"bottom"')
593 
594     @_docstring.dedent_interpd
595     def secondary_yaxis(self, location, *, functions=None, **kwargs):
596         """
597         Add a second y-axis to this `~.axes.Axes`.
598 
599         For example if we want to have a second scale for the data plotted on
600         the yaxis.
601 
602         %(_secax_docstring)s
603 
604         Examples
605         --------
606         Add a secondary Axes that converts from radians to degrees
607 
608         .. plot::
609 
610             fig, ax = plt.subplots()
611             ax.plot(range(1, 360, 5), range(1, 360, 5))
612             ax.set_ylabel('degrees')
613             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
614                                                            np.rad2deg))
615             secax.set_ylabel('radians')
616         """
617         if location in ['left', 'right'] or isinstance(location, Real):
618             secondary_ax = SecondaryAxis(self, 'y', location,
619                                          functions, **kwargs)
620             self.add_child_axes(secondary_ax)
621             return secondary_ax
622         else:
623             raise ValueError('secondary_yaxis location must be either '
624                              'a float or "left"/"right"')
625 
626     @_docstring.dedent_interpd
627     def text(self, x, y, s, fontdict=None, **kwargs):
628         """
629         Add text to the Axes.
630 
631         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
632 
633         Parameters
634         ----------
635         x, y : float
636             The position to place the text. By default, this is in data
637             coordinates. The coordinate system can be changed using the
638             *transform* parameter.
639 
640         s : str
641             The text.
642 
643         fontdict : dict, default: None
644             A dictionary to override the default text properties. If fontdict
645             is None, the defaults are determined by `.rcParams`.
646 
647         Returns
648         -------
649         `.Text`
650             The created `.Text` instance.
651 
652         Other Parameters
653         ----------------
654         **kwargs : `~matplotlib.text.Text` properties.
655             Other miscellaneous text parameters.
656 
657             %(Text:kwdoc)s
658 
659         Examples
660         --------
661         Individual keyword arguments can be used to override any given
662         parameter::
663 
664             >>> text(x, y, s, fontsize=12)
665 
666         The default transform specifies that text is in data coords,
667         alternatively, you can specify text in axis coords ((0, 0) is
668         lower-left and (1, 1) is upper-right).  The example below places
669         text in the center of the Axes::
670 
671             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
672             ...      verticalalignment='center', transform=ax.transAxes)
673 
674         You can put a rectangular box around the text instance (e.g., to
675         set a background color) by using the keyword *bbox*.  *bbox* is
676         a dictionary of `~matplotlib.patches.Rectangle`
677         properties.  For example::
678 
679             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
680         """
681         effective_kwargs = {
682             'verticalalignment': 'baseline',
683             'horizontalalignment': 'left',
684             'transform': self.transData,
685             'clip_on': False,
686             **(fontdict if fontdict is not None else {}),
687             **kwargs,
688         }
689         t = mtext.Text(x, y, text=s, **effective_kwargs)
690         if t.get_clip_path() is None:
691             t.set_clip_path(self.patch)
692         self._add_text(t)
693         return t
694 
695     @_docstring.dedent_interpd
696     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
697                  arrowprops=None, annotation_clip=None, **kwargs):
698         # Signature must match Annotation. This is verified in
699         # test_annotate_signature().
700         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
701                              textcoords=textcoords, arrowprops=arrowprops,
702                              annotation_clip=annotation_clip, **kwargs)
703         a.set_transform(mtransforms.IdentityTransform())
704         if kwargs.get('clip_on', False) and a.get_clip_path() is None:
705             a.set_clip_path(self.patch)
706         self._add_text(a)
707         return a
708     annotate.__doc__ = mtext.Annotation.__init__.__doc__
709     #### Lines and spans
710 
711     @_docstring.dedent_interpd
712     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
713         """
714         Add a horizontal line across the Axes.
715 
716         Parameters
717         ----------
718         y : float, default: 0
719             y position in data coordinates of the horizontal line.
720 
721         xmin : float, default: 0
722             Should be between 0 and 1, 0 being the far left of the plot, 1 the
723             far right of the plot.
724 
725         xmax : float, default: 1
726             Should be between 0 and 1, 0 being the far left of the plot, 1 the
727             far right of the plot.
728 
729         Returns
730         -------
731         `~matplotlib.lines.Line2D`
732 
733         Other Parameters
734         ----------------
735         **kwargs
736             Valid keyword arguments are `.Line2D` properties, except for
737             'transform':
738 
739             %(Line2D:kwdoc)s
740 
741         See Also
742         --------
743         hlines : Add horizontal lines in data coordinates.
744         axhspan : Add a horizontal span (rectangle) across the axis.
745         axline : Add a line with an arbitrary slope.
746 
747         Examples
748         --------
749         * draw a thick red hline at 'y' = 0 that spans the xrange::
750 
751             >>> axhline(linewidth=4, color='r')
752 
753         * draw a default hline at 'y' = 1 that spans the xrange::
754 
755             >>> axhline(y=1)
756 
757         * draw a default hline at 'y' = .5 that spans the middle half of
758           the xrange::
759 
760             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
761         """
762         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
763         if "transform" in kwargs:
764             raise ValueError("'transform' is not allowed as a keyword "
765                              "argument; axhline generates its own transform.")
766         ymin, ymax = self.get_ybound()
767 
768         # Strip away the units for comparison with non-unitized bounds.
769         yy, = self._process_unit_info([("y", y)], kwargs)
770         scaley = (yy < ymin) or (yy > ymax)
771 
772         trans = self.get_yaxis_transform(which='grid')
773         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
774         self.add_line(l)
775         if scaley:
776             self._request_autoscale_view("y")
777         return l
778 
779     @_docstring.dedent_interpd
780     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
781         """
782         Add a vertical line across the Axes.
783 
784         Parameters
785         ----------
786         x : float, default: 0
787             x position in data coordinates of the vertical line.
788 
789         ymin : float, default: 0
790             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
791             top of the plot.
792 
793         ymax : float, default: 1
794             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
795             top of the plot.
796 
797         Returns
798         -------
799         `~matplotlib.lines.Line2D`
800 
801         Other Parameters
802         ----------------
803         **kwargs
804             Valid keyword arguments are `.Line2D` properties, except for
805             'transform':
806 
807             %(Line2D:kwdoc)s
808 
809         See Also
810         --------
811         vlines : Add vertical lines in data coordinates.
812         axvspan : Add a vertical span (rectangle) across the axis.
813         axline : Add a line with an arbitrary slope.
814 
815         Examples
816         --------
817         * draw a thick red vline at *x* = 0 that spans the yrange::
818 
819             >>> axvline(linewidth=4, color='r')
820 
821         * draw a default vline at *x* = 1 that spans the yrange::
822 
823             >>> axvline(x=1)
824 
825         * draw a default vline at *x* = .5 that spans the middle half of
826           the yrange::
827 
828             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
829         """
830         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
831         if "transform" in kwargs:
832             raise ValueError("'transform' is not allowed as a keyword "
833                              "argument; axvline generates its own transform.")
834         xmin, xmax = self.get_xbound()
835 
836         # Strip away the units for comparison with non-unitized bounds.
837         xx, = self._process_unit_info([("x", x)], kwargs)
838         scalex = (xx < xmin) or (xx > xmax)
839 
840         trans = self.get_xaxis_transform(which='grid')
841         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
842         self.add_line(l)
843         if scalex:
844             self._request_autoscale_view("x")
845         return l
846 
847     @staticmethod
848     def _check_no_units(vals, names):
849         # Helper method to check that vals are not unitized
850         for val, name in zip(vals, names):
851             if not munits._is_natively_supported(val):
852                 raise ValueError(f"{name} must be a single scalar value, "
853                                  f"but got {val}")
854 
855     @_docstring.dedent_interpd
856     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
857         """
858         Add an infinitely long straight line.
859 
860         The line can be defined either by two points *xy1* and *xy2*, or
861         by one point *xy1* and a *slope*.
862 
863         This draws a straight line "on the screen", regardless of the x and y
864         scales, and is thus also suitable for drawing exponential decays in
865         semilog plots, power laws in loglog plots, etc. However, *slope*
866         should only be used with linear scales; It has no clear meaning for
867         all other scales, and thus the behavior is undefined. Please specify
868         the line using the points *xy1*, *xy2* for non-linear scales.
869 
870         The *transform* keyword argument only applies to the points *xy1*,
871         *xy2*. The *slope* (if given) is always in data coordinates. This can
872         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
873         slope.
874 
875         Parameters
876         ----------
877         xy1, xy2 : (float, float)
878             Points for the line to pass through.
879             Either *xy2* or *slope* has to be given.
880         slope : float, optional
881             The slope of the line. Either *xy2* or *slope* has to be given.
882 
883         Returns
884         -------
885         `.Line2D`
886 
887         Other Parameters
888         ----------------
889         **kwargs
890             Valid kwargs are `.Line2D` properties
891 
892             %(Line2D:kwdoc)s
893 
894         See Also
895         --------
896         axhline : for horizontal lines
897         axvline : for vertical lines
898 
899         Examples
900         --------
901         Draw a thick red line passing through (0, 0) and (1, 1)::
902 
903             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
904         """
905         if slope is not None and (self.get_xscale() != 'linear' or
906                                   self.get_yscale() != 'linear'):
907             raise TypeError("'slope' cannot be used with non-linear scales")
908 
909         datalim = [xy1] if xy2 is None else [xy1, xy2]
910         if "transform" in kwargs:
911             # if a transform is passed (i.e. line points not in data space),
912             # data limits should not be adjusted.
913             datalim = []
914 
915         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
916         # Like add_line, but correctly handling data limits.
917         self._set_artist_props(line)
918         if line.get_clip_path() is None:
919             line.set_clip_path(self.patch)
920         if not line.get_label():
921             line.set_label(f"_child{len(self._children)}")
922         self._children.append(line)
923         line._remove_method = self._children.remove
924         self.update_datalim(datalim)
925 
926         self._request_autoscale_view()
927         return line
928 
929     @_docstring.dedent_interpd
930     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
931         """
932         Add a horizontal span (rectangle) across the Axes.
933 
934         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
935         the whole x-axis horizontally.  The x-span can be set using *xmin*
936         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
937         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
938         the limits set by `~.Axes.set_xlim`.
939 
940         Parameters
941         ----------
942         ymin : float
943             Lower y-coordinate of the span, in data units.
944         ymax : float
945             Upper y-coordinate of the span, in data units.
946         xmin : float, default: 0
947             Lower x-coordinate of the span, in x-axis (0-1) units.
948         xmax : float, default: 1
949             Upper x-coordinate of the span, in x-axis (0-1) units.
950 
951         Returns
952         -------
953         `~matplotlib.patches.Polygon`
954             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
955 
956         Other Parameters
957         ----------------
958         **kwargs : `~matplotlib.patches.Polygon` properties
959 
960         %(Polygon:kwdoc)s
961 
962         See Also
963         --------
964         axvspan : Add a vertical span across the Axes.
965         """
966         # Strip units away.
967         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
968         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
969 
970         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
971         p = mpatches.Polygon(verts, **kwargs)
972         p.set_transform(self.get_yaxis_transform(which="grid"))
973         self.add_patch(p)
974         self._request_autoscale_view("y")
975         return p
976 
977     @_docstring.dedent_interpd
978     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
979         """
980         Add a vertical span (rectangle) across the Axes.
981 
982         The rectangle spans from *xmin* to *xmax* horizontally, and, by
983         default, the whole y-axis vertically.  The y-span can be set using
984         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
985         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
986         regardless of the limits set by `~.Axes.set_ylim`.
987 
988         Parameters
989         ----------
990         xmin : float
991             Lower x-coordinate of the span, in data units.
992         xmax : float
993             Upper x-coordinate of the span, in data units.
994         ymin : float, default: 0
995             Lower y-coordinate of the span, in y-axis units (0-1).
996         ymax : float, default: 1
997             Upper y-coordinate of the span, in y-axis units (0-1).
998 
999         Returns
1000         -------
1001         `~matplotlib.patches.Polygon`
1002             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1003 
1004         Other Parameters
1005         ----------------
1006         **kwargs : `~matplotlib.patches.Polygon` properties
1007 
1008         %(Polygon:kwdoc)s
1009 
1010         See Also
1011         --------
1012         axhspan : Add a horizontal span across the Axes.
1013 
1014         Examples
1015         --------
1016         Draw a vertical, green, translucent rectangle from x = 1.25 to
1017         x = 1.55 that spans the yrange of the Axes.
1018 
1019         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1020 
1021         """
1022         # Strip units away.
1023         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1024         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1025 
1026         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1027         p = mpatches.Polygon(verts, **kwargs)
1028         p.set_transform(self.get_xaxis_transform(which="grid"))
1029         p.get_path()._interpolation_steps = 100
1030         self.add_patch(p)
1031         self._request_autoscale_view("x")
1032         return p
1033 
1034     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1035                       label_namer="y")
1036     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1037                label='', **kwargs):
1038         """
1039         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1040 
1041         Parameters
1042         ----------
1043         y : float or array-like
1044             y-indexes where to plot the lines.
1045 
1046         xmin, xmax : float or array-like
1047             Respective beginning and end of each line. If scalars are
1048             provided, all lines will have the same length.
1049 
1050         colors : list of colors, default: :rc:`lines.color`
1051 
1052         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1053 
1054         label : str, default: ''
1055 
1056         Returns
1057         -------
1058         `~matplotlib.collections.LineCollection`
1059 
1060         Other Parameters
1061         ----------------
1062         data : indexable object, optional
1063             DATA_PARAMETER_PLACEHOLDER
1064         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1065 
1066         See Also
1067         --------
1068         vlines : vertical lines
1069         axhline : horizontal line across the Axes
1070         """
1071 
1072         # We do the conversion first since not all unitized data is uniform
1073         xmin, xmax, y = self._process_unit_info(
1074             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1075 
1076         if not np.iterable(y):
1077             y = [y]
1078         if not np.iterable(xmin):
1079             xmin = [xmin]
1080         if not np.iterable(xmax):
1081             xmax = [xmax]
1082 
1083         # Create and combine masked_arrays from input
1084         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1085         y = np.ravel(y)
1086         xmin = np.ravel(xmin)
1087         xmax = np.ravel(xmax)
1088 
1089         masked_verts = np.ma.empty((len(y), 2, 2))
1090         masked_verts[:, 0, 0] = xmin
1091         masked_verts[:, 0, 1] = y
1092         masked_verts[:, 1, 0] = xmax
1093         masked_verts[:, 1, 1] = y
1094 
1095         lines = mcoll.LineCollection(masked_verts, colors=colors,
1096                                      linestyles=linestyles, label=label)
1097         self.add_collection(lines, autolim=False)
1098         lines._internal_update(kwargs)
1099 
1100         if len(y) > 0:
1101             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1102             # the case of y being a masked *object* array (as can be generated
1103             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1104             minx = np.nanmin(masked_verts[..., 0])
1105             maxx = np.nanmax(masked_verts[..., 0])
1106             miny = np.nanmin(masked_verts[..., 1])
1107             maxy = np.nanmax(masked_verts[..., 1])
1108             corners = (minx, miny), (maxx, maxy)
1109             self.update_datalim(corners)
1110             self._request_autoscale_view()
1111 
1112         return lines
1113 
1114     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1115                       label_namer="x")
1116     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1117                label='', **kwargs):
1118         """
1119         Plot vertical lines at each *x* from *ymin* to *ymax*.
1120 
1121         Parameters
1122         ----------
1123         x : float or array-like
1124             x-indexes where to plot the lines.
1125 
1126         ymin, ymax : float or array-like
1127             Respective beginning and end of each line. If scalars are
1128             provided, all lines will have the same length.
1129 
1130         colors : list of colors, default: :rc:`lines.color`
1131 
1132         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1133 
1134         label : str, default: ''
1135 
1136         Returns
1137         -------
1138         `~matplotlib.collections.LineCollection`
1139 
1140         Other Parameters
1141         ----------------
1142         data : indexable object, optional
1143             DATA_PARAMETER_PLACEHOLDER
1144         **kwargs : `~matplotlib.collections.LineCollection` properties.
1145 
1146         See Also
1147         --------
1148         hlines : horizontal lines
1149         axvline : vertical line across the Axes
1150         """
1151 
1152         # We do the conversion first since not all unitized data is uniform
1153         x, ymin, ymax = self._process_unit_info(
1154             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1155 
1156         if not np.iterable(x):
1157             x = [x]
1158         if not np.iterable(ymin):
1159             ymin = [ymin]
1160         if not np.iterable(ymax):
1161             ymax = [ymax]
1162 
1163         # Create and combine masked_arrays from input
1164         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1165         x = np.ravel(x)
1166         ymin = np.ravel(ymin)
1167         ymax = np.ravel(ymax)
1168 
1169         masked_verts = np.ma.empty((len(x), 2, 2))
1170         masked_verts[:, 0, 0] = x
1171         masked_verts[:, 0, 1] = ymin
1172         masked_verts[:, 1, 0] = x
1173         masked_verts[:, 1, 1] = ymax
1174 
1175         lines = mcoll.LineCollection(masked_verts, colors=colors,
1176                                      linestyles=linestyles, label=label)
1177         self.add_collection(lines, autolim=False)
1178         lines._internal_update(kwargs)
1179 
1180         if len(x) > 0:
1181             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1182             # the case of x being a masked *object* array (as can be generated
1183             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1184             minx = np.nanmin(masked_verts[..., 0])
1185             maxx = np.nanmax(masked_verts[..., 0])
1186             miny = np.nanmin(masked_verts[..., 1])
1187             maxy = np.nanmax(masked_verts[..., 1])
1188             corners = (minx, miny), (maxx, maxy)
1189             self.update_datalim(corners)
1190             self._request_autoscale_view()
1191 
1192         return lines
1193 
1194     @_preprocess_data(replace_names=["positions", "lineoffsets",
1195                                      "linelengths", "linewidths",
1196                                      "colors", "linestyles"])
1197     @_docstring.dedent_interpd
1198     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1199                   linelengths=1, linewidths=None, colors=None, alpha=None,
1200                   linestyles='solid', **kwargs):
1201         """
1202         Plot identical parallel lines at the given positions.
1203 
1204         This type of plot is commonly used in neuroscience for representing
1205         neural events, where it is usually called a spike raster, dot raster,
1206         or raster plot.
1207 
1208         However, it is useful in any situation where you wish to show the
1209         timing or position of multiple sets of discrete events, such as the
1210         arrival times of people to a business on each day of the month or the
1211         date of hurricanes each year of the last century.
1212 
1213         Parameters
1214         ----------
1215         positions : array-like or list of array-like
1216             A 1D array-like defines the positions of one sequence of events.
1217 
1218             Multiple groups of events may be passed as a list of array-likes.
1219             Each group can be styled independently by passing lists of values
1220             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1221             *linestyles*.
1222 
1223             Note that *positions* can be a 2D array, but in practice different
1224             event groups usually have different counts so that one will use a
1225             list of different-length arrays rather than a 2D array.
1226 
1227         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1228             The direction of the event sequence:
1229 
1230             - 'horizontal': the events are arranged horizontally.
1231               The indicator lines are vertical.
1232             - 'vertical': the events are arranged vertically.
1233               The indicator lines are horizontal.
1234 
1235         lineoffsets : float or array-like, default: 1
1236             The offset of the center of the lines from the origin, in the
1237             direction orthogonal to *orientation*.
1238 
1239             If *positions* is 2D, this can be a sequence with length matching
1240             the length of *positions*.
1241 
1242         linelengths : float or array-like, default: 1
1243             The total height of the lines (i.e. the lines stretches from
1244             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1245 
1246             If *positions* is 2D, this can be a sequence with length matching
1247             the length of *positions*.
1248 
1249         linewidths : float or array-like, default: :rc:`lines.linewidth`
1250             The line width(s) of the event lines, in points.
1251 
1252             If *positions* is 2D, this can be a sequence with length matching
1253             the length of *positions*.
1254 
1255         colors : color or list of colors, default: :rc:`lines.color`
1256             The color(s) of the event lines.
1257 
1258             If *positions* is 2D, this can be a sequence with length matching
1259             the length of *positions*.
1260 
1261         alpha : float or array-like, default: 1
1262             The alpha blending value(s), between 0 (transparent) and 1
1263             (opaque).
1264 
1265             If *positions* is 2D, this can be a sequence with length matching
1266             the length of *positions*.
1267 
1268         linestyles : str or tuple or list of such values, default: 'solid'
1269             Default is 'solid'. Valid strings are ['solid', 'dashed',
1270             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1271             should be of the form::
1272 
1273                 (offset, onoffseq),
1274 
1275             where *onoffseq* is an even length tuple of on and off ink
1276             in points.
1277 
1278             If *positions* is 2D, this can be a sequence with length matching
1279             the length of *positions*.
1280 
1281         data : indexable object, optional
1282             DATA_PARAMETER_PLACEHOLDER
1283 
1284         **kwargs
1285             Other keyword arguments are line collection properties.  See
1286             `.LineCollection` for a list of the valid properties.
1287 
1288         Returns
1289         -------
1290         list of `.EventCollection`
1291             The `.EventCollection` that were added.
1292 
1293         Notes
1294         -----
1295         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1296         only a single value is given, that value is applied to all lines. If an
1297         array-like is given, it must have the same length as *positions*, and
1298         each value will be applied to the corresponding row of the array.
1299 
1300         Examples
1301         --------
1302         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1303         """
1304 
1305         lineoffsets, linelengths = self._process_unit_info(
1306                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1307 
1308         # fix positions, noting that it can be a list of lists:
1309         if not np.iterable(positions):
1310             positions = [positions]
1311         elif any(np.iterable(position) for position in positions):
1312             positions = [np.asanyarray(position) for position in positions]
1313         else:
1314             positions = [np.asanyarray(positions)]
1315 
1316         if len(positions) == 0:
1317             return []
1318 
1319         poss = []
1320         for position in positions:
1321             poss += self._process_unit_info([("x", position)], kwargs)
1322         positions = poss
1323 
1324         # prevent 'singular' keys from **kwargs dict from overriding the effect
1325         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1326         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1327         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1328         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1329 
1330         if not np.iterable(lineoffsets):
1331             lineoffsets = [lineoffsets]
1332         if not np.iterable(linelengths):
1333             linelengths = [linelengths]
1334         if not np.iterable(linewidths):
1335             linewidths = [linewidths]
1336         if not np.iterable(colors):
1337             colors = [colors]
1338         if not np.iterable(alpha):
1339             alpha = [alpha]
1340         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1341             linestyles = [linestyles]
1342 
1343         lineoffsets = np.asarray(lineoffsets)
1344         linelengths = np.asarray(linelengths)
1345         linewidths = np.asarray(linewidths)
1346 
1347         if len(lineoffsets) == 0:
1348             lineoffsets = [None]
1349         if len(linelengths) == 0:
1350             linelengths = [None]
1351         if len(linewidths) == 0:
1352             lineoffsets = [None]
1353         if len(linewidths) == 0:
1354             lineoffsets = [None]
1355         if len(colors) == 0:
1356             colors = [None]
1357         try:
1358             # Early conversion of the colors into RGBA values to take care
1359             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1360             colors = mcolors.to_rgba_array(colors)
1361         except ValueError:
1362             # Will fail if any element of *colors* is None. But as long
1363             # as len(colors) == 1 or len(positions), the rest of the
1364             # code should process *colors* properly.
1365             pass
1366 
1367         if len(lineoffsets) == 1 and len(positions) != 1:
1368             lineoffsets = np.tile(lineoffsets, len(positions))
1369             lineoffsets[0] = 0
1370             lineoffsets = np.cumsum(lineoffsets)
1371         if len(linelengths) == 1:
1372             linelengths = np.tile(linelengths, len(positions))
1373         if len(linewidths) == 1:
1374             linewidths = np.tile(linewidths, len(positions))
1375         if len(colors) == 1:
1376             colors = list(colors) * len(positions)
1377         if len(alpha) == 1:
1378             alpha = list(alpha) * len(positions)
1379         if len(linestyles) == 1:
1380             linestyles = [linestyles] * len(positions)
1381 
1382         if len(lineoffsets) != len(positions):
1383             raise ValueError('lineoffsets and positions are unequal sized '
1384                              'sequences')
1385         if len(linelengths) != len(positions):
1386             raise ValueError('linelengths and positions are unequal sized '
1387                              'sequences')
1388         if len(linewidths) != len(positions):
1389             raise ValueError('linewidths and positions are unequal sized '
1390                              'sequences')
1391         if len(colors) != len(positions):
1392             raise ValueError('colors and positions are unequal sized '
1393                              'sequences')
1394         if len(alpha) != len(positions):
1395             raise ValueError('alpha and positions are unequal sized '
1396                              'sequences')
1397         if len(linestyles) != len(positions):
1398             raise ValueError('linestyles and positions are unequal sized '
1399                              'sequences')
1400 
1401         colls = []
1402         for position, lineoffset, linelength, linewidth, color, alpha_, \
1403             linestyle in \
1404                 zip(positions, lineoffsets, linelengths, linewidths,
1405                     colors, alpha, linestyles):
1406             coll = mcoll.EventCollection(position,
1407                                          orientation=orientation,
1408                                          lineoffset=lineoffset,
1409                                          linelength=linelength,
1410                                          linewidth=linewidth,
1411                                          color=color,
1412                                          alpha=alpha_,
1413                                          linestyle=linestyle)
1414             self.add_collection(coll, autolim=False)
1415             coll._internal_update(kwargs)
1416             colls.append(coll)
1417 
1418         if len(positions) > 0:
1419             # try to get min/max
1420             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1421                        if len(_p) > 0]
1422             # if we have any non-empty positions, try to autoscale
1423             if len(min_max) > 0:
1424                 mins, maxes = zip(*min_max)
1425                 minpos = np.min(mins)
1426                 maxpos = np.max(maxes)
1427 
1428                 minline = (lineoffsets - linelengths).min()
1429                 maxline = (lineoffsets + linelengths).max()
1430 
1431                 if orientation == "vertical":
1432                     corners = (minline, minpos), (maxline, maxpos)
1433                 else:  # "horizontal"
1434                     corners = (minpos, minline), (maxpos, maxline)
1435                 self.update_datalim(corners)
1436                 self._request_autoscale_view()
1437 
1438         return colls
1439 
1440     #### Basic plotting
1441 
1442     # Uses a custom implementation of data-kwarg handling in
1443     # _process_plot_var_args.
1444     @_docstring.dedent_interpd
1445     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1446         """
1447         Plot y versus x as lines and/or markers.
1448 
1449         Call signatures::
1450 
1451             plot([x], y, [fmt], *, data=None, **kwargs)
1452             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1453 
1454         The coordinates of the points or line nodes are given by *x*, *y*.
1455 
1456         The optional parameter *fmt* is a convenient way for defining basic
1457         formatting like color, marker and linestyle. It's a shortcut string
1458         notation described in the *Notes* section below.
1459 
1460         >>> plot(x, y)        # plot x and y using default line style and color
1461         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1462         >>> plot(y)           # plot y using x as index array 0..N-1
1463         >>> plot(y, 'r+')     # ditto, but with red plusses
1464 
1465         You can use `.Line2D` properties as keyword arguments for more
1466         control on the appearance. Line properties and *fmt* can be mixed.
1467         The following two calls yield identical results:
1468 
1469         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1470         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1471         ...      linewidth=2, markersize=12)
1472 
1473         When conflicting with *fmt*, keyword arguments take precedence.
1474 
1475 
1476         **Plotting labelled data**
1477 
1478         There's a convenient way for plotting objects with labelled data (i.e.
1479         data that can be accessed by index ``obj['y']``). Instead of giving
1480         the data in *x* and *y*, you can provide the object in the *data*
1481         parameter and just give the labels for *x* and *y*::
1482 
1483         >>> plot('xlabel', 'ylabel', data=obj)
1484 
1485         All indexable objects are supported. This could e.g. be a `dict`, a
1486         `pandas.DataFrame` or a structured numpy array.
1487 
1488 
1489         **Plotting multiple sets of data**
1490 
1491         There are various ways to plot multiple sets of data.
1492 
1493         - The most straight forward way is just to call `plot` multiple times.
1494           Example:
1495 
1496           >>> plot(x1, y1, 'bo')
1497           >>> plot(x2, y2, 'go')
1498 
1499         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1500           for every column. If both *x* and *y* are 2D, they must have the
1501           same shape. If only one of them is 2D with shape (N, m) the other
1502           must have length N and will be used for every data set m.
1503 
1504           Example:
1505 
1506           >>> x = [1, 2, 3]
1507           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1508           >>> plot(x, y)
1509 
1510           is equivalent to:
1511 
1512           >>> for col in range(y.shape[1]):
1513           ...     plot(x, y[:, col])
1514 
1515         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1516           groups::
1517 
1518           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1519 
1520           In this case, any additional keyword argument applies to all
1521           datasets. Also, this syntax cannot be combined with the *data*
1522           parameter.
1523 
1524         By default, each line is assigned a different style specified by a
1525         'style cycle'. The *fmt* and line property parameters are only
1526         necessary if you want explicit deviations from these defaults.
1527         Alternatively, you can also change the style cycle using
1528         :rc:`axes.prop_cycle`.
1529 
1530 
1531         Parameters
1532         ----------
1533         x, y : array-like or scalar
1534             The horizontal / vertical coordinates of the data points.
1535             *x* values are optional and default to ``range(len(y))``.
1536 
1537             Commonly, these parameters are 1D arrays.
1538 
1539             They can also be scalars, or two-dimensional (in that case, the
1540             columns represent separate data sets).
1541 
1542             These arguments cannot be passed as keywords.
1543 
1544         fmt : str, optional
1545             A format string, e.g. 'ro' for red circles. See the *Notes*
1546             section for a full description of the format strings.
1547 
1548             Format strings are just an abbreviation for quickly setting
1549             basic line properties. All of these and more can also be
1550             controlled by keyword arguments.
1551 
1552             This argument cannot be passed as keyword.
1553 
1554         data : indexable object, optional
1555             An object with labelled data. If given, provide the label names to
1556             plot in *x* and *y*.
1557 
1558             .. note::
1559                 Technically there's a slight ambiguity in calls where the
1560                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1561                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1562                 the former interpretation is chosen, but a warning is issued.
1563                 You may suppress the warning by adding an empty format string
1564                 ``plot('n', 'o', '', data=obj)``.
1565 
1566         Returns
1567         -------
1568         list of `.Line2D`
1569             A list of lines representing the plotted data.
1570 
1571         Other Parameters
1572         ----------------
1573         scalex, scaley : bool, default: True
1574             These parameters determine if the view limits are adapted to the
1575             data limits. The values are passed on to
1576             `~.axes.Axes.autoscale_view`.
1577 
1578         **kwargs : `.Line2D` properties, optional
1579             *kwargs* are used to specify properties like a line label (for
1580             auto legends), linewidth, antialiasing, marker face color.
1581             Example::
1582 
1583             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1584             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1585 
1586             If you specify multiple lines with one plot call, the kwargs apply
1587             to all those lines. In case the label object is iterable, each
1588             element is used as labels for each set of data.
1589 
1590             Here is a list of available `.Line2D` properties:
1591 
1592             %(Line2D:kwdoc)s
1593 
1594         See Also
1595         --------
1596         scatter : XY scatter plot with markers of varying size and/or color (
1597             sometimes also called bubble chart).
1598 
1599         Notes
1600         -----
1601         **Format Strings**
1602 
1603         A format string consists of a part for color, marker and line::
1604 
1605             fmt = '[marker][line][color]'
1606 
1607         Each of them is optional. If not provided, the value from the style
1608         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1609         the data will be a line without markers.
1610 
1611         Other combinations such as ``[color][marker][line]`` are also
1612         supported, but note that their parsing may be ambiguous.
1613 
1614         **Markers**
1615 
1616         =============   ===============================
1617         character       description
1618         =============   ===============================
1619         ``'.'``         point marker
1620         ``','``         pixel marker
1621         ``'o'``         circle marker
1622         ``'v'``         triangle_down marker
1623         ``'^'``         triangle_up marker
1624         ``'<'``         triangle_left marker
1625         ``'>'``         triangle_right marker
1626         ``'1'``         tri_down marker
1627         ``'2'``         tri_up marker
1628         ``'3'``         tri_left marker
1629         ``'4'``         tri_right marker
1630         ``'8'``         octagon marker
1631         ``'s'``         square marker
1632         ``'p'``         pentagon marker
1633         ``'P'``         plus (filled) marker
1634         ``'*'``         star marker
1635         ``'h'``         hexagon1 marker
1636         ``'H'``         hexagon2 marker
1637         ``'+'``         plus marker
1638         ``'x'``         x marker
1639         ``'X'``         x (filled) marker
1640         ``'D'``         diamond marker
1641         ``'d'``         thin_diamond marker
1642         ``'|'``         vline marker
1643         ``'_'``         hline marker
1644         =============   ===============================
1645 
1646         **Line Styles**
1647 
1648         =============    ===============================
1649         character        description
1650         =============    ===============================
1651         ``'-'``          solid line style
1652         ``'--'``         dashed line style
1653         ``'-.'``         dash-dot line style
1654         ``':'``          dotted line style
1655         =============    ===============================
1656 
1657         Example format strings::
1658 
1659             'b'    # blue markers with default shape
1660             'or'   # red circles
1661             '-g'   # green solid line
1662             '--'   # dashed line with default color
1663             '^k:'  # black triangle_up markers connected by a dotted line
1664 
1665         **Colors**
1666 
1667         The supported color abbreviations are the single letter codes
1668 
1669         =============    ===============================
1670         character        color
1671         =============    ===============================
1672         ``'b'``          blue
1673         ``'g'``          green
1674         ``'r'``          red
1675         ``'c'``          cyan
1676         ``'m'``          magenta
1677         ``'y'``          yellow
1678         ``'k'``          black
1679         ``'w'``          white
1680         =============    ===============================
1681 
1682         and the ``'CN'`` colors that index into the default property cycle.
1683 
1684         If the color is the only part of the format string, you can
1685         additionally use any  `matplotlib.colors` spec, e.g. full names
1686         (``'green'``) or hex strings (``'#008000'``).
1687         """
1688         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1689         lines = [*self._get_lines(*args, data=data, **kwargs)]
1690         for line in lines:
1691             self.add_line(line)
1692         if scalex:
1693             self._request_autoscale_view("x")
1694         if scaley:
1695             self._request_autoscale_view("y")
1696         return lines
1697 
1698     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1699     @_docstring.dedent_interpd
1700     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1701                   **kwargs):
1702         """
1703         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1704 
1705         .. admonition:: Discouraged
1706 
1707             This method exists for historic reasons and will be deprecated in
1708             the future.
1709 
1710             - ``datetime``-like data should directly be plotted using
1711               `~.Axes.plot`.
1712             -  If you need to plot plain numeric data as :ref:`date-format` or
1713                need to set a timezone, call ``ax.xaxis.axis_date`` /
1714                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1715                `.Axis.axis_date`.
1716 
1717         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1718         However, the axis labels are formatted as dates depending on *xdate*
1719         and *ydate*.  Note that `.plot` will work with `datetime` and
1720         `numpy.datetime64` objects without resorting to this method.
1721 
1722         Parameters
1723         ----------
1724         x, y : array-like
1725             The coordinates of the data points. If *xdate* or *ydate* is
1726             *True*, the respective values *x* or *y* are interpreted as
1727             :ref:`Matplotlib dates <date-format>`.
1728 
1729         fmt : str, optional
1730             The plot format string. For details, see the corresponding
1731             parameter in `.plot`.
1732 
1733         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1734             The time zone to use in labeling dates.
1735 
1736         xdate : bool, default: True
1737             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1738 
1739         ydate : bool, default: False
1740             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1741 
1742         Returns
1743         -------
1744         list of `.Line2D`
1745             Objects representing the plotted data.
1746 
1747         Other Parameters
1748         ----------------
1749         data : indexable object, optional
1750             DATA_PARAMETER_PLACEHOLDER
1751         **kwargs
1752             Keyword arguments control the `.Line2D` properties:
1753 
1754             %(Line2D:kwdoc)s
1755 
1756         See Also
1757         --------
1758         matplotlib.dates : Helper functions on dates.
1759         matplotlib.dates.date2num : Convert dates to num.
1760         matplotlib.dates.num2date : Convert num to dates.
1761         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1762 
1763         Notes
1764         -----
1765         If you are using custom date tickers and formatters, it may be
1766         necessary to set the formatters/locators after the call to
1767         `.plot_date`. `.plot_date` will set the default tick locator to
1768         `.AutoDateLocator` (if the tick locator is not already set to a
1769         `.DateLocator` instance) and the default tick formatter to
1770         `.AutoDateFormatter` (if the tick formatter is not already set to a
1771         `.DateFormatter` instance).
1772         """
1773         if xdate:
1774             self.xaxis_date(tz)
1775         if ydate:
1776             self.yaxis_date(tz)
1777         return self.plot(x, y, fmt, **kwargs)
1778 
1779     # @_preprocess_data() # let 'plot' do the unpacking..
1780     @_docstring.dedent_interpd
1781     def loglog(self, *args, **kwargs):
1782         """
1783         Make a plot with log scaling on both the x- and y-axis.
1784 
1785         Call signatures::
1786 
1787             loglog([x], y, [fmt], data=None, **kwargs)
1788             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1789 
1790         This is just a thin wrapper around `.plot` which additionally changes
1791         both the x-axis and the y-axis to log scaling. All the concepts and
1792         parameters of plot can be used here as well.
1793 
1794         The additional parameters *base*, *subs* and *nonpositive* control the
1795         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1796         `.Axes.set_yscale`. To use different properties on the x-axis and the
1797         y-axis, use e.g.
1798         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1799 
1800         Parameters
1801         ----------
1802         base : float, default: 10
1803             Base of the logarithm.
1804 
1805         subs : sequence, optional
1806             The location of the minor ticks. If *None*, reasonable locations
1807             are automatically chosen depending on the number of decades in the
1808             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1809 
1810         nonpositive : {'mask', 'clip'}, default: 'mask'
1811             Non-positive values can be masked as invalid, or clipped to a very
1812             small positive number.
1813 
1814         **kwargs
1815             All parameters supported by `.plot`.
1816 
1817         Returns
1818         -------
1819         list of `.Line2D`
1820             Objects representing the plotted data.
1821         """
1822         dx = {k: v for k, v in kwargs.items()
1823               if k in ['base', 'subs', 'nonpositive',
1824                        'basex', 'subsx', 'nonposx']}
1825         self.set_xscale('log', **dx)
1826         dy = {k: v for k, v in kwargs.items()
1827               if k in ['base', 'subs', 'nonpositive',
1828                        'basey', 'subsy', 'nonposy']}
1829         self.set_yscale('log', **dy)
1830         return self.plot(
1831             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1832 
1833     # @_preprocess_data() # let 'plot' do the unpacking..
1834     @_docstring.dedent_interpd
1835     def semilogx(self, *args, **kwargs):
1836         """
1837         Make a plot with log scaling on the x-axis.
1838 
1839         Call signatures::
1840 
1841             semilogx([x], y, [fmt], data=None, **kwargs)
1842             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1843 
1844         This is just a thin wrapper around `.plot` which additionally changes
1845         the x-axis to log scaling. All the concepts and parameters of plot can
1846         be used here as well.
1847 
1848         The additional parameters *base*, *subs*, and *nonpositive* control the
1849         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1850 
1851         Parameters
1852         ----------
1853         base : float, default: 10
1854             Base of the x logarithm.
1855 
1856         subs : array-like, optional
1857             The location of the minor xticks. If *None*, reasonable locations
1858             are automatically chosen depending on the number of decades in the
1859             plot. See `.Axes.set_xscale` for details.
1860 
1861         nonpositive : {'mask', 'clip'}, default: 'mask'
1862             Non-positive values in x can be masked as invalid, or clipped to a
1863             very small positive number.
1864 
1865         **kwargs
1866             All parameters supported by `.plot`.
1867 
1868         Returns
1869         -------
1870         list of `.Line2D`
1871             Objects representing the plotted data.
1872         """
1873         d = {k: v for k, v in kwargs.items()
1874              if k in ['base', 'subs', 'nonpositive',
1875                       'basex', 'subsx', 'nonposx']}
1876         self.set_xscale('log', **d)
1877         return self.plot(
1878             *args, **{k: v for k, v in kwargs.items() if k not in d})
1879 
1880     # @_preprocess_data() # let 'plot' do the unpacking..
1881     @_docstring.dedent_interpd
1882     def semilogy(self, *args, **kwargs):
1883         """
1884         Make a plot with log scaling on the y-axis.
1885 
1886         Call signatures::
1887 
1888             semilogy([x], y, [fmt], data=None, **kwargs)
1889             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1890 
1891         This is just a thin wrapper around `.plot` which additionally changes
1892         the y-axis to log scaling. All the concepts and parameters of plot can
1893         be used here as well.
1894 
1895         The additional parameters *base*, *subs*, and *nonpositive* control the
1896         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1897 
1898         Parameters
1899         ----------
1900         base : float, default: 10
1901             Base of the y logarithm.
1902 
1903         subs : array-like, optional
1904             The location of the minor yticks. If *None*, reasonable locations
1905             are automatically chosen depending on the number of decades in the
1906             plot. See `.Axes.set_yscale` for details.
1907 
1908         nonpositive : {'mask', 'clip'}, default: 'mask'
1909             Non-positive values in y can be masked as invalid, or clipped to a
1910             very small positive number.
1911 
1912         **kwargs
1913             All parameters supported by `.plot`.
1914 
1915         Returns
1916         -------
1917         list of `.Line2D`
1918             Objects representing the plotted data.
1919         """
1920         d = {k: v for k, v in kwargs.items()
1921              if k in ['base', 'subs', 'nonpositive',
1922                       'basey', 'subsy', 'nonposy']}
1923         self.set_yscale('log', **d)
1924         return self.plot(
1925             *args, **{k: v for k, v in kwargs.items() if k not in d})
1926 
1927     @_preprocess_data(replace_names=["x"], label_namer="x")
1928     def acorr(self, x, **kwargs):
1929         """
1930         Plot the autocorrelation of *x*.
1931 
1932         Parameters
1933         ----------
1934         x : array-like
1935 
1936         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1937             A detrending function applied to *x*.  It must have the
1938             signature ::
1939 
1940                 detrend(x: np.ndarray) -> np.ndarray
1941 
1942         normed : bool, default: True
1943             If ``True``, input vectors are normalised to unit length.
1944 
1945         usevlines : bool, default: True
1946             Determines the plot style.
1947 
1948             If ``True``, vertical lines are plotted from 0 to the acorr value
1949             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1950             at y=0 using `.Axes.axhline`.
1951 
1952             If ``False``, markers are plotted at the acorr values using
1953             `.Axes.plot`.
1954 
1955         maxlags : int, default: 10
1956             Number of lags to show. If ``None``, will return all
1957             ``2 * len(x) - 1`` lags.
1958 
1959         Returns
1960         -------
1961         lags : array (length ``2*maxlags+1``)
1962             The lag vector.
1963         c : array  (length ``2*maxlags+1``)
1964             The auto correlation vector.
1965         line : `.LineCollection` or `.Line2D`
1966             `.Artist` added to the Axes of the correlation:
1967 
1968             - `.LineCollection` if *usevlines* is True.
1969             - `.Line2D` if *usevlines* is False.
1970         b : `.Line2D` or None
1971             Horizontal line at 0 if *usevlines* is True
1972             None *usevlines* is False.
1973 
1974         Other Parameters
1975         ----------------
1976         linestyle : `.Line2D` property, optional
1977             The linestyle for plotting the data points.
1978             Only used if *usevlines* is ``False``.
1979 
1980         marker : str, default: 'o'
1981             The marker for plotting the data points.
1982             Only used if *usevlines* is ``False``.
1983 
1984         data : indexable object, optional
1985             DATA_PARAMETER_PLACEHOLDER
1986 
1987         **kwargs
1988             Additional parameters are passed to `.Axes.vlines` and
1989             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
1990             passed to `.Axes.plot`.
1991 
1992         Notes
1993         -----
1994         The cross correlation is performed with `numpy.correlate` with
1995         ``mode = "full"``.
1996         """
1997         return self.xcorr(x, x, **kwargs)
1998 
1999     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
2000     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2001               usevlines=True, maxlags=10, **kwargs):
2002         r"""
2003         Plot the cross correlation between *x* and *y*.
2004 
2005         The correlation with lag k is defined as
2006         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2007         conjugate of :math:`y`.
2008 
2009         Parameters
2010         ----------
2011         x, y : array-like of length n
2012 
2013         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2014             A detrending function applied to *x* and *y*.  It must have the
2015             signature ::
2016 
2017                 detrend(x: np.ndarray) -> np.ndarray
2018 
2019         normed : bool, default: True
2020             If ``True``, input vectors are normalised to unit length.
2021 
2022         usevlines : bool, default: True
2023             Determines the plot style.
2024 
2025             If ``True``, vertical lines are plotted from 0 to the xcorr value
2026             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2027             at y=0 using `.Axes.axhline`.
2028 
2029             If ``False``, markers are plotted at the xcorr values using
2030             `.Axes.plot`.
2031 
2032         maxlags : int, default: 10
2033             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2034             lags.
2035 
2036         Returns
2037         -------
2038         lags : array (length ``2*maxlags+1``)
2039             The lag vector.
2040         c : array  (length ``2*maxlags+1``)
2041             The auto correlation vector.
2042         line : `.LineCollection` or `.Line2D`
2043             `.Artist` added to the Axes of the correlation:
2044 
2045             - `.LineCollection` if *usevlines* is True.
2046             - `.Line2D` if *usevlines* is False.
2047         b : `.Line2D` or None
2048             Horizontal line at 0 if *usevlines* is True
2049             None *usevlines* is False.
2050 
2051         Other Parameters
2052         ----------------
2053         linestyle : `.Line2D` property, optional
2054             The linestyle for plotting the data points.
2055             Only used if *usevlines* is ``False``.
2056 
2057         marker : str, default: 'o'
2058             The marker for plotting the data points.
2059             Only used if *usevlines* is ``False``.
2060 
2061         data : indexable object, optional
2062             DATA_PARAMETER_PLACEHOLDER
2063 
2064         **kwargs
2065             Additional parameters are passed to `.Axes.vlines` and
2066             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2067             passed to `.Axes.plot`.
2068 
2069         Notes
2070         -----
2071         The cross correlation is performed with `numpy.correlate` with
2072         ``mode = "full"``.
2073         """
2074         Nx = len(x)
2075         if Nx != len(y):
2076             raise ValueError('x and y must be equal length')
2077 
2078         x = detrend(np.asarray(x))
2079         y = detrend(np.asarray(y))
2080 
2081         correls = np.correlate(x, y, mode="full")
2082 
2083         if normed:
2084             correls /= np.sqrt(np.dot(x, x) * np.dot(y, y))
2085 
2086         if maxlags is None:
2087             maxlags = Nx - 1
2088 
2089         if maxlags >= Nx or maxlags < 1:
2090             raise ValueError('maxlags must be None or strictly '
2091                              'positive < %d' % Nx)
2092 
2093         lags = np.arange(-maxlags, maxlags + 1)
2094         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2095 
2096         if usevlines:
2097             a = self.vlines(lags, [0], correls, **kwargs)
2098             # Make label empty so only vertical lines get a legend entry
2099             kwargs.pop('label', '')
2100             b = self.axhline(**kwargs)
2101         else:
2102             kwargs.setdefault('marker', 'o')
2103             kwargs.setdefault('linestyle', 'None')
2104             a, = self.plot(lags, correls, **kwargs)
2105             b = None
2106         return lags, correls, a, b
2107 
2108     #### Specialized plotting
2109 
2110     # @_preprocess_data() # let 'plot' do the unpacking..
2111     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2112         """
2113         Make a step plot.
2114 
2115         Call signatures::
2116 
2117             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2118             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2119 
2120         This is just a thin wrapper around `.plot` which changes some
2121         formatting options. Most of the concepts and parameters of plot can be
2122         used here as well.
2123 
2124         .. note::
2125 
2126             This method uses a standard plot with a step drawstyle: The *x*
2127             values are the reference positions and steps extend left/right/both
2128             directions depending on *where*.
2129 
2130             For the common case where you know the values and edges of the
2131             steps, use `~.Axes.stairs` instead.
2132 
2133         Parameters
2134         ----------
2135         x : array-like
2136             1D sequence of x positions. It is assumed, but not checked, that
2137             it is uniformly increasing.
2138 
2139         y : array-like
2140             1D sequence of y levels.
2141 
2142         fmt : str, optional
2143             A format string, e.g. 'g' for a green line. See `.plot` for a more
2144             detailed description.
2145 
2146             Note: While full format strings are accepted, it is recommended to
2147             only specify the color. Line styles are currently ignored (use
2148             the keyword argument *linestyle* instead). Markers are accepted
2149             and plotted on the given positions, however, this is a rarely
2150             needed feature for step plots.
2151 
2152         where : {'pre', 'post', 'mid'}, default: 'pre'
2153             Define where the steps should be placed:
2154 
2155             - 'pre': The y value is continued constantly to the left from
2156               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2157               value ``y[i]``.
2158             - 'post': The y value is continued constantly to the right from
2159               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2160               value ``y[i]``.
2161             - 'mid': Steps occur half-way between the *x* positions.
2162 
2163         data : indexable object, optional
2164             An object with labelled data. If given, provide the label names to
2165             plot in *x* and *y*.
2166 
2167         **kwargs
2168             Additional parameters are the same as those for `.plot`.
2169 
2170         Returns
2171         -------
2172         list of `.Line2D`
2173             Objects representing the plotted data.
2174         """
2175         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2176         kwargs['drawstyle'] = 'steps-' + where
2177         return self.plot(x, y, *args, data=data, **kwargs)
2178 
2179     @staticmethod
2180     def _convert_dx(dx, x0, xconv, convert):
2181         """
2182         Small helper to do logic of width conversion flexibly.
2183 
2184         *dx* and *x0* have units, but *xconv* has already been converted
2185         to unitless (and is an ndarray).  This allows the *dx* to have units
2186         that are different from *x0*, but are still accepted by the
2187         ``__add__`` operator of *x0*.
2188         """
2189 
2190         # x should be an array...
2191         assert type(xconv) is np.ndarray
2192 
2193         if xconv.size == 0:
2194             # xconv has already been converted, but maybe empty...
2195             return convert(dx)
2196 
2197         try:
2198             # attempt to add the width to x0; this works for
2199             # datetime+timedelta, for instance
2200 
2201             # only use the first element of x and x0.  This saves
2202             # having to be sure addition works across the whole
2203             # vector.  This is particularly an issue if
2204             # x0 and dx are lists so x0 + dx just concatenates the lists.
2205             # We can't just cast x0 and dx to numpy arrays because that
2206             # removes the units from unit packages like `pint` that
2207             # wrap numpy arrays.
2208             try:
2209                 x0 = cbook._safe_first_finite(x0)
2210             except (TypeError, IndexError, KeyError):
2211                 pass
2212             except StopIteration:
2213                 # this means we found no finite element, fall back to first
2214                 # element unconditionally
2215                 x0 = cbook.safe_first_element(x0)
2216 
2217             try:
2218                 x = cbook._safe_first_finite(xconv)
2219             except (TypeError, IndexError, KeyError):
2220                 x = xconv
2221             except StopIteration:
2222                 # this means we found no finite element, fall back to first
2223                 # element unconditionally
2224                 x = cbook.safe_first_element(xconv)
2225 
2226             delist = False
2227             if not np.iterable(dx):
2228                 dx = [dx]
2229                 delist = True
2230             dx = [convert(x0 + ddx) - x for ddx in dx]
2231             if delist:
2232                 dx = dx[0]
2233         except (ValueError, TypeError, AttributeError):
2234             # if the above fails (for any reason) just fallback to what
2235             # we do by default and convert dx by itself.
2236             dx = convert(dx)
2237         return dx
2238 
2239     @_preprocess_data()
2240     @_docstring.dedent_interpd
2241     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2242             **kwargs):
2243         r"""
2244         Make a bar plot.
2245 
2246         The bars are positioned at *x* with the given *align*\ment. Their
2247         dimensions are given by *height* and *width*. The vertical baseline
2248         is *bottom* (default 0).
2249 
2250         Many parameters can take either a single value applying to all bars
2251         or a sequence of values, one for each bar.
2252 
2253         Parameters
2254         ----------
2255         x : float or array-like
2256             The x coordinates of the bars. See also *align* for the
2257             alignment of the bars to the coordinates.
2258 
2259         height : float or array-like
2260             The height(s) of the bars.
2261 
2262         width : float or array-like, default: 0.8
2263             The width(s) of the bars.
2264 
2265         bottom : float or array-like, default: 0
2266             The y coordinate(s) of the bottom side(s) of the bars.
2267 
2268         align : {'center', 'edge'}, default: 'center'
2269             Alignment of the bars to the *x* coordinates:
2270 
2271             - 'center': Center the base on the *x* positions.
2272             - 'edge': Align the left edges of the bars with the *x* positions.
2273 
2274             To align the bars on the right edge pass a negative *width* and
2275             ``align='edge'``.
2276 
2277         Returns
2278         -------
2279         `.BarContainer`
2280             Container with all the bars and optionally errorbars.
2281 
2282         Other Parameters
2283         ----------------
2284         color : color or list of color, optional
2285             The colors of the bar faces.
2286 
2287         edgecolor : color or list of color, optional
2288             The colors of the bar edges.
2289 
2290         linewidth : float or array-like, optional
2291             Width of the bar edge(s). If 0, don't draw edges.
2292 
2293         tick_label : str or list of str, optional
2294             The tick labels of the bars.
2295             Default: None (Use default numeric labels.)
2296 
2297         label : str or list of str, optional
2298             A single label is attached to the resulting `.BarContainer` as a
2299             label for the whole dataset.
2300             If a list is provided, it must be the same length as *x* and
2301             labels the individual bars. Repeated labels are not de-duplicated
2302             and will cause repeated label entries, so this is best used when
2303             bars also differ in style (e.g., by passing a list to *color*.)
2304 
2305         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2306             If not *None*, add horizontal / vertical errorbars to the bar tips.
2307             The values are +/- sizes relative to the data:
2308 
2309             - scalar: symmetric +/- values for all bars
2310             - shape(N,): symmetric +/- values for each bar
2311             - shape(2, N): Separate - and + values for each bar. First row
2312               contains the lower errors, the second row contains the upper
2313               errors.
2314             - *None*: No errorbar. (Default)
2315 
2316             See :doc:`/gallery/statistics/errorbar_features` for an example on
2317             the usage of *xerr* and *yerr*.
2318 
2319         ecolor : color or list of color, default: 'black'
2320             The line color of the errorbars.
2321 
2322         capsize : float, default: :rc:`errorbar.capsize`
2323            The length of the error bar caps in points.
2324 
2325         error_kw : dict, optional
2326             Dictionary of keyword arguments to be passed to the
2327             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2328             here take precedence over the independent keyword arguments.
2329 
2330         log : bool, default: False
2331             If *True*, set the y-axis to be log scale.
2332 
2333         data : indexable object, optional
2334             DATA_PARAMETER_PLACEHOLDER
2335 
2336         **kwargs : `.Rectangle` properties
2337 
2338         %(Rectangle:kwdoc)s
2339 
2340         See Also
2341         --------
2342         barh : Plot a horizontal bar plot.
2343 
2344         Notes
2345         -----
2346         Stacked bars can be achieved by passing individual *bottom* values per
2347         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2348         """
2349         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2350         color = kwargs.pop('color', None)
2351         if color is None:
2352             color = self._get_patches_for_fill.get_next_color()
2353         edgecolor = kwargs.pop('edgecolor', None)
2354         linewidth = kwargs.pop('linewidth', None)
2355         hatch = kwargs.pop('hatch', None)
2356 
2357         # Because xerr and yerr will be passed to errorbar, most dimension
2358         # checking and processing will be left to the errorbar method.
2359         xerr = kwargs.pop('xerr', None)
2360         yerr = kwargs.pop('yerr', None)
2361         error_kw = kwargs.pop('error_kw', {})
2362         ezorder = error_kw.pop('zorder', None)
2363         if ezorder is None:
2364             ezorder = kwargs.get('zorder', None)
2365             if ezorder is not None:
2366                 # If using the bar zorder, increment slightly to make sure
2367                 # errorbars are drawn on top of bars
2368                 ezorder += 0.01
2369         error_kw.setdefault('zorder', ezorder)
2370         ecolor = kwargs.pop('ecolor', 'k')
2371         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2372         error_kw.setdefault('ecolor', ecolor)
2373         error_kw.setdefault('capsize', capsize)
2374 
2375         # The keyword argument *orientation* is used by barh() to defer all
2376         # logic and drawing to bar(). It is considered internal and is
2377         # intentionally not mentioned in the docstring.
2378         orientation = kwargs.pop('orientation', 'vertical')
2379         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2380         log = kwargs.pop('log', False)
2381         label = kwargs.pop('label', '')
2382         tick_labels = kwargs.pop('tick_label', None)
2383 
2384         y = bottom  # Matches barh call signature.
2385         if orientation == 'vertical':
2386             if y is None:
2387                 y = 0
2388         else:  # horizontal
2389             if x is None:
2390                 x = 0
2391 
2392         if orientation == 'vertical':
2393             self._process_unit_info(
2394                 [("x", x), ("y", height)], kwargs, convert=False)
2395             if log:
2396                 self.set_yscale('log', nonpositive='clip')
2397         else:  # horizontal
2398             self._process_unit_info(
2399                 [("x", width), ("y", y)], kwargs, convert=False)
2400             if log:
2401                 self.set_xscale('log', nonpositive='clip')
2402 
2403         # lets do some conversions now since some types cannot be
2404         # subtracted uniformly
2405         if self.xaxis is not None:
2406             x0 = x
2407             x = np.asarray(self.convert_xunits(x))
2408             width = self._convert_dx(width, x0, x, self.convert_xunits)
2409             if xerr is not None:
2410                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2411         if self.yaxis is not None:
2412             y0 = y
2413             y = np.asarray(self.convert_yunits(y))
2414             height = self._convert_dx(height, y0, y, self.convert_yunits)
2415             if yerr is not None:
2416                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2417 
2418         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2419             # Make args iterable too.
2420             np.atleast_1d(x), height, width, y, linewidth, hatch)
2421 
2422         # Now that units have been converted, set the tick locations.
2423         if orientation == 'vertical':
2424             tick_label_axis = self.xaxis
2425             tick_label_position = x
2426         else:  # horizontal
2427             tick_label_axis = self.yaxis
2428             tick_label_position = y
2429 
2430         if not isinstance(label, str) and np.iterable(label):
2431             bar_container_label = '_nolegend_'
2432             patch_labels = label
2433         else:
2434             bar_container_label = label
2435             patch_labels = ['_nolegend_'] * len(x)
2436         if len(patch_labels) != len(x):
2437             raise ValueError(f'number of labels ({len(patch_labels)}) '
2438                              f'does not match number of bars ({len(x)}).')
2439 
2440         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2441         hatch = itertools.cycle(np.atleast_1d(hatch))
2442         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2443                                 # Fallback if color == "none".
2444                                 itertools.repeat('none'))
2445         if edgecolor is None:
2446             edgecolor = itertools.repeat(None)
2447         else:
2448             edgecolor = itertools.chain(
2449                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2450                 # Fallback if edgecolor == "none".
2451                 itertools.repeat('none'))
2452 
2453         # We will now resolve the alignment and really have
2454         # left, bottom, width, height vectors
2455         _api.check_in_list(['center', 'edge'], align=align)
2456         if align == 'center':
2457             if orientation == 'vertical':
2458                 try:
2459                     left = x - width / 2
2460                 except TypeError as e:
2461                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2462                                     f'and width ({width.dtype}) '
2463                                     f'are incompatible') from e
2464                 bottom = y
2465             else:  # horizontal
2466                 try:
2467                     bottom = y - height / 2
2468                 except TypeError as e:
2469                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2470                                     f'and height ({height.dtype}) '
2471                                     f'are incompatible') from e
2472                 left = x
2473         else:  # edge
2474             left = x
2475             bottom = y
2476 
2477         patches = []
2478         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2479                    hatch, patch_labels)
2480         for l, b, w, h, c, e, lw, htch, lbl in args:
2481             r = mpatches.Rectangle(
2482                 xy=(l, b), width=w, height=h,
2483                 facecolor=c,
2484                 edgecolor=e,
2485                 linewidth=lw,
2486                 label=lbl,
2487                 hatch=htch,
2488                 )
2489             r._internal_update(kwargs)
2490             r.get_path()._interpolation_steps = 100
2491             if orientation == 'vertical':
2492                 r.sticky_edges.y.append(b)
2493             else:  # horizontal
2494                 r.sticky_edges.x.append(l)
2495             self.add_patch(r)
2496             patches.append(r)
2497 
2498         if xerr is not None or yerr is not None:
2499             if orientation == 'vertical':
2500                 # using list comps rather than arrays to preserve unit info
2501                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2502                 ey = [b + h for b, h in zip(bottom, height)]
2503 
2504             else:  # horizontal
2505                 # using list comps rather than arrays to preserve unit info
2506                 ex = [l + w for l, w in zip(left, width)]
2507                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2508 
2509             error_kw.setdefault("label", '_nolegend_')
2510 
2511             errorbar = self.errorbar(ex, ey,
2512                                      yerr=yerr, xerr=xerr,
2513                                      fmt='none', **error_kw)
2514         else:
2515             errorbar = None
2516 
2517         self._request_autoscale_view()
2518 
2519         if orientation == 'vertical':
2520             datavalues = height
2521         else:  # horizontal
2522             datavalues = width
2523 
2524         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2525                                      orientation=orientation,
2526                                      label=bar_container_label)
2527         self.add_container(bar_container)
2528 
2529         if tick_labels is not None:
2530             tick_labels = np.broadcast_to(tick_labels, len(patches))
2531             tick_label_axis.set_ticks(tick_label_position)
2532             tick_label_axis.set_ticklabels(tick_labels)
2533 
2534         return bar_container
2535 
2536     # @_preprocess_data() # let 'bar' do the unpacking..
2537     @_docstring.dedent_interpd
2538     def barh(self, y, width, height=0.8, left=None, *, align="center",
2539              data=None, **kwargs):
2540         r"""
2541         Make a horizontal bar plot.
2542 
2543         The bars are positioned at *y* with the given *align*\ment. Their
2544         dimensions are given by *width* and *height*. The horizontal baseline
2545         is *left* (default 0).
2546 
2547         Many parameters can take either a single value applying to all bars
2548         or a sequence of values, one for each bar.
2549 
2550         Parameters
2551         ----------
2552         y : float or array-like
2553             The y coordinates of the bars. See also *align* for the
2554             alignment of the bars to the coordinates.
2555 
2556         width : float or array-like
2557             The width(s) of the bars.
2558 
2559         height : float or array-like, default: 0.8
2560             The heights of the bars.
2561 
2562         left : float or array-like, default: 0
2563             The x coordinates of the left side(s) of the bars.
2564 
2565         align : {'center', 'edge'}, default: 'center'
2566             Alignment of the base to the *y* coordinates*:
2567 
2568             - 'center': Center the bars on the *y* positions.
2569             - 'edge': Align the bottom edges of the bars with the *y*
2570               positions.
2571 
2572             To align the bars on the top edge pass a negative *height* and
2573             ``align='edge'``.
2574 
2575         Returns
2576         -------
2577         `.BarContainer`
2578             Container with all the bars and optionally errorbars.
2579 
2580         Other Parameters
2581         ----------------
2582         color : color or list of color, optional
2583             The colors of the bar faces.
2584 
2585         edgecolor : color or list of color, optional
2586             The colors of the bar edges.
2587 
2588         linewidth : float or array-like, optional
2589             Width of the bar edge(s). If 0, don't draw edges.
2590 
2591         tick_label : str or list of str, optional
2592             The tick labels of the bars.
2593             Default: None (Use default numeric labels.)
2594 
2595         label : str or list of str, optional
2596             A single label is attached to the resulting `.BarContainer` as a
2597             label for the whole dataset.
2598             If a list is provided, it must be the same length as *y* and
2599             labels the individual bars. Repeated labels are not de-duplicated
2600             and will cause repeated label entries, so this is best used when
2601             bars also differ in style (e.g., by passing a list to *color*.)
2602 
2603         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2604             If not *None*, add horizontal / vertical errorbars to the bar tips.
2605             The values are +/- sizes relative to the data:
2606 
2607             - scalar: symmetric +/- values for all bars
2608             - shape(N,): symmetric +/- values for each bar
2609             - shape(2, N): Separate - and + values for each bar. First row
2610               contains the lower errors, the second row contains the upper
2611               errors.
2612             - *None*: No errorbar. (default)
2613 
2614             See :doc:`/gallery/statistics/errorbar_features` for an example on
2615             the usage of *xerr* and *yerr*.
2616 
2617         ecolor : color or list of color, default: 'black'
2618             The line color of the errorbars.
2619 
2620         capsize : float, default: :rc:`errorbar.capsize`
2621            The length of the error bar caps in points.
2622 
2623         error_kw : dict, optional
2624             Dictionary of keyword arguments to be passed to the
2625             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2626             here take precedence over the independent keyword arguments.
2627 
2628         log : bool, default: False
2629             If ``True``, set the x-axis to be log scale.
2630 
2631         data : indexable object, optional
2632             If given, all parameters also accept a string ``s``, which is
2633             interpreted as ``data[s]`` (unless this raises an exception).
2634 
2635         **kwargs : `.Rectangle` properties
2636 
2637         %(Rectangle:kwdoc)s
2638 
2639         See Also
2640         --------
2641         bar : Plot a vertical bar plot.
2642 
2643         Notes
2644         -----
2645         Stacked bars can be achieved by passing individual *left* values per
2646         bar. See
2647         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2648         """
2649         kwargs.setdefault('orientation', 'horizontal')
2650         patches = self.bar(x=left, height=height, width=width, bottom=y,
2651                            align=align, data=data, **kwargs)
2652         return patches
2653 
2654     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2655                   padding=0, **kwargs):
2656         """
2657         Label a bar plot.
2658 
2659         Adds labels to bars in the given `.BarContainer`.
2660         You may need to adjust the axis limits to fit the labels.
2661 
2662         Parameters
2663         ----------
2664         container : `.BarContainer`
2665             Container with all the bars and optionally errorbars, likely
2666             returned from `.bar` or `.barh`.
2667 
2668         labels : array-like, optional
2669             A list of label texts, that should be displayed. If not given, the
2670             label texts will be the data values formatted with *fmt*.
2671 
2672         fmt : str or callable, default: '%g'
2673             An unnamed %-style or {}-style format string for the label or a
2674             function to call with the value as the first argument.
2675             When *fmt* is a string and can be interpreted in both formats,
2676             %-style takes precedence over {}-style.
2677 
2678             .. versionadded:: 3.7
2679                Support for {}-style format string and callables.
2680 
2681         label_type : {'edge', 'center'}, default: 'edge'
2682             The label type. Possible values:
2683 
2684             - 'edge': label placed at the end-point of the bar segment, and the
2685               value displayed will be the position of that end-point.
2686             - 'center': label placed in the center of the bar segment, and the
2687               value displayed will be the length of that segment.
2688               (useful for stacked bars, i.e.,
2689               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2690 
2691         padding : float, default: 0
2692             Distance of label from the end of the bar, in points.
2693 
2694         **kwargs
2695             Any remaining keyword arguments are passed through to
2696             `.Axes.annotate`. The alignment parameters (
2697             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2698             not supported because the labels are automatically aligned to
2699             the bars.
2700 
2701         Returns
2702         -------
2703         list of `.Text`
2704             A list of `.Text` instances for the labels.
2705         """
2706         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2707             if key in kwargs:
2708                 raise ValueError(
2709                     f"Passing {key!r} to bar_label() is not supported.")
2710 
2711         a, b = self.yaxis.get_view_interval()
2712         y_inverted = a > b
2713         c, d = self.xaxis.get_view_interval()
2714         x_inverted = c > d
2715 
2716         # want to know whether to put label on positive or negative direction
2717         # cannot use np.sign here because it will return 0 if x == 0
2718         def sign(x):
2719             return 1 if x >= 0 else -1
2720 
2721         _api.check_in_list(['edge', 'center'], label_type=label_type)
2722 
2723         bars = container.patches
2724         errorbar = container.errorbar
2725         datavalues = container.datavalues
2726         orientation = container.orientation
2727 
2728         if errorbar:
2729             # check "ErrorbarContainer" for the definition of these elements
2730             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2731             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2732             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2733             errs = barlinecol.get_segments()
2734         else:
2735             errs = []
2736 
2737         if labels is None:
2738             labels = []
2739 
2740         annotations = []
2741 
2742         for bar, err, dat, lbl in itertools.zip_longest(
2743                 bars, errs, datavalues, labels
2744         ):
2745             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2746             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2747 
2748             if orientation == "vertical":
2749                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2750                 length = abs(y0 - y1)
2751             else:  # horizontal
2752                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2753                 length = abs(x0 - x1)
2754 
2755             if err is None or np.size(err) == 0:
2756                 endpt = extrema
2757             elif orientation == "vertical":
2758                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2759             else:  # horizontal
2760                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2761 
2762             if label_type == "center":
2763                 value = sign(dat) * length
2764             else:  # edge
2765                 value = extrema
2766 
2767             if label_type == "center":
2768                 xy = (0.5, 0.5)
2769                 kwargs["xycoords"] = (
2770                     lambda r, b=bar:
2771                         mtransforms.Bbox.intersection(
2772                             b.get_window_extent(r), b.get_clip_box()
2773                         )
2774                 )
2775             else:  # edge
2776                 if orientation == "vertical":
2777                     xy = xc, endpt
2778                 else:  # horizontal
2779                     xy = endpt, yc
2780 
2781             if orientation == "vertical":
2782                 y_direction = -1 if y_inverted else 1
2783                 xytext = 0, y_direction * sign(dat) * padding
2784             else:  # horizontal
2785                 x_direction = -1 if x_inverted else 1
2786                 xytext = x_direction * sign(dat) * padding, 0
2787 
2788             if label_type == "center":
2789                 ha, va = "center", "center"
2790             else:  # edge
2791                 if orientation == "vertical":
2792                     ha = 'center'
2793                     if y_inverted:
2794                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2795                     else:
2796                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2797                 else:  # horizontal
2798                     if x_inverted:
2799                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2800                     else:
2801                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2802                     va = 'center'
2803 
2804             if np.isnan(dat):
2805                 lbl = ''
2806 
2807             if lbl is None:
2808                 if isinstance(fmt, str):
2809                     lbl = cbook._auto_format_str(fmt, value)
2810                 elif callable(fmt):
2811                     lbl = fmt(value)
2812                 else:
2813                     raise TypeError("fmt must be a str or callable")
2814             annotation = self.annotate(lbl,
2815                                        xy, xytext, textcoords="offset points",
2816                                        ha=ha, va=va, **kwargs)
2817             annotations.append(annotation)
2818 
2819         return annotations
2820 
2821     @_preprocess_data()
2822     @_docstring.dedent_interpd
2823     def broken_barh(self, xranges, yrange, **kwargs):
2824         """
2825         Plot a horizontal sequence of rectangles.
2826 
2827         A rectangle is drawn for each element of *xranges*. All rectangles
2828         have the same vertical position and size defined by *yrange*.
2829 
2830         Parameters
2831         ----------
2832         xranges : sequence of tuples (*xmin*, *xwidth*)
2833             The x-positions and extents of the rectangles. For each tuple
2834             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2835             *xwidth*.
2836         yrange : (*ymin*, *yheight*)
2837             The y-position and extent for all the rectangles.
2838 
2839         Returns
2840         -------
2841         `~.collections.PolyCollection`
2842 
2843         Other Parameters
2844         ----------------
2845         data : indexable object, optional
2846             DATA_PARAMETER_PLACEHOLDER
2847         **kwargs : `.PolyCollection` properties
2848 
2849             Each *kwarg* can be either a single argument applying to all
2850             rectangles, e.g.::
2851 
2852                 facecolors='black'
2853 
2854             or a sequence of arguments over which is cycled, e.g.::
2855 
2856                 facecolors=('black', 'blue')
2857 
2858             would create interleaving black and blue rectangles.
2859 
2860             Supported keywords:
2861 
2862             %(PolyCollection:kwdoc)s
2863         """
2864         # process the unit information
2865         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2866         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2867         self._process_unit_info(
2868             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2869 
2870         vertices = []
2871         y0, dy = yrange
2872         y0, y1 = self.convert_yunits((y0, y0 + dy))
2873         for xr in xranges:  # convert the absolute values, not the x and dx
2874             try:
2875                 x0, dx = xr
2876             except Exception:
2877                 raise ValueError(
2878                     "each range in xrange must be a sequence with two "
2879                     "elements (i.e. xrange must be an (N, 2) array)") from None
2880             x0, x1 = self.convert_xunits((x0, x0 + dx))
2881             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2882 
2883         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2884         self.add_collection(col, autolim=True)
2885         self._request_autoscale_view()
2886 
2887         return col
2888 
2889     @_preprocess_data()
2890     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2891              label=None, orientation='vertical'):
2892         """
2893         Create a stem plot.
2894 
2895         A stem plot draws lines perpendicular to a baseline at each location
2896         *locs* from the baseline to *heads*, and places a marker there. For
2897         vertical stem plots (the default), the *locs* are *x* positions, and
2898         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2899         *y* positions, and the *heads* are *x* values.
2900 
2901         Call signature::
2902 
2903           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2904 
2905         The *locs*-positions are optional. *linefmt* may be provided as
2906         positional, but all other formats must be provided as keyword
2907         arguments.
2908 
2909         Parameters
2910         ----------
2911         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2912             For vertical stem plots, the x-positions of the stems.
2913             For horizontal stem plots, the y-positions of the stems.
2914 
2915         heads : array-like
2916             For vertical stem plots, the y-values of the stem heads.
2917             For horizontal stem plots, the x-values of the stem heads.
2918 
2919         linefmt : str, optional
2920             A string defining the color and/or linestyle of the vertical lines:
2921 
2922             =========  =============
2923             Character  Line Style
2924             =========  =============
2925             ``'-'``    solid line
2926             ``'--'``   dashed line
2927             ``'-.'``   dash-dot line
2928             ``':'``    dotted line
2929             =========  =============
2930 
2931             Default: 'C0-', i.e. solid line with the first color of the color
2932             cycle.
2933 
2934             Note: Markers specified through this parameter (e.g. 'x') will be
2935             silently ignored. Instead, markers should be specified using
2936             *markerfmt*.
2937 
2938         markerfmt : str, optional
2939             A string defining the color and/or shape of the markers at the stem
2940             heads. If the marker is not given, use the marker 'o', i.e. filled
2941             circles. If the color is not given, use the color from *linefmt*.
2942 
2943         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2944             A format string defining the properties of the baseline.
2945 
2946         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2947             If 'vertical', will produce a plot with stems oriented vertically,
2948             If 'horizontal', the stems will be oriented horizontally.
2949 
2950         bottom : float, default: 0
2951             The y/x-position of the baseline (depending on orientation).
2952 
2953         label : str, default: None
2954             The label to use for the stems in legends.
2955 
2956         data : indexable object, optional
2957             DATA_PARAMETER_PLACEHOLDER
2958 
2959         Returns
2960         -------
2961         `.StemContainer`
2962             The container may be treated like a tuple
2963             (*markerline*, *stemlines*, *baseline*)
2964 
2965         Notes
2966         -----
2967         .. seealso::
2968             The MATLAB function
2969             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2970             which inspired this method.
2971         """
2972         if not 1 <= len(args) <= 3:
2973             _api.nargs_error('stem', '1-3', len(args))
2974         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
2975 
2976         if len(args) == 1:
2977             heads, = args
2978             locs = np.arange(len(heads))
2979             args = ()
2980         elif isinstance(args[1], str):
2981             heads, *args = args
2982             locs = np.arange(len(heads))
2983         else:
2984             locs, heads, *args = args
2985 
2986         if orientation == 'vertical':
2987             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
2988         else:  # horizontal
2989             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
2990 
2991         # resolve line format
2992         if linefmt is None:
2993             linefmt = args[0] if len(args) > 0 else "C0-"
2994         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
2995 
2996         # resolve marker format
2997         if markerfmt is None:
2998             # if not given as kwarg, fall back to 'o'
2999             markerfmt = "o"
3000         if markerfmt == '':
3001             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3002         markerstyle, markermarker, markercolor = \
3003             _process_plot_format(markerfmt)
3004         if markermarker is None:
3005             markermarker = 'o'
3006         if markerstyle is None:
3007             markerstyle = 'None'
3008         if markercolor is None:
3009             markercolor = linecolor
3010 
3011         # resolve baseline format
3012         if basefmt is None:
3013             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3014                        "C3-")
3015         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3016 
3017         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3018         if linestyle is None:
3019             linestyle = mpl.rcParams['lines.linestyle']
3020         xlines = self.vlines if orientation == "vertical" else self.hlines
3021         stemlines = xlines(
3022             locs, bottom, heads,
3023             colors=linecolor, linestyles=linestyle, label="_nolegend_")
3024 
3025         if orientation == 'horizontal':
3026             marker_x = heads
3027             marker_y = locs
3028             baseline_x = [bottom, bottom]
3029             baseline_y = [np.min(locs), np.max(locs)]
3030         else:
3031             marker_x = locs
3032             marker_y = heads
3033             baseline_x = [np.min(locs), np.max(locs)]
3034             baseline_y = [bottom, bottom]
3035 
3036         markerline, = self.plot(marker_x, marker_y,
3037                                 color=markercolor, linestyle=markerstyle,
3038                                 marker=markermarker, label="_nolegend_")
3039 
3040         baseline, = self.plot(baseline_x, baseline_y,
3041                               color=basecolor, linestyle=basestyle,
3042                               marker=basemarker, label="_nolegend_")
3043 
3044         stem_container = StemContainer((markerline, stemlines, baseline),
3045                                        label=label)
3046         self.add_container(stem_container)
3047         return stem_container
3048 
3049     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3050     def pie(self, x, explode=None, labels=None, colors=None,
3051             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3052             startangle=0, radius=1, counterclock=True,
3053             wedgeprops=None, textprops=None, center=(0, 0),
3054             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3055         """
3056         Plot a pie chart.
3057 
3058         Make a pie chart of array *x*.  The fractional area of each wedge is
3059         given by ``x/sum(x)``.
3060 
3061         The wedges are plotted counterclockwise, by default starting from the
3062         x-axis.
3063 
3064         Parameters
3065         ----------
3066         x : 1D array-like
3067             The wedge sizes.
3068 
3069         explode : array-like, default: None
3070             If not *None*, is a ``len(x)`` array which specifies the fraction
3071             of the radius with which to offset each wedge.
3072 
3073         labels : list, default: None
3074             A sequence of strings providing the labels for each wedge
3075 
3076         colors : array-like, default: None
3077             A sequence of colors through which the pie chart will cycle.  If
3078             *None*, will use the colors in the currently active cycle.
3079 
3080         hatch : str or list, default: None
3081             Hatching pattern applied to all pie wedges or sequence of patterns
3082             through which the chart will cycle. For a list of valid patterns,
3083             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3084 
3085             .. versionadded:: 3.7
3086 
3087         autopct : None or str or callable, default: None
3088             If not *None*, *autopct* is a string or function used to label the
3089             wedges with their numeric value. The label will be placed inside
3090             the wedge. If *autopct* is a format string, the label will be
3091             ``fmt % pct``. If *autopct* is a function, then it will be called.
3092 
3093         pctdistance : float, default: 0.6
3094             The relative distance along the radius at which the text
3095             generated by *autopct* is drawn. To draw the text outside the pie,
3096             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3097             ``None``.
3098 
3099         labeldistance : float or None, default: 1.1
3100             The relative distance along the radius at which the labels are
3101             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3102             If set to ``None``, labels are not drawn but are still stored for
3103             use in `.legend`.
3104 
3105         shadow : bool, default: False
3106             Draw a shadow beneath the pie.
3107 
3108         startangle : float, default: 0 degrees
3109             The angle by which the start of the pie is rotated,
3110             counterclockwise from the x-axis.
3111 
3112         radius : float, default: 1
3113             The radius of the pie.
3114 
3115         counterclock : bool, default: True
3116             Specify fractions direction, clockwise or counterclockwise.
3117 
3118         wedgeprops : dict, default: None
3119             Dict of arguments passed to each `.patches.Wedge` of the pie.
3120             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3121             the wedge border lines equal to 3. By default, ``clip_on=False``.
3122             When there is a conflict between these properties and other
3123             keywords, properties passed to *wedgeprops* take precedence.
3124 
3125         textprops : dict, default: None
3126             Dict of arguments to pass to the text objects.
3127 
3128         center : (float, float), default: (0, 0)
3129             The coordinates of the center of the chart.
3130 
3131         frame : bool, default: False
3132             Plot Axes frame with the chart if true.
3133 
3134         rotatelabels : bool, default: False
3135             Rotate each label to the angle of the corresponding slice if true.
3136 
3137         normalize : bool, default: True
3138             When *True*, always make a full pie by normalizing x so that
3139             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3140             and raises a `ValueError` for ``sum(x) > 1``.
3141 
3142         data : indexable object, optional
3143             DATA_PARAMETER_PLACEHOLDER
3144 
3145         Returns
3146         -------
3147         patches : list
3148             A sequence of `matplotlib.patches.Wedge` instances
3149 
3150         texts : list
3151             A list of the label `.Text` instances.
3152 
3153         autotexts : list
3154             A list of `.Text` instances for the numeric labels. This will only
3155             be returned if the parameter *autopct* is not *None*.
3156 
3157         Notes
3158         -----
3159         The pie chart will probably look best if the figure and Axes are
3160         square, or the Axes aspect is equal.
3161         This method sets the aspect ratio of the axis to "equal".
3162         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3163         """
3164         self.set_aspect('equal')
3165         # The use of float32 is "historical", but can't be changed without
3166         # regenerating the test baselines.
3167         x = np.asarray(x, np.float32)
3168         if x.ndim > 1:
3169             raise ValueError("x must be 1D")
3170 
3171         if np.any(x < 0):
3172             raise ValueError("Wedge sizes 'x' must be non negative values")
3173 
3174         sx = x.sum()
3175 
3176         if normalize:
3177             x = x / sx
3178         elif sx > 1:
3179             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3180         if labels is None:
3181             labels = [''] * len(x)
3182         if explode is None:
3183             explode = [0] * len(x)
3184         if len(x) != len(labels):
3185             raise ValueError("'label' must be of length 'x'")
3186         if len(x) != len(explode):
3187             raise ValueError("'explode' must be of length 'x'")
3188         if colors is None:
3189             get_next_color = self._get_patches_for_fill.get_next_color
3190         else:
3191             color_cycle = itertools.cycle(colors)
3192 
3193             def get_next_color():
3194                 return next(color_cycle)
3195 
3196         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3197 
3198         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3199         if radius <= 0:
3200             raise ValueError(f'radius must be a positive number, not {radius}')
3201 
3202         # Starting theta1 is the start fraction of the circle
3203         theta1 = startangle / 360
3204 
3205         if wedgeprops is None:
3206             wedgeprops = {}
3207         if textprops is None:
3208             textprops = {}
3209 
3210         texts = []
3211         slices = []
3212         autotexts = []
3213 
3214         for frac, label, expl in zip(x, labels, explode):
3215             x, y = center
3216             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3217             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3218             x += expl * math.cos(thetam)
3219             y += expl * math.sin(thetam)
3220 
3221             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3222                                360. * max(theta1, theta2),
3223                                facecolor=get_next_color(),
3224                                hatch=next(hatch_cycle),
3225                                clip_on=False,
3226                                label=label)
3227             w.set(**wedgeprops)
3228             slices.append(w)
3229             self.add_patch(w)
3230 
3231             if shadow:
3232                 # Make sure to add a shadow after the call to add_patch so the
3233                 # figure and transform props will be set.
3234                 shad = mpatches.Shadow(w, -0.02, -0.02, label='_nolegend_')
3235                 self.add_patch(shad)
3236 
3237             if labeldistance is not None:
3238                 xt = x + labeldistance * radius * math.cos(thetam)
3239                 yt = y + labeldistance * radius * math.sin(thetam)
3240                 label_alignment_h = 'left' if xt > 0 else 'right'
3241                 label_alignment_v = 'center'
3242                 label_rotation = 'horizontal'
3243                 if rotatelabels:
3244                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3245                     label_rotation = (np.rad2deg(thetam)
3246                                       + (0 if xt > 0 else 180))
3247                 t = self.text(xt, yt, label,
3248                               clip_on=False,
3249                               horizontalalignment=label_alignment_h,
3250                               verticalalignment=label_alignment_v,
3251                               rotation=label_rotation,
3252                               size=mpl.rcParams['xtick.labelsize'])
3253                 t.set(**textprops)
3254                 texts.append(t)
3255 
3256             if autopct is not None:
3257                 xt = x + pctdistance * radius * math.cos(thetam)
3258                 yt = y + pctdistance * radius * math.sin(thetam)
3259                 if isinstance(autopct, str):
3260                     s = autopct % (100. * frac)
3261                 elif callable(autopct):
3262                     s = autopct(100. * frac)
3263                 else:
3264                     raise TypeError(
3265                         'autopct must be callable or a format string')
3266                 t = self.text(xt, yt, s,
3267                               clip_on=False,
3268                               horizontalalignment='center',
3269                               verticalalignment='center')
3270                 t.set(**textprops)
3271                 autotexts.append(t)
3272 
3273             theta1 = theta2
3274 
3275         if frame:
3276             self._request_autoscale_view()
3277         else:
3278             self.set(frame_on=False, xticks=[], yticks=[],
3279                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3280                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3281 
3282         if autopct is None:
3283             return slices, texts
3284         else:
3285             return slices, texts, autotexts
3286 
3287     @staticmethod
3288     def _errorevery_to_mask(x, errorevery):
3289         """
3290         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3291 
3292         This function is split out to be usable both by 2D and 3D errorbars.
3293         """
3294         if isinstance(errorevery, Integral):
3295             errorevery = (0, errorevery)
3296         if isinstance(errorevery, tuple):
3297             if (len(errorevery) == 2 and
3298                     isinstance(errorevery[0], Integral) and
3299                     isinstance(errorevery[1], Integral)):
3300                 errorevery = slice(errorevery[0], None, errorevery[1])
3301             else:
3302                 raise ValueError(
3303                     f'{errorevery=!r} is a not a tuple of two integers')
3304         elif isinstance(errorevery, slice):
3305             pass
3306         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3307             try:
3308                 x[errorevery]  # fancy indexing
3309             except (ValueError, IndexError) as err:
3310                 raise ValueError(
3311                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3312                     "index to match 'xerr'/'yerr'") from err
3313         else:
3314             raise ValueError(f"{errorevery=!r} is not a recognized value")
3315         everymask = np.zeros(len(x), bool)
3316         everymask[errorevery] = True
3317         return everymask
3318 
3319     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3320                       label_namer="y")
3321     @_docstring.dedent_interpd
3322     def errorbar(self, x, y, yerr=None, xerr=None,
3323                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3324                  barsabove=False, lolims=False, uplims=False,
3325                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3326                  **kwargs):
3327         """
3328         Plot y versus x as lines and/or markers with attached errorbars.
3329 
3330         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3331         sizes. By default, this draws the data markers/lines as well the
3332         errorbars. Use fmt='none' to draw errorbars without any data markers.
3333 
3334         .. versionadded:: 3.7
3335            Caps and error lines are drawn in polar coordinates on polar plots.
3336 
3337 
3338         Parameters
3339         ----------
3340         x, y : float or array-like
3341             The data positions.
3342 
3343         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3344             The errorbar sizes:
3345 
3346             - scalar: Symmetric +/- values for all data points.
3347             - shape(N,): Symmetric +/-values for each data point.
3348             - shape(2, N): Separate - and + values for each bar. First row
3349               contains the lower errors, the second row contains the upper
3350               errors.
3351             - *None*: No errorbar.
3352 
3353             All values must be >= 0.
3354 
3355             See :doc:`/gallery/statistics/errorbar_features`
3356             for an example on the usage of ``xerr`` and ``yerr``.
3357 
3358         fmt : str, default: ''
3359             The format for the data points / data lines. See `.plot` for
3360             details.
3361 
3362             Use 'none' (case-insensitive) to plot errorbars without any data
3363             markers.
3364 
3365         ecolor : color, default: None
3366             The color of the errorbar lines.  If None, use the color of the
3367             line connecting the markers.
3368 
3369         elinewidth : float, default: None
3370             The linewidth of the errorbar lines. If None, the linewidth of
3371             the current style is used.
3372 
3373         capsize : float, default: :rc:`errorbar.capsize`
3374             The length of the error bar caps in points.
3375 
3376         capthick : float, default: None
3377             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3378             This setting is a more sensible name for the property that
3379             controls the thickness of the error bar cap in points. For
3380             backwards compatibility, if *mew* or *markeredgewidth* are given,
3381             then they will over-ride *capthick*. This may change in future
3382             releases.
3383 
3384         barsabove : bool, default: False
3385             If True, will plot the errorbars above the plot
3386             symbols. Default is below.
3387 
3388         lolims, uplims, xlolims, xuplims : bool, default: False
3389             These arguments can be used to indicate that a value gives only
3390             upper/lower limits.  In that case a caret symbol is used to
3391             indicate this. *lims*-arguments may be scalars, or array-likes of
3392             the same length as *xerr* and *yerr*.  To use limits with inverted
3393             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3394             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3395             *lolims* to True means that the y-value is a *lower* limit of the
3396             True value, so, only an *upward*-pointing arrow will be drawn!
3397 
3398         errorevery : int or (int, int), default: 1
3399             draws error bars on a subset of the data. *errorevery* =N draws
3400             error bars on the points (x[::N], y[::N]).
3401             *errorevery* =(start, N) draws error bars on the points
3402             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3403             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3404             Used to avoid overlapping error bars when two series share x-axis
3405             values.
3406 
3407         Returns
3408         -------
3409         `.ErrorbarContainer`
3410             The container contains:
3411 
3412             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3413             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3414             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3415               vertical error ranges.
3416 
3417         Other Parameters
3418         ----------------
3419         data : indexable object, optional
3420             DATA_PARAMETER_PLACEHOLDER
3421 
3422         **kwargs
3423             All other keyword arguments are passed on to the `~.Axes.plot` call
3424             drawing the markers. For example, this code makes big red squares
3425             with thick green edges::
3426 
3427                 x, y, yerr = rand(3, 10)
3428                 errorbar(x, y, yerr, marker='s', mfc='red',
3429                          mec='green', ms=20, mew=4)
3430 
3431             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3432             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3433             and *markeredgewidth*.
3434 
3435             Valid kwargs for the marker properties are:
3436 
3437             - *dashes*
3438             - *dash_capstyle*
3439             - *dash_joinstyle*
3440             - *drawstyle*
3441             - *fillstyle*
3442             - *linestyle*
3443             - *marker*
3444             - *markeredgecolor*
3445             - *markeredgewidth*
3446             - *markerfacecolor*
3447             - *markerfacecoloralt*
3448             - *markersize*
3449             - *markevery*
3450             - *solid_capstyle*
3451             - *solid_joinstyle*
3452 
3453             Refer to the corresponding `.Line2D` property for more details:
3454 
3455             %(Line2D:kwdoc)s
3456         """
3457         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3458         # Drop anything that comes in as None to use the default instead.
3459         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3460         kwargs.setdefault('zorder', 2)
3461 
3462         # Casting to object arrays preserves units.
3463         if not isinstance(x, np.ndarray):
3464             x = np.asarray(x, dtype=object)
3465         if not isinstance(y, np.ndarray):
3466             y = np.asarray(y, dtype=object)
3467 
3468         def _upcast_err(err):
3469             """
3470             Safely handle tuple of containers that carry units.
3471 
3472             This function covers the case where the input to the xerr/yerr is a
3473             length 2 tuple of equal length ndarray-subclasses that carry the
3474             unit information in the container.
3475 
3476             If we have a tuple of nested numpy array (subclasses), we defer
3477             coercing the units to be consistent to the underlying unit
3478             library (and implicitly the broadcasting).
3479 
3480             Otherwise, fallback to casting to an object array.
3481             """
3482 
3483             if (
3484                     # make sure it is not a scalar
3485                     np.iterable(err) and
3486                     # and it is not empty
3487                     len(err) > 0 and
3488                     # and the first element is an array sub-class use
3489                     # safe_first_element because getitem is index-first not
3490                     # location first on pandas objects so err[0] almost always
3491                     # fails.
3492                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3493             ):
3494                 # Get the type of the first element
3495                 atype = type(cbook._safe_first_finite(err))
3496                 # Promote the outer container to match the inner container
3497                 if atype is np.ndarray:
3498                     # Converts using np.asarray, because data cannot
3499                     # be directly passed to init of np.ndarray
3500                     return np.asarray(err, dtype=object)
3501                 # If atype is not np.ndarray, directly pass data to init.
3502                 # This works for types such as unyts and astropy units
3503                 return atype(err)
3504             # Otherwise wrap it in an object array
3505             return np.asarray(err, dtype=object)
3506 
3507         if xerr is not None and not isinstance(xerr, np.ndarray):
3508             xerr = _upcast_err(xerr)
3509         if yerr is not None and not isinstance(yerr, np.ndarray):
3510             yerr = _upcast_err(yerr)
3511         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3512         if len(x) != len(y):
3513             raise ValueError("'x' and 'y' must have the same size")
3514 
3515         everymask = self._errorevery_to_mask(x, errorevery)
3516 
3517         label = kwargs.pop("label", None)
3518         kwargs['label'] = '_nolegend_'
3519 
3520         # Create the main line and determine overall kwargs for child artists.
3521         # We avoid calling self.plot() directly, or self._get_lines(), because
3522         # that would call self._process_unit_info again, and do other indirect
3523         # data processing.
3524         (data_line, base_style), = self._get_lines._plot_args(
3525             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3526 
3527         # Do this after creating `data_line` to avoid modifying `base_style`.
3528         if barsabove:
3529             data_line.set_zorder(kwargs['zorder'] - .1)
3530         else:
3531             data_line.set_zorder(kwargs['zorder'] + .1)
3532 
3533         # Add line to plot, or throw it away and use it to determine kwargs.
3534         if fmt.lower() != 'none':
3535             self.add_line(data_line)
3536         else:
3537             data_line = None
3538             # Remove alpha=0 color that _get_lines._plot_args returns for
3539             # 'none' format, and replace it with user-specified color, if
3540             # supplied.
3541             base_style.pop('color')
3542             if 'color' in kwargs:
3543                 base_style['color'] = kwargs.pop('color')
3544 
3545         if 'color' not in base_style:
3546             base_style['color'] = 'C0'
3547         if ecolor is None:
3548             ecolor = base_style['color']
3549 
3550         # Eject any line-specific information from format string, as it's not
3551         # needed for bars or caps.
3552         for key in ['marker', 'markersize', 'markerfacecolor',
3553                     'markerfacecoloralt',
3554                     'markeredgewidth', 'markeredgecolor', 'markevery',
3555                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3556                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3557                     'dashes']:
3558             base_style.pop(key, None)
3559 
3560         # Make the style dict for the line collections (the bars).
3561         eb_lines_style = {**base_style, 'color': ecolor}
3562 
3563         if elinewidth is not None:
3564             eb_lines_style['linewidth'] = elinewidth
3565         elif 'linewidth' in kwargs:
3566             eb_lines_style['linewidth'] = kwargs['linewidth']
3567 
3568         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3569             if key in kwargs:
3570                 eb_lines_style[key] = kwargs[key]
3571 
3572         # Make the style dict for caps (the "hats").
3573         eb_cap_style = {**base_style, 'linestyle': 'none'}
3574         if capsize is None:
3575             capsize = mpl.rcParams["errorbar.capsize"]
3576         if capsize > 0:
3577             eb_cap_style['markersize'] = 2. * capsize
3578         if capthick is not None:
3579             eb_cap_style['markeredgewidth'] = capthick
3580 
3581         # For backwards-compat, allow explicit setting of
3582         # 'markeredgewidth' to over-ride capthick.
3583         for key in ('markeredgewidth', 'transform', 'alpha',
3584                     'zorder', 'rasterized'):
3585             if key in kwargs:
3586                 eb_cap_style[key] = kwargs[key]
3587         eb_cap_style['color'] = ecolor
3588 
3589         barcols = []
3590         caplines = {'x': [], 'y': []}
3591 
3592         # Vectorized fancy-indexer.
3593         def apply_mask(arrays, mask):
3594             return [array[mask] for array in arrays]
3595 
3596         # dep: dependent dataset, indep: independent dataset
3597         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3598              marker, lomarker, himarker) in [
3599                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3600                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3601                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3602                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3603         ]:
3604             if err is None:
3605                 continue
3606             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3607             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3608             try:
3609                 np.broadcast_to(err, (2, len(dep)))
3610             except ValueError:
3611                 raise ValueError(
3612                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3613                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3614                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3615             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3616             if np.any(np.less(err, -err, out=res, where=(err == err))):
3617                 # like err<0, but also works for timedelta and nan.
3618                 raise ValueError(
3619                     f"'{dep_axis}err' must not contain negative values")
3620             # This is like
3621             #     elow, ehigh = np.broadcast_to(...)
3622             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3623             # except that broadcast_to would strip units.
3624             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3625             barcols.append(lines_func(
3626                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3627             if self.name == "polar" and dep_axis == "x":
3628                 for b in barcols:
3629                     for p in b.get_paths():
3630                         p._interpolation_steps = 2
3631             # Normal errorbars for points without upper/lower limits.
3632             nolims = ~(lolims | uplims)
3633             if nolims.any() and capsize > 0:
3634                 indep_masked, lo_masked, hi_masked = apply_mask(
3635                     [indep, low, high], nolims & everymask)
3636                 for lh_masked in [lo_masked, hi_masked]:
3637                     # Since this has to work for x and y as dependent data, we
3638                     # first set both x and y to the independent variable and
3639                     # overwrite the respective dependent data in a second step.
3640                     line = mlines.Line2D(indep_masked, indep_masked,
3641                                          marker=marker, **eb_cap_style)
3642                     line.set(**{f"{dep_axis}data": lh_masked})
3643                     caplines[dep_axis].append(line)
3644             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3645                 if not lims.any():
3646                     continue
3647                 hlmarker = (
3648                     himarker
3649                     if self._axis_map[dep_axis].get_inverted() ^ idx
3650                     else lomarker)
3651                 x_masked, y_masked, hl_masked = apply_mask(
3652                     [x, y, hl], lims & everymask)
3653                 # As above, we set the dependent data in a second step.
3654                 line = mlines.Line2D(x_masked, y_masked,
3655                                      marker=hlmarker, **eb_cap_style)
3656                 line.set(**{f"{dep_axis}data": hl_masked})
3657                 caplines[dep_axis].append(line)
3658                 if capsize > 0:
3659                     caplines[dep_axis].append(mlines.Line2D(
3660                         x_masked, y_masked, marker=marker, **eb_cap_style))
3661         if self.name == 'polar':
3662             for axis in caplines:
3663                 for l in caplines[axis]:
3664                     # Rotate caps to be perpendicular to the error bars
3665                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3666                         rotation = mtransforms.Affine2D().rotate(theta)
3667                         if axis == 'y':
3668                             rotation.rotate(-np.pi / 2)
3669                         ms = mmarkers.MarkerStyle(marker=marker,
3670                                                   transform=rotation)
3671                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3672                                                     **eb_cap_style))
3673         else:
3674             for axis in caplines:
3675                 for l in caplines[axis]:
3676                     self.add_line(l)
3677 
3678         self._request_autoscale_view()
3679         caplines = caplines['x'] + caplines['y']
3680         errorbar_container = ErrorbarContainer(
3681             (data_line, tuple(caplines), tuple(barcols)),
3682             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3683             label=label)
3684         self.containers.append(errorbar_container)
3685 
3686         return errorbar_container  # (l0, caplines, barcols)
3687 
3688     @_preprocess_data()
3689     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3690                 positions=None, widths=None, patch_artist=None,
3691                 bootstrap=None, usermedians=None, conf_intervals=None,
3692                 meanline=None, showmeans=None, showcaps=None,
3693                 showbox=None, showfliers=None, boxprops=None,
3694                 labels=None, flierprops=None, medianprops=None,
3695                 meanprops=None, capprops=None, whiskerprops=None,
3696                 manage_ticks=True, autorange=False, zorder=None,
3697                 capwidths=None):
3698         """
3699         Draw a box and whisker plot.
3700 
3701         The box extends from the first quartile (Q1) to the third
3702         quartile (Q3) of the data, with a line at the median.
3703         The whiskers extend from the box to the farthest data point
3704         lying within 1.5x the inter-quartile range (IQR) from the box.
3705         Flier points are those past the end of the whiskers.
3706         See https://en.wikipedia.org/wiki/Box_plot for reference.
3707 
3708         .. code-block:: none
3709 
3710                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3711                                |-----:-----|
3712                o      |--------|     :     |--------|    o  o
3713                                |-----:-----|
3714              flier             <----------->            fliers
3715                                     IQR
3716 
3717 
3718         Parameters
3719         ----------
3720         x : Array or a sequence of vectors.
3721             The input data.  If a 2D array, a boxplot is drawn for each column
3722             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3723             array in *x*.
3724 
3725         notch : bool, default: False
3726             Whether to draw a notched boxplot (`True`), or a rectangular
3727             boxplot (`False`).  The notches represent the confidence interval
3728             (CI) around the median.  The documentation for *bootstrap*
3729             describes how the locations of the notches are computed by
3730             default, but their locations may also be overridden by setting the
3731             *conf_intervals* parameter.
3732 
3733             .. note::
3734 
3735                 In cases where the values of the CI are less than the
3736                 lower quartile or greater than the upper quartile, the
3737                 notches will extend beyond the box, giving it a
3738                 distinctive "flipped" appearance. This is expected
3739                 behavior and consistent with other statistical
3740                 visualization packages.
3741 
3742         sym : str, optional
3743             The default symbol for flier points.  An empty string ('') hides
3744             the fliers.  If `None`, then the fliers default to 'b+'.  More
3745             control is provided by the *flierprops* parameter.
3746 
3747         vert : bool, default: True
3748             If `True`, draws vertical boxes.
3749             If `False`, draw horizontal boxes.
3750 
3751         whis : float or (float, float), default: 1.5
3752             The position of the whiskers.
3753 
3754             If a float, the lower whisker is at the lowest datum above
3755             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3756             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3757             third quartiles.  The default value of ``whis = 1.5`` corresponds
3758             to Tukey's original definition of boxplots.
3759 
3760             If a pair of floats, they indicate the percentiles at which to
3761             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3762             (0, 100) results in whiskers covering the whole range of the data.
3763 
3764             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3765             to (0, 100) (cover the whole range of the data) if *autorange* is
3766             True.
3767 
3768             Beyond the whiskers, data are considered outliers and are plotted
3769             as individual points.
3770 
3771         bootstrap : int, optional
3772             Specifies whether to bootstrap the confidence intervals
3773             around the median for notched boxplots. If *bootstrap* is
3774             None, no bootstrapping is performed, and notches are
3775             calculated using a Gaussian-based asymptotic approximation
3776             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3777             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3778             the number of times to bootstrap the median to determine its
3779             95% confidence intervals. Values between 1000 and 10000 are
3780             recommended.
3781 
3782         usermedians : 1D array-like, optional
3783             A 1D array-like of length ``len(x)``.  Each entry that is not
3784             `None` forces the value of the median for the corresponding
3785             dataset.  For entries that are `None`, the medians are computed
3786             by Matplotlib as normal.
3787 
3788         conf_intervals : array-like, optional
3789             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3790             None forces the location of the corresponding notch (which is
3791             only drawn if *notch* is `True`).  For entries that are `None`,
3792             the notches are computed by the method specified by the other
3793             parameters (e.g., *bootstrap*).
3794 
3795         positions : array-like, optional
3796             The positions of the boxes. The ticks and limits are
3797             automatically set to match the positions. Defaults to
3798             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3799 
3800         widths : float or array-like
3801             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3802             between extreme positions)``, if that is smaller.
3803 
3804         patch_artist : bool, default: False
3805             If `False` produces boxes with the Line2D artist. Otherwise,
3806             boxes are drawn with Patch artists.
3807 
3808         labels : sequence, optional
3809             Labels for each dataset (one per dataset).
3810 
3811         manage_ticks : bool, default: True
3812             If True, the tick locations and labels will be adjusted to match
3813             the boxplot positions.
3814 
3815         autorange : bool, default: False
3816             When `True` and the data are distributed such that the 25th and
3817             75th percentiles are equal, *whis* is set to (0, 100) such
3818             that the whisker ends are at the minimum and maximum of the data.
3819 
3820         meanline : bool, default: False
3821             If `True` (and *showmeans* is `True`), will try to render the
3822             mean as a line spanning the full width of the box according to
3823             *meanprops* (see below).  Not recommended if *shownotches* is also
3824             True.  Otherwise, means will be shown as points.
3825 
3826         zorder : float, default: ``Line2D.zorder = 2``
3827             The zorder of the boxplot.
3828 
3829         Returns
3830         -------
3831         dict
3832           A dictionary mapping each component of the boxplot to a list
3833           of the `.Line2D` instances created. That dictionary has the
3834           following keys (assuming vertical boxplots):
3835 
3836           - ``boxes``: the main body of the boxplot showing the
3837             quartiles and the median's confidence intervals if
3838             enabled.
3839 
3840           - ``medians``: horizontal lines at the median of each box.
3841 
3842           - ``whiskers``: the vertical lines extending to the most
3843             extreme, non-outlier data points.
3844 
3845           - ``caps``: the horizontal lines at the ends of the
3846             whiskers.
3847 
3848           - ``fliers``: points representing data that extend beyond
3849             the whiskers (fliers).
3850 
3851           - ``means``: points or lines representing the means.
3852 
3853         Other Parameters
3854         ----------------
3855         showcaps : bool, default: True
3856             Show the caps on the ends of whiskers.
3857         showbox : bool, default: True
3858             Show the central box.
3859         showfliers : bool, default: True
3860             Show the outliers beyond the caps.
3861         showmeans : bool, default: False
3862             Show the arithmetic means.
3863         capprops : dict, default: None
3864             The style of the caps.
3865         capwidths : float or array, default: None
3866             The widths of the caps.
3867         boxprops : dict, default: None
3868             The style of the box.
3869         whiskerprops : dict, default: None
3870             The style of the whiskers.
3871         flierprops : dict, default: None
3872             The style of the fliers.
3873         medianprops : dict, default: None
3874             The style of the median.
3875         meanprops : dict, default: None
3876             The style of the mean.
3877         data : indexable object, optional
3878             DATA_PARAMETER_PLACEHOLDER
3879 
3880         See Also
3881         --------
3882         violinplot : Draw an estimate of the probability density function.
3883         """
3884 
3885         # Missing arguments default to rcParams.
3886         if whis is None:
3887             whis = mpl.rcParams['boxplot.whiskers']
3888         if bootstrap is None:
3889             bootstrap = mpl.rcParams['boxplot.bootstrap']
3890 
3891         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3892                                        labels=labels, autorange=autorange)
3893         if notch is None:
3894             notch = mpl.rcParams['boxplot.notch']
3895         if vert is None:
3896             vert = mpl.rcParams['boxplot.vertical']
3897         if patch_artist is None:
3898             patch_artist = mpl.rcParams['boxplot.patchartist']
3899         if meanline is None:
3900             meanline = mpl.rcParams['boxplot.meanline']
3901         if showmeans is None:
3902             showmeans = mpl.rcParams['boxplot.showmeans']
3903         if showcaps is None:
3904             showcaps = mpl.rcParams['boxplot.showcaps']
3905         if showbox is None:
3906             showbox = mpl.rcParams['boxplot.showbox']
3907         if showfliers is None:
3908             showfliers = mpl.rcParams['boxplot.showfliers']
3909 
3910         if boxprops is None:
3911             boxprops = {}
3912         if whiskerprops is None:
3913             whiskerprops = {}
3914         if capprops is None:
3915             capprops = {}
3916         if medianprops is None:
3917             medianprops = {}
3918         if meanprops is None:
3919             meanprops = {}
3920         if flierprops is None:
3921             flierprops = {}
3922 
3923         if patch_artist:
3924             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3925             if 'color' in boxprops:
3926                 boxprops['edgecolor'] = boxprops.pop('color')
3927 
3928         # if non-default sym value, put it into the flier dictionary
3929         # the logic for providing the default symbol ('b+') now lives
3930         # in bxp in the initial value of flierkw
3931         # handle all of the *sym* related logic here so we only have to pass
3932         # on the flierprops dict.
3933         if sym is not None:
3934             # no-flier case, which should really be done with
3935             # 'showfliers=False' but none-the-less deal with it to keep back
3936             # compatibility
3937             if sym == '':
3938                 # blow away existing dict and make one for invisible markers
3939                 flierprops = dict(linestyle='none', marker='', color='none')
3940                 # turn the fliers off just to be safe
3941                 showfliers = False
3942             # now process the symbol string
3943             else:
3944                 # process the symbol string
3945                 # discarded linestyle
3946                 _, marker, color = _process_plot_format(sym)
3947                 # if we have a marker, use it
3948                 if marker is not None:
3949                     flierprops['marker'] = marker
3950                 # if we have a color, use it
3951                 if color is not None:
3952                     # assume that if color is passed in the user want
3953                     # filled symbol, if the users want more control use
3954                     # flierprops
3955                     flierprops['color'] = color
3956                     flierprops['markerfacecolor'] = color
3957                     flierprops['markeredgecolor'] = color
3958 
3959         # replace medians if necessary:
3960         if usermedians is not None:
3961             if (len(np.ravel(usermedians)) != len(bxpstats) or
3962                     np.shape(usermedians)[0] != len(bxpstats)):
3963                 raise ValueError(
3964                     "'usermedians' and 'x' have different lengths")
3965             else:
3966                 # reassign medians as necessary
3967                 for stats, med in zip(bxpstats, usermedians):
3968                     if med is not None:
3969                         stats['med'] = med
3970 
3971         if conf_intervals is not None:
3972             if len(conf_intervals) != len(bxpstats):
3973                 raise ValueError(
3974                     "'conf_intervals' and 'x' have different lengths")
3975             else:
3976                 for stats, ci in zip(bxpstats, conf_intervals):
3977                     if ci is not None:
3978                         if len(ci) != 2:
3979                             raise ValueError('each confidence interval must '
3980                                              'have two values')
3981                         else:
3982                             if ci[0] is not None:
3983                                 stats['cilo'] = ci[0]
3984                             if ci[1] is not None:
3985                                 stats['cihi'] = ci[1]
3986 
3987         artists = self.bxp(bxpstats, positions=positions, widths=widths,
3988                            vert=vert, patch_artist=patch_artist,
3989                            shownotches=notch, showmeans=showmeans,
3990                            showcaps=showcaps, showbox=showbox,
3991                            boxprops=boxprops, flierprops=flierprops,
3992                            medianprops=medianprops, meanprops=meanprops,
3993                            meanline=meanline, showfliers=showfliers,
3994                            capprops=capprops, whiskerprops=whiskerprops,
3995                            manage_ticks=manage_ticks, zorder=zorder,
3996                            capwidths=capwidths)
3997         return artists
3998 
3999     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4000             patch_artist=False, shownotches=False, showmeans=False,
4001             showcaps=True, showbox=True, showfliers=True,
4002             boxprops=None, whiskerprops=None, flierprops=None,
4003             medianprops=None, capprops=None, meanprops=None,
4004             meanline=False, manage_ticks=True, zorder=None,
4005             capwidths=None):
4006         """
4007         Drawing function for box and whisker plots.
4008 
4009         Make a box and whisker plot for each column of *x* or each
4010         vector in sequence *x*.  The box extends from the lower to
4011         upper quartile values of the data, with a line at the median.
4012         The whiskers extend from the box to show the range of the
4013         data.  Flier points are those past the end of the whiskers.
4014 
4015         Parameters
4016         ----------
4017         bxpstats : list of dicts
4018           A list of dictionaries containing stats for each boxplot.
4019           Required keys are:
4020 
4021           - ``med``: Median (scalar).
4022           - ``q1``, ``q3``: First & third quartiles (scalars).
4023           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4024 
4025           Optional keys are:
4026 
4027           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4028           - ``fliers``: Data beyond the whiskers (array-like).
4029             Needed if ``showfliers=True``.
4030           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4031             about the median. Needed if ``shownotches=True``.
4032           - ``label``: Name of the dataset (str).  If available,
4033             this will be used a tick label for the boxplot
4034 
4035         positions : array-like, default: [1, 2, ..., n]
4036           The positions of the boxes. The ticks and limits
4037           are automatically set to match the positions.
4038 
4039         widths : float or array-like, default: None
4040           The widths of the boxes.  The default is
4041           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4042 
4043         capwidths : float or array-like, default: None
4044           Either a scalar or a vector and sets the width of each cap.
4045           The default is ``0.5*(with of the box)``, see *widths*.
4046 
4047         vert : bool, default: True
4048           If `True` (default), makes the boxes vertical.
4049           If `False`, makes horizontal boxes.
4050 
4051         patch_artist : bool, default: False
4052           If `False` produces boxes with the `.Line2D` artist.
4053           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4054 
4055         shownotches, showmeans, showcaps, showbox, showfliers : bool
4056           Whether to draw the CI notches, the mean value (both default to
4057           False), the caps, the box, and the fliers (all three default to
4058           True).
4059 
4060         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4061  dict, optional
4062           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4063           means.
4064 
4065         meanline : bool, default: False
4066           If `True` (and *showmeans* is `True`), will try to render the mean
4067           as a line spanning the full width of the box according to
4068           *meanprops*. Not recommended if *shownotches* is also True.
4069           Otherwise, means will be shown as points.
4070 
4071         manage_ticks : bool, default: True
4072           If True, the tick locations and labels will be adjusted to match the
4073           boxplot positions.
4074 
4075         zorder : float, default: ``Line2D.zorder = 2``
4076           The zorder of the resulting boxplot.
4077 
4078         Returns
4079         -------
4080         dict
4081           A dictionary mapping each component of the boxplot to a list
4082           of the `.Line2D` instances created. That dictionary has the
4083           following keys (assuming vertical boxplots):
4084 
4085           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4086             the median's confidence intervals if enabled.
4087           - ``medians``: horizontal lines at the median of each box.
4088           - ``whiskers``: vertical lines up to the last non-outlier data.
4089           - ``caps``: horizontal lines at the ends of the whiskers.
4090           - ``fliers``: points representing data beyond the whiskers (fliers).
4091           - ``means``: points or lines representing the means.
4092 
4093         Examples
4094         --------
4095         .. plot:: gallery/statistics/bxp.py
4096         """
4097 
4098         # lists of artists to be output
4099         whiskers = []
4100         caps = []
4101         boxes = []
4102         medians = []
4103         means = []
4104         fliers = []
4105 
4106         # empty list of xticklabels
4107         datalabels = []
4108 
4109         # Use default zorder if none specified
4110         if zorder is None:
4111             zorder = mlines.Line2D.zorder
4112 
4113         zdelta = 0.1
4114 
4115         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4116             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4117                  if k.startswith(f'boxplot.{subkey}props')}
4118             d['zorder'] = zorder + zdelta
4119             if not usemarker:
4120                 d['marker'] = ''
4121             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4122             return d
4123 
4124         box_kw = {
4125             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4126             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4127             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4128             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4129                           else mpl.rcParams['patch.facecolor']),
4130             'zorder': zorder,
4131             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4132         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4133         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4134         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4135         flier_kw = merge_kw_rc('flier', flierprops)
4136         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4137         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4138         removed_prop = 'marker' if meanline else 'linestyle'
4139         # Only remove the property if it's not set explicitly as a parameter.
4140         if meanprops is None or removed_prop not in meanprops:
4141             mean_kw[removed_prop] = ''
4142 
4143         # vertical or horizontal plot?
4144         maybe_swap = slice(None) if vert else slice(None, None, -1)
4145 
4146         def do_plot(xs, ys, **kwargs):
4147             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4148 
4149         def do_patch(xs, ys, **kwargs):
4150             path = mpath.Path._create_closed(
4151                 np.column_stack([xs, ys][maybe_swap]))
4152             patch = mpatches.PathPatch(path, **kwargs)
4153             self.add_artist(patch)
4154             return patch
4155 
4156         # input validation
4157         N = len(bxpstats)
4158         datashape_message = ("List of boxplot statistics and `{0}` "
4159                              "values must have same the length")
4160         # check position
4161         if positions is None:
4162             positions = list(range(1, N + 1))
4163         elif len(positions) != N:
4164             raise ValueError(datashape_message.format("positions"))
4165 
4166         positions = np.array(positions)
4167         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4168             raise TypeError("positions should be an iterable of numbers")
4169 
4170         # width
4171         if widths is None:
4172             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4173         elif np.isscalar(widths):
4174             widths = [widths] * N
4175         elif len(widths) != N:
4176             raise ValueError(datashape_message.format("widths"))
4177 
4178         # capwidth
4179         if capwidths is None:
4180             capwidths = 0.5 * np.array(widths)
4181         elif np.isscalar(capwidths):
4182             capwidths = [capwidths] * N
4183         elif len(capwidths) != N:
4184             raise ValueError(datashape_message.format("capwidths"))
4185 
4186         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4187                                                capwidths):
4188             # try to find a new label
4189             datalabels.append(stats.get('label', pos))
4190 
4191             # whisker coords
4192             whis_x = [pos, pos]
4193             whislo_y = [stats['q1'], stats['whislo']]
4194             whishi_y = [stats['q3'], stats['whishi']]
4195             # cap coords
4196             cap_left = pos - capwidth * 0.5
4197             cap_right = pos + capwidth * 0.5
4198             cap_x = [cap_left, cap_right]
4199             cap_lo = np.full(2, stats['whislo'])
4200             cap_hi = np.full(2, stats['whishi'])
4201             # box and median coords
4202             box_left = pos - width * 0.5
4203             box_right = pos + width * 0.5
4204             med_y = [stats['med'], stats['med']]
4205             # notched boxes
4206             if shownotches:
4207                 notch_left = pos - width * 0.25
4208                 notch_right = pos + width * 0.25
4209                 box_x = [box_left, box_right, box_right, notch_right,
4210                          box_right, box_right, box_left, box_left, notch_left,
4211                          box_left, box_left]
4212                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4213                          stats['med'], stats['cihi'], stats['q3'],
4214                          stats['q3'], stats['cihi'], stats['med'],
4215                          stats['cilo'], stats['q1']]
4216                 med_x = [notch_left, notch_right]
4217             # plain boxes
4218             else:
4219                 box_x = [box_left, box_right, box_right, box_left, box_left]
4220                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4221                          stats['q1']]
4222                 med_x = [box_left, box_right]
4223 
4224             # maybe draw the box
4225             if showbox:
4226                 do_box = do_patch if patch_artist else do_plot
4227                 boxes.append(do_box(box_x, box_y, **box_kw))
4228             # draw the whiskers
4229             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4230             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4231             # maybe draw the caps
4232             if showcaps:
4233                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4234                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4235             # draw the medians
4236             medians.append(do_plot(med_x, med_y, **median_kw))
4237             # maybe draw the means
4238             if showmeans:
4239                 if meanline:
4240                     means.append(do_plot(
4241                         [box_left, box_right], [stats['mean'], stats['mean']],
4242                         **mean_kw
4243                     ))
4244                 else:
4245                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4246             # maybe draw the fliers
4247             if showfliers:
4248                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4249                 flier_y = stats['fliers']
4250                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4251 
4252         if manage_ticks:
4253             axis_name = "x" if vert else "y"
4254             interval = getattr(self.dataLim, f"interval{axis_name}")
4255             axis = self._axis_map[axis_name]
4256             positions = axis.convert_units(positions)
4257             # The 0.5 additional padding ensures reasonable-looking boxes
4258             # even when drawing a single box.  We set the sticky edge to
4259             # prevent margins expansion, in order to match old behavior (back
4260             # when separate calls to boxplot() would completely reset the axis
4261             # limits regardless of what was drawn before).  The sticky edges
4262             # are attached to the median lines, as they are always present.
4263             interval[:] = (min(interval[0], min(positions) - .5),
4264                            max(interval[1], max(positions) + .5))
4265             for median, position in zip(medians, positions):
4266                 getattr(median.sticky_edges, axis_name).extend(
4267                     [position - .5, position + .5])
4268             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4269             locator = axis.get_major_locator()
4270             if not isinstance(axis.get_major_locator(),
4271                               mticker.FixedLocator):
4272                 locator = mticker.FixedLocator([])
4273                 axis.set_major_locator(locator)
4274             locator.locs = np.array([*locator.locs, *positions])
4275             formatter = axis.get_major_formatter()
4276             if not isinstance(axis.get_major_formatter(),
4277                               mticker.FixedFormatter):
4278                 formatter = mticker.FixedFormatter([])
4279                 axis.set_major_formatter(formatter)
4280             formatter.seq = [*formatter.seq, *datalabels]
4281 
4282             self._request_autoscale_view()
4283 
4284         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4285                     medians=medians, fliers=fliers, means=means)
4286 
4287     @staticmethod
4288     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4289                                   get_next_color_func):
4290         """
4291         Helper function to process color related arguments of `.Axes.scatter`.
4292 
4293         Argument precedence for facecolors:
4294 
4295         - c (if not None)
4296         - kwargs['facecolor']
4297         - kwargs['facecolors']
4298         - kwargs['color'] (==kwcolor)
4299         - 'b' if in classic mode else the result of ``get_next_color_func()``
4300 
4301         Argument precedence for edgecolors:
4302 
4303         - kwargs['edgecolor']
4304         - edgecolors (is an explicit kw argument in scatter())
4305         - kwargs['color'] (==kwcolor)
4306         - 'face' if not in classic mode else None
4307 
4308         Parameters
4309         ----------
4310         c : color or sequence or sequence of color or None
4311             See argument description of `.Axes.scatter`.
4312         edgecolors : color or sequence of color or {'face', 'none'} or None
4313             See argument description of `.Axes.scatter`.
4314         kwargs : dict
4315             Additional kwargs. If these keys exist, we pop and process them:
4316             'facecolors', 'facecolor', 'edgecolor', 'color'
4317             Note: The dict is modified by this function.
4318         xsize : int
4319             The size of the x and y arrays passed to `.Axes.scatter`.
4320         get_next_color_func : callable
4321             A callable that returns a color. This color is used as facecolor
4322             if no other color is provided.
4323 
4324             Note, that this is a function rather than a fixed color value to
4325             support conditional evaluation of the next color.  As of the
4326             current implementation obtaining the next color from the
4327             property cycle advances the cycle. This must only happen if we
4328             actually use the color, which will only be decided within this
4329             method.
4330 
4331         Returns
4332         -------
4333         c
4334             The input *c* if it was not *None*, else a color derived from the
4335             other inputs or defaults.
4336         colors : array(N, 4) or None
4337             The facecolors as RGBA values, or *None* if a colormap is used.
4338         edgecolors
4339             The edgecolor.
4340 
4341         """
4342         facecolors = kwargs.pop('facecolors', None)
4343         facecolors = kwargs.pop('facecolor', facecolors)
4344         edgecolors = kwargs.pop('edgecolor', edgecolors)
4345 
4346         kwcolor = kwargs.pop('color', None)
4347 
4348         if kwcolor is not None and c is not None:
4349             raise ValueError("Supply a 'c' argument or a 'color'"
4350                              " kwarg but not both; they differ but"
4351                              " their functionalities overlap.")
4352 
4353         if kwcolor is not None:
4354             try:
4355                 mcolors.to_rgba_array(kwcolor)
4356             except ValueError as err:
4357                 raise ValueError(
4358                     "'color' kwarg must be a color or sequence of color "
4359                     "specs.  For a sequence of values to be color-mapped, use "
4360                     "the 'c' argument instead.") from err
4361             if edgecolors is None:
4362                 edgecolors = kwcolor
4363             if facecolors is None:
4364                 facecolors = kwcolor
4365 
4366         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4367             edgecolors = mpl.rcParams['scatter.edgecolors']
4368 
4369         c_was_none = c is None
4370         if c is None:
4371             c = (facecolors if facecolors is not None
4372                  else "b" if mpl.rcParams['_internal.classic_mode']
4373                  else get_next_color_func())
4374         c_is_string_or_strings = (
4375             isinstance(c, str)
4376             or (np.iterable(c) and len(c) > 0
4377                 and isinstance(cbook._safe_first_finite(c), str)))
4378 
4379         def invalid_shape_exception(csize, xsize):
4380             return ValueError(
4381                 f"'c' argument has {csize} elements, which is inconsistent "
4382                 f"with 'x' and 'y' with size {xsize}.")
4383 
4384         c_is_mapped = False  # Unless proven otherwise below.
4385         valid_shape = True  # Unless proven otherwise below.
4386         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4387             try:  # First, does 'c' look suitable for value-mapping?
4388                 c = np.asanyarray(c, dtype=float)
4389             except ValueError:
4390                 pass  # Failed to convert to float array; must be color specs.
4391             else:
4392                 # handle the documented special case of a 2D array with 1
4393                 # row which as RGB(A) to broadcast.
4394                 if c.shape == (1, 4) or c.shape == (1, 3):
4395                     c_is_mapped = False
4396                     if c.size != xsize:
4397                         valid_shape = False
4398                 # If c can be either mapped values or an RGB(A) color, prefer
4399                 # the former if shapes match, the latter otherwise.
4400                 elif c.size == xsize:
4401                     c = c.ravel()
4402                     c_is_mapped = True
4403                 else:  # Wrong size; it must not be intended for mapping.
4404                     if c.shape in ((3,), (4,)):
4405                         _api.warn_external(
4406                             "*c* argument looks like a single numeric RGB or "
4407                             "RGBA sequence, which should be avoided as value-"
4408                             "mapping will have precedence in case its length "
4409                             "matches with *x* & *y*.  Please use the *color* "
4410                             "keyword-argument or provide a 2D array "
4411                             "with a single row if you intend to specify "
4412                             "the same RGB or RGBA value for all points.")
4413                     valid_shape = False
4414         if not c_is_mapped:
4415             try:  # Is 'c' acceptable as PathCollection facecolors?
4416                 colors = mcolors.to_rgba_array(c)
4417             except (TypeError, ValueError) as err:
4418                 if "RGBA values should be within 0-1 range" in str(err):
4419                     raise
4420                 else:
4421                     if not valid_shape:
4422                         raise invalid_shape_exception(c.size, xsize) from err
4423                     # Both the mapping *and* the RGBA conversion failed: pretty
4424                     # severe failure => one may appreciate a verbose feedback.
4425                     raise ValueError(
4426                         f"'c' argument must be a color, a sequence of colors, "
4427                         f"or a sequence of numbers, not {c!r}") from err
4428             else:
4429                 if len(colors) not in (0, 1, xsize):
4430                     # NB: remember that a single color is also acceptable.
4431                     # Besides *colors* will be an empty array if c == 'none'.
4432                     raise invalid_shape_exception(len(colors), xsize)
4433         else:
4434             colors = None  # use cmap, norm after collection is created
4435         return c, colors, edgecolors
4436 
4437     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4438                                      "edgecolors", "c", "facecolor",
4439                                      "facecolors", "color"],
4440                       label_namer="y")
4441     @_docstring.interpd
4442     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4443                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4444                 edgecolors=None, plotnonfinite=False, **kwargs):
4445         """
4446         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4447 
4448         Parameters
4449         ----------
4450         x, y : float or array-like, shape (n, )
4451             The data positions.
4452 
4453         s : float or array-like, shape (n, ), optional
4454             The marker size in points**2 (typographic points are 1/72 in.).
4455             Default is ``rcParams['lines.markersize'] ** 2``.
4456 
4457             The linewidth and edgecolor can visually interact with the marker
4458             size, and can lead to artifacts if the marker size is smaller than
4459             the linewidth.
4460 
4461             If the linewidth is greater than 0 and the edgecolor is anything
4462             but *'none'*, then the effective size of the marker will be
4463             increased by half the linewidth because the stroke will be centered
4464             on the edge of the shape.
4465 
4466             To eliminate the marker edge either set *linewidth=0* or
4467             *edgecolor='none'*.
4468 
4469         c : array-like or list of colors or color, optional
4470             The marker colors. Possible values:
4471 
4472             - A scalar or sequence of n numbers to be mapped to colors using
4473               *cmap* and *norm*.
4474             - A 2D array in which the rows are RGB or RGBA.
4475             - A sequence of colors of length n.
4476             - A single color format string.
4477 
4478             Note that *c* should not be a single numeric RGB or RGBA sequence
4479             because that is indistinguishable from an array of values to be
4480             colormapped. If you want to specify the same RGB or RGBA value for
4481             all points, use a 2D array with a single row.  Otherwise,
4482             value-matching will have precedence in case of a size matching with
4483             *x* and *y*.
4484 
4485             If you wish to specify a single color for all points
4486             prefer the *color* keyword argument.
4487 
4488             Defaults to `None`. In that case the marker color is determined
4489             by the value of *color*, *facecolor* or *facecolors*. In case
4490             those are not specified or `None`, the marker color is determined
4491             by the next color of the ``Axes``' current "shape and fill" color
4492             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4493 
4494         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4495             The marker style. *marker* can be either an instance of the class
4496             or the text shorthand for a particular marker.
4497             See :mod:`matplotlib.markers` for more information about marker
4498             styles.
4499 
4500         %(cmap_doc)s
4501 
4502             This parameter is ignored if *c* is RGB(A).
4503 
4504         %(norm_doc)s
4505 
4506             This parameter is ignored if *c* is RGB(A).
4507 
4508         %(vmin_vmax_doc)s
4509 
4510             This parameter is ignored if *c* is RGB(A).
4511 
4512         alpha : float, default: None
4513             The alpha blending value, between 0 (transparent) and 1 (opaque).
4514 
4515         linewidths : float or array-like, default: :rc:`lines.linewidth`
4516             The linewidth of the marker edges. Note: The default *edgecolors*
4517             is 'face'. You may want to change this as well.
4518 
4519         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4520 default: :rc:`scatter.edgecolors`
4521             The edge color of the marker. Possible values:
4522 
4523             - 'face': The edge color will always be the same as the face color.
4524             - 'none': No patch boundary will be drawn.
4525             - A color or sequence of colors.
4526 
4527             For non-filled markers, *edgecolors* is ignored. Instead, the color
4528             is determined like with 'face', i.e. from *c*, *colors*, or
4529             *facecolors*.
4530 
4531         plotnonfinite : bool, default: False
4532             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4533             or ``nan``). If ``True`` the points are drawn with the *bad*
4534             colormap color (see `.Colormap.set_bad`).
4535 
4536         Returns
4537         -------
4538         `~matplotlib.collections.PathCollection`
4539 
4540         Other Parameters
4541         ----------------
4542         data : indexable object, optional
4543             DATA_PARAMETER_PLACEHOLDER
4544         **kwargs : `~matplotlib.collections.Collection` properties
4545 
4546         See Also
4547         --------
4548         plot : To plot scatter plots when markers are identical in size and
4549             color.
4550 
4551         Notes
4552         -----
4553         * The `.plot` function will be faster for scatterplots where markers
4554           don't vary in size or color.
4555 
4556         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4557           case all masks will be combined and only unmasked points will be
4558           plotted.
4559 
4560         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4561           may be input as N-D arrays, but within scatter they will be
4562           flattened. The exception is *c*, which will be flattened only if its
4563           size matches the size of *x* and *y*.
4564 
4565         """
4566         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4567         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4568         # np.ma.ravel yields an ndarray, not a masked array,
4569         # unless its argument is a masked array.
4570         x = np.ma.ravel(x)
4571         y = np.ma.ravel(y)
4572         if x.size != y.size:
4573             raise ValueError("x and y must be the same size")
4574 
4575         if s is None:
4576             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4577                  mpl.rcParams['lines.markersize'] ** 2.0)
4578         s = np.ma.ravel(s)
4579         if (len(s) not in (1, x.size) or
4580                 (not np.issubdtype(s.dtype, np.floating) and
4581                  not np.issubdtype(s.dtype, np.integer))):
4582             raise ValueError(
4583                 "s must be a scalar, "
4584                 "or float array-like with the same size as x and y")
4585 
4586         # get the original edgecolor the user passed before we normalize
4587         orig_edgecolor = edgecolors
4588         if edgecolors is None:
4589             orig_edgecolor = kwargs.get('edgecolor', None)
4590         c, colors, edgecolors = \
4591             self._parse_scatter_color_args(
4592                 c, edgecolors, kwargs, x.size,
4593                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4594 
4595         if plotnonfinite and colors is None:
4596             c = np.ma.masked_invalid(c)
4597             x, y, s, edgecolors, linewidths = \
4598                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4599         else:
4600             x, y, s, c, colors, edgecolors, linewidths = \
4601                 cbook._combine_masks(
4602                     x, y, s, c, colors, edgecolors, linewidths)
4603         # Unmask edgecolors if it was actually a single RGB or RGBA.
4604         if (x.size in (3, 4)
4605                 and np.ma.is_masked(edgecolors)
4606                 and not np.ma.is_masked(orig_edgecolor)):
4607             edgecolors = edgecolors.data
4608 
4609         scales = s   # Renamed for readability below.
4610 
4611         # load default marker from rcParams
4612         if marker is None:
4613             marker = mpl.rcParams['scatter.marker']
4614 
4615         if isinstance(marker, mmarkers.MarkerStyle):
4616             marker_obj = marker
4617         else:
4618             marker_obj = mmarkers.MarkerStyle(marker)
4619 
4620         path = marker_obj.get_path().transformed(
4621             marker_obj.get_transform())
4622         if not marker_obj.is_filled():
4623             if orig_edgecolor is not None:
4624                 _api.warn_external(
4625                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4626                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4627                     "ignoring the edgecolor in favor of the facecolor.  This "
4628                     "behavior may change in the future."
4629                 )
4630             # We need to handle markers that can not be filled (like
4631             # '+' and 'x') differently than markers that can be
4632             # filled, but have their fillstyle set to 'none'.  This is
4633             # to get:
4634             #
4635             #  - respecting the fillestyle if set
4636             #  - maintaining back-compatibility for querying the facecolor of
4637             #    the un-fillable markers.
4638             #
4639             # While not an ideal situation, but is better than the
4640             # alternatives.
4641             if marker_obj.get_fillstyle() == 'none':
4642                 # promote the facecolor to be the edgecolor
4643                 edgecolors = colors
4644                 # set the facecolor to 'none' (at the last chance) because
4645                 # we can not fill a path if the facecolor is non-null
4646                 # (which is defendable at the renderer level).
4647                 colors = 'none'
4648             else:
4649                 # if we are not nulling the face color we can do this
4650                 # simpler
4651                 edgecolors = 'face'
4652 
4653             if linewidths is None:
4654                 linewidths = mpl.rcParams['lines.linewidth']
4655             elif np.iterable(linewidths):
4656                 linewidths = [
4657                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4658                     for lw in linewidths]
4659 
4660         offsets = np.ma.column_stack([x, y])
4661 
4662         collection = mcoll.PathCollection(
4663             (path,), scales,
4664             facecolors=colors,
4665             edgecolors=edgecolors,
4666             linewidths=linewidths,
4667             offsets=offsets,
4668             offset_transform=kwargs.pop('transform', self.transData),
4669             alpha=alpha,
4670         )
4671         collection.set_transform(mtransforms.IdentityTransform())
4672         if colors is None:
4673             collection.set_array(c)
4674             collection.set_cmap(cmap)
4675             collection.set_norm(norm)
4676             collection._scale_norm(norm, vmin, vmax)
4677         else:
4678             extra_kwargs = {
4679                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4680                     }
4681             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4682             if any(extra_keys):
4683                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4684                 _api.warn_external(
4685                     "No data for colormapping provided via 'c'. "
4686                     f"Parameters {keys_str} will be ignored")
4687         collection._internal_update(kwargs)
4688 
4689         # Classic mode only:
4690         # ensure there are margins to allow for the
4691         # finite size of the symbols.  In v2.x, margins
4692         # are present by default, so we disable this
4693         # scatter-specific override.
4694         if mpl.rcParams['_internal.classic_mode']:
4695             if self._xmargin < 0.05 and x.size > 0:
4696                 self.set_xmargin(0.05)
4697             if self._ymargin < 0.05 and x.size > 0:
4698                 self.set_ymargin(0.05)
4699 
4700         self.add_collection(collection)
4701         self._request_autoscale_view()
4702 
4703         return collection
4704 
4705     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4706     @_docstring.dedent_interpd
4707     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4708                xscale='linear', yscale='linear', extent=None,
4709                cmap=None, norm=None, vmin=None, vmax=None,
4710                alpha=None, linewidths=None, edgecolors='face',
4711                reduce_C_function=np.mean, mincnt=None, marginals=False,
4712                **kwargs):
4713         """
4714         Make a 2D hexagonal binning plot of points *x*, *y*.
4715 
4716         If *C* is *None*, the value of the hexagon is determined by the number
4717         of points in the hexagon. Otherwise, *C* specifies values at the
4718         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4719         using *reduce_C_function*.
4720 
4721         Parameters
4722         ----------
4723         x, y : array-like
4724             The data positions. *x* and *y* must be of the same length.
4725 
4726         C : array-like, optional
4727             If given, these values are accumulated in the bins. Otherwise,
4728             every point has a value of 1. Must be of the same length as *x*
4729             and *y*.
4730 
4731         gridsize : int or (int, int), default: 100
4732             If a single int, the number of hexagons in the *x*-direction.
4733             The number of hexagons in the *y*-direction is chosen such that
4734             the hexagons are approximately regular.
4735 
4736             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4737             in the *x*-direction and the *y*-direction. In the
4738             *y*-direction, counting is done along vertically aligned
4739             hexagons, not along the zig-zag chains of hexagons; see the
4740             following illustration.
4741 
4742             .. plot::
4743 
4744                import numpy
4745                import matplotlib.pyplot as plt
4746 
4747                np.random.seed(19680801)
4748                n= 300
4749                x = np.random.standard_normal(n)
4750                y = np.random.standard_normal(n)
4751 
4752                fig, ax = plt.subplots(figsize=(4, 4))
4753                h = ax.hexbin(x, y, gridsize=(5, 3))
4754                hx, hy = h.get_offsets().T
4755                ax.plot(hx[24::3], hy[24::3], 'ro-')
4756                ax.plot(hx[-3:], hy[-3:], 'ro-')
4757                ax.set_title('gridsize=(5, 3)')
4758                ax.axis('off')
4759 
4760             To get approximately regular hexagons, choose
4761             :math:`n_x = \\sqrt{3}\\,n_y`.
4762 
4763         bins : 'log' or int or sequence, default: None
4764             Discretization of the hexagon values.
4765 
4766             - If *None*, no binning is applied; the color of each hexagon
4767               directly corresponds to its count value.
4768             - If 'log', use a logarithmic scale for the colormap.
4769               Internally, :math:`log_{10}(i+1)` is used to determine the
4770               hexagon color. This is equivalent to ``norm=LogNorm()``.
4771             - If an integer, divide the counts in the specified number
4772               of bins, and color the hexagons accordingly.
4773             - If a sequence of values, the values of the lower bound of
4774               the bins to be used.
4775 
4776         xscale : {'linear', 'log'}, default: 'linear'
4777             Use a linear or log10 scale on the horizontal axis.
4778 
4779         yscale : {'linear', 'log'}, default: 'linear'
4780             Use a linear or log10 scale on the vertical axis.
4781 
4782         mincnt : int > 0, default: *None*
4783             If not *None*, only display cells with more than *mincnt*
4784             number of points in the cell.
4785 
4786         marginals : bool, default: *False*
4787             If marginals is *True*, plot the marginal density as
4788             colormapped rectangles along the bottom of the x-axis and
4789             left of the y-axis.
4790 
4791         extent : 4-tuple of float, default: *None*
4792             The limits of the bins (xmin, xmax, ymin, ymax).
4793             The default assigns the limits based on
4794             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4795 
4796             If *xscale* or *yscale* is set to 'log', the limits are
4797             expected to be the exponent for a power of 10. E.g. for
4798             x-limits of 1 and 50 in 'linear' scale and y-limits
4799             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4800 
4801         Returns
4802         -------
4803         `~matplotlib.collections.PolyCollection`
4804             A `.PolyCollection` defining the hexagonal bins.
4805 
4806             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4807               the x, y positions of the M hexagon centers.
4808             - `.PolyCollection.get_array` contains the values of the M
4809               hexagons.
4810 
4811             If *marginals* is *True*, horizontal
4812             bar and vertical bar (both PolyCollections) will be attached
4813             to the return collection as attributes *hbar* and *vbar*.
4814 
4815         Other Parameters
4816         ----------------
4817         %(cmap_doc)s
4818 
4819         %(norm_doc)s
4820 
4821         %(vmin_vmax_doc)s
4822 
4823         alpha : float between 0 and 1, optional
4824             The alpha blending value, between 0 (transparent) and 1 (opaque).
4825 
4826         linewidths : float, default: *None*
4827             If *None*, defaults to 1.0.
4828 
4829         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4830             The color of the hexagon edges. Possible values are:
4831 
4832             - 'face': Draw the edges in the same color as the fill color.
4833             - 'none': No edges are drawn. This can sometimes lead to unsightly
4834               unpainted pixels between the hexagons.
4835             - *None*: Draw outlines in the default color.
4836             - An explicit color.
4837 
4838         reduce_C_function : callable, default: `numpy.mean`
4839             The function to aggregate *C* within the bins. It is ignored if
4840             *C* is not given. This must have the signature::
4841 
4842                 def reduce_C_function(C: array) -> float
4843 
4844             Commonly used functions are:
4845 
4846             - `numpy.mean`: average of the points
4847             - `numpy.sum`: integral of the point values
4848             - `numpy.amax`: value taken from the largest point
4849 
4850         data : indexable object, optional
4851             DATA_PARAMETER_PLACEHOLDER
4852 
4853         **kwargs : `~matplotlib.collections.PolyCollection` properties
4854             All other keyword arguments are passed on to `.PolyCollection`:
4855 
4856             %(PolyCollection:kwdoc)s
4857 
4858         See Also
4859         --------
4860         hist2d : 2D histogram rectangular bins
4861         """
4862         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4863 
4864         x, y, C = cbook.delete_masked_points(x, y, C)
4865 
4866         # Set the size of the hexagon grid
4867         if np.iterable(gridsize):
4868             nx, ny = gridsize
4869         else:
4870             nx = gridsize
4871             ny = int(nx / math.sqrt(3))
4872         # Count the number of data in each hexagon
4873         x = np.asarray(x, float)
4874         y = np.asarray(y, float)
4875 
4876         # Will be log()'d if necessary, and then rescaled.
4877         tx = x
4878         ty = y
4879 
4880         if xscale == 'log':
4881             if np.any(x <= 0.0):
4882                 raise ValueError("x contains non-positive values, so can not "
4883                                  "be log-scaled")
4884             tx = np.log10(tx)
4885         if yscale == 'log':
4886             if np.any(y <= 0.0):
4887                 raise ValueError("y contains non-positive values, so can not "
4888                                  "be log-scaled")
4889             ty = np.log10(ty)
4890         if extent is not None:
4891             xmin, xmax, ymin, ymax = extent
4892         else:
4893             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4894             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4895 
4896             # to avoid issues with singular data, expand the min/max pairs
4897             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4898             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4899 
4900         nx1 = nx + 1
4901         ny1 = ny + 1
4902         nx2 = nx
4903         ny2 = ny
4904         n = nx1 * ny1 + nx2 * ny2
4905 
4906         # In the x-direction, the hexagons exactly cover the region from
4907         # xmin to xmax. Need some padding to avoid roundoff errors.
4908         padding = 1.e-9 * (xmax - xmin)
4909         xmin -= padding
4910         xmax += padding
4911         sx = (xmax - xmin) / nx
4912         sy = (ymax - ymin) / ny
4913         # Positions in hexagon index coordinates.
4914         ix = (tx - xmin) / sx
4915         iy = (ty - ymin) / sy
4916         ix1 = np.round(ix).astype(int)
4917         iy1 = np.round(iy).astype(int)
4918         ix2 = np.floor(ix).astype(int)
4919         iy2 = np.floor(iy).astype(int)
4920         # flat indices, plus one so that out-of-range points go to position 0.
4921         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4922                       ix1 * ny1 + iy1 + 1, 0)
4923         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4924                       ix2 * ny2 + iy2 + 1, 0)
4925 
4926         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4927         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4928         bdist = (d1 < d2)
4929 
4930         if C is None:  # [1:] drops out-of-range points.
4931             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4932             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4933             accum = np.concatenate([counts1, counts2]).astype(float)
4934             if mincnt is not None:
4935                 accum[accum < mincnt] = np.nan
4936             C = np.ones(len(x))
4937         else:
4938             # store the C values in a list per hexagon index
4939             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4940             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4941             for i in range(len(x)):
4942                 if bdist[i]:
4943                     Cs_at_i1[i1[i]].append(C[i])
4944                 else:
4945                     Cs_at_i2[i2[i]].append(C[i])
4946             if mincnt is None:
4947                 mincnt = 0
4948             accum = np.array(
4949                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4950                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4951                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4952                 float)
4953 
4954         good_idxs = ~np.isnan(accum)
4955 
4956         offsets = np.zeros((n, 2), float)
4957         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4958         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4959         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4960         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4961         offsets[:, 0] *= sx
4962         offsets[:, 1] *= sy
4963         offsets[:, 0] += xmin
4964         offsets[:, 1] += ymin
4965         # remove accumulation bins with no data
4966         offsets = offsets[good_idxs, :]
4967         accum = accum[good_idxs]
4968 
4969         polygon = [sx, sy / 3] * np.array(
4970             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
4971 
4972         if linewidths is None:
4973             linewidths = [1.0]
4974 
4975         if xscale == 'log' or yscale == 'log':
4976             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
4977             if xscale == 'log':
4978                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
4979                 xmin = 10.0 ** xmin
4980                 xmax = 10.0 ** xmax
4981                 self.set_xscale(xscale)
4982             if yscale == 'log':
4983                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
4984                 ymin = 10.0 ** ymin
4985                 ymax = 10.0 ** ymax
4986                 self.set_yscale(yscale)
4987             collection = mcoll.PolyCollection(
4988                 polygons,
4989                 edgecolors=edgecolors,
4990                 linewidths=linewidths,
4991                 )
4992         else:
4993             collection = mcoll.PolyCollection(
4994                 [polygon],
4995                 edgecolors=edgecolors,
4996                 linewidths=linewidths,
4997                 offsets=offsets,
4998                 offset_transform=mtransforms.AffineDeltaTransform(
4999                     self.transData),
5000             )
5001 
5002         # Set normalizer if bins is 'log'
5003         if bins == 'log':
5004             if norm is not None:
5005                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5006                                    f"can be supplied, ignoring bins={bins}")
5007             else:
5008                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5009                 vmin = vmax = None
5010             bins = None
5011 
5012         # autoscale the norm with current accum values if it hasn't been set
5013         if norm is not None:
5014             if norm.vmin is None and norm.vmax is None:
5015                 norm.autoscale(accum)
5016 
5017         if bins is not None:
5018             if not np.iterable(bins):
5019                 minimum, maximum = min(accum), max(accum)
5020                 bins -= 1  # one less edge than bins
5021                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5022             bins = np.sort(bins)
5023             accum = bins.searchsorted(accum)
5024 
5025         collection.set_array(accum)
5026         collection.set_cmap(cmap)
5027         collection.set_norm(norm)
5028         collection.set_alpha(alpha)
5029         collection._internal_update(kwargs)
5030         collection._scale_norm(norm, vmin, vmax)
5031 
5032         corners = ((xmin, ymin), (xmax, ymax))
5033         self.update_datalim(corners)
5034         self._request_autoscale_view(tight=True)
5035 
5036         # add the collection last
5037         self.add_collection(collection, autolim=False)
5038         if not marginals:
5039             return collection
5040 
5041         # Process marginals
5042         bars = []
5043         for zname, z, zmin, zmax, zscale, nbins in [
5044                 ("x", x, xmin, xmax, xscale, nx),
5045                 ("y", y, ymin, ymax, yscale, 2 * ny),
5046         ]:
5047 
5048             if zscale == "log":
5049                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5050             else:
5051                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5052 
5053             verts = np.empty((nbins, 4, 2))
5054             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5055             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5056             verts[:, 0, 1] = verts[:, 3, 1] = .00
5057             verts[:, 1, 1] = verts[:, 2, 1] = .05
5058             if zname == "y":
5059                 verts = verts[:, :, ::-1]  # Swap x and y.
5060 
5061             # Sort z-values into bins defined by bin_edges.
5062             bin_idxs = np.searchsorted(bin_edges, z) - 1
5063             values = np.empty(nbins)
5064             for i in range(nbins):
5065                 # Get C-values for each bin, and compute bin value with
5066                 # reduce_C_function.
5067                 ci = C[bin_idxs == i]
5068                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5069 
5070             mask = ~np.isnan(values)
5071             verts = verts[mask]
5072             values = values[mask]
5073 
5074             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5075             bar = mcoll.PolyCollection(
5076                 verts, transform=trans, edgecolors="face")
5077             bar.set_array(values)
5078             bar.set_cmap(cmap)
5079             bar.set_norm(norm)
5080             bar.set_alpha(alpha)
5081             bar._internal_update(kwargs)
5082             bars.append(self.add_collection(bar, autolim=False))
5083 
5084         collection.hbar, collection.vbar = bars
5085 
5086         def on_changed(collection):
5087             collection.hbar.set_cmap(collection.get_cmap())
5088             collection.hbar.set_cmap(collection.get_cmap())
5089             collection.vbar.set_clim(collection.get_clim())
5090             collection.vbar.set_clim(collection.get_clim())
5091 
5092         collection.callbacks.connect('changed', on_changed)
5093 
5094         return collection
5095 
5096     @_docstring.dedent_interpd
5097     def arrow(self, x, y, dx, dy, **kwargs):
5098         """
5099         Add an arrow to the Axes.
5100 
5101         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5102 
5103         Parameters
5104         ----------
5105         %(FancyArrow)s
5106 
5107         Returns
5108         -------
5109         `.FancyArrow`
5110             The created `.FancyArrow` object.
5111 
5112         Notes
5113         -----
5114         The resulting arrow is affected by the Axes aspect ratio and limits.
5115         This may produce an arrow whose head is not square with its stem. To
5116         create an arrow whose head is square with its stem,
5117         use :meth:`annotate` for example:
5118 
5119         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5120         ...             arrowprops=dict(arrowstyle="->"))
5121 
5122         """
5123         # Strip away units for the underlying patch since units
5124         # do not make sense to most patch-like code
5125         x = self.convert_xunits(x)
5126         y = self.convert_yunits(y)
5127         dx = self.convert_xunits(dx)
5128         dy = self.convert_yunits(dy)
5129 
5130         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5131         self.add_patch(a)
5132         self._request_autoscale_view()
5133         return a
5134 
5135     @_docstring.copy(mquiver.QuiverKey.__init__)
5136     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5137         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5138         self.add_artist(qk)
5139         return qk
5140 
5141     # Handle units for x and y, if they've been passed
5142     def _quiver_units(self, args, kwargs):
5143         if len(args) > 3:
5144             x, y = args[0:2]
5145             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5146             return (x, y) + args[2:]
5147         return args
5148 
5149     # args can be a combination of X, Y, U, V, C and all should be replaced
5150     @_preprocess_data()
5151     @_docstring.dedent_interpd
5152     def quiver(self, *args, **kwargs):
5153         """%(quiver_doc)s"""
5154         # Make sure units are handled for x and y values
5155         args = self._quiver_units(args, kwargs)
5156         q = mquiver.Quiver(self, *args, **kwargs)
5157         self.add_collection(q, autolim=True)
5158         self._request_autoscale_view()
5159         return q
5160 
5161     # args can be some combination of X, Y, U, V, C and all should be replaced
5162     @_preprocess_data()
5163     @_docstring.dedent_interpd
5164     def barbs(self, *args, **kwargs):
5165         """%(barbs_doc)s"""
5166         # Make sure units are handled for x and y values
5167         args = self._quiver_units(args, kwargs)
5168         b = mquiver.Barbs(self, *args, **kwargs)
5169         self.add_collection(b, autolim=True)
5170         self._request_autoscale_view()
5171         return b
5172 
5173     # Uses a custom implementation of data-kwarg handling in
5174     # _process_plot_var_args.
5175     def fill(self, *args, data=None, **kwargs):
5176         """
5177         Plot filled polygons.
5178 
5179         Parameters
5180         ----------
5181         *args : sequence of x, y, [color]
5182             Each polygon is defined by the lists of *x* and *y* positions of
5183             its nodes, optionally followed by a *color* specifier. See
5184             :mod:`matplotlib.colors` for supported color specifiers. The
5185             standard color cycle is used for polygons without a color
5186             specifier.
5187 
5188             You can plot multiple polygons by providing multiple *x*, *y*,
5189             *[color]* groups.
5190 
5191             For example, each of the following is legal::
5192 
5193                 ax.fill(x, y)                    # a polygon with default color
5194                 ax.fill(x, y, "b")               # a blue polygon
5195                 ax.fill(x, y, x2, y2)            # two polygons
5196                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5197 
5198         data : indexable object, optional
5199             An object with labelled data. If given, provide the label names to
5200             plot in *x* and *y*, e.g.::
5201 
5202                 ax.fill("time", "signal",
5203                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5204 
5205         Returns
5206         -------
5207         list of `~matplotlib.patches.Polygon`
5208 
5209         Other Parameters
5210         ----------------
5211         **kwargs : `~matplotlib.patches.Polygon` properties
5212 
5213         Notes
5214         -----
5215         Use :meth:`fill_between` if you would like to fill the region between
5216         two curves.
5217         """
5218         # For compatibility(!), get aliases from Line2D rather than Patch.
5219         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5220         # _get_patches_for_fill returns a generator, convert it to a list.
5221         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5222         for poly in patches:
5223             self.add_patch(poly)
5224         self._request_autoscale_view()
5225         return patches
5226 
5227     def _fill_between_x_or_y(
5228             self, ind_dir, ind, dep1, dep2=0, *,
5229             where=None, interpolate=False, step=None, **kwargs):
5230         # Common implementation between fill_between (*ind_dir*="x") and
5231         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5232         # *dep* the dependent variable.  The docstring below is interpolated
5233         # to generate both methods' docstrings.
5234         """
5235         Fill the area between two {dir} curves.
5236 
5237         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5238         *{dep}2*).  This creates one or multiple polygons describing the filled
5239         area.
5240 
5241         You may exclude some {dir} sections from filling using *where*.
5242 
5243         By default, the edges connect the given points directly.  Use *step*
5244         if the filling should be a step function, i.e. constant in between
5245         *{ind}*.
5246 
5247         Parameters
5248         ----------
5249         {ind} : array (length N)
5250             The {ind} coordinates of the nodes defining the curves.
5251 
5252         {dep}1 : array (length N) or scalar
5253             The {dep} coordinates of the nodes defining the first curve.
5254 
5255         {dep}2 : array (length N) or scalar, default: 0
5256             The {dep} coordinates of the nodes defining the second curve.
5257 
5258         where : array of bool (length N), optional
5259             Define *where* to exclude some {dir} regions from being filled.
5260             The filled regions are defined by the coordinates ``{ind}[where]``.
5261             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5262             ``where[i] and where[i+1]``.  Note that this definition implies
5263             that an isolated *True* value between two *False* values in *where*
5264             will not result in filling.  Both sides of the *True* position
5265             remain unfilled due to the adjacent *False* values.
5266 
5267         interpolate : bool, default: False
5268             This option is only relevant if *where* is used and the two curves
5269             are crossing each other.
5270 
5271             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5272             similar.  By default, the nodes of the polygon defining the filled
5273             region will only be placed at the positions in the *{ind}* array.
5274             Such a polygon cannot describe the above semantics close to the
5275             intersection.  The {ind}-sections containing the intersection are
5276             simply clipped.
5277 
5278             Setting *interpolate* to *True* will calculate the actual
5279             intersection point and extend the filled region up to this point.
5280 
5281         step : {{'pre', 'post', 'mid'}}, optional
5282             Define *step* if the filling should be a step function,
5283             i.e. constant in between *{ind}*.  The value determines where the
5284             step will occur:
5285 
5286             - 'pre': The y value is continued constantly to the left from
5287               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5288               value ``y[i]``.
5289             - 'post': The y value is continued constantly to the right from
5290               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5291               value ``y[i]``.
5292             - 'mid': Steps occur half-way between the *x* positions.
5293 
5294         Returns
5295         -------
5296         `.PolyCollection`
5297             A `.PolyCollection` containing the plotted polygons.
5298 
5299         Other Parameters
5300         ----------------
5301         data : indexable object, optional
5302             DATA_PARAMETER_PLACEHOLDER
5303 
5304         **kwargs
5305             All other keyword arguments are passed on to `.PolyCollection`.
5306             They control the `.Polygon` properties:
5307 
5308             %(PolyCollection:kwdoc)s
5309 
5310         See Also
5311         --------
5312         fill_between : Fill between two sets of y-values.
5313         fill_betweenx : Fill between two sets of x-values.
5314         """
5315 
5316         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5317 
5318         if not mpl.rcParams["_internal.classic_mode"]:
5319             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5320             if not any(c in kwargs for c in ("color", "facecolor")):
5321                 kwargs["facecolor"] = \
5322                     self._get_patches_for_fill.get_next_color()
5323 
5324         # Handle united data, such as dates
5325         ind, dep1, dep2 = map(
5326             ma.masked_invalid, self._process_unit_info(
5327                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5328 
5329         for name, array in [
5330                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5331             if array.ndim > 1:
5332                 raise ValueError(f"{name!r} is not 1-dimensional")
5333 
5334         if where is None:
5335             where = True
5336         else:
5337             where = np.asarray(where, dtype=bool)
5338             if where.size != ind.size:
5339                 raise ValueError(f"where size ({where.size}) does not match "
5340                                  f"{ind_dir} size ({ind.size})")
5341         where = where & ~functools.reduce(
5342             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5343 
5344         ind, dep1, dep2 = np.broadcast_arrays(
5345             np.atleast_1d(ind), dep1, dep2, subok=True)
5346 
5347         polys = []
5348         for idx0, idx1 in cbook.contiguous_regions(where):
5349             indslice = ind[idx0:idx1]
5350             dep1slice = dep1[idx0:idx1]
5351             dep2slice = dep2[idx0:idx1]
5352             if step is not None:
5353                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5354                 indslice, dep1slice, dep2slice = \
5355                     step_func(indslice, dep1slice, dep2slice)
5356 
5357             if not len(indslice):
5358                 continue
5359 
5360             N = len(indslice)
5361             pts = np.zeros((2 * N + 2, 2))
5362 
5363             if interpolate:
5364                 def get_interp_point(idx):
5365                     im1 = max(idx - 1, 0)
5366                     ind_values = ind[im1:idx+1]
5367                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5368                     dep1_values = dep1[im1:idx+1]
5369 
5370                     if len(diff_values) == 2:
5371                         if np.ma.is_masked(diff_values[1]):
5372                             return ind[im1], dep1[im1]
5373                         elif np.ma.is_masked(diff_values[0]):
5374                             return ind[idx], dep1[idx]
5375 
5376                     diff_order = diff_values.argsort()
5377                     diff_root_ind = np.interp(
5378                         0, diff_values[diff_order], ind_values[diff_order])
5379                     ind_order = ind_values.argsort()
5380                     diff_root_dep = np.interp(
5381                         diff_root_ind,
5382                         ind_values[ind_order], dep1_values[ind_order])
5383                     return diff_root_ind, diff_root_dep
5384 
5385                 start = get_interp_point(idx0)
5386                 end = get_interp_point(idx1)
5387             else:
5388                 # Handle scalar dep2 (e.g. 0): the fill should go all
5389                 # the way down to 0 even if none of the dep1 sample points do.
5390                 start = indslice[0], dep2slice[0]
5391                 end = indslice[-1], dep2slice[-1]
5392 
5393             pts[0] = start
5394             pts[N + 1] = end
5395 
5396             pts[1:N+1, 0] = indslice
5397             pts[1:N+1, 1] = dep1slice
5398             pts[N+2:, 0] = indslice[::-1]
5399             pts[N+2:, 1] = dep2slice[::-1]
5400 
5401             if ind_dir == "y":
5402                 pts = pts[:, ::-1]
5403 
5404             polys.append(pts)
5405 
5406         collection = mcoll.PolyCollection(polys, **kwargs)
5407 
5408         # now update the datalim and autoscale
5409         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5410                             np.column_stack([ind[where], dep2[where]])])
5411         if ind_dir == "y":
5412             pts = pts[:, ::-1]
5413         self.update_datalim(pts, updatex=True, updatey=True)
5414         self.add_collection(collection, autolim=False)
5415         self._request_autoscale_view()
5416         return collection
5417 
5418     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5419                      step=None, **kwargs):
5420         return self._fill_between_x_or_y(
5421             "x", x, y1, y2,
5422             where=where, interpolate=interpolate, step=step, **kwargs)
5423 
5424     if _fill_between_x_or_y.__doc__:
5425         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5426             dir="horizontal", ind="x", dep="y"
5427         )
5428     fill_between = _preprocess_data(
5429         _docstring.dedent_interpd(fill_between),
5430         replace_names=["x", "y1", "y2", "where"])
5431 
5432     def fill_betweenx(self, y, x1, x2=0, where=None,
5433                       step=None, interpolate=False, **kwargs):
5434         return self._fill_between_x_or_y(
5435             "y", y, x1, x2,
5436             where=where, interpolate=interpolate, step=step, **kwargs)
5437 
5438     if _fill_between_x_or_y.__doc__:
5439         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5440             dir="vertical", ind="y", dep="x"
5441         )
5442     fill_betweenx = _preprocess_data(
5443         _docstring.dedent_interpd(fill_betweenx),
5444         replace_names=["y", "x1", "x2", "where"])
5445 
5446     #### plotting z(x, y): imshow, pcolor and relatives, contour
5447 
5448     @_preprocess_data()
5449     @_docstring.interpd
5450     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5451                interpolation=None, alpha=None,
5452                vmin=None, vmax=None, origin=None, extent=None,
5453                interpolation_stage=None, filternorm=True, filterrad=4.0,
5454                resample=None, url=None, **kwargs):
5455         """
5456         Display data as an image, i.e., on a 2D regular raster.
5457 
5458         The input may either be actual RGB(A) data, or 2D scalar data, which
5459         will be rendered as a pseudocolor image. For displaying a grayscale
5460         image set up the colormapping using the parameters
5461         ``cmap='gray', vmin=0, vmax=255``.
5462 
5463         The number of pixels used to render an image is set by the Axes size
5464         and the *dpi* of the figure. This can lead to aliasing artifacts when
5465         the image is resampled because the displayed image size will usually
5466         not match the size of *X* (see
5467         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5468         The resampling can be controlled via the *interpolation* parameter
5469         and/or :rc:`image.interpolation`.
5470 
5471         Parameters
5472         ----------
5473         X : array-like or PIL image
5474             The image data. Supported array shapes are:
5475 
5476             - (M, N): an image with scalar data. The values are mapped to
5477               colors using normalization and a colormap. See parameters *norm*,
5478               *cmap*, *vmin*, *vmax*.
5479             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5480             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5481               i.e. including transparency.
5482 
5483             The first two dimensions (M, N) define the rows and columns of
5484             the image.
5485 
5486             Out-of-range RGB(A) values are clipped.
5487 
5488         %(cmap_doc)s
5489 
5490             This parameter is ignored if *X* is RGB(A).
5491 
5492         %(norm_doc)s
5493 
5494             This parameter is ignored if *X* is RGB(A).
5495 
5496         %(vmin_vmax_doc)s
5497 
5498             This parameter is ignored if *X* is RGB(A).
5499 
5500         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5501             The aspect ratio of the Axes.  This parameter is particularly
5502             relevant for images since it determines whether data pixels are
5503             square.
5504 
5505             This parameter is a shortcut for explicitly calling
5506             `.Axes.set_aspect`. See there for further details.
5507 
5508             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5509               (unless pixel sizes are explicitly made non-square in data
5510               coordinates using *extent*).
5511             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5512               that the data fit in the Axes. In general, this will result in
5513               non-square pixels.
5514 
5515         interpolation : str, default: :rc:`image.interpolation`
5516             The interpolation method used.
5517 
5518             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5519             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5520             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5521             'sinc', 'lanczos', 'blackman'.
5522 
5523             The data *X* is resampled to the pixel size of the image on the
5524             figure canvas, using the interpolation method to either up- or
5525             downsample the data.
5526 
5527             If *interpolation* is 'none', then for the ps, pdf, and svg
5528             backends no down- or upsampling occurs, and the image data is
5529             passed to the backend as a native image.  Note that different ps,
5530             pdf, and svg viewers may display these raw pixels differently. On
5531             other backends, 'none' is the same as 'nearest'.
5532 
5533             If *interpolation* is the default 'antialiased', then 'nearest'
5534             interpolation is used if the image is upsampled by more than a
5535             factor of three (i.e. the number of display pixels is at least
5536             three times the size of the data array).  If the upsampling rate is
5537             smaller than 3, or the image is downsampled, then 'hanning'
5538             interpolation is used to act as an anti-aliasing filter, unless the
5539             image happens to be upsampled by exactly a factor of two or one.
5540 
5541             See
5542             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5543             for an overview of the supported interpolation methods, and
5544             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5545             a discussion of image antialiasing.
5546 
5547             Some interpolation methods require an additional radius parameter,
5548             which can be set by *filterrad*. Additionally, the antigrain image
5549             resize filter is controlled by the parameter *filternorm*.
5550 
5551         interpolation_stage : {'data', 'rgba'}, default: 'data'
5552             If 'data', interpolation
5553             is carried out on the data provided by the user.  If 'rgba', the
5554             interpolation is carried out after the colormapping has been
5555             applied (visual interpolation).
5556 
5557         alpha : float or array-like, optional
5558             The alpha blending value, between 0 (transparent) and 1 (opaque).
5559             If *alpha* is an array, the alpha blending values are applied pixel
5560             by pixel, and *alpha* must have the same shape as *X*.
5561 
5562         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5563             Place the [0, 0] index of the array in the upper left or lower
5564             left corner of the Axes. The convention (the default) 'upper' is
5565             typically used for matrices and images.
5566 
5567             Note that the vertical axis points upward for 'lower'
5568             but downward for 'upper'.
5569 
5570             See the :ref:`imshow_extent` tutorial for
5571             examples and a more detailed description.
5572 
5573         extent : floats (left, right, bottom, top), optional
5574             The bounding box in data coordinates that the image will fill.
5575             These values may be unitful and match the units of the Axes.
5576             The image is stretched individually along x and y to fill the box.
5577 
5578             The default extent is determined by the following conditions.
5579             Pixels have unit size in data coordinates. Their centers are on
5580             integer coordinates, and their center coordinates range from 0 to
5581             columns-1 horizontally and from 0 to rows-1 vertically.
5582 
5583             Note that the direction of the vertical axis and thus the default
5584             values for top and bottom depend on *origin*:
5585 
5586             - For ``origin == 'upper'`` the default is
5587               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5588             - For ``origin == 'lower'`` the default is
5589               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5590 
5591             See the :ref:`imshow_extent` tutorial for
5592             examples and a more detailed description.
5593 
5594         filternorm : bool, default: True
5595             A parameter for the antigrain image resize filter (see the
5596             antigrain documentation).  If *filternorm* is set, the filter
5597             normalizes integer values and corrects the rounding errors. It
5598             doesn't do anything with the source floating point values, it
5599             corrects only integers according to the rule of 1.0 which means
5600             that any sum of pixel weights must be equal to 1.0.  So, the
5601             filter function must produce a graph of the proper shape.
5602 
5603         filterrad : float > 0, default: 4.0
5604             The filter radius for filters that have a radius parameter, i.e.
5605             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5606 
5607         resample : bool, default: :rc:`image.resample`
5608             When *True*, use a full resampling method.  When *False*, only
5609             resample when the output image is larger than the input image.
5610 
5611         url : str, optional
5612             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5613 
5614         Returns
5615         -------
5616         `~matplotlib.image.AxesImage`
5617 
5618         Other Parameters
5619         ----------------
5620         data : indexable object, optional
5621             DATA_PARAMETER_PLACEHOLDER
5622 
5623         **kwargs : `~matplotlib.artist.Artist` properties
5624             These parameters are passed on to the constructor of the
5625             `.AxesImage` artist.
5626 
5627         See Also
5628         --------
5629         matshow : Plot a matrix or an array as an image.
5630 
5631         Notes
5632         -----
5633         Unless *extent* is used, pixel centers will be located at integer
5634         coordinates. In other words: the origin will coincide with the center
5635         of pixel (0, 0).
5636 
5637         There are two common representations for RGB images with an alpha
5638         channel:
5639 
5640         -   Straight (unassociated) alpha: R, G, and B channels represent the
5641             color of the pixel, disregarding its opacity.
5642         -   Premultiplied (associated) alpha: R, G, and B channels represent
5643             the color of the pixel, adjusted for its opacity by multiplication.
5644 
5645         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5646         (unassociated) alpha representation.
5647         """
5648         if aspect is None:
5649             aspect = mpl.rcParams['image.aspect']
5650         self.set_aspect(aspect)
5651         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5652                               interpolation=interpolation, origin=origin,
5653                               extent=extent, filternorm=filternorm,
5654                               filterrad=filterrad, resample=resample,
5655                               interpolation_stage=interpolation_stage,
5656                               **kwargs)
5657 
5658         im.set_data(X)
5659         im.set_alpha(alpha)
5660         if im.get_clip_path() is None:
5661             # image does not already have clipping set, clip to axes patch
5662             im.set_clip_path(self.patch)
5663         im._scale_norm(norm, vmin, vmax)
5664         im.set_url(url)
5665 
5666         # update ax.dataLim, and, if autoscaling, set viewLim
5667         # to tightly fit the image, regardless of dataLim.
5668         im.set_extent(im.get_extent())
5669 
5670         self.add_image(im)
5671         return im
5672 
5673     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5674         # - create X and Y if not present;
5675         # - reshape X and Y as needed if they are 1-D;
5676         # - check for proper sizes based on `shading` kwarg;
5677         # - reset shading if shading='auto' to flat or nearest
5678         #   depending on size;
5679 
5680         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5681         try:
5682             _api.check_in_list(_valid_shading, shading=shading)
5683         except ValueError:
5684             _api.warn_external(f"shading value '{shading}' not in list of "
5685                                f"valid values {_valid_shading}. Setting "
5686                                "shading='auto'.")
5687             shading = 'auto'
5688 
5689         if len(args) == 1:
5690             C = np.asanyarray(args[0])
5691             nrows, ncols = C.shape[:2]
5692             if shading in ['gouraud', 'nearest']:
5693                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5694             else:
5695                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5696                 shading = 'flat'
5697             C = cbook.safe_masked_invalid(C)
5698             return X, Y, C, shading
5699 
5700         if len(args) == 3:
5701             # Check x and y for bad data...
5702             C = np.asanyarray(args[2])
5703             # unit conversion allows e.g. datetime objects as axis values
5704             X, Y = args[:2]
5705             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5706             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5707 
5708             if funcname == 'pcolormesh':
5709                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5710                     raise ValueError(
5711                         'x and y arguments to pcolormesh cannot have '
5712                         'non-finite values or be of type '
5713                         'numpy.ma.core.MaskedArray with masked values')
5714                 # safe_masked_invalid() returns an ndarray for dtypes other
5715                 # than floating point.
5716                 if isinstance(X, np.ma.core.MaskedArray):
5717                     X = X.data  # strip mask as downstream doesn't like it...
5718                 if isinstance(Y, np.ma.core.MaskedArray):
5719                     Y = Y.data
5720             nrows, ncols = C.shape[:2]
5721         else:
5722             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5723 
5724         Nx = X.shape[-1]
5725         Ny = Y.shape[0]
5726         if X.ndim != 2 or X.shape[0] == 1:
5727             x = X.reshape(1, Nx)
5728             X = x.repeat(Ny, axis=0)
5729         if Y.ndim != 2 or Y.shape[1] == 1:
5730             y = Y.reshape(Ny, 1)
5731             Y = y.repeat(Nx, axis=1)
5732         if X.shape != Y.shape:
5733             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5734                             f'see help({funcname})')
5735 
5736         if shading == 'auto':
5737             if ncols == Nx and nrows == Ny:
5738                 shading = 'nearest'
5739             else:
5740                 shading = 'flat'
5741 
5742         if shading == 'flat':
5743             if (Nx, Ny) != (ncols + 1, nrows + 1):
5744                 raise TypeError(f"Dimensions of C {C.shape} should"
5745                                 f" be one smaller than X({Nx}) and Y({Ny})"
5746                                 f" while using shading='flat'"
5747                                 f" see help({funcname})")
5748         else:    # ['nearest', 'gouraud']:
5749             if (Nx, Ny) != (ncols, nrows):
5750                 raise TypeError('Dimensions of C %s are incompatible with'
5751                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5752                                     C.shape, Nx, Ny, funcname))
5753             if shading == 'nearest':
5754                 # grid is specified at the center, so define corners
5755                 # at the midpoints between the grid centers and then use the
5756                 # flat algorithm.
5757                 def _interp_grid(X):
5758                     # helper for below
5759                     if np.shape(X)[1] > 1:
5760                         dX = np.diff(X, axis=1)/2.
5761                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5762                             _api.warn_external(
5763                                 f"The input coordinates to {funcname} are "
5764                                 "interpreted as cell centers, but are not "
5765                                 "monotonically increasing or decreasing. "
5766                                 "This may lead to incorrectly calculated cell "
5767                                 "edges, in which case, please supply "
5768                                 f"explicit cell edges to {funcname}.")
5769                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5770                                        X[:, :-1] + dX,
5771                                        X[:, [-1]] + dX[:, [-1]]))
5772                     else:
5773                         # This is just degenerate, but we can't reliably guess
5774                         # a dX if there is just one value.
5775                         X = np.hstack((X, X))
5776                     return X
5777 
5778                 if ncols == Nx:
5779                     X = _interp_grid(X)
5780                     Y = _interp_grid(Y)
5781                 if nrows == Ny:
5782                     X = _interp_grid(X.T).T
5783                     Y = _interp_grid(Y.T).T
5784                 shading = 'flat'
5785 
5786         C = cbook.safe_masked_invalid(C)
5787         return X, Y, C, shading
5788 
5789     @_preprocess_data()
5790     @_docstring.dedent_interpd
5791     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5792                vmin=None, vmax=None, **kwargs):
5793         r"""
5794         Create a pseudocolor plot with a non-regular rectangular grid.
5795 
5796         Call signature::
5797 
5798             pcolor([X, Y,] C, **kwargs)
5799 
5800         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5801 
5802         .. hint::
5803 
5804             ``pcolor()`` can be very slow for large arrays. In most
5805             cases you should use the similar but much faster
5806             `~.Axes.pcolormesh` instead. See
5807             :ref:`Differences between pcolor() and pcolormesh()
5808             <differences-pcolor-pcolormesh>` for a discussion of the
5809             differences.
5810 
5811         Parameters
5812         ----------
5813         C : 2D array-like
5814             The color-mapped values.  Color-mapping is controlled by *cmap*,
5815             *norm*, *vmin*, and *vmax*.
5816 
5817         X, Y : array-like, optional
5818             The coordinates of the corners of quadrilaterals of a pcolormesh::
5819 
5820                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5821                                       
5822                                            
5823                                       
5824                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5825 
5826             Note that the column index corresponds to the x-coordinate, and
5827             the row index corresponds to y. For details, see the
5828             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5829 
5830             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5831             greater than those of *C*, and the quadrilateral is colored due
5832             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5833             dimensions, a warning will be raised and the last row and column
5834             of *C* will be ignored.
5835 
5836             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5837             the same as those of *C* (if not, a ValueError will be raised). The
5838             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5839 
5840             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5841             expanded as needed into the appropriate 2D arrays, making a
5842             rectangular grid.
5843 
5844         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5845             The fill style for the quadrilateral. Possible values:
5846 
5847             - 'flat': A solid color is used for each quad. The color of the
5848               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5849               ``C[i, j]``. The dimensions of *X* and *Y* should be
5850               one greater than those of *C*; if they are the same as *C*,
5851               then a deprecation warning is raised, and the last row
5852               and column of *C* are dropped.
5853             - 'nearest': Each grid point will have a color centered on it,
5854               extending halfway between the adjacent grid centers.  The
5855               dimensions of *X* and *Y* must be the same as *C*.
5856             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5857               larger than *C*.  Choose 'nearest' if dimensions are the same.
5858 
5859             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5860             for more description.
5861 
5862         %(cmap_doc)s
5863 
5864         %(norm_doc)s
5865 
5866         %(vmin_vmax_doc)s
5867 
5868         edgecolors : {'none', None, 'face', color, color sequence}, optional
5869             The color of the edges. Defaults to 'none'. Possible values:
5870 
5871             - 'none' or '': No edge.
5872             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5873               :rc:`patch.force_edgecolor` has to be True for this to work.
5874             - 'face': Use the adjacent face color.
5875             - A color or sequence of colors will set the edge color.
5876 
5877             The singular form *edgecolor* works as an alias.
5878 
5879         alpha : float, default: None
5880             The alpha blending value of the face color, between 0 (transparent)
5881             and 1 (opaque). Note: The edgecolor is currently not affected by
5882             this.
5883 
5884         snap : bool, default: False
5885             Whether to snap the mesh to pixel boundaries.
5886 
5887         Returns
5888         -------
5889         `matplotlib.collections.Collection`
5890 
5891         Other Parameters
5892         ----------------
5893         antialiaseds : bool, default: False
5894             The default *antialiaseds* is False if the default
5895             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5896             at patch boundaries, and works regardless of the value of alpha.
5897             If *edgecolors* is not "none", then the default *antialiaseds*
5898             is taken from :rc:`patch.antialiased`.
5899             Stroking the edges may be preferred if *alpha* is 1, but will
5900             cause artifacts otherwise.
5901 
5902         data : indexable object, optional
5903             DATA_PARAMETER_PLACEHOLDER
5904 
5905         **kwargs
5906             Additionally, the following arguments are allowed. They are passed
5907             along to the `~matplotlib.collections.PolyCollection` constructor:
5908 
5909         %(PolyCollection:kwdoc)s
5910 
5911         See Also
5912         --------
5913         pcolormesh : for an explanation of the differences between
5914             pcolor and pcolormesh.
5915         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5916             faster alternative.
5917 
5918         Notes
5919         -----
5920         **Masked arrays**
5921 
5922         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5923         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5924         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5925         plotted.
5926 
5927         .. _axes-pcolor-grid-orientation:
5928 
5929         **Grid orientation**
5930 
5931         The grid orientation follows the standard matrix convention: An array
5932         *C* with shape (nrows, ncolumns) is plotted with the column number as
5933         *X* and the row number as *Y*.
5934         """
5935 
5936         if shading is None:
5937             shading = mpl.rcParams['pcolor.shading']
5938         shading = shading.lower()
5939         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5940                                             kwargs=kwargs)
5941         Ny, Nx = X.shape
5942 
5943         # convert to MA, if necessary.
5944         C = ma.asarray(C)
5945         X = ma.asarray(X)
5946         Y = ma.asarray(Y)
5947 
5948         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5949         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5950                   mask[0:-1, 1:] + mask[1:, 0:-1])
5951         # don't plot if C or any of the surrounding vertices are masked.
5952         mask = ma.getmaskarray(C) + xymask
5953 
5954         unmask = ~mask
5955         X1 = ma.filled(X[:-1, :-1])[unmask]
5956         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5957         X2 = ma.filled(X[1:, :-1])[unmask]
5958         Y2 = ma.filled(Y[1:, :-1])[unmask]
5959         X3 = ma.filled(X[1:, 1:])[unmask]
5960         Y3 = ma.filled(Y[1:, 1:])[unmask]
5961         X4 = ma.filled(X[:-1, 1:])[unmask]
5962         Y4 = ma.filled(Y[:-1, 1:])[unmask]
5963         npoly = len(X1)
5964 
5965         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
5966         verts = xy.reshape((npoly, 5, 2))
5967 
5968         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
5969 
5970         linewidths = (0.25,)
5971         if 'linewidth' in kwargs:
5972             kwargs['linewidths'] = kwargs.pop('linewidth')
5973         kwargs.setdefault('linewidths', linewidths)
5974 
5975         if 'edgecolor' in kwargs:
5976             kwargs['edgecolors'] = kwargs.pop('edgecolor')
5977         ec = kwargs.setdefault('edgecolors', 'none')
5978 
5979         # aa setting will default via collections to patch.antialiased
5980         # unless the boundary is not stroked, in which case the
5981         # default will be False; with unstroked boundaries, aa
5982         # makes artifacts that are often disturbing.
5983         if 'antialiased' in kwargs:
5984             kwargs['antialiaseds'] = kwargs.pop('antialiased')
5985         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
5986             kwargs['antialiaseds'] = False
5987 
5988         kwargs.setdefault('snap', False)
5989 
5990         collection = mcoll.PolyCollection(
5991             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
5992         collection._scale_norm(norm, vmin, vmax)
5993 
5994         x = X.compressed()
5995         y = Y.compressed()
5996 
5997         # Transform from native to data coordinates?
5998         t = collection._transform
5999         if (not isinstance(t, mtransforms.Transform) and
6000                 hasattr(t, '_as_mpl_transform')):
6001             t = t._as_mpl_transform(self.axes)
6002 
6003         if t and any(t.contains_branch_seperately(self.transData)):
6004             trans_to_data = t - self.transData
6005             pts = np.vstack([x, y]).T.astype(float)
6006             transformed_pts = trans_to_data.transform(pts)
6007             x = transformed_pts[..., 0]
6008             y = transformed_pts[..., 1]
6009 
6010         self.add_collection(collection, autolim=False)
6011 
6012         minx = np.min(x)
6013         maxx = np.max(x)
6014         miny = np.min(y)
6015         maxy = np.max(y)
6016         collection.sticky_edges.x[:] = [minx, maxx]
6017         collection.sticky_edges.y[:] = [miny, maxy]
6018         corners = (minx, miny), (maxx, maxy)
6019         self.update_datalim(corners)
6020         self._request_autoscale_view()
6021         return collection
6022 
6023     @_preprocess_data()
6024     @_docstring.dedent_interpd
6025     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6026                    vmax=None, shading=None, antialiased=False, **kwargs):
6027         """
6028         Create a pseudocolor plot with a non-regular rectangular grid.
6029 
6030         Call signature::
6031 
6032             pcolormesh([X, Y,] C, **kwargs)
6033 
6034         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6035 
6036         .. hint::
6037 
6038            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6039            and preferred in most cases. For a detailed discussion on the
6040            differences see :ref:`Differences between pcolor() and pcolormesh()
6041            <differences-pcolor-pcolormesh>`.
6042 
6043         Parameters
6044         ----------
6045         C : array-like
6046             The mesh data. Supported array shapes are:
6047 
6048             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6049               colors using normalization and a colormap. See parameters *norm*,
6050               *cmap*, *vmin*, *vmax*.
6051             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6052             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6053               i.e. including transparency.
6054 
6055             The first two dimensions (M, N) define the rows and columns of
6056             the mesh data.
6057 
6058         X, Y : array-like, optional
6059             The coordinates of the corners of quadrilaterals of a pcolormesh::
6060 
6061                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6062                                       
6063                                            
6064                                       
6065                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6066 
6067             Note that the column index corresponds to the x-coordinate, and
6068             the row index corresponds to y. For details, see the
6069             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6070 
6071             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6072             greater than those of *C*, and the quadrilateral is colored due
6073             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6074             dimensions, a warning will be raised and the last row and column
6075             of *C* will be ignored.
6076 
6077             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6078             and *Y* should be the same as those of *C* (if not, a ValueError
6079             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6080             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6081             interpolation is caried out between the quadrilateral corners.
6082 
6083             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6084             expanded as needed into the appropriate 2D arrays, making a
6085             rectangular grid.
6086 
6087         %(cmap_doc)s
6088 
6089         %(norm_doc)s
6090 
6091         %(vmin_vmax_doc)s
6092 
6093         edgecolors : {'none', None, 'face', color, color sequence}, optional
6094             The color of the edges. Defaults to 'none'. Possible values:
6095 
6096             - 'none' or '': No edge.
6097             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6098               :rc:`patch.force_edgecolor` has to be True for this to work.
6099             - 'face': Use the adjacent face color.
6100             - A color or sequence of colors will set the edge color.
6101 
6102             The singular form *edgecolor* works as an alias.
6103 
6104         alpha : float, default: None
6105             The alpha blending value, between 0 (transparent) and 1 (opaque).
6106 
6107         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6108             The fill style for the quadrilateral; defaults to
6109             :rc:`pcolor.shading`. Possible values:
6110 
6111             - 'flat': A solid color is used for each quad. The color of the
6112               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6113               ``C[i, j]``. The dimensions of *X* and *Y* should be
6114               one greater than those of *C*; if they are the same as *C*,
6115               then a deprecation warning is raised, and the last row
6116               and column of *C* are dropped.
6117             - 'nearest': Each grid point will have a color centered on it,
6118               extending halfway between the adjacent grid centers.  The
6119               dimensions of *X* and *Y* must be the same as *C*.
6120             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6121               corners (i', j') are given by ``C[i', j']``. The color values of
6122               the area in between is interpolated from the corner values.
6123               The dimensions of *X* and *Y* must be the same as *C*. When
6124               Gouraud shading is used, *edgecolors* is ignored.
6125             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6126               larger than *C*.  Choose 'nearest' if dimensions are the same.
6127 
6128             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6129             for more description.
6130 
6131         snap : bool, default: False
6132             Whether to snap the mesh to pixel boundaries.
6133 
6134         rasterized : bool, optional
6135             Rasterize the pcolormesh when drawing vector graphics.  This can
6136             speed up rendering and produce smaller files for large data sets.
6137             See also :doc:`/gallery/misc/rasterization_demo`.
6138 
6139         Returns
6140         -------
6141         `matplotlib.collections.QuadMesh`
6142 
6143         Other Parameters
6144         ----------------
6145         data : indexable object, optional
6146             DATA_PARAMETER_PLACEHOLDER
6147 
6148         **kwargs
6149             Additionally, the following arguments are allowed. They are passed
6150             along to the `~matplotlib.collections.QuadMesh` constructor:
6151 
6152         %(QuadMesh:kwdoc)s
6153 
6154         See Also
6155         --------
6156         pcolor : An alternative implementation with slightly different
6157             features. For a detailed discussion on the differences see
6158             :ref:`Differences between pcolor() and pcolormesh()
6159             <differences-pcolor-pcolormesh>`.
6160         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6161             faster alternative.
6162 
6163         Notes
6164         -----
6165         **Masked arrays**
6166 
6167         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6168         quadrilateral will be transparent. Masking of *X* and *Y* is not
6169         supported. Use `~.Axes.pcolor` if you need this functionality.
6170 
6171         .. _axes-pcolormesh-grid-orientation:
6172 
6173         **Grid orientation**
6174 
6175         The grid orientation follows the standard matrix convention: An array
6176         *C* with shape (nrows, ncolumns) is plotted with the column number as
6177         *X* and the row number as *Y*.
6178 
6179         .. _differences-pcolor-pcolormesh:
6180 
6181         **Differences between pcolor() and pcolormesh()**
6182 
6183         Both methods are used to create a pseudocolor plot of a 2D array
6184         using quadrilaterals.
6185 
6186         The main difference lies in the created object and internal data
6187         handling:
6188         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6189         returns a `.QuadMesh`. The latter is more specialized for the given
6190         purpose and thus is faster. It should almost always be preferred.
6191 
6192         There is also a slight difference in the handling of masked arrays.
6193         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6194         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6195         and *Y*. The reason lies in the internal handling of the masked values.
6196         `~.Axes.pcolor` leaves out the respective polygons from the
6197         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6198         elements to transparent. You can see the difference when using
6199         edgecolors. While all edges are drawn irrespective of masking in a
6200         QuadMesh, the edge between two adjacent masked quadrilaterals in
6201         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6202         exist in the PolyCollection.
6203 
6204         Another difference is the support of Gouraud shading in
6205         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6206 
6207         """
6208         if shading is None:
6209             shading = mpl.rcParams['pcolor.shading']
6210         shading = shading.lower()
6211         kwargs.setdefault('edgecolors', 'none')
6212 
6213         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6214                                             shading=shading, kwargs=kwargs)
6215         coords = np.stack([X, Y], axis=-1)
6216 
6217         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6218 
6219         collection = mcoll.QuadMesh(
6220             coords, antialiased=antialiased, shading=shading,
6221             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6222         collection._scale_norm(norm, vmin, vmax)
6223 
6224         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6225 
6226         # Transform from native to data coordinates?
6227         t = collection._transform
6228         if (not isinstance(t, mtransforms.Transform) and
6229                 hasattr(t, '_as_mpl_transform')):
6230             t = t._as_mpl_transform(self.axes)
6231 
6232         if t and any(t.contains_branch_seperately(self.transData)):
6233             trans_to_data = t - self.transData
6234             coords = trans_to_data.transform(coords)
6235 
6236         self.add_collection(collection, autolim=False)
6237 
6238         minx, miny = np.min(coords, axis=0)
6239         maxx, maxy = np.max(coords, axis=0)
6240         collection.sticky_edges.x[:] = [minx, maxx]
6241         collection.sticky_edges.y[:] = [miny, maxy]
6242         corners = (minx, miny), (maxx, maxy)
6243         self.update_datalim(corners)
6244         self._request_autoscale_view()
6245         return collection
6246 
6247     @_preprocess_data()
6248     @_docstring.dedent_interpd
6249     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6250                    vmax=None, **kwargs):
6251         """
6252         Create a pseudocolor plot with a non-regular rectangular grid.
6253 
6254         Call signature::
6255 
6256           ax.pcolorfast([X, Y], C, /, **kwargs)
6257 
6258         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6259         It's designed to provide the fastest pcolor-type plotting with the
6260         Agg backend. To achieve this, it uses different algorithms internally
6261         depending on the complexity of the input grid (regular rectangular,
6262         non-regular rectangular or arbitrary quadrilateral).
6263 
6264         .. warning::
6265 
6266            This method is experimental. Compared to `~.Axes.pcolor` or
6267            `~.Axes.pcolormesh` it has some limitations:
6268 
6269            - It supports only flat shading (no outlines)
6270            - It lacks support for log scaling of the axes.
6271            - It does not have a pyplot wrapper.
6272 
6273         Parameters
6274         ----------
6275         C : array-like
6276             The image data. Supported array shapes are:
6277 
6278             - (M, N): an image with scalar data.  Color-mapping is controlled
6279               by *cmap*, *norm*, *vmin*, and *vmax*.
6280             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6281             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6282               i.e. including transparency.
6283 
6284             The first two dimensions (M, N) define the rows and columns of
6285             the image.
6286 
6287             This parameter can only be passed positionally.
6288 
6289         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6290             *X* and *Y* are used to specify the coordinates of the
6291             quadrilaterals. There are different ways to do this:
6292 
6293             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6294               a *uniform rectangular grid*.
6295 
6296               The tuples define the outer edges of the grid. All individual
6297               quadrilaterals will be of the same size. This is the fastest
6298               version.
6299 
6300             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6301               grid*.
6302 
6303               In this case *X* and *Y* have to be monotonic 1D arrays of length
6304               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6305 
6306               The speed is intermediate. Note: The grid is checked, and if
6307               found to be uniform the fast version is used.
6308 
6309             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6310               grid* (i.e. if the quadrilaterals are not rectangular).
6311 
6312               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6313               specifying the x and y coordinates of the corners of the colored
6314               quadrilaterals.
6315 
6316               This is the most general, but the slowest to render.  It may
6317               produce faster and more compact output using ps, pdf, and
6318               svg backends, however.
6319 
6320             These arguments can only be passed positionally.
6321 
6322         %(cmap_doc)s
6323 
6324             This parameter is ignored if *C* is RGB(A).
6325 
6326         %(norm_doc)s
6327 
6328             This parameter is ignored if *C* is RGB(A).
6329 
6330         %(vmin_vmax_doc)s
6331 
6332             This parameter is ignored if *C* is RGB(A).
6333 
6334         alpha : float, default: None
6335             The alpha blending value, between 0 (transparent) and 1 (opaque).
6336 
6337         snap : bool, default: False
6338             Whether to snap the mesh to pixel boundaries.
6339 
6340         Returns
6341         -------
6342         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6343             The return type depends on the type of grid:
6344 
6345             - `.AxesImage` for a regular rectangular grid.
6346             - `.PcolorImage` for a non-regular rectangular grid.
6347             - `.QuadMesh` for a non-rectangular grid.
6348 
6349         Other Parameters
6350         ----------------
6351         data : indexable object, optional
6352             DATA_PARAMETER_PLACEHOLDER
6353 
6354         **kwargs
6355             Supported additional parameters depend on the type of grid.
6356             See return types of *image* for further description.
6357         """
6358 
6359         C = args[-1]
6360         nr, nc = np.shape(C)[:2]
6361         if len(args) == 1:
6362             style = "image"
6363             x = [0, nc]
6364             y = [0, nr]
6365         elif len(args) == 3:
6366             x, y = args[:2]
6367             x = np.asarray(x)
6368             y = np.asarray(y)
6369             if x.ndim == 1 and y.ndim == 1:
6370                 if x.size == 2 and y.size == 2:
6371                     style = "image"
6372                 else:
6373                     dx = np.diff(x)
6374                     dy = np.diff(y)
6375                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6376                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6377                         style = "image"
6378                     else:
6379                         style = "pcolorimage"
6380             elif x.ndim == 2 and y.ndim == 2:
6381                 style = "quadmesh"
6382             else:
6383                 raise TypeError("arguments do not match valid signatures")
6384         else:
6385             _api.nargs_error('pcolorfast', '1 or 3', len(args))
6386 
6387         if style == "quadmesh":
6388             # data point in each cell is value at lower left corner
6389             coords = np.stack([x, y], axis=-1)
6390             if np.ndim(C) not in {2, 3}:
6391                 raise ValueError("C must be 2D or 3D")
6392             collection = mcoll.QuadMesh(
6393                 coords, array=C,
6394                 alpha=alpha, cmap=cmap, norm=norm,
6395                 antialiased=False, edgecolors="none")
6396             self.add_collection(collection, autolim=False)
6397             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6398             ret = collection
6399 
6400         else:  # It's one of the two image styles.
6401             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6402             if style == "image":
6403                 im = mimage.AxesImage(
6404                     self, cmap=cmap, norm=norm,
6405                     data=C, alpha=alpha, extent=extent,
6406                     interpolation='nearest', origin='lower',
6407                     **kwargs)
6408             elif style == "pcolorimage":
6409                 im = mimage.PcolorImage(
6410                     self, x, y, C,
6411                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6412                     **kwargs)
6413             self.add_image(im)
6414             ret = im
6415 
6416         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6417             ret._scale_norm(norm, vmin, vmax)
6418 
6419         if ret.get_clip_path() is None:
6420             # image does not already have clipping set, clip to axes patch
6421             ret.set_clip_path(self.patch)
6422 
6423         ret.sticky_edges.x[:] = [xl, xr]
6424         ret.sticky_edges.y[:] = [yb, yt]
6425         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6426         self._request_autoscale_view(tight=True)
6427         return ret
6428 
6429     @_preprocess_data()
6430     @_docstring.dedent_interpd
6431     def contour(self, *args, **kwargs):
6432         """
6433         Plot contour lines.
6434 
6435         Call signature::
6436 
6437             contour([X, Y,] Z, [levels], **kwargs)
6438         %(contour_doc)s
6439         """
6440         kwargs['filled'] = False
6441         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6442         self._request_autoscale_view()
6443         return contours
6444 
6445     @_preprocess_data()
6446     @_docstring.dedent_interpd
6447     def contourf(self, *args, **kwargs):
6448         """
6449         Plot filled contours.
6450 
6451         Call signature::
6452 
6453             contourf([X, Y,] Z, [levels], **kwargs)
6454         %(contour_doc)s
6455         """
6456         kwargs['filled'] = True
6457         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6458         self._request_autoscale_view()
6459         return contours
6460 
6461     def clabel(self, CS, levels=None, **kwargs):
6462         """
6463         Label a contour plot.
6464 
6465         Adds labels to line contours in given `.ContourSet`.
6466 
6467         Parameters
6468         ----------
6469         CS : `.ContourSet` instance
6470             Line contours to label.
6471 
6472         levels : array-like, optional
6473             A list of level values, that should be labeled. The list must be
6474             a subset of ``CS.levels``. If not given, all levels are labeled.
6475 
6476         **kwargs
6477             All other parameters are documented in `~.ContourLabeler.clabel`.
6478         """
6479         return CS.clabel(levels, **kwargs)
6480 
6481     #### Data analysis
6482 
6483     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6484     def hist(self, x, bins=None, range=None, density=False, weights=None,
6485              cumulative=False, bottom=None, histtype='bar', align='mid',
6486              orientation='vertical', rwidth=None, log=False,
6487              color=None, label=None, stacked=False, **kwargs):
6488         """
6489         Compute and plot a histogram.
6490 
6491         This method uses `numpy.histogram` to bin the data in *x* and count the
6492         number of values in each bin, then draws the distribution either as a
6493         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6494         *weights* parameters are forwarded to `numpy.histogram`.
6495 
6496         If the data has already been binned and counted, use `~.bar` or
6497         `~.stairs` to plot the distribution::
6498 
6499             counts, bins = np.histogram(x)
6500             plt.stairs(counts, bins)
6501 
6502         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6503         treating each bin as a single point with a weight equal to its count::
6504 
6505             plt.hist(bins[:-1], bins, weights=counts)
6506 
6507         The data input *x* can be a singular array, a list of datasets of
6508         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6509         which each column is a dataset. Note that the ndarray form is
6510         transposed relative to the list form. If the input is an array, then
6511         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6512         sequence of arrays, then the return value is a tuple
6513         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6514 
6515         Masked arrays are not supported.
6516 
6517         Parameters
6518         ----------
6519         x : (n,) array or sequence of (n,) arrays
6520             Input values, this takes either a single array or a sequence of
6521             arrays which are not required to be of the same length.
6522 
6523         bins : int or sequence or str, default: :rc:`hist.bins`
6524             If *bins* is an integer, it defines the number of equal-width bins
6525             in the range.
6526 
6527             If *bins* is a sequence, it defines the bin edges, including the
6528             left edge of the first bin and the right edge of the last bin;
6529             in this case, bins may be unequally spaced.  All but the last
6530             (righthand-most) bin is half-open.  In other words, if *bins* is::
6531 
6532                 [1, 2, 3, 4]
6533 
6534             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6535             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6536             *includes* 4.
6537 
6538             If *bins* is a string, it is one of the binning strategies
6539             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6540             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6541 
6542         range : tuple or None, default: None
6543             The lower and upper range of the bins. Lower and upper outliers
6544             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6545             Range has no effect if *bins* is a sequence.
6546 
6547             If *bins* is a sequence or *range* is specified, autoscaling
6548             is based on the specified bin range instead of the
6549             range of x.
6550 
6551         density : bool, default: False
6552             If ``True``, draw and return a probability density: each bin
6553             will display the bin's raw count divided by the total number of
6554             counts *and the bin width*
6555             (``density = counts / (sum(counts) * np.diff(bins))``),
6556             so that the area under the histogram integrates to 1
6557             (``np.sum(density * np.diff(bins)) == 1``).
6558 
6559             If *stacked* is also ``True``, the sum of the histograms is
6560             normalized to 1.
6561 
6562         weights : (n,) array-like or None, default: None
6563             An array of weights, of the same shape as *x*.  Each value in
6564             *x* only contributes its associated weight towards the bin count
6565             (instead of 1).  If *density* is ``True``, the weights are
6566             normalized, so that the integral of the density over the range
6567             remains 1.
6568 
6569         cumulative : bool or -1, default: False
6570             If ``True``, then a histogram is computed where each bin gives the
6571             counts in that bin plus all bins for smaller values. The last bin
6572             gives the total number of datapoints.
6573 
6574             If *density* is also ``True`` then the histogram is normalized such
6575             that the last bin equals 1.
6576 
6577             If *cumulative* is a number less than 0 (e.g., -1), the direction
6578             of accumulation is reversed.  In this case, if *density* is also
6579             ``True``, then the histogram is normalized such that the first bin
6580             equals 1.
6581 
6582         bottom : array-like, scalar, or None, default: None
6583             Location of the bottom of each bin, i.e. bins are drawn from
6584             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6585             of each bin is shifted by the same amount. If an array, each bin
6586             is shifted independently and the length of bottom must match the
6587             number of bins. If None, defaults to 0.
6588 
6589         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6590             The type of histogram to draw.
6591 
6592             - 'bar' is a traditional bar-type histogram.  If multiple data
6593               are given the bars are arranged side by side.
6594             - 'barstacked' is a bar-type histogram where multiple
6595               data are stacked on top of each other.
6596             - 'step' generates a lineplot that is by default unfilled.
6597             - 'stepfilled' generates a lineplot that is by default filled.
6598 
6599         align : {'left', 'mid', 'right'}, default: 'mid'
6600             The horizontal alignment of the histogram bars.
6601 
6602             - 'left': bars are centered on the left bin edges.
6603             - 'mid': bars are centered between the bin edges.
6604             - 'right': bars are centered on the right bin edges.
6605 
6606         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6607             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6608             and the *bottom* kwarg will be the left edges.
6609 
6610         rwidth : float or None, default: None
6611             The relative width of the bars as a fraction of the bin width.  If
6612             ``None``, automatically compute the width.
6613 
6614             Ignored if *histtype* is 'step' or 'stepfilled'.
6615 
6616         log : bool, default: False
6617             If ``True``, the histogram axis will be set to a log scale.
6618 
6619         color : color or array-like of colors or None, default: None
6620             Color or sequence of colors, one per dataset.  Default (``None``)
6621             uses the standard line color sequence.
6622 
6623         label : str or None, default: None
6624             String, or sequence of strings to match multiple datasets.  Bar
6625             charts yield multiple patches per dataset, but only the first gets
6626             the label, so that `~.Axes.legend` will work as expected.
6627 
6628         stacked : bool, default: False
6629             If ``True``, multiple data are stacked on top of each other If
6630             ``False`` multiple data are arranged side by side if histtype is
6631             'bar' or on top of each other if histtype is 'step'
6632 
6633         Returns
6634         -------
6635         n : array or list of arrays
6636             The values of the histogram bins. See *density* and *weights* for a
6637             description of the possible semantics.  If input *x* is an array,
6638             then this is an array of length *nbins*. If input is a sequence of
6639             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6640             the values of the histograms for each of the arrays in the same
6641             order.  The dtype of the array *n* (or of its element arrays) will
6642             always be float even if no weighting or normalization is used.
6643 
6644         bins : array
6645             The edges of the bins. Length nbins + 1 (nbins left edges and right
6646             edge of last bin).  Always a single array even when multiple data
6647             sets are passed in.
6648 
6649         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6650 such objects
6651             Container of individual artists used to create the histogram
6652             or list of such containers if there are multiple input datasets.
6653 
6654         Other Parameters
6655         ----------------
6656         data : indexable object, optional
6657             DATA_PARAMETER_PLACEHOLDER
6658 
6659         **kwargs
6660             `~matplotlib.patches.Patch` properties
6661 
6662         See Also
6663         --------
6664         hist2d : 2D histogram with rectangular bins
6665         hexbin : 2D histogram with hexagonal bins
6666 
6667         Notes
6668         -----
6669         For large numbers of bins (>1000), plotting can be significantly faster
6670         if *histtype* is set to 'step' or 'stepfilled' rather than 'bar' or
6671         'barstacked'.
6672         """
6673         # Avoid shadowing the builtin.
6674         bin_range = range
6675         from builtins import range
6676 
6677         if np.isscalar(x):
6678             x = [x]
6679 
6680         if bins is None:
6681             bins = mpl.rcParams['hist.bins']
6682 
6683         # Validate string inputs here to avoid cluttering subsequent code.
6684         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6685                            histtype=histtype)
6686         _api.check_in_list(['left', 'mid', 'right'], align=align)
6687         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6688 
6689         if histtype == 'barstacked' and not stacked:
6690             stacked = True
6691 
6692         # Massage 'x' for processing.
6693         x = cbook._reshape_2D(x, 'x')
6694         nx = len(x)  # number of datasets
6695 
6696         # Process unit information.  _process_unit_info sets the unit and
6697         # converts the first dataset; then we convert each following dataset
6698         # one at a time.
6699         if orientation == "vertical":
6700             convert_units = self.convert_xunits
6701             x = [*self._process_unit_info([("x", x[0])], kwargs),
6702                  *map(convert_units, x[1:])]
6703         else:  # horizontal
6704             convert_units = self.convert_yunits
6705             x = [*self._process_unit_info([("y", x[0])], kwargs),
6706                  *map(convert_units, x[1:])]
6707 
6708         if bin_range is not None:
6709             bin_range = convert_units(bin_range)
6710 
6711         if not cbook.is_scalar_or_string(bins):
6712             bins = convert_units(bins)
6713 
6714         # We need to do to 'weights' what was done to 'x'
6715         if weights is not None:
6716             w = cbook._reshape_2D(weights, 'weights')
6717         else:
6718             w = [None] * nx
6719 
6720         if len(w) != nx:
6721             raise ValueError('weights should have the same shape as x')
6722 
6723         input_empty = True
6724         for xi, wi in zip(x, w):
6725             len_xi = len(xi)
6726             if wi is not None and len(wi) != len_xi:
6727                 raise ValueError('weights should have the same shape as x')
6728             if len_xi:
6729                 input_empty = False
6730 
6731         if color is None:
6732             colors = [self._get_lines.get_next_color() for i in range(nx)]
6733         else:
6734             colors = mcolors.to_rgba_array(color)
6735             if len(colors) != nx:
6736                 raise ValueError(f"The 'color' keyword argument must have one "
6737                                  f"color per dataset, but {nx} datasets and "
6738                                  f"{len(colors)} colors were provided")
6739 
6740         hist_kwargs = dict()
6741 
6742         # if the bin_range is not given, compute without nan numpy
6743         # does not do this for us when guessing the range (but will
6744         # happily ignore nans when computing the histogram).
6745         if bin_range is None:
6746             xmin = np.inf
6747             xmax = -np.inf
6748             for xi in x:
6749                 if len(xi):
6750                     # python's min/max ignore nan,
6751                     # np.minnan returns nan for all nan input
6752                     xmin = min(xmin, np.nanmin(xi))
6753                     xmax = max(xmax, np.nanmax(xi))
6754             if xmin <= xmax:  # Only happens if we have seen a finite value.
6755                 bin_range = (xmin, xmax)
6756 
6757         # If bins are not specified either explicitly or via range,
6758         # we need to figure out the range required for all datasets,
6759         # and supply that to np.histogram.
6760         if not input_empty and len(x) > 1:
6761             if weights is not None:
6762                 _w = np.concatenate(w)
6763             else:
6764                 _w = None
6765             bins = np.histogram_bin_edges(
6766                 np.concatenate(x), bins, bin_range, _w)
6767         else:
6768             hist_kwargs['range'] = bin_range
6769 
6770         density = bool(density)
6771         if density and not stacked:
6772             hist_kwargs['density'] = density
6773 
6774         # List to store all the top coordinates of the histograms
6775         tops = []  # Will have shape (n_datasets, n_bins).
6776         # Loop through datasets
6777         for i in range(nx):
6778             # this will automatically overwrite bins,
6779             # so that each histogram uses the same bins
6780             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6781             tops.append(m)
6782         tops = np.array(tops, float)  # causes problems later if it's an int
6783         bins = np.array(bins, float)  # causes problems if float16
6784         if stacked:
6785             tops = tops.cumsum(axis=0)
6786             # If a stacked density plot, normalize so the area of all the
6787             # stacked histograms together is 1
6788             if density:
6789                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6790         if cumulative:
6791             slc = slice(None)
6792             if isinstance(cumulative, Number) and cumulative < 0:
6793                 slc = slice(None, None, -1)
6794             if density:
6795                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6796             else:
6797                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6798 
6799         patches = []
6800 
6801         if histtype.startswith('bar'):
6802 
6803             totwidth = np.diff(bins)
6804 
6805             if rwidth is not None:
6806                 dr = np.clip(rwidth, 0, 1)
6807             elif (len(tops) > 1 and
6808                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6809                 dr = 0.8
6810             else:
6811                 dr = 1.0
6812 
6813             if histtype == 'bar' and not stacked:
6814                 width = dr * totwidth / nx
6815                 dw = width
6816                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6817             elif histtype == 'barstacked' or stacked:
6818                 width = dr * totwidth
6819                 boffset, dw = 0.0, 0.0
6820 
6821             if align == 'mid':
6822                 boffset += 0.5 * totwidth
6823             elif align == 'right':
6824                 boffset += totwidth
6825 
6826             if orientation == 'horizontal':
6827                 _barfunc = self.barh
6828                 bottom_kwarg = 'left'
6829             else:  # orientation == 'vertical'
6830                 _barfunc = self.bar
6831                 bottom_kwarg = 'bottom'
6832 
6833             for top, color in zip(tops, colors):
6834                 if bottom is None:
6835                     bottom = np.zeros(len(top))
6836                 if stacked:
6837                     height = top - bottom
6838                 else:
6839                     height = top
6840                 bars = _barfunc(bins[:-1]+boffset, height, width,
6841                                 align='center', log=log,
6842                                 color=color, **{bottom_kwarg: bottom})
6843                 patches.append(bars)
6844                 if stacked:
6845                     bottom = top
6846                 boffset += dw
6847             # Remove stickies from all bars but the lowest ones, as otherwise
6848             # margin expansion would be unable to cross the stickies in the
6849             # middle of the bars.
6850             for bars in patches[1:]:
6851                 for patch in bars:
6852                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6853 
6854         elif histtype.startswith('step'):
6855             # these define the perimeter of the polygon
6856             x = np.zeros(4 * len(bins) - 3)
6857             y = np.zeros(4 * len(bins) - 3)
6858 
6859             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6860             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6861 
6862             if bottom is None:
6863                 bottom = 0
6864 
6865             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6866             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6867 
6868             if log:
6869                 if orientation == 'horizontal':
6870                     self.set_xscale('log', nonpositive='clip')
6871                 else:  # orientation == 'vertical'
6872                     self.set_yscale('log', nonpositive='clip')
6873 
6874             if align == 'left':
6875                 x -= 0.5*(bins[1]-bins[0])
6876             elif align == 'right':
6877                 x += 0.5*(bins[1]-bins[0])
6878 
6879             # If fill kwarg is set, it will be passed to the patch collection,
6880             # overriding this
6881             fill = (histtype == 'stepfilled')
6882 
6883             xvals, yvals = [], []
6884             for top in tops:
6885                 if stacked:
6886                     # top of the previous polygon becomes the bottom
6887                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6888                 # set the top of this polygon
6889                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6890 
6891                 # The starting point of the polygon has not yet been
6892                 # updated. So far only the endpoint was adjusted. This
6893                 # assignment closes the polygon. The redundant endpoint is
6894                 # later discarded (for step and stepfilled).
6895                 y[0] = y[-1]
6896 
6897                 if orientation == 'horizontal':
6898                     xvals.append(y.copy())
6899                     yvals.append(x.copy())
6900                 else:
6901                     xvals.append(x.copy())
6902                     yvals.append(y.copy())
6903 
6904             # stepfill is closed, step is not
6905             split = -1 if fill else 2 * len(bins)
6906             # add patches in reverse order so that when stacking,
6907             # items lower in the stack are plotted on top of
6908             # items higher in the stack
6909             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6910                 patches.append(self.fill(
6911                     x[:split], y[:split],
6912                     closed=True if fill else None,
6913                     facecolor=color,
6914                     edgecolor=None if fill else color,
6915                     fill=fill if fill else None,
6916                     zorder=None if fill else mlines.Line2D.zorder))
6917             for patch_list in patches:
6918                 for patch in patch_list:
6919                     if orientation == 'vertical':
6920                         patch.sticky_edges.y.append(0)
6921                     elif orientation == 'horizontal':
6922                         patch.sticky_edges.x.append(0)
6923 
6924             # we return patches, so put it back in the expected order
6925             patches.reverse()
6926 
6927         # If None, make all labels None (via zip_longest below); otherwise,
6928         # cast each element to str, but keep a single str as it.
6929         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6930         for patch, lbl in itertools.zip_longest(patches, labels):
6931             if patch:
6932                 p = patch[0]
6933                 p._internal_update(kwargs)
6934                 if lbl is not None:
6935                     p.set_label(lbl)
6936                 for p in patch[1:]:
6937                     p._internal_update(kwargs)
6938                     p.set_label('_nolegend_')
6939 
6940         if nx == 1:
6941             return tops[0], bins, patches[0]
6942         else:
6943             patch_type = ("BarContainer" if histtype.startswith("bar")
6944                           else "list[Polygon]")
6945             return tops, bins, cbook.silent_list(patch_type, patches)
6946 
6947     @_preprocess_data()
6948     def stairs(self, values, edges=None, *,
6949                orientation='vertical', baseline=0, fill=False, **kwargs):
6950         """
6951         A stepwise constant function as a line with bounding edges
6952         or a filled plot.
6953 
6954         Parameters
6955         ----------
6956         values : array-like
6957             The step heights.
6958 
6959         edges : array-like
6960             The edge positions, with ``len(edges) == len(vals) + 1``,
6961             between which the curve takes on vals values.
6962 
6963         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6964             The direction of the steps. Vertical means that *values* are along
6965             the y-axis, and edges are along the x-axis.
6966 
6967         baseline : float, array-like or None, default: 0
6968             The bottom value of the bounding edges or when
6969             ``fill=True``, position of lower edge. If *fill* is
6970             True or an array is passed to *baseline*, a closed
6971             path is drawn.
6972 
6973         fill : bool, default: False
6974             Whether the area under the step curve should be filled.
6975 
6976         Returns
6977         -------
6978         StepPatch : `matplotlib.patches.StepPatch`
6979 
6980         Other Parameters
6981         ----------------
6982         data : indexable object, optional
6983             DATA_PARAMETER_PLACEHOLDER
6984 
6985         **kwargs
6986             `~matplotlib.patches.StepPatch` properties
6987 
6988         """
6989 
6990         if 'color' in kwargs:
6991             _color = kwargs.pop('color')
6992         else:
6993             _color = self._get_lines.get_next_color()
6994         if fill:
6995             kwargs.setdefault('linewidth', 0)
6996             kwargs.setdefault('facecolor', _color)
6997         else:
6998             kwargs.setdefault('edgecolor', _color)
6999 
7000         if edges is None:
7001             edges = np.arange(len(values) + 1)
7002 
7003         edges, values, baseline = self._process_unit_info(
7004             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7005 
7006         patch = mpatches.StepPatch(values,
7007                                    edges,
7008                                    baseline=baseline,
7009                                    orientation=orientation,
7010                                    fill=fill,
7011                                    **kwargs)
7012         self.add_patch(patch)
7013         if baseline is None:
7014             baseline = 0
7015         if orientation == 'vertical':
7016             patch.sticky_edges.y.append(np.min(baseline))
7017             self.update_datalim([(edges[0], np.min(baseline))])
7018         else:
7019             patch.sticky_edges.x.append(np.min(baseline))
7020             self.update_datalim([(np.min(baseline), edges[0])])
7021         self._request_autoscale_view()
7022         return patch
7023 
7024     @_preprocess_data(replace_names=["x", "y", "weights"])
7025     @_docstring.dedent_interpd
7026     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7027                cmin=None, cmax=None, **kwargs):
7028         """
7029         Make a 2D histogram plot.
7030 
7031         Parameters
7032         ----------
7033         x, y : array-like, shape (n, )
7034             Input values
7035 
7036         bins : None or int or [int, int] or array-like or [array, array]
7037 
7038             The bin specification:
7039 
7040             - If int, the number of bins for the two dimensions
7041               (nx=ny=bins).
7042             - If ``[int, int]``, the number of bins in each dimension
7043               (nx, ny = bins).
7044             - If array-like, the bin edges for the two dimensions
7045               (x_edges=y_edges=bins).
7046             - If ``[array, array]``, the bin edges in each dimension
7047               (x_edges, y_edges = bins).
7048 
7049             The default value is 10.
7050 
7051         range : array-like shape(2, 2), optional
7052             The leftmost and rightmost edges of the bins along each dimension
7053             (if not specified explicitly in the bins parameters): ``[[xmin,
7054             xmax], [ymin, ymax]]``. All values outside of this range will be
7055             considered outliers and not tallied in the histogram.
7056 
7057         density : bool, default: False
7058             Normalize histogram.  See the documentation for the *density*
7059             parameter of `~.Axes.hist` for more details.
7060 
7061         weights : array-like, shape (n, ), optional
7062             An array of values w_i weighing each sample (x_i, y_i).
7063 
7064         cmin, cmax : float, default: None
7065             All bins that has count less than *cmin* or more than *cmax* will
7066             not be displayed (set to NaN before passing to imshow) and these
7067             count values in the return value count histogram will also be set
7068             to nan upon return.
7069 
7070         Returns
7071         -------
7072         h : 2D array
7073             The bi-dimensional histogram of samples x and y. Values in x are
7074             histogrammed along the first dimension and values in y are
7075             histogrammed along the second dimension.
7076         xedges : 1D array
7077             The bin edges along the x-axis.
7078         yedges : 1D array
7079             The bin edges along the y-axis.
7080         image : `~.matplotlib.collections.QuadMesh`
7081 
7082         Other Parameters
7083         ----------------
7084         %(cmap_doc)s
7085 
7086         %(norm_doc)s
7087 
7088         %(vmin_vmax_doc)s
7089 
7090         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7091             The alpha blending value.
7092 
7093         data : indexable object, optional
7094             DATA_PARAMETER_PLACEHOLDER
7095 
7096         **kwargs
7097             Additional parameters are passed along to the
7098             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7099             constructor.
7100 
7101         See Also
7102         --------
7103         hist : 1D histogram plotting
7104         hexbin : 2D histogram with hexagonal bins
7105 
7106         Notes
7107         -----
7108         - Currently ``hist2d`` calculates its own axis limits, and any limits
7109           previously set are ignored.
7110         - Rendering the histogram with a logarithmic color scale is
7111           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7112           keyword argument. Likewise, power-law normalization (similar
7113           in effect to gamma correction) can be accomplished with
7114           `.colors.PowerNorm`.
7115         """
7116 
7117         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7118                                            density=density, weights=weights)
7119 
7120         if cmin is not None:
7121             h[h < cmin] = None
7122         if cmax is not None:
7123             h[h > cmax] = None
7124 
7125         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7126         self.set_xlim(xedges[0], xedges[-1])
7127         self.set_ylim(yedges[0], yedges[-1])
7128 
7129         return h, xedges, yedges, pc
7130 
7131     @_preprocess_data(replace_names=["x", "weights"], label_namer="x")
7132     @_docstring.dedent_interpd
7133     def ecdf(self, x, weights=None, *, complementary=False,
7134              orientation="vertical", compress=False, **kwargs):
7135         """
7136         Compute and plot the empirical cumulative distribution function of *x*.
7137 
7138         .. versionadded:: 3.8
7139 
7140         Parameters
7141         ----------
7142         x : 1d array-like
7143             The input data.  Infinite entries are kept (and move the relevant
7144             end of the ecdf from 0/1), but NaNs and masked values are errors.
7145 
7146         weights : 1d array-like or None, default: None
7147             The weights of the entries; must have the same shape as *x*.
7148             Weights corresponding to NaN data points are dropped, and then the
7149             remaining weights are normalized to sum to 1.  If unset, all
7150             entries have the same weight.
7151 
7152         complementary : bool, default: False
7153             Whether to plot a cumulative distribution function, which increases
7154             from 0 to 1 (the default), or a complementary cumulative
7155             distribution function, which decreases from 1 to 0.
7156 
7157         orientation : {"vertical", "horizontal"}, default: "vertical"
7158             Whether the entries are plotted along the x-axis ("vertical", the
7159             default) or the y-axis ("horizontal").  This parameter takes the
7160             same values as in `~.Axes.hist`.
7161 
7162         compress : bool, default: False
7163             Whether multiple entries with the same values are grouped together
7164             (with a summed weight) before plotting.  This is mainly useful if
7165             *x* contains many identical data points, to decrease the rendering
7166             complexity of the plot. If *x* contains no duplicate points, this
7167             has no effect and just uses some time and memory.
7168 
7169         Other Parameters
7170         ----------------
7171         data : indexable object, optional
7172             DATA_PARAMETER_PLACEHOLDER
7173 
7174         **kwargs
7175             Keyword arguments control the `.Line2D` properties:
7176 
7177             %(Line2D:kwdoc)s
7178 
7179         Returns
7180         -------
7181         `.Line2D`
7182 
7183         Notes
7184         -----
7185         The ecdf plot can be thought of as a cumulative histogram with one bin
7186         per data entry; i.e. it reports on the entire dataset without any
7187         arbitrary binning.
7188 
7189         If *x* contains NaNs or masked entries, either remove them first from
7190         the array (if they should not taken into account), or replace them by
7191         -inf or +inf (if they should be sorted at the beginning or the end of
7192         the array).
7193         """
7194         _api.check_in_list(["horizontal", "vertical"], orientation=orientation)
7195         if "drawstyle" in kwargs or "ds" in kwargs:
7196             raise TypeError("Cannot pass 'drawstyle' or 'ds' to ecdf()")
7197         if np.ma.getmask(x).any():
7198             raise ValueError("ecdf() does not support masked entries")
7199         x = np.asarray(x)
7200         if np.isnan(x).any():
7201             raise ValueError("ecdf() does not support NaNs")
7202         argsort = np.argsort(x)
7203         x = x[argsort]
7204         if weights is None:
7205             # Ensure that we end at exactly 1, avoiding floating point errors.
7206             cum_weights = (1 + np.arange(len(x))) / len(x)
7207         else:
7208             weights = np.take(weights, argsort)   # Reorder weights like we reordered x.
7209             cum_weights = np.cumsum(weights / np.sum(weights))
7210         if compress:
7211             # Get indices of unique x values.
7212             compress_idxs = [0, *(x[:-1] != x[1:]).nonzero()[0] + 1]
7213             x = x[compress_idxs]
7214             cum_weights = cum_weights[compress_idxs]
7215         if orientation == "vertical":
7216             if not complementary:
7217                 line, = self.plot([x[0], *x], [0, *cum_weights],
7218                                   drawstyle="steps-post", **kwargs)
7219             else:
7220                 line, = self.plot([*x, x[-1]], [1, *1 - cum_weights],
7221                                   drawstyle="steps-pre", **kwargs)
7222             line.sticky_edges.y[:] = [0, 1]
7223         else:  # orientation == "horizontal":
7224             if not complementary:
7225                 line, = self.plot([0, *cum_weights], [x[0], *x],
7226                                   drawstyle="steps-pre", **kwargs)
7227             else:
7228                 line, = self.plot([1, *1 - cum_weights], [*x, x[-1]],
7229                                   drawstyle="steps-post", **kwargs)
7230             line.sticky_edges.x[:] = [0, 1]
7231         return line
7232 
7233     @_preprocess_data(replace_names=["x"])
7234     @_docstring.dedent_interpd
7235     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7236             window=None, noverlap=None, pad_to=None,
7237             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7238         r"""
7239         Plot the power spectral density.
7240 
7241         The power spectral density :math:`P_{xx}` by Welch's average
7242         periodogram method.  The vector *x* is divided into *NFFT* length
7243         segments.  Each segment is detrended by function *detrend* and
7244         windowed by function *window*.  *noverlap* gives the length of
7245         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7246         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7247         with a scaling to correct for power loss due to windowing.
7248 
7249         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7250 
7251         Parameters
7252         ----------
7253         x : 1-D array or sequence
7254             Array or sequence containing the data
7255 
7256         %(Spectral)s
7257 
7258         %(PSD)s
7259 
7260         noverlap : int, default: 0 (no overlap)
7261             The number of points of overlap between segments.
7262 
7263         Fc : int, default: 0
7264             The center frequency of *x*, which offsets the x extents of the
7265             plot to reflect the frequency range used when a signal is acquired
7266             and then filtered and downsampled to baseband.
7267 
7268         return_line : bool, default: False
7269             Whether to include the line object plotted in the returned values.
7270 
7271         Returns
7272         -------
7273         Pxx : 1-D array
7274             The values for the power spectrum :math:`P_{xx}` before scaling
7275             (real valued).
7276 
7277         freqs : 1-D array
7278             The frequencies corresponding to the elements in *Pxx*.
7279 
7280         line : `~matplotlib.lines.Line2D`
7281             The line created by this function.
7282             Only returned if *return_line* is True.
7283 
7284         Other Parameters
7285         ----------------
7286         data : indexable object, optional
7287             DATA_PARAMETER_PLACEHOLDER
7288 
7289         **kwargs
7290             Keyword arguments control the `.Line2D` properties:
7291 
7292             %(Line2D:kwdoc)s
7293 
7294         See Also
7295         --------
7296         specgram
7297             Differs in the default overlap; in not returning the mean of the
7298             segment periodograms; in returning the times of the segments; and
7299             in plotting a colormap instead of a line.
7300         magnitude_spectrum
7301             Plots the magnitude spectrum.
7302         csd
7303             Plots the spectral density between two signals.
7304 
7305         Notes
7306         -----
7307         For plotting, the power is plotted as
7308         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7309         is returned.
7310 
7311         References
7312         ----------
7313         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7314         John Wiley & Sons (1986)
7315         """
7316         if Fc is None:
7317             Fc = 0
7318 
7319         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7320                               window=window, noverlap=noverlap, pad_to=pad_to,
7321                               sides=sides, scale_by_freq=scale_by_freq)
7322         freqs += Fc
7323 
7324         if scale_by_freq in (None, True):
7325             psd_units = 'dB/Hz'
7326         else:
7327             psd_units = 'dB'
7328 
7329         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7330         self.set_xlabel('Frequency')
7331         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7332         self.grid(True)
7333 
7334         vmin, vmax = self.get_ybound()
7335         step = max(10 * int(np.log10(vmax - vmin)), 1)
7336         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7337         self.set_yticks(ticks)
7338 
7339         if return_line is None or not return_line:
7340             return pxx, freqs
7341         else:
7342             return pxx, freqs, line
7343 
7344     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7345     @_docstring.dedent_interpd
7346     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7347             window=None, noverlap=None, pad_to=None,
7348             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7349         r"""
7350         Plot the cross-spectral density.
7351 
7352         The cross spectral density :math:`P_{xy}` by Welch's average
7353         periodogram method.  The vectors *x* and *y* are divided into
7354         *NFFT* length segments.  Each segment is detrended by function
7355         *detrend* and windowed by function *window*.  *noverlap* gives
7356         the length of the overlap between segments.  The product of
7357         the direct FFTs of *x* and *y* are averaged over each segment
7358         to compute :math:`P_{xy}`, with a scaling to correct for power
7359         loss due to windowing.
7360 
7361         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7362         padded to *NFFT*.
7363 
7364         Parameters
7365         ----------
7366         x, y : 1-D arrays or sequences
7367             Arrays or sequences containing the data.
7368 
7369         %(Spectral)s
7370 
7371         %(PSD)s
7372 
7373         noverlap : int, default: 0 (no overlap)
7374             The number of points of overlap between segments.
7375 
7376         Fc : int, default: 0
7377             The center frequency of *x*, which offsets the x extents of the
7378             plot to reflect the frequency range used when a signal is acquired
7379             and then filtered and downsampled to baseband.
7380 
7381         return_line : bool, default: False
7382             Whether to include the line object plotted in the returned values.
7383 
7384         Returns
7385         -------
7386         Pxy : 1-D array
7387             The values for the cross spectrum :math:`P_{xy}` before scaling
7388             (complex valued).
7389 
7390         freqs : 1-D array
7391             The frequencies corresponding to the elements in *Pxy*.
7392 
7393         line : `~matplotlib.lines.Line2D`
7394             The line created by this function.
7395             Only returned if *return_line* is True.
7396 
7397         Other Parameters
7398         ----------------
7399         data : indexable object, optional
7400             DATA_PARAMETER_PLACEHOLDER
7401 
7402         **kwargs
7403             Keyword arguments control the `.Line2D` properties:
7404 
7405             %(Line2D:kwdoc)s
7406 
7407         See Also
7408         --------
7409         psd : is equivalent to setting ``y = x``.
7410 
7411         Notes
7412         -----
7413         For plotting, the power is plotted as
7414         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7415         is returned.
7416 
7417         References
7418         ----------
7419         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7420         John Wiley & Sons (1986)
7421         """
7422         if Fc is None:
7423             Fc = 0
7424 
7425         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7426                               window=window, noverlap=noverlap, pad_to=pad_to,
7427                               sides=sides, scale_by_freq=scale_by_freq)
7428         # pxy is complex
7429         freqs += Fc
7430 
7431         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7432         self.set_xlabel('Frequency')
7433         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7434         self.grid(True)
7435 
7436         vmin, vmax = self.get_ybound()
7437         step = max(10 * int(np.log10(vmax - vmin)), 1)
7438         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7439         self.set_yticks(ticks)
7440 
7441         if return_line is None or not return_line:
7442             return pxy, freqs
7443         else:
7444             return pxy, freqs, line
7445 
7446     @_preprocess_data(replace_names=["x"])
7447     @_docstring.dedent_interpd
7448     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7449                            pad_to=None, sides=None, scale=None,
7450                            **kwargs):
7451         """
7452         Plot the magnitude spectrum.
7453 
7454         Compute the magnitude spectrum of *x*.  Data is padded to a
7455         length of *pad_to* and the windowing function *window* is applied to
7456         the signal.
7457 
7458         Parameters
7459         ----------
7460         x : 1-D array or sequence
7461             Array or sequence containing the data.
7462 
7463         %(Spectral)s
7464 
7465         %(Single_Spectrum)s
7466 
7467         scale : {'default', 'linear', 'dB'}
7468             The scaling of the values in the *spec*.  'linear' is no scaling.
7469             'dB' returns the values in dB scale, i.e., the dB amplitude
7470             (20 * log10). 'default' is 'linear'.
7471 
7472         Fc : int, default: 0
7473             The center frequency of *x*, which offsets the x extents of the
7474             plot to reflect the frequency range used when a signal is acquired
7475             and then filtered and downsampled to baseband.
7476 
7477         Returns
7478         -------
7479         spectrum : 1-D array
7480             The values for the magnitude spectrum before scaling (real valued).
7481 
7482         freqs : 1-D array
7483             The frequencies corresponding to the elements in *spectrum*.
7484 
7485         line : `~matplotlib.lines.Line2D`
7486             The line created by this function.
7487 
7488         Other Parameters
7489         ----------------
7490         data : indexable object, optional
7491             DATA_PARAMETER_PLACEHOLDER
7492 
7493         **kwargs
7494             Keyword arguments control the `.Line2D` properties:
7495 
7496             %(Line2D:kwdoc)s
7497 
7498         See Also
7499         --------
7500         psd
7501             Plots the power spectral density.
7502         angle_spectrum
7503             Plots the angles of the corresponding frequencies.
7504         phase_spectrum
7505             Plots the phase (unwrapped angle) of the corresponding frequencies.
7506         specgram
7507             Can plot the magnitude spectrum of segments within the signal in a
7508             colormap.
7509         """
7510         if Fc is None:
7511             Fc = 0
7512 
7513         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7514                                               pad_to=pad_to, sides=sides)
7515         freqs += Fc
7516 
7517         yunits = _api.check_getitem(
7518             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7519              'dB': 'dB'},
7520             scale=scale)
7521         if yunits == 'energy':
7522             Z = spec
7523         else:  # yunits == 'dB'
7524             Z = 20. * np.log10(spec)
7525 
7526         line, = self.plot(freqs, Z, **kwargs)
7527         self.set_xlabel('Frequency')
7528         self.set_ylabel('Magnitude (%s)' % yunits)
7529 
7530         return spec, freqs, line
7531 
7532     @_preprocess_data(replace_names=["x"])
7533     @_docstring.dedent_interpd
7534     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7535                        pad_to=None, sides=None, **kwargs):
7536         """
7537         Plot the angle spectrum.
7538 
7539         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7540         Data is padded to a length of *pad_to* and the windowing function
7541         *window* is applied to the signal.
7542 
7543         Parameters
7544         ----------
7545         x : 1-D array or sequence
7546             Array or sequence containing the data.
7547 
7548         %(Spectral)s
7549 
7550         %(Single_Spectrum)s
7551 
7552         Fc : int, default: 0
7553             The center frequency of *x*, which offsets the x extents of the
7554             plot to reflect the frequency range used when a signal is acquired
7555             and then filtered and downsampled to baseband.
7556 
7557         Returns
7558         -------
7559         spectrum : 1-D array
7560             The values for the angle spectrum in radians (real valued).
7561 
7562         freqs : 1-D array
7563             The frequencies corresponding to the elements in *spectrum*.
7564 
7565         line : `~matplotlib.lines.Line2D`
7566             The line created by this function.
7567 
7568         Other Parameters
7569         ----------------
7570         data : indexable object, optional
7571             DATA_PARAMETER_PLACEHOLDER
7572 
7573         **kwargs
7574             Keyword arguments control the `.Line2D` properties:
7575 
7576             %(Line2D:kwdoc)s
7577 
7578         See Also
7579         --------
7580         magnitude_spectrum
7581             Plots the magnitudes of the corresponding frequencies.
7582         phase_spectrum
7583             Plots the unwrapped version of this function.
7584         specgram
7585             Can plot the angle spectrum of segments within the signal in a
7586             colormap.
7587         """
7588         if Fc is None:
7589             Fc = 0
7590 
7591         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7592                                           pad_to=pad_to, sides=sides)
7593         freqs += Fc
7594 
7595         lines = self.plot(freqs, spec, **kwargs)
7596         self.set_xlabel('Frequency')
7597         self.set_ylabel('Angle (radians)')
7598 
7599         return spec, freqs, lines[0]
7600 
7601     @_preprocess_data(replace_names=["x"])
7602     @_docstring.dedent_interpd
7603     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7604                        pad_to=None, sides=None, **kwargs):
7605         """
7606         Plot the phase spectrum.
7607 
7608         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7609         Data is padded to a length of *pad_to* and the windowing function
7610         *window* is applied to the signal.
7611 
7612         Parameters
7613         ----------
7614         x : 1-D array or sequence
7615             Array or sequence containing the data
7616 
7617         %(Spectral)s
7618 
7619         %(Single_Spectrum)s
7620 
7621         Fc : int, default: 0
7622             The center frequency of *x*, which offsets the x extents of the
7623             plot to reflect the frequency range used when a signal is acquired
7624             and then filtered and downsampled to baseband.
7625 
7626         Returns
7627         -------
7628         spectrum : 1-D array
7629             The values for the phase spectrum in radians (real valued).
7630 
7631         freqs : 1-D array
7632             The frequencies corresponding to the elements in *spectrum*.
7633 
7634         line : `~matplotlib.lines.Line2D`
7635             The line created by this function.
7636 
7637         Other Parameters
7638         ----------------
7639         data : indexable object, optional
7640             DATA_PARAMETER_PLACEHOLDER
7641 
7642         **kwargs
7643             Keyword arguments control the `.Line2D` properties:
7644 
7645             %(Line2D:kwdoc)s
7646 
7647         See Also
7648         --------
7649         magnitude_spectrum
7650             Plots the magnitudes of the corresponding frequencies.
7651         angle_spectrum
7652             Plots the wrapped version of this function.
7653         specgram
7654             Can plot the phase spectrum of segments within the signal in a
7655             colormap.
7656         """
7657         if Fc is None:
7658             Fc = 0
7659 
7660         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7661                                           pad_to=pad_to, sides=sides)
7662         freqs += Fc
7663 
7664         lines = self.plot(freqs, spec, **kwargs)
7665         self.set_xlabel('Frequency')
7666         self.set_ylabel('Phase (radians)')
7667 
7668         return spec, freqs, lines[0]
7669 
7670     @_preprocess_data(replace_names=["x", "y"])
7671     @_docstring.dedent_interpd
7672     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7673                window=mlab.window_hanning, noverlap=0, pad_to=None,
7674                sides='default', scale_by_freq=None, **kwargs):
7675         r"""
7676         Plot the coherence between *x* and *y*.
7677 
7678         Coherence is the normalized cross spectral density:
7679 
7680         .. math::
7681 
7682           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7683 
7684         Parameters
7685         ----------
7686         %(Spectral)s
7687 
7688         %(PSD)s
7689 
7690         noverlap : int, default: 0 (no overlap)
7691             The number of points of overlap between blocks.
7692 
7693         Fc : int, default: 0
7694             The center frequency of *x*, which offsets the x extents of the
7695             plot to reflect the frequency range used when a signal is acquired
7696             and then filtered and downsampled to baseband.
7697 
7698         Returns
7699         -------
7700         Cxy : 1-D array
7701             The coherence vector.
7702 
7703         freqs : 1-D array
7704             The frequencies for the elements in *Cxy*.
7705 
7706         Other Parameters
7707         ----------------
7708         data : indexable object, optional
7709             DATA_PARAMETER_PLACEHOLDER
7710 
7711         **kwargs
7712             Keyword arguments control the `.Line2D` properties:
7713 
7714             %(Line2D:kwdoc)s
7715 
7716         References
7717         ----------
7718         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7719         John Wiley & Sons (1986)
7720         """
7721         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7722                                  window=window, noverlap=noverlap,
7723                                  scale_by_freq=scale_by_freq, sides=sides,
7724                                  pad_to=pad_to)
7725         freqs += Fc
7726 
7727         self.plot(freqs, cxy, **kwargs)
7728         self.set_xlabel('Frequency')
7729         self.set_ylabel('Coherence')
7730         self.grid(True)
7731 
7732         return cxy, freqs
7733 
7734     @_preprocess_data(replace_names=["x"])
7735     @_docstring.dedent_interpd
7736     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7737                  window=None, noverlap=None,
7738                  cmap=None, xextent=None, pad_to=None, sides=None,
7739                  scale_by_freq=None, mode=None, scale=None,
7740                  vmin=None, vmax=None, **kwargs):
7741         """
7742         Plot a spectrogram.
7743 
7744         Compute and plot a spectrogram of data in *x*.  Data are split into
7745         *NFFT* length segments and the spectrum of each section is
7746         computed.  The windowing function *window* is applied to each
7747         segment, and the amount of overlap of each segment is
7748         specified with *noverlap*. The spectrogram is plotted as a colormap
7749         (using imshow).
7750 
7751         Parameters
7752         ----------
7753         x : 1-D array or sequence
7754             Array or sequence containing the data.
7755 
7756         %(Spectral)s
7757 
7758         %(PSD)s
7759 
7760         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7761             What sort of spectrum to use.  Default is 'psd', which takes the
7762             power spectral density.  'magnitude' returns the magnitude
7763             spectrum.  'angle' returns the phase spectrum without unwrapping.
7764             'phase' returns the phase spectrum with unwrapping.
7765 
7766         noverlap : int, default: 128
7767             The number of points of overlap between blocks.
7768 
7769         scale : {'default', 'linear', 'dB'}
7770             The scaling of the values in the *spec*.  'linear' is no scaling.
7771             'dB' returns the values in dB scale.  When *mode* is 'psd',
7772             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7773             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7774             'magnitude' and 'linear' otherwise.  This must be 'linear'
7775             if *mode* is 'angle' or 'phase'.
7776 
7777         Fc : int, default: 0
7778             The center frequency of *x*, which offsets the x extents of the
7779             plot to reflect the frequency range used when a signal is acquired
7780             and then filtered and downsampled to baseband.
7781 
7782         cmap : `.Colormap`, default: :rc:`image.cmap`
7783 
7784         xextent : *None* or (xmin, xmax)
7785             The image extent along the x-axis. The default sets *xmin* to the
7786             left border of the first bin (*spectrum* column) and *xmax* to the
7787             right border of the last bin. Note that for *noverlap>0* the width
7788             of the bins is smaller than those of the segments.
7789 
7790         data : indexable object, optional
7791             DATA_PARAMETER_PLACEHOLDER
7792 
7793         **kwargs
7794             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7795             which makes the specgram image. The origin keyword argument
7796             is not supported.
7797 
7798         Returns
7799         -------
7800         spectrum : 2D array
7801             Columns are the periodograms of successive segments.
7802 
7803         freqs : 1-D array
7804             The frequencies corresponding to the rows in *spectrum*.
7805 
7806         t : 1-D array
7807             The times corresponding to midpoints of segments (i.e., the columns
7808             in *spectrum*).
7809 
7810         im : `.AxesImage`
7811             The image created by imshow containing the spectrogram.
7812 
7813         See Also
7814         --------
7815         psd
7816             Differs in the default overlap; in returning the mean of the
7817             segment periodograms; in not returning times; and in generating a
7818             line plot instead of colormap.
7819         magnitude_spectrum
7820             A single spectrum, similar to having a single segment when *mode*
7821             is 'magnitude'. Plots a line instead of a colormap.
7822         angle_spectrum
7823             A single spectrum, similar to having a single segment when *mode*
7824             is 'angle'. Plots a line instead of a colormap.
7825         phase_spectrum
7826             A single spectrum, similar to having a single segment when *mode*
7827             is 'phase'. Plots a line instead of a colormap.
7828 
7829         Notes
7830         -----
7831         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7832         is set to 'psd'.
7833         """
7834         if NFFT is None:
7835             NFFT = 256  # same default as in mlab.specgram()
7836         if Fc is None:
7837             Fc = 0  # same default as in mlab._spectral_helper()
7838         if noverlap is None:
7839             noverlap = 128  # same default as in mlab.specgram()
7840         if Fs is None:
7841             Fs = 2  # same default as in mlab._spectral_helper()
7842 
7843         if mode == 'complex':
7844             raise ValueError('Cannot plot a complex specgram')
7845 
7846         if scale is None or scale == 'default':
7847             if mode in ['angle', 'phase']:
7848                 scale = 'linear'
7849             else:
7850                 scale = 'dB'
7851         elif mode in ['angle', 'phase'] and scale == 'dB':
7852             raise ValueError('Cannot use dB scale with angle or phase mode')
7853 
7854         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7855                                        detrend=detrend, window=window,
7856                                        noverlap=noverlap, pad_to=pad_to,
7857                                        sides=sides,
7858                                        scale_by_freq=scale_by_freq,
7859                                        mode=mode)
7860 
7861         if scale == 'linear':
7862             Z = spec
7863         elif scale == 'dB':
7864             if mode is None or mode == 'default' or mode == 'psd':
7865                 Z = 10. * np.log10(spec)
7866             else:
7867                 Z = 20. * np.log10(spec)
7868         else:
7869             raise ValueError(f'Unknown scale {scale!r}')
7870 
7871         Z = np.flipud(Z)
7872 
7873         if xextent is None:
7874             # padding is needed for first and last segment:
7875             pad_xextent = (NFFT-noverlap) / Fs / 2
7876             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7877         xmin, xmax = xextent
7878         freqs += Fc
7879         extent = xmin, xmax, freqs[0], freqs[-1]
7880 
7881         if 'origin' in kwargs:
7882             raise _api.kwarg_error("specgram", "origin")
7883 
7884         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7885                          origin='upper', **kwargs)
7886         self.axis('auto')
7887 
7888         return spec, freqs, t, im
7889 
7890     @_docstring.dedent_interpd
7891     def spy(self, Z, precision=0, marker=None, markersize=None,
7892             aspect='equal', origin="upper", **kwargs):
7893         """
7894         Plot the sparsity pattern of a 2D array.
7895 
7896         This visualizes the non-zero values of the array.
7897 
7898         Two plotting styles are available: image and marker. Both
7899         are available for full arrays, but only the marker style
7900         works for `scipy.sparse.spmatrix` instances.
7901 
7902         **Image style**
7903 
7904         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7905         extra remaining keyword arguments are passed to this method.
7906 
7907         **Marker style**
7908 
7909         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7910         *None*, a `.Line2D` object will be returned with the value of marker
7911         determining the marker type, and any remaining keyword arguments
7912         passed to `~.Axes.plot`.
7913 
7914         Parameters
7915         ----------
7916         Z : (M, N) array-like
7917             The array to be plotted.
7918 
7919         precision : float or 'present', default: 0
7920             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7921             values of :math:`|Z| > precision` will be plotted.
7922 
7923             For `scipy.sparse.spmatrix` instances, you can also
7924             pass 'present'. In this case any value present in the array
7925             will be plotted, even if it is identically zero.
7926 
7927         aspect : {'equal', 'auto', None} or float, default: 'equal'
7928             The aspect ratio of the Axes.  This parameter is particularly
7929             relevant for images since it determines whether data pixels are
7930             square.
7931 
7932             This parameter is a shortcut for explicitly calling
7933             `.Axes.set_aspect`. See there for further details.
7934 
7935             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7936             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7937               that the data fit in the Axes. In general, this will result in
7938               non-square pixels.
7939             - *None*: Use :rc:`image.aspect`.
7940 
7941         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7942             Place the [0, 0] index of the array in the upper left or lower left
7943             corner of the Axes. The convention 'upper' is typically used for
7944             matrices and images.
7945 
7946         Returns
7947         -------
7948         `~matplotlib.image.AxesImage` or `.Line2D`
7949             The return type depends on the plotting style (see above).
7950 
7951         Other Parameters
7952         ----------------
7953         **kwargs
7954             The supported additional parameters depend on the plotting style.
7955 
7956             For the image style, you can pass the following additional
7957             parameters of `~.Axes.imshow`:
7958 
7959             - *cmap*
7960             - *alpha*
7961             - *url*
7962             - any `.Artist` properties (passed on to the `.AxesImage`)
7963 
7964             For the marker style, you can pass any `.Line2D` property except
7965             for *linestyle*:
7966 
7967             %(Line2D:kwdoc)s
7968         """
7969         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
7970             marker = 's'
7971         _api.check_in_list(["upper", "lower"], origin=origin)
7972         if marker is None and markersize is None:
7973             Z = np.asarray(Z)
7974             mask = np.abs(Z) > precision
7975 
7976             if 'cmap' not in kwargs:
7977                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
7978                                                         name='binary')
7979             if 'interpolation' in kwargs:
7980                 raise _api.kwarg_error("spy", "interpolation")
7981             if 'norm' not in kwargs:
7982                 kwargs['norm'] = mcolors.NoNorm()
7983             ret = self.imshow(mask, interpolation='nearest',
7984                               aspect=aspect, origin=origin,
7985                               **kwargs)
7986         else:
7987             if hasattr(Z, 'tocoo'):
7988                 c = Z.tocoo()
7989                 if precision == 'present':
7990                     y = c.row
7991                     x = c.col
7992                 else:
7993                     nonzero = np.abs(c.data) > precision
7994                     y = c.row[nonzero]
7995                     x = c.col[nonzero]
7996             else:
7997                 Z = np.asarray(Z)
7998                 nonzero = np.abs(Z) > precision
7999                 y, x = np.nonzero(nonzero)
8000             if marker is None:
8001                 marker = 's'
8002             if markersize is None:
8003                 markersize = 10
8004             if 'linestyle' in kwargs:
8005                 raise _api.kwarg_error("spy", "linestyle")
8006             ret = mlines.Line2D(
8007                 x, y, linestyle='None', marker=marker, markersize=markersize,
8008                 **kwargs)
8009             self.add_line(ret)
8010             nr, nc = Z.shape
8011             self.set_xlim(-0.5, nc - 0.5)
8012             if origin == "upper":
8013                 self.set_ylim(nr - 0.5, -0.5)
8014             else:
8015                 self.set_ylim(-0.5, nr - 0.5)
8016             self.set_aspect(aspect)
8017         self.title.set_y(1.05)
8018         if origin == "upper":
8019             self.xaxis.tick_top()
8020         else:  # lower
8021             self.xaxis.tick_bottom()
8022         self.xaxis.set_ticks_position('both')
8023         self.xaxis.set_major_locator(
8024             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8025         self.yaxis.set_major_locator(
8026             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8027         return ret
8028 
8029     def matshow(self, Z, **kwargs):
8030         """
8031         Plot the values of a 2D matrix or array as color-coded image.
8032 
8033         The matrix will be shown the way it would be printed, with the first
8034         row at the top.  Row and column numbering is zero-based.
8035 
8036         Parameters
8037         ----------
8038         Z : (M, N) array-like
8039             The matrix to be displayed.
8040 
8041         Returns
8042         -------
8043         `~matplotlib.image.AxesImage`
8044 
8045         Other Parameters
8046         ----------------
8047         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
8048 
8049         See Also
8050         --------
8051         imshow : More general function to plot data on a 2D regular raster.
8052 
8053         Notes
8054         -----
8055         This is just a convenience function wrapping `.imshow` to set useful
8056         defaults for displaying a matrix. In particular:
8057 
8058         - Set ``origin='upper'``.
8059         - Set ``interpolation='nearest'``.
8060         - Set ``aspect='equal'``.
8061         - Ticks are placed to the left and above.
8062         - Ticks are formatted to show integer indices.
8063 
8064         """
8065         Z = np.asanyarray(Z)
8066         kw = {'origin': 'upper',
8067               'interpolation': 'nearest',
8068               'aspect': 'equal',          # (already the imshow default)
8069               **kwargs}
8070         im = self.imshow(Z, **kw)
8071         self.title.set_y(1.05)
8072         self.xaxis.tick_top()
8073         self.xaxis.set_ticks_position('both')
8074         self.xaxis.set_major_locator(
8075             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8076         self.yaxis.set_major_locator(
8077             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
8078         return im
8079 
8080     @_preprocess_data(replace_names=["dataset"])
8081     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
8082                    showmeans=False, showextrema=True, showmedians=False,
8083                    quantiles=None, points=100, bw_method=None):
8084         """
8085         Make a violin plot.
8086 
8087         Make a violin plot for each column of *dataset* or each vector in
8088         sequence *dataset*.  Each filled area extends to represent the
8089         entire data range, with optional lines at the mean, the median,
8090         the minimum, the maximum, and user-specified quantiles.
8091 
8092         Parameters
8093         ----------
8094         dataset : Array or a sequence of vectors.
8095           The input data.
8096 
8097         positions : array-like, default: [1, 2, ..., n]
8098           The positions of the violins. The ticks and limits are
8099           automatically set to match the positions.
8100 
8101         vert : bool, default: True.
8102           If true, creates a vertical violin plot.
8103           Otherwise, creates a horizontal violin plot.
8104 
8105         widths : array-like, default: 0.5
8106           Either a scalar or a vector that sets the maximal width of
8107           each violin. The default is 0.5, which uses about half of the
8108           available horizontal space.
8109 
8110         showmeans : bool, default: False
8111           If `True`, will toggle rendering of the means.
8112 
8113         showextrema : bool, default: True
8114           If `True`, will toggle rendering of the extrema.
8115 
8116         showmedians : bool, default: False
8117           If `True`, will toggle rendering of the medians.
8118 
8119         quantiles : array-like, default: None
8120           If not None, set a list of floats in interval [0, 1] for each violin,
8121           which stands for the quantiles that will be rendered for that
8122           violin.
8123 
8124         points : int, default: 100
8125           Defines the number of points to evaluate each of the
8126           gaussian kernel density estimations at.
8127 
8128         bw_method : str, scalar or callable, optional
8129           The method used to calculate the estimator bandwidth.  This can be
8130           'scott', 'silverman', a scalar constant or a callable.  If a
8131           scalar, this will be used directly as `kde.factor`.  If a
8132           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8133           its only parameter and return a scalar. If None (default), 'scott'
8134           is used.
8135 
8136         data : indexable object, optional
8137             DATA_PARAMETER_PLACEHOLDER
8138 
8139         Returns
8140         -------
8141         dict
8142           A dictionary mapping each component of the violinplot to a
8143           list of the corresponding collection instances created. The
8144           dictionary has the following keys:
8145 
8146           - ``bodies``: A list of the `~.collections.PolyCollection`
8147             instances containing the filled area of each violin.
8148 
8149           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8150             the mean values of each of the violin's distribution.
8151 
8152           - ``cmins``: A `~.collections.LineCollection` instance that marks
8153             the bottom of each violin's distribution.
8154 
8155           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8156             the top of each violin's distribution.
8157 
8158           - ``cbars``: A `~.collections.LineCollection` instance that marks
8159             the centers of each violin's distribution.
8160 
8161           - ``cmedians``: A `~.collections.LineCollection` instance that
8162             marks the median values of each of the violin's distribution.
8163 
8164           - ``cquantiles``: A `~.collections.LineCollection` instance created
8165             to identify the quantile values of each of the violin's
8166             distribution.
8167 
8168         """
8169 
8170         def _kde_method(X, coords):
8171             # Unpack in case of e.g. Pandas or xarray object
8172             X = cbook._unpack_to_numpy(X)
8173             # fallback gracefully if the vector contains only one value
8174             if np.all(X[0] == X):
8175                 return (X[0] == coords).astype(float)
8176             kde = mlab.GaussianKDE(X, bw_method)
8177             return kde.evaluate(coords)
8178 
8179         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8180                                      quantiles=quantiles)
8181         return self.violin(vpstats, positions=positions, vert=vert,
8182                            widths=widths, showmeans=showmeans,
8183                            showextrema=showextrema, showmedians=showmedians)
8184 
8185     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8186                showmeans=False, showextrema=True, showmedians=False):
8187         """
8188         Drawing function for violin plots.
8189 
8190         Draw a violin plot for each column of *vpstats*. Each filled area
8191         extends to represent the entire data range, with optional lines at the
8192         mean, the median, the minimum, the maximum, and the quantiles values.
8193 
8194         Parameters
8195         ----------
8196         vpstats : list of dicts
8197           A list of dictionaries containing stats for each violin plot.
8198           Required keys are:
8199 
8200           - ``coords``: A list of scalars containing the coordinates that
8201             the violin's kernel density estimate were evaluated at.
8202 
8203           - ``vals``: A list of scalars containing the values of the
8204             kernel density estimate at each of the coordinates given
8205             in *coords*.
8206 
8207           - ``mean``: The mean value for this violin's dataset.
8208 
8209           - ``median``: The median value for this violin's dataset.
8210 
8211           - ``min``: The minimum value for this violin's dataset.
8212 
8213           - ``max``: The maximum value for this violin's dataset.
8214 
8215           Optional keys are:
8216 
8217           - ``quantiles``: A list of scalars containing the quantile values
8218             for this violin's dataset.
8219 
8220         positions : array-like, default: [1, 2, ..., n]
8221           The positions of the violins. The ticks and limits are
8222           automatically set to match the positions.
8223 
8224         vert : bool, default: True.
8225           If true, plots the violins vertically.
8226           Otherwise, plots the violins horizontally.
8227 
8228         widths : array-like, default: 0.5
8229           Either a scalar or a vector that sets the maximal width of
8230           each violin. The default is 0.5, which uses about half of the
8231           available horizontal space.
8232 
8233         showmeans : bool, default: False
8234           If true, will toggle rendering of the means.
8235 
8236         showextrema : bool, default: True
8237           If true, will toggle rendering of the extrema.
8238 
8239         showmedians : bool, default: False
8240           If true, will toggle rendering of the medians.
8241 
8242         Returns
8243         -------
8244         dict
8245           A dictionary mapping each component of the violinplot to a
8246           list of the corresponding collection instances created. The
8247           dictionary has the following keys:
8248 
8249           - ``bodies``: A list of the `~.collections.PolyCollection`
8250             instances containing the filled area of each violin.
8251 
8252           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8253             the mean values of each of the violin's distribution.
8254 
8255           - ``cmins``: A `~.collections.LineCollection` instance that marks
8256             the bottom of each violin's distribution.
8257 
8258           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8259             the top of each violin's distribution.
8260 
8261           - ``cbars``: A `~.collections.LineCollection` instance that marks
8262             the centers of each violin's distribution.
8263 
8264           - ``cmedians``: A `~.collections.LineCollection` instance that
8265             marks the median values of each of the violin's distribution.
8266 
8267           - ``cquantiles``: A `~.collections.LineCollection` instance created
8268             to identify the quantiles values of each of the violin's
8269             distribution.
8270         """
8271 
8272         # Statistical quantities to be plotted on the violins
8273         means = []
8274         mins = []
8275         maxes = []
8276         medians = []
8277         quantiles = []
8278 
8279         qlens = []  # Number of quantiles in each dataset.
8280 
8281         artists = {}  # Collections to be returned
8282 
8283         N = len(vpstats)
8284         datashape_message = ("List of violinplot statistics and `{0}` "
8285                              "values must have the same length")
8286 
8287         # Validate positions
8288         if positions is None:
8289             positions = range(1, N + 1)
8290         elif len(positions) != N:
8291             raise ValueError(datashape_message.format("positions"))
8292 
8293         # Validate widths
8294         if np.isscalar(widths):
8295             widths = [widths] * N
8296         elif len(widths) != N:
8297             raise ValueError(datashape_message.format("widths"))
8298 
8299         # Calculate ranges for statistics lines (shape (2, N)).
8300         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8301 
8302         # Colors.
8303         if mpl.rcParams['_internal.classic_mode']:
8304             fillcolor = 'y'
8305             linecolor = 'r'
8306         else:
8307             fillcolor = linecolor = self._get_lines.get_next_color()
8308 
8309         # Check whether we are rendering vertically or horizontally
8310         if vert:
8311             fill = self.fill_betweenx
8312             perp_lines = functools.partial(self.hlines, colors=linecolor)
8313             par_lines = functools.partial(self.vlines, colors=linecolor)
8314         else:
8315             fill = self.fill_between
8316             perp_lines = functools.partial(self.vlines, colors=linecolor)
8317             par_lines = functools.partial(self.hlines, colors=linecolor)
8318 
8319         # Render violins
8320         bodies = []
8321         for stats, pos, width in zip(vpstats, positions, widths):
8322             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8323             vals = np.array(stats['vals'])
8324             vals = 0.5 * width * vals / vals.max()
8325             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8326                             facecolor=fillcolor, alpha=0.3)]
8327             means.append(stats['mean'])
8328             mins.append(stats['min'])
8329             maxes.append(stats['max'])
8330             medians.append(stats['median'])
8331             q = stats.get('quantiles')  # a list of floats, or None
8332             if q is None:
8333                 q = []
8334             quantiles.extend(q)
8335             qlens.append(len(q))
8336         artists['bodies'] = bodies
8337 
8338         if showmeans:  # Render means
8339             artists['cmeans'] = perp_lines(means, *line_ends)
8340         if showextrema:  # Render extrema
8341             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8342             artists['cmins'] = perp_lines(mins, *line_ends)
8343             artists['cbars'] = par_lines(positions, mins, maxes)
8344         if showmedians:  # Render medians
8345             artists['cmedians'] = perp_lines(medians, *line_ends)
8346         if quantiles:  # Render quantiles: each width is repeated qlen times.
8347             artists['cquantiles'] = perp_lines(
8348                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8349 
8350         return artists
8351 
8352     # Methods that are entirely implemented in other modules.
8353 
8354     table = mtable.table
8355 
8356     # args can be either Y or y1, y2, ... and all should be replaced
8357     stackplot = _preprocess_data()(mstack.stackplot)
8358 
8359     streamplot = _preprocess_data(
8360         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8361 
8362     tricontour = mtri.tricontour
8363     tricontourf = mtri.tricontourf
8364     tripcolor = mtri.tripcolor
8365     triplot = mtri.triplot
8366 
8367     def _get_aspect_ratio(self):
8368         """
8369         Convenience method to calculate the aspect ratio of the axes in
8370         the display coordinate system.
8371         """
8372         figure_size = self.get_figure().get_size_inches()
8373         ll, ur = self.get_position() * figure_size
8374         width, height = ur - ll
8375         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:43:19.568 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 14:43:19.568 | INFO     | Search-only: skipping patch selection
2025-10-17 14:43:19.706 | INFO     | Task matplotlib__matplotlib-25547 completed successfully.
2025-10-17 14:43:19.707 | INFO     | No patch generated. You can try running ACR again.
