2025-10-17 18:21:14.198 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 18:21:16.726 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=869, output_tokens=12, cost=0.009050
2025-10-17 18:21:40.452 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1049, output_tokens=943, cost=0.038780
2025-10-17 18:21:41.485 | INFO     | registered non reproducing test 0
2025-10-17 18:22:00.314 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2361, output_tokens=810, cost=0.047910
2025-10-17 18:22:04.878 | INFO     | registered non reproducing test 1
2025-10-17 18:22:27.023 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4847, output_tokens=842, cost=0.073730
2025-10-17 18:22:28.559 | INFO     | registered non reproducing test 2
2025-10-17 18:22:28.559 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 18:22:28.562 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:22:38.809 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1170, output_tokens=407, cost=0.023910
2025-10-17 18:22:38.813 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:22:41.109 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=761, output_tokens=52, cost=0.009170
2025-10-17 18:22:41.110 | DEBUG    | Extracted a valid json.
2025-10-17 18:22:41.110 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"InheritanceDiagram\")",
        "search_method(\"make_path_relative\")",
        "search_code(\"svg\")",
        "search_code(\"path\")"
    ],
    "bug_locations": []
}
2025-10-17 18:22:41.911 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 18:22:41.911 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 18:23:04.163 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3517, output_tokens=907, cost=0.062380
2025-10-17 18:23:04.171 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:23:12.968 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4640, output_tokens=332, cost=0.056360
2025-10-17 18:23:12.972 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:23:20.692 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=686, output_tokens=328, cost=0.016700
2025-10-17 18:23:20.693 | DEBUG    | Extracted a valid json.
2025-10-17 18:23:20.693 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/ext/inheritance_diagram.py",
            "class": "InheritanceDiagram",
            "method": "",
            "intended_behavior": "This class, specifically within its method responsible for generating the SVG, needs to ensure that paths for links within the SVG are correctly computed relative to the documentation's build output directory, not just relative to the SVG itself. The fix should ensure that when an SVG diagram is embedded in a document not at the root level, the links within the SVG correctly consider the document's position in the directory structure to avoid resulting in 404 errors. This could involve modifying how the paths are calculated within this class, potentially introducing a new method to correctly calculate the relative paths based on the document embedding the SVG, or adjusting the existing logic to account for the embedding document's location."
        },
        {
            "file": "sphinx/writers/html5.py",
            "class": "",
            "method": "",
            "intended_behavior": "In the context of writing HTML5 output, where SVGs are included, this file should ensure that any embedded objects, particularly SVG images with links, have their paths resolved in a way that accurately reflects their location within the overall site structure. If this file contributes to processing or embedding SVG content, it may need adjustments to correctly handle path resolution for links within SVGs. The specific method(s) responsible for this might need to be examined and modified to ensure that paths are correctly computed, taking the embedding documentâ€™s location into account."
        }
    ]
}
2025-10-17 18:23:20.700 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/inheritance_diagram.py</file>
<class>InheritanceDiagram</class>
<method>None</method>
<code>
332 class InheritanceDiagram(SphinxDirective):
333     """
334     Run when the inheritance_diagram directive is first encountered.
335     """
336     has_content = False
337     required_arguments = 1
338     optional_arguments = 0
339     final_argument_whitespace = True
340     option_spec: OptionSpec = {
341         'parts': int,
342         'private-bases': directives.flag,
343         'caption': directives.unchanged,
344         'top-classes': directives.unchanged_required,
345     }
346 
347     def run(self) -> list[Node]:
348         node = inheritance_diagram()
349         node.document = self.state.document
350         class_names = self.arguments[0].split()
351         class_role = self.env.get_domain('py').role('class')
352         # Store the original content for use as a hash
353         node['parts'] = self.options.get('parts', 0)
354         node['content'] = ', '.join(class_names)
355         node['top-classes'] = []
356         for cls in self.options.get('top-classes', '').split(','):
357             cls = cls.strip()
358             if cls:
359                 node['top-classes'].append(cls)
360 
361         # Create a graph starting with the list of classes
362         try:
363             graph = InheritanceGraph(
364                 class_names, self.env.ref_context.get('py:module'),  # type: ignore[arg-type]
365                 parts=node['parts'],
366                 private_bases='private-bases' in self.options,
367                 aliases=self.config.inheritance_alias,
368                 top_classes=node['top-classes'])
369         except InheritanceException as err:
370             return [node.document.reporter.warning(err, line=self.lineno)]
371 
372         # Create xref nodes for each target of the graph's image map and
373         # add them to the doc tree so that Sphinx can resolve the
374         # references to real URLs later.  These nodes will eventually be
375         # removed from the doctree after we're done with them.
376         for name in graph.get_all_class_names():
377             refnodes, x = class_role(  # type: ignore
378                 'class', ':class:`%s`' % name, name, 0, self.state)  # type: ignore
379             node.extend(refnodes)
380         # Store the graph object so we can use it to generate the
381         # dot file later
382         node['graph'] = graph
383 
384         if 'caption' not in self.options:
385             self.add_name(node)
386             return [node]
387         else:
388             figure = figure_wrapper(self, node, self.options['caption'])
389             self.add_name(figure)
390             return [figure]

</code><intended_behavior>This class, specifically within its method responsible for generating the SVG, needs to ensure that paths for links within the SVG are correctly computed relative to the documentation's build output directory, not just relative to the SVG itself. The fix should ensure that when an SVG diagram is embedded in a document not at the root level, the links within the SVG correctly consider the document's position in the directory structure to avoid resulting in 404 errors. This could involve modifying how the paths are calculated within this class, potentially introducing a new method to correctly calculate the relative paths based on the document embedding the SVG, or adjusting the existing logic to account for the embedding document's location.</intended_behavior>, <file>sphinx/writers/html5.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Experimental docutils writers for HTML5 handling Sphinx's custom nodes."""
2 
3 from __future__ import annotations
4 
5 import os
6 import posixpath
7 import re
8 import urllib.parse
9 from collections.abc import Iterable
10 from typing import TYPE_CHECKING, cast
11 
12 from docutils import nodes
13 from docutils.nodes import Element, Node, Text
14 from docutils.writers.html5_polyglot import HTMLTranslator as BaseTranslator
15 
16 from sphinx import addnodes
17 from sphinx.builders import Builder
18 from sphinx.locale import _, __, admonitionlabels
19 from sphinx.util import logging
20 from sphinx.util.docutils import SphinxTranslator
21 from sphinx.util.images import get_image_size
22 
23 if TYPE_CHECKING:
24     from sphinx.builders.html import StandaloneHTMLBuilder
25 
26 
27 logger = logging.getLogger(__name__)
28 
29 # A good overview of the purpose behind these classes can be found here:
30 # http://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html
31 
32 
33 def multiply_length(length: str, scale: int) -> str:
34     """Multiply *length* (width or height) by *scale*."""
35     matched = re.match(r'^(\d*\.?\d*)\s*(\S*)$', length)
36     if not matched:
37         return length
38     if scale == 100:
39         return length
40     amount, unit = matched.groups()
41     result = float(amount) * scale / 100
42     return f"{int(result)}{unit}"
43 
44 
45 class HTML5Translator(SphinxTranslator, BaseTranslator):
46     """
47     Our custom HTML translator.
48     """
49 
50     builder: StandaloneHTMLBuilder
51     # Override docutils.writers.html5_polyglot:HTMLTranslator
52     # otherwise, nodes like <inline classes="s">...</inline> will be
53     # converted to <s>...</s> by `visit_inline`.
54     supported_inline_tags: set[str] = set()
55 
56     def __init__(self, document: nodes.document, builder: Builder) -> None:
57         super().__init__(document, builder)
58 
59         self.highlighter = self.builder.highlighter
60         self.docnames = [self.builder.current_docname]  # for singlehtml builder
61         self.manpages_url = self.config.manpages_url
62         self.protect_literal_text = 0
63         self.secnumber_suffix = self.config.html_secnumber_suffix
64         self.param_separator = ''
65         self.optional_param_level = 0
66         self._table_row_indices = [0]
67         self._fieldlist_row_indices = [0]
68         self.required_params_left = 0
69 
70     def visit_start_of_file(self, node: Element) -> None:
71         # only occurs in the single-file builder
72         self.docnames.append(node['docname'])
73         self.body.append('<span id="document-%s"></span>' % node['docname'])
74 
75     def depart_start_of_file(self, node: Element) -> None:
76         self.docnames.pop()
77 
78     #############################################################
79     # Domain-specific object descriptions
80     #############################################################
81 
82     # Top-level nodes for descriptions
83     ##################################
84 
85     def visit_desc(self, node: Element) -> None:
86         self.body.append(self.starttag(node, 'dl'))
87 
88     def depart_desc(self, node: Element) -> None:
89         self.body.append('</dl>\n\n')
90 
91     def visit_desc_signature(self, node: Element) -> None:
92         # the id is set automatically
93         self.body.append(self.starttag(node, 'dt'))
94         self.protect_literal_text += 1
95 
96     def depart_desc_signature(self, node: Element) -> None:
97         self.protect_literal_text -= 1
98         if not node.get('is_multiline'):
99             self.add_permalink_ref(node, _('Permalink to this definition'))
100         self.body.append('</dt>\n')
101 
102     def visit_desc_signature_line(self, node: Element) -> None:
103         pass
104 
105     def depart_desc_signature_line(self, node: Element) -> None:
106         if node.get('add_permalink'):
107             # the permalink info is on the parent desc_signature node
108             self.add_permalink_ref(node.parent, _('Permalink to this definition'))
109         self.body.append('<br />')
110 
111     def visit_desc_content(self, node: Element) -> None:
112         self.body.append(self.starttag(node, 'dd', ''))
113 
114     def depart_desc_content(self, node: Element) -> None:
115         self.body.append('</dd>')
116 
117     def visit_desc_inline(self, node: Element) -> None:
118         self.body.append(self.starttag(node, 'span', ''))
119 
120     def depart_desc_inline(self, node: Element) -> None:
121         self.body.append('</span>')
122 
123     # Nodes for high-level structure in signatures
124     ##############################################
125 
126     def visit_desc_name(self, node: Element) -> None:
127         self.body.append(self.starttag(node, 'span', ''))
128 
129     def depart_desc_name(self, node: Element) -> None:
130         self.body.append('</span>')
131 
132     def visit_desc_addname(self, node: Element) -> None:
133         self.body.append(self.starttag(node, 'span', ''))
134 
135     def depart_desc_addname(self, node: Element) -> None:
136         self.body.append('</span>')
137 
138     def visit_desc_type(self, node: Element) -> None:
139         pass
140 
141     def depart_desc_type(self, node: Element) -> None:
142         pass
143 
144     def visit_desc_returns(self, node: Element) -> None:
145         self.body.append(' <span class="sig-return">')
146         self.body.append('<span class="sig-return-icon">&#x2192;</span>')
147         self.body.append(' <span class="sig-return-typehint">')
148 
149     def depart_desc_returns(self, node: Element) -> None:
150         self.body.append('</span></span>')
151 
152     def _visit_sig_parameter_list(
153         self,
154         node: Element,
155         parameter_group: type[Element],
156         sig_open_paren: str,
157         sig_close_paren: str,
158     ) -> None:
159         """Visit a signature parameters or type parameters list.
160 
161         The *parameter_group* value is the type of child nodes acting as required parameters
162         or as a set of contiguous optional parameters.
163         """
164         self.body.append(f'<span class="sig-paren">{sig_open_paren}</span>')
165         self.is_first_param = True
166         self.optional_param_level = 0
167         self.params_left_at_level = 0
168         self.param_group_index = 0
169         # Counts as what we call a parameter group either a required parameter, or a
170         # set of contiguous optional ones.
171         self.list_is_required_param = [isinstance(c, parameter_group) for c in node.children]
172         # How many required parameters are left.
173         self.required_params_left = sum(self.list_is_required_param)
174         self.param_separator = node.child_text_separator
175         self.multi_line_parameter_list = node.get('multi_line_parameter_list', False)
176         if self.multi_line_parameter_list:
177             self.body.append('\n\n')
178             self.body.append(self.starttag(node, 'dl'))
179             self.param_separator = self.param_separator.rstrip()
180         self.context.append(sig_close_paren)
181 
182     def _depart_sig_parameter_list(self, node: Element) -> None:
183         if node.get('multi_line_parameter_list'):
184             self.body.append('</dl>\n\n')
185         sig_close_paren = self.context.pop()
186         self.body.append(f'<span class="sig-paren">{sig_close_paren}</span>')
187 
188     def visit_desc_parameterlist(self, node: Element) -> None:
189         self._visit_sig_parameter_list(node, addnodes.desc_parameter, '(', ')')
190 
191     def depart_desc_parameterlist(self, node: Element) -> None:
192         self._depart_sig_parameter_list(node)
193 
194     def visit_desc_type_parameter_list(self, node: Element) -> None:
195         self._visit_sig_parameter_list(node, addnodes.desc_type_parameter, '[', ']')
196 
197     def depart_desc_type_parameter_list(self, node: Element) -> None:
198         self._depart_sig_parameter_list(node)
199 
200     # If required parameters are still to come, then put the comma after
201     # the parameter.  Otherwise, put the comma before.  This ensures that
202     # signatures like the following render correctly (see issue #1001):
203     #
204     #     foo([a, ]b, c[, d])
205     #
206     def visit_desc_parameter(self, node: Element) -> None:
207         on_separate_line = self.multi_line_parameter_list
208         if on_separate_line and not (self.is_first_param and self.optional_param_level > 0):
209             self.body.append(self.starttag(node, 'dd', ''))
210         if self.is_first_param:
211             self.is_first_param = False
212         elif not on_separate_line and not self.required_params_left:
213             self.body.append(self.param_separator)
214         if self.optional_param_level == 0:
215             self.required_params_left -= 1
216         else:
217             self.params_left_at_level -= 1
218         if not node.hasattr('noemph'):
219             self.body.append('<em class="sig-param">')
220 
221     def depart_desc_parameter(self, node: Element) -> None:
222         if not node.hasattr('noemph'):
223             self.body.append('</em>')
224         is_required = self.list_is_required_param[self.param_group_index]
225         if self.multi_line_parameter_list:
226             is_last_group = self.param_group_index + 1 == len(self.list_is_required_param)
227             next_is_required = (
228                 not is_last_group
229                 and self.list_is_required_param[self.param_group_index + 1]
230             )
231             opt_param_left_at_level = self.params_left_at_level > 0
232             if opt_param_left_at_level or is_required and (is_last_group or next_is_required):
233                 self.body.append(self.param_separator)
234                 self.body.append('</dd>\n')
235 
236         elif self.required_params_left:
237             self.body.append(self.param_separator)
238 
239         if is_required:
240             self.param_group_index += 1
241 
242     def visit_desc_type_parameter(self, node: Element) -> None:
243         self.visit_desc_parameter(node)
244 
245     def depart_desc_type_parameter(self, node: Element) -> None:
246         self.depart_desc_parameter(node)
247 
248     def visit_desc_optional(self, node: Element) -> None:
249         self.params_left_at_level = sum([isinstance(c, addnodes.desc_parameter)
250                                          for c in node.children])
251         self.optional_param_level += 1
252         self.max_optional_param_level = self.optional_param_level
253         if self.multi_line_parameter_list:
254             # If the first parameter is optional, start a new line and open the bracket.
255             if self.is_first_param:
256                 self.body.append(self.starttag(node, 'dd', ''))
257                 self.body.append('<span class="optional">[</span>')
258             # Else, if there remains at least one required parameter, append the
259             # parameter separator, open a new bracket, and end the line.
260             elif self.required_params_left:
261                 self.body.append(self.param_separator)
262                 self.body.append('<span class="optional">[</span>')
263                 self.body.append('</dd>\n')
264             # Else, open a new bracket, append the parameter separator,
265             # and end the line.
266             else:
267                 self.body.append('<span class="optional">[</span>')
268                 self.body.append(self.param_separator)
269                 self.body.append('</dd>\n')
270         else:
271             self.body.append('<span class="optional">[</span>')
272 
273     def depart_desc_optional(self, node: Element) -> None:
274         self.optional_param_level -= 1
275         if self.multi_line_parameter_list:
276             # If it's the first time we go down one level, add the separator
277             # before the bracket.
278             if self.optional_param_level == self.max_optional_param_level - 1:
279                 self.body.append(self.param_separator)
280             self.body.append('<span class="optional">]</span>')
281             # End the line if we have just closed the last bracket of this
282             # optional parameter group.
283             if self.optional_param_level == 0:
284                 self.body.append('</dd>\n')
285         else:
286             self.body.append('<span class="optional">]</span>')
287         if self.optional_param_level == 0:
288             self.param_group_index += 1
289 
290     def visit_desc_annotation(self, node: Element) -> None:
291         self.body.append(self.starttag(node, 'em', '', CLASS='property'))
292 
293     def depart_desc_annotation(self, node: Element) -> None:
294         self.body.append('</em>')
295 
296     ##############################################
297 
298     def visit_versionmodified(self, node: Element) -> None:
299         self.body.append(self.starttag(node, 'div', CLASS=node['type']))
300 
301     def depart_versionmodified(self, node: Element) -> None:
302         self.body.append('</div>\n')
303 
304     # overwritten
305     def visit_reference(self, node: Element) -> None:
306         atts = {'class': 'reference'}
307         if node.get('internal') or 'refuri' not in node:
308             atts['class'] += ' internal'
309         else:
310             atts['class'] += ' external'
311         if 'refuri' in node:
312             atts['href'] = node['refuri'] or '#'
313             if self.settings.cloak_email_addresses and atts['href'].startswith('mailto:'):
314                 atts['href'] = self.cloak_mailto(atts['href'])
315                 self.in_mailto = True
316         else:
317             assert 'refid' in node, \
318                    'References must have "refuri" or "refid" attribute.'
319             atts['href'] = '#' + node['refid']
320         if not isinstance(node.parent, nodes.TextElement):
321             assert len(node) == 1 and isinstance(node[0], nodes.image)  # NoQA: PT018
322             atts['class'] += ' image-reference'
323         if 'reftitle' in node:
324             atts['title'] = node['reftitle']
325         if 'target' in node:
326             atts['target'] = node['target']
327         self.body.append(self.starttag(node, 'a', '', **atts))
328 
329         if node.get('secnumber'):
330             self.body.append(('%s' + self.secnumber_suffix) %
331                              '.'.join(map(str, node['secnumber'])))
332 
333     def visit_number_reference(self, node: Element) -> None:
334         self.visit_reference(node)
335 
336     def depart_number_reference(self, node: Element) -> None:
337         self.depart_reference(node)
338 
339     # overwritten -- we don't want source comments to show up in the HTML
340     def visit_comment(self, node: Element) -> None:  # type: ignore
341         raise nodes.SkipNode
342 
343     # overwritten
344     def visit_admonition(self, node: Element, name: str = '') -> None:
345         self.body.append(self.starttag(
346             node, 'div', CLASS=('admonition ' + name)))
347         if name:
348             node.insert(0, nodes.title(name, admonitionlabels[name]))
349 
350     def depart_admonition(self, node: Element | None = None) -> None:
351         self.body.append('</div>\n')
352 
353     def visit_seealso(self, node: Element) -> None:
354         self.visit_admonition(node, 'seealso')
355 
356     def depart_seealso(self, node: Element) -> None:
357         self.depart_admonition(node)
358 
359     def get_secnumber(self, node: Element) -> tuple[int, ...] | None:
360         if node.get('secnumber'):
361             return node['secnumber']
362 
363         if isinstance(node.parent, nodes.section):
364             if self.builder.name == 'singlehtml':
365                 docname = self.docnames[-1]
366                 anchorname = "{}/#{}".format(docname, node.parent['ids'][0])
367                 if anchorname not in self.builder.secnumbers:
368                     anchorname = "%s/" % docname  # try first heading which has no anchor
369             else:
370                 anchorname = '#' + node.parent['ids'][0]
371                 if anchorname not in self.builder.secnumbers:
372                     anchorname = ''  # try first heading which has no anchor
373 
374             if self.builder.secnumbers.get(anchorname):
375                 return self.builder.secnumbers[anchorname]
376 
377         return None
378 
379     def add_secnumber(self, node: Element) -> None:
380         secnumber = self.get_secnumber(node)
381         if secnumber:
382             self.body.append('<span class="section-number">%s</span>' %
383                              ('.'.join(map(str, secnumber)) + self.secnumber_suffix))
384 
385     def add_fignumber(self, node: Element) -> None:
386         def append_fignumber(figtype: str, figure_id: str) -> None:
387             if self.builder.name == 'singlehtml':
388                 key = f"{self.docnames[-1]}/{figtype}"
389             else:
390                 key = figtype
391 
392             if figure_id in self.builder.fignumbers.get(key, {}):
393                 self.body.append('<span class="caption-number">')
394                 prefix = self.config.numfig_format.get(figtype)
395                 if prefix is None:
396                     msg = __('numfig_format is not defined for %s') % figtype
397                     logger.warning(msg)
398                 else:
399                     numbers = self.builder.fignumbers[key][figure_id]
400                     self.body.append(prefix % '.'.join(map(str, numbers)) + ' ')
401                     self.body.append('</span>')
402 
403         figtype = self.builder.env.domains['std'].get_enumerable_node_type(node)
404         if figtype:
405             if len(node['ids']) == 0:
406                 msg = __('Any IDs not assigned for %s node') % node.tagname
407                 logger.warning(msg, location=node)
408             else:
409                 append_fignumber(figtype, node['ids'][0])
410 
411     def add_permalink_ref(self, node: Element, title: str) -> None:
412         if node['ids'] and self.config.html_permalinks and self.builder.add_permalinks:
413             format = '<a class="headerlink" href="#%s" title="%s">%s</a>'
414             self.body.append(format % (node['ids'][0], title,
415                                        self.config.html_permalinks_icon))
416 
417     # overwritten
418     def visit_bullet_list(self, node: Element) -> None:
419         if len(node) == 1 and isinstance(node[0], addnodes.toctree):
420             # avoid emitting empty <ul></ul>
421             raise nodes.SkipNode
422         super().visit_bullet_list(node)
423 
424     # overwritten
425     def visit_definition(self, node: Element) -> None:
426         # don't insert </dt> here.
427         self.body.append(self.starttag(node, 'dd', ''))
428 
429     # overwritten
430     def depart_definition(self, node: Element) -> None:
431         self.body.append('</dd>\n')
432 
433     # overwritten
434     def visit_classifier(self, node: Element) -> None:
435         self.body.append(self.starttag(node, 'span', '', CLASS='classifier'))
436 
437     # overwritten
438     def depart_classifier(self, node: Element) -> None:
439         self.body.append('</span>')
440 
441         next_node: Node = node.next_node(descend=False, siblings=True)
442         if not isinstance(next_node, nodes.classifier):
443             # close `<dt>` tag at the tail of classifiers
444             self.body.append('</dt>')
445 
446     # overwritten
447     def visit_term(self, node: Element) -> None:
448         self.body.append(self.starttag(node, 'dt', ''))
449 
450     # overwritten
451     def depart_term(self, node: Element) -> None:
452         next_node: Node = node.next_node(descend=False, siblings=True)
453         if isinstance(next_node, nodes.classifier):
454             # Leave the end tag to `self.depart_classifier()`, in case
455             # there's a classifier.
456             pass
457         else:
458             if isinstance(node.parent.parent.parent, addnodes.glossary):
459                 # add permalink if glossary terms
460                 self.add_permalink_ref(node, _('Permalink to this term'))
461 
462             self.body.append('</dt>')
463 
464     # overwritten
465     def visit_title(self, node: Element) -> None:
466         if isinstance(node.parent, addnodes.compact_paragraph) and node.parent.get('toctree'):
467             self.body.append(self.starttag(node, 'p', '', CLASS='caption', ROLE='heading'))
468             self.body.append('<span class="caption-text">')
469             self.context.append('</span></p>\n')
470         else:
471             super().visit_title(node)
472         self.add_secnumber(node)
473         self.add_fignumber(node.parent)
474         if isinstance(node.parent, nodes.table):
475             self.body.append('<span class="caption-text">')
476 
477     def depart_title(self, node: Element) -> None:
478         close_tag = self.context[-1]
479         if (self.config.html_permalinks and self.builder.add_permalinks and
480                 node.parent.hasattr('ids') and node.parent['ids']):
481             # add permalink anchor
482             if close_tag.startswith('</h'):
483                 self.add_permalink_ref(node.parent, _('Permalink to this heading'))
484             elif close_tag.startswith('</a></h'):
485                 self.body.append('</a><a class="headerlink" href="#%s" ' %
486                                  node.parent['ids'][0] +
487                                  'title="{}">{}'.format(
488                                      _('Permalink to this heading'),
489                                      self.config.html_permalinks_icon))
490             elif isinstance(node.parent, nodes.table):
491                 self.body.append('</span>')
492                 self.add_permalink_ref(node.parent, _('Permalink to this table'))
493         elif isinstance(node.parent, nodes.table):
494             self.body.append('</span>')
495 
496         super().depart_title(node)
497 
498     # overwritten
499     def visit_literal_block(self, node: Element) -> None:
500         if node.rawsource != node.astext():
501             # most probably a parsed-literal block -- don't highlight
502             return super().visit_literal_block(node)
503 
504         lang = node.get('language', 'default')
505         linenos = node.get('linenos', False)
506         highlight_args = node.get('highlight_args', {})
507         highlight_args['force'] = node.get('force', False)
508         opts = self.config.highlight_options.get(lang, {})
509 
510         if linenos and self.config.html_codeblock_linenos_style:
511             linenos = self.config.html_codeblock_linenos_style
512 
513         highlighted = self.highlighter.highlight_block(
514             node.rawsource, lang, opts=opts, linenos=linenos,
515             location=node, **highlight_args,
516         )
517         starttag = self.starttag(node, 'div', suffix='',
518                                  CLASS='highlight-%s notranslate' % lang)
519         self.body.append(starttag + highlighted + '</div>\n')
520         raise nodes.SkipNode
521 
522     def visit_caption(self, node: Element) -> None:
523         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
524             self.body.append('<div class="code-block-caption">')
525         else:
526             super().visit_caption(node)
527         self.add_fignumber(node.parent)
528         self.body.append(self.starttag(node, 'span', '', CLASS='caption-text'))
529 
530     def depart_caption(self, node: Element) -> None:
531         self.body.append('</span>')
532 
533         # append permalink if available
534         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
535             self.add_permalink_ref(node.parent, _('Permalink to this code'))
536         elif isinstance(node.parent, nodes.figure):
537             self.add_permalink_ref(node.parent, _('Permalink to this image'))
538         elif node.parent.get('toctree'):
539             self.add_permalink_ref(node.parent.parent, _('Permalink to this toctree'))
540 
541         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
542             self.body.append('</div>\n')
543         else:
544             super().depart_caption(node)
545 
546     def visit_doctest_block(self, node: Element) -> None:
547         self.visit_literal_block(node)
548 
549     # overwritten to add the <div> (for XHTML compliance)
550     def visit_block_quote(self, node: Element) -> None:
551         self.body.append(self.starttag(node, 'blockquote') + '<div>')
552 
553     def depart_block_quote(self, node: Element) -> None:
554         self.body.append('</div></blockquote>\n')
555 
556     # overwritten
557     def visit_literal(self, node: Element) -> None:
558         if 'kbd' in node['classes']:
559             self.body.append(self.starttag(node, 'kbd', '',
560                                            CLASS='docutils literal notranslate'))
561             return
562         lang = node.get("language", None)
563         if 'code' not in node['classes'] or not lang:
564             self.body.append(self.starttag(node, 'code', '',
565                                            CLASS='docutils literal notranslate'))
566             self.protect_literal_text += 1
567             return
568 
569         opts = self.config.highlight_options.get(lang, {})
570         highlighted = self.highlighter.highlight_block(
571             node.astext(), lang, opts=opts, location=node, nowrap=True)
572         starttag = self.starttag(
573             node,
574             "code",
575             suffix="",
576             CLASS="docutils literal highlight highlight-%s" % lang,
577         )
578         self.body.append(starttag + highlighted.strip() + "</code>")
579         raise nodes.SkipNode
580 
581     def depart_literal(self, node: Element) -> None:
582         if 'kbd' in node['classes']:
583             self.body.append('</kbd>')
584         else:
585             self.protect_literal_text -= 1
586             self.body.append('</code>')
587 
588     def visit_productionlist(self, node: Element) -> None:
589         self.body.append(self.starttag(node, 'pre'))
590         names = []
591         productionlist = cast(Iterable[addnodes.production], node)
592         for production in productionlist:
593             names.append(production['tokenname'])
594         maxlen = max(len(name) for name in names)
595         lastname = None
596         for production in productionlist:
597             if production['tokenname']:
598                 lastname = production['tokenname'].ljust(maxlen)
599                 self.body.append(self.starttag(production, 'strong', ''))
600                 self.body.append(lastname + '</strong> ::= ')
601             elif lastname is not None:
602                 self.body.append('%s     ' % (' ' * len(lastname)))
603             production.walkabout(self)
604             self.body.append('\n')
605         self.body.append('</pre>\n')
606         raise nodes.SkipNode
607 
608     def depart_productionlist(self, node: Element) -> None:
609         pass
610 
611     def visit_production(self, node: Element) -> None:
612         pass
613 
614     def depart_production(self, node: Element) -> None:
615         pass
616 
617     def visit_centered(self, node: Element) -> None:
618         self.body.append(self.starttag(node, 'p', CLASS="centered") +
619                          '<strong>')
620 
621     def depart_centered(self, node: Element) -> None:
622         self.body.append('</strong></p>')
623 
624     def visit_compact_paragraph(self, node: Element) -> None:
625         pass
626 
627     def depart_compact_paragraph(self, node: Element) -> None:
628         pass
629 
630     def visit_download_reference(self, node: Element) -> None:
631         atts = {'class': 'reference download',
632                 'download': ''}
633 
634         if not self.builder.download_support:
635             self.context.append('')
636         elif 'refuri' in node:
637             atts['class'] += ' external'
638             atts['href'] = node['refuri']
639             self.body.append(self.starttag(node, 'a', '', **atts))
640             self.context.append('</a>')
641         elif 'filename' in node:
642             atts['class'] += ' internal'
643             atts['href'] = posixpath.join(self.builder.dlpath,
644                                           urllib.parse.quote(node['filename']))
645             self.body.append(self.starttag(node, 'a', '', **atts))
646             self.context.append('</a>')
647         else:
648             self.context.append('')
649 
650     def depart_download_reference(self, node: Element) -> None:
651         self.body.append(self.context.pop())
652 
653     # overwritten
654     def visit_figure(self, node: Element) -> None:
655         # set align=default if align not specified to give a default style
656         node.setdefault('align', 'default')
657 
658         return super().visit_figure(node)
659 
660     # overwritten
661     def visit_image(self, node: Element) -> None:
662         olduri = node['uri']
663         # rewrite the URI if the environment knows about it
664         if olduri in self.builder.images:
665             node['uri'] = posixpath.join(self.builder.imgpath,
666                                          urllib.parse.quote(self.builder.images[olduri]))
667 
668         if 'scale' in node:
669             # Try to figure out image height and width.  Docutils does that too,
670             # but it tries the final file name, which does not necessarily exist
671             # yet at the time the HTML file is written.
672             if not ('width' in node and 'height' in node):
673                 size = get_image_size(os.path.join(self.builder.srcdir, olduri))
674                 if size is None:
675                     logger.warning(
676                         __('Could not obtain image size. :scale: option is ignored.'),
677                         location=node,
678                     )
679                 else:
680                     if 'width' not in node:
681                         node['width'] = str(size[0])
682                     if 'height' not in node:
683                         node['height'] = str(size[1])
684 
685         uri = node['uri']
686         if uri.lower().endswith(('svg', 'svgz')):
687             atts = {'src': uri}
688             if 'width' in node:
689                 atts['width'] = node['width']
690             if 'height' in node:
691                 atts['height'] = node['height']
692             if 'scale' in node:
693                 if 'width' in atts:
694                     atts['width'] = multiply_length(atts['width'], node['scale'])
695                 if 'height' in atts:
696                     atts['height'] = multiply_length(atts['height'], node['scale'])
697             atts['alt'] = node.get('alt', uri)
698             if 'align' in node:
699                 atts['class'] = 'align-%s' % node['align']
700             self.body.append(self.emptytag(node, 'img', '', **atts))
701             return
702 
703         super().visit_image(node)
704 
705     # overwritten
706     def depart_image(self, node: Element) -> None:
707         if node['uri'].lower().endswith(('svg', 'svgz')):
708             pass
709         else:
710             super().depart_image(node)
711 
712     def visit_toctree(self, node: Element) -> None:
713         # this only happens when formatting a toc from env.tocs -- in this
714         # case we don't want to include the subtree
715         raise nodes.SkipNode
716 
717     def visit_index(self, node: Element) -> None:
718         raise nodes.SkipNode
719 
720     def visit_tabular_col_spec(self, node: Element) -> None:
721         raise nodes.SkipNode
722 
723     def visit_glossary(self, node: Element) -> None:
724         pass
725 
726     def depart_glossary(self, node: Element) -> None:
727         pass
728 
729     def visit_acks(self, node: Element) -> None:
730         pass
731 
732     def depart_acks(self, node: Element) -> None:
733         pass
734 
735     def visit_hlist(self, node: Element) -> None:
736         self.body.append('<table class="hlist"><tr>')
737 
738     def depart_hlist(self, node: Element) -> None:
739         self.body.append('</tr></table>\n')
740 
741     def visit_hlistcol(self, node: Element) -> None:
742         self.body.append('<td>')
743 
744     def depart_hlistcol(self, node: Element) -> None:
745         self.body.append('</td>')
746 
747     # overwritten
748     def visit_Text(self, node: Text) -> None:
749         text = node.astext()
750         encoded = self.encode(text)
751         if self.protect_literal_text:
752             # moved here from base class's visit_literal to support
753             # more formatting in literal nodes
754             for token in self.words_and_spaces.findall(encoded):
755                 if token.strip():
756                     # protect literal text from line wrapping
757                     self.body.append('<span class="pre">%s</span>' % token)
758                 elif token in ' \n':
759                     # allow breaks at whitespace
760                     self.body.append(token)
761                 else:
762                     # protect runs of multiple spaces; the last one can wrap
763                     self.body.append('&#160;' * (len(token) - 1) + ' ')
764         else:
765             if self.in_mailto and self.settings.cloak_email_addresses:
766                 encoded = self.cloak_email(encoded)
767             self.body.append(encoded)
768 
769     def visit_note(self, node: Element) -> None:
770         self.visit_admonition(node, 'note')
771 
772     def depart_note(self, node: Element) -> None:
773         self.depart_admonition(node)
774 
775     def visit_warning(self, node: Element) -> None:
776         self.visit_admonition(node, 'warning')
777 
778     def depart_warning(self, node: Element) -> None:
779         self.depart_admonition(node)
780 
781     def visit_attention(self, node: Element) -> None:
782         self.visit_admonition(node, 'attention')
783 
784     def depart_attention(self, node: Element) -> None:
785         self.depart_admonition(node)
786 
787     def visit_caution(self, node: Element) -> None:
788         self.visit_admonition(node, 'caution')
789 
790     def depart_caution(self, node: Element) -> None:
791         self.depart_admonition(node)
792 
793     def visit_danger(self, node: Element) -> None:
794         self.visit_admonition(node, 'danger')
795 
796     def depart_danger(self, node: Element) -> None:
797         self.depart_admonition(node)
798 
799     def visit_error(self, node: Element) -> None:
800         self.visit_admonition(node, 'error')
801 
802     def depart_error(self, node: Element) -> None:
803         self.depart_admonition(node)
804 
805     def visit_hint(self, node: Element) -> None:
806         self.visit_admonition(node, 'hint')
807 
808     def depart_hint(self, node: Element) -> None:
809         self.depart_admonition(node)
810 
811     def visit_important(self, node: Element) -> None:
812         self.visit_admonition(node, 'important')
813 
814     def depart_important(self, node: Element) -> None:
815         self.depart_admonition(node)
816 
817     def visit_tip(self, node: Element) -> None:
818         self.visit_admonition(node, 'tip')
819 
820     def depart_tip(self, node: Element) -> None:
821         self.depart_admonition(node)
822 
823     def visit_literal_emphasis(self, node: Element) -> None:
824         return self.visit_emphasis(node)
825 
826     def depart_literal_emphasis(self, node: Element) -> None:
827         return self.depart_emphasis(node)
828 
829     def visit_literal_strong(self, node: Element) -> None:
830         return self.visit_strong(node)
831 
832     def depart_literal_strong(self, node: Element) -> None:
833         return self.depart_strong(node)
834 
835     def visit_abbreviation(self, node: Element) -> None:
836         attrs = {}
837         if node.hasattr('explanation'):
838             attrs['title'] = node['explanation']
839         self.body.append(self.starttag(node, 'abbr', '', **attrs))
840 
841     def depart_abbreviation(self, node: Element) -> None:
842         self.body.append('</abbr>')
843 
844     def visit_manpage(self, node: Element) -> None:
845         self.visit_literal_emphasis(node)
846         if self.manpages_url:
847             node['refuri'] = self.manpages_url.format(**node.attributes)
848             self.visit_reference(node)
849 
850     def depart_manpage(self, node: Element) -> None:
851         if self.manpages_url:
852             self.depart_reference(node)
853         self.depart_literal_emphasis(node)
854 
855     # overwritten to add even/odd classes
856 
857     def visit_table(self, node: Element) -> None:
858         self._table_row_indices.append(0)
859 
860         atts = {}
861         classes = [cls.strip(' \t\n') for cls in self.settings.table_style.split(',')]
862         classes.insert(0, "docutils")  # compat
863 
864         # set align-default if align not specified to give a default style
865         classes.append('align-%s' % node.get('align', 'default'))
866 
867         if 'width' in node:
868             atts['style'] = 'width: %s' % node['width']
869         tag = self.starttag(node, 'table', CLASS=' '.join(classes), **atts)
870         self.body.append(tag)
871 
872     def depart_table(self, node: Element) -> None:
873         self._table_row_indices.pop()
874         super().depart_table(node)
875 
876     def visit_row(self, node: Element) -> None:
877         self._table_row_indices[-1] += 1
878         if self._table_row_indices[-1] % 2 == 0:
879             node['classes'].append('row-even')
880         else:
881             node['classes'].append('row-odd')
882         self.body.append(self.starttag(node, 'tr', ''))
883         node.column = 0  # type: ignore
884 
885     def visit_field_list(self, node: Element) -> None:
886         self._fieldlist_row_indices.append(0)
887         return super().visit_field_list(node)
888 
889     def depart_field_list(self, node: Element) -> None:
890         self._fieldlist_row_indices.pop()
891         return super().depart_field_list(node)
892 
893     def visit_field(self, node: Element) -> None:
894         self._fieldlist_row_indices[-1] += 1
895         if self._fieldlist_row_indices[-1] % 2 == 0:
896             node['classes'].append('field-even')
897         else:
898             node['classes'].append('field-odd')
899 
900     def visit_math(self, node: Element, math_env: str = '') -> None:
901         # see validate_math_renderer
902         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
903         visit, _ = self.builder.app.registry.html_inline_math_renderers[name]
904         visit(self, node)
905 
906     def depart_math(self, node: Element, math_env: str = '') -> None:
907         # see validate_math_renderer
908         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
909         _, depart = self.builder.app.registry.html_inline_math_renderers[name]
910         if depart:
911             depart(self, node)
912 
913     def visit_math_block(self, node: Element, math_env: str = '') -> None:
914         # see validate_math_renderer
915         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
916         visit, _ = self.builder.app.registry.html_block_math_renderers[name]
917         visit(self, node)
918 
919     def depart_math_block(self, node: Element, math_env: str = '') -> None:
920         # see validate_math_renderer
921         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
922         _, depart = self.builder.app.registry.html_block_math_renderers[name]
923         if depart:
924             depart(self, node)
925 
926     # See Docutils r9413
927     # Re-instate the footnote-reference class
928     def visit_footnote_reference(self, node):
929         href = '#' + node['refid']
930         classes = ['footnote-reference', self.settings.footnote_references]
931         self.body.append(self.starttag(node, 'a', suffix='', classes=classes,
932                                        role='doc-noteref', href=href))
933         self.body.append('<span class="fn-bracket">[</span>')

</code><intended_behavior>In the context of writing HTML5 output, where SVGs are included, this file should ensure that any embedded objects, particularly SVG images with links, have their paths resolved in a way that accurately reflects their location within the overall site structure. If this file contributes to processing or embedding SVG content, it may need adjustments to correctly handle path resolution for links within SVGs. The specific method(s) responsible for this might need to be examined and modified to ensure that paths are correctly computed, taking the embedding documentâ€™s location into account.</intended_behavior>]
2025-10-17 18:23:20.700 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/inheritance_diagram.py</file>
<class>InheritanceDiagram</class>
<method>None</method>
<code>
332 class InheritanceDiagram(SphinxDirective):
333     """
334     Run when the inheritance_diagram directive is first encountered.
335     """
336     has_content = False
337     required_arguments = 1
338     optional_arguments = 0
339     final_argument_whitespace = True
340     option_spec: OptionSpec = {
341         'parts': int,
342         'private-bases': directives.flag,
343         'caption': directives.unchanged,
344         'top-classes': directives.unchanged_required,
345     }
346 
347     def run(self) -> list[Node]:
348         node = inheritance_diagram()
349         node.document = self.state.document
350         class_names = self.arguments[0].split()
351         class_role = self.env.get_domain('py').role('class')
352         # Store the original content for use as a hash
353         node['parts'] = self.options.get('parts', 0)
354         node['content'] = ', '.join(class_names)
355         node['top-classes'] = []
356         for cls in self.options.get('top-classes', '').split(','):
357             cls = cls.strip()
358             if cls:
359                 node['top-classes'].append(cls)
360 
361         # Create a graph starting with the list of classes
362         try:
363             graph = InheritanceGraph(
364                 class_names, self.env.ref_context.get('py:module'),  # type: ignore[arg-type]
365                 parts=node['parts'],
366                 private_bases='private-bases' in self.options,
367                 aliases=self.config.inheritance_alias,
368                 top_classes=node['top-classes'])
369         except InheritanceException as err:
370             return [node.document.reporter.warning(err, line=self.lineno)]
371 
372         # Create xref nodes for each target of the graph's image map and
373         # add them to the doc tree so that Sphinx can resolve the
374         # references to real URLs later.  These nodes will eventually be
375         # removed from the doctree after we're done with them.
376         for name in graph.get_all_class_names():
377             refnodes, x = class_role(  # type: ignore
378                 'class', ':class:`%s`' % name, name, 0, self.state)  # type: ignore
379             node.extend(refnodes)
380         # Store the graph object so we can use it to generate the
381         # dot file later
382         node['graph'] = graph
383 
384         if 'caption' not in self.options:
385             self.add_name(node)
386             return [node]
387         else:
388             figure = figure_wrapper(self, node, self.options['caption'])
389             self.add_name(figure)
390             return [figure]

</code><intended_behavior>This class, specifically within its method responsible for generating the SVG, needs to ensure that paths for links within the SVG are correctly computed relative to the documentation's build output directory, not just relative to the SVG itself. The fix should ensure that when an SVG diagram is embedded in a document not at the root level, the links within the SVG correctly consider the document's position in the directory structure to avoid resulting in 404 errors. This could involve modifying how the paths are calculated within this class, potentially introducing a new method to correctly calculate the relative paths based on the document embedding the SVG, or adjusting the existing logic to account for the embedding document's location.</intended_behavior>, <file>sphinx/writers/html5.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Experimental docutils writers for HTML5 handling Sphinx's custom nodes."""
2 
3 from __future__ import annotations
4 
5 import os
6 import posixpath
7 import re
8 import urllib.parse
9 from collections.abc import Iterable
10 from typing import TYPE_CHECKING, cast
11 
12 from docutils import nodes
13 from docutils.nodes import Element, Node, Text
14 from docutils.writers.html5_polyglot import HTMLTranslator as BaseTranslator
15 
16 from sphinx import addnodes
17 from sphinx.builders import Builder
18 from sphinx.locale import _, __, admonitionlabels
19 from sphinx.util import logging
20 from sphinx.util.docutils import SphinxTranslator
21 from sphinx.util.images import get_image_size
22 
23 if TYPE_CHECKING:
24     from sphinx.builders.html import StandaloneHTMLBuilder
25 
26 
27 logger = logging.getLogger(__name__)
28 
29 # A good overview of the purpose behind these classes can be found here:
30 # http://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html
31 
32 
33 def multiply_length(length: str, scale: int) -> str:
34     """Multiply *length* (width or height) by *scale*."""
35     matched = re.match(r'^(\d*\.?\d*)\s*(\S*)$', length)
36     if not matched:
37         return length
38     if scale == 100:
39         return length
40     amount, unit = matched.groups()
41     result = float(amount) * scale / 100
42     return f"{int(result)}{unit}"
43 
44 
45 class HTML5Translator(SphinxTranslator, BaseTranslator):
46     """
47     Our custom HTML translator.
48     """
49 
50     builder: StandaloneHTMLBuilder
51     # Override docutils.writers.html5_polyglot:HTMLTranslator
52     # otherwise, nodes like <inline classes="s">...</inline> will be
53     # converted to <s>...</s> by `visit_inline`.
54     supported_inline_tags: set[str] = set()
55 
56     def __init__(self, document: nodes.document, builder: Builder) -> None:
57         super().__init__(document, builder)
58 
59         self.highlighter = self.builder.highlighter
60         self.docnames = [self.builder.current_docname]  # for singlehtml builder
61         self.manpages_url = self.config.manpages_url
62         self.protect_literal_text = 0
63         self.secnumber_suffix = self.config.html_secnumber_suffix
64         self.param_separator = ''
65         self.optional_param_level = 0
66         self._table_row_indices = [0]
67         self._fieldlist_row_indices = [0]
68         self.required_params_left = 0
69 
70     def visit_start_of_file(self, node: Element) -> None:
71         # only occurs in the single-file builder
72         self.docnames.append(node['docname'])
73         self.body.append('<span id="document-%s"></span>' % node['docname'])
74 
75     def depart_start_of_file(self, node: Element) -> None:
76         self.docnames.pop()
77 
78     #############################################################
79     # Domain-specific object descriptions
80     #############################################################
81 
82     # Top-level nodes for descriptions
83     ##################################
84 
85     def visit_desc(self, node: Element) -> None:
86         self.body.append(self.starttag(node, 'dl'))
87 
88     def depart_desc(self, node: Element) -> None:
89         self.body.append('</dl>\n\n')
90 
91     def visit_desc_signature(self, node: Element) -> None:
92         # the id is set automatically
93         self.body.append(self.starttag(node, 'dt'))
94         self.protect_literal_text += 1
95 
96     def depart_desc_signature(self, node: Element) -> None:
97         self.protect_literal_text -= 1
98         if not node.get('is_multiline'):
99             self.add_permalink_ref(node, _('Permalink to this definition'))
100         self.body.append('</dt>\n')
101 
102     def visit_desc_signature_line(self, node: Element) -> None:
103         pass
104 
105     def depart_desc_signature_line(self, node: Element) -> None:
106         if node.get('add_permalink'):
107             # the permalink info is on the parent desc_signature node
108             self.add_permalink_ref(node.parent, _('Permalink to this definition'))
109         self.body.append('<br />')
110 
111     def visit_desc_content(self, node: Element) -> None:
112         self.body.append(self.starttag(node, 'dd', ''))
113 
114     def depart_desc_content(self, node: Element) -> None:
115         self.body.append('</dd>')
116 
117     def visit_desc_inline(self, node: Element) -> None:
118         self.body.append(self.starttag(node, 'span', ''))
119 
120     def depart_desc_inline(self, node: Element) -> None:
121         self.body.append('</span>')
122 
123     # Nodes for high-level structure in signatures
124     ##############################################
125 
126     def visit_desc_name(self, node: Element) -> None:
127         self.body.append(self.starttag(node, 'span', ''))
128 
129     def depart_desc_name(self, node: Element) -> None:
130         self.body.append('</span>')
131 
132     def visit_desc_addname(self, node: Element) -> None:
133         self.body.append(self.starttag(node, 'span', ''))
134 
135     def depart_desc_addname(self, node: Element) -> None:
136         self.body.append('</span>')
137 
138     def visit_desc_type(self, node: Element) -> None:
139         pass
140 
141     def depart_desc_type(self, node: Element) -> None:
142         pass
143 
144     def visit_desc_returns(self, node: Element) -> None:
145         self.body.append(' <span class="sig-return">')
146         self.body.append('<span class="sig-return-icon">&#x2192;</span>')
147         self.body.append(' <span class="sig-return-typehint">')
148 
149     def depart_desc_returns(self, node: Element) -> None:
150         self.body.append('</span></span>')
151 
152     def _visit_sig_parameter_list(
153         self,
154         node: Element,
155         parameter_group: type[Element],
156         sig_open_paren: str,
157         sig_close_paren: str,
158     ) -> None:
159         """Visit a signature parameters or type parameters list.
160 
161         The *parameter_group* value is the type of child nodes acting as required parameters
162         or as a set of contiguous optional parameters.
163         """
164         self.body.append(f'<span class="sig-paren">{sig_open_paren}</span>')
165         self.is_first_param = True
166         self.optional_param_level = 0
167         self.params_left_at_level = 0
168         self.param_group_index = 0
169         # Counts as what we call a parameter group either a required parameter, or a
170         # set of contiguous optional ones.
171         self.list_is_required_param = [isinstance(c, parameter_group) for c in node.children]
172         # How many required parameters are left.
173         self.required_params_left = sum(self.list_is_required_param)
174         self.param_separator = node.child_text_separator
175         self.multi_line_parameter_list = node.get('multi_line_parameter_list', False)
176         if self.multi_line_parameter_list:
177             self.body.append('\n\n')
178             self.body.append(self.starttag(node, 'dl'))
179             self.param_separator = self.param_separator.rstrip()
180         self.context.append(sig_close_paren)
181 
182     def _depart_sig_parameter_list(self, node: Element) -> None:
183         if node.get('multi_line_parameter_list'):
184             self.body.append('</dl>\n\n')
185         sig_close_paren = self.context.pop()
186         self.body.append(f'<span class="sig-paren">{sig_close_paren}</span>')
187 
188     def visit_desc_parameterlist(self, node: Element) -> None:
189         self._visit_sig_parameter_list(node, addnodes.desc_parameter, '(', ')')
190 
191     def depart_desc_parameterlist(self, node: Element) -> None:
192         self._depart_sig_parameter_list(node)
193 
194     def visit_desc_type_parameter_list(self, node: Element) -> None:
195         self._visit_sig_parameter_list(node, addnodes.desc_type_parameter, '[', ']')
196 
197     def depart_desc_type_parameter_list(self, node: Element) -> None:
198         self._depart_sig_parameter_list(node)
199 
200     # If required parameters are still to come, then put the comma after
201     # the parameter.  Otherwise, put the comma before.  This ensures that
202     # signatures like the following render correctly (see issue #1001):
203     #
204     #     foo([a, ]b, c[, d])
205     #
206     def visit_desc_parameter(self, node: Element) -> None:
207         on_separate_line = self.multi_line_parameter_list
208         if on_separate_line and not (self.is_first_param and self.optional_param_level > 0):
209             self.body.append(self.starttag(node, 'dd', ''))
210         if self.is_first_param:
211             self.is_first_param = False
212         elif not on_separate_line and not self.required_params_left:
213             self.body.append(self.param_separator)
214         if self.optional_param_level == 0:
215             self.required_params_left -= 1
216         else:
217             self.params_left_at_level -= 1
218         if not node.hasattr('noemph'):
219             self.body.append('<em class="sig-param">')
220 
221     def depart_desc_parameter(self, node: Element) -> None:
222         if not node.hasattr('noemph'):
223             self.body.append('</em>')
224         is_required = self.list_is_required_param[self.param_group_index]
225         if self.multi_line_parameter_list:
226             is_last_group = self.param_group_index + 1 == len(self.list_is_required_param)
227             next_is_required = (
228                 not is_last_group
229                 and self.list_is_required_param[self.param_group_index + 1]
230             )
231             opt_param_left_at_level = self.params_left_at_level > 0
232             if opt_param_left_at_level or is_required and (is_last_group or next_is_required):
233                 self.body.append(self.param_separator)
234                 self.body.append('</dd>\n')
235 
236         elif self.required_params_left:
237             self.body.append(self.param_separator)
238 
239         if is_required:
240             self.param_group_index += 1
241 
242     def visit_desc_type_parameter(self, node: Element) -> None:
243         self.visit_desc_parameter(node)
244 
245     def depart_desc_type_parameter(self, node: Element) -> None:
246         self.depart_desc_parameter(node)
247 
248     def visit_desc_optional(self, node: Element) -> None:
249         self.params_left_at_level = sum([isinstance(c, addnodes.desc_parameter)
250                                          for c in node.children])
251         self.optional_param_level += 1
252         self.max_optional_param_level = self.optional_param_level
253         if self.multi_line_parameter_list:
254             # If the first parameter is optional, start a new line and open the bracket.
255             if self.is_first_param:
256                 self.body.append(self.starttag(node, 'dd', ''))
257                 self.body.append('<span class="optional">[</span>')
258             # Else, if there remains at least one required parameter, append the
259             # parameter separator, open a new bracket, and end the line.
260             elif self.required_params_left:
261                 self.body.append(self.param_separator)
262                 self.body.append('<span class="optional">[</span>')
263                 self.body.append('</dd>\n')
264             # Else, open a new bracket, append the parameter separator,
265             # and end the line.
266             else:
267                 self.body.append('<span class="optional">[</span>')
268                 self.body.append(self.param_separator)
269                 self.body.append('</dd>\n')
270         else:
271             self.body.append('<span class="optional">[</span>')
272 
273     def depart_desc_optional(self, node: Element) -> None:
274         self.optional_param_level -= 1
275         if self.multi_line_parameter_list:
276             # If it's the first time we go down one level, add the separator
277             # before the bracket.
278             if self.optional_param_level == self.max_optional_param_level - 1:
279                 self.body.append(self.param_separator)
280             self.body.append('<span class="optional">]</span>')
281             # End the line if we have just closed the last bracket of this
282             # optional parameter group.
283             if self.optional_param_level == 0:
284                 self.body.append('</dd>\n')
285         else:
286             self.body.append('<span class="optional">]</span>')
287         if self.optional_param_level == 0:
288             self.param_group_index += 1
289 
290     def visit_desc_annotation(self, node: Element) -> None:
291         self.body.append(self.starttag(node, 'em', '', CLASS='property'))
292 
293     def depart_desc_annotation(self, node: Element) -> None:
294         self.body.append('</em>')
295 
296     ##############################################
297 
298     def visit_versionmodified(self, node: Element) -> None:
299         self.body.append(self.starttag(node, 'div', CLASS=node['type']))
300 
301     def depart_versionmodified(self, node: Element) -> None:
302         self.body.append('</div>\n')
303 
304     # overwritten
305     def visit_reference(self, node: Element) -> None:
306         atts = {'class': 'reference'}
307         if node.get('internal') or 'refuri' not in node:
308             atts['class'] += ' internal'
309         else:
310             atts['class'] += ' external'
311         if 'refuri' in node:
312             atts['href'] = node['refuri'] or '#'
313             if self.settings.cloak_email_addresses and atts['href'].startswith('mailto:'):
314                 atts['href'] = self.cloak_mailto(atts['href'])
315                 self.in_mailto = True
316         else:
317             assert 'refid' in node, \
318                    'References must have "refuri" or "refid" attribute.'
319             atts['href'] = '#' + node['refid']
320         if not isinstance(node.parent, nodes.TextElement):
321             assert len(node) == 1 and isinstance(node[0], nodes.image)  # NoQA: PT018
322             atts['class'] += ' image-reference'
323         if 'reftitle' in node:
324             atts['title'] = node['reftitle']
325         if 'target' in node:
326             atts['target'] = node['target']
327         self.body.append(self.starttag(node, 'a', '', **atts))
328 
329         if node.get('secnumber'):
330             self.body.append(('%s' + self.secnumber_suffix) %
331                              '.'.join(map(str, node['secnumber'])))
332 
333     def visit_number_reference(self, node: Element) -> None:
334         self.visit_reference(node)
335 
336     def depart_number_reference(self, node: Element) -> None:
337         self.depart_reference(node)
338 
339     # overwritten -- we don't want source comments to show up in the HTML
340     def visit_comment(self, node: Element) -> None:  # type: ignore
341         raise nodes.SkipNode
342 
343     # overwritten
344     def visit_admonition(self, node: Element, name: str = '') -> None:
345         self.body.append(self.starttag(
346             node, 'div', CLASS=('admonition ' + name)))
347         if name:
348             node.insert(0, nodes.title(name, admonitionlabels[name]))
349 
350     def depart_admonition(self, node: Element | None = None) -> None:
351         self.body.append('</div>\n')
352 
353     def visit_seealso(self, node: Element) -> None:
354         self.visit_admonition(node, 'seealso')
355 
356     def depart_seealso(self, node: Element) -> None:
357         self.depart_admonition(node)
358 
359     def get_secnumber(self, node: Element) -> tuple[int, ...] | None:
360         if node.get('secnumber'):
361             return node['secnumber']
362 
363         if isinstance(node.parent, nodes.section):
364             if self.builder.name == 'singlehtml':
365                 docname = self.docnames[-1]
366                 anchorname = "{}/#{}".format(docname, node.parent['ids'][0])
367                 if anchorname not in self.builder.secnumbers:
368                     anchorname = "%s/" % docname  # try first heading which has no anchor
369             else:
370                 anchorname = '#' + node.parent['ids'][0]
371                 if anchorname not in self.builder.secnumbers:
372                     anchorname = ''  # try first heading which has no anchor
373 
374             if self.builder.secnumbers.get(anchorname):
375                 return self.builder.secnumbers[anchorname]
376 
377         return None
378 
379     def add_secnumber(self, node: Element) -> None:
380         secnumber = self.get_secnumber(node)
381         if secnumber:
382             self.body.append('<span class="section-number">%s</span>' %
383                              ('.'.join(map(str, secnumber)) + self.secnumber_suffix))
384 
385     def add_fignumber(self, node: Element) -> None:
386         def append_fignumber(figtype: str, figure_id: str) -> None:
387             if self.builder.name == 'singlehtml':
388                 key = f"{self.docnames[-1]}/{figtype}"
389             else:
390                 key = figtype
391 
392             if figure_id in self.builder.fignumbers.get(key, {}):
393                 self.body.append('<span class="caption-number">')
394                 prefix = self.config.numfig_format.get(figtype)
395                 if prefix is None:
396                     msg = __('numfig_format is not defined for %s') % figtype
397                     logger.warning(msg)
398                 else:
399                     numbers = self.builder.fignumbers[key][figure_id]
400                     self.body.append(prefix % '.'.join(map(str, numbers)) + ' ')
401                     self.body.append('</span>')
402 
403         figtype = self.builder.env.domains['std'].get_enumerable_node_type(node)
404         if figtype:
405             if len(node['ids']) == 0:
406                 msg = __('Any IDs not assigned for %s node') % node.tagname
407                 logger.warning(msg, location=node)
408             else:
409                 append_fignumber(figtype, node['ids'][0])
410 
411     def add_permalink_ref(self, node: Element, title: str) -> None:
412         if node['ids'] and self.config.html_permalinks and self.builder.add_permalinks:
413             format = '<a class="headerlink" href="#%s" title="%s">%s</a>'
414             self.body.append(format % (node['ids'][0], title,
415                                        self.config.html_permalinks_icon))
416 
417     # overwritten
418     def visit_bullet_list(self, node: Element) -> None:
419         if len(node) == 1 and isinstance(node[0], addnodes.toctree):
420             # avoid emitting empty <ul></ul>
421             raise nodes.SkipNode
422         super().visit_bullet_list(node)
423 
424     # overwritten
425     def visit_definition(self, node: Element) -> None:
426         # don't insert </dt> here.
427         self.body.append(self.starttag(node, 'dd', ''))
428 
429     # overwritten
430     def depart_definition(self, node: Element) -> None:
431         self.body.append('</dd>\n')
432 
433     # overwritten
434     def visit_classifier(self, node: Element) -> None:
435         self.body.append(self.starttag(node, 'span', '', CLASS='classifier'))
436 
437     # overwritten
438     def depart_classifier(self, node: Element) -> None:
439         self.body.append('</span>')
440 
441         next_node: Node = node.next_node(descend=False, siblings=True)
442         if not isinstance(next_node, nodes.classifier):
443             # close `<dt>` tag at the tail of classifiers
444             self.body.append('</dt>')
445 
446     # overwritten
447     def visit_term(self, node: Element) -> None:
448         self.body.append(self.starttag(node, 'dt', ''))
449 
450     # overwritten
451     def depart_term(self, node: Element) -> None:
452         next_node: Node = node.next_node(descend=False, siblings=True)
453         if isinstance(next_node, nodes.classifier):
454             # Leave the end tag to `self.depart_classifier()`, in case
455             # there's a classifier.
456             pass
457         else:
458             if isinstance(node.parent.parent.parent, addnodes.glossary):
459                 # add permalink if glossary terms
460                 self.add_permalink_ref(node, _('Permalink to this term'))
461 
462             self.body.append('</dt>')
463 
464     # overwritten
465     def visit_title(self, node: Element) -> None:
466         if isinstance(node.parent, addnodes.compact_paragraph) and node.parent.get('toctree'):
467             self.body.append(self.starttag(node, 'p', '', CLASS='caption', ROLE='heading'))
468             self.body.append('<span class="caption-text">')
469             self.context.append('</span></p>\n')
470         else:
471             super().visit_title(node)
472         self.add_secnumber(node)
473         self.add_fignumber(node.parent)
474         if isinstance(node.parent, nodes.table):
475             self.body.append('<span class="caption-text">')
476 
477     def depart_title(self, node: Element) -> None:
478         close_tag = self.context[-1]
479         if (self.config.html_permalinks and self.builder.add_permalinks and
480                 node.parent.hasattr('ids') and node.parent['ids']):
481             # add permalink anchor
482             if close_tag.startswith('</h'):
483                 self.add_permalink_ref(node.parent, _('Permalink to this heading'))
484             elif close_tag.startswith('</a></h'):
485                 self.body.append('</a><a class="headerlink" href="#%s" ' %
486                                  node.parent['ids'][0] +
487                                  'title="{}">{}'.format(
488                                      _('Permalink to this heading'),
489                                      self.config.html_permalinks_icon))
490             elif isinstance(node.parent, nodes.table):
491                 self.body.append('</span>')
492                 self.add_permalink_ref(node.parent, _('Permalink to this table'))
493         elif isinstance(node.parent, nodes.table):
494             self.body.append('</span>')
495 
496         super().depart_title(node)
497 
498     # overwritten
499     def visit_literal_block(self, node: Element) -> None:
500         if node.rawsource != node.astext():
501             # most probably a parsed-literal block -- don't highlight
502             return super().visit_literal_block(node)
503 
504         lang = node.get('language', 'default')
505         linenos = node.get('linenos', False)
506         highlight_args = node.get('highlight_args', {})
507         highlight_args['force'] = node.get('force', False)
508         opts = self.config.highlight_options.get(lang, {})
509 
510         if linenos and self.config.html_codeblock_linenos_style:
511             linenos = self.config.html_codeblock_linenos_style
512 
513         highlighted = self.highlighter.highlight_block(
514             node.rawsource, lang, opts=opts, linenos=linenos,
515             location=node, **highlight_args,
516         )
517         starttag = self.starttag(node, 'div', suffix='',
518                                  CLASS='highlight-%s notranslate' % lang)
519         self.body.append(starttag + highlighted + '</div>\n')
520         raise nodes.SkipNode
521 
522     def visit_caption(self, node: Element) -> None:
523         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
524             self.body.append('<div class="code-block-caption">')
525         else:
526             super().visit_caption(node)
527         self.add_fignumber(node.parent)
528         self.body.append(self.starttag(node, 'span', '', CLASS='caption-text'))
529 
530     def depart_caption(self, node: Element) -> None:
531         self.body.append('</span>')
532 
533         # append permalink if available
534         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
535             self.add_permalink_ref(node.parent, _('Permalink to this code'))
536         elif isinstance(node.parent, nodes.figure):
537             self.add_permalink_ref(node.parent, _('Permalink to this image'))
538         elif node.parent.get('toctree'):
539             self.add_permalink_ref(node.parent.parent, _('Permalink to this toctree'))
540 
541         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):
542             self.body.append('</div>\n')
543         else:
544             super().depart_caption(node)
545 
546     def visit_doctest_block(self, node: Element) -> None:
547         self.visit_literal_block(node)
548 
549     # overwritten to add the <div> (for XHTML compliance)
550     def visit_block_quote(self, node: Element) -> None:
551         self.body.append(self.starttag(node, 'blockquote') + '<div>')
552 
553     def depart_block_quote(self, node: Element) -> None:
554         self.body.append('</div></blockquote>\n')
555 
556     # overwritten
557     def visit_literal(self, node: Element) -> None:
558         if 'kbd' in node['classes']:
559             self.body.append(self.starttag(node, 'kbd', '',
560                                            CLASS='docutils literal notranslate'))
561             return
562         lang = node.get("language", None)
563         if 'code' not in node['classes'] or not lang:
564             self.body.append(self.starttag(node, 'code', '',
565                                            CLASS='docutils literal notranslate'))
566             self.protect_literal_text += 1
567             return
568 
569         opts = self.config.highlight_options.get(lang, {})
570         highlighted = self.highlighter.highlight_block(
571             node.astext(), lang, opts=opts, location=node, nowrap=True)
572         starttag = self.starttag(
573             node,
574             "code",
575             suffix="",
576             CLASS="docutils literal highlight highlight-%s" % lang,
577         )
578         self.body.append(starttag + highlighted.strip() + "</code>")
579         raise nodes.SkipNode
580 
581     def depart_literal(self, node: Element) -> None:
582         if 'kbd' in node['classes']:
583             self.body.append('</kbd>')
584         else:
585             self.protect_literal_text -= 1
586             self.body.append('</code>')
587 
588     def visit_productionlist(self, node: Element) -> None:
589         self.body.append(self.starttag(node, 'pre'))
590         names = []
591         productionlist = cast(Iterable[addnodes.production], node)
592         for production in productionlist:
593             names.append(production['tokenname'])
594         maxlen = max(len(name) for name in names)
595         lastname = None
596         for production in productionlist:
597             if production['tokenname']:
598                 lastname = production['tokenname'].ljust(maxlen)
599                 self.body.append(self.starttag(production, 'strong', ''))
600                 self.body.append(lastname + '</strong> ::= ')
601             elif lastname is not None:
602                 self.body.append('%s     ' % (' ' * len(lastname)))
603             production.walkabout(self)
604             self.body.append('\n')
605         self.body.append('</pre>\n')
606         raise nodes.SkipNode
607 
608     def depart_productionlist(self, node: Element) -> None:
609         pass
610 
611     def visit_production(self, node: Element) -> None:
612         pass
613 
614     def depart_production(self, node: Element) -> None:
615         pass
616 
617     def visit_centered(self, node: Element) -> None:
618         self.body.append(self.starttag(node, 'p', CLASS="centered") +
619                          '<strong>')
620 
621     def depart_centered(self, node: Element) -> None:
622         self.body.append('</strong></p>')
623 
624     def visit_compact_paragraph(self, node: Element) -> None:
625         pass
626 
627     def depart_compact_paragraph(self, node: Element) -> None:
628         pass
629 
630     def visit_download_reference(self, node: Element) -> None:
631         atts = {'class': 'reference download',
632                 'download': ''}
633 
634         if not self.builder.download_support:
635             self.context.append('')
636         elif 'refuri' in node:
637             atts['class'] += ' external'
638             atts['href'] = node['refuri']
639             self.body.append(self.starttag(node, 'a', '', **atts))
640             self.context.append('</a>')
641         elif 'filename' in node:
642             atts['class'] += ' internal'
643             atts['href'] = posixpath.join(self.builder.dlpath,
644                                           urllib.parse.quote(node['filename']))
645             self.body.append(self.starttag(node, 'a', '', **atts))
646             self.context.append('</a>')
647         else:
648             self.context.append('')
649 
650     def depart_download_reference(self, node: Element) -> None:
651         self.body.append(self.context.pop())
652 
653     # overwritten
654     def visit_figure(self, node: Element) -> None:
655         # set align=default if align not specified to give a default style
656         node.setdefault('align', 'default')
657 
658         return super().visit_figure(node)
659 
660     # overwritten
661     def visit_image(self, node: Element) -> None:
662         olduri = node['uri']
663         # rewrite the URI if the environment knows about it
664         if olduri in self.builder.images:
665             node['uri'] = posixpath.join(self.builder.imgpath,
666                                          urllib.parse.quote(self.builder.images[olduri]))
667 
668         if 'scale' in node:
669             # Try to figure out image height and width.  Docutils does that too,
670             # but it tries the final file name, which does not necessarily exist
671             # yet at the time the HTML file is written.
672             if not ('width' in node and 'height' in node):
673                 size = get_image_size(os.path.join(self.builder.srcdir, olduri))
674                 if size is None:
675                     logger.warning(
676                         __('Could not obtain image size. :scale: option is ignored.'),
677                         location=node,
678                     )
679                 else:
680                     if 'width' not in node:
681                         node['width'] = str(size[0])
682                     if 'height' not in node:
683                         node['height'] = str(size[1])
684 
685         uri = node['uri']
686         if uri.lower().endswith(('svg', 'svgz')):
687             atts = {'src': uri}
688             if 'width' in node:
689                 atts['width'] = node['width']
690             if 'height' in node:
691                 atts['height'] = node['height']
692             if 'scale' in node:
693                 if 'width' in atts:
694                     atts['width'] = multiply_length(atts['width'], node['scale'])
695                 if 'height' in atts:
696                     atts['height'] = multiply_length(atts['height'], node['scale'])
697             atts['alt'] = node.get('alt', uri)
698             if 'align' in node:
699                 atts['class'] = 'align-%s' % node['align']
700             self.body.append(self.emptytag(node, 'img', '', **atts))
701             return
702 
703         super().visit_image(node)
704 
705     # overwritten
706     def depart_image(self, node: Element) -> None:
707         if node['uri'].lower().endswith(('svg', 'svgz')):
708             pass
709         else:
710             super().depart_image(node)
711 
712     def visit_toctree(self, node: Element) -> None:
713         # this only happens when formatting a toc from env.tocs -- in this
714         # case we don't want to include the subtree
715         raise nodes.SkipNode
716 
717     def visit_index(self, node: Element) -> None:
718         raise nodes.SkipNode
719 
720     def visit_tabular_col_spec(self, node: Element) -> None:
721         raise nodes.SkipNode
722 
723     def visit_glossary(self, node: Element) -> None:
724         pass
725 
726     def depart_glossary(self, node: Element) -> None:
727         pass
728 
729     def visit_acks(self, node: Element) -> None:
730         pass
731 
732     def depart_acks(self, node: Element) -> None:
733         pass
734 
735     def visit_hlist(self, node: Element) -> None:
736         self.body.append('<table class="hlist"><tr>')
737 
738     def depart_hlist(self, node: Element) -> None:
739         self.body.append('</tr></table>\n')
740 
741     def visit_hlistcol(self, node: Element) -> None:
742         self.body.append('<td>')
743 
744     def depart_hlistcol(self, node: Element) -> None:
745         self.body.append('</td>')
746 
747     # overwritten
748     def visit_Text(self, node: Text) -> None:
749         text = node.astext()
750         encoded = self.encode(text)
751         if self.protect_literal_text:
752             # moved here from base class's visit_literal to support
753             # more formatting in literal nodes
754             for token in self.words_and_spaces.findall(encoded):
755                 if token.strip():
756                     # protect literal text from line wrapping
757                     self.body.append('<span class="pre">%s</span>' % token)
758                 elif token in ' \n':
759                     # allow breaks at whitespace
760                     self.body.append(token)
761                 else:
762                     # protect runs of multiple spaces; the last one can wrap
763                     self.body.append('&#160;' * (len(token) - 1) + ' ')
764         else:
765             if self.in_mailto and self.settings.cloak_email_addresses:
766                 encoded = self.cloak_email(encoded)
767             self.body.append(encoded)
768 
769     def visit_note(self, node: Element) -> None:
770         self.visit_admonition(node, 'note')
771 
772     def depart_note(self, node: Element) -> None:
773         self.depart_admonition(node)
774 
775     def visit_warning(self, node: Element) -> None:
776         self.visit_admonition(node, 'warning')
777 
778     def depart_warning(self, node: Element) -> None:
779         self.depart_admonition(node)
780 
781     def visit_attention(self, node: Element) -> None:
782         self.visit_admonition(node, 'attention')
783 
784     def depart_attention(self, node: Element) -> None:
785         self.depart_admonition(node)
786 
787     def visit_caution(self, node: Element) -> None:
788         self.visit_admonition(node, 'caution')
789 
790     def depart_caution(self, node: Element) -> None:
791         self.depart_admonition(node)
792 
793     def visit_danger(self, node: Element) -> None:
794         self.visit_admonition(node, 'danger')
795 
796     def depart_danger(self, node: Element) -> None:
797         self.depart_admonition(node)
798 
799     def visit_error(self, node: Element) -> None:
800         self.visit_admonition(node, 'error')
801 
802     def depart_error(self, node: Element) -> None:
803         self.depart_admonition(node)
804 
805     def visit_hint(self, node: Element) -> None:
806         self.visit_admonition(node, 'hint')
807 
808     def depart_hint(self, node: Element) -> None:
809         self.depart_admonition(node)
810 
811     def visit_important(self, node: Element) -> None:
812         self.visit_admonition(node, 'important')
813 
814     def depart_important(self, node: Element) -> None:
815         self.depart_admonition(node)
816 
817     def visit_tip(self, node: Element) -> None:
818         self.visit_admonition(node, 'tip')
819 
820     def depart_tip(self, node: Element) -> None:
821         self.depart_admonition(node)
822 
823     def visit_literal_emphasis(self, node: Element) -> None:
824         return self.visit_emphasis(node)
825 
826     def depart_literal_emphasis(self, node: Element) -> None:
827         return self.depart_emphasis(node)
828 
829     def visit_literal_strong(self, node: Element) -> None:
830         return self.visit_strong(node)
831 
832     def depart_literal_strong(self, node: Element) -> None:
833         return self.depart_strong(node)
834 
835     def visit_abbreviation(self, node: Element) -> None:
836         attrs = {}
837         if node.hasattr('explanation'):
838             attrs['title'] = node['explanation']
839         self.body.append(self.starttag(node, 'abbr', '', **attrs))
840 
841     def depart_abbreviation(self, node: Element) -> None:
842         self.body.append('</abbr>')
843 
844     def visit_manpage(self, node: Element) -> None:
845         self.visit_literal_emphasis(node)
846         if self.manpages_url:
847             node['refuri'] = self.manpages_url.format(**node.attributes)
848             self.visit_reference(node)
849 
850     def depart_manpage(self, node: Element) -> None:
851         if self.manpages_url:
852             self.depart_reference(node)
853         self.depart_literal_emphasis(node)
854 
855     # overwritten to add even/odd classes
856 
857     def visit_table(self, node: Element) -> None:
858         self._table_row_indices.append(0)
859 
860         atts = {}
861         classes = [cls.strip(' \t\n') for cls in self.settings.table_style.split(',')]
862         classes.insert(0, "docutils")  # compat
863 
864         # set align-default if align not specified to give a default style
865         classes.append('align-%s' % node.get('align', 'default'))
866 
867         if 'width' in node:
868             atts['style'] = 'width: %s' % node['width']
869         tag = self.starttag(node, 'table', CLASS=' '.join(classes), **atts)
870         self.body.append(tag)
871 
872     def depart_table(self, node: Element) -> None:
873         self._table_row_indices.pop()
874         super().depart_table(node)
875 
876     def visit_row(self, node: Element) -> None:
877         self._table_row_indices[-1] += 1
878         if self._table_row_indices[-1] % 2 == 0:
879             node['classes'].append('row-even')
880         else:
881             node['classes'].append('row-odd')
882         self.body.append(self.starttag(node, 'tr', ''))
883         node.column = 0  # type: ignore
884 
885     def visit_field_list(self, node: Element) -> None:
886         self._fieldlist_row_indices.append(0)
887         return super().visit_field_list(node)
888 
889     def depart_field_list(self, node: Element) -> None:
890         self._fieldlist_row_indices.pop()
891         return super().depart_field_list(node)
892 
893     def visit_field(self, node: Element) -> None:
894         self._fieldlist_row_indices[-1] += 1
895         if self._fieldlist_row_indices[-1] % 2 == 0:
896             node['classes'].append('field-even')
897         else:
898             node['classes'].append('field-odd')
899 
900     def visit_math(self, node: Element, math_env: str = '') -> None:
901         # see validate_math_renderer
902         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
903         visit, _ = self.builder.app.registry.html_inline_math_renderers[name]
904         visit(self, node)
905 
906     def depart_math(self, node: Element, math_env: str = '') -> None:
907         # see validate_math_renderer
908         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
909         _, depart = self.builder.app.registry.html_inline_math_renderers[name]
910         if depart:
911             depart(self, node)
912 
913     def visit_math_block(self, node: Element, math_env: str = '') -> None:
914         # see validate_math_renderer
915         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
916         visit, _ = self.builder.app.registry.html_block_math_renderers[name]
917         visit(self, node)
918 
919     def depart_math_block(self, node: Element, math_env: str = '') -> None:
920         # see validate_math_renderer
921         name: str = self.builder.math_renderer_name  # type: ignore[assignment]
922         _, depart = self.builder.app.registry.html_block_math_renderers[name]
923         if depart:
924             depart(self, node)
925 
926     # See Docutils r9413
927     # Re-instate the footnote-reference class
928     def visit_footnote_reference(self, node):
929         href = '#' + node['refid']
930         classes = ['footnote-reference', self.settings.footnote_references]
931         self.body.append(self.starttag(node, 'a', suffix='', classes=classes,
932                                        role='doc-noteref', href=href))
933         self.body.append('<span class="fn-bracket">[</span>')

</code><intended_behavior>In the context of writing HTML5 output, where SVGs are included, this file should ensure that any embedded objects, particularly SVG images with links, have their paths resolved in a way that accurately reflects their location within the overall site structure. If this file contributes to processing or embedding SVG content, it may need adjustments to correctly handle path resolution for links within SVGs. The specific method(s) responsible for this might need to be examined and modified to ensure that paths are correctly computed, taking the embedding documentâ€™s location into account.</intended_behavior>]
2025-10-17 18:23:20.701 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 18:23:20.701 | INFO     | Search-only: skipping patch selection
2025-10-17 18:23:20.783 | INFO     | Task sphinx-doc__sphinx-10614 completed successfully.
2025-10-17 18:23:20.784 | INFO     | No patch generated. You can try running ACR again.
