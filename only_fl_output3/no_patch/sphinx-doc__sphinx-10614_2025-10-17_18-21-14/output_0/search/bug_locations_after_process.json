[
    {
        "rel_file_path": "sphinx/ext/inheritance_diagram.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__7.2/sphinx/ext/inheritance_diagram.py",
        "start": 332,
        "end": 390,
        "class_name": "InheritanceDiagram",
        "method_name": null,
        "code": "332 class InheritanceDiagram(SphinxDirective):\n333     \"\"\"\n334     Run when the inheritance_diagram directive is first encountered.\n335     \"\"\"\n336     has_content = False\n337     required_arguments = 1\n338     optional_arguments = 0\n339     final_argument_whitespace = True\n340     option_spec: OptionSpec = {\n341         'parts': int,\n342         'private-bases': directives.flag,\n343         'caption': directives.unchanged,\n344         'top-classes': directives.unchanged_required,\n345     }\n346 \n347     def run(self) -> list[Node]:\n348         node = inheritance_diagram()\n349         node.document = self.state.document\n350         class_names = self.arguments[0].split()\n351         class_role = self.env.get_domain('py').role('class')\n352         # Store the original content for use as a hash\n353         node['parts'] = self.options.get('parts', 0)\n354         node['content'] = ', '.join(class_names)\n355         node['top-classes'] = []\n356         for cls in self.options.get('top-classes', '').split(','):\n357             cls = cls.strip()\n358             if cls:\n359                 node['top-classes'].append(cls)\n360 \n361         # Create a graph starting with the list of classes\n362         try:\n363             graph = InheritanceGraph(\n364                 class_names, self.env.ref_context.get('py:module'),  # type: ignore[arg-type]\n365                 parts=node['parts'],\n366                 private_bases='private-bases' in self.options,\n367                 aliases=self.config.inheritance_alias,\n368                 top_classes=node['top-classes'])\n369         except InheritanceException as err:\n370             return [node.document.reporter.warning(err, line=self.lineno)]\n371 \n372         # Create xref nodes for each target of the graph's image map and\n373         # add them to the doc tree so that Sphinx can resolve the\n374         # references to real URLs later.  These nodes will eventually be\n375         # removed from the doctree after we're done with them.\n376         for name in graph.get_all_class_names():\n377             refnodes, x = class_role(  # type: ignore\n378                 'class', ':class:`%s`' % name, name, 0, self.state)  # type: ignore\n379             node.extend(refnodes)\n380         # Store the graph object so we can use it to generate the\n381         # dot file later\n382         node['graph'] = graph\n383 \n384         if 'caption' not in self.options:\n385             self.add_name(node)\n386             return [node]\n387         else:\n388             figure = figure_wrapper(self, node, self.options['caption'])\n389             self.add_name(figure)\n390             return [figure]\n",
        "intended_behavior": "This class, specifically within its method responsible for generating the SVG, needs to ensure that paths for links within the SVG are correctly computed relative to the documentation's build output directory, not just relative to the SVG itself. The fix should ensure that when an SVG diagram is embedded in a document not at the root level, the links within the SVG correctly consider the document's position in the directory structure to avoid resulting in 404 errors. This could involve modifying how the paths are calculated within this class, potentially introducing a new method to correctly calculate the relative paths based on the document embedding the SVG, or adjusting the existing logic to account for the embedding document's location."
    },
    {
        "rel_file_path": "sphinx/writers/html5.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__7.2/sphinx/writers/html5.py",
        "start": 1,
        "end": 933,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Experimental docutils writers for HTML5 handling Sphinx's custom nodes.\"\"\"\n2 \n3 from __future__ import annotations\n4 \n5 import os\n6 import posixpath\n7 import re\n8 import urllib.parse\n9 from collections.abc import Iterable\n10 from typing import TYPE_CHECKING, cast\n11 \n12 from docutils import nodes\n13 from docutils.nodes import Element, Node, Text\n14 from docutils.writers.html5_polyglot import HTMLTranslator as BaseTranslator\n15 \n16 from sphinx import addnodes\n17 from sphinx.builders import Builder\n18 from sphinx.locale import _, __, admonitionlabels\n19 from sphinx.util import logging\n20 from sphinx.util.docutils import SphinxTranslator\n21 from sphinx.util.images import get_image_size\n22 \n23 if TYPE_CHECKING:\n24     from sphinx.builders.html import StandaloneHTMLBuilder\n25 \n26 \n27 logger = logging.getLogger(__name__)\n28 \n29 # A good overview of the purpose behind these classes can be found here:\n30 # http://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html\n31 \n32 \n33 def multiply_length(length: str, scale: int) -> str:\n34     \"\"\"Multiply *length* (width or height) by *scale*.\"\"\"\n35     matched = re.match(r'^(\\d*\\.?\\d*)\\s*(\\S*)$', length)\n36     if not matched:\n37         return length\n38     if scale == 100:\n39         return length\n40     amount, unit = matched.groups()\n41     result = float(amount) * scale / 100\n42     return f\"{int(result)}{unit}\"\n43 \n44 \n45 class HTML5Translator(SphinxTranslator, BaseTranslator):\n46     \"\"\"\n47     Our custom HTML translator.\n48     \"\"\"\n49 \n50     builder: StandaloneHTMLBuilder\n51     # Override docutils.writers.html5_polyglot:HTMLTranslator\n52     # otherwise, nodes like <inline classes=\"s\">...</inline> will be\n53     # converted to <s>...</s> by `visit_inline`.\n54     supported_inline_tags: set[str] = set()\n55 \n56     def __init__(self, document: nodes.document, builder: Builder) -> None:\n57         super().__init__(document, builder)\n58 \n59         self.highlighter = self.builder.highlighter\n60         self.docnames = [self.builder.current_docname]  # for singlehtml builder\n61         self.manpages_url = self.config.manpages_url\n62         self.protect_literal_text = 0\n63         self.secnumber_suffix = self.config.html_secnumber_suffix\n64         self.param_separator = ''\n65         self.optional_param_level = 0\n66         self._table_row_indices = [0]\n67         self._fieldlist_row_indices = [0]\n68         self.required_params_left = 0\n69 \n70     def visit_start_of_file(self, node: Element) -> None:\n71         # only occurs in the single-file builder\n72         self.docnames.append(node['docname'])\n73         self.body.append('<span id=\"document-%s\"></span>' % node['docname'])\n74 \n75     def depart_start_of_file(self, node: Element) -> None:\n76         self.docnames.pop()\n77 \n78     #############################################################\n79     # Domain-specific object descriptions\n80     #############################################################\n81 \n82     # Top-level nodes for descriptions\n83     ##################################\n84 \n85     def visit_desc(self, node: Element) -> None:\n86         self.body.append(self.starttag(node, 'dl'))\n87 \n88     def depart_desc(self, node: Element) -> None:\n89         self.body.append('</dl>\\n\\n')\n90 \n91     def visit_desc_signature(self, node: Element) -> None:\n92         # the id is set automatically\n93         self.body.append(self.starttag(node, 'dt'))\n94         self.protect_literal_text += 1\n95 \n96     def depart_desc_signature(self, node: Element) -> None:\n97         self.protect_literal_text -= 1\n98         if not node.get('is_multiline'):\n99             self.add_permalink_ref(node, _('Permalink to this definition'))\n100         self.body.append('</dt>\\n')\n101 \n102     def visit_desc_signature_line(self, node: Element) -> None:\n103         pass\n104 \n105     def depart_desc_signature_line(self, node: Element) -> None:\n106         if node.get('add_permalink'):\n107             # the permalink info is on the parent desc_signature node\n108             self.add_permalink_ref(node.parent, _('Permalink to this definition'))\n109         self.body.append('<br />')\n110 \n111     def visit_desc_content(self, node: Element) -> None:\n112         self.body.append(self.starttag(node, 'dd', ''))\n113 \n114     def depart_desc_content(self, node: Element) -> None:\n115         self.body.append('</dd>')\n116 \n117     def visit_desc_inline(self, node: Element) -> None:\n118         self.body.append(self.starttag(node, 'span', ''))\n119 \n120     def depart_desc_inline(self, node: Element) -> None:\n121         self.body.append('</span>')\n122 \n123     # Nodes for high-level structure in signatures\n124     ##############################################\n125 \n126     def visit_desc_name(self, node: Element) -> None:\n127         self.body.append(self.starttag(node, 'span', ''))\n128 \n129     def depart_desc_name(self, node: Element) -> None:\n130         self.body.append('</span>')\n131 \n132     def visit_desc_addname(self, node: Element) -> None:\n133         self.body.append(self.starttag(node, 'span', ''))\n134 \n135     def depart_desc_addname(self, node: Element) -> None:\n136         self.body.append('</span>')\n137 \n138     def visit_desc_type(self, node: Element) -> None:\n139         pass\n140 \n141     def depart_desc_type(self, node: Element) -> None:\n142         pass\n143 \n144     def visit_desc_returns(self, node: Element) -> None:\n145         self.body.append(' <span class=\"sig-return\">')\n146         self.body.append('<span class=\"sig-return-icon\">&#x2192;</span>')\n147         self.body.append(' <span class=\"sig-return-typehint\">')\n148 \n149     def depart_desc_returns(self, node: Element) -> None:\n150         self.body.append('</span></span>')\n151 \n152     def _visit_sig_parameter_list(\n153         self,\n154         node: Element,\n155         parameter_group: type[Element],\n156         sig_open_paren: str,\n157         sig_close_paren: str,\n158     ) -> None:\n159         \"\"\"Visit a signature parameters or type parameters list.\n160 \n161         The *parameter_group* value is the type of child nodes acting as required parameters\n162         or as a set of contiguous optional parameters.\n163         \"\"\"\n164         self.body.append(f'<span class=\"sig-paren\">{sig_open_paren}</span>')\n165         self.is_first_param = True\n166         self.optional_param_level = 0\n167         self.params_left_at_level = 0\n168         self.param_group_index = 0\n169         # Counts as what we call a parameter group either a required parameter, or a\n170         # set of contiguous optional ones.\n171         self.list_is_required_param = [isinstance(c, parameter_group) for c in node.children]\n172         # How many required parameters are left.\n173         self.required_params_left = sum(self.list_is_required_param)\n174         self.param_separator = node.child_text_separator\n175         self.multi_line_parameter_list = node.get('multi_line_parameter_list', False)\n176         if self.multi_line_parameter_list:\n177             self.body.append('\\n\\n')\n178             self.body.append(self.starttag(node, 'dl'))\n179             self.param_separator = self.param_separator.rstrip()\n180         self.context.append(sig_close_paren)\n181 \n182     def _depart_sig_parameter_list(self, node: Element) -> None:\n183         if node.get('multi_line_parameter_list'):\n184             self.body.append('</dl>\\n\\n')\n185         sig_close_paren = self.context.pop()\n186         self.body.append(f'<span class=\"sig-paren\">{sig_close_paren}</span>')\n187 \n188     def visit_desc_parameterlist(self, node: Element) -> None:\n189         self._visit_sig_parameter_list(node, addnodes.desc_parameter, '(', ')')\n190 \n191     def depart_desc_parameterlist(self, node: Element) -> None:\n192         self._depart_sig_parameter_list(node)\n193 \n194     def visit_desc_type_parameter_list(self, node: Element) -> None:\n195         self._visit_sig_parameter_list(node, addnodes.desc_type_parameter, '[', ']')\n196 \n197     def depart_desc_type_parameter_list(self, node: Element) -> None:\n198         self._depart_sig_parameter_list(node)\n199 \n200     # If required parameters are still to come, then put the comma after\n201     # the parameter.  Otherwise, put the comma before.  This ensures that\n202     # signatures like the following render correctly (see issue #1001):\n203     #\n204     #     foo([a, ]b, c[, d])\n205     #\n206     def visit_desc_parameter(self, node: Element) -> None:\n207         on_separate_line = self.multi_line_parameter_list\n208         if on_separate_line and not (self.is_first_param and self.optional_param_level > 0):\n209             self.body.append(self.starttag(node, 'dd', ''))\n210         if self.is_first_param:\n211             self.is_first_param = False\n212         elif not on_separate_line and not self.required_params_left:\n213             self.body.append(self.param_separator)\n214         if self.optional_param_level == 0:\n215             self.required_params_left -= 1\n216         else:\n217             self.params_left_at_level -= 1\n218         if not node.hasattr('noemph'):\n219             self.body.append('<em class=\"sig-param\">')\n220 \n221     def depart_desc_parameter(self, node: Element) -> None:\n222         if not node.hasattr('noemph'):\n223             self.body.append('</em>')\n224         is_required = self.list_is_required_param[self.param_group_index]\n225         if self.multi_line_parameter_list:\n226             is_last_group = self.param_group_index + 1 == len(self.list_is_required_param)\n227             next_is_required = (\n228                 not is_last_group\n229                 and self.list_is_required_param[self.param_group_index + 1]\n230             )\n231             opt_param_left_at_level = self.params_left_at_level > 0\n232             if opt_param_left_at_level or is_required and (is_last_group or next_is_required):\n233                 self.body.append(self.param_separator)\n234                 self.body.append('</dd>\\n')\n235 \n236         elif self.required_params_left:\n237             self.body.append(self.param_separator)\n238 \n239         if is_required:\n240             self.param_group_index += 1\n241 \n242     def visit_desc_type_parameter(self, node: Element) -> None:\n243         self.visit_desc_parameter(node)\n244 \n245     def depart_desc_type_parameter(self, node: Element) -> None:\n246         self.depart_desc_parameter(node)\n247 \n248     def visit_desc_optional(self, node: Element) -> None:\n249         self.params_left_at_level = sum([isinstance(c, addnodes.desc_parameter)\n250                                          for c in node.children])\n251         self.optional_param_level += 1\n252         self.max_optional_param_level = self.optional_param_level\n253         if self.multi_line_parameter_list:\n254             # If the first parameter is optional, start a new line and open the bracket.\n255             if self.is_first_param:\n256                 self.body.append(self.starttag(node, 'dd', ''))\n257                 self.body.append('<span class=\"optional\">[</span>')\n258             # Else, if there remains at least one required parameter, append the\n259             # parameter separator, open a new bracket, and end the line.\n260             elif self.required_params_left:\n261                 self.body.append(self.param_separator)\n262                 self.body.append('<span class=\"optional\">[</span>')\n263                 self.body.append('</dd>\\n')\n264             # Else, open a new bracket, append the parameter separator,\n265             # and end the line.\n266             else:\n267                 self.body.append('<span class=\"optional\">[</span>')\n268                 self.body.append(self.param_separator)\n269                 self.body.append('</dd>\\n')\n270         else:\n271             self.body.append('<span class=\"optional\">[</span>')\n272 \n273     def depart_desc_optional(self, node: Element) -> None:\n274         self.optional_param_level -= 1\n275         if self.multi_line_parameter_list:\n276             # If it's the first time we go down one level, add the separator\n277             # before the bracket.\n278             if self.optional_param_level == self.max_optional_param_level - 1:\n279                 self.body.append(self.param_separator)\n280             self.body.append('<span class=\"optional\">]</span>')\n281             # End the line if we have just closed the last bracket of this\n282             # optional parameter group.\n283             if self.optional_param_level == 0:\n284                 self.body.append('</dd>\\n')\n285         else:\n286             self.body.append('<span class=\"optional\">]</span>')\n287         if self.optional_param_level == 0:\n288             self.param_group_index += 1\n289 \n290     def visit_desc_annotation(self, node: Element) -> None:\n291         self.body.append(self.starttag(node, 'em', '', CLASS='property'))\n292 \n293     def depart_desc_annotation(self, node: Element) -> None:\n294         self.body.append('</em>')\n295 \n296     ##############################################\n297 \n298     def visit_versionmodified(self, node: Element) -> None:\n299         self.body.append(self.starttag(node, 'div', CLASS=node['type']))\n300 \n301     def depart_versionmodified(self, node: Element) -> None:\n302         self.body.append('</div>\\n')\n303 \n304     # overwritten\n305     def visit_reference(self, node: Element) -> None:\n306         atts = {'class': 'reference'}\n307         if node.get('internal') or 'refuri' not in node:\n308             atts['class'] += ' internal'\n309         else:\n310             atts['class'] += ' external'\n311         if 'refuri' in node:\n312             atts['href'] = node['refuri'] or '#'\n313             if self.settings.cloak_email_addresses and atts['href'].startswith('mailto:'):\n314                 atts['href'] = self.cloak_mailto(atts['href'])\n315                 self.in_mailto = True\n316         else:\n317             assert 'refid' in node, \\\n318                    'References must have \"refuri\" or \"refid\" attribute.'\n319             atts['href'] = '#' + node['refid']\n320         if not isinstance(node.parent, nodes.TextElement):\n321             assert len(node) == 1 and isinstance(node[0], nodes.image)  # NoQA: PT018\n322             atts['class'] += ' image-reference'\n323         if 'reftitle' in node:\n324             atts['title'] = node['reftitle']\n325         if 'target' in node:\n326             atts['target'] = node['target']\n327         self.body.append(self.starttag(node, 'a', '', **atts))\n328 \n329         if node.get('secnumber'):\n330             self.body.append(('%s' + self.secnumber_suffix) %\n331                              '.'.join(map(str, node['secnumber'])))\n332 \n333     def visit_number_reference(self, node: Element) -> None:\n334         self.visit_reference(node)\n335 \n336     def depart_number_reference(self, node: Element) -> None:\n337         self.depart_reference(node)\n338 \n339     # overwritten -- we don't want source comments to show up in the HTML\n340     def visit_comment(self, node: Element) -> None:  # type: ignore\n341         raise nodes.SkipNode\n342 \n343     # overwritten\n344     def visit_admonition(self, node: Element, name: str = '') -> None:\n345         self.body.append(self.starttag(\n346             node, 'div', CLASS=('admonition ' + name)))\n347         if name:\n348             node.insert(0, nodes.title(name, admonitionlabels[name]))\n349 \n350     def depart_admonition(self, node: Element | None = None) -> None:\n351         self.body.append('</div>\\n')\n352 \n353     def visit_seealso(self, node: Element) -> None:\n354         self.visit_admonition(node, 'seealso')\n355 \n356     def depart_seealso(self, node: Element) -> None:\n357         self.depart_admonition(node)\n358 \n359     def get_secnumber(self, node: Element) -> tuple[int, ...] | None:\n360         if node.get('secnumber'):\n361             return node['secnumber']\n362 \n363         if isinstance(node.parent, nodes.section):\n364             if self.builder.name == 'singlehtml':\n365                 docname = self.docnames[-1]\n366                 anchorname = \"{}/#{}\".format(docname, node.parent['ids'][0])\n367                 if anchorname not in self.builder.secnumbers:\n368                     anchorname = \"%s/\" % docname  # try first heading which has no anchor\n369             else:\n370                 anchorname = '#' + node.parent['ids'][0]\n371                 if anchorname not in self.builder.secnumbers:\n372                     anchorname = ''  # try first heading which has no anchor\n373 \n374             if self.builder.secnumbers.get(anchorname):\n375                 return self.builder.secnumbers[anchorname]\n376 \n377         return None\n378 \n379     def add_secnumber(self, node: Element) -> None:\n380         secnumber = self.get_secnumber(node)\n381         if secnumber:\n382             self.body.append('<span class=\"section-number\">%s</span>' %\n383                              ('.'.join(map(str, secnumber)) + self.secnumber_suffix))\n384 \n385     def add_fignumber(self, node: Element) -> None:\n386         def append_fignumber(figtype: str, figure_id: str) -> None:\n387             if self.builder.name == 'singlehtml':\n388                 key = f\"{self.docnames[-1]}/{figtype}\"\n389             else:\n390                 key = figtype\n391 \n392             if figure_id in self.builder.fignumbers.get(key, {}):\n393                 self.body.append('<span class=\"caption-number\">')\n394                 prefix = self.config.numfig_format.get(figtype)\n395                 if prefix is None:\n396                     msg = __('numfig_format is not defined for %s') % figtype\n397                     logger.warning(msg)\n398                 else:\n399                     numbers = self.builder.fignumbers[key][figure_id]\n400                     self.body.append(prefix % '.'.join(map(str, numbers)) + ' ')\n401                     self.body.append('</span>')\n402 \n403         figtype = self.builder.env.domains['std'].get_enumerable_node_type(node)\n404         if figtype:\n405             if len(node['ids']) == 0:\n406                 msg = __('Any IDs not assigned for %s node') % node.tagname\n407                 logger.warning(msg, location=node)\n408             else:\n409                 append_fignumber(figtype, node['ids'][0])\n410 \n411     def add_permalink_ref(self, node: Element, title: str) -> None:\n412         if node['ids'] and self.config.html_permalinks and self.builder.add_permalinks:\n413             format = '<a class=\"headerlink\" href=\"#%s\" title=\"%s\">%s</a>'\n414             self.body.append(format % (node['ids'][0], title,\n415                                        self.config.html_permalinks_icon))\n416 \n417     # overwritten\n418     def visit_bullet_list(self, node: Element) -> None:\n419         if len(node) == 1 and isinstance(node[0], addnodes.toctree):\n420             # avoid emitting empty <ul></ul>\n421             raise nodes.SkipNode\n422         super().visit_bullet_list(node)\n423 \n424     # overwritten\n425     def visit_definition(self, node: Element) -> None:\n426         # don't insert </dt> here.\n427         self.body.append(self.starttag(node, 'dd', ''))\n428 \n429     # overwritten\n430     def depart_definition(self, node: Element) -> None:\n431         self.body.append('</dd>\\n')\n432 \n433     # overwritten\n434     def visit_classifier(self, node: Element) -> None:\n435         self.body.append(self.starttag(node, 'span', '', CLASS='classifier'))\n436 \n437     # overwritten\n438     def depart_classifier(self, node: Element) -> None:\n439         self.body.append('</span>')\n440 \n441         next_node: Node = node.next_node(descend=False, siblings=True)\n442         if not isinstance(next_node, nodes.classifier):\n443             # close `<dt>` tag at the tail of classifiers\n444             self.body.append('</dt>')\n445 \n446     # overwritten\n447     def visit_term(self, node: Element) -> None:\n448         self.body.append(self.starttag(node, 'dt', ''))\n449 \n450     # overwritten\n451     def depart_term(self, node: Element) -> None:\n452         next_node: Node = node.next_node(descend=False, siblings=True)\n453         if isinstance(next_node, nodes.classifier):\n454             # Leave the end tag to `self.depart_classifier()`, in case\n455             # there's a classifier.\n456             pass\n457         else:\n458             if isinstance(node.parent.parent.parent, addnodes.glossary):\n459                 # add permalink if glossary terms\n460                 self.add_permalink_ref(node, _('Permalink to this term'))\n461 \n462             self.body.append('</dt>')\n463 \n464     # overwritten\n465     def visit_title(self, node: Element) -> None:\n466         if isinstance(node.parent, addnodes.compact_paragraph) and node.parent.get('toctree'):\n467             self.body.append(self.starttag(node, 'p', '', CLASS='caption', ROLE='heading'))\n468             self.body.append('<span class=\"caption-text\">')\n469             self.context.append('</span></p>\\n')\n470         else:\n471             super().visit_title(node)\n472         self.add_secnumber(node)\n473         self.add_fignumber(node.parent)\n474         if isinstance(node.parent, nodes.table):\n475             self.body.append('<span class=\"caption-text\">')\n476 \n477     def depart_title(self, node: Element) -> None:\n478         close_tag = self.context[-1]\n479         if (self.config.html_permalinks and self.builder.add_permalinks and\n480                 node.parent.hasattr('ids') and node.parent['ids']):\n481             # add permalink anchor\n482             if close_tag.startswith('</h'):\n483                 self.add_permalink_ref(node.parent, _('Permalink to this heading'))\n484             elif close_tag.startswith('</a></h'):\n485                 self.body.append('</a><a class=\"headerlink\" href=\"#%s\" ' %\n486                                  node.parent['ids'][0] +\n487                                  'title=\"{}\">{}'.format(\n488                                      _('Permalink to this heading'),\n489                                      self.config.html_permalinks_icon))\n490             elif isinstance(node.parent, nodes.table):\n491                 self.body.append('</span>')\n492                 self.add_permalink_ref(node.parent, _('Permalink to this table'))\n493         elif isinstance(node.parent, nodes.table):\n494             self.body.append('</span>')\n495 \n496         super().depart_title(node)\n497 \n498     # overwritten\n499     def visit_literal_block(self, node: Element) -> None:\n500         if node.rawsource != node.astext():\n501             # most probably a parsed-literal block -- don't highlight\n502             return super().visit_literal_block(node)\n503 \n504         lang = node.get('language', 'default')\n505         linenos = node.get('linenos', False)\n506         highlight_args = node.get('highlight_args', {})\n507         highlight_args['force'] = node.get('force', False)\n508         opts = self.config.highlight_options.get(lang, {})\n509 \n510         if linenos and self.config.html_codeblock_linenos_style:\n511             linenos = self.config.html_codeblock_linenos_style\n512 \n513         highlighted = self.highlighter.highlight_block(\n514             node.rawsource, lang, opts=opts, linenos=linenos,\n515             location=node, **highlight_args,\n516         )\n517         starttag = self.starttag(node, 'div', suffix='',\n518                                  CLASS='highlight-%s notranslate' % lang)\n519         self.body.append(starttag + highlighted + '</div>\\n')\n520         raise nodes.SkipNode\n521 \n522     def visit_caption(self, node: Element) -> None:\n523         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):\n524             self.body.append('<div class=\"code-block-caption\">')\n525         else:\n526             super().visit_caption(node)\n527         self.add_fignumber(node.parent)\n528         self.body.append(self.starttag(node, 'span', '', CLASS='caption-text'))\n529 \n530     def depart_caption(self, node: Element) -> None:\n531         self.body.append('</span>')\n532 \n533         # append permalink if available\n534         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):\n535             self.add_permalink_ref(node.parent, _('Permalink to this code'))\n536         elif isinstance(node.parent, nodes.figure):\n537             self.add_permalink_ref(node.parent, _('Permalink to this image'))\n538         elif node.parent.get('toctree'):\n539             self.add_permalink_ref(node.parent.parent, _('Permalink to this toctree'))\n540 \n541         if isinstance(node.parent, nodes.container) and node.parent.get('literal_block'):\n542             self.body.append('</div>\\n')\n543         else:\n544             super().depart_caption(node)\n545 \n546     def visit_doctest_block(self, node: Element) -> None:\n547         self.visit_literal_block(node)\n548 \n549     # overwritten to add the <div> (for XHTML compliance)\n550     def visit_block_quote(self, node: Element) -> None:\n551         self.body.append(self.starttag(node, 'blockquote') + '<div>')\n552 \n553     def depart_block_quote(self, node: Element) -> None:\n554         self.body.append('</div></blockquote>\\n')\n555 \n556     # overwritten\n557     def visit_literal(self, node: Element) -> None:\n558         if 'kbd' in node['classes']:\n559             self.body.append(self.starttag(node, 'kbd', '',\n560                                            CLASS='docutils literal notranslate'))\n561             return\n562         lang = node.get(\"language\", None)\n563         if 'code' not in node['classes'] or not lang:\n564             self.body.append(self.starttag(node, 'code', '',\n565                                            CLASS='docutils literal notranslate'))\n566             self.protect_literal_text += 1\n567             return\n568 \n569         opts = self.config.highlight_options.get(lang, {})\n570         highlighted = self.highlighter.highlight_block(\n571             node.astext(), lang, opts=opts, location=node, nowrap=True)\n572         starttag = self.starttag(\n573             node,\n574             \"code\",\n575             suffix=\"\",\n576             CLASS=\"docutils literal highlight highlight-%s\" % lang,\n577         )\n578         self.body.append(starttag + highlighted.strip() + \"</code>\")\n579         raise nodes.SkipNode\n580 \n581     def depart_literal(self, node: Element) -> None:\n582         if 'kbd' in node['classes']:\n583             self.body.append('</kbd>')\n584         else:\n585             self.protect_literal_text -= 1\n586             self.body.append('</code>')\n587 \n588     def visit_productionlist(self, node: Element) -> None:\n589         self.body.append(self.starttag(node, 'pre'))\n590         names = []\n591         productionlist = cast(Iterable[addnodes.production], node)\n592         for production in productionlist:\n593             names.append(production['tokenname'])\n594         maxlen = max(len(name) for name in names)\n595         lastname = None\n596         for production in productionlist:\n597             if production['tokenname']:\n598                 lastname = production['tokenname'].ljust(maxlen)\n599                 self.body.append(self.starttag(production, 'strong', ''))\n600                 self.body.append(lastname + '</strong> ::= ')\n601             elif lastname is not None:\n602                 self.body.append('%s     ' % (' ' * len(lastname)))\n603             production.walkabout(self)\n604             self.body.append('\\n')\n605         self.body.append('</pre>\\n')\n606         raise nodes.SkipNode\n607 \n608     def depart_productionlist(self, node: Element) -> None:\n609         pass\n610 \n611     def visit_production(self, node: Element) -> None:\n612         pass\n613 \n614     def depart_production(self, node: Element) -> None:\n615         pass\n616 \n617     def visit_centered(self, node: Element) -> None:\n618         self.body.append(self.starttag(node, 'p', CLASS=\"centered\") +\n619                          '<strong>')\n620 \n621     def depart_centered(self, node: Element) -> None:\n622         self.body.append('</strong></p>')\n623 \n624     def visit_compact_paragraph(self, node: Element) -> None:\n625         pass\n626 \n627     def depart_compact_paragraph(self, node: Element) -> None:\n628         pass\n629 \n630     def visit_download_reference(self, node: Element) -> None:\n631         atts = {'class': 'reference download',\n632                 'download': ''}\n633 \n634         if not self.builder.download_support:\n635             self.context.append('')\n636         elif 'refuri' in node:\n637             atts['class'] += ' external'\n638             atts['href'] = node['refuri']\n639             self.body.append(self.starttag(node, 'a', '', **atts))\n640             self.context.append('</a>')\n641         elif 'filename' in node:\n642             atts['class'] += ' internal'\n643             atts['href'] = posixpath.join(self.builder.dlpath,\n644                                           urllib.parse.quote(node['filename']))\n645             self.body.append(self.starttag(node, 'a', '', **atts))\n646             self.context.append('</a>')\n647         else:\n648             self.context.append('')\n649 \n650     def depart_download_reference(self, node: Element) -> None:\n651         self.body.append(self.context.pop())\n652 \n653     # overwritten\n654     def visit_figure(self, node: Element) -> None:\n655         # set align=default if align not specified to give a default style\n656         node.setdefault('align', 'default')\n657 \n658         return super().visit_figure(node)\n659 \n660     # overwritten\n661     def visit_image(self, node: Element) -> None:\n662         olduri = node['uri']\n663         # rewrite the URI if the environment knows about it\n664         if olduri in self.builder.images:\n665             node['uri'] = posixpath.join(self.builder.imgpath,\n666                                          urllib.parse.quote(self.builder.images[olduri]))\n667 \n668         if 'scale' in node:\n669             # Try to figure out image height and width.  Docutils does that too,\n670             # but it tries the final file name, which does not necessarily exist\n671             # yet at the time the HTML file is written.\n672             if not ('width' in node and 'height' in node):\n673                 size = get_image_size(os.path.join(self.builder.srcdir, olduri))\n674                 if size is None:\n675                     logger.warning(\n676                         __('Could not obtain image size. :scale: option is ignored.'),\n677                         location=node,\n678                     )\n679                 else:\n680                     if 'width' not in node:\n681                         node['width'] = str(size[0])\n682                     if 'height' not in node:\n683                         node['height'] = str(size[1])\n684 \n685         uri = node['uri']\n686         if uri.lower().endswith(('svg', 'svgz')):\n687             atts = {'src': uri}\n688             if 'width' in node:\n689                 atts['width'] = node['width']\n690             if 'height' in node:\n691                 atts['height'] = node['height']\n692             if 'scale' in node:\n693                 if 'width' in atts:\n694                     atts['width'] = multiply_length(atts['width'], node['scale'])\n695                 if 'height' in atts:\n696                     atts['height'] = multiply_length(atts['height'], node['scale'])\n697             atts['alt'] = node.get('alt', uri)\n698             if 'align' in node:\n699                 atts['class'] = 'align-%s' % node['align']\n700             self.body.append(self.emptytag(node, 'img', '', **atts))\n701             return\n702 \n703         super().visit_image(node)\n704 \n705     # overwritten\n706     def depart_image(self, node: Element) -> None:\n707         if node['uri'].lower().endswith(('svg', 'svgz')):\n708             pass\n709         else:\n710             super().depart_image(node)\n711 \n712     def visit_toctree(self, node: Element) -> None:\n713         # this only happens when formatting a toc from env.tocs -- in this\n714         # case we don't want to include the subtree\n715         raise nodes.SkipNode\n716 \n717     def visit_index(self, node: Element) -> None:\n718         raise nodes.SkipNode\n719 \n720     def visit_tabular_col_spec(self, node: Element) -> None:\n721         raise nodes.SkipNode\n722 \n723     def visit_glossary(self, node: Element) -> None:\n724         pass\n725 \n726     def depart_glossary(self, node: Element) -> None:\n727         pass\n728 \n729     def visit_acks(self, node: Element) -> None:\n730         pass\n731 \n732     def depart_acks(self, node: Element) -> None:\n733         pass\n734 \n735     def visit_hlist(self, node: Element) -> None:\n736         self.body.append('<table class=\"hlist\"><tr>')\n737 \n738     def depart_hlist(self, node: Element) -> None:\n739         self.body.append('</tr></table>\\n')\n740 \n741     def visit_hlistcol(self, node: Element) -> None:\n742         self.body.append('<td>')\n743 \n744     def depart_hlistcol(self, node: Element) -> None:\n745         self.body.append('</td>')\n746 \n747     # overwritten\n748     def visit_Text(self, node: Text) -> None:\n749         text = node.astext()\n750         encoded = self.encode(text)\n751         if self.protect_literal_text:\n752             # moved here from base class's visit_literal to support\n753             # more formatting in literal nodes\n754             for token in self.words_and_spaces.findall(encoded):\n755                 if token.strip():\n756                     # protect literal text from line wrapping\n757                     self.body.append('<span class=\"pre\">%s</span>' % token)\n758                 elif token in ' \\n':\n759                     # allow breaks at whitespace\n760                     self.body.append(token)\n761                 else:\n762                     # protect runs of multiple spaces; the last one can wrap\n763                     self.body.append('&#160;' * (len(token) - 1) + ' ')\n764         else:\n765             if self.in_mailto and self.settings.cloak_email_addresses:\n766                 encoded = self.cloak_email(encoded)\n767             self.body.append(encoded)\n768 \n769     def visit_note(self, node: Element) -> None:\n770         self.visit_admonition(node, 'note')\n771 \n772     def depart_note(self, node: Element) -> None:\n773         self.depart_admonition(node)\n774 \n775     def visit_warning(self, node: Element) -> None:\n776         self.visit_admonition(node, 'warning')\n777 \n778     def depart_warning(self, node: Element) -> None:\n779         self.depart_admonition(node)\n780 \n781     def visit_attention(self, node: Element) -> None:\n782         self.visit_admonition(node, 'attention')\n783 \n784     def depart_attention(self, node: Element) -> None:\n785         self.depart_admonition(node)\n786 \n787     def visit_caution(self, node: Element) -> None:\n788         self.visit_admonition(node, 'caution')\n789 \n790     def depart_caution(self, node: Element) -> None:\n791         self.depart_admonition(node)\n792 \n793     def visit_danger(self, node: Element) -> None:\n794         self.visit_admonition(node, 'danger')\n795 \n796     def depart_danger(self, node: Element) -> None:\n797         self.depart_admonition(node)\n798 \n799     def visit_error(self, node: Element) -> None:\n800         self.visit_admonition(node, 'error')\n801 \n802     def depart_error(self, node: Element) -> None:\n803         self.depart_admonition(node)\n804 \n805     def visit_hint(self, node: Element) -> None:\n806         self.visit_admonition(node, 'hint')\n807 \n808     def depart_hint(self, node: Element) -> None:\n809         self.depart_admonition(node)\n810 \n811     def visit_important(self, node: Element) -> None:\n812         self.visit_admonition(node, 'important')\n813 \n814     def depart_important(self, node: Element) -> None:\n815         self.depart_admonition(node)\n816 \n817     def visit_tip(self, node: Element) -> None:\n818         self.visit_admonition(node, 'tip')\n819 \n820     def depart_tip(self, node: Element) -> None:\n821         self.depart_admonition(node)\n822 \n823     def visit_literal_emphasis(self, node: Element) -> None:\n824         return self.visit_emphasis(node)\n825 \n826     def depart_literal_emphasis(self, node: Element) -> None:\n827         return self.depart_emphasis(node)\n828 \n829     def visit_literal_strong(self, node: Element) -> None:\n830         return self.visit_strong(node)\n831 \n832     def depart_literal_strong(self, node: Element) -> None:\n833         return self.depart_strong(node)\n834 \n835     def visit_abbreviation(self, node: Element) -> None:\n836         attrs = {}\n837         if node.hasattr('explanation'):\n838             attrs['title'] = node['explanation']\n839         self.body.append(self.starttag(node, 'abbr', '', **attrs))\n840 \n841     def depart_abbreviation(self, node: Element) -> None:\n842         self.body.append('</abbr>')\n843 \n844     def visit_manpage(self, node: Element) -> None:\n845         self.visit_literal_emphasis(node)\n846         if self.manpages_url:\n847             node['refuri'] = self.manpages_url.format(**node.attributes)\n848             self.visit_reference(node)\n849 \n850     def depart_manpage(self, node: Element) -> None:\n851         if self.manpages_url:\n852             self.depart_reference(node)\n853         self.depart_literal_emphasis(node)\n854 \n855     # overwritten to add even/odd classes\n856 \n857     def visit_table(self, node: Element) -> None:\n858         self._table_row_indices.append(0)\n859 \n860         atts = {}\n861         classes = [cls.strip(' \\t\\n') for cls in self.settings.table_style.split(',')]\n862         classes.insert(0, \"docutils\")  # compat\n863 \n864         # set align-default if align not specified to give a default style\n865         classes.append('align-%s' % node.get('align', 'default'))\n866 \n867         if 'width' in node:\n868             atts['style'] = 'width: %s' % node['width']\n869         tag = self.starttag(node, 'table', CLASS=' '.join(classes), **atts)\n870         self.body.append(tag)\n871 \n872     def depart_table(self, node: Element) -> None:\n873         self._table_row_indices.pop()\n874         super().depart_table(node)\n875 \n876     def visit_row(self, node: Element) -> None:\n877         self._table_row_indices[-1] += 1\n878         if self._table_row_indices[-1] % 2 == 0:\n879             node['classes'].append('row-even')\n880         else:\n881             node['classes'].append('row-odd')\n882         self.body.append(self.starttag(node, 'tr', ''))\n883         node.column = 0  # type: ignore\n884 \n885     def visit_field_list(self, node: Element) -> None:\n886         self._fieldlist_row_indices.append(0)\n887         return super().visit_field_list(node)\n888 \n889     def depart_field_list(self, node: Element) -> None:\n890         self._fieldlist_row_indices.pop()\n891         return super().depart_field_list(node)\n892 \n893     def visit_field(self, node: Element) -> None:\n894         self._fieldlist_row_indices[-1] += 1\n895         if self._fieldlist_row_indices[-1] % 2 == 0:\n896             node['classes'].append('field-even')\n897         else:\n898             node['classes'].append('field-odd')\n899 \n900     def visit_math(self, node: Element, math_env: str = '') -> None:\n901         # see validate_math_renderer\n902         name: str = self.builder.math_renderer_name  # type: ignore[assignment]\n903         visit, _ = self.builder.app.registry.html_inline_math_renderers[name]\n904         visit(self, node)\n905 \n906     def depart_math(self, node: Element, math_env: str = '') -> None:\n907         # see validate_math_renderer\n908         name: str = self.builder.math_renderer_name  # type: ignore[assignment]\n909         _, depart = self.builder.app.registry.html_inline_math_renderers[name]\n910         if depart:\n911             depart(self, node)\n912 \n913     def visit_math_block(self, node: Element, math_env: str = '') -> None:\n914         # see validate_math_renderer\n915         name: str = self.builder.math_renderer_name  # type: ignore[assignment]\n916         visit, _ = self.builder.app.registry.html_block_math_renderers[name]\n917         visit(self, node)\n918 \n919     def depart_math_block(self, node: Element, math_env: str = '') -> None:\n920         # see validate_math_renderer\n921         name: str = self.builder.math_renderer_name  # type: ignore[assignment]\n922         _, depart = self.builder.app.registry.html_block_math_renderers[name]\n923         if depart:\n924             depart(self, node)\n925 \n926     # See Docutils r9413\n927     # Re-instate the footnote-reference class\n928     def visit_footnote_reference(self, node):\n929         href = '#' + node['refid']\n930         classes = ['footnote-reference', self.settings.footnote_references]\n931         self.body.append(self.starttag(node, 'a', suffix='', classes=classes,\n932                                        role='doc-noteref', href=href))\n933         self.body.append('<span class=\"fn-bracket\">[</span>')\n",
        "intended_behavior": "In the context of writing HTML5 output, where SVGs are included, this file should ensure that any embedded objects, particularly SVG images with links, have their paths resolved in a way that accurately reflects their location within the overall site structure. If this file contributes to processing or embedding SVG content, it may need adjustments to correctly handle path resolution for links within SVGs. The specific method(s) responsible for this might need to be examined and modified to ensure that paths are correctly computed, taking the embedding document\u2019s location into account."
    }
]