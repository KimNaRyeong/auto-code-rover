2025-10-17 19:22:04.016 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 19:22:06.521 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=479, output_tokens=12, cost=0.005150
2025-10-17 19:22:18.078 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=659, output_tokens=508, cost=0.021830
2025-10-17 19:22:19.098 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:22:25.200 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=788, output_tokens=280, cost=0.016280
2025-10-17 19:22:25.206 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:22:26.844 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=634, output_tokens=43, cost=0.007630
2025-10-17 19:22:26.846 | DEBUG    | Extracted a valid json.
2025-10-17 19:22:26.846 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"needs_extensions\")",
        "search_code(\"version comparison\")",
        "search_code(\"'>='\")"
    ],
    "bug_locations": []
}
2025-10-17 19:22:26.879 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 19:22:26.880 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 19:22:41.270 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1281, output_tokens=591, cost=0.030540
2025-10-17 19:22:41.281 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:22:51.148 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2089, output_tokens=368, cost=0.031930
2025-10-17 19:22:51.155 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:22:52.204 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-17 19:22:52.205 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:22:52.205 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 19:22:54.006 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-17 19:22:54.007 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:22:54.007 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 19:22:55.046 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-17 19:22:55.047 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:22:55.047 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 19:22:57.699 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-17 19:22:57.700 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:22:57.700 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 19:22:59.735 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=14, cost=0.007640
2025-10-17 19:22:59.736 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 19:22:59.737 | DEBUG    | Agent proxy return the following json: None
2025-10-17 19:22:59.737 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 19:22:59.738 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 19:22:59.738 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:23:07.984 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2484, output_tokens=325, cost=0.034590
2025-10-17 19:23:07.991 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:23:11.140 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=679, output_tokens=70, cost=0.008890
2025-10-17 19:23:11.142 | DEBUG    | Extracted a valid json.
2025-10-17 19:23:11.147 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"setup_extension\")",
        "search_code(\"Extension\")",
        "search_code(\"version parsing\")",
        "search_code(\"parse_version\")",
        "search_code(\"LooseVersion\")",
        "search_code(\"StrictVersion\")"
    ],
    "bug_locations": []
}
2025-10-17 19:23:11.250 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 19:23:11.250 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 19:23:30.411 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3897, output_tokens=931, cost=0.066900
2025-10-17 19:23:30.420 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:23:40.924 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5044, output_tokens=413, cost=0.062830
2025-10-17 19:23:40.932 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:23:46.301 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=767, output_tokens=186, cost=0.013250
2025-10-17 19:23:46.302 | DEBUG    | Extracted a valid json.
2025-10-17 19:23:46.308 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/application.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify or ensure the extension setup logic correctly parses and compares semantic versions. This could involve using a utility like parse_version or adopting a robust comparison approach similar to LooseVersion but suited for semantic versioning, ensuring \"0.10\" is correctly seen as greater than \"0.6\"."
        },
        {
            "file": "sphinx/registry.py",
            "class": "",
            "method": "",
            "intended_behavior": "When registering or validating extension versions, employ a consistent, accurate method for semantic version parsing and comparison. This ensures extensions with correct version numbers are accepted, addressing the comparison issue (\"0.6\" vs. \"0.10\")."
        }
    ]
}
2025-10-17 19:23:46.315 | DEBUG    | Bug location extracted successfully: [<file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import IO, TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Type, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers import Parser
26 from docutils.parsers.rst import Directive, roles
27 from docutils.transforms import Transform
28 from pygments.lexer import Lexer
29 
30 import sphinx
31 from sphinx import locale, package_dir
32 from sphinx.config import Config
33 from sphinx.deprecation import RemovedInSphinx60Warning
34 from sphinx.domains import Domain, Index
35 from sphinx.environment import BuildEnvironment
36 from sphinx.environment.collectors import EnvironmentCollector
37 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
38 from sphinx.events import EventManager
39 from sphinx.extension import Extension
40 from sphinx.highlighting import lexer_classes
41 from sphinx.locale import __
42 from sphinx.project import Project
43 from sphinx.registry import SphinxComponentRegistry
44 from sphinx.roles import XRefRole
45 from sphinx.theming import Theme
46 from sphinx.util import docutils, logging, progress_message
47 from sphinx.util.build_phase import BuildPhase
48 from sphinx.util.console import bold  # type: ignore
49 from sphinx.util.i18n import CatalogRepository
50 from sphinx.util.logging import prefixed_warnings
51 from sphinx.util.osutil import abspath, ensuredir, relpath
52 from sphinx.util.tags import Tags
53 from sphinx.util.typing import RoleFunction, TitleGetter
54 
55 if TYPE_CHECKING:
56     from docutils.nodes import Node  # NOQA
57 
58     from sphinx.builders import Builder
59 
60 
61 builtin_extensions = (
62     'sphinx.addnodes',
63     'sphinx.builders.changes',
64     'sphinx.builders.epub3',
65     'sphinx.builders.dirhtml',
66     'sphinx.builders.dummy',
67     'sphinx.builders.gettext',
68     'sphinx.builders.html',
69     'sphinx.builders.latex',
70     'sphinx.builders.linkcheck',
71     'sphinx.builders.manpage',
72     'sphinx.builders.singlehtml',
73     'sphinx.builders.texinfo',
74     'sphinx.builders.text',
75     'sphinx.builders.xml',
76     'sphinx.config',
77     'sphinx.domains.c',
78     'sphinx.domains.changeset',
79     'sphinx.domains.citation',
80     'sphinx.domains.cpp',
81     'sphinx.domains.index',
82     'sphinx.domains.javascript',
83     'sphinx.domains.math',
84     'sphinx.domains.python',
85     'sphinx.domains.rst',
86     'sphinx.domains.std',
87     'sphinx.directives',
88     'sphinx.directives.code',
89     'sphinx.directives.other',
90     'sphinx.directives.patches',
91     'sphinx.extension',
92     'sphinx.parsers',
93     'sphinx.registry',
94     'sphinx.roles',
95     'sphinx.transforms',
96     'sphinx.transforms.compact_bullet_list',
97     'sphinx.transforms.i18n',
98     'sphinx.transforms.references',
99     'sphinx.transforms.post_transforms',
100     'sphinx.transforms.post_transforms.code',
101     'sphinx.transforms.post_transforms.images',
102     'sphinx.util.compat',
103     'sphinx.versioning',
104     # collectors should be loaded by specific order
105     'sphinx.environment.collectors.dependencies',
106     'sphinx.environment.collectors.asset',
107     'sphinx.environment.collectors.metadata',
108     'sphinx.environment.collectors.title',
109     'sphinx.environment.collectors.toctree',
110     # 1st party extensions
111     'sphinxcontrib.applehelp',
112     'sphinxcontrib.devhelp',
113     'sphinxcontrib.htmlhelp',
114     'sphinxcontrib.serializinghtml',
115     'sphinxcontrib.qthelp',
116     # Strictly, alabaster theme is not a builtin extension,
117     # but it is loaded automatically to use it as default theme.
118     'alabaster',
119 )
120 
121 ENV_PICKLE_FILENAME = 'environment.pickle'
122 
123 logger = logging.getLogger(__name__)
124 
125 
126 class Sphinx:
127     """The main application class and extensibility interface.
128 
129     :ivar srcdir: Directory containing source.
130     :ivar confdir: Directory containing ``conf.py``.
131     :ivar doctreedir: Directory for storing pickled doctrees.
132     :ivar outdir: Directory for storing build documents.
133     """
134 
135     warningiserror: bool
136     _warncount: int
137 
138     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,
139                  buildername: str, confoverrides: Dict = None,
140                  status: IO = sys.stdout, warning: IO = sys.stderr,
141                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
142                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
143         self.phase = BuildPhase.INITIALIZATION
144         self.verbosity = verbosity
145         self.extensions: Dict[str, Extension] = {}
146         self.builder: Optional[Builder] = None
147         self.env: Optional[BuildEnvironment] = None
148         self.project: Optional[Project] = None
149         self.registry = SphinxComponentRegistry()
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155 
156         if not path.isdir(self.srcdir):
157             raise ApplicationError(__('Cannot find source directory (%s)') %
158                                    self.srcdir)
159 
160         if path.exists(self.outdir) and not path.isdir(self.outdir):
161             raise ApplicationError(__('Output directory (%s) is not a directory') %
162                                    self.outdir)
163 
164         if self.srcdir == self.outdir:
165             raise ApplicationError(__('Source directory and destination '
166                                       'directory cannot be identical'))
167 
168         self.parallel = parallel
169 
170         if status is None:
171             self._status: IO = StringIO()
172             self.quiet: bool = True
173         else:
174             self._status = status
175             self.quiet = False
176 
177         if warning is None:
178             self._warning: IO = StringIO()
179         else:
180             self._warning = warning
181         self._warncount = 0
182         self.keep_going = warningiserror and keep_going
183         if self.keep_going:
184             self.warningiserror = False
185         else:
186             self.warningiserror = warningiserror
187         logging.setup(self, self._status, self._warning)
188 
189         self.events = EventManager(self)
190 
191         # keep last few messages for traceback
192         # This will be filled by sphinx.util.logging.LastMessagesWriter
193         self.messagelog: deque = deque(maxlen=10)
194 
195         # say hello to the world
196         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
197 
198         # notice for parallel build on macOS and py38+
199         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
200             logger.info(bold(__("For security reasons, parallel mode is disabled on macOS and "
201                                 "python3.8 and above. For more details, please read "
202                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
203 
204         # status code for command-line application
205         self.statuscode = 0
206 
207         # read config
208         self.tags = Tags(tags)
209         if confdir is None:
210             # set confdir to srcdir if -C given (!= no confdir); a few pieces
211             # of code expect a confdir to be set
212             self.confdir = self.srcdir
213             self.config = Config({}, confoverrides or {})
214         else:
215             self.confdir = abspath(confdir)
216             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
217 
218         # initialize some limited config variables before initialize i18n and loading
219         # extensions
220         self.config.pre_init_values()
221 
222         # set up translation infrastructure
223         self._init_i18n()
224 
225         # check the Sphinx version if requested
226         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
227             raise VersionRequirementError(
228                 __('This project needs at least Sphinx v%s and therefore cannot '
229                    'be built with this version.') % self.config.needs_sphinx)
230 
231         # load all built-in extension modules
232         for extension in builtin_extensions:
233             self.setup_extension(extension)
234 
235         # load all user-given extension modules
236         for extension in self.config.extensions:
237             self.setup_extension(extension)
238 
239         # preload builder module (before init config values)
240         self.preload_builder(buildername)
241 
242         if not path.isdir(outdir):
243             with progress_message(__('making output directory')):
244                 ensuredir(outdir)
245 
246         # the config file itself can be an extension
247         if self.config.setup:
248             prefix = __('while setting up extension %s:') % "conf.py"
249             with prefixed_warnings(prefix):
250                 if callable(self.config.setup):
251                     self.config.setup(self)
252                 else:
253                     raise ConfigError(
254                         __("'setup' as currently defined in conf.py isn't a Python callable. "
255                            "Please modify its definition to make it a callable function. "
256                            "This is needed for conf.py to behave as a Sphinx extension.")
257                     )
258 
259         # now that we know all config values, collect them from conf.py
260         self.config.init_values()
261         self.events.emit('config-inited', self.config)
262 
263         # create the project
264         self.project = Project(self.srcdir, self.config.source_suffix)
265         # create the builder
266         self.builder = self.create_builder(buildername)
267         # set up the build environment
268         self._init_env(freshenv)
269         # set up the builder
270         self._init_builder()
271 
272     def _init_i18n(self) -> None:
273         """Load translated strings from the configured localedirs if enabled in
274         the configuration.
275         """
276         if self.config.language is None:
277             self.translator, has_translation = locale.init([], None)
278         else:
279             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
280                         nonl=True)
281 
282             # compile mo files if sphinx.po file in user locale directories are updated
283             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
284                                      self.config.language, self.config.source_encoding)
285             for catalog in repo.catalogs:
286                 if catalog.domain == 'sphinx' and catalog.is_outdated():
287                     catalog.write_mo(self.config.language)
288 
289             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)
290             locale_dirs += [None]
291             locale_dirs += [path.join(package_dir, 'locale')]
292 
293             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
294             if has_translation or self.config.language == 'en':
295                 # "en" never needs to be translated
296                 logger.info(__('done'))
297             else:
298                 logger.info(__('not available for built-in messages'))
299 
300     def _init_env(self, freshenv: bool) -> None:
301         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
302         if freshenv or not os.path.exists(filename):
303             self.env = BuildEnvironment(self)
304             self.env.find_files(self.config, self.builder)
305         else:
306             try:
307                 with progress_message(__('loading pickled environment')):
308                     with open(filename, 'rb') as f:
309                         self.env = pickle.load(f)
310                         self.env.setup(self)
311             except Exception as err:
312                 logger.info(__('failed: %s'), err)
313                 self._init_env(freshenv=True)
314 
315     def preload_builder(self, name: str) -> None:
316         self.registry.preload_builder(self, name)
317 
318     def create_builder(self, name: str) -> "Builder":
319         if name is None:
320             logger.info(__('No builder selected, using default: html'))
321             name = 'html'
322 
323         return self.registry.create_builder(self, name)
324 
325     def _init_builder(self) -> None:
326         self.builder.set_environment(self.env)
327         self.builder.init()
328         self.events.emit('builder-inited')
329 
330     # ---- main "build" method -------------------------------------------------
331 
332     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
333         self.phase = BuildPhase.READING
334         try:
335             if force_all:
336                 self.builder.compile_all_catalogs()
337                 self.builder.build_all()
338             elif filenames:
339                 self.builder.compile_specific_catalogs(filenames)
340                 self.builder.build_specific(filenames)
341             else:
342                 self.builder.compile_update_catalogs()
343                 self.builder.build_update()
344 
345             if self._warncount and self.keep_going:
346                 self.statuscode = 1
347 
348             status = (__('succeeded') if self.statuscode == 0
349                       else __('finished with problems'))
350             if self._warncount:
351                 if self.warningiserror:
352                     if self._warncount == 1:
353                         msg = __('build %s, %s warning (with warnings treated as errors).')
354                     else:
355                         msg = __('build %s, %s warnings (with warnings treated as errors).')
356                 else:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning.')
359                     else:
360                         msg = __('build %s, %s warnings.')
361 
362                 logger.info(bold(msg % (status, self._warncount)))
363             else:
364                 logger.info(bold(__('build %s.') % status))
365 
366             if self.statuscode == 0 and self.builder.epilog:
367                 logger.info('')
368                 logger.info(self.builder.epilog % {
369                     'outdir': relpath(self.outdir),
370                     'project': self.config.project
371                 })
372         except Exception as err:
373             # delete the saved env to force a fresh build next time
374             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
375             if path.isfile(envfile):
376                 os.unlink(envfile)
377             self.events.emit('build-finished', err)
378             raise
379         else:
380             self.events.emit('build-finished', None)
381         self.builder.cleanup()
382 
383     # ---- general extensibility interface -------------------------------------
384 
385     def setup_extension(self, extname: str) -> None:
386         """Import and setup a Sphinx extension module.
387 
388         Load the extension given by the module *name*.  Use this if your
389         extension needs the features provided by another extension.  No-op if
390         called twice.
391         """
392         logger.debug('[app] setting up extension: %r', extname)
393         self.registry.load_extension(self, extname)
394 
395     def require_sphinx(self, version: str) -> None:
396         """Check the Sphinx version if requested.
397 
398         Compare *version* with the version of the running Sphinx, and abort the
399         build when it is too old.
400 
401         :param version: The required version in the form of ``major.minor``.
402 
403         .. versionadded:: 1.0
404         """
405         if version > sphinx.__display_version__[:3]:
406             raise VersionRequirementError(version)
407 
408     # event interface
409     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
410         """Register *callback* to be called when *event* is emitted.
411 
412         For details on available core events and the arguments of callback
413         functions, please see :ref:`events`.
414 
415         :param event: The name of target event
416         :param callback: Callback function for the event
417         :param priority: The priority of the callback.  The callbacks will be invoked
418                          in order of *priority* (ascending).
419         :return: A listener ID.  It can be used for :meth:`disconnect`.
420 
421         .. versionchanged:: 3.0
422 
423            Support *priority*
424         """
425         listener_id = self.events.connect(event, callback, priority)
426         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
427                      event, priority, callback, listener_id)
428         return listener_id
429 
430     def disconnect(self, listener_id: int) -> None:
431         """Unregister callback by *listener_id*.
432 
433         :param listener_id: A listener_id that :meth:`connect` returns
434         """
435         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
436         self.events.disconnect(listener_id)
437 
438     def emit(self, event: str, *args: Any,
439              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:
440         """Emit *event* and pass *arguments* to the callback functions.
441 
442         Return the return values of all callbacks as a list.  Do not emit core
443         Sphinx events in extensions!
444 
445         :param event: The name of event that will be emitted
446         :param args: The arguments for the event
447         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
448 
449         .. versionchanged:: 3.1
450 
451            Added *allowed_exceptions* to specify path-through exceptions
452         """
453         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
454 
455     def emit_firstresult(self, event: str, *args: Any,
456                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:
457         """Emit *event* and pass *arguments* to the callback functions.
458 
459         Return the result of the first callback that doesn't return ``None``.
460 
461         :param event: The name of event that will be emitted
462         :param args: The arguments for the event
463         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
464 
465         .. versionadded:: 0.5
466         .. versionchanged:: 3.1
467 
468            Added *allowed_exceptions* to specify path-through exceptions
469         """
470         return self.events.emit_firstresult(event, *args,
471                                             allowed_exceptions=allowed_exceptions)
472 
473     # registering addon parts
474 
475     def add_builder(self, builder: Type["Builder"], override: bool = False) -> None:
476         """Register a new builder.
477 
478         :param builder: A builder class
479         :param override: If true, install the builder forcedly even if another builder
480                          is already installed as the same name
481 
482         .. versionchanged:: 1.8
483            Add *override* keyword.
484         """
485         self.registry.add_builder(builder, override=override)
486 
487     # TODO(stephenfin): Describe 'types' parameter
488     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
489                          types: Any = ()) -> None:
490         """Register a configuration value.
491 
492         This is necessary for Sphinx to recognize new values and set default
493         values accordingly.
494 
495 
496         :param name: The name of the configuration value.  It is recommended to be prefixed
497                      with the extension name (ex. ``html_logo``, ``epub_title``)
498         :param default: The default value of the configuration.
499         :param rebuild: The condition of rebuild.  It must be one of those values:
500 
501                         * ``'env'`` if a change in the setting only takes effect when a
502                           document is parsed -- this means that the whole environment must be
503                           rebuilt.
504                         * ``'html'`` if a change in the setting needs a full rebuild of HTML
505                           documents.
506                         * ``''`` if a change in the setting will not need any special rebuild.
507         :param types: The type of configuration value.  A list of types can be specified.  For
508                       example, ``[str]`` is used to describe a configuration that takes string
509                       value.
510 
511         .. versionchanged:: 0.4
512            If the *default* value is a callable, it will be called with the
513            config object as its argument in order to get the default value.
514            This can be used to implement config values whose default depends on
515            other values.
516 
517         .. versionchanged:: 0.6
518            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
519            ``'env'``) to a string.  However, booleans are still accepted and
520            converted internally.
521         """
522         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))
523         if rebuild in (False, True):
524             rebuild = 'env' if rebuild else ''
525         self.config.add(name, default, rebuild, types)
526 
527     def add_event(self, name: str) -> None:
528         """Register an event called *name*.
529 
530         This is needed to be able to emit it.
531 
532         :param name: The name of the event
533         """
534         logger.debug('[app] adding event: %r', name)
535         self.events.add(name)
536 
537     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],
538                        override: bool = False) -> None:
539         """Register or override a Docutils translator class.
540 
541         This is used to register a custom output translator or to replace a
542         builtin translator.  This allows extensions to use a custom translator
543         and define custom nodes for the translator (see :meth:`add_node`).
544 
545         :param name: The name of the builder for the translator
546         :param translator_class: A translator class
547         :param override: If true, install the translator forcedly even if another translator
548                          is already installed as the same name
549 
550         .. versionadded:: 1.3
551         .. versionchanged:: 1.8
552            Add *override* keyword.
553         """
554         self.registry.add_translator(name, translator_class, override=override)
555 
556     def add_node(self, node: Type[Element], override: bool = False,
557                  **kwargs: Tuple[Callable, Optional[Callable]]) -> None:
558         """Register a Docutils node class.
559 
560         This is necessary for Docutils internals.  It may also be used in the
561         future to validate nodes in the parsed documents.
562 
563         :param node: A node class
564         :param kwargs: Visitor functions for each builder (see below)
565         :param override: If true, install the node forcedly even if another node is already
566                          installed as the same name
567 
568         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
569         writers can be given as keyword arguments: the keyword should be one or
570         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
571         or any other supported translators, the value a 2-tuple of ``(visit,
572         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
573         function raises :exc:`docutils.nodes.SkipNode`.  Example:
574 
575         .. code-block:: python
576 
577            class math(docutils.nodes.Element): pass
578 
579            def visit_math_html(self, node):
580                self.body.append(self.starttag(node, 'math'))
581            def depart_math_html(self, node):
582                self.body.append('</math>')
583 
584            app.add_node(math, html=(visit_math_html, depart_math_html))
585 
586         Obviously, translators for which you don't specify visitor methods will
587         choke on the node when encountered in a document to translate.
588 
589         .. versionchanged:: 0.5
590            Added the support for keyword arguments giving visit functions.
591         """
592         logger.debug('[app] adding node: %r', (node, kwargs))
593         if not override and docutils.is_node_registered(node):
594             logger.warning(__('node class %r is already registered, '
595                               'its visitors will be overridden'),
596                            node.__name__, type='app', subtype='add_node')
597         docutils.register_node(node)
598         self.registry.add_translation_handlers(node, **kwargs)
599 
600     def add_enumerable_node(self, node: Type[Element], figtype: str,
601                             title_getter: TitleGetter = None, override: bool = False,
602                             **kwargs: Tuple[Callable, Callable]) -> None:
603         """Register a Docutils node class as a numfig target.
604 
605         Sphinx numbers the node automatically. And then the users can refer it
606         using :rst:role:`numref`.
607 
608         :param node: A node class
609         :param figtype: The type of enumerable nodes.  Each figtype has individual numbering
610                         sequences.  As system figtypes, ``figure``, ``table`` and
611                         ``code-block`` are defined.  It is possible to add custom nodes to
612                         these default figtypes.  It is also possible to define new custom
613                         figtype if a new figtype is given.
614         :param title_getter: A getter function to obtain the title of node.  It takes an
615                              instance of the enumerable node, and it must return its title as
616                              string.  The title is used to the default title of references for
617                              :rst:role:`ref`.  By default, Sphinx searches
618                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the
619                              node as a title.
620         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)
621         :param override: If true, install the node forcedly even if another node is already
622                          installed as the same name
623 
624         .. versionadded:: 1.4
625         """
626         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
627         self.add_node(node, override=override, **kwargs)
628 
629     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:
630         """Register a Docutils directive.
631 
632         :param name: The name of the directive
633         :param cls: A directive class
634         :param override: If true, install the directive forcedly even if another directive
635                          is already installed as the same name
636 
637         For example, a custom directive named ``my-directive`` would be added
638         like this:
639 
640         .. code-block:: python
641 
642            from docutils.parsers.rst import Directive, directives
643 
644            class MyDirective(Directive):
645                has_content = True
646                required_arguments = 1
647                optional_arguments = 0
648                final_argument_whitespace = True
649                option_spec = {
650                    'class': directives.class_option,
651                    'name': directives.unchanged,
652                }
653 
654                def run(self):
655                    ...
656 
657            def setup(app):
658                app.add_directive('my-directive', MyDirective)
659 
660         For more details, see `the Docutils docs
661         <https://docutils.sourceforge.io/docs/howto/rst-directives.html>`__ .
662 
663         .. versionchanged:: 0.6
664            Docutils 0.5-style directive classes are now supported.
665         .. deprecated:: 1.8
666            Docutils 0.4-style (function based) directives support is deprecated.
667         .. versionchanged:: 1.8
668            Add *override* keyword.
669         """
670         logger.debug('[app] adding directive: %r', (name, cls))
671         if not override and docutils.is_directive_registered(name):
672             logger.warning(__('directive %r is already registered, it will be overridden'),
673                            name, type='app', subtype='add_directive')
674 
675         docutils.register_directive(name, cls)
676 
677     def add_role(self, name: str, role: Any, override: bool = False) -> None:
678         """Register a Docutils role.
679 
680         :param name: The name of role
681         :param role: A role function
682         :param override: If true, install the role forcedly even if another role is already
683                          installed as the same name
684 
685         For more details about role functions, see `the Docutils docs
686         <https://docutils.sourceforge.io/docs/howto/rst-roles.html>`__ .
687 
688         .. versionchanged:: 1.8
689            Add *override* keyword.
690         """
691         logger.debug('[app] adding role: %r', (name, role))
692         if not override and docutils.is_role_registered(name):
693             logger.warning(__('role %r is already registered, it will be overridden'),
694                            name, type='app', subtype='add_role')
695         docutils.register_role(name, role)
696 
697     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
698         """Register a generic Docutils role.
699 
700         Register a Docutils role that does nothing but wrap its contents in the
701         node given by *nodeclass*.
702 
703         If *override* is True, the given *nodeclass* is forcedly installed even if
704         a role named as *name* is already installed.
705 
706         .. versionadded:: 0.6
707         .. versionchanged:: 1.8
708            Add *override* keyword.
709         """
710         # Don't use ``roles.register_generic_role`` because it uses
711         # ``register_canonical_role``.
712         logger.debug('[app] adding generic role: %r', (name, nodeclass))
713         if not override and docutils.is_role_registered(name):
714             logger.warning(__('role %r is already registered, it will be overridden'),
715                            name, type='app', subtype='add_generic_role')
716         role = roles.GenericRole(name, nodeclass)
717         docutils.register_role(name, role)
718 
719     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
720         """Register a domain.
721 
722         :param domain: A domain class
723         :param override: If true, install the domain forcedly even if another domain
724                          is already installed as the same name
725 
726         .. versionadded:: 1.0
727         .. versionchanged:: 1.8
728            Add *override* keyword.
729         """
730         self.registry.add_domain(domain, override=override)
731 
732     def add_directive_to_domain(self, domain: str, name: str,
733                                 cls: Type[Directive], override: bool = False) -> None:
734         """Register a Docutils directive in a domain.
735 
736         Like :meth:`add_directive`, but the directive is added to the domain
737         named *domain*.
738 
739         :param domain: The name of target domain
740         :param name: A name of directive
741         :param cls: A directive class
742         :param override: If true, install the directive forcedly even if another directive
743                          is already installed as the same name
744 
745         .. versionadded:: 1.0
746         .. versionchanged:: 1.8
747            Add *override* keyword.
748         """
749         self.registry.add_directive_to_domain(domain, name, cls, override=override)
750 
751     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
752                            override: bool = False) -> None:
753         """Register a Docutils role in a domain.
754 
755         Like :meth:`add_role`, but the role is added to the domain named
756         *domain*.
757 
758         :param domain: The name of the target domain
759         :param name: The name of the role
760         :param role: The role function
761         :param override: If true, install the role forcedly even if another role is already
762                          installed as the same name
763 
764         .. versionadded:: 1.0
765         .. versionchanged:: 1.8
766            Add *override* keyword.
767         """
768         self.registry.add_role_to_domain(domain, name, role, override=override)
769 
770     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False
771                             ) -> None:
772         """Register a custom index for a domain.
773 
774         Add a custom *index* class to the domain named *domain*.
775 
776         :param domain: The name of the target domain
777         :param index: The index class
778         :param override: If true, install the index forcedly even if another index is
779                          already installed as the same name
780 
781         .. versionadded:: 1.0
782         .. versionchanged:: 1.8
783            Add *override* keyword.
784         """
785         self.registry.add_index_to_domain(domain, index)
786 
787     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
788                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
789                         objname: str = '', doc_field_types: List = [], override: bool = False
790                         ) -> None:
791         """Register a new object type.
792 
793         This method is a very convenient way to add a new :term:`object` type
794         that can be cross-referenced.  It will do this:
795 
796         - Create a new directive (called *directivename*) for documenting an
797           object.  It will automatically add index entries if *indextemplate*
798           is nonempty; if given, it must contain exactly one instance of
799           ``%s``.  See the example below for how the template will be
800           interpreted.
801         - Create a new role (called *rolename*) to cross-reference to these
802           object descriptions.
803         - If you provide *parse_node*, it must be a function that takes a
804           string and a docutils node, and it must populate the node with
805           children parsed from the string.  It must then return the name of the
806           item to be used in cross-referencing and index entries.  See the
807           :file:`conf.py` file in the source for this documentation for an
808           example.
809         - The *objname* (if not given, will default to *directivename*) names
810           the type of object.  It is used when listing objects, e.g. in search
811           results.
812 
813         For example, if you have this call in a custom Sphinx extension::
814 
815            app.add_object_type('directive', 'dir', 'pair: %s; directive')
816 
817         you can use this markup in your documents::
818 
819            .. rst:directive:: function
820 
821               Document a function.
822 
823            <...>
824 
825            See also the :rst:dir:`function` directive.
826 
827         For the directive, an index entry will be generated as if you had prepended ::
828 
829            .. index:: pair: function; directive
830 
831         The reference node will be of class ``literal`` (so it will be rendered
832         in a proportional font, as appropriate for code) unless you give the
833         *ref_nodeclass* argument, which must be a docutils node class.  Most
834         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
835         you can also use ``docutils.nodes.generated`` if you want no further
836         text decoration.  If the text should be treated as literal (e.g. no
837         smart quote replacement), but not have typewriter styling, use
838         ``sphinx.addnodes.literal_emphasis`` or
839         ``sphinx.addnodes.literal_strong``.
840 
841         For the role content, you have the same syntactical possibilities as
842         for standard Sphinx roles (see :ref:`xref-syntax`).
843 
844         If *override* is True, the given object_type is forcedly installed even if
845         an object_type having the same name is already installed.
846 
847         .. versionchanged:: 1.8
848            Add *override* keyword.
849         """
850         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
851                                       ref_nodeclass, objname, doc_field_types,
852                                       override=override)
853 
854     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
855                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
856                           override: bool = False) -> None:
857         """Register a new crossref object type.
858 
859         This method is very similar to :meth:`add_object_type` except that the
860         directive it generates must be empty, and will produce no output.
861 
862         That means that you can add semantic targets to your sources, and refer
863         to them using custom roles instead of generic ones (like
864         :rst:role:`ref`).  Example call::
865 
866            app.add_crossref_type('topic', 'topic', 'single: %s',
867                                  docutils.nodes.emphasis)
868 
869         Example usage::
870 
871            .. topic:: application API
872 
873            The application API
874            -------------------
875 
876            Some random text here.
877 
878            See also :topic:`this section <application API>`.
879 
880         (Of course, the element following the ``topic`` directive needn't be a
881         section.)
882 
883         If *override* is True, the given crossref_type is forcedly installed even if
884         a crossref_type having the same name is already installed.
885 
886         .. versionchanged:: 1.8
887            Add *override* keyword.
888         """
889         self.registry.add_crossref_type(directivename, rolename,
890                                         indextemplate, ref_nodeclass, objname,
891                                         override=override)
892 
893     def add_transform(self, transform: Type[Transform]) -> None:
894         """Register a Docutils transform to be applied after parsing.
895 
896         Add the standard docutils :class:`Transform` subclass *transform* to
897         the list of transforms that are applied after Sphinx parses a reST
898         document.
899 
900         :param transform: A transform class
901 
902         .. list-table:: priority range categories for Sphinx transforms
903            :widths: 20,80
904 
905            * - Priority
906              - Main purpose in Sphinx
907            * - 0-99
908              - Fix invalid nodes by docutils. Translate a doctree.
909            * - 100-299
910              - Preparation
911            * - 300-399
912              - early
913            * - 400-699
914              - main
915            * - 700-799
916              - Post processing. Deadline to modify text and referencing.
917            * - 800-899
918              - Collect referencing and referenced nodes. Domain processing.
919            * - 900-999
920              - Finalize and clean up.
921 
922         refs: `Transform Priority Range Categories`__
923 
924         __ https://docutils.sourceforge.io/docs/ref/transforms.html#transform-priority-range-categories
925         """  # NOQA
926         self.registry.add_transform(transform)
927 
928     def add_post_transform(self, transform: Type[Transform]) -> None:
929         """Register a Docutils transform to be applied before writing.
930 
931         Add the standard docutils :class:`Transform` subclass *transform* to
932         the list of transforms that are applied before Sphinx writes a
933         document.
934 
935         :param transform: A transform class
936         """
937         self.registry.add_post_transform(transform)
938 
939     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
940         """Register a JavaScript file to include in the HTML output.
941 
942         Add *filename* to the list of JavaScript files that the default HTML
943         template will include in order of *priority* (ascending).  The filename
944         must be relative to the HTML static path , or a full URI with scheme.
945         If the priority of the JavaScript file is the same as others, the JavaScript
946         files will be included in order of registration.  If the keyword
947         argument ``body`` is given, its value will be added between the
948         ``<script>`` tags. Extra keyword arguments are included as attributes of
949         the ``<script>`` tag.
950 
951         Example::
952 
953             app.add_js_file('example.js')
954             # => <script src="_static/example.js"></script>
955 
956             app.add_js_file('example.js', async="async")
957             # => <script src="_static/example.js" async="async"></script>
958 
959             app.add_js_file(None, body="var myVariable = 'foo';")
960             # => <script>var myVariable = 'foo';</script>
961 
962         .. list-table:: priority range for JavaScript files
963            :widths: 20,80
964 
965            * - Priority
966              - Main purpose in Sphinx
967            * - 200
968              - default priority for built-in JavaScript files
969            * - 500
970              - default priority for extensions
971            * - 800
972              - default priority for :confval:`html_js_files`
973 
974         A JavaScript file can be added to the specific HTML page when an extension
975         calls this method on :event:`html-page-context` event.
976 
977         .. versionadded:: 0.5
978 
979         .. versionchanged:: 1.8
980            Renamed from ``app.add_javascript()``.
981            And it allows keyword arguments as attributes of script tag.
982 
983         .. versionchanged:: 3.5
984            Take priority argument.  Allow to add a JavaScript file to the specific page.
985         """
986         self.registry.add_js_file(filename, priority=priority, **kwargs)
987         if hasattr(self.builder, 'add_js_file'):
988             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore
989 
990     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
991         """Register a stylesheet to include in the HTML output.
992 
993         Add *filename* to the list of CSS files that the default HTML template
994         will include in order of *priority* (ascending).  The filename must be
995         relative to the HTML static path, or a full URI with scheme.  If the
996         priority of the CSS file is the same as others, the CSS files will be
997         included in order of registration.  The keyword arguments are also
998         accepted for attributes of ``<link>`` tag.
999 
1000         Example::
1001 
1002             app.add_css_file('custom.css')
1003             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
1004 
1005             app.add_css_file('print.css', media='print')
1006             # => <link rel="stylesheet" href="_static/print.css"
1007             #          type="text/css" media="print" />
1008 
1009             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
1010             # => <link rel="alternate stylesheet" href="_static/fancy.css"
1011             #          type="text/css" title="fancy" />
1012 
1013         .. list-table:: priority range for CSS files
1014            :widths: 20,80
1015 
1016            * - Priority
1017              - Main purpose in Sphinx
1018            * - 200
1019              - default priority for built-in CSS files
1020            * - 500
1021              - default priority for extensions
1022            * - 800
1023              - default priority for :confval:`html_css_files`
1024 
1025         A CSS file can be added to the specific HTML page when an extension calls
1026         this method on :event:`html-page-context` event.
1027 
1028         .. versionadded:: 1.0
1029 
1030         .. versionchanged:: 1.6
1031            Optional ``alternate`` and/or ``title`` attributes can be supplied
1032            with the arguments *alternate* (a Boolean) and *title* (a string).
1033            The default is no title and *alternate* = ``False``. For
1034            more information, refer to the `documentation
1035            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
1036 
1037         .. versionchanged:: 1.8
1038            Renamed from ``app.add_stylesheet()``.
1039            And it allows keyword arguments as attributes of link tag.
1040 
1041         .. versionchanged:: 3.5
1042            Take priority argument.  Allow to add a CSS file to the specific page.
1043         """
1044         logger.debug('[app] adding stylesheet: %r', filename)
1045         self.registry.add_css_files(filename, priority=priority, **kwargs)
1046         if hasattr(self.builder, 'add_css_file'):
1047             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore
1048 
1049     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
1050                        ) -> None:
1051         """An alias of :meth:`add_css_file`.
1052 
1053         .. deprecated:: 1.8
1054         """
1055         logger.warning('The app.add_stylesheet() is deprecated. '
1056                        'Please use app.add_css_file() instead.')
1057 
1058         attributes = {}  # type: Dict[str, Any]
1059         if alternate:
1060             attributes['rel'] = 'alternate stylesheet'
1061         else:
1062             attributes['rel'] = 'stylesheet'
1063 
1064         if title:
1065             attributes['title'] = title
1066 
1067         self.add_css_file(filename, **attributes)
1068 
1069     def add_latex_package(self, packagename: str, options: str = None,
1070                           after_hyperref: bool = False) -> None:
1071         r"""Register a package to include in the LaTeX source code.
1072 
1073         Add *packagename* to the list of packages that LaTeX source code will
1074         include.  If you provide *options*, it will be taken to the `\usepackage`
1075         declaration.  If you set *after_hyperref* truthy, the package will be
1076         loaded after ``hyperref`` package.
1077 
1078         .. code-block:: python
1079 
1080            app.add_latex_package('mypackage')
1081            # => \usepackage{mypackage}
1082            app.add_latex_package('mypackage', 'foo,bar')
1083            # => \usepackage[foo,bar]{mypackage}
1084 
1085         .. versionadded:: 1.3
1086         .. versionadded:: 3.1
1087 
1088            *after_hyperref* option.
1089         """
1090         self.registry.add_latex_package(packagename, options, after_hyperref)
1091 
1092     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:
1093         """Register a new lexer for source code.
1094 
1095         Use *lexer* to highlight code blocks with the given language *alias*.
1096 
1097         .. versionadded:: 0.6
1098         .. versionchanged:: 2.1
1099            Take a lexer class as an argument.  An instance of lexers are
1100            still supported until Sphinx-3.x.
1101         """
1102         logger.debug('[app] adding lexer: %r', (alias, lexer))
1103         lexer_classes[alias] = lexer
1104 
1105     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1106         """Register a new documenter class for the autodoc extension.
1107 
1108         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1109         extension.  It must be a subclass of
1110         :class:`sphinx.ext.autodoc.Documenter`.  This allows auto-documenting
1111         new types of objects.  See the source of the autodoc module for
1112         examples on how to subclass :class:`Documenter`.
1113 
1114         If *override* is True, the given *cls* is forcedly installed even if
1115         a documenter having the same name is already installed.
1116 
1117         See :ref:`autodoc_ext_tutorial`.
1118 
1119         .. versionadded:: 0.6
1120         .. versionchanged:: 2.2
1121            Add *override* keyword.
1122         """
1123         logger.debug('[app] adding autodocumenter: %r', cls)
1124         from sphinx.ext.autodoc.directive import AutodocDirective
1125         self.registry.add_documenter(cls.objtype, cls)
1126         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1127 
1128     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]
1129                                ) -> None:
1130         """Register a new ``getattr``-like function for the autodoc extension.
1131 
1132         Add *getter*, which must be a function with an interface compatible to
1133         the :func:`getattr` builtin, as the autodoc attribute getter for
1134         objects that are instances of *typ*.  All cases where autodoc needs to
1135         get an attribute of a type are then handled by this function instead of
1136         :func:`getattr`.
1137 
1138         .. versionadded:: 0.6
1139         """
1140         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1141         self.registry.add_autodoc_attrgetter(typ, getter)
1142 
1143     def add_search_language(self, cls: Any) -> None:
1144         """Register a new language for the HTML search index.
1145 
1146         Add *cls*, which must be a subclass of
1147         :class:`sphinx.search.SearchLanguage`, as a support language for
1148         building the HTML full-text search index.  The class must have a *lang*
1149         attribute that indicates the language it should be used for.  See
1150         :confval:`html_search_language`.
1151 
1152         .. versionadded:: 1.1
1153         """
1154         logger.debug('[app] adding search language: %r', cls)
1155         from sphinx.search import SearchLanguage, languages
1156         assert issubclass(cls, SearchLanguage)
1157         languages[cls.lang] = cls
1158 
1159     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1160         """Register a suffix of source files.
1161 
1162         Same as :confval:`source_suffix`.  The users can override this
1163         using the config setting.
1164 
1165         If *override* is True, the given *suffix* is forcedly installed even if
1166         the same suffix is already installed.
1167 
1168         .. versionadded:: 1.8
1169         """
1170         self.registry.add_source_suffix(suffix, filetype, override=override)
1171 
1172     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
1173         """Register a parser class.
1174 
1175         If *override* is True, the given *parser* is forcedly installed even if
1176         a parser for the same suffix is already installed.
1177 
1178         .. versionadded:: 1.4
1179         .. versionchanged:: 1.8
1180            *suffix* argument is deprecated.  It only accepts *parser* argument.
1181            Use :meth:`add_source_suffix` API to register suffix instead.
1182         .. versionchanged:: 1.8
1183            Add *override* keyword.
1184         """
1185         self.registry.add_source_parser(parser, override=override)
1186 
1187     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:
1188         """Register an environment collector class.
1189 
1190         Refer to :ref:`collector-api`.
1191 
1192         .. versionadded:: 1.6
1193         """
1194         logger.debug('[app] adding environment collector: %r', collector)
1195         collector().enable(self)
1196 
1197     def add_html_theme(self, name: str, theme_path: str) -> None:
1198         """Register a HTML Theme.
1199 
1200         The *name* is a name of theme, and *theme_path* is a full path to the
1201         theme (refs: :ref:`distribute-your-theme`).
1202 
1203         .. versionadded:: 1.6
1204         """
1205         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1206         self.registry.add_html_theme(name, theme_path)
1207 
1208     def add_html_math_renderer(self, name: str,
1209                                inline_renderers: Tuple[Callable, Callable] = None,
1210                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1211         """Register a math renderer for HTML.
1212 
1213         The *name* is a name of math renderer.  Both *inline_renderers* and
1214         *block_renderers* are used as visitor functions for the HTML writer:
1215         the former for inline math node (``nodes.math``), the latter for
1216         block math node (``nodes.math_block``).  Regarding visitor functions,
1217         see :meth:`add_node` for details.
1218 
1219         .. versionadded:: 1.8
1220 
1221         """
1222         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1223 
1224     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1225         """Register a message catalog.
1226 
1227         :param catalog: The name of the catalog
1228         :param locale_dir: The base path of the message catalog
1229 
1230         For more details, see :func:`sphinx.locale.get_translation()`.
1231 
1232         .. versionadded:: 1.8
1233         """
1234         locale.init([locale_dir], self.config.language, catalog)
1235         locale.init_console(locale_dir, catalog)
1236 
1237     # ---- other methods -------------------------------------------------
1238     def is_parallel_allowed(self, typ: str) -> bool:
1239         """Check whether parallel processing is allowed or not.
1240 
1241         :param typ: A type of processing; ``'read'`` or ``'write'``.
1242         """
1243         if typ == 'read':
1244             attrname = 'parallel_read_safe'
1245             message_not_declared = __("the %s extension does not declare if it "
1246                                       "is safe for parallel reading, assuming "
1247                                       "it isn't - please ask the extension author "
1248                                       "to check and make it explicit")
1249             message_not_safe = __("the %s extension is not safe for parallel reading")
1250         elif typ == 'write':
1251             attrname = 'parallel_write_safe'
1252             message_not_declared = __("the %s extension does not declare if it "
1253                                       "is safe for parallel writing, assuming "
1254                                       "it isn't - please ask the extension author "
1255                                       "to check and make it explicit")
1256             message_not_safe = __("the %s extension is not safe for parallel writing")
1257         else:
1258             raise ValueError('parallel type %s is not supported' % typ)
1259 
1260         for ext in self.extensions.values():
1261             allowed = getattr(ext, attrname, None)
1262             if allowed is None:
1263                 logger.warning(message_not_declared, ext.name)
1264                 logger.warning(__('doing serial %s'), typ)
1265                 return False
1266             elif not allowed:
1267                 logger.warning(message_not_safe, ext.name)
1268                 logger.warning(__('doing serial %s'), typ)
1269                 return False
1270 
1271         return True
1272 
1273     def set_html_assets_policy(self, policy):
1274         """Set the policy to include assets in HTML pages.
1275 
1276         - always: include the assets in all the pages
1277         - per_page: include the assets only in pages where they are used
1278 
1279         .. versionadded: 4.1
1280         """
1281         if policy not in ('always', 'per_page'):
1282             raise ValueError('policy %s is not supported' % policy)
1283         self.registry.html_assets_policy = policy
1284 
1285     @property
1286     def html_themes(self) -> Dict[str, str]:
1287         warnings.warn('app.html_themes is deprecated.',
1288                       RemovedInSphinx60Warning)
1289         return self.registry.html_themes
1290 
1291 
1292 class TemplateBridge:
1293     """
1294     This class defines the interface for a "template bridge", that is, a class
1295     that renders templates given a template name and a context.
1296     """
1297 
1298     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1299         """Called by the builder to initialize the template system.
1300 
1301         *builder* is the builder object; you'll probably want to look at the
1302         value of ``builder.config.templates_path``.
1303 
1304         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1305         case, *dirs* can be list of fixed directories to look for templates.
1306         """
1307         raise NotImplementedError('must be implemented in subclasses')
1308 
1309     def newest_template_mtime(self) -> float:
1310         """Called by the builder to determine if output files are outdated
1311         because of template changes.  Return the mtime of the newest template
1312         file that was changed.  The default implementation returns ``0``.
1313         """
1314         return 0
1315 
1316     def render(self, template: str, context: Dict) -> None:
1317         """Called by the builder to render a template given as a filename with
1318         a specified context (a Python dictionary).
1319         """
1320         raise NotImplementedError('must be implemented in subclasses')
1321 
1322     def render_string(self, template: str, context: Dict) -> str:
1323         """Called by the builder to render a template given as a string with a
1324         specified context (a Python dictionary).
1325         """
1326         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>Modify or ensure the extension setup logic correctly parses and compares semantic versions. This could involve using a utility like parse_version or adopting a robust comparison approach similar to LooseVersion but suited for semantic versioning, ensuring "0.10" is correctly seen as greater than "0.6".</intended_behavior>, <file>sphinx/registry.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.registry
3     ~~~~~~~~~~~~~~~
4 
5     Sphinx component registry.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import traceback
12 import warnings
13 from importlib import import_module
14 from types import MethodType
15 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Type,
16                     Union)
17 
18 from docutils import nodes
19 from docutils.io import Input
20 from docutils.nodes import Element, Node, TextElement
21 from docutils.parsers import Parser
22 from docutils.parsers.rst import Directive
23 from docutils.transforms import Transform
24 from pkg_resources import iter_entry_points
25 
26 from sphinx.builders import Builder
27 from sphinx.config import Config
28 from sphinx.deprecation import RemovedInSphinx60Warning
29 from sphinx.domains import Domain, Index, ObjType
30 from sphinx.domains.std import GenericObject, Target
31 from sphinx.environment import BuildEnvironment
32 from sphinx.errors import ExtensionError, SphinxError, VersionRequirementError
33 from sphinx.extension import Extension
34 from sphinx.locale import __
35 from sphinx.parsers import Parser as SphinxParser
36 from sphinx.roles import XRefRole
37 from sphinx.util import logging
38 from sphinx.util.logging import prefixed_warnings
39 from sphinx.util.typing import RoleFunction, TitleGetter
40 
41 if TYPE_CHECKING:
42     from sphinx.application import Sphinx
43     from sphinx.ext.autodoc import Documenter
44 
45 logger = logging.getLogger(__name__)
46 
47 # list of deprecated extensions. Keys are extension name.
48 # Values are Sphinx version that merge the extension.
49 EXTENSION_BLACKLIST = {
50     "sphinxjp.themecore": "1.2"
51 }
52 
53 
54 class SphinxComponentRegistry:
55     def __init__(self) -> None:
56         #: special attrgetter for autodoc; class object -> attrgetter
57         self.autodoc_attrgettrs: Dict[Type, Callable[[Any, str, Any], Any]] = {}
58 
59         #: builders; a dict of builder name -> bulider class
60         self.builders: Dict[str, Type[Builder]] = {}
61 
62         #: autodoc documenters; a dict of documenter name -> documenter class
63         self.documenters: Dict[str, Type[Documenter]] = {}
64 
65         #: css_files; a list of tuple of filename and attributes
66         self.css_files: List[Tuple[str, Dict[str, Any]]] = []
67 
68         #: domains; a dict of domain name -> domain class
69         self.domains: Dict[str, Type[Domain]] = {}
70 
71         #: additional directives for domains
72         #: a dict of domain name -> dict of directive name -> directive
73         self.domain_directives: Dict[str, Dict[str, Any]] = {}
74 
75         #: additional indices for domains
76         #: a dict of domain name -> list of index class
77         self.domain_indices: Dict[str, List[Type[Index]]] = {}
78 
79         #: additional object types for domains
80         #: a dict of domain name -> dict of objtype name -> objtype
81         self.domain_object_types: Dict[str, Dict[str, ObjType]] = {}
82 
83         #: additional roles for domains
84         #: a dict of domain name -> dict of role name -> role impl.
85         self.domain_roles: Dict[str, Dict[str, Union[RoleFunction, XRefRole]]] = {}
86 
87         #: additional enumerable nodes
88         #: a dict of node class -> tuple of figtype and title_getter function
89         self.enumerable_nodes: Dict[Type[Node], Tuple[str, TitleGetter]] = {}
90 
91         #: HTML inline and block math renderers
92         #: a dict of name -> tuple of visit function and depart function
93         self.html_inline_math_renderers: Dict[str, Tuple[Callable, Callable]] = {}
94         self.html_block_math_renderers: Dict[str, Tuple[Callable, Callable]] = {}
95 
96         #: HTML assets
97         self.html_assets_policy: str = 'per_page'
98 
99         #: HTML themes
100         self.html_themes: Dict[str, str] = {}
101 
102         #: js_files; list of JS paths or URLs
103         self.js_files: List[Tuple[str, Dict[str, Any]]] = []
104 
105         #: LaTeX packages; list of package names and its options
106         self.latex_packages: List[Tuple[str, str]] = []
107 
108         self.latex_packages_after_hyperref: List[Tuple[str, str]] = []
109 
110         #: post transforms; list of transforms
111         self.post_transforms: List[Type[Transform]] = []
112 
113         #: source paresrs; file type -> parser class
114         self.source_parsers: Dict[str, Type[Parser]] = {}
115 
116         #: source inputs; file type -> input class
117         self.source_inputs: Dict[str, Type[Input]] = {}
118 
119         #: source suffix: suffix -> file type
120         self.source_suffix: Dict[str, str] = {}
121 
122         #: custom translators; builder name -> translator class
123         self.translators: Dict[str, Type[nodes.NodeVisitor]] = {}
124 
125         #: custom handlers for translators
126         #: a dict of builder name -> dict of node name -> visitor and departure functions
127         self.translation_handlers: Dict[str, Dict[str, Tuple[Callable, Callable]]] = {}
128 
129         #: additional transforms; list of transforms
130         self.transforms: List[Type[Transform]] = []
131 
132     def add_builder(self, builder: Type[Builder], override: bool = False) -> None:
133         logger.debug('[app] adding builder: %r', builder)
134         if not hasattr(builder, 'name'):
135             raise ExtensionError(__('Builder class %s has no "name" attribute') % builder)
136         if builder.name in self.builders and not override:
137             raise ExtensionError(__('Builder %r already exists (in module %s)') %
138                                  (builder.name, self.builders[builder.name].__module__))
139         self.builders[builder.name] = builder
140 
141     def preload_builder(self, app: "Sphinx", name: str) -> None:
142         if name is None:
143             return
144 
145         if name not in self.builders:
146             entry_points = iter_entry_points('sphinx.builders', name)
147             try:
148                 entry_point = next(entry_points)
149             except StopIteration as exc:
150                 raise SphinxError(__('Builder name %s not registered or available'
151                                      ' through entry point') % name) from exc
152 
153             self.load_extension(app, entry_point.module_name)
154 
155     def create_builder(self, app: "Sphinx", name: str) -> Builder:
156         if name not in self.builders:
157             raise SphinxError(__('Builder name %s not registered') % name)
158 
159         return self.builders[name](app)
160 
161     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
162         logger.debug('[app] adding domain: %r', domain)
163         if domain.name in self.domains and not override:
164             raise ExtensionError(__('domain %s already registered') % domain.name)
165         self.domains[domain.name] = domain
166 
167     def has_domain(self, domain: str) -> bool:
168         return domain in self.domains
169 
170     def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:
171         for DomainClass in self.domains.values():
172             domain = DomainClass(env)
173 
174             # transplant components added by extensions
175             domain.directives.update(self.domain_directives.get(domain.name, {}))
176             domain.roles.update(self.domain_roles.get(domain.name, {}))
177             domain.indices.extend(self.domain_indices.get(domain.name, []))
178             for name, objtype in self.domain_object_types.get(domain.name, {}).items():
179                 domain.add_object_type(name, objtype)
180 
181             yield domain
182 
183     def add_directive_to_domain(self, domain: str, name: str,
184                                 cls: Type[Directive], override: bool = False) -> None:
185         logger.debug('[app] adding directive to domain: %r', (domain, name, cls))
186         if domain not in self.domains:
187             raise ExtensionError(__('domain %s not yet registered') % domain)
188 
189         directives = self.domain_directives.setdefault(domain, {})
190         if name in directives and not override:
191             raise ExtensionError(__('The %r directive is already registered to domain %s') %
192                                  (name, domain))
193         directives[name] = cls
194 
195     def add_role_to_domain(self, domain: str, name: str,
196                            role: Union[RoleFunction, XRefRole], override: bool = False
197                            ) -> None:
198         logger.debug('[app] adding role to domain: %r', (domain, name, role))
199         if domain not in self.domains:
200             raise ExtensionError(__('domain %s not yet registered') % domain)
201         roles = self.domain_roles.setdefault(domain, {})
202         if name in roles and not override:
203             raise ExtensionError(__('The %r role is already registered to domain %s') %
204                                  (name, domain))
205         roles[name] = role
206 
207     def add_index_to_domain(self, domain: str, index: Type[Index],
208                             override: bool = False) -> None:
209         logger.debug('[app] adding index to domain: %r', (domain, index))
210         if domain not in self.domains:
211             raise ExtensionError(__('domain %s not yet registered') % domain)
212         indices = self.domain_indices.setdefault(domain, [])
213         if index in indices and not override:
214             raise ExtensionError(__('The %r index is already registered to domain %s') %
215                                  (index.name, domain))
216         indices.append(index)
217 
218     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
219                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
220                         objname: str = '', doc_field_types: List = [], override: bool = False
221                         ) -> None:
222         logger.debug('[app] adding object type: %r',
223                      (directivename, rolename, indextemplate, parse_node,
224                       ref_nodeclass, objname, doc_field_types))
225 
226         # create a subclass of GenericObject as the new directive
227         directive = type(directivename,
228                          (GenericObject, object),
229                          {'indextemplate': indextemplate,
230                           'parse_node': staticmethod(parse_node),
231                           'doc_field_types': doc_field_types})
232 
233         self.add_directive_to_domain('std', directivename, directive)
234         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
235 
236         object_types = self.domain_object_types.setdefault('std', {})
237         if directivename in object_types and not override:
238             raise ExtensionError(__('The %r object_type is already registered') %
239                                  directivename)
240         object_types[directivename] = ObjType(objname or directivename, rolename)
241 
242     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
243                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
244                           override: bool = False) -> None:
245         logger.debug('[app] adding crossref type: %r',
246                      (directivename, rolename, indextemplate, ref_nodeclass, objname))
247 
248         # create a subclass of Target as the new directive
249         directive = type(directivename,
250                          (Target, object),
251                          {'indextemplate': indextemplate})
252 
253         self.add_directive_to_domain('std', directivename, directive)
254         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
255 
256         object_types = self.domain_object_types.setdefault('std', {})
257         if directivename in object_types and not override:
258             raise ExtensionError(__('The %r crossref_type is already registered') %
259                                  directivename)
260         object_types[directivename] = ObjType(objname or directivename, rolename)
261 
262     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
263         logger.debug('[app] adding source_suffix: %r, %r', suffix, filetype)
264         if suffix in self.source_suffix and not override:
265             raise ExtensionError(__('source_suffix %r is already registered') % suffix)
266         else:
267             self.source_suffix[suffix] = filetype
268 
269     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
270         logger.debug('[app] adding search source_parser: %r', parser)
271 
272         # create a map from filetype to parser
273         for filetype in parser.supported:
274             if filetype in self.source_parsers and not override:
275                 raise ExtensionError(__('source_parser for %r is already registered') %
276                                      filetype)
277             else:
278                 self.source_parsers[filetype] = parser
279 
280     def get_source_parser(self, filetype: str) -> Type[Parser]:
281         try:
282             return self.source_parsers[filetype]
283         except KeyError as exc:
284             raise SphinxError(__('Source parser for %s not registered') % filetype) from exc
285 
286     def get_source_parsers(self) -> Dict[str, Type[Parser]]:
287         return self.source_parsers
288 
289     def create_source_parser(self, app: "Sphinx", filename: str) -> Parser:
290         parser_class = self.get_source_parser(filename)
291         parser = parser_class()
292         if isinstance(parser, SphinxParser):
293             parser.set_application(app)
294         return parser
295 
296     def get_source_input(self, filetype: str) -> Optional[Type[Input]]:
297         warnings.warn('SphinxComponentRegistry.get_source_input() is deprecated.',
298                       RemovedInSphinx60Warning)
299 
300         try:
301             return self.source_inputs[filetype]
302         except KeyError:
303             try:
304                 # use special source_input for unknown filetype
305                 return self.source_inputs['*']
306             except KeyError:
307                 return None
308 
309     def add_translator(self, name: str, translator: Type[nodes.NodeVisitor],
310                        override: bool = False) -> None:
311         logger.debug('[app] Change of translator for the %s builder.', name)
312         if name in self.translators and not override:
313             raise ExtensionError(__('Translator for %r already exists') % name)
314         self.translators[name] = translator
315 
316     def add_translation_handlers(self, node: Type[Element],
317                                  **kwargs: Tuple[Callable, Callable]) -> None:
318         logger.debug('[app] adding translation_handlers: %r, %r', node, kwargs)
319         for builder_name, handlers in kwargs.items():
320             translation_handlers = self.translation_handlers.setdefault(builder_name, {})
321             try:
322                 visit, depart = handlers  # unpack once for assertion
323                 translation_handlers[node.__name__] = (visit, depart)
324             except ValueError as exc:
325                 raise ExtensionError(
326                     __('kwargs for add_node() must be a (visit, depart) '
327                        'function tuple: %r=%r') % (builder_name, handlers)
328                 ) from exc
329 
330     def get_translator_class(self, builder: Builder) -> Type[nodes.NodeVisitor]:
331         return self.translators.get(builder.name,
332                                     builder.default_translator_class)
333 
334     def create_translator(self, builder: Builder, *args: Any) -> nodes.NodeVisitor:
335         translator_class = self.get_translator_class(builder)
336         assert translator_class, "translator not found for %s" % builder.name
337         translator = translator_class(*args)
338 
339         # transplant handlers for custom nodes to translator instance
340         handlers = self.translation_handlers.get(builder.name, None)
341         if handlers is None:
342             # retry with builder.format
343             handlers = self.translation_handlers.get(builder.format, {})
344 
345         for name, (visit, depart) in handlers.items():
346             setattr(translator, 'visit_' + name, MethodType(visit, translator))
347             if depart:
348                 setattr(translator, 'depart_' + name, MethodType(depart, translator))
349 
350         return translator
351 
352     def add_transform(self, transform: Type[Transform]) -> None:
353         logger.debug('[app] adding transform: %r', transform)
354         self.transforms.append(transform)
355 
356     def get_transforms(self) -> List[Type[Transform]]:
357         return self.transforms
358 
359     def add_post_transform(self, transform: Type[Transform]) -> None:
360         logger.debug('[app] adding post transform: %r', transform)
361         self.post_transforms.append(transform)
362 
363     def get_post_transforms(self) -> List[Type[Transform]]:
364         return self.post_transforms
365 
366     def add_documenter(self, objtype: str, documenter: Type["Documenter"]) -> None:
367         self.documenters[objtype] = documenter
368 
369     def add_autodoc_attrgetter(self, typ: Type,
370                                attrgetter: Callable[[Any, str, Any], Any]) -> None:
371         self.autodoc_attrgettrs[typ] = attrgetter
372 
373     def add_css_files(self, filename: str, **attributes: Any) -> None:
374         self.css_files.append((filename, attributes))
375 
376     def add_js_file(self, filename: str, **attributes: Any) -> None:
377         logger.debug('[app] adding js_file: %r, %r', filename, attributes)
378         self.js_files.append((filename, attributes))
379 
380     def has_latex_package(self, name: str) -> bool:
381         packages = self.latex_packages + self.latex_packages_after_hyperref
382         return bool([x for x in packages if x[0] == name])
383 
384     def add_latex_package(self, name: str, options: str, after_hyperref: bool = False) -> None:
385         if self.has_latex_package(name):
386             logger.warn("latex package '%s' already included" % name)
387 
388         logger.debug('[app] adding latex package: %r', name)
389         if after_hyperref:
390             self.latex_packages_after_hyperref.append((name, options))
391         else:
392             self.latex_packages.append((name, options))
393 
394     def add_enumerable_node(self, node: Type[Node], figtype: str,
395                             title_getter: TitleGetter = None, override: bool = False) -> None:
396         logger.debug('[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter)
397         if node in self.enumerable_nodes and not override:
398             raise ExtensionError(__('enumerable_node %r already registered') % node)
399         self.enumerable_nodes[node] = (figtype, title_getter)
400 
401     def add_html_math_renderer(self, name: str,
402                                inline_renderers: Tuple[Callable, Callable],
403                                block_renderers: Tuple[Callable, Callable]) -> None:
404         logger.debug('[app] adding html_math_renderer: %s, %r, %r',
405                      name, inline_renderers, block_renderers)
406         if name in self.html_inline_math_renderers:
407             raise ExtensionError(__('math renderer %s is already registered') % name)
408 
409         self.html_inline_math_renderers[name] = inline_renderers
410         self.html_block_math_renderers[name] = block_renderers
411 
412     def add_html_theme(self, name: str, theme_path: str) -> None:
413         self.html_themes[name] = theme_path
414 
415     def load_extension(self, app: "Sphinx", extname: str) -> None:
416         """Load a Sphinx extension."""
417         if extname in app.extensions:  # already loaded
418             return
419         if extname in EXTENSION_BLACKLIST:
420             logger.warning(__('the extension %r was already merged with Sphinx since '
421                               'version %s; this extension is ignored.'),
422                            extname, EXTENSION_BLACKLIST[extname])
423             return
424 
425         # update loading context
426         prefix = __('while setting up extension %s:') % extname
427         with prefixed_warnings(prefix):
428             try:
429                 mod = import_module(extname)
430             except ImportError as err:
431                 logger.verbose(__('Original exception:\n') + traceback.format_exc())
432                 raise ExtensionError(__('Could not import extension %s') % extname,
433                                      err) from err
434 
435             setup = getattr(mod, 'setup', None)
436             if setup is None:
437                 logger.warning(__('extension %r has no setup() function; is it really '
438                                   'a Sphinx extension module?'), extname)
439                 metadata: Dict[str, Any] = {}
440             else:
441                 try:
442                     metadata = setup(app)
443                 except VersionRequirementError as err:
444                     # add the extension name to the version required
445                     raise VersionRequirementError(
446                         __('The %s extension used by this project needs at least '
447                            'Sphinx v%s; it therefore cannot be built with this '
448                            'version.') % (extname, err)
449                     ) from err
450 
451             if metadata is None:
452                 metadata = {}
453             elif not isinstance(metadata, dict):
454                 logger.warning(__('extension %r returned an unsupported object from '
455                                   'its setup() function; it should return None or a '
456                                   'metadata dictionary'), extname)
457                 metadata = {}
458 
459             app.extensions[extname] = Extension(extname, mod, **metadata)
460 
461     def get_envversion(self, app: "Sphinx") -> Dict[str, str]:
462         from sphinx.environment import ENV_VERSION
463         envversion = {ext.name: ext.metadata['env_version'] for ext in app.extensions.values()
464                       if ext.metadata.get('env_version')}
465         envversion['sphinx'] = ENV_VERSION
466         return envversion
467 
468 
469 def merge_source_suffix(app: "Sphinx", config: Config) -> None:
470     """Merge any user-specified source_suffix with any added by extensions."""
471     for suffix, filetype in app.registry.source_suffix.items():
472         if suffix not in app.config.source_suffix:
473             app.config.source_suffix[suffix] = filetype
474         elif app.config.source_suffix[suffix] is None:
475             # filetype is not specified (default filetype).
476             # So it overrides default filetype by extensions setting.
477             app.config.source_suffix[suffix] = filetype
478 
479     # copy config.source_suffix to registry
480     app.registry.source_suffix = app.config.source_suffix
481 
482 
483 def setup(app: "Sphinx") -> Dict[str, Any]:
484     app.connect('config-inited', merge_source_suffix, priority=800)
485 
486     return {
487         'version': 'builtin',
488         'parallel_read_safe': True,
489         'parallel_write_safe': True,
490     }

</code><intended_behavior>When registering or validating extension versions, employ a consistent, accurate method for semantic version parsing and comparison. This ensures extensions with correct version numbers are accepted, addressing the comparison issue ("0.6" vs. "0.10").</intended_behavior>]
2025-10-17 19:23:46.315 | INFO     | Search completed. Bug locations: [<file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import IO, TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Type, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers import Parser
26 from docutils.parsers.rst import Directive, roles
27 from docutils.transforms import Transform
28 from pygments.lexer import Lexer
29 
30 import sphinx
31 from sphinx import locale, package_dir
32 from sphinx.config import Config
33 from sphinx.deprecation import RemovedInSphinx60Warning
34 from sphinx.domains import Domain, Index
35 from sphinx.environment import BuildEnvironment
36 from sphinx.environment.collectors import EnvironmentCollector
37 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
38 from sphinx.events import EventManager
39 from sphinx.extension import Extension
40 from sphinx.highlighting import lexer_classes
41 from sphinx.locale import __
42 from sphinx.project import Project
43 from sphinx.registry import SphinxComponentRegistry
44 from sphinx.roles import XRefRole
45 from sphinx.theming import Theme
46 from sphinx.util import docutils, logging, progress_message
47 from sphinx.util.build_phase import BuildPhase
48 from sphinx.util.console import bold  # type: ignore
49 from sphinx.util.i18n import CatalogRepository
50 from sphinx.util.logging import prefixed_warnings
51 from sphinx.util.osutil import abspath, ensuredir, relpath
52 from sphinx.util.tags import Tags
53 from sphinx.util.typing import RoleFunction, TitleGetter
54 
55 if TYPE_CHECKING:
56     from docutils.nodes import Node  # NOQA
57 
58     from sphinx.builders import Builder
59 
60 
61 builtin_extensions = (
62     'sphinx.addnodes',
63     'sphinx.builders.changes',
64     'sphinx.builders.epub3',
65     'sphinx.builders.dirhtml',
66     'sphinx.builders.dummy',
67     'sphinx.builders.gettext',
68     'sphinx.builders.html',
69     'sphinx.builders.latex',
70     'sphinx.builders.linkcheck',
71     'sphinx.builders.manpage',
72     'sphinx.builders.singlehtml',
73     'sphinx.builders.texinfo',
74     'sphinx.builders.text',
75     'sphinx.builders.xml',
76     'sphinx.config',
77     'sphinx.domains.c',
78     'sphinx.domains.changeset',
79     'sphinx.domains.citation',
80     'sphinx.domains.cpp',
81     'sphinx.domains.index',
82     'sphinx.domains.javascript',
83     'sphinx.domains.math',
84     'sphinx.domains.python',
85     'sphinx.domains.rst',
86     'sphinx.domains.std',
87     'sphinx.directives',
88     'sphinx.directives.code',
89     'sphinx.directives.other',
90     'sphinx.directives.patches',
91     'sphinx.extension',
92     'sphinx.parsers',
93     'sphinx.registry',
94     'sphinx.roles',
95     'sphinx.transforms',
96     'sphinx.transforms.compact_bullet_list',
97     'sphinx.transforms.i18n',
98     'sphinx.transforms.references',
99     'sphinx.transforms.post_transforms',
100     'sphinx.transforms.post_transforms.code',
101     'sphinx.transforms.post_transforms.images',
102     'sphinx.util.compat',
103     'sphinx.versioning',
104     # collectors should be loaded by specific order
105     'sphinx.environment.collectors.dependencies',
106     'sphinx.environment.collectors.asset',
107     'sphinx.environment.collectors.metadata',
108     'sphinx.environment.collectors.title',
109     'sphinx.environment.collectors.toctree',
110     # 1st party extensions
111     'sphinxcontrib.applehelp',
112     'sphinxcontrib.devhelp',
113     'sphinxcontrib.htmlhelp',
114     'sphinxcontrib.serializinghtml',
115     'sphinxcontrib.qthelp',
116     # Strictly, alabaster theme is not a builtin extension,
117     # but it is loaded automatically to use it as default theme.
118     'alabaster',
119 )
120 
121 ENV_PICKLE_FILENAME = 'environment.pickle'
122 
123 logger = logging.getLogger(__name__)
124 
125 
126 class Sphinx:
127     """The main application class and extensibility interface.
128 
129     :ivar srcdir: Directory containing source.
130     :ivar confdir: Directory containing ``conf.py``.
131     :ivar doctreedir: Directory for storing pickled doctrees.
132     :ivar outdir: Directory for storing build documents.
133     """
134 
135     warningiserror: bool
136     _warncount: int
137 
138     def __init__(self, srcdir: str, confdir: Optional[str], outdir: str, doctreedir: str,
139                  buildername: str, confoverrides: Dict = None,
140                  status: IO = sys.stdout, warning: IO = sys.stderr,
141                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
142                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
143         self.phase = BuildPhase.INITIALIZATION
144         self.verbosity = verbosity
145         self.extensions: Dict[str, Extension] = {}
146         self.builder: Optional[Builder] = None
147         self.env: Optional[BuildEnvironment] = None
148         self.project: Optional[Project] = None
149         self.registry = SphinxComponentRegistry()
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155 
156         if not path.isdir(self.srcdir):
157             raise ApplicationError(__('Cannot find source directory (%s)') %
158                                    self.srcdir)
159 
160         if path.exists(self.outdir) and not path.isdir(self.outdir):
161             raise ApplicationError(__('Output directory (%s) is not a directory') %
162                                    self.outdir)
163 
164         if self.srcdir == self.outdir:
165             raise ApplicationError(__('Source directory and destination '
166                                       'directory cannot be identical'))
167 
168         self.parallel = parallel
169 
170         if status is None:
171             self._status: IO = StringIO()
172             self.quiet: bool = True
173         else:
174             self._status = status
175             self.quiet = False
176 
177         if warning is None:
178             self._warning: IO = StringIO()
179         else:
180             self._warning = warning
181         self._warncount = 0
182         self.keep_going = warningiserror and keep_going
183         if self.keep_going:
184             self.warningiserror = False
185         else:
186             self.warningiserror = warningiserror
187         logging.setup(self, self._status, self._warning)
188 
189         self.events = EventManager(self)
190 
191         # keep last few messages for traceback
192         # This will be filled by sphinx.util.logging.LastMessagesWriter
193         self.messagelog: deque = deque(maxlen=10)
194 
195         # say hello to the world
196         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
197 
198         # notice for parallel build on macOS and py38+
199         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
200             logger.info(bold(__("For security reasons, parallel mode is disabled on macOS and "
201                                 "python3.8 and above. For more details, please read "
202                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
203 
204         # status code for command-line application
205         self.statuscode = 0
206 
207         # read config
208         self.tags = Tags(tags)
209         if confdir is None:
210             # set confdir to srcdir if -C given (!= no confdir); a few pieces
211             # of code expect a confdir to be set
212             self.confdir = self.srcdir
213             self.config = Config({}, confoverrides or {})
214         else:
215             self.confdir = abspath(confdir)
216             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
217 
218         # initialize some limited config variables before initialize i18n and loading
219         # extensions
220         self.config.pre_init_values()
221 
222         # set up translation infrastructure
223         self._init_i18n()
224 
225         # check the Sphinx version if requested
226         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
227             raise VersionRequirementError(
228                 __('This project needs at least Sphinx v%s and therefore cannot '
229                    'be built with this version.') % self.config.needs_sphinx)
230 
231         # load all built-in extension modules
232         for extension in builtin_extensions:
233             self.setup_extension(extension)
234 
235         # load all user-given extension modules
236         for extension in self.config.extensions:
237             self.setup_extension(extension)
238 
239         # preload builder module (before init config values)
240         self.preload_builder(buildername)
241 
242         if not path.isdir(outdir):
243             with progress_message(__('making output directory')):
244                 ensuredir(outdir)
245 
246         # the config file itself can be an extension
247         if self.config.setup:
248             prefix = __('while setting up extension %s:') % "conf.py"
249             with prefixed_warnings(prefix):
250                 if callable(self.config.setup):
251                     self.config.setup(self)
252                 else:
253                     raise ConfigError(
254                         __("'setup' as currently defined in conf.py isn't a Python callable. "
255                            "Please modify its definition to make it a callable function. "
256                            "This is needed for conf.py to behave as a Sphinx extension.")
257                     )
258 
259         # now that we know all config values, collect them from conf.py
260         self.config.init_values()
261         self.events.emit('config-inited', self.config)
262 
263         # create the project
264         self.project = Project(self.srcdir, self.config.source_suffix)
265         # create the builder
266         self.builder = self.create_builder(buildername)
267         # set up the build environment
268         self._init_env(freshenv)
269         # set up the builder
270         self._init_builder()
271 
272     def _init_i18n(self) -> None:
273         """Load translated strings from the configured localedirs if enabled in
274         the configuration.
275         """
276         if self.config.language is None:
277             self.translator, has_translation = locale.init([], None)
278         else:
279             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
280                         nonl=True)
281 
282             # compile mo files if sphinx.po file in user locale directories are updated
283             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
284                                      self.config.language, self.config.source_encoding)
285             for catalog in repo.catalogs:
286                 if catalog.domain == 'sphinx' and catalog.is_outdated():
287                     catalog.write_mo(self.config.language)
288 
289             locale_dirs: List[Optional[str]] = list(repo.locale_dirs)
290             locale_dirs += [None]
291             locale_dirs += [path.join(package_dir, 'locale')]
292 
293             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
294             if has_translation or self.config.language == 'en':
295                 # "en" never needs to be translated
296                 logger.info(__('done'))
297             else:
298                 logger.info(__('not available for built-in messages'))
299 
300     def _init_env(self, freshenv: bool) -> None:
301         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
302         if freshenv or not os.path.exists(filename):
303             self.env = BuildEnvironment(self)
304             self.env.find_files(self.config, self.builder)
305         else:
306             try:
307                 with progress_message(__('loading pickled environment')):
308                     with open(filename, 'rb') as f:
309                         self.env = pickle.load(f)
310                         self.env.setup(self)
311             except Exception as err:
312                 logger.info(__('failed: %s'), err)
313                 self._init_env(freshenv=True)
314 
315     def preload_builder(self, name: str) -> None:
316         self.registry.preload_builder(self, name)
317 
318     def create_builder(self, name: str) -> "Builder":
319         if name is None:
320             logger.info(__('No builder selected, using default: html'))
321             name = 'html'
322 
323         return self.registry.create_builder(self, name)
324 
325     def _init_builder(self) -> None:
326         self.builder.set_environment(self.env)
327         self.builder.init()
328         self.events.emit('builder-inited')
329 
330     # ---- main "build" method -------------------------------------------------
331 
332     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
333         self.phase = BuildPhase.READING
334         try:
335             if force_all:
336                 self.builder.compile_all_catalogs()
337                 self.builder.build_all()
338             elif filenames:
339                 self.builder.compile_specific_catalogs(filenames)
340                 self.builder.build_specific(filenames)
341             else:
342                 self.builder.compile_update_catalogs()
343                 self.builder.build_update()
344 
345             if self._warncount and self.keep_going:
346                 self.statuscode = 1
347 
348             status = (__('succeeded') if self.statuscode == 0
349                       else __('finished with problems'))
350             if self._warncount:
351                 if self.warningiserror:
352                     if self._warncount == 1:
353                         msg = __('build %s, %s warning (with warnings treated as errors).')
354                     else:
355                         msg = __('build %s, %s warnings (with warnings treated as errors).')
356                 else:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning.')
359                     else:
360                         msg = __('build %s, %s warnings.')
361 
362                 logger.info(bold(msg % (status, self._warncount)))
363             else:
364                 logger.info(bold(__('build %s.') % status))
365 
366             if self.statuscode == 0 and self.builder.epilog:
367                 logger.info('')
368                 logger.info(self.builder.epilog % {
369                     'outdir': relpath(self.outdir),
370                     'project': self.config.project
371                 })
372         except Exception as err:
373             # delete the saved env to force a fresh build next time
374             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
375             if path.isfile(envfile):
376                 os.unlink(envfile)
377             self.events.emit('build-finished', err)
378             raise
379         else:
380             self.events.emit('build-finished', None)
381         self.builder.cleanup()
382 
383     # ---- general extensibility interface -------------------------------------
384 
385     def setup_extension(self, extname: str) -> None:
386         """Import and setup a Sphinx extension module.
387 
388         Load the extension given by the module *name*.  Use this if your
389         extension needs the features provided by another extension.  No-op if
390         called twice.
391         """
392         logger.debug('[app] setting up extension: %r', extname)
393         self.registry.load_extension(self, extname)
394 
395     def require_sphinx(self, version: str) -> None:
396         """Check the Sphinx version if requested.
397 
398         Compare *version* with the version of the running Sphinx, and abort the
399         build when it is too old.
400 
401         :param version: The required version in the form of ``major.minor``.
402 
403         .. versionadded:: 1.0
404         """
405         if version > sphinx.__display_version__[:3]:
406             raise VersionRequirementError(version)
407 
408     # event interface
409     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
410         """Register *callback* to be called when *event* is emitted.
411 
412         For details on available core events and the arguments of callback
413         functions, please see :ref:`events`.
414 
415         :param event: The name of target event
416         :param callback: Callback function for the event
417         :param priority: The priority of the callback.  The callbacks will be invoked
418                          in order of *priority* (ascending).
419         :return: A listener ID.  It can be used for :meth:`disconnect`.
420 
421         .. versionchanged:: 3.0
422 
423            Support *priority*
424         """
425         listener_id = self.events.connect(event, callback, priority)
426         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
427                      event, priority, callback, listener_id)
428         return listener_id
429 
430     def disconnect(self, listener_id: int) -> None:
431         """Unregister callback by *listener_id*.
432 
433         :param listener_id: A listener_id that :meth:`connect` returns
434         """
435         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
436         self.events.disconnect(listener_id)
437 
438     def emit(self, event: str, *args: Any,
439              allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> List:
440         """Emit *event* and pass *arguments* to the callback functions.
441 
442         Return the return values of all callbacks as a list.  Do not emit core
443         Sphinx events in extensions!
444 
445         :param event: The name of event that will be emitted
446         :param args: The arguments for the event
447         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
448 
449         .. versionchanged:: 3.1
450 
451            Added *allowed_exceptions* to specify path-through exceptions
452         """
453         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
454 
455     def emit_firstresult(self, event: str, *args: Any,
456                          allowed_exceptions: Tuple[Type[Exception], ...] = ()) -> Any:
457         """Emit *event* and pass *arguments* to the callback functions.
458 
459         Return the result of the first callback that doesn't return ``None``.
460 
461         :param event: The name of event that will be emitted
462         :param args: The arguments for the event
463         :param allowed_exceptions: The list of exceptions that are allowed in the callbacks
464 
465         .. versionadded:: 0.5
466         .. versionchanged:: 3.1
467 
468            Added *allowed_exceptions* to specify path-through exceptions
469         """
470         return self.events.emit_firstresult(event, *args,
471                                             allowed_exceptions=allowed_exceptions)
472 
473     # registering addon parts
474 
475     def add_builder(self, builder: Type["Builder"], override: bool = False) -> None:
476         """Register a new builder.
477 
478         :param builder: A builder class
479         :param override: If true, install the builder forcedly even if another builder
480                          is already installed as the same name
481 
482         .. versionchanged:: 1.8
483            Add *override* keyword.
484         """
485         self.registry.add_builder(builder, override=override)
486 
487     # TODO(stephenfin): Describe 'types' parameter
488     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
489                          types: Any = ()) -> None:
490         """Register a configuration value.
491 
492         This is necessary for Sphinx to recognize new values and set default
493         values accordingly.
494 
495 
496         :param name: The name of the configuration value.  It is recommended to be prefixed
497                      with the extension name (ex. ``html_logo``, ``epub_title``)
498         :param default: The default value of the configuration.
499         :param rebuild: The condition of rebuild.  It must be one of those values:
500 
501                         * ``'env'`` if a change in the setting only takes effect when a
502                           document is parsed -- this means that the whole environment must be
503                           rebuilt.
504                         * ``'html'`` if a change in the setting needs a full rebuild of HTML
505                           documents.
506                         * ``''`` if a change in the setting will not need any special rebuild.
507         :param types: The type of configuration value.  A list of types can be specified.  For
508                       example, ``[str]`` is used to describe a configuration that takes string
509                       value.
510 
511         .. versionchanged:: 0.4
512            If the *default* value is a callable, it will be called with the
513            config object as its argument in order to get the default value.
514            This can be used to implement config values whose default depends on
515            other values.
516 
517         .. versionchanged:: 0.6
518            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
519            ``'env'``) to a string.  However, booleans are still accepted and
520            converted internally.
521         """
522         logger.debug('[app] adding config value: %r', (name, default, rebuild, types))
523         if rebuild in (False, True):
524             rebuild = 'env' if rebuild else ''
525         self.config.add(name, default, rebuild, types)
526 
527     def add_event(self, name: str) -> None:
528         """Register an event called *name*.
529 
530         This is needed to be able to emit it.
531 
532         :param name: The name of the event
533         """
534         logger.debug('[app] adding event: %r', name)
535         self.events.add(name)
536 
537     def set_translator(self, name: str, translator_class: Type[nodes.NodeVisitor],
538                        override: bool = False) -> None:
539         """Register or override a Docutils translator class.
540 
541         This is used to register a custom output translator or to replace a
542         builtin translator.  This allows extensions to use a custom translator
543         and define custom nodes for the translator (see :meth:`add_node`).
544 
545         :param name: The name of the builder for the translator
546         :param translator_class: A translator class
547         :param override: If true, install the translator forcedly even if another translator
548                          is already installed as the same name
549 
550         .. versionadded:: 1.3
551         .. versionchanged:: 1.8
552            Add *override* keyword.
553         """
554         self.registry.add_translator(name, translator_class, override=override)
555 
556     def add_node(self, node: Type[Element], override: bool = False,
557                  **kwargs: Tuple[Callable, Optional[Callable]]) -> None:
558         """Register a Docutils node class.
559 
560         This is necessary for Docutils internals.  It may also be used in the
561         future to validate nodes in the parsed documents.
562 
563         :param node: A node class
564         :param kwargs: Visitor functions for each builder (see below)
565         :param override: If true, install the node forcedly even if another node is already
566                          installed as the same name
567 
568         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
569         writers can be given as keyword arguments: the keyword should be one or
570         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
571         or any other supported translators, the value a 2-tuple of ``(visit,
572         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
573         function raises :exc:`docutils.nodes.SkipNode`.  Example:
574 
575         .. code-block:: python
576 
577            class math(docutils.nodes.Element): pass
578 
579            def visit_math_html(self, node):
580                self.body.append(self.starttag(node, 'math'))
581            def depart_math_html(self, node):
582                self.body.append('</math>')
583 
584            app.add_node(math, html=(visit_math_html, depart_math_html))
585 
586         Obviously, translators for which you don't specify visitor methods will
587         choke on the node when encountered in a document to translate.
588 
589         .. versionchanged:: 0.5
590            Added the support for keyword arguments giving visit functions.
591         """
592         logger.debug('[app] adding node: %r', (node, kwargs))
593         if not override and docutils.is_node_registered(node):
594             logger.warning(__('node class %r is already registered, '
595                               'its visitors will be overridden'),
596                            node.__name__, type='app', subtype='add_node')
597         docutils.register_node(node)
598         self.registry.add_translation_handlers(node, **kwargs)
599 
600     def add_enumerable_node(self, node: Type[Element], figtype: str,
601                             title_getter: TitleGetter = None, override: bool = False,
602                             **kwargs: Tuple[Callable, Callable]) -> None:
603         """Register a Docutils node class as a numfig target.
604 
605         Sphinx numbers the node automatically. And then the users can refer it
606         using :rst:role:`numref`.
607 
608         :param node: A node class
609         :param figtype: The type of enumerable nodes.  Each figtype has individual numbering
610                         sequences.  As system figtypes, ``figure``, ``table`` and
611                         ``code-block`` are defined.  It is possible to add custom nodes to
612                         these default figtypes.  It is also possible to define new custom
613                         figtype if a new figtype is given.
614         :param title_getter: A getter function to obtain the title of node.  It takes an
615                              instance of the enumerable node, and it must return its title as
616                              string.  The title is used to the default title of references for
617                              :rst:role:`ref`.  By default, Sphinx searches
618                              ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the
619                              node as a title.
620         :param kwargs: Visitor functions for each builder (same as :meth:`add_node`)
621         :param override: If true, install the node forcedly even if another node is already
622                          installed as the same name
623 
624         .. versionadded:: 1.4
625         """
626         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
627         self.add_node(node, override=override, **kwargs)
628 
629     def add_directive(self, name: str, cls: Type[Directive], override: bool = False) -> None:
630         """Register a Docutils directive.
631 
632         :param name: The name of the directive
633         :param cls: A directive class
634         :param override: If true, install the directive forcedly even if another directive
635                          is already installed as the same name
636 
637         For example, a custom directive named ``my-directive`` would be added
638         like this:
639 
640         .. code-block:: python
641 
642            from docutils.parsers.rst import Directive, directives
643 
644            class MyDirective(Directive):
645                has_content = True
646                required_arguments = 1
647                optional_arguments = 0
648                final_argument_whitespace = True
649                option_spec = {
650                    'class': directives.class_option,
651                    'name': directives.unchanged,
652                }
653 
654                def run(self):
655                    ...
656 
657            def setup(app):
658                app.add_directive('my-directive', MyDirective)
659 
660         For more details, see `the Docutils docs
661         <https://docutils.sourceforge.io/docs/howto/rst-directives.html>`__ .
662 
663         .. versionchanged:: 0.6
664            Docutils 0.5-style directive classes are now supported.
665         .. deprecated:: 1.8
666            Docutils 0.4-style (function based) directives support is deprecated.
667         .. versionchanged:: 1.8
668            Add *override* keyword.
669         """
670         logger.debug('[app] adding directive: %r', (name, cls))
671         if not override and docutils.is_directive_registered(name):
672             logger.warning(__('directive %r is already registered, it will be overridden'),
673                            name, type='app', subtype='add_directive')
674 
675         docutils.register_directive(name, cls)
676 
677     def add_role(self, name: str, role: Any, override: bool = False) -> None:
678         """Register a Docutils role.
679 
680         :param name: The name of role
681         :param role: A role function
682         :param override: If true, install the role forcedly even if another role is already
683                          installed as the same name
684 
685         For more details about role functions, see `the Docutils docs
686         <https://docutils.sourceforge.io/docs/howto/rst-roles.html>`__ .
687 
688         .. versionchanged:: 1.8
689            Add *override* keyword.
690         """
691         logger.debug('[app] adding role: %r', (name, role))
692         if not override and docutils.is_role_registered(name):
693             logger.warning(__('role %r is already registered, it will be overridden'),
694                            name, type='app', subtype='add_role')
695         docutils.register_role(name, role)
696 
697     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
698         """Register a generic Docutils role.
699 
700         Register a Docutils role that does nothing but wrap its contents in the
701         node given by *nodeclass*.
702 
703         If *override* is True, the given *nodeclass* is forcedly installed even if
704         a role named as *name* is already installed.
705 
706         .. versionadded:: 0.6
707         .. versionchanged:: 1.8
708            Add *override* keyword.
709         """
710         # Don't use ``roles.register_generic_role`` because it uses
711         # ``register_canonical_role``.
712         logger.debug('[app] adding generic role: %r', (name, nodeclass))
713         if not override and docutils.is_role_registered(name):
714             logger.warning(__('role %r is already registered, it will be overridden'),
715                            name, type='app', subtype='add_generic_role')
716         role = roles.GenericRole(name, nodeclass)
717         docutils.register_role(name, role)
718 
719     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
720         """Register a domain.
721 
722         :param domain: A domain class
723         :param override: If true, install the domain forcedly even if another domain
724                          is already installed as the same name
725 
726         .. versionadded:: 1.0
727         .. versionchanged:: 1.8
728            Add *override* keyword.
729         """
730         self.registry.add_domain(domain, override=override)
731 
732     def add_directive_to_domain(self, domain: str, name: str,
733                                 cls: Type[Directive], override: bool = False) -> None:
734         """Register a Docutils directive in a domain.
735 
736         Like :meth:`add_directive`, but the directive is added to the domain
737         named *domain*.
738 
739         :param domain: The name of target domain
740         :param name: A name of directive
741         :param cls: A directive class
742         :param override: If true, install the directive forcedly even if another directive
743                          is already installed as the same name
744 
745         .. versionadded:: 1.0
746         .. versionchanged:: 1.8
747            Add *override* keyword.
748         """
749         self.registry.add_directive_to_domain(domain, name, cls, override=override)
750 
751     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
752                            override: bool = False) -> None:
753         """Register a Docutils role in a domain.
754 
755         Like :meth:`add_role`, but the role is added to the domain named
756         *domain*.
757 
758         :param domain: The name of the target domain
759         :param name: The name of the role
760         :param role: The role function
761         :param override: If true, install the role forcedly even if another role is already
762                          installed as the same name
763 
764         .. versionadded:: 1.0
765         .. versionchanged:: 1.8
766            Add *override* keyword.
767         """
768         self.registry.add_role_to_domain(domain, name, role, override=override)
769 
770     def add_index_to_domain(self, domain: str, index: Type[Index], override: bool = False
771                             ) -> None:
772         """Register a custom index for a domain.
773 
774         Add a custom *index* class to the domain named *domain*.
775 
776         :param domain: The name of the target domain
777         :param index: The index class
778         :param override: If true, install the index forcedly even if another index is
779                          already installed as the same name
780 
781         .. versionadded:: 1.0
782         .. versionchanged:: 1.8
783            Add *override* keyword.
784         """
785         self.registry.add_index_to_domain(domain, index)
786 
787     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
788                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
789                         objname: str = '', doc_field_types: List = [], override: bool = False
790                         ) -> None:
791         """Register a new object type.
792 
793         This method is a very convenient way to add a new :term:`object` type
794         that can be cross-referenced.  It will do this:
795 
796         - Create a new directive (called *directivename*) for documenting an
797           object.  It will automatically add index entries if *indextemplate*
798           is nonempty; if given, it must contain exactly one instance of
799           ``%s``.  See the example below for how the template will be
800           interpreted.
801         - Create a new role (called *rolename*) to cross-reference to these
802           object descriptions.
803         - If you provide *parse_node*, it must be a function that takes a
804           string and a docutils node, and it must populate the node with
805           children parsed from the string.  It must then return the name of the
806           item to be used in cross-referencing and index entries.  See the
807           :file:`conf.py` file in the source for this documentation for an
808           example.
809         - The *objname* (if not given, will default to *directivename*) names
810           the type of object.  It is used when listing objects, e.g. in search
811           results.
812 
813         For example, if you have this call in a custom Sphinx extension::
814 
815            app.add_object_type('directive', 'dir', 'pair: %s; directive')
816 
817         you can use this markup in your documents::
818 
819            .. rst:directive:: function
820 
821               Document a function.
822 
823            <...>
824 
825            See also the :rst:dir:`function` directive.
826 
827         For the directive, an index entry will be generated as if you had prepended ::
828 
829            .. index:: pair: function; directive
830 
831         The reference node will be of class ``literal`` (so it will be rendered
832         in a proportional font, as appropriate for code) unless you give the
833         *ref_nodeclass* argument, which must be a docutils node class.  Most
834         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
835         you can also use ``docutils.nodes.generated`` if you want no further
836         text decoration.  If the text should be treated as literal (e.g. no
837         smart quote replacement), but not have typewriter styling, use
838         ``sphinx.addnodes.literal_emphasis`` or
839         ``sphinx.addnodes.literal_strong``.
840 
841         For the role content, you have the same syntactical possibilities as
842         for standard Sphinx roles (see :ref:`xref-syntax`).
843 
844         If *override* is True, the given object_type is forcedly installed even if
845         an object_type having the same name is already installed.
846 
847         .. versionchanged:: 1.8
848            Add *override* keyword.
849         """
850         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
851                                       ref_nodeclass, objname, doc_field_types,
852                                       override=override)
853 
854     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
855                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
856                           override: bool = False) -> None:
857         """Register a new crossref object type.
858 
859         This method is very similar to :meth:`add_object_type` except that the
860         directive it generates must be empty, and will produce no output.
861 
862         That means that you can add semantic targets to your sources, and refer
863         to them using custom roles instead of generic ones (like
864         :rst:role:`ref`).  Example call::
865 
866            app.add_crossref_type('topic', 'topic', 'single: %s',
867                                  docutils.nodes.emphasis)
868 
869         Example usage::
870 
871            .. topic:: application API
872 
873            The application API
874            -------------------
875 
876            Some random text here.
877 
878            See also :topic:`this section <application API>`.
879 
880         (Of course, the element following the ``topic`` directive needn't be a
881         section.)
882 
883         If *override* is True, the given crossref_type is forcedly installed even if
884         a crossref_type having the same name is already installed.
885 
886         .. versionchanged:: 1.8
887            Add *override* keyword.
888         """
889         self.registry.add_crossref_type(directivename, rolename,
890                                         indextemplate, ref_nodeclass, objname,
891                                         override=override)
892 
893     def add_transform(self, transform: Type[Transform]) -> None:
894         """Register a Docutils transform to be applied after parsing.
895 
896         Add the standard docutils :class:`Transform` subclass *transform* to
897         the list of transforms that are applied after Sphinx parses a reST
898         document.
899 
900         :param transform: A transform class
901 
902         .. list-table:: priority range categories for Sphinx transforms
903            :widths: 20,80
904 
905            * - Priority
906              - Main purpose in Sphinx
907            * - 0-99
908              - Fix invalid nodes by docutils. Translate a doctree.
909            * - 100-299
910              - Preparation
911            * - 300-399
912              - early
913            * - 400-699
914              - main
915            * - 700-799
916              - Post processing. Deadline to modify text and referencing.
917            * - 800-899
918              - Collect referencing and referenced nodes. Domain processing.
919            * - 900-999
920              - Finalize and clean up.
921 
922         refs: `Transform Priority Range Categories`__
923 
924         __ https://docutils.sourceforge.io/docs/ref/transforms.html#transform-priority-range-categories
925         """  # NOQA
926         self.registry.add_transform(transform)
927 
928     def add_post_transform(self, transform: Type[Transform]) -> None:
929         """Register a Docutils transform to be applied before writing.
930 
931         Add the standard docutils :class:`Transform` subclass *transform* to
932         the list of transforms that are applied before Sphinx writes a
933         document.
934 
935         :param transform: A transform class
936         """
937         self.registry.add_post_transform(transform)
938 
939     def add_js_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
940         """Register a JavaScript file to include in the HTML output.
941 
942         Add *filename* to the list of JavaScript files that the default HTML
943         template will include in order of *priority* (ascending).  The filename
944         must be relative to the HTML static path , or a full URI with scheme.
945         If the priority of the JavaScript file is the same as others, the JavaScript
946         files will be included in order of registration.  If the keyword
947         argument ``body`` is given, its value will be added between the
948         ``<script>`` tags. Extra keyword arguments are included as attributes of
949         the ``<script>`` tag.
950 
951         Example::
952 
953             app.add_js_file('example.js')
954             # => <script src="_static/example.js"></script>
955 
956             app.add_js_file('example.js', async="async")
957             # => <script src="_static/example.js" async="async"></script>
958 
959             app.add_js_file(None, body="var myVariable = 'foo';")
960             # => <script>var myVariable = 'foo';</script>
961 
962         .. list-table:: priority range for JavaScript files
963            :widths: 20,80
964 
965            * - Priority
966              - Main purpose in Sphinx
967            * - 200
968              - default priority for built-in JavaScript files
969            * - 500
970              - default priority for extensions
971            * - 800
972              - default priority for :confval:`html_js_files`
973 
974         A JavaScript file can be added to the specific HTML page when an extension
975         calls this method on :event:`html-page-context` event.
976 
977         .. versionadded:: 0.5
978 
979         .. versionchanged:: 1.8
980            Renamed from ``app.add_javascript()``.
981            And it allows keyword arguments as attributes of script tag.
982 
983         .. versionchanged:: 3.5
984            Take priority argument.  Allow to add a JavaScript file to the specific page.
985         """
986         self.registry.add_js_file(filename, priority=priority, **kwargs)
987         if hasattr(self.builder, 'add_js_file'):
988             self.builder.add_js_file(filename, priority=priority, **kwargs)  # type: ignore
989 
990     def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -> None:
991         """Register a stylesheet to include in the HTML output.
992 
993         Add *filename* to the list of CSS files that the default HTML template
994         will include in order of *priority* (ascending).  The filename must be
995         relative to the HTML static path, or a full URI with scheme.  If the
996         priority of the CSS file is the same as others, the CSS files will be
997         included in order of registration.  The keyword arguments are also
998         accepted for attributes of ``<link>`` tag.
999 
1000         Example::
1001 
1002             app.add_css_file('custom.css')
1003             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
1004 
1005             app.add_css_file('print.css', media='print')
1006             # => <link rel="stylesheet" href="_static/print.css"
1007             #          type="text/css" media="print" />
1008 
1009             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
1010             # => <link rel="alternate stylesheet" href="_static/fancy.css"
1011             #          type="text/css" title="fancy" />
1012 
1013         .. list-table:: priority range for CSS files
1014            :widths: 20,80
1015 
1016            * - Priority
1017              - Main purpose in Sphinx
1018            * - 200
1019              - default priority for built-in CSS files
1020            * - 500
1021              - default priority for extensions
1022            * - 800
1023              - default priority for :confval:`html_css_files`
1024 
1025         A CSS file can be added to the specific HTML page when an extension calls
1026         this method on :event:`html-page-context` event.
1027 
1028         .. versionadded:: 1.0
1029 
1030         .. versionchanged:: 1.6
1031            Optional ``alternate`` and/or ``title`` attributes can be supplied
1032            with the arguments *alternate* (a Boolean) and *title* (a string).
1033            The default is no title and *alternate* = ``False``. For
1034            more information, refer to the `documentation
1035            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
1036 
1037         .. versionchanged:: 1.8
1038            Renamed from ``app.add_stylesheet()``.
1039            And it allows keyword arguments as attributes of link tag.
1040 
1041         .. versionchanged:: 3.5
1042            Take priority argument.  Allow to add a CSS file to the specific page.
1043         """
1044         logger.debug('[app] adding stylesheet: %r', filename)
1045         self.registry.add_css_files(filename, priority=priority, **kwargs)
1046         if hasattr(self.builder, 'add_css_file'):
1047             self.builder.add_css_file(filename, priority=priority, **kwargs)  # type: ignore
1048 
1049     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
1050                        ) -> None:
1051         """An alias of :meth:`add_css_file`.
1052 
1053         .. deprecated:: 1.8
1054         """
1055         logger.warning('The app.add_stylesheet() is deprecated. '
1056                        'Please use app.add_css_file() instead.')
1057 
1058         attributes = {}  # type: Dict[str, Any]
1059         if alternate:
1060             attributes['rel'] = 'alternate stylesheet'
1061         else:
1062             attributes['rel'] = 'stylesheet'
1063 
1064         if title:
1065             attributes['title'] = title
1066 
1067         self.add_css_file(filename, **attributes)
1068 
1069     def add_latex_package(self, packagename: str, options: str = None,
1070                           after_hyperref: bool = False) -> None:
1071         r"""Register a package to include in the LaTeX source code.
1072 
1073         Add *packagename* to the list of packages that LaTeX source code will
1074         include.  If you provide *options*, it will be taken to the `\usepackage`
1075         declaration.  If you set *after_hyperref* truthy, the package will be
1076         loaded after ``hyperref`` package.
1077 
1078         .. code-block:: python
1079 
1080            app.add_latex_package('mypackage')
1081            # => \usepackage{mypackage}
1082            app.add_latex_package('mypackage', 'foo,bar')
1083            # => \usepackage[foo,bar]{mypackage}
1084 
1085         .. versionadded:: 1.3
1086         .. versionadded:: 3.1
1087 
1088            *after_hyperref* option.
1089         """
1090         self.registry.add_latex_package(packagename, options, after_hyperref)
1091 
1092     def add_lexer(self, alias: str, lexer: Type[Lexer]) -> None:
1093         """Register a new lexer for source code.
1094 
1095         Use *lexer* to highlight code blocks with the given language *alias*.
1096 
1097         .. versionadded:: 0.6
1098         .. versionchanged:: 2.1
1099            Take a lexer class as an argument.  An instance of lexers are
1100            still supported until Sphinx-3.x.
1101         """
1102         logger.debug('[app] adding lexer: %r', (alias, lexer))
1103         lexer_classes[alias] = lexer
1104 
1105     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1106         """Register a new documenter class for the autodoc extension.
1107 
1108         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1109         extension.  It must be a subclass of
1110         :class:`sphinx.ext.autodoc.Documenter`.  This allows auto-documenting
1111         new types of objects.  See the source of the autodoc module for
1112         examples on how to subclass :class:`Documenter`.
1113 
1114         If *override* is True, the given *cls* is forcedly installed even if
1115         a documenter having the same name is already installed.
1116 
1117         See :ref:`autodoc_ext_tutorial`.
1118 
1119         .. versionadded:: 0.6
1120         .. versionchanged:: 2.2
1121            Add *override* keyword.
1122         """
1123         logger.debug('[app] adding autodocumenter: %r', cls)
1124         from sphinx.ext.autodoc.directive import AutodocDirective
1125         self.registry.add_documenter(cls.objtype, cls)
1126         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1127 
1128     def add_autodoc_attrgetter(self, typ: Type, getter: Callable[[Any, str, Any], Any]
1129                                ) -> None:
1130         """Register a new ``getattr``-like function for the autodoc extension.
1131 
1132         Add *getter*, which must be a function with an interface compatible to
1133         the :func:`getattr` builtin, as the autodoc attribute getter for
1134         objects that are instances of *typ*.  All cases where autodoc needs to
1135         get an attribute of a type are then handled by this function instead of
1136         :func:`getattr`.
1137 
1138         .. versionadded:: 0.6
1139         """
1140         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1141         self.registry.add_autodoc_attrgetter(typ, getter)
1142 
1143     def add_search_language(self, cls: Any) -> None:
1144         """Register a new language for the HTML search index.
1145 
1146         Add *cls*, which must be a subclass of
1147         :class:`sphinx.search.SearchLanguage`, as a support language for
1148         building the HTML full-text search index.  The class must have a *lang*
1149         attribute that indicates the language it should be used for.  See
1150         :confval:`html_search_language`.
1151 
1152         .. versionadded:: 1.1
1153         """
1154         logger.debug('[app] adding search language: %r', cls)
1155         from sphinx.search import SearchLanguage, languages
1156         assert issubclass(cls, SearchLanguage)
1157         languages[cls.lang] = cls
1158 
1159     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1160         """Register a suffix of source files.
1161 
1162         Same as :confval:`source_suffix`.  The users can override this
1163         using the config setting.
1164 
1165         If *override* is True, the given *suffix* is forcedly installed even if
1166         the same suffix is already installed.
1167 
1168         .. versionadded:: 1.8
1169         """
1170         self.registry.add_source_suffix(suffix, filetype, override=override)
1171 
1172     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
1173         """Register a parser class.
1174 
1175         If *override* is True, the given *parser* is forcedly installed even if
1176         a parser for the same suffix is already installed.
1177 
1178         .. versionadded:: 1.4
1179         .. versionchanged:: 1.8
1180            *suffix* argument is deprecated.  It only accepts *parser* argument.
1181            Use :meth:`add_source_suffix` API to register suffix instead.
1182         .. versionchanged:: 1.8
1183            Add *override* keyword.
1184         """
1185         self.registry.add_source_parser(parser, override=override)
1186 
1187     def add_env_collector(self, collector: Type[EnvironmentCollector]) -> None:
1188         """Register an environment collector class.
1189 
1190         Refer to :ref:`collector-api`.
1191 
1192         .. versionadded:: 1.6
1193         """
1194         logger.debug('[app] adding environment collector: %r', collector)
1195         collector().enable(self)
1196 
1197     def add_html_theme(self, name: str, theme_path: str) -> None:
1198         """Register a HTML Theme.
1199 
1200         The *name* is a name of theme, and *theme_path* is a full path to the
1201         theme (refs: :ref:`distribute-your-theme`).
1202 
1203         .. versionadded:: 1.6
1204         """
1205         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1206         self.registry.add_html_theme(name, theme_path)
1207 
1208     def add_html_math_renderer(self, name: str,
1209                                inline_renderers: Tuple[Callable, Callable] = None,
1210                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1211         """Register a math renderer for HTML.
1212 
1213         The *name* is a name of math renderer.  Both *inline_renderers* and
1214         *block_renderers* are used as visitor functions for the HTML writer:
1215         the former for inline math node (``nodes.math``), the latter for
1216         block math node (``nodes.math_block``).  Regarding visitor functions,
1217         see :meth:`add_node` for details.
1218 
1219         .. versionadded:: 1.8
1220 
1221         """
1222         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1223 
1224     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1225         """Register a message catalog.
1226 
1227         :param catalog: The name of the catalog
1228         :param locale_dir: The base path of the message catalog
1229 
1230         For more details, see :func:`sphinx.locale.get_translation()`.
1231 
1232         .. versionadded:: 1.8
1233         """
1234         locale.init([locale_dir], self.config.language, catalog)
1235         locale.init_console(locale_dir, catalog)
1236 
1237     # ---- other methods -------------------------------------------------
1238     def is_parallel_allowed(self, typ: str) -> bool:
1239         """Check whether parallel processing is allowed or not.
1240 
1241         :param typ: A type of processing; ``'read'`` or ``'write'``.
1242         """
1243         if typ == 'read':
1244             attrname = 'parallel_read_safe'
1245             message_not_declared = __("the %s extension does not declare if it "
1246                                       "is safe for parallel reading, assuming "
1247                                       "it isn't - please ask the extension author "
1248                                       "to check and make it explicit")
1249             message_not_safe = __("the %s extension is not safe for parallel reading")
1250         elif typ == 'write':
1251             attrname = 'parallel_write_safe'
1252             message_not_declared = __("the %s extension does not declare if it "
1253                                       "is safe for parallel writing, assuming "
1254                                       "it isn't - please ask the extension author "
1255                                       "to check and make it explicit")
1256             message_not_safe = __("the %s extension is not safe for parallel writing")
1257         else:
1258             raise ValueError('parallel type %s is not supported' % typ)
1259 
1260         for ext in self.extensions.values():
1261             allowed = getattr(ext, attrname, None)
1262             if allowed is None:
1263                 logger.warning(message_not_declared, ext.name)
1264                 logger.warning(__('doing serial %s'), typ)
1265                 return False
1266             elif not allowed:
1267                 logger.warning(message_not_safe, ext.name)
1268                 logger.warning(__('doing serial %s'), typ)
1269                 return False
1270 
1271         return True
1272 
1273     def set_html_assets_policy(self, policy):
1274         """Set the policy to include assets in HTML pages.
1275 
1276         - always: include the assets in all the pages
1277         - per_page: include the assets only in pages where they are used
1278 
1279         .. versionadded: 4.1
1280         """
1281         if policy not in ('always', 'per_page'):
1282             raise ValueError('policy %s is not supported' % policy)
1283         self.registry.html_assets_policy = policy
1284 
1285     @property
1286     def html_themes(self) -> Dict[str, str]:
1287         warnings.warn('app.html_themes is deprecated.',
1288                       RemovedInSphinx60Warning)
1289         return self.registry.html_themes
1290 
1291 
1292 class TemplateBridge:
1293     """
1294     This class defines the interface for a "template bridge", that is, a class
1295     that renders templates given a template name and a context.
1296     """
1297 
1298     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1299         """Called by the builder to initialize the template system.
1300 
1301         *builder* is the builder object; you'll probably want to look at the
1302         value of ``builder.config.templates_path``.
1303 
1304         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1305         case, *dirs* can be list of fixed directories to look for templates.
1306         """
1307         raise NotImplementedError('must be implemented in subclasses')
1308 
1309     def newest_template_mtime(self) -> float:
1310         """Called by the builder to determine if output files are outdated
1311         because of template changes.  Return the mtime of the newest template
1312         file that was changed.  The default implementation returns ``0``.
1313         """
1314         return 0
1315 
1316     def render(self, template: str, context: Dict) -> None:
1317         """Called by the builder to render a template given as a filename with
1318         a specified context (a Python dictionary).
1319         """
1320         raise NotImplementedError('must be implemented in subclasses')
1321 
1322     def render_string(self, template: str, context: Dict) -> str:
1323         """Called by the builder to render a template given as a string with a
1324         specified context (a Python dictionary).
1325         """
1326         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>Modify or ensure the extension setup logic correctly parses and compares semantic versions. This could involve using a utility like parse_version or adopting a robust comparison approach similar to LooseVersion but suited for semantic versioning, ensuring "0.10" is correctly seen as greater than "0.6".</intended_behavior>, <file>sphinx/registry.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.registry
3     ~~~~~~~~~~~~~~~
4 
5     Sphinx component registry.
6 
7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import traceback
12 import warnings
13 from importlib import import_module
14 from types import MethodType
15 from typing import (TYPE_CHECKING, Any, Callable, Dict, Iterator, List, Optional, Tuple, Type,
16                     Union)
17 
18 from docutils import nodes
19 from docutils.io import Input
20 from docutils.nodes import Element, Node, TextElement
21 from docutils.parsers import Parser
22 from docutils.parsers.rst import Directive
23 from docutils.transforms import Transform
24 from pkg_resources import iter_entry_points
25 
26 from sphinx.builders import Builder
27 from sphinx.config import Config
28 from sphinx.deprecation import RemovedInSphinx60Warning
29 from sphinx.domains import Domain, Index, ObjType
30 from sphinx.domains.std import GenericObject, Target
31 from sphinx.environment import BuildEnvironment
32 from sphinx.errors import ExtensionError, SphinxError, VersionRequirementError
33 from sphinx.extension import Extension
34 from sphinx.locale import __
35 from sphinx.parsers import Parser as SphinxParser
36 from sphinx.roles import XRefRole
37 from sphinx.util import logging
38 from sphinx.util.logging import prefixed_warnings
39 from sphinx.util.typing import RoleFunction, TitleGetter
40 
41 if TYPE_CHECKING:
42     from sphinx.application import Sphinx
43     from sphinx.ext.autodoc import Documenter
44 
45 logger = logging.getLogger(__name__)
46 
47 # list of deprecated extensions. Keys are extension name.
48 # Values are Sphinx version that merge the extension.
49 EXTENSION_BLACKLIST = {
50     "sphinxjp.themecore": "1.2"
51 }
52 
53 
54 class SphinxComponentRegistry:
55     def __init__(self) -> None:
56         #: special attrgetter for autodoc; class object -> attrgetter
57         self.autodoc_attrgettrs: Dict[Type, Callable[[Any, str, Any], Any]] = {}
58 
59         #: builders; a dict of builder name -> bulider class
60         self.builders: Dict[str, Type[Builder]] = {}
61 
62         #: autodoc documenters; a dict of documenter name -> documenter class
63         self.documenters: Dict[str, Type[Documenter]] = {}
64 
65         #: css_files; a list of tuple of filename and attributes
66         self.css_files: List[Tuple[str, Dict[str, Any]]] = []
67 
68         #: domains; a dict of domain name -> domain class
69         self.domains: Dict[str, Type[Domain]] = {}
70 
71         #: additional directives for domains
72         #: a dict of domain name -> dict of directive name -> directive
73         self.domain_directives: Dict[str, Dict[str, Any]] = {}
74 
75         #: additional indices for domains
76         #: a dict of domain name -> list of index class
77         self.domain_indices: Dict[str, List[Type[Index]]] = {}
78 
79         #: additional object types for domains
80         #: a dict of domain name -> dict of objtype name -> objtype
81         self.domain_object_types: Dict[str, Dict[str, ObjType]] = {}
82 
83         #: additional roles for domains
84         #: a dict of domain name -> dict of role name -> role impl.
85         self.domain_roles: Dict[str, Dict[str, Union[RoleFunction, XRefRole]]] = {}
86 
87         #: additional enumerable nodes
88         #: a dict of node class -> tuple of figtype and title_getter function
89         self.enumerable_nodes: Dict[Type[Node], Tuple[str, TitleGetter]] = {}
90 
91         #: HTML inline and block math renderers
92         #: a dict of name -> tuple of visit function and depart function
93         self.html_inline_math_renderers: Dict[str, Tuple[Callable, Callable]] = {}
94         self.html_block_math_renderers: Dict[str, Tuple[Callable, Callable]] = {}
95 
96         #: HTML assets
97         self.html_assets_policy: str = 'per_page'
98 
99         #: HTML themes
100         self.html_themes: Dict[str, str] = {}
101 
102         #: js_files; list of JS paths or URLs
103         self.js_files: List[Tuple[str, Dict[str, Any]]] = []
104 
105         #: LaTeX packages; list of package names and its options
106         self.latex_packages: List[Tuple[str, str]] = []
107 
108         self.latex_packages_after_hyperref: List[Tuple[str, str]] = []
109 
110         #: post transforms; list of transforms
111         self.post_transforms: List[Type[Transform]] = []
112 
113         #: source paresrs; file type -> parser class
114         self.source_parsers: Dict[str, Type[Parser]] = {}
115 
116         #: source inputs; file type -> input class
117         self.source_inputs: Dict[str, Type[Input]] = {}
118 
119         #: source suffix: suffix -> file type
120         self.source_suffix: Dict[str, str] = {}
121 
122         #: custom translators; builder name -> translator class
123         self.translators: Dict[str, Type[nodes.NodeVisitor]] = {}
124 
125         #: custom handlers for translators
126         #: a dict of builder name -> dict of node name -> visitor and departure functions
127         self.translation_handlers: Dict[str, Dict[str, Tuple[Callable, Callable]]] = {}
128 
129         #: additional transforms; list of transforms
130         self.transforms: List[Type[Transform]] = []
131 
132     def add_builder(self, builder: Type[Builder], override: bool = False) -> None:
133         logger.debug('[app] adding builder: %r', builder)
134         if not hasattr(builder, 'name'):
135             raise ExtensionError(__('Builder class %s has no "name" attribute') % builder)
136         if builder.name in self.builders and not override:
137             raise ExtensionError(__('Builder %r already exists (in module %s)') %
138                                  (builder.name, self.builders[builder.name].__module__))
139         self.builders[builder.name] = builder
140 
141     def preload_builder(self, app: "Sphinx", name: str) -> None:
142         if name is None:
143             return
144 
145         if name not in self.builders:
146             entry_points = iter_entry_points('sphinx.builders', name)
147             try:
148                 entry_point = next(entry_points)
149             except StopIteration as exc:
150                 raise SphinxError(__('Builder name %s not registered or available'
151                                      ' through entry point') % name) from exc
152 
153             self.load_extension(app, entry_point.module_name)
154 
155     def create_builder(self, app: "Sphinx", name: str) -> Builder:
156         if name not in self.builders:
157             raise SphinxError(__('Builder name %s not registered') % name)
158 
159         return self.builders[name](app)
160 
161     def add_domain(self, domain: Type[Domain], override: bool = False) -> None:
162         logger.debug('[app] adding domain: %r', domain)
163         if domain.name in self.domains and not override:
164             raise ExtensionError(__('domain %s already registered') % domain.name)
165         self.domains[domain.name] = domain
166 
167     def has_domain(self, domain: str) -> bool:
168         return domain in self.domains
169 
170     def create_domains(self, env: BuildEnvironment) -> Iterator[Domain]:
171         for DomainClass in self.domains.values():
172             domain = DomainClass(env)
173 
174             # transplant components added by extensions
175             domain.directives.update(self.domain_directives.get(domain.name, {}))
176             domain.roles.update(self.domain_roles.get(domain.name, {}))
177             domain.indices.extend(self.domain_indices.get(domain.name, []))
178             for name, objtype in self.domain_object_types.get(domain.name, {}).items():
179                 domain.add_object_type(name, objtype)
180 
181             yield domain
182 
183     def add_directive_to_domain(self, domain: str, name: str,
184                                 cls: Type[Directive], override: bool = False) -> None:
185         logger.debug('[app] adding directive to domain: %r', (domain, name, cls))
186         if domain not in self.domains:
187             raise ExtensionError(__('domain %s not yet registered') % domain)
188 
189         directives = self.domain_directives.setdefault(domain, {})
190         if name in directives and not override:
191             raise ExtensionError(__('The %r directive is already registered to domain %s') %
192                                  (name, domain))
193         directives[name] = cls
194 
195     def add_role_to_domain(self, domain: str, name: str,
196                            role: Union[RoleFunction, XRefRole], override: bool = False
197                            ) -> None:
198         logger.debug('[app] adding role to domain: %r', (domain, name, role))
199         if domain not in self.domains:
200             raise ExtensionError(__('domain %s not yet registered') % domain)
201         roles = self.domain_roles.setdefault(domain, {})
202         if name in roles and not override:
203             raise ExtensionError(__('The %r role is already registered to domain %s') %
204                                  (name, domain))
205         roles[name] = role
206 
207     def add_index_to_domain(self, domain: str, index: Type[Index],
208                             override: bool = False) -> None:
209         logger.debug('[app] adding index to domain: %r', (domain, index))
210         if domain not in self.domains:
211             raise ExtensionError(__('domain %s not yet registered') % domain)
212         indices = self.domain_indices.setdefault(domain, [])
213         if index in indices and not override:
214             raise ExtensionError(__('The %r index is already registered to domain %s') %
215                                  (index.name, domain))
216         indices.append(index)
217 
218     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
219                         parse_node: Callable = None, ref_nodeclass: Type[TextElement] = None,
220                         objname: str = '', doc_field_types: List = [], override: bool = False
221                         ) -> None:
222         logger.debug('[app] adding object type: %r',
223                      (directivename, rolename, indextemplate, parse_node,
224                       ref_nodeclass, objname, doc_field_types))
225 
226         # create a subclass of GenericObject as the new directive
227         directive = type(directivename,
228                          (GenericObject, object),
229                          {'indextemplate': indextemplate,
230                           'parse_node': staticmethod(parse_node),
231                           'doc_field_types': doc_field_types})
232 
233         self.add_directive_to_domain('std', directivename, directive)
234         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
235 
236         object_types = self.domain_object_types.setdefault('std', {})
237         if directivename in object_types and not override:
238             raise ExtensionError(__('The %r object_type is already registered') %
239                                  directivename)
240         object_types[directivename] = ObjType(objname or directivename, rolename)
241 
242     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
243                           ref_nodeclass: Type[TextElement] = None, objname: str = '',
244                           override: bool = False) -> None:
245         logger.debug('[app] adding crossref type: %r',
246                      (directivename, rolename, indextemplate, ref_nodeclass, objname))
247 
248         # create a subclass of Target as the new directive
249         directive = type(directivename,
250                          (Target, object),
251                          {'indextemplate': indextemplate})
252 
253         self.add_directive_to_domain('std', directivename, directive)
254         self.add_role_to_domain('std', rolename, XRefRole(innernodeclass=ref_nodeclass))
255 
256         object_types = self.domain_object_types.setdefault('std', {})
257         if directivename in object_types and not override:
258             raise ExtensionError(__('The %r crossref_type is already registered') %
259                                  directivename)
260         object_types[directivename] = ObjType(objname or directivename, rolename)
261 
262     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
263         logger.debug('[app] adding source_suffix: %r, %r', suffix, filetype)
264         if suffix in self.source_suffix and not override:
265             raise ExtensionError(__('source_suffix %r is already registered') % suffix)
266         else:
267             self.source_suffix[suffix] = filetype
268 
269     def add_source_parser(self, parser: Type[Parser], override: bool = False) -> None:
270         logger.debug('[app] adding search source_parser: %r', parser)
271 
272         # create a map from filetype to parser
273         for filetype in parser.supported:
274             if filetype in self.source_parsers and not override:
275                 raise ExtensionError(__('source_parser for %r is already registered') %
276                                      filetype)
277             else:
278                 self.source_parsers[filetype] = parser
279 
280     def get_source_parser(self, filetype: str) -> Type[Parser]:
281         try:
282             return self.source_parsers[filetype]
283         except KeyError as exc:
284             raise SphinxError(__('Source parser for %s not registered') % filetype) from exc
285 
286     def get_source_parsers(self) -> Dict[str, Type[Parser]]:
287         return self.source_parsers
288 
289     def create_source_parser(self, app: "Sphinx", filename: str) -> Parser:
290         parser_class = self.get_source_parser(filename)
291         parser = parser_class()
292         if isinstance(parser, SphinxParser):
293             parser.set_application(app)
294         return parser
295 
296     def get_source_input(self, filetype: str) -> Optional[Type[Input]]:
297         warnings.warn('SphinxComponentRegistry.get_source_input() is deprecated.',
298                       RemovedInSphinx60Warning)
299 
300         try:
301             return self.source_inputs[filetype]
302         except KeyError:
303             try:
304                 # use special source_input for unknown filetype
305                 return self.source_inputs['*']
306             except KeyError:
307                 return None
308 
309     def add_translator(self, name: str, translator: Type[nodes.NodeVisitor],
310                        override: bool = False) -> None:
311         logger.debug('[app] Change of translator for the %s builder.', name)
312         if name in self.translators and not override:
313             raise ExtensionError(__('Translator for %r already exists') % name)
314         self.translators[name] = translator
315 
316     def add_translation_handlers(self, node: Type[Element],
317                                  **kwargs: Tuple[Callable, Callable]) -> None:
318         logger.debug('[app] adding translation_handlers: %r, %r', node, kwargs)
319         for builder_name, handlers in kwargs.items():
320             translation_handlers = self.translation_handlers.setdefault(builder_name, {})
321             try:
322                 visit, depart = handlers  # unpack once for assertion
323                 translation_handlers[node.__name__] = (visit, depart)
324             except ValueError as exc:
325                 raise ExtensionError(
326                     __('kwargs for add_node() must be a (visit, depart) '
327                        'function tuple: %r=%r') % (builder_name, handlers)
328                 ) from exc
329 
330     def get_translator_class(self, builder: Builder) -> Type[nodes.NodeVisitor]:
331         return self.translators.get(builder.name,
332                                     builder.default_translator_class)
333 
334     def create_translator(self, builder: Builder, *args: Any) -> nodes.NodeVisitor:
335         translator_class = self.get_translator_class(builder)
336         assert translator_class, "translator not found for %s" % builder.name
337         translator = translator_class(*args)
338 
339         # transplant handlers for custom nodes to translator instance
340         handlers = self.translation_handlers.get(builder.name, None)
341         if handlers is None:
342             # retry with builder.format
343             handlers = self.translation_handlers.get(builder.format, {})
344 
345         for name, (visit, depart) in handlers.items():
346             setattr(translator, 'visit_' + name, MethodType(visit, translator))
347             if depart:
348                 setattr(translator, 'depart_' + name, MethodType(depart, translator))
349 
350         return translator
351 
352     def add_transform(self, transform: Type[Transform]) -> None:
353         logger.debug('[app] adding transform: %r', transform)
354         self.transforms.append(transform)
355 
356     def get_transforms(self) -> List[Type[Transform]]:
357         return self.transforms
358 
359     def add_post_transform(self, transform: Type[Transform]) -> None:
360         logger.debug('[app] adding post transform: %r', transform)
361         self.post_transforms.append(transform)
362 
363     def get_post_transforms(self) -> List[Type[Transform]]:
364         return self.post_transforms
365 
366     def add_documenter(self, objtype: str, documenter: Type["Documenter"]) -> None:
367         self.documenters[objtype] = documenter
368 
369     def add_autodoc_attrgetter(self, typ: Type,
370                                attrgetter: Callable[[Any, str, Any], Any]) -> None:
371         self.autodoc_attrgettrs[typ] = attrgetter
372 
373     def add_css_files(self, filename: str, **attributes: Any) -> None:
374         self.css_files.append((filename, attributes))
375 
376     def add_js_file(self, filename: str, **attributes: Any) -> None:
377         logger.debug('[app] adding js_file: %r, %r', filename, attributes)
378         self.js_files.append((filename, attributes))
379 
380     def has_latex_package(self, name: str) -> bool:
381         packages = self.latex_packages + self.latex_packages_after_hyperref
382         return bool([x for x in packages if x[0] == name])
383 
384     def add_latex_package(self, name: str, options: str, after_hyperref: bool = False) -> None:
385         if self.has_latex_package(name):
386             logger.warn("latex package '%s' already included" % name)
387 
388         logger.debug('[app] adding latex package: %r', name)
389         if after_hyperref:
390             self.latex_packages_after_hyperref.append((name, options))
391         else:
392             self.latex_packages.append((name, options))
393 
394     def add_enumerable_node(self, node: Type[Node], figtype: str,
395                             title_getter: TitleGetter = None, override: bool = False) -> None:
396         logger.debug('[app] adding enumerable node: (%r, %r, %r)', node, figtype, title_getter)
397         if node in self.enumerable_nodes and not override:
398             raise ExtensionError(__('enumerable_node %r already registered') % node)
399         self.enumerable_nodes[node] = (figtype, title_getter)
400 
401     def add_html_math_renderer(self, name: str,
402                                inline_renderers: Tuple[Callable, Callable],
403                                block_renderers: Tuple[Callable, Callable]) -> None:
404         logger.debug('[app] adding html_math_renderer: %s, %r, %r',
405                      name, inline_renderers, block_renderers)
406         if name in self.html_inline_math_renderers:
407             raise ExtensionError(__('math renderer %s is already registered') % name)
408 
409         self.html_inline_math_renderers[name] = inline_renderers
410         self.html_block_math_renderers[name] = block_renderers
411 
412     def add_html_theme(self, name: str, theme_path: str) -> None:
413         self.html_themes[name] = theme_path
414 
415     def load_extension(self, app: "Sphinx", extname: str) -> None:
416         """Load a Sphinx extension."""
417         if extname in app.extensions:  # already loaded
418             return
419         if extname in EXTENSION_BLACKLIST:
420             logger.warning(__('the extension %r was already merged with Sphinx since '
421                               'version %s; this extension is ignored.'),
422                            extname, EXTENSION_BLACKLIST[extname])
423             return
424 
425         # update loading context
426         prefix = __('while setting up extension %s:') % extname
427         with prefixed_warnings(prefix):
428             try:
429                 mod = import_module(extname)
430             except ImportError as err:
431                 logger.verbose(__('Original exception:\n') + traceback.format_exc())
432                 raise ExtensionError(__('Could not import extension %s') % extname,
433                                      err) from err
434 
435             setup = getattr(mod, 'setup', None)
436             if setup is None:
437                 logger.warning(__('extension %r has no setup() function; is it really '
438                                   'a Sphinx extension module?'), extname)
439                 metadata: Dict[str, Any] = {}
440             else:
441                 try:
442                     metadata = setup(app)
443                 except VersionRequirementError as err:
444                     # add the extension name to the version required
445                     raise VersionRequirementError(
446                         __('The %s extension used by this project needs at least '
447                            'Sphinx v%s; it therefore cannot be built with this '
448                            'version.') % (extname, err)
449                     ) from err
450 
451             if metadata is None:
452                 metadata = {}
453             elif not isinstance(metadata, dict):
454                 logger.warning(__('extension %r returned an unsupported object from '
455                                   'its setup() function; it should return None or a '
456                                   'metadata dictionary'), extname)
457                 metadata = {}
458 
459             app.extensions[extname] = Extension(extname, mod, **metadata)
460 
461     def get_envversion(self, app: "Sphinx") -> Dict[str, str]:
462         from sphinx.environment import ENV_VERSION
463         envversion = {ext.name: ext.metadata['env_version'] for ext in app.extensions.values()
464                       if ext.metadata.get('env_version')}
465         envversion['sphinx'] = ENV_VERSION
466         return envversion
467 
468 
469 def merge_source_suffix(app: "Sphinx", config: Config) -> None:
470     """Merge any user-specified source_suffix with any added by extensions."""
471     for suffix, filetype in app.registry.source_suffix.items():
472         if suffix not in app.config.source_suffix:
473             app.config.source_suffix[suffix] = filetype
474         elif app.config.source_suffix[suffix] is None:
475             # filetype is not specified (default filetype).
476             # So it overrides default filetype by extensions setting.
477             app.config.source_suffix[suffix] = filetype
478 
479     # copy config.source_suffix to registry
480     app.registry.source_suffix = app.config.source_suffix
481 
482 
483 def setup(app: "Sphinx") -> Dict[str, Any]:
484     app.connect('config-inited', merge_source_suffix, priority=800)
485 
486     return {
487         'version': 'builtin',
488         'parallel_read_safe': True,
489         'parallel_write_safe': True,
490     }

</code><intended_behavior>When registering or validating extension versions, employ a consistent, accurate method for semantic version parsing and comparison. This ensures extensions with correct version numbers are accepted, addressing the comparison issue ("0.6" vs. "0.10").</intended_behavior>]
2025-10-17 19:23:46.315 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 19:23:46.316 | INFO     | Search-only: skipping patch selection
2025-10-17 19:23:46.389 | INFO     | Task sphinx-doc__sphinx-9711 completed successfully.
2025-10-17 19:23:46.390 | INFO     | No patch generated. You can try running ACR again.
