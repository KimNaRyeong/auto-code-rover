2025-10-17 10:55:58.451 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 10:56:01.865 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=12, cost=0.005100
2025-10-17 10:56:01.865 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 10:56:01.869 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:56:12.069 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=782, output_tokens=435, cost=0.020870
2025-10-17 10:56:12.078 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:56:15.498 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=789, output_tokens=88, cost=0.010530
2025-10-17 10:56:15.500 | DEBUG    | Extracted a valid json.
2025-10-17 10:56:15.500 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MigrationExecutor\")",
        "search_method_in_class(\"apply_migration\", \"MigrationExecutor\")",
        "search_method_in_class(\"record_unapplied_migrations\", \"MigrationExecutor\")",
        "search_class(\"Migration\")",
        "search_method(\"detect_soft_applied\")",
        "search_code(\"replaces =\")"
    ],
    "bug_locations": []
}
2025-10-17 10:56:15.595 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 10:56:15.595 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 10:56:37.226 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4607, output_tokens=961, cost=0.074900
2025-10-17 10:56:37.243 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:56:50.445 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5784, output_tokens=610, cost=0.076140
2025-10-17 10:56:50.457 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:57:01.722 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=964, output_tokens=516, cost=0.025120
2025-10-17 10:57:01.723 | DEBUG    | Extracted a valid json.
2025-10-17 10:57:01.723 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/migrations/executor.py",
            "class": "MigrationExecutor",
            "method": "apply_migration",
            "intended_behavior": "This method should include additional logic to: 1. Verify if a migration listed in the django_migrations table still exists as a file or is part of a squashed migration (considering the replaces attribute). This could involve leveraging existing attributes or methods related to migration discovery and including a check against the django_migrations table to ensure only migrations that physically exist or are logically valid (replaced by a squashed migration) are applied. 2. Ensure that if a migration is deemed nonexistent but recorded as applied, it should be either flagged for further action (like manual removal or notification to the user) or automatically handled in a manner that maintains database integrity and avoids the previously described 'name collision' issue."
        },
        {
            "file": "django/db/migrations/executor.py",
            "class": "MigrationExecutor",
            "method": "record_migration",
            "intended_behavior": "Enhance this method to: 1. Before recording a new migration as applied, check if its name potentially conflicts with any previously applied but now-nonexistent (file-deleted) migrations. This isn't purely about string matching but should consider the semantic naming conflicts that could arise from Django's migration naming conventions. 2. If a conflict is detected, the method should either prevent the recording of the new migration (throwing an error or warning) or, more sophisticated, handle the cleanup of outdated migration records under specific, safe conditions."
        },
        {
            "file": "django/db/migrations/executor.py",
            "class": "MigrationExecutor",
            "intended_behavior": "A new method, potentially named validate_migration_records, should: 1. Iterate through the django_migrations table records and compare them against the existing migration files and the replaces attribute in any squashed migrations. 2. Identify and handle discrepancies where a record exists for a migration that has no corresponding file or is not accounted for in a replaces attribute, doing so in a way that preserves the integrity of the migration history and the state of the database schema. 3. This method could be called at strategic points within the migration application process (perhaps as part of the initial checks in migrate or apply_migration) to ensure the accuracy of the django_migrations table before proceeding with applying new migrations."
        }
    ]
}
2025-10-17 10:57:01.733 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>apply_migration</method>
<code>
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state

</code><intended_behavior>This method should include additional logic to: 1. Verify if a migration listed in the django_migrations table still exists as a file or is part of a squashed migration (considering the replaces attribute). This could involve leveraging existing attributes or methods related to migration discovery and including a check against the django_migrations table to ensure only migrations that physically exist or are logically valid (replaced by a squashed migration) are applied. 2. Ensure that if a migration is deemed nonexistent but recorded as applied, it should be either flagged for further action (like manual removal or notification to the user) or automatically handled in a manner that maintains database integrity and avoids the previously described 'name collision' issue.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>record_migration</method>
<code>
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)

</code><intended_behavior>Enhance this method to: 1. Before recording a new migration as applied, check if its name potentially conflicts with any previously applied but now-nonexistent (file-deleted) migrations. This isn't purely about string matching but should consider the semantic naming conflicts that could arise from Django's migration naming conventions. 2. If a conflict is detected, the method should either prevent the recording of the new migration (throwing an error or warning) or, more sophisticated, handle the cleanup of outdated migration records under specific, safe conditions.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>A new method, potentially named validate_migration_records, should: 1. Iterate through the django_migrations table records and compare them against the existing migration files and the replaces attribute in any squashed migrations. 2. Identify and handle discrepancies where a record exists for a migration that has no corresponding file or is not accounted for in a replaces attribute, doing so in a way that preserves the integrity of the migration history and the state of the database schema. 3. This method could be called at strategic points within the migration application process (perhaps as part of the initial checks in migrate or apply_migration) to ensure the accuracy of the django_migrations table before proceeding with applying new migrations.</intended_behavior>]
2025-10-17 10:57:01.734 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>apply_migration</method>
<code>
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state

</code><intended_behavior>This method should include additional logic to: 1. Verify if a migration listed in the django_migrations table still exists as a file or is part of a squashed migration (considering the replaces attribute). This could involve leveraging existing attributes or methods related to migration discovery and including a check against the django_migrations table to ensure only migrations that physically exist or are logically valid (replaced by a squashed migration) are applied. 2. Ensure that if a migration is deemed nonexistent but recorded as applied, it should be either flagged for further action (like manual removal or notification to the user) or automatically handled in a manner that maintains database integrity and avoids the previously described 'name collision' issue.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>record_migration</method>
<code>
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)

</code><intended_behavior>Enhance this method to: 1. Before recording a new migration as applied, check if its name potentially conflicts with any previously applied but now-nonexistent (file-deleted) migrations. This isn't purely about string matching but should consider the semantic naming conflicts that could arise from Django's migration naming conventions. 2. If a conflict is detected, the method should either prevent the recording of the new migration (throwing an error or warning) or, more sophisticated, handle the cleanup of outdated migration records under specific, safe conditions.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>A new method, potentially named validate_migration_records, should: 1. Iterate through the django_migrations table records and compare them against the existing migration files and the replaces attribute in any squashed migrations. 2. Identify and handle discrepancies where a record exists for a migration that has no corresponding file or is not accounted for in a replaces attribute, doing so in a way that preserves the integrity of the migration history and the state of the database schema. 3. This method could be called at strategic points within the migration application process (perhaps as part of the initial checks in migrate or apply_migration) to ensure the accuracy of the django_migrations table before proceeding with applying new migrations.</intended_behavior>]
2025-10-17 10:57:01.734 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 10:57:01.734 | INFO     | Search-only: skipping patch selection
2025-10-17 10:57:01.902 | INFO     | Task django__django-15240 completed successfully.
2025-10-17 10:57:01.903 | INFO     | No patch generated. You can try running ACR again.
