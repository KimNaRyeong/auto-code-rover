[
    {
        "rel_file_path": "django/contrib/auth/forms.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/auth/forms.py",
        "start": 183,
        "end": 196,
        "class_name": "AuthenticationForm",
        "method_name": "__init__",
        "code": "183     def __init__(self, request=None, *args, **kwargs):\n184         \"\"\"\n185         The 'request' parameter is set for custom auth use by subclasses.\n186         The form data comes in via the standard 'data' kwarg.\n187         \"\"\"\n188         self.request = request\n189         self.user_cache = None\n190         super().__init__(*args, **kwargs)\n191 \n192         # Set the max length and label for the \"username\" field.\n193         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n194         self.fields['username'].max_length = self.username_field.max_length or 254\n195         if self.fields['username'].label is None:\n196             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n",
        "intended_behavior": "In the `__init__` method, after setting the `max_length` attribute for the `username` field (line 194), the method should also ensure that the `maxlength` HTML attribute is correctly set so that it is rendered in the form's HTML output. This can be achieved by adjusting the widget's attributes of the `username` field to include `maxlength`. For example, it should ensure that the following adjustment is made:\n```python\nself.fields['username'].widget.attrs['maxlength'] = self.fields['username'].max_length\n```\nThis code snippet ensures the HTML rendered for the `username` field includes a `maxlength` attribute that matches the `max_length` value of the field. This change will enforce the maximum length constraint directly within the HTML, preventing users from inputting more characters than allowed and mirroring the validation logic on the client side that already exists on the server side."
    },
    {
        "rel_file_path": "django/contrib/auth/forms.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/auth/forms.py",
        "start": 163,
        "end": 236,
        "class_name": "AuthenticationForm",
        "method_name": null,
        "code": "163 class AuthenticationForm(forms.Form):\n164     \"\"\"\n165     Base class for authenticating users. Extend this to get a form that accepts\n166     username/password logins.\n167     \"\"\"\n168     username = UsernameField(widget=forms.TextInput(attrs={'autofocus': True}))\n169     password = forms.CharField(\n170         label=_(\"Password\"),\n171         strip=False,\n172         widget=forms.PasswordInput(attrs={'autocomplete': 'current-password'}),\n173     )\n174 \n175     error_messages = {\n176         'invalid_login': _(\n177             \"Please enter a correct %(username)s and password. Note that both \"\n178             \"fields may be case-sensitive.\"\n179         ),\n180         'inactive': _(\"This account is inactive.\"),\n181     }\n182 \n183     def __init__(self, request=None, *args, **kwargs):\n184         \"\"\"\n185         The 'request' parameter is set for custom auth use by subclasses.\n186         The form data comes in via the standard 'data' kwarg.\n187         \"\"\"\n188         self.request = request\n189         self.user_cache = None\n190         super().__init__(*args, **kwargs)\n191 \n192         # Set the max length and label for the \"username\" field.\n193         self.username_field = UserModel._meta.get_field(UserModel.USERNAME_FIELD)\n194         self.fields['username'].max_length = self.username_field.max_length or 254\n195         if self.fields['username'].label is None:\n196             self.fields['username'].label = capfirst(self.username_field.verbose_name)\n197 \n198     def clean(self):\n199         username = self.cleaned_data.get('username')\n200         password = self.cleaned_data.get('password')\n201 \n202         if username is not None and password:\n203             self.user_cache = authenticate(self.request, username=username, password=password)\n204             if self.user_cache is None:\n205                 raise self.get_invalid_login_error()\n206             else:\n207                 self.confirm_login_allowed(self.user_cache)\n208 \n209         return self.cleaned_data\n210 \n211     def confirm_login_allowed(self, user):\n212         \"\"\"\n213         Controls whether the given User may log in. This is a policy setting,\n214         independent of end-user authentication. This default behavior is to\n215         allow login by active users, and reject login by inactive users.\n216 \n217         If the given user cannot log in, this method should raise a\n218         ``forms.ValidationError``.\n219 \n220         If the given user may log in, this method should return None.\n221         \"\"\"\n222         if not user.is_active:\n223             raise forms.ValidationError(\n224                 self.error_messages['inactive'],\n225                 code='inactive',\n226             )\n227 \n228     def get_user(self):\n229         return self.user_cache\n230 \n231     def get_invalid_login_error(self):\n232         return forms.ValidationError(\n233             self.error_messages['invalid_login'],\n234             code='invalid_login',\n235             params={'username': self.username_field.verbose_name},\n236         )\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/contrib/auth/forms.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/auth/forms.py",
        "start": 64,
        "end": 69,
        "class_name": "UsernameField",
        "method_name": "widget_attrs",
        "code": "64     def widget_attrs(self, widget):\n65         return {\n66             **super().widget_attrs(widget),\n67             'autocapitalize': 'none',\n68             'autocomplete': 'username',\n69         }\n",
        "intended_behavior": "If the `widget_attrs` method of `UsernameField` does not already handle setting the `maxlength` attribute based on the field's `max_length`, this method should be updated or implemented to ensure that the `maxlength` attribute is correctly set for widgets of `UsernameField`. The method should merge any existing attributes with the `maxlength` attribute, ensuring not to overwrite any existing widget attributes. This approach provides a more generic solution ensuring that all instances of `UsernameField` across the application respect the `max_length` constraint in their HTML rendering."
    },
    {
        "rel_file_path": "django/contrib/auth/forms.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/contrib/auth/forms.py",
        "start": 60,
        "end": 69,
        "class_name": "UsernameField",
        "method_name": null,
        "code": "60 class UsernameField(forms.CharField):\n61     def to_python(self, value):\n62         return unicodedata.normalize('NFKC', super().to_python(value))\n63 \n64     def widget_attrs(self, widget):\n65         return {\n66             **super().widget_attrs(widget),\n67             'autocapitalize': 'none',\n68             'autocomplete': 'username',\n69         }\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]