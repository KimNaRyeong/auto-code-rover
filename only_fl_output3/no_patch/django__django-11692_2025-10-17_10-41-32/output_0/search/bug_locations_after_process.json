[
    {
        "rel_file_path": "django/db/models/query.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/models/query.py",
        "start": 1034,
        "end": 1043,
        "class_name": null,
        "method_name": "union",
        "code": "1034     def union(self, *other_qs, all=False):\n1035         # If the query is an EmptyQuerySet, combine all nonempty querysets.\n1036         if isinstance(self, EmptyQuerySet):\n1037             qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]\n1038             if not qs:\n1039                 return self\n1040             if len(qs) == 1:\n1041                 return qs[0]\n1042             return qs[0]._combinator_query('union', *qs[1:], all=all)\n1043         return self._combinator_query('union', *other_qs, all=all)\n",
        "intended_behavior": "This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL."
    },
    {
        "rel_file_path": "django/contrib/gis/geos/geometry.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/contrib/gis/geos/geometry.py",
        "start": 601,
        "end": 603,
        "class_name": null,
        "method_name": "union",
        "code": "601     def union(self, other):\n602         \"Return a Geometry representing all the points in this Geometry and other.\"\n603         return self._topology(capi.geos_union(self.ptr, other.ptr))\n",
        "intended_behavior": "This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL."
    },
    {
        "rel_file_path": "django/contrib/gis/gdal/geometries.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/contrib/gis/gdal/geometries.py",
        "start": 493,
        "end": 498,
        "class_name": null,
        "method_name": "union",
        "code": "493     def union(self, other):\n494         \"\"\"\n495         Return a new geometry consisting of the region which is the union of\n496         this geometry and the other.\n497         \"\"\"\n498         return self._geomgen(capi.geom_union, other)\n",
        "intended_behavior": "This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL."
    },
    {
        "rel_file_path": "django/db/models/expressions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/models/expressions.py",
        "start": 1,
        "end": 1492,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 import datetime\n3 import functools\n4 import inspect\n5 from decimal import Decimal\n6 from uuid import UUID\n7 \n8 from django.core.exceptions import EmptyResultSet, FieldError\n9 from django.db import DatabaseError, NotSupportedError, connection\n10 from django.db.models import fields\n11 from django.db.models.constants import LOOKUP_SEP\n12 from django.db.models.query_utils import Q\n13 from django.utils.deconstruct import deconstructible\n14 from django.utils.functional import cached_property\n15 from django.utils.hashable import make_hashable\n16 \n17 \n18 class SQLiteNumericMixin:\n19     \"\"\"\n20     Some expressions with output_field=DecimalField() must be cast to\n21     numeric to be properly filtered.\n22     \"\"\"\n23     def as_sqlite(self, compiler, connection, **extra_context):\n24         sql, params = self.as_sql(compiler, connection, **extra_context)\n25         try:\n26             if self.output_field.get_internal_type() == 'DecimalField':\n27                 sql = 'CAST(%s AS NUMERIC)' % sql\n28         except FieldError:\n29             pass\n30         return sql, params\n31 \n32 \n33 class Combinable:\n34     \"\"\"\n35     Provide the ability to combine one or two objects with\n36     some connector. For example F('foo') + F('bar').\n37     \"\"\"\n38 \n39     # Arithmetic connectors\n40     ADD = '+'\n41     SUB = '-'\n42     MUL = '*'\n43     DIV = '/'\n44     POW = '^'\n45     # The following is a quoted % operator - it is quoted because it can be\n46     # used in strings that also have parameter substitution.\n47     MOD = '%%'\n48 \n49     # Bitwise operators - note that these are generated by .bitand()\n50     # and .bitor(), the '&' and '|' are reserved for boolean operator\n51     # usage.\n52     BITAND = '&'\n53     BITOR = '|'\n54     BITLEFTSHIFT = '<<'\n55     BITRIGHTSHIFT = '>>'\n56     BITXOR = '#'\n57 \n58     def _combine(self, other, connector, reversed):\n59         if not hasattr(other, 'resolve_expression'):\n60             # everything must be resolvable to an expression\n61             other = Value(other)\n62 \n63         if reversed:\n64             return CombinedExpression(other, connector, self)\n65         return CombinedExpression(self, connector, other)\n66 \n67     #############\n68     # OPERATORS #\n69     #############\n70 \n71     def __neg__(self):\n72         return self._combine(-1, self.MUL, False)\n73 \n74     def __add__(self, other):\n75         return self._combine(other, self.ADD, False)\n76 \n77     def __sub__(self, other):\n78         return self._combine(other, self.SUB, False)\n79 \n80     def __mul__(self, other):\n81         return self._combine(other, self.MUL, False)\n82 \n83     def __truediv__(self, other):\n84         return self._combine(other, self.DIV, False)\n85 \n86     def __mod__(self, other):\n87         return self._combine(other, self.MOD, False)\n88 \n89     def __pow__(self, other):\n90         return self._combine(other, self.POW, False)\n91 \n92     def __and__(self, other):\n93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n94             return Q(self) & Q(other)\n95         raise NotImplementedError(\n96             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n97         )\n98 \n99     def bitand(self, other):\n100         return self._combine(other, self.BITAND, False)\n101 \n102     def bitleftshift(self, other):\n103         return self._combine(other, self.BITLEFTSHIFT, False)\n104 \n105     def bitrightshift(self, other):\n106         return self._combine(other, self.BITRIGHTSHIFT, False)\n107 \n108     def bitxor(self, other):\n109         return self._combine(other, self.BITXOR, False)\n110 \n111     def __or__(self, other):\n112         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):\n113             return Q(self) | Q(other)\n114         raise NotImplementedError(\n115             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n116         )\n117 \n118     def bitor(self, other):\n119         return self._combine(other, self.BITOR, False)\n120 \n121     def __radd__(self, other):\n122         return self._combine(other, self.ADD, True)\n123 \n124     def __rsub__(self, other):\n125         return self._combine(other, self.SUB, True)\n126 \n127     def __rmul__(self, other):\n128         return self._combine(other, self.MUL, True)\n129 \n130     def __rtruediv__(self, other):\n131         return self._combine(other, self.DIV, True)\n132 \n133     def __rmod__(self, other):\n134         return self._combine(other, self.MOD, True)\n135 \n136     def __rpow__(self, other):\n137         return self._combine(other, self.POW, True)\n138 \n139     def __rand__(self, other):\n140         raise NotImplementedError(\n141             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n142         )\n143 \n144     def __ror__(self, other):\n145         raise NotImplementedError(\n146             \"Use .bitand() and .bitor() for bitwise logical operations.\"\n147         )\n148 \n149 \n150 class BaseExpression:\n151     \"\"\"Base class for all query expressions.\"\"\"\n152 \n153     empty_result_set_value = NotImplemented\n154     # aggregate specific fields\n155     is_summary = False\n156     _output_field_resolved_to_none = False\n157     # Can the expression be used in a WHERE clause?\n158     filterable = True\n159     # Can the expression can be used as a source expression in Window?\n160     window_compatible = False\n161 \n162     def __init__(self, output_field=None):\n163         if output_field is not None:\n164             self.output_field = output_field\n165 \n166     def __getstate__(self):\n167         state = self.__dict__.copy()\n168         state.pop('convert_value', None)\n169         return state\n170 \n171     def get_db_converters(self, connection):\n172         return (\n173             []\n174             if self.convert_value is self._convert_value_noop else\n175             [self.convert_value]\n176         ) + self.output_field.get_db_converters(connection)\n177 \n178     def get_source_expressions(self):\n179         return []\n180 \n181     def set_source_expressions(self, exprs):\n182         assert not exprs\n183 \n184     def _parse_expressions(self, *expressions):\n185         return [\n186             arg if hasattr(arg, 'resolve_expression') else (\n187                 F(arg) if isinstance(arg, str) else Value(arg)\n188             ) for arg in expressions\n189         ]\n190 \n191     def as_sql(self, compiler, connection):\n192         \"\"\"\n193         Responsible for returning a (sql, [params]) tuple to be included\n194         in the current query.\n195 \n196         Different backends can provide their own implementation, by\n197         providing an `as_{vendor}` method and patching the Expression:\n198 \n199         ```\n200         def override_as_sql(self, compiler, connection):\n201             # custom logic\n202             return super().as_sql(compiler, connection)\n203         setattr(Expression, 'as_' + connection.vendor, override_as_sql)\n204         ```\n205 \n206         Arguments:\n207          * compiler: the query compiler responsible for generating the query.\n208            Must have a compile method, returning a (sql, [params]) tuple.\n209            Calling compiler(value) will return a quoted `value`.\n210 \n211          * connection: the database connection used for the current query.\n212 \n213         Return: (sql, params)\n214           Where `sql` is a string containing ordered sql parameters to be\n215           replaced with the elements of the list `params`.\n216         \"\"\"\n217         raise NotImplementedError(\"Subclasses must implement as_sql()\")\n218 \n219     @cached_property\n220     def contains_aggregate(self):\n221         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())\n222 \n223     @cached_property\n224     def contains_over_clause(self):\n225         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())\n226 \n227     @cached_property\n228     def contains_column_references(self):\n229         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())\n230 \n231     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n232         \"\"\"\n233         Provide the chance to do any preprocessing or validation before being\n234         added to the query.\n235 \n236         Arguments:\n237          * query: the backend query implementation\n238          * allow_joins: boolean allowing or denying use of joins\n239            in this query\n240          * reuse: a set of reusable joins for multijoins\n241          * summarize: a terminal aggregate clause\n242          * for_save: whether this expression about to be used in a save or update\n243 \n244         Return: an Expression to be added to the query.\n245         \"\"\"\n246         c = self.copy()\n247         c.is_summary = summarize\n248         c.set_source_expressions([\n249             expr.resolve_expression(query, allow_joins, reuse, summarize)\n250             if expr else None\n251             for expr in c.get_source_expressions()\n252         ])\n253         return c\n254 \n255     @property\n256     def conditional(self):\n257         return isinstance(self.output_field, fields.BooleanField)\n258 \n259     @property\n260     def field(self):\n261         return self.output_field\n262 \n263     @cached_property\n264     def output_field(self):\n265         \"\"\"Return the output type of this expressions.\"\"\"\n266         output_field = self._resolve_output_field()\n267         if output_field is None:\n268             self._output_field_resolved_to_none = True\n269             raise FieldError('Cannot resolve expression type, unknown output_field')\n270         return output_field\n271 \n272     @cached_property\n273     def _output_field_or_none(self):\n274         \"\"\"\n275         Return the output field of this expression, or None if\n276         _resolve_output_field() didn't return an output type.\n277         \"\"\"\n278         try:\n279             return self.output_field\n280         except FieldError:\n281             if not self._output_field_resolved_to_none:\n282                 raise\n283 \n284     def _resolve_output_field(self):\n285         \"\"\"\n286         Attempt to infer the output type of the expression. If the output\n287         fields of all source fields match then, simply infer the same type\n288         here. This isn't always correct, but it makes sense most of the time.\n289 \n290         Consider the difference between `2 + 2` and `2 / 3`. Inferring\n291         the type here is a convenience for the common case. The user should\n292         supply their own output_field with more complex computations.\n293 \n294         If a source's output field resolves to None, exclude it from this check.\n295         If all sources are None, then an error is raised higher up the stack in\n296         the output_field property.\n297         \"\"\"\n298         sources_iter = (source for source in self.get_source_fields() if source is not None)\n299         for output_field in sources_iter:\n300             for source in sources_iter:\n301                 if not isinstance(output_field, source.__class__):\n302                     raise FieldError(\n303                         'Expression contains mixed types: %s, %s. You must '\n304                         'set output_field.' % (\n305                             output_field.__class__.__name__,\n306                             source.__class__.__name__,\n307                         )\n308                     )\n309             return output_field\n310 \n311     @staticmethod\n312     def _convert_value_noop(value, expression, connection):\n313         return value\n314 \n315     @cached_property\n316     def convert_value(self):\n317         \"\"\"\n318         Expressions provide their own converters because users have the option\n319         of manually specifying the output_field which may be a different type\n320         from the one the database returns.\n321         \"\"\"\n322         field = self.output_field\n323         internal_type = field.get_internal_type()\n324         if internal_type == 'FloatField':\n325             return lambda value, expression, connection: None if value is None else float(value)\n326         elif internal_type.endswith('IntegerField'):\n327             return lambda value, expression, connection: None if value is None else int(value)\n328         elif internal_type == 'DecimalField':\n329             return lambda value, expression, connection: None if value is None else Decimal(value)\n330         return self._convert_value_noop\n331 \n332     def get_lookup(self, lookup):\n333         return self.output_field.get_lookup(lookup)\n334 \n335     def get_transform(self, name):\n336         return self.output_field.get_transform(name)\n337 \n338     def relabeled_clone(self, change_map):\n339         clone = self.copy()\n340         clone.set_source_expressions([\n341             e.relabeled_clone(change_map) if e is not None else None\n342             for e in self.get_source_expressions()\n343         ])\n344         return clone\n345 \n346     def copy(self):\n347         return copy.copy(self)\n348 \n349     def get_group_by_cols(self, alias=None):\n350         if not self.contains_aggregate:\n351             return [self]\n352         cols = []\n353         for source in self.get_source_expressions():\n354             cols.extend(source.get_group_by_cols())\n355         return cols\n356 \n357     def get_source_fields(self):\n358         \"\"\"Return the underlying field types used by this aggregate.\"\"\"\n359         return [e._output_field_or_none for e in self.get_source_expressions()]\n360 \n361     def asc(self, **kwargs):\n362         return OrderBy(self, **kwargs)\n363 \n364     def desc(self, **kwargs):\n365         return OrderBy(self, descending=True, **kwargs)\n366 \n367     def reverse_ordering(self):\n368         return self\n369 \n370     def flatten(self):\n371         \"\"\"\n372         Recursively yield this expression and all subexpressions, in\n373         depth-first order.\n374         \"\"\"\n375         yield self\n376         for expr in self.get_source_expressions():\n377             if expr:\n378                 if hasattr(expr, 'flatten'):\n379                     yield from expr.flatten()\n380                 else:\n381                     yield expr\n382 \n383     def select_format(self, compiler, sql, params):\n384         \"\"\"\n385         Custom format for select clauses. For example, EXISTS expressions need\n386         to be wrapped in CASE WHEN on Oracle.\n387         \"\"\"\n388         if hasattr(self.output_field, 'select_format'):\n389             return self.output_field.select_format(compiler, sql, params)\n390         return sql, params\n391 \n392 \n393 @deconstructible\n394 class Expression(BaseExpression, Combinable):\n395     \"\"\"An expression that can be combined with other expressions.\"\"\"\n396 \n397     @cached_property\n398     def identity(self):\n399         constructor_signature = inspect.signature(self.__init__)\n400         args, kwargs = self._constructor_args\n401         signature = constructor_signature.bind_partial(*args, **kwargs)\n402         signature.apply_defaults()\n403         arguments = signature.arguments.items()\n404         identity = [self.__class__]\n405         for arg, value in arguments:\n406             if isinstance(value, fields.Field):\n407                 if value.name and value.model:\n408                     value = (value.model._meta.label, value.name)\n409                 else:\n410                     value = type(value)\n411             else:\n412                 value = make_hashable(value)\n413             identity.append((arg, value))\n414         return tuple(identity)\n415 \n416     def __eq__(self, other):\n417         if not isinstance(other, Expression):\n418             return NotImplemented\n419         return other.identity == self.identity\n420 \n421     def __hash__(self):\n422         return hash(self.identity)\n423 \n424 \n425 _connector_combinators = {\n426     connector: [\n427         (fields.IntegerField, fields.IntegerField, fields.IntegerField),\n428         (fields.IntegerField, fields.DecimalField, fields.DecimalField),\n429         (fields.DecimalField, fields.IntegerField, fields.DecimalField),\n430         (fields.IntegerField, fields.FloatField, fields.FloatField),\n431         (fields.FloatField, fields.IntegerField, fields.FloatField),\n432     ]\n433     for connector in (Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV)\n434 }\n435 \n436 \n437 @functools.lru_cache(maxsize=128)\n438 def _resolve_combined_type(connector, lhs_type, rhs_type):\n439     combinators = _connector_combinators.get(connector, ())\n440     for combinator_lhs_type, combinator_rhs_type, combined_type in combinators:\n441         if issubclass(lhs_type, combinator_lhs_type) and issubclass(rhs_type, combinator_rhs_type):\n442             return combined_type\n443 \n444 \n445 class CombinedExpression(SQLiteNumericMixin, Expression):\n446 \n447     def __init__(self, lhs, connector, rhs, output_field=None):\n448         super().__init__(output_field=output_field)\n449         self.connector = connector\n450         self.lhs = lhs\n451         self.rhs = rhs\n452 \n453     def __repr__(self):\n454         return \"<{}: {}>\".format(self.__class__.__name__, self)\n455 \n456     def __str__(self):\n457         return \"{} {} {}\".format(self.lhs, self.connector, self.rhs)\n458 \n459     def get_source_expressions(self):\n460         return [self.lhs, self.rhs]\n461 \n462     def set_source_expressions(self, exprs):\n463         self.lhs, self.rhs = exprs\n464 \n465     def _resolve_output_field(self):\n466         try:\n467             return super()._resolve_output_field()\n468         except FieldError:\n469             combined_type = _resolve_combined_type(\n470                 self.connector,\n471                 type(self.lhs.output_field),\n472                 type(self.rhs.output_field),\n473             )\n474             if combined_type is None:\n475                 raise\n476             return combined_type()\n477 \n478     def as_sql(self, compiler, connection):\n479         expressions = []\n480         expression_params = []\n481         sql, params = compiler.compile(self.lhs)\n482         expressions.append(sql)\n483         expression_params.extend(params)\n484         sql, params = compiler.compile(self.rhs)\n485         expressions.append(sql)\n486         expression_params.extend(params)\n487         # order of precedence\n488         expression_wrapper = '(%s)'\n489         sql = connection.ops.combine_expression(self.connector, expressions)\n490         return expression_wrapper % sql, expression_params\n491 \n492     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n493         lhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n494         rhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n495         if not isinstance(self, (DurationExpression, TemporalSubtraction)):\n496             try:\n497                 lhs_type = lhs.output_field.get_internal_type()\n498             except (AttributeError, FieldError):\n499                 lhs_type = None\n500             try:\n501                 rhs_type = rhs.output_field.get_internal_type()\n502             except (AttributeError, FieldError):\n503                 rhs_type = None\n504             if 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:\n505                 return DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(\n506                     query, allow_joins, reuse, summarize, for_save,\n507                 )\n508             datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}\n509             if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:\n510                 return TemporalSubtraction(self.lhs, self.rhs).resolve_expression(\n511                     query, allow_joins, reuse, summarize, for_save,\n512                 )\n513         c = self.copy()\n514         c.is_summary = summarize\n515         c.lhs = lhs\n516         c.rhs = rhs\n517         return c\n518 \n519 \n520 class DurationExpression(CombinedExpression):\n521     def compile(self, side, compiler, connection):\n522         try:\n523             output = side.output_field\n524         except FieldError:\n525             pass\n526         else:\n527             if output.get_internal_type() == 'DurationField':\n528                 sql, params = compiler.compile(side)\n529                 return connection.ops.format_for_duration_arithmetic(sql), params\n530         return compiler.compile(side)\n531 \n532     def as_sql(self, compiler, connection):\n533         if connection.features.has_native_duration_field:\n534             return super().as_sql(compiler, connection)\n535         connection.ops.check_expression_support(self)\n536         expressions = []\n537         expression_params = []\n538         sql, params = self.compile(self.lhs, compiler, connection)\n539         expressions.append(sql)\n540         expression_params.extend(params)\n541         sql, params = self.compile(self.rhs, compiler, connection)\n542         expressions.append(sql)\n543         expression_params.extend(params)\n544         # order of precedence\n545         expression_wrapper = '(%s)'\n546         sql = connection.ops.combine_duration_expression(self.connector, expressions)\n547         return expression_wrapper % sql, expression_params\n548 \n549     def as_sqlite(self, compiler, connection, **extra_context):\n550         sql, params = self.as_sql(compiler, connection, **extra_context)\n551         if self.connector in {Combinable.MUL, Combinable.DIV}:\n552             try:\n553                 lhs_type = self.lhs.output_field.get_internal_type()\n554                 rhs_type = self.rhs.output_field.get_internal_type()\n555             except (AttributeError, FieldError):\n556                 pass\n557             else:\n558                 allowed_fields = {\n559                     'DecimalField', 'DurationField', 'FloatField', 'IntegerField',\n560                 }\n561                 if lhs_type not in allowed_fields or rhs_type not in allowed_fields:\n562                     raise DatabaseError(\n563                         f'Invalid arguments for operator {self.connector}.'\n564                     )\n565         return sql, params\n566 \n567 \n568 class TemporalSubtraction(CombinedExpression):\n569     output_field = fields.DurationField()\n570 \n571     def __init__(self, lhs, rhs):\n572         super().__init__(lhs, self.SUB, rhs)\n573 \n574     def as_sql(self, compiler, connection):\n575         connection.ops.check_expression_support(self)\n576         lhs = compiler.compile(self.lhs)\n577         rhs = compiler.compile(self.rhs)\n578         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)\n579 \n580 \n581 @deconstructible(path='django.db.models.F')\n582 class F(Combinable):\n583     \"\"\"An object capable of resolving references to existing query objects.\"\"\"\n584 \n585     def __init__(self, name):\n586         \"\"\"\n587         Arguments:\n588          * name: the name of the field this expression references\n589         \"\"\"\n590         self.name = name\n591 \n592     def __repr__(self):\n593         return \"{}({})\".format(self.__class__.__name__, self.name)\n594 \n595     def resolve_expression(self, query=None, allow_joins=True, reuse=None,\n596                            summarize=False, for_save=False):\n597         return query.resolve_ref(self.name, allow_joins, reuse, summarize)\n598 \n599     def asc(self, **kwargs):\n600         return OrderBy(self, **kwargs)\n601 \n602     def desc(self, **kwargs):\n603         return OrderBy(self, descending=True, **kwargs)\n604 \n605     def __eq__(self, other):\n606         return self.__class__ == other.__class__ and self.name == other.name\n607 \n608     def __hash__(self):\n609         return hash(self.name)\n610 \n611 \n612 class ResolvedOuterRef(F):\n613     \"\"\"\n614     An object that contains a reference to an outer query.\n615 \n616     In this case, the reference to the outer query has been resolved because\n617     the inner query has been used as a subquery.\n618     \"\"\"\n619     contains_aggregate = False\n620 \n621     def as_sql(self, *args, **kwargs):\n622         raise ValueError(\n623             'This queryset contains a reference to an outer query and may '\n624             'only be used in a subquery.'\n625         )\n626 \n627     def resolve_expression(self, *args, **kwargs):\n628         col = super().resolve_expression(*args, **kwargs)\n629         # FIXME: Rename possibly_multivalued to multivalued and fix detection\n630         # for non-multivalued JOINs (e.g. foreign key fields). This should take\n631         # into account\u00a0only many-to-many and one-to-many relationships.\n632         col.possibly_multivalued = LOOKUP_SEP in self.name\n633         return col\n634 \n635     def relabeled_clone(self, relabels):\n636         return self\n637 \n638     def get_group_by_cols(self, alias=None):\n639         return []\n640 \n641 \n642 class OuterRef(F):\n643     contains_aggregate = False\n644 \n645     def resolve_expression(self, *args, **kwargs):\n646         if isinstance(self.name, self.__class__):\n647             return self.name\n648         return ResolvedOuterRef(self.name)\n649 \n650     def relabeled_clone(self, relabels):\n651         return self\n652 \n653 \n654 @deconstructible(path='django.db.models.Func')\n655 class Func(SQLiteNumericMixin, Expression):\n656     \"\"\"An SQL function call.\"\"\"\n657     function = None\n658     template = '%(function)s(%(expressions)s)'\n659     arg_joiner = ', '\n660     arity = None  # The number of arguments the function accepts.\n661 \n662     def __init__(self, *expressions, output_field=None, **extra):\n663         if self.arity is not None and len(expressions) != self.arity:\n664             raise TypeError(\n665                 \"'%s' takes exactly %s %s (%s given)\" % (\n666                     self.__class__.__name__,\n667                     self.arity,\n668                     \"argument\" if self.arity == 1 else \"arguments\",\n669                     len(expressions),\n670                 )\n671             )\n672         super().__init__(output_field=output_field)\n673         self.source_expressions = self._parse_expressions(*expressions)\n674         self.extra = extra\n675 \n676     def __repr__(self):\n677         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n678         extra = {**self.extra, **self._get_repr_options()}\n679         if extra:\n680             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))\n681             return \"{}({}, {})\".format(self.__class__.__name__, args, extra)\n682         return \"{}({})\".format(self.__class__.__name__, args)\n683 \n684     def _get_repr_options(self):\n685         \"\"\"Return a dict of extra __init__() options to include in the repr.\"\"\"\n686         return {}\n687 \n688     def get_source_expressions(self):\n689         return self.source_expressions\n690 \n691     def set_source_expressions(self, exprs):\n692         self.source_expressions = exprs\n693 \n694     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n695         c = self.copy()\n696         c.is_summary = summarize\n697         for pos, arg in enumerate(c.source_expressions):\n698             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n699         return c\n700 \n701     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):\n702         connection.ops.check_expression_support(self)\n703         sql_parts = []\n704         params = []\n705         for arg in self.source_expressions:\n706             try:\n707                 arg_sql, arg_params = compiler.compile(arg)\n708             except EmptyResultSet:\n709                 empty_result_set_value = getattr(arg, 'empty_result_set_value', NotImplemented)\n710                 if empty_result_set_value is NotImplemented:\n711                     raise\n712                 arg_sql, arg_params = compiler.compile(Value(empty_result_set_value))\n713             sql_parts.append(arg_sql)\n714             params.extend(arg_params)\n715         data = {**self.extra, **extra_context}\n716         # Use the first supplied value in this order: the parameter to this\n717         # method, a value supplied in __init__()'s **extra (the value in\n718         # `data`), or the value defined on the class.\n719         if function is not None:\n720             data['function'] = function\n721         else:\n722             data.setdefault('function', self.function)\n723         template = template or data.get('template', self.template)\n724         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)\n725         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)\n726         return template % data, params\n727 \n728     def copy(self):\n729         copy = super().copy()\n730         copy.source_expressions = self.source_expressions[:]\n731         copy.extra = self.extra.copy()\n732         return copy\n733 \n734 \n735 @deconstructible(path='django.db.models.Value')\n736 class Value(SQLiteNumericMixin, Expression):\n737     \"\"\"Represent a wrapped value as a node within an expression.\"\"\"\n738     # Provide a default value for `for_save` in order to allow unresolved\n739     # instances to be compiled until a decision is taken in #25425.\n740     for_save = False\n741 \n742     def __init__(self, value, output_field=None):\n743         \"\"\"\n744         Arguments:\n745          * value: the value this expression represents. The value will be\n746            added into the sql parameter list and properly quoted.\n747 \n748          * output_field: an instance of the model field type that this\n749            expression will return, such as IntegerField() or CharField().\n750         \"\"\"\n751         super().__init__(output_field=output_field)\n752         self.value = value\n753 \n754     def __repr__(self):\n755         return f'{self.__class__.__name__}({self.value!r})'\n756 \n757     def as_sql(self, compiler, connection):\n758         connection.ops.check_expression_support(self)\n759         val = self.value\n760         output_field = self._output_field_or_none\n761         if output_field is not None:\n762             if self.for_save:\n763                 val = output_field.get_db_prep_save(val, connection=connection)\n764             else:\n765                 val = output_field.get_db_prep_value(val, connection=connection)\n766             if hasattr(output_field, 'get_placeholder'):\n767                 return output_field.get_placeholder(val, compiler, connection), [val]\n768         if val is None:\n769             # cx_Oracle does not always convert None to the appropriate\n770             # NULL type (like in case expressions using numbers), so we\n771             # use a literal SQL NULL\n772             return 'NULL', []\n773         return '%s', [val]\n774 \n775     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n776         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n777         c.for_save = for_save\n778         return c\n779 \n780     def get_group_by_cols(self, alias=None):\n781         return []\n782 \n783     def _resolve_output_field(self):\n784         if isinstance(self.value, str):\n785             return fields.CharField()\n786         if isinstance(self.value, bool):\n787             return fields.BooleanField()\n788         if isinstance(self.value, int):\n789             return fields.IntegerField()\n790         if isinstance(self.value, float):\n791             return fields.FloatField()\n792         if isinstance(self.value, datetime.datetime):\n793             return fields.DateTimeField()\n794         if isinstance(self.value, datetime.date):\n795             return fields.DateField()\n796         if isinstance(self.value, datetime.time):\n797             return fields.TimeField()\n798         if isinstance(self.value, datetime.timedelta):\n799             return fields.DurationField()\n800         if isinstance(self.value, Decimal):\n801             return fields.DecimalField()\n802         if isinstance(self.value, bytes):\n803             return fields.BinaryField()\n804         if isinstance(self.value, UUID):\n805             return fields.UUIDField()\n806 \n807     @property\n808     def empty_result_set_value(self):\n809         return self.value\n810 \n811 \n812 class RawSQL(Expression):\n813     def __init__(self, sql, params, output_field=None):\n814         if output_field is None:\n815             output_field = fields.Field()\n816         self.sql, self.params = sql, params\n817         super().__init__(output_field=output_field)\n818 \n819     def __repr__(self):\n820         return \"{}({}, {})\".format(self.__class__.__name__, self.sql, self.params)\n821 \n822     def as_sql(self, compiler, connection):\n823         return '(%s)' % self.sql, self.params\n824 \n825     def get_group_by_cols(self, alias=None):\n826         return [self]\n827 \n828     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n829         # Resolve parents fields used in raw SQL.\n830         for parent in query.model._meta.get_parent_list():\n831             for parent_field in parent._meta.local_fields:\n832                 _, column_name = parent_field.get_attname_column()\n833                 if column_name.lower() in self.sql.lower():\n834                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)\n835                     break\n836         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)\n837 \n838 \n839 class Star(Expression):\n840     def __repr__(self):\n841         return \"'*'\"\n842 \n843     def as_sql(self, compiler, connection):\n844         return '*', []\n845 \n846 \n847 class Col(Expression):\n848 \n849     contains_column_references = True\n850     possibly_multivalued = False\n851 \n852     def __init__(self, alias, target, output_field=None):\n853         if output_field is None:\n854             output_field = target\n855         super().__init__(output_field=output_field)\n856         self.alias, self.target = alias, target\n857 \n858     def __repr__(self):\n859         alias, target = self.alias, self.target\n860         identifiers = (alias, str(target)) if alias else (str(target),)\n861         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))\n862 \n863     def as_sql(self, compiler, connection):\n864         alias, column = self.alias, self.target.column\n865         identifiers = (alias, column) if alias else (column,)\n866         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n867         return sql, []\n868 \n869     def relabeled_clone(self, relabels):\n870         if self.alias is None:\n871             return self\n872         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)\n873 \n874     def get_group_by_cols(self, alias=None):\n875         return [self]\n876 \n877     def get_db_converters(self, connection):\n878         if self.target == self.output_field:\n879             return self.output_field.get_db_converters(connection)\n880         return (self.output_field.get_db_converters(connection) +\n881                 self.target.get_db_converters(connection))\n882 \n883 \n884 class Ref(Expression):\n885     \"\"\"\n886     Reference to column alias of the query. For example, Ref('sum_cost') in\n887     qs.annotate(sum_cost=Sum('cost')) query.\n888     \"\"\"\n889     def __init__(self, refs, source):\n890         super().__init__()\n891         self.refs, self.source = refs, source\n892 \n893     def __repr__(self):\n894         return \"{}({}, {})\".format(self.__class__.__name__, self.refs, self.source)\n895 \n896     def get_source_expressions(self):\n897         return [self.source]\n898 \n899     def set_source_expressions(self, exprs):\n900         self.source, = exprs\n901 \n902     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n903         # The sub-expression `source` has already been resolved, as this is\n904         # just a reference to the name of `source`.\n905         return self\n906 \n907     def relabeled_clone(self, relabels):\n908         return self\n909 \n910     def as_sql(self, compiler, connection):\n911         return connection.ops.quote_name(self.refs), []\n912 \n913     def get_group_by_cols(self, alias=None):\n914         return [self]\n915 \n916 \n917 class ExpressionList(Func):\n918     \"\"\"\n919     An expression containing multiple expressions. Can be used to provide a\n920     list of expressions as an argument to another expression, like a partition\n921     clause.\n922     \"\"\"\n923     template = '%(expressions)s'\n924 \n925     def __init__(self, *expressions, **extra):\n926         if not expressions:\n927             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)\n928         super().__init__(*expressions, **extra)\n929 \n930     def __str__(self):\n931         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)\n932 \n933     def as_sqlite(self, compiler, connection, **extra_context):\n934         # Casting to numeric is unnecessary.\n935         return self.as_sql(compiler, connection, **extra_context)\n936 \n937 \n938 class OrderByList(Func):\n939     template = 'ORDER BY %(expressions)s'\n940 \n941     def __init__(self, *expressions, **extra):\n942         expressions = (\n943             (\n944                 OrderBy(F(expr[1:]), descending=True)\n945                 if isinstance(expr, str) and expr[0] == '-'\n946                 else expr\n947             )\n948             for expr in expressions\n949         )\n950         super().__init__(*expressions, **extra)\n951 \n952     def as_sql(self, *args, **kwargs):\n953         if not self.source_expressions:\n954             return '', ()\n955         return super().as_sql(*args, **kwargs)\n956 \n957 \n958 @deconstructible(path='django.db.models.ExpressionWrapper')\n959 class ExpressionWrapper(SQLiteNumericMixin, Expression):\n960     \"\"\"\n961     An expression that can wrap another expression so that it can provide\n962     extra context to the inner expression, such as the output_field.\n963     \"\"\"\n964 \n965     def __init__(self, expression, output_field):\n966         super().__init__(output_field=output_field)\n967         self.expression = expression\n968 \n969     def set_source_expressions(self, exprs):\n970         self.expression = exprs[0]\n971 \n972     def get_source_expressions(self):\n973         return [self.expression]\n974 \n975     def get_group_by_cols(self, alias=None):\n976         if isinstance(self.expression, Expression):\n977             expression = self.expression.copy()\n978             expression.output_field = self.output_field\n979             return expression.get_group_by_cols(alias=alias)\n980         # For non-expressions e.g. an SQL WHERE clause, the entire\n981         # `expression` must be included in the GROUP BY clause.\n982         return super().get_group_by_cols()\n983 \n984     def as_sql(self, compiler, connection):\n985         return compiler.compile(self.expression)\n986 \n987     def __repr__(self):\n988         return \"{}({})\".format(self.__class__.__name__, self.expression)\n989 \n990 \n991 @deconstructible(path='django.db.models.When')\n992 class When(Expression):\n993     template = 'WHEN %(condition)s THEN %(result)s'\n994     # This isn't a complete conditional expression, must be used in Case().\n995     conditional = False\n996 \n997     def __init__(self, condition=None, then=None, **lookups):\n998         if lookups:\n999             if condition is None:\n1000                 condition, lookups = Q(**lookups), None\n1001             elif getattr(condition, 'conditional', False):\n1002                 condition, lookups = Q(condition, **lookups), None\n1003         if condition is None or not getattr(condition, 'conditional', False) or lookups:\n1004             raise TypeError(\n1005                 'When() supports a Q object, a boolean expression, or lookups '\n1006                 'as a condition.'\n1007             )\n1008         if isinstance(condition, Q) and not condition:\n1009             raise ValueError(\"An empty Q() can't be used as a When() condition.\")\n1010         super().__init__(output_field=None)\n1011         self.condition = condition\n1012         self.result = self._parse_expressions(then)[0]\n1013 \n1014     def __str__(self):\n1015         return \"WHEN %r THEN %r\" % (self.condition, self.result)\n1016 \n1017     def __repr__(self):\n1018         return \"<%s: %s>\" % (self.__class__.__name__, self)\n1019 \n1020     def get_source_expressions(self):\n1021         return [self.condition, self.result]\n1022 \n1023     def set_source_expressions(self, exprs):\n1024         self.condition, self.result = exprs\n1025 \n1026     def get_source_fields(self):\n1027         # We're only interested in the fields of the result expressions.\n1028         return [self.result._output_field_or_none]\n1029 \n1030     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n1031         c = self.copy()\n1032         c.is_summary = summarize\n1033         if hasattr(c.condition, 'resolve_expression'):\n1034             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)\n1035         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n1036         return c\n1037 \n1038     def as_sql(self, compiler, connection, template=None, **extra_context):\n1039         connection.ops.check_expression_support(self)\n1040         template_params = extra_context\n1041         sql_params = []\n1042         condition_sql, condition_params = compiler.compile(self.condition)\n1043         template_params['condition'] = condition_sql\n1044         sql_params.extend(condition_params)\n1045         result_sql, result_params = compiler.compile(self.result)\n1046         template_params['result'] = result_sql\n1047         sql_params.extend(result_params)\n1048         template = template or self.template\n1049         return template % template_params, sql_params\n1050 \n1051     def get_group_by_cols(self, alias=None):\n1052         # This is not a complete expression and cannot be used in GROUP BY.\n1053         cols = []\n1054         for source in self.get_source_expressions():\n1055             cols.extend(source.get_group_by_cols())\n1056         return cols\n1057 \n1058 \n1059 @deconstructible(path='django.db.models.Case')\n1060 class Case(SQLiteNumericMixin, Expression):\n1061     \"\"\"\n1062     An SQL searched CASE expression:\n1063 \n1064         CASE\n1065             WHEN n > 0\n1066                 THEN 'positive'\n1067             WHEN n < 0\n1068                 THEN 'negative'\n1069             ELSE 'zero'\n1070         END\n1071     \"\"\"\n1072     template = 'CASE %(cases)s ELSE %(default)s END'\n1073     case_joiner = ' '\n1074 \n1075     def __init__(self, *cases, default=None, output_field=None, **extra):\n1076         if not all(isinstance(case, When) for case in cases):\n1077             raise TypeError(\"Positional arguments must all be When objects.\")\n1078         super().__init__(output_field)\n1079         self.cases = list(cases)\n1080         self.default = self._parse_expressions(default)[0]\n1081         self.extra = extra\n1082 \n1083     def __str__(self):\n1084         return \"CASE %s, ELSE %r\" % (', '.join(str(c) for c in self.cases), self.default)\n1085 \n1086     def __repr__(self):\n1087         return \"<%s: %s>\" % (self.__class__.__name__, self)\n1088 \n1089     def get_source_expressions(self):\n1090         return self.cases + [self.default]\n1091 \n1092     def set_source_expressions(self, exprs):\n1093         *self.cases, self.default = exprs\n1094 \n1095     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n1096         c = self.copy()\n1097         c.is_summary = summarize\n1098         for pos, case in enumerate(c.cases):\n1099             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n1100         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)\n1101         return c\n1102 \n1103     def copy(self):\n1104         c = super().copy()\n1105         c.cases = c.cases[:]\n1106         return c\n1107 \n1108     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):\n1109         connection.ops.check_expression_support(self)\n1110         if not self.cases:\n1111             return compiler.compile(self.default)\n1112         template_params = {**self.extra, **extra_context}\n1113         case_parts = []\n1114         sql_params = []\n1115         for case in self.cases:\n1116             try:\n1117                 case_sql, case_params = compiler.compile(case)\n1118             except EmptyResultSet:\n1119                 continue\n1120             case_parts.append(case_sql)\n1121             sql_params.extend(case_params)\n1122         default_sql, default_params = compiler.compile(self.default)\n1123         if not case_parts:\n1124             return default_sql, default_params\n1125         case_joiner = case_joiner or self.case_joiner\n1126         template_params['cases'] = case_joiner.join(case_parts)\n1127         template_params['default'] = default_sql\n1128         sql_params.extend(default_params)\n1129         template = template or template_params.get('template', self.template)\n1130         sql = template % template_params\n1131         if self._output_field_or_none is not None:\n1132             sql = connection.ops.unification_cast_sql(self.output_field) % sql\n1133         return sql, sql_params\n1134 \n1135     def get_group_by_cols(self, alias=None):\n1136         if not self.cases:\n1137             return self.default.get_group_by_cols(alias)\n1138         return super().get_group_by_cols(alias)\n1139 \n1140 \n1141 class Subquery(BaseExpression, Combinable):\n1142     \"\"\"\n1143     An explicit subquery. It may contain OuterRef() references to the outer\n1144     query which will be resolved when it is applied to that query.\n1145     \"\"\"\n1146     template = '(%(subquery)s)'\n1147     contains_aggregate = False\n1148     empty_result_set_value = None\n1149 \n1150     def __init__(self, queryset, output_field=None, **extra):\n1151         # Allow the usage of both QuerySet and sql.Query objects.\n1152         self.query = getattr(queryset, 'query', queryset).clone()\n1153         self.query.subquery = True\n1154         self.extra = extra\n1155         super().__init__(output_field)\n1156 \n1157     def get_source_expressions(self):\n1158         return [self.query]\n1159 \n1160     def set_source_expressions(self, exprs):\n1161         self.query = exprs[0]\n1162 \n1163     def _resolve_output_field(self):\n1164         return self.query.output_field\n1165 \n1166     def copy(self):\n1167         clone = super().copy()\n1168         clone.query = clone.query.clone()\n1169         return clone\n1170 \n1171     @property\n1172     def external_aliases(self):\n1173         return self.query.external_aliases\n1174 \n1175     def get_external_cols(self):\n1176         return self.query.get_external_cols()\n1177 \n1178     def as_sql(self, compiler, connection, template=None, query=None, **extra_context):\n1179         connection.ops.check_expression_support(self)\n1180         template_params = {**self.extra, **extra_context}\n1181         query = query or self.query\n1182         subquery_sql, sql_params = query.as_sql(compiler, connection)\n1183         template_params['subquery'] = subquery_sql[1:-1]\n1184 \n1185         template = template or template_params.get('template', self.template)\n1186         sql = template % template_params\n1187         return sql, sql_params\n1188 \n1189     def get_group_by_cols(self, alias=None):\n1190         # If this expression is referenced by an alias for an explicit GROUP BY\n1191         # through values() a reference to this expression and not the\n1192         # underlying .query must be returned to ensure external column\n1193         # references are not grouped against as well.\n1194         if alias:\n1195             return [Ref(alias, self)]\n1196         return self.query.get_group_by_cols()\n1197 \n1198 \n1199 class Exists(Subquery):\n1200     template = 'EXISTS(%(subquery)s)'\n1201     output_field = fields.BooleanField()\n1202 \n1203     def __init__(self, queryset, negated=False, **kwargs):\n1204         self.negated = negated\n1205         super().__init__(queryset, **kwargs)\n1206 \n1207     def __invert__(self):\n1208         clone = self.copy()\n1209         clone.negated = not self.negated\n1210         return clone\n1211 \n1212     def as_sql(self, compiler, connection, template=None, **extra_context):\n1213         query = self.query.exists(using=connection.alias)\n1214         sql, params = super().as_sql(\n1215             compiler,\n1216             connection,\n1217             template=template,\n1218             query=query,\n1219             **extra_context,\n1220         )\n1221         if self.negated:\n1222             sql = 'NOT {}'.format(sql)\n1223         return sql, params\n1224 \n1225     def select_format(self, compiler, sql, params):\n1226         # Wrap EXISTS() with a CASE WHEN expression if a database backend\n1227         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP\n1228         # BY list.\n1229         if not compiler.connection.features.supports_boolean_expr_in_select_clause:\n1230             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n1231         return sql, params\n1232 \n1233 \n1234 @deconstructible(path='django.db.models.OrderBy')\n1235 class OrderBy(Expression):\n1236     template = '%(expression)s %(ordering)s'\n1237     conditional = False\n1238 \n1239     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):\n1240         if nulls_first and nulls_last:\n1241             raise ValueError('nulls_first and nulls_last are mutually exclusive')\n1242         self.nulls_first = nulls_first\n1243         self.nulls_last = nulls_last\n1244         self.descending = descending\n1245         if not hasattr(expression, 'resolve_expression'):\n1246             raise ValueError('expression must be an expression type')\n1247         self.expression = expression\n1248 \n1249     def __repr__(self):\n1250         return \"{}({}, descending={})\".format(\n1251             self.__class__.__name__, self.expression, self.descending)\n1252 \n1253     def set_source_expressions(self, exprs):\n1254         self.expression = exprs[0]\n1255 \n1256     def get_source_expressions(self):\n1257         return [self.expression]\n1258 \n1259     def as_sql(self, compiler, connection, template=None, **extra_context):\n1260         template = template or self.template\n1261         if connection.features.supports_order_by_nulls_modifier:\n1262             if self.nulls_last:\n1263                 template = '%s NULLS LAST' % template\n1264             elif self.nulls_first:\n1265                 template = '%s NULLS FIRST' % template\n1266         else:\n1267             if self.nulls_last and not (\n1268                 self.descending and connection.features.order_by_nulls_first\n1269             ):\n1270                 template = '%%(expression)s IS NULL, %s' % template\n1271             elif self.nulls_first and not (\n1272                 not self.descending and connection.features.order_by_nulls_first\n1273             ):\n1274                 template = '%%(expression)s IS NOT NULL, %s' % template\n1275         connection.ops.check_expression_support(self)\n1276         expression_sql, params = compiler.compile(self.expression)\n1277         placeholders = {\n1278             'expression': expression_sql,\n1279             'ordering': 'DESC' if self.descending else 'ASC',\n1280             **extra_context,\n1281         }\n1282         params *= template.count('%(expression)s')\n1283         return (template % placeholders).rstrip(), params\n1284 \n1285     def as_oracle(self, compiler, connection):\n1286         # Oracle doesn't allow ORDER BY EXISTS() or filters unless it's wrapped\n1287         # in a CASE WHEN.\n1288         if connection.ops.conditional_expression_supported_in_where_clause(self.expression):\n1289             copy = self.copy()\n1290             copy.expression = Case(\n1291                 When(self.expression, then=True),\n1292                 default=False,\n1293             )\n1294             return copy.as_sql(compiler, connection)\n1295         return self.as_sql(compiler, connection)\n1296 \n1297     def get_group_by_cols(self, alias=None):\n1298         cols = []\n1299         for source in self.get_source_expressions():\n1300             cols.extend(source.get_group_by_cols())\n1301         return cols\n1302 \n1303     def reverse_ordering(self):\n1304         self.descending = not self.descending\n1305         if self.nulls_first or self.nulls_last:\n1306             self.nulls_first = not self.nulls_first\n1307             self.nulls_last = not self.nulls_last\n1308         return self\n1309 \n1310     def asc(self):\n1311         self.descending = False\n1312 \n1313     def desc(self):\n1314         self.descending = True\n1315 \n1316 \n1317 class Window(SQLiteNumericMixin, Expression):\n1318     template = '%(expression)s OVER (%(window)s)'\n1319     # Although the main expression may either be an aggregate or an\n1320     # expression with an aggregate function, the GROUP BY that will\n1321     # be introduced in the query as a result is not desired.\n1322     contains_aggregate = False\n1323     contains_over_clause = True\n1324     filterable = False\n1325 \n1326     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):\n1327         self.partition_by = partition_by\n1328         self.order_by = order_by\n1329         self.frame = frame\n1330 \n1331         if not getattr(expression, 'window_compatible', False):\n1332             raise ValueError(\n1333                 \"Expression '%s' isn't compatible with OVER clauses.\" %\n1334                 expression.__class__.__name__\n1335             )\n1336 \n1337         if self.partition_by is not None:\n1338             if not isinstance(self.partition_by, (tuple, list)):\n1339                 self.partition_by = (self.partition_by,)\n1340             self.partition_by = ExpressionList(*self.partition_by)\n1341 \n1342         if self.order_by is not None:\n1343             if isinstance(self.order_by, (list, tuple)):\n1344                 self.order_by = OrderByList(*self.order_by)\n1345             elif isinstance(self.order_by, (BaseExpression, str)):\n1346                 self.order_by = OrderByList(self.order_by)\n1347             else:\n1348                 raise ValueError(\n1349                     'Window.order_by must be either a string reference to a '\n1350                     'field, an expression, or a list or tuple of them.'\n1351                 )\n1352         super().__init__(output_field=output_field)\n1353         self.source_expression = self._parse_expressions(expression)[0]\n1354 \n1355     def _resolve_output_field(self):\n1356         return self.source_expression.output_field\n1357 \n1358     def get_source_expressions(self):\n1359         return [self.source_expression, self.partition_by, self.order_by, self.frame]\n1360 \n1361     def set_source_expressions(self, exprs):\n1362         self.source_expression, self.partition_by, self.order_by, self.frame = exprs\n1363 \n1364     def as_sql(self, compiler, connection, template=None):\n1365         connection.ops.check_expression_support(self)\n1366         if not connection.features.supports_over_clause:\n1367             raise NotSupportedError('This backend does not support window expressions.')\n1368         expr_sql, params = compiler.compile(self.source_expression)\n1369         window_sql, window_params = [], []\n1370 \n1371         if self.partition_by is not None:\n1372             sql_expr, sql_params = self.partition_by.as_sql(\n1373                 compiler=compiler, connection=connection,\n1374                 template='PARTITION BY %(expressions)s',\n1375             )\n1376             window_sql.append(sql_expr)\n1377             window_params.extend(sql_params)\n1378 \n1379         if self.order_by is not None:\n1380             order_sql, order_params = compiler.compile(self.order_by)\n1381             window_sql.append(order_sql)\n1382             window_params.extend(order_params)\n1383 \n1384         if self.frame:\n1385             frame_sql, frame_params = compiler.compile(self.frame)\n1386             window_sql.append(frame_sql)\n1387             window_params.extend(frame_params)\n1388 \n1389         params.extend(window_params)\n1390         template = template or self.template\n1391 \n1392         return template % {\n1393             'expression': expr_sql,\n1394             'window': ' '.join(window_sql).strip()\n1395         }, params\n1396 \n1397     def as_sqlite(self, compiler, connection):\n1398         if isinstance(self.output_field, fields.DecimalField):\n1399             # Casting to numeric must be outside of the window expression.\n1400             copy = self.copy()\n1401             source_expressions = copy.get_source_expressions()\n1402             source_expressions[0].output_field = fields.FloatField()\n1403             copy.set_source_expressions(source_expressions)\n1404             return super(Window, copy).as_sqlite(compiler, connection)\n1405         return self.as_sql(compiler, connection)\n1406 \n1407     def __str__(self):\n1408         return '{} OVER ({}{}{})'.format(\n1409             str(self.source_expression),\n1410             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',\n1411             str(self.order_by or ''),\n1412             str(self.frame or ''),\n1413         )\n1414 \n1415     def __repr__(self):\n1416         return '<%s: %s>' % (self.__class__.__name__, self)\n1417 \n1418     def get_group_by_cols(self, alias=None):\n1419         return []\n1420 \n1421 \n1422 class WindowFrame(Expression):\n1423     \"\"\"\n1424     Model the frame clause in window expressions. There are two types of frame\n1425     clauses which are subclasses, however, all processing and validation (by no\n1426     means intended to be complete) is done here. Thus, providing an end for a\n1427     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last\n1428     row in the frame).\n1429     \"\"\"\n1430     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'\n1431 \n1432     def __init__(self, start=None, end=None):\n1433         self.start = Value(start)\n1434         self.end = Value(end)\n1435 \n1436     def set_source_expressions(self, exprs):\n1437         self.start, self.end = exprs\n1438 \n1439     def get_source_expressions(self):\n1440         return [self.start, self.end]\n1441 \n1442     def as_sql(self, compiler, connection):\n1443         connection.ops.check_expression_support(self)\n1444         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)\n1445         return self.template % {\n1446             'frame_type': self.frame_type,\n1447             'start': start,\n1448             'end': end,\n1449         }, []\n1450 \n1451     def __repr__(self):\n1452         return '<%s: %s>' % (self.__class__.__name__, self)\n1453 \n1454     def get_group_by_cols(self, alias=None):\n1455         return []\n1456 \n1457     def __str__(self):\n1458         if self.start.value is not None and self.start.value < 0:\n1459             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)\n1460         elif self.start.value is not None and self.start.value == 0:\n1461             start = connection.ops.CURRENT_ROW\n1462         else:\n1463             start = connection.ops.UNBOUNDED_PRECEDING\n1464 \n1465         if self.end.value is not None and self.end.value > 0:\n1466             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)\n1467         elif self.end.value is not None and self.end.value == 0:\n1468             end = connection.ops.CURRENT_ROW\n1469         else:\n1470             end = connection.ops.UNBOUNDED_FOLLOWING\n1471         return self.template % {\n1472             'frame_type': self.frame_type,\n1473             'start': start,\n1474             'end': end,\n1475         }\n1476 \n1477     def window_frame_start_end(self, connection, start, end):\n1478         raise NotImplementedError('Subclasses must implement window_frame_start_end().')\n1479 \n1480 \n1481 class RowRange(WindowFrame):\n1482     frame_type = 'ROWS'\n1483 \n1484     def window_frame_start_end(self, connection, start, end):\n1485         return connection.ops.window_frame_rows_start_end(start, end)\n1486 \n1487 \n1488 class ValueRange(WindowFrame):\n1489     frame_type = 'RANGE'\n1490 \n1491     def window_frame_start_end(self, connection, start, end):\n1492         return connection.ops.window_frame_range_start_end(start, end)\n",
        "intended_behavior": "In the implementation of `Subquery` and possibly other related expressions, there should be clear handling or documentation of how these expressions can be used with `union` and `OR` (`|`) operations. If there's a limitation within the Django ORM that prevents the direct use of `OuterRef` in conjunction with `union`, then a workaround or clear guidelines should be provided. For example, enhancing the `Subquery` expression to internally handle or adapt to `union` directives in a way that the outer references do not lose their context or lead to SQL generation errors."
    }
]