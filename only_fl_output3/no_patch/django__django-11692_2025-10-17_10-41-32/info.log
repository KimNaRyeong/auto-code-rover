2025-10-17 10:41:33.650 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 10:41:38.545 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=301, output_tokens=12, cost=0.003370
2025-10-17 10:41:38.546 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 10:41:38.550 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:41:50.195 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=607, output_tokens=429, cost=0.018940
2025-10-17 10:41:50.204 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:41:53.245 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=783, output_tokens=61, cost=0.009660
2025-10-17 10:41:53.246 | DEBUG    | Extracted a valid json.
2025-10-17 10:41:53.246 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Document\")",
        "search_code(\"Subquery\")",
        "search_code(\"OuterRef\")",
        "search_code(\".union(\")",
        "search_code(\" | \")"
    ],
    "bug_locations": []
}
2025-10-17 10:41:53.468 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 10:41:53.468 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 10:42:10.535 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2165, output_tokens=810, cost=0.045950
2025-10-17 10:42:10.543 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:42:18.192 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3191, output_tokens=347, cost=0.042320
2025-10-17 10:42:18.196 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:42:24.941 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=701, output_tokens=300, cost=0.016010
2025-10-17 10:42:24.942 | DEBUG    | Extracted a valid json.
2025-10-17 10:42:24.942 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/models/sql/query.py",
            "class": "",
            "method": "union",
            "intended_behavior": "This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL."
        },
        {
            "file": "django/db/models/expressions.py",
            "class": "",
            "method": "",
            "intended_behavior": "In the implementation of `Subquery` and possibly other related expressions, there should be clear handling or documentation of how these expressions can be used with `union` and `OR` (`|`) operations. If there's a limitation within the Django ORM that prevents the direct use of `OuterRef` in conjunction with `union`, then a workaround or clear guidelines should be provided. For example, enhancing the `Subquery` expression to internally handle or adapt to `union` directives in a way that the outer references do not lose their context or lead to SQL generation errors."
        }
    ]
}
2025-10-17 10:42:24.957 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/query.py</file>
<class>None</class>
<method>union</method>
<code>
1034     def union(self, *other_qs, all=False):
1035         # If the query is an EmptyQuerySet, combine all nonempty querysets.
1036         if isinstance(self, EmptyQuerySet):
1037             qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]
1038             if not qs:
1039                 return self
1040             if len(qs) == 1:
1041                 return qs[0]
1042             return qs[0]._combinator_query('union', *qs[1:], all=all)
1043         return self._combinator_query('union', *other_qs, all=all)

</code><intended_behavior>This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL.</intended_behavior>, <file>django/contrib/gis/geos/geometry.py</file>
<class>None</class>
<method>union</method>
<code>
601     def union(self, other):
602         "Return a Geometry representing all the points in this Geometry and other."
603         return self._topology(capi.geos_union(self.ptr, other.ptr))

</code><intended_behavior>This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL.</intended_behavior>, <file>django/contrib/gis/gdal/geometries.py</file>
<class>None</class>
<method>union</method>
<code>
493     def union(self, other):
494         """
495         Return a new geometry consisting of the region which is the union of
496         this geometry and the other.
497         """
498         return self._geomgen(capi.geom_union, other)

</code><intended_behavior>This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL.</intended_behavior>, <file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import functools
4 import inspect
5 from decimal import Decimal
6 from uuid import UUID
7 
8 from django.core.exceptions import EmptyResultSet, FieldError
9 from django.db import DatabaseError, NotSupportedError, connection
10 from django.db.models import fields
11 from django.db.models.constants import LOOKUP_SEP
12 from django.db.models.query_utils import Q
13 from django.utils.deconstruct import deconstructible
14 from django.utils.functional import cached_property
15 from django.utils.hashable import make_hashable
16 
17 
18 class SQLiteNumericMixin:
19     """
20     Some expressions with output_field=DecimalField() must be cast to
21     numeric to be properly filtered.
22     """
23     def as_sqlite(self, compiler, connection, **extra_context):
24         sql, params = self.as_sql(compiler, connection, **extra_context)
25         try:
26             if self.output_field.get_internal_type() == 'DecimalField':
27                 sql = 'CAST(%s AS NUMERIC)' % sql
28         except FieldError:
29             pass
30         return sql, params
31 
32 
33 class Combinable:
34     """
35     Provide the ability to combine one or two objects with
36     some connector. For example F('foo') + F('bar').
37     """
38 
39     # Arithmetic connectors
40     ADD = '+'
41     SUB = '-'
42     MUL = '*'
43     DIV = '/'
44     POW = '^'
45     # The following is a quoted % operator - it is quoted because it can be
46     # used in strings that also have parameter substitution.
47     MOD = '%%'
48 
49     # Bitwise operators - note that these are generated by .bitand()
50     # and .bitor(), the '&' and '|' are reserved for boolean operator
51     # usage.
52     BITAND = '&'
53     BITOR = '|'
54     BITLEFTSHIFT = '<<'
55     BITRIGHTSHIFT = '>>'
56     BITXOR = '#'
57 
58     def _combine(self, other, connector, reversed):
59         if not hasattr(other, 'resolve_expression'):
60             # everything must be resolvable to an expression
61             other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def bitxor(self, other):
109         return self._combine(other, self.BITXOR, False)
110 
111     def __or__(self, other):
112         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
113             return Q(self) | Q(other)
114         raise NotImplementedError(
115             "Use .bitand() and .bitor() for bitwise logical operations."
116         )
117 
118     def bitor(self, other):
119         return self._combine(other, self.BITOR, False)
120 
121     def __radd__(self, other):
122         return self._combine(other, self.ADD, True)
123 
124     def __rsub__(self, other):
125         return self._combine(other, self.SUB, True)
126 
127     def __rmul__(self, other):
128         return self._combine(other, self.MUL, True)
129 
130     def __rtruediv__(self, other):
131         return self._combine(other, self.DIV, True)
132 
133     def __rmod__(self, other):
134         return self._combine(other, self.MOD, True)
135 
136     def __rpow__(self, other):
137         return self._combine(other, self.POW, True)
138 
139     def __rand__(self, other):
140         raise NotImplementedError(
141             "Use .bitand() and .bitor() for bitwise logical operations."
142         )
143 
144     def __ror__(self, other):
145         raise NotImplementedError(
146             "Use .bitand() and .bitor() for bitwise logical operations."
147         )
148 
149 
150 class BaseExpression:
151     """Base class for all query expressions."""
152 
153     empty_result_set_value = NotImplemented
154     # aggregate specific fields
155     is_summary = False
156     _output_field_resolved_to_none = False
157     # Can the expression be used in a WHERE clause?
158     filterable = True
159     # Can the expression can be used as a source expression in Window?
160     window_compatible = False
161 
162     def __init__(self, output_field=None):
163         if output_field is not None:
164             self.output_field = output_field
165 
166     def __getstate__(self):
167         state = self.__dict__.copy()
168         state.pop('convert_value', None)
169         return state
170 
171     def get_db_converters(self, connection):
172         return (
173             []
174             if self.convert_value is self._convert_value_noop else
175             [self.convert_value]
176         ) + self.output_field.get_db_converters(connection)
177 
178     def get_source_expressions(self):
179         return []
180 
181     def set_source_expressions(self, exprs):
182         assert not exprs
183 
184     def _parse_expressions(self, *expressions):
185         return [
186             arg if hasattr(arg, 'resolve_expression') else (
187                 F(arg) if isinstance(arg, str) else Value(arg)
188             ) for arg in expressions
189         ]
190 
191     def as_sql(self, compiler, connection):
192         """
193         Responsible for returning a (sql, [params]) tuple to be included
194         in the current query.
195 
196         Different backends can provide their own implementation, by
197         providing an `as_{vendor}` method and patching the Expression:
198 
199         ```
200         def override_as_sql(self, compiler, connection):
201             # custom logic
202             return super().as_sql(compiler, connection)
203         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
204         ```
205 
206         Arguments:
207          * compiler: the query compiler responsible for generating the query.
208            Must have a compile method, returning a (sql, [params]) tuple.
209            Calling compiler(value) will return a quoted `value`.
210 
211          * connection: the database connection used for the current query.
212 
213         Return: (sql, params)
214           Where `sql` is a string containing ordered sql parameters to be
215           replaced with the elements of the list `params`.
216         """
217         raise NotImplementedError("Subclasses must implement as_sql()")
218 
219     @cached_property
220     def contains_aggregate(self):
221         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
222 
223     @cached_property
224     def contains_over_clause(self):
225         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
226 
227     @cached_property
228     def contains_column_references(self):
229         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
230 
231     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
232         """
233         Provide the chance to do any preprocessing or validation before being
234         added to the query.
235 
236         Arguments:
237          * query: the backend query implementation
238          * allow_joins: boolean allowing or denying use of joins
239            in this query
240          * reuse: a set of reusable joins for multijoins
241          * summarize: a terminal aggregate clause
242          * for_save: whether this expression about to be used in a save or update
243 
244         Return: an Expression to be added to the query.
245         """
246         c = self.copy()
247         c.is_summary = summarize
248         c.set_source_expressions([
249             expr.resolve_expression(query, allow_joins, reuse, summarize)
250             if expr else None
251             for expr in c.get_source_expressions()
252         ])
253         return c
254 
255     @property
256     def conditional(self):
257         return isinstance(self.output_field, fields.BooleanField)
258 
259     @property
260     def field(self):
261         return self.output_field
262 
263     @cached_property
264     def output_field(self):
265         """Return the output type of this expressions."""
266         output_field = self._resolve_output_field()
267         if output_field is None:
268             self._output_field_resolved_to_none = True
269             raise FieldError('Cannot resolve expression type, unknown output_field')
270         return output_field
271 
272     @cached_property
273     def _output_field_or_none(self):
274         """
275         Return the output field of this expression, or None if
276         _resolve_output_field() didn't return an output type.
277         """
278         try:
279             return self.output_field
280         except FieldError:
281             if not self._output_field_resolved_to_none:
282                 raise
283 
284     def _resolve_output_field(self):
285         """
286         Attempt to infer the output type of the expression. If the output
287         fields of all source fields match then, simply infer the same type
288         here. This isn't always correct, but it makes sense most of the time.
289 
290         Consider the difference between `2 + 2` and `2 / 3`. Inferring
291         the type here is a convenience for the common case. The user should
292         supply their own output_field with more complex computations.
293 
294         If a source's output field resolves to None, exclude it from this check.
295         If all sources are None, then an error is raised higher up the stack in
296         the output_field property.
297         """
298         sources_iter = (source for source in self.get_source_fields() if source is not None)
299         for output_field in sources_iter:
300             for source in sources_iter:
301                 if not isinstance(output_field, source.__class__):
302                     raise FieldError(
303                         'Expression contains mixed types: %s, %s. You must '
304                         'set output_field.' % (
305                             output_field.__class__.__name__,
306                             source.__class__.__name__,
307                         )
308                     )
309             return output_field
310 
311     @staticmethod
312     def _convert_value_noop(value, expression, connection):
313         return value
314 
315     @cached_property
316     def convert_value(self):
317         """
318         Expressions provide their own converters because users have the option
319         of manually specifying the output_field which may be a different type
320         from the one the database returns.
321         """
322         field = self.output_field
323         internal_type = field.get_internal_type()
324         if internal_type == 'FloatField':
325             return lambda value, expression, connection: None if value is None else float(value)
326         elif internal_type.endswith('IntegerField'):
327             return lambda value, expression, connection: None if value is None else int(value)
328         elif internal_type == 'DecimalField':
329             return lambda value, expression, connection: None if value is None else Decimal(value)
330         return self._convert_value_noop
331 
332     def get_lookup(self, lookup):
333         return self.output_field.get_lookup(lookup)
334 
335     def get_transform(self, name):
336         return self.output_field.get_transform(name)
337 
338     def relabeled_clone(self, change_map):
339         clone = self.copy()
340         clone.set_source_expressions([
341             e.relabeled_clone(change_map) if e is not None else None
342             for e in self.get_source_expressions()
343         ])
344         return clone
345 
346     def copy(self):
347         return copy.copy(self)
348 
349     def get_group_by_cols(self, alias=None):
350         if not self.contains_aggregate:
351             return [self]
352         cols = []
353         for source in self.get_source_expressions():
354             cols.extend(source.get_group_by_cols())
355         return cols
356 
357     def get_source_fields(self):
358         """Return the underlying field types used by this aggregate."""
359         return [e._output_field_or_none for e in self.get_source_expressions()]
360 
361     def asc(self, **kwargs):
362         return OrderBy(self, **kwargs)
363 
364     def desc(self, **kwargs):
365         return OrderBy(self, descending=True, **kwargs)
366 
367     def reverse_ordering(self):
368         return self
369 
370     def flatten(self):
371         """
372         Recursively yield this expression and all subexpressions, in
373         depth-first order.
374         """
375         yield self
376         for expr in self.get_source_expressions():
377             if expr:
378                 if hasattr(expr, 'flatten'):
379                     yield from expr.flatten()
380                 else:
381                     yield expr
382 
383     def select_format(self, compiler, sql, params):
384         """
385         Custom format for select clauses. For example, EXISTS expressions need
386         to be wrapped in CASE WHEN on Oracle.
387         """
388         if hasattr(self.output_field, 'select_format'):
389             return self.output_field.select_format(compiler, sql, params)
390         return sql, params
391 
392 
393 @deconstructible
394 class Expression(BaseExpression, Combinable):
395     """An expression that can be combined with other expressions."""
396 
397     @cached_property
398     def identity(self):
399         constructor_signature = inspect.signature(self.__init__)
400         args, kwargs = self._constructor_args
401         signature = constructor_signature.bind_partial(*args, **kwargs)
402         signature.apply_defaults()
403         arguments = signature.arguments.items()
404         identity = [self.__class__]
405         for arg, value in arguments:
406             if isinstance(value, fields.Field):
407                 if value.name and value.model:
408                     value = (value.model._meta.label, value.name)
409                 else:
410                     value = type(value)
411             else:
412                 value = make_hashable(value)
413             identity.append((arg, value))
414         return tuple(identity)
415 
416     def __eq__(self, other):
417         if not isinstance(other, Expression):
418             return NotImplemented
419         return other.identity == self.identity
420 
421     def __hash__(self):
422         return hash(self.identity)
423 
424 
425 _connector_combinators = {
426     connector: [
427         (fields.IntegerField, fields.IntegerField, fields.IntegerField),
428         (fields.IntegerField, fields.DecimalField, fields.DecimalField),
429         (fields.DecimalField, fields.IntegerField, fields.DecimalField),
430         (fields.IntegerField, fields.FloatField, fields.FloatField),
431         (fields.FloatField, fields.IntegerField, fields.FloatField),
432     ]
433     for connector in (Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV)
434 }
435 
436 
437 @functools.lru_cache(maxsize=128)
438 def _resolve_combined_type(connector, lhs_type, rhs_type):
439     combinators = _connector_combinators.get(connector, ())
440     for combinator_lhs_type, combinator_rhs_type, combined_type in combinators:
441         if issubclass(lhs_type, combinator_lhs_type) and issubclass(rhs_type, combinator_rhs_type):
442             return combined_type
443 
444 
445 class CombinedExpression(SQLiteNumericMixin, Expression):
446 
447     def __init__(self, lhs, connector, rhs, output_field=None):
448         super().__init__(output_field=output_field)
449         self.connector = connector
450         self.lhs = lhs
451         self.rhs = rhs
452 
453     def __repr__(self):
454         return "<{}: {}>".format(self.__class__.__name__, self)
455 
456     def __str__(self):
457         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
458 
459     def get_source_expressions(self):
460         return [self.lhs, self.rhs]
461 
462     def set_source_expressions(self, exprs):
463         self.lhs, self.rhs = exprs
464 
465     def _resolve_output_field(self):
466         try:
467             return super()._resolve_output_field()
468         except FieldError:
469             combined_type = _resolve_combined_type(
470                 self.connector,
471                 type(self.lhs.output_field),
472                 type(self.rhs.output_field),
473             )
474             if combined_type is None:
475                 raise
476             return combined_type()
477 
478     def as_sql(self, compiler, connection):
479         expressions = []
480         expression_params = []
481         sql, params = compiler.compile(self.lhs)
482         expressions.append(sql)
483         expression_params.extend(params)
484         sql, params = compiler.compile(self.rhs)
485         expressions.append(sql)
486         expression_params.extend(params)
487         # order of precedence
488         expression_wrapper = '(%s)'
489         sql = connection.ops.combine_expression(self.connector, expressions)
490         return expression_wrapper % sql, expression_params
491 
492     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
493         lhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
494         rhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
495         if not isinstance(self, (DurationExpression, TemporalSubtraction)):
496             try:
497                 lhs_type = lhs.output_field.get_internal_type()
498             except (AttributeError, FieldError):
499                 lhs_type = None
500             try:
501                 rhs_type = rhs.output_field.get_internal_type()
502             except (AttributeError, FieldError):
503                 rhs_type = None
504             if 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:
505                 return DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(
506                     query, allow_joins, reuse, summarize, for_save,
507                 )
508             datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}
509             if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:
510                 return TemporalSubtraction(self.lhs, self.rhs).resolve_expression(
511                     query, allow_joins, reuse, summarize, for_save,
512                 )
513         c = self.copy()
514         c.is_summary = summarize
515         c.lhs = lhs
516         c.rhs = rhs
517         return c
518 
519 
520 class DurationExpression(CombinedExpression):
521     def compile(self, side, compiler, connection):
522         try:
523             output = side.output_field
524         except FieldError:
525             pass
526         else:
527             if output.get_internal_type() == 'DurationField':
528                 sql, params = compiler.compile(side)
529                 return connection.ops.format_for_duration_arithmetic(sql), params
530         return compiler.compile(side)
531 
532     def as_sql(self, compiler, connection):
533         if connection.features.has_native_duration_field:
534             return super().as_sql(compiler, connection)
535         connection.ops.check_expression_support(self)
536         expressions = []
537         expression_params = []
538         sql, params = self.compile(self.lhs, compiler, connection)
539         expressions.append(sql)
540         expression_params.extend(params)
541         sql, params = self.compile(self.rhs, compiler, connection)
542         expressions.append(sql)
543         expression_params.extend(params)
544         # order of precedence
545         expression_wrapper = '(%s)'
546         sql = connection.ops.combine_duration_expression(self.connector, expressions)
547         return expression_wrapper % sql, expression_params
548 
549     def as_sqlite(self, compiler, connection, **extra_context):
550         sql, params = self.as_sql(compiler, connection, **extra_context)
551         if self.connector in {Combinable.MUL, Combinable.DIV}:
552             try:
553                 lhs_type = self.lhs.output_field.get_internal_type()
554                 rhs_type = self.rhs.output_field.get_internal_type()
555             except (AttributeError, FieldError):
556                 pass
557             else:
558                 allowed_fields = {
559                     'DecimalField', 'DurationField', 'FloatField', 'IntegerField',
560                 }
561                 if lhs_type not in allowed_fields or rhs_type not in allowed_fields:
562                     raise DatabaseError(
563                         f'Invalid arguments for operator {self.connector}.'
564                     )
565         return sql, params
566 
567 
568 class TemporalSubtraction(CombinedExpression):
569     output_field = fields.DurationField()
570 
571     def __init__(self, lhs, rhs):
572         super().__init__(lhs, self.SUB, rhs)
573 
574     def as_sql(self, compiler, connection):
575         connection.ops.check_expression_support(self)
576         lhs = compiler.compile(self.lhs)
577         rhs = compiler.compile(self.rhs)
578         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
579 
580 
581 @deconstructible(path='django.db.models.F')
582 class F(Combinable):
583     """An object capable of resolving references to existing query objects."""
584 
585     def __init__(self, name):
586         """
587         Arguments:
588          * name: the name of the field this expression references
589         """
590         self.name = name
591 
592     def __repr__(self):
593         return "{}({})".format(self.__class__.__name__, self.name)
594 
595     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
596                            summarize=False, for_save=False):
597         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
598 
599     def asc(self, **kwargs):
600         return OrderBy(self, **kwargs)
601 
602     def desc(self, **kwargs):
603         return OrderBy(self, descending=True, **kwargs)
604 
605     def __eq__(self, other):
606         return self.__class__ == other.__class__ and self.name == other.name
607 
608     def __hash__(self):
609         return hash(self.name)
610 
611 
612 class ResolvedOuterRef(F):
613     """
614     An object that contains a reference to an outer query.
615 
616     In this case, the reference to the outer query has been resolved because
617     the inner query has been used as a subquery.
618     """
619     contains_aggregate = False
620 
621     def as_sql(self, *args, **kwargs):
622         raise ValueError(
623             'This queryset contains a reference to an outer query and may '
624             'only be used in a subquery.'
625         )
626 
627     def resolve_expression(self, *args, **kwargs):
628         col = super().resolve_expression(*args, **kwargs)
629         # FIXME: Rename possibly_multivalued to multivalued and fix detection
630         # for non-multivalued JOINs (e.g. foreign key fields). This should take
631         # into accountÂ only many-to-many and one-to-many relationships.
632         col.possibly_multivalued = LOOKUP_SEP in self.name
633         return col
634 
635     def relabeled_clone(self, relabels):
636         return self
637 
638     def get_group_by_cols(self, alias=None):
639         return []
640 
641 
642 class OuterRef(F):
643     contains_aggregate = False
644 
645     def resolve_expression(self, *args, **kwargs):
646         if isinstance(self.name, self.__class__):
647             return self.name
648         return ResolvedOuterRef(self.name)
649 
650     def relabeled_clone(self, relabels):
651         return self
652 
653 
654 @deconstructible(path='django.db.models.Func')
655 class Func(SQLiteNumericMixin, Expression):
656     """An SQL function call."""
657     function = None
658     template = '%(function)s(%(expressions)s)'
659     arg_joiner = ', '
660     arity = None  # The number of arguments the function accepts.
661 
662     def __init__(self, *expressions, output_field=None, **extra):
663         if self.arity is not None and len(expressions) != self.arity:
664             raise TypeError(
665                 "'%s' takes exactly %s %s (%s given)" % (
666                     self.__class__.__name__,
667                     self.arity,
668                     "argument" if self.arity == 1 else "arguments",
669                     len(expressions),
670                 )
671             )
672         super().__init__(output_field=output_field)
673         self.source_expressions = self._parse_expressions(*expressions)
674         self.extra = extra
675 
676     def __repr__(self):
677         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
678         extra = {**self.extra, **self._get_repr_options()}
679         if extra:
680             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
681             return "{}({}, {})".format(self.__class__.__name__, args, extra)
682         return "{}({})".format(self.__class__.__name__, args)
683 
684     def _get_repr_options(self):
685         """Return a dict of extra __init__() options to include in the repr."""
686         return {}
687 
688     def get_source_expressions(self):
689         return self.source_expressions
690 
691     def set_source_expressions(self, exprs):
692         self.source_expressions = exprs
693 
694     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
695         c = self.copy()
696         c.is_summary = summarize
697         for pos, arg in enumerate(c.source_expressions):
698             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
699         return c
700 
701     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
702         connection.ops.check_expression_support(self)
703         sql_parts = []
704         params = []
705         for arg in self.source_expressions:
706             try:
707                 arg_sql, arg_params = compiler.compile(arg)
708             except EmptyResultSet:
709                 empty_result_set_value = getattr(arg, 'empty_result_set_value', NotImplemented)
710                 if empty_result_set_value is NotImplemented:
711                     raise
712                 arg_sql, arg_params = compiler.compile(Value(empty_result_set_value))
713             sql_parts.append(arg_sql)
714             params.extend(arg_params)
715         data = {**self.extra, **extra_context}
716         # Use the first supplied value in this order: the parameter to this
717         # method, a value supplied in __init__()'s **extra (the value in
718         # `data`), or the value defined on the class.
719         if function is not None:
720             data['function'] = function
721         else:
722             data.setdefault('function', self.function)
723         template = template or data.get('template', self.template)
724         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
725         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
726         return template % data, params
727 
728     def copy(self):
729         copy = super().copy()
730         copy.source_expressions = self.source_expressions[:]
731         copy.extra = self.extra.copy()
732         return copy
733 
734 
735 @deconstructible(path='django.db.models.Value')
736 class Value(SQLiteNumericMixin, Expression):
737     """Represent a wrapped value as a node within an expression."""
738     # Provide a default value for `for_save` in order to allow unresolved
739     # instances to be compiled until a decision is taken in #25425.
740     for_save = False
741 
742     def __init__(self, value, output_field=None):
743         """
744         Arguments:
745          * value: the value this expression represents. The value will be
746            added into the sql parameter list and properly quoted.
747 
748          * output_field: an instance of the model field type that this
749            expression will return, such as IntegerField() or CharField().
750         """
751         super().__init__(output_field=output_field)
752         self.value = value
753 
754     def __repr__(self):
755         return f'{self.__class__.__name__}({self.value!r})'
756 
757     def as_sql(self, compiler, connection):
758         connection.ops.check_expression_support(self)
759         val = self.value
760         output_field = self._output_field_or_none
761         if output_field is not None:
762             if self.for_save:
763                 val = output_field.get_db_prep_save(val, connection=connection)
764             else:
765                 val = output_field.get_db_prep_value(val, connection=connection)
766             if hasattr(output_field, 'get_placeholder'):
767                 return output_field.get_placeholder(val, compiler, connection), [val]
768         if val is None:
769             # cx_Oracle does not always convert None to the appropriate
770             # NULL type (like in case expressions using numbers), so we
771             # use a literal SQL NULL
772             return 'NULL', []
773         return '%s', [val]
774 
775     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
776         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
777         c.for_save = for_save
778         return c
779 
780     def get_group_by_cols(self, alias=None):
781         return []
782 
783     def _resolve_output_field(self):
784         if isinstance(self.value, str):
785             return fields.CharField()
786         if isinstance(self.value, bool):
787             return fields.BooleanField()
788         if isinstance(self.value, int):
789             return fields.IntegerField()
790         if isinstance(self.value, float):
791             return fields.FloatField()
792         if isinstance(self.value, datetime.datetime):
793             return fields.DateTimeField()
794         if isinstance(self.value, datetime.date):
795             return fields.DateField()
796         if isinstance(self.value, datetime.time):
797             return fields.TimeField()
798         if isinstance(self.value, datetime.timedelta):
799             return fields.DurationField()
800         if isinstance(self.value, Decimal):
801             return fields.DecimalField()
802         if isinstance(self.value, bytes):
803             return fields.BinaryField()
804         if isinstance(self.value, UUID):
805             return fields.UUIDField()
806 
807     @property
808     def empty_result_set_value(self):
809         return self.value
810 
811 
812 class RawSQL(Expression):
813     def __init__(self, sql, params, output_field=None):
814         if output_field is None:
815             output_field = fields.Field()
816         self.sql, self.params = sql, params
817         super().__init__(output_field=output_field)
818 
819     def __repr__(self):
820         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
821 
822     def as_sql(self, compiler, connection):
823         return '(%s)' % self.sql, self.params
824 
825     def get_group_by_cols(self, alias=None):
826         return [self]
827 
828     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
829         # Resolve parents fields used in raw SQL.
830         for parent in query.model._meta.get_parent_list():
831             for parent_field in parent._meta.local_fields:
832                 _, column_name = parent_field.get_attname_column()
833                 if column_name.lower() in self.sql.lower():
834                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
835                     break
836         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
837 
838 
839 class Star(Expression):
840     def __repr__(self):
841         return "'*'"
842 
843     def as_sql(self, compiler, connection):
844         return '*', []
845 
846 
847 class Col(Expression):
848 
849     contains_column_references = True
850     possibly_multivalued = False
851 
852     def __init__(self, alias, target, output_field=None):
853         if output_field is None:
854             output_field = target
855         super().__init__(output_field=output_field)
856         self.alias, self.target = alias, target
857 
858     def __repr__(self):
859         alias, target = self.alias, self.target
860         identifiers = (alias, str(target)) if alias else (str(target),)
861         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
862 
863     def as_sql(self, compiler, connection):
864         alias, column = self.alias, self.target.column
865         identifiers = (alias, column) if alias else (column,)
866         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
867         return sql, []
868 
869     def relabeled_clone(self, relabels):
870         if self.alias is None:
871             return self
872         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
873 
874     def get_group_by_cols(self, alias=None):
875         return [self]
876 
877     def get_db_converters(self, connection):
878         if self.target == self.output_field:
879             return self.output_field.get_db_converters(connection)
880         return (self.output_field.get_db_converters(connection) +
881                 self.target.get_db_converters(connection))
882 
883 
884 class Ref(Expression):
885     """
886     Reference to column alias of the query. For example, Ref('sum_cost') in
887     qs.annotate(sum_cost=Sum('cost')) query.
888     """
889     def __init__(self, refs, source):
890         super().__init__()
891         self.refs, self.source = refs, source
892 
893     def __repr__(self):
894         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
895 
896     def get_source_expressions(self):
897         return [self.source]
898 
899     def set_source_expressions(self, exprs):
900         self.source, = exprs
901 
902     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
903         # The sub-expression `source` has already been resolved, as this is
904         # just a reference to the name of `source`.
905         return self
906 
907     def relabeled_clone(self, relabels):
908         return self
909 
910     def as_sql(self, compiler, connection):
911         return connection.ops.quote_name(self.refs), []
912 
913     def get_group_by_cols(self, alias=None):
914         return [self]
915 
916 
917 class ExpressionList(Func):
918     """
919     An expression containing multiple expressions. Can be used to provide a
920     list of expressions as an argument to another expression, like a partition
921     clause.
922     """
923     template = '%(expressions)s'
924 
925     def __init__(self, *expressions, **extra):
926         if not expressions:
927             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
928         super().__init__(*expressions, **extra)
929 
930     def __str__(self):
931         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
932 
933     def as_sqlite(self, compiler, connection, **extra_context):
934         # Casting to numeric is unnecessary.
935         return self.as_sql(compiler, connection, **extra_context)
936 
937 
938 class OrderByList(Func):
939     template = 'ORDER BY %(expressions)s'
940 
941     def __init__(self, *expressions, **extra):
942         expressions = (
943             (
944                 OrderBy(F(expr[1:]), descending=True)
945                 if isinstance(expr, str) and expr[0] == '-'
946                 else expr
947             )
948             for expr in expressions
949         )
950         super().__init__(*expressions, **extra)
951 
952     def as_sql(self, *args, **kwargs):
953         if not self.source_expressions:
954             return '', ()
955         return super().as_sql(*args, **kwargs)
956 
957 
958 @deconstructible(path='django.db.models.ExpressionWrapper')
959 class ExpressionWrapper(SQLiteNumericMixin, Expression):
960     """
961     An expression that can wrap another expression so that it can provide
962     extra context to the inner expression, such as the output_field.
963     """
964 
965     def __init__(self, expression, output_field):
966         super().__init__(output_field=output_field)
967         self.expression = expression
968 
969     def set_source_expressions(self, exprs):
970         self.expression = exprs[0]
971 
972     def get_source_expressions(self):
973         return [self.expression]
974 
975     def get_group_by_cols(self, alias=None):
976         if isinstance(self.expression, Expression):
977             expression = self.expression.copy()
978             expression.output_field = self.output_field
979             return expression.get_group_by_cols(alias=alias)
980         # For non-expressions e.g. an SQL WHERE clause, the entire
981         # `expression` must be included in the GROUP BY clause.
982         return super().get_group_by_cols()
983 
984     def as_sql(self, compiler, connection):
985         return compiler.compile(self.expression)
986 
987     def __repr__(self):
988         return "{}({})".format(self.__class__.__name__, self.expression)
989 
990 
991 @deconstructible(path='django.db.models.When')
992 class When(Expression):
993     template = 'WHEN %(condition)s THEN %(result)s'
994     # This isn't a complete conditional expression, must be used in Case().
995     conditional = False
996 
997     def __init__(self, condition=None, then=None, **lookups):
998         if lookups:
999             if condition is None:
1000                 condition, lookups = Q(**lookups), None
1001             elif getattr(condition, 'conditional', False):
1002                 condition, lookups = Q(condition, **lookups), None
1003         if condition is None or not getattr(condition, 'conditional', False) or lookups:
1004             raise TypeError(
1005                 'When() supports a Q object, a boolean expression, or lookups '
1006                 'as a condition.'
1007             )
1008         if isinstance(condition, Q) and not condition:
1009             raise ValueError("An empty Q() can't be used as a When() condition.")
1010         super().__init__(output_field=None)
1011         self.condition = condition
1012         self.result = self._parse_expressions(then)[0]
1013 
1014     def __str__(self):
1015         return "WHEN %r THEN %r" % (self.condition, self.result)
1016 
1017     def __repr__(self):
1018         return "<%s: %s>" % (self.__class__.__name__, self)
1019 
1020     def get_source_expressions(self):
1021         return [self.condition, self.result]
1022 
1023     def set_source_expressions(self, exprs):
1024         self.condition, self.result = exprs
1025 
1026     def get_source_fields(self):
1027         # We're only interested in the fields of the result expressions.
1028         return [self.result._output_field_or_none]
1029 
1030     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1031         c = self.copy()
1032         c.is_summary = summarize
1033         if hasattr(c.condition, 'resolve_expression'):
1034             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
1035         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1036         return c
1037 
1038     def as_sql(self, compiler, connection, template=None, **extra_context):
1039         connection.ops.check_expression_support(self)
1040         template_params = extra_context
1041         sql_params = []
1042         condition_sql, condition_params = compiler.compile(self.condition)
1043         template_params['condition'] = condition_sql
1044         sql_params.extend(condition_params)
1045         result_sql, result_params = compiler.compile(self.result)
1046         template_params['result'] = result_sql
1047         sql_params.extend(result_params)
1048         template = template or self.template
1049         return template % template_params, sql_params
1050 
1051     def get_group_by_cols(self, alias=None):
1052         # This is not a complete expression and cannot be used in GROUP BY.
1053         cols = []
1054         for source in self.get_source_expressions():
1055             cols.extend(source.get_group_by_cols())
1056         return cols
1057 
1058 
1059 @deconstructible(path='django.db.models.Case')
1060 class Case(SQLiteNumericMixin, Expression):
1061     """
1062     An SQL searched CASE expression:
1063 
1064         CASE
1065             WHEN n > 0
1066                 THEN 'positive'
1067             WHEN n < 0
1068                 THEN 'negative'
1069             ELSE 'zero'
1070         END
1071     """
1072     template = 'CASE %(cases)s ELSE %(default)s END'
1073     case_joiner = ' '
1074 
1075     def __init__(self, *cases, default=None, output_field=None, **extra):
1076         if not all(isinstance(case, When) for case in cases):
1077             raise TypeError("Positional arguments must all be When objects.")
1078         super().__init__(output_field)
1079         self.cases = list(cases)
1080         self.default = self._parse_expressions(default)[0]
1081         self.extra = extra
1082 
1083     def __str__(self):
1084         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
1085 
1086     def __repr__(self):
1087         return "<%s: %s>" % (self.__class__.__name__, self)
1088 
1089     def get_source_expressions(self):
1090         return self.cases + [self.default]
1091 
1092     def set_source_expressions(self, exprs):
1093         *self.cases, self.default = exprs
1094 
1095     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1096         c = self.copy()
1097         c.is_summary = summarize
1098         for pos, case in enumerate(c.cases):
1099             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1100         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1101         return c
1102 
1103     def copy(self):
1104         c = super().copy()
1105         c.cases = c.cases[:]
1106         return c
1107 
1108     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
1109         connection.ops.check_expression_support(self)
1110         if not self.cases:
1111             return compiler.compile(self.default)
1112         template_params = {**self.extra, **extra_context}
1113         case_parts = []
1114         sql_params = []
1115         for case in self.cases:
1116             try:
1117                 case_sql, case_params = compiler.compile(case)
1118             except EmptyResultSet:
1119                 continue
1120             case_parts.append(case_sql)
1121             sql_params.extend(case_params)
1122         default_sql, default_params = compiler.compile(self.default)
1123         if not case_parts:
1124             return default_sql, default_params
1125         case_joiner = case_joiner or self.case_joiner
1126         template_params['cases'] = case_joiner.join(case_parts)
1127         template_params['default'] = default_sql
1128         sql_params.extend(default_params)
1129         template = template or template_params.get('template', self.template)
1130         sql = template % template_params
1131         if self._output_field_or_none is not None:
1132             sql = connection.ops.unification_cast_sql(self.output_field) % sql
1133         return sql, sql_params
1134 
1135     def get_group_by_cols(self, alias=None):
1136         if not self.cases:
1137             return self.default.get_group_by_cols(alias)
1138         return super().get_group_by_cols(alias)
1139 
1140 
1141 class Subquery(BaseExpression, Combinable):
1142     """
1143     An explicit subquery. It may contain OuterRef() references to the outer
1144     query which will be resolved when it is applied to that query.
1145     """
1146     template = '(%(subquery)s)'
1147     contains_aggregate = False
1148     empty_result_set_value = None
1149 
1150     def __init__(self, queryset, output_field=None, **extra):
1151         # Allow the usage of both QuerySet and sql.Query objects.
1152         self.query = getattr(queryset, 'query', queryset).clone()
1153         self.query.subquery = True
1154         self.extra = extra
1155         super().__init__(output_field)
1156 
1157     def get_source_expressions(self):
1158         return [self.query]
1159 
1160     def set_source_expressions(self, exprs):
1161         self.query = exprs[0]
1162 
1163     def _resolve_output_field(self):
1164         return self.query.output_field
1165 
1166     def copy(self):
1167         clone = super().copy()
1168         clone.query = clone.query.clone()
1169         return clone
1170 
1171     @property
1172     def external_aliases(self):
1173         return self.query.external_aliases
1174 
1175     def get_external_cols(self):
1176         return self.query.get_external_cols()
1177 
1178     def as_sql(self, compiler, connection, template=None, query=None, **extra_context):
1179         connection.ops.check_expression_support(self)
1180         template_params = {**self.extra, **extra_context}
1181         query = query or self.query
1182         subquery_sql, sql_params = query.as_sql(compiler, connection)
1183         template_params['subquery'] = subquery_sql[1:-1]
1184 
1185         template = template or template_params.get('template', self.template)
1186         sql = template % template_params
1187         return sql, sql_params
1188 
1189     def get_group_by_cols(self, alias=None):
1190         # If this expression is referenced by an alias for an explicit GROUP BY
1191         # through values() a reference to this expression and not the
1192         # underlying .query must be returned to ensure external column
1193         # references are not grouped against as well.
1194         if alias:
1195             return [Ref(alias, self)]
1196         return self.query.get_group_by_cols()
1197 
1198 
1199 class Exists(Subquery):
1200     template = 'EXISTS(%(subquery)s)'
1201     output_field = fields.BooleanField()
1202 
1203     def __init__(self, queryset, negated=False, **kwargs):
1204         self.negated = negated
1205         super().__init__(queryset, **kwargs)
1206 
1207     def __invert__(self):
1208         clone = self.copy()
1209         clone.negated = not self.negated
1210         return clone
1211 
1212     def as_sql(self, compiler, connection, template=None, **extra_context):
1213         query = self.query.exists(using=connection.alias)
1214         sql, params = super().as_sql(
1215             compiler,
1216             connection,
1217             template=template,
1218             query=query,
1219             **extra_context,
1220         )
1221         if self.negated:
1222             sql = 'NOT {}'.format(sql)
1223         return sql, params
1224 
1225     def select_format(self, compiler, sql, params):
1226         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1227         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP
1228         # BY list.
1229         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1230             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1231         return sql, params
1232 
1233 
1234 @deconstructible(path='django.db.models.OrderBy')
1235 class OrderBy(Expression):
1236     template = '%(expression)s %(ordering)s'
1237     conditional = False
1238 
1239     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1240         if nulls_first and nulls_last:
1241             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1242         self.nulls_first = nulls_first
1243         self.nulls_last = nulls_last
1244         self.descending = descending
1245         if not hasattr(expression, 'resolve_expression'):
1246             raise ValueError('expression must be an expression type')
1247         self.expression = expression
1248 
1249     def __repr__(self):
1250         return "{}({}, descending={})".format(
1251             self.__class__.__name__, self.expression, self.descending)
1252 
1253     def set_source_expressions(self, exprs):
1254         self.expression = exprs[0]
1255 
1256     def get_source_expressions(self):
1257         return [self.expression]
1258 
1259     def as_sql(self, compiler, connection, template=None, **extra_context):
1260         template = template or self.template
1261         if connection.features.supports_order_by_nulls_modifier:
1262             if self.nulls_last:
1263                 template = '%s NULLS LAST' % template
1264             elif self.nulls_first:
1265                 template = '%s NULLS FIRST' % template
1266         else:
1267             if self.nulls_last and not (
1268                 self.descending and connection.features.order_by_nulls_first
1269             ):
1270                 template = '%%(expression)s IS NULL, %s' % template
1271             elif self.nulls_first and not (
1272                 not self.descending and connection.features.order_by_nulls_first
1273             ):
1274                 template = '%%(expression)s IS NOT NULL, %s' % template
1275         connection.ops.check_expression_support(self)
1276         expression_sql, params = compiler.compile(self.expression)
1277         placeholders = {
1278             'expression': expression_sql,
1279             'ordering': 'DESC' if self.descending else 'ASC',
1280             **extra_context,
1281         }
1282         params *= template.count('%(expression)s')
1283         return (template % placeholders).rstrip(), params
1284 
1285     def as_oracle(self, compiler, connection):
1286         # Oracle doesn't allow ORDER BY EXISTS() or filters unless it's wrapped
1287         # in a CASE WHEN.
1288         if connection.ops.conditional_expression_supported_in_where_clause(self.expression):
1289             copy = self.copy()
1290             copy.expression = Case(
1291                 When(self.expression, then=True),
1292                 default=False,
1293             )
1294             return copy.as_sql(compiler, connection)
1295         return self.as_sql(compiler, connection)
1296 
1297     def get_group_by_cols(self, alias=None):
1298         cols = []
1299         for source in self.get_source_expressions():
1300             cols.extend(source.get_group_by_cols())
1301         return cols
1302 
1303     def reverse_ordering(self):
1304         self.descending = not self.descending
1305         if self.nulls_first or self.nulls_last:
1306             self.nulls_first = not self.nulls_first
1307             self.nulls_last = not self.nulls_last
1308         return self
1309 
1310     def asc(self):
1311         self.descending = False
1312 
1313     def desc(self):
1314         self.descending = True
1315 
1316 
1317 class Window(SQLiteNumericMixin, Expression):
1318     template = '%(expression)s OVER (%(window)s)'
1319     # Although the main expression may either be an aggregate or an
1320     # expression with an aggregate function, the GROUP BY that will
1321     # be introduced in the query as a result is not desired.
1322     contains_aggregate = False
1323     contains_over_clause = True
1324     filterable = False
1325 
1326     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1327         self.partition_by = partition_by
1328         self.order_by = order_by
1329         self.frame = frame
1330 
1331         if not getattr(expression, 'window_compatible', False):
1332             raise ValueError(
1333                 "Expression '%s' isn't compatible with OVER clauses." %
1334                 expression.__class__.__name__
1335             )
1336 
1337         if self.partition_by is not None:
1338             if not isinstance(self.partition_by, (tuple, list)):
1339                 self.partition_by = (self.partition_by,)
1340             self.partition_by = ExpressionList(*self.partition_by)
1341 
1342         if self.order_by is not None:
1343             if isinstance(self.order_by, (list, tuple)):
1344                 self.order_by = OrderByList(*self.order_by)
1345             elif isinstance(self.order_by, (BaseExpression, str)):
1346                 self.order_by = OrderByList(self.order_by)
1347             else:
1348                 raise ValueError(
1349                     'Window.order_by must be either a string reference to a '
1350                     'field, an expression, or a list or tuple of them.'
1351                 )
1352         super().__init__(output_field=output_field)
1353         self.source_expression = self._parse_expressions(expression)[0]
1354 
1355     def _resolve_output_field(self):
1356         return self.source_expression.output_field
1357 
1358     def get_source_expressions(self):
1359         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1360 
1361     def set_source_expressions(self, exprs):
1362         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1363 
1364     def as_sql(self, compiler, connection, template=None):
1365         connection.ops.check_expression_support(self)
1366         if not connection.features.supports_over_clause:
1367             raise NotSupportedError('This backend does not support window expressions.')
1368         expr_sql, params = compiler.compile(self.source_expression)
1369         window_sql, window_params = [], []
1370 
1371         if self.partition_by is not None:
1372             sql_expr, sql_params = self.partition_by.as_sql(
1373                 compiler=compiler, connection=connection,
1374                 template='PARTITION BY %(expressions)s',
1375             )
1376             window_sql.append(sql_expr)
1377             window_params.extend(sql_params)
1378 
1379         if self.order_by is not None:
1380             order_sql, order_params = compiler.compile(self.order_by)
1381             window_sql.append(order_sql)
1382             window_params.extend(order_params)
1383 
1384         if self.frame:
1385             frame_sql, frame_params = compiler.compile(self.frame)
1386             window_sql.append(frame_sql)
1387             window_params.extend(frame_params)
1388 
1389         params.extend(window_params)
1390         template = template or self.template
1391 
1392         return template % {
1393             'expression': expr_sql,
1394             'window': ' '.join(window_sql).strip()
1395         }, params
1396 
1397     def as_sqlite(self, compiler, connection):
1398         if isinstance(self.output_field, fields.DecimalField):
1399             # Casting to numeric must be outside of the window expression.
1400             copy = self.copy()
1401             source_expressions = copy.get_source_expressions()
1402             source_expressions[0].output_field = fields.FloatField()
1403             copy.set_source_expressions(source_expressions)
1404             return super(Window, copy).as_sqlite(compiler, connection)
1405         return self.as_sql(compiler, connection)
1406 
1407     def __str__(self):
1408         return '{} OVER ({}{}{})'.format(
1409             str(self.source_expression),
1410             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1411             str(self.order_by or ''),
1412             str(self.frame or ''),
1413         )
1414 
1415     def __repr__(self):
1416         return '<%s: %s>' % (self.__class__.__name__, self)
1417 
1418     def get_group_by_cols(self, alias=None):
1419         return []
1420 
1421 
1422 class WindowFrame(Expression):
1423     """
1424     Model the frame clause in window expressions. There are two types of frame
1425     clauses which are subclasses, however, all processing and validation (by no
1426     means intended to be complete) is done here. Thus, providing an end for a
1427     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1428     row in the frame).
1429     """
1430     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1431 
1432     def __init__(self, start=None, end=None):
1433         self.start = Value(start)
1434         self.end = Value(end)
1435 
1436     def set_source_expressions(self, exprs):
1437         self.start, self.end = exprs
1438 
1439     def get_source_expressions(self):
1440         return [self.start, self.end]
1441 
1442     def as_sql(self, compiler, connection):
1443         connection.ops.check_expression_support(self)
1444         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1445         return self.template % {
1446             'frame_type': self.frame_type,
1447             'start': start,
1448             'end': end,
1449         }, []
1450 
1451     def __repr__(self):
1452         return '<%s: %s>' % (self.__class__.__name__, self)
1453 
1454     def get_group_by_cols(self, alias=None):
1455         return []
1456 
1457     def __str__(self):
1458         if self.start.value is not None and self.start.value < 0:
1459             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1460         elif self.start.value is not None and self.start.value == 0:
1461             start = connection.ops.CURRENT_ROW
1462         else:
1463             start = connection.ops.UNBOUNDED_PRECEDING
1464 
1465         if self.end.value is not None and self.end.value > 0:
1466             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1467         elif self.end.value is not None and self.end.value == 0:
1468             end = connection.ops.CURRENT_ROW
1469         else:
1470             end = connection.ops.UNBOUNDED_FOLLOWING
1471         return self.template % {
1472             'frame_type': self.frame_type,
1473             'start': start,
1474             'end': end,
1475         }
1476 
1477     def window_frame_start_end(self, connection, start, end):
1478         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1479 
1480 
1481 class RowRange(WindowFrame):
1482     frame_type = 'ROWS'
1483 
1484     def window_frame_start_end(self, connection, start, end):
1485         return connection.ops.window_frame_rows_start_end(start, end)
1486 
1487 
1488 class ValueRange(WindowFrame):
1489     frame_type = 'RANGE'
1490 
1491     def window_frame_start_end(self, connection, start, end):
1492         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>In the implementation of `Subquery` and possibly other related expressions, there should be clear handling or documentation of how these expressions can be used with `union` and `OR` (`|`) operations. If there's a limitation within the Django ORM that prevents the direct use of `OuterRef` in conjunction with `union`, then a workaround or clear guidelines should be provided. For example, enhancing the `Subquery` expression to internally handle or adapt to `union` directives in a way that the outer references do not lose their context or lead to SQL generation errors.</intended_behavior>]
2025-10-17 10:42:24.958 | INFO     | Search completed. Bug locations: [<file>django/db/models/query.py</file>
<class>None</class>
<method>union</method>
<code>
1034     def union(self, *other_qs, all=False):
1035         # If the query is an EmptyQuerySet, combine all nonempty querysets.
1036         if isinstance(self, EmptyQuerySet):
1037             qs = [q for q in other_qs if not isinstance(q, EmptyQuerySet)]
1038             if not qs:
1039                 return self
1040             if len(qs) == 1:
1041                 return qs[0]
1042             return qs[0]._combinator_query('union', *qs[1:], all=all)
1043         return self._combinator_query('union', *other_qs, all=all)

</code><intended_behavior>This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL.</intended_behavior>, <file>django/contrib/gis/geos/geometry.py</file>
<class>None</class>
<method>union</method>
<code>
601     def union(self, other):
602         "Return a Geometry representing all the points in this Geometry and other."
603         return self._topology(capi.geos_union(self.ptr, other.ptr))

</code><intended_behavior>This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL.</intended_behavior>, <file>django/contrib/gis/gdal/geometries.py</file>
<class>None</class>
<method>union</method>
<code>
493     def union(self, other):
494         """
495         Return a new geometry consisting of the region which is the union of
496         this geometry and the other.
497         """
498         return self._geomgen(capi.geom_union, other)

</code><intended_behavior>This file, particularly where the `union` method is implemented, should be enhanced to properly handle `Subquery` and `OuterRef` within union operations. The intended behavior should allow `union` to recognize and preserve outer references when combining queries, instead of raising an error. This requires ensuring that the SQL generated by the union operation is correctly formed when `Subquery` expressions involving `OuterRef` are used, potentially by tracking outer references and ensuring they're correctly represented in the final SQL.</intended_behavior>, <file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import functools
4 import inspect
5 from decimal import Decimal
6 from uuid import UUID
7 
8 from django.core.exceptions import EmptyResultSet, FieldError
9 from django.db import DatabaseError, NotSupportedError, connection
10 from django.db.models import fields
11 from django.db.models.constants import LOOKUP_SEP
12 from django.db.models.query_utils import Q
13 from django.utils.deconstruct import deconstructible
14 from django.utils.functional import cached_property
15 from django.utils.hashable import make_hashable
16 
17 
18 class SQLiteNumericMixin:
19     """
20     Some expressions with output_field=DecimalField() must be cast to
21     numeric to be properly filtered.
22     """
23     def as_sqlite(self, compiler, connection, **extra_context):
24         sql, params = self.as_sql(compiler, connection, **extra_context)
25         try:
26             if self.output_field.get_internal_type() == 'DecimalField':
27                 sql = 'CAST(%s AS NUMERIC)' % sql
28         except FieldError:
29             pass
30         return sql, params
31 
32 
33 class Combinable:
34     """
35     Provide the ability to combine one or two objects with
36     some connector. For example F('foo') + F('bar').
37     """
38 
39     # Arithmetic connectors
40     ADD = '+'
41     SUB = '-'
42     MUL = '*'
43     DIV = '/'
44     POW = '^'
45     # The following is a quoted % operator - it is quoted because it can be
46     # used in strings that also have parameter substitution.
47     MOD = '%%'
48 
49     # Bitwise operators - note that these are generated by .bitand()
50     # and .bitor(), the '&' and '|' are reserved for boolean operator
51     # usage.
52     BITAND = '&'
53     BITOR = '|'
54     BITLEFTSHIFT = '<<'
55     BITRIGHTSHIFT = '>>'
56     BITXOR = '#'
57 
58     def _combine(self, other, connector, reversed):
59         if not hasattr(other, 'resolve_expression'):
60             # everything must be resolvable to an expression
61             other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def bitxor(self, other):
109         return self._combine(other, self.BITXOR, False)
110 
111     def __or__(self, other):
112         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
113             return Q(self) | Q(other)
114         raise NotImplementedError(
115             "Use .bitand() and .bitor() for bitwise logical operations."
116         )
117 
118     def bitor(self, other):
119         return self._combine(other, self.BITOR, False)
120 
121     def __radd__(self, other):
122         return self._combine(other, self.ADD, True)
123 
124     def __rsub__(self, other):
125         return self._combine(other, self.SUB, True)
126 
127     def __rmul__(self, other):
128         return self._combine(other, self.MUL, True)
129 
130     def __rtruediv__(self, other):
131         return self._combine(other, self.DIV, True)
132 
133     def __rmod__(self, other):
134         return self._combine(other, self.MOD, True)
135 
136     def __rpow__(self, other):
137         return self._combine(other, self.POW, True)
138 
139     def __rand__(self, other):
140         raise NotImplementedError(
141             "Use .bitand() and .bitor() for bitwise logical operations."
142         )
143 
144     def __ror__(self, other):
145         raise NotImplementedError(
146             "Use .bitand() and .bitor() for bitwise logical operations."
147         )
148 
149 
150 class BaseExpression:
151     """Base class for all query expressions."""
152 
153     empty_result_set_value = NotImplemented
154     # aggregate specific fields
155     is_summary = False
156     _output_field_resolved_to_none = False
157     # Can the expression be used in a WHERE clause?
158     filterable = True
159     # Can the expression can be used as a source expression in Window?
160     window_compatible = False
161 
162     def __init__(self, output_field=None):
163         if output_field is not None:
164             self.output_field = output_field
165 
166     def __getstate__(self):
167         state = self.__dict__.copy()
168         state.pop('convert_value', None)
169         return state
170 
171     def get_db_converters(self, connection):
172         return (
173             []
174             if self.convert_value is self._convert_value_noop else
175             [self.convert_value]
176         ) + self.output_field.get_db_converters(connection)
177 
178     def get_source_expressions(self):
179         return []
180 
181     def set_source_expressions(self, exprs):
182         assert not exprs
183 
184     def _parse_expressions(self, *expressions):
185         return [
186             arg if hasattr(arg, 'resolve_expression') else (
187                 F(arg) if isinstance(arg, str) else Value(arg)
188             ) for arg in expressions
189         ]
190 
191     def as_sql(self, compiler, connection):
192         """
193         Responsible for returning a (sql, [params]) tuple to be included
194         in the current query.
195 
196         Different backends can provide their own implementation, by
197         providing an `as_{vendor}` method and patching the Expression:
198 
199         ```
200         def override_as_sql(self, compiler, connection):
201             # custom logic
202             return super().as_sql(compiler, connection)
203         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
204         ```
205 
206         Arguments:
207          * compiler: the query compiler responsible for generating the query.
208            Must have a compile method, returning a (sql, [params]) tuple.
209            Calling compiler(value) will return a quoted `value`.
210 
211          * connection: the database connection used for the current query.
212 
213         Return: (sql, params)
214           Where `sql` is a string containing ordered sql parameters to be
215           replaced with the elements of the list `params`.
216         """
217         raise NotImplementedError("Subclasses must implement as_sql()")
218 
219     @cached_property
220     def contains_aggregate(self):
221         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
222 
223     @cached_property
224     def contains_over_clause(self):
225         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
226 
227     @cached_property
228     def contains_column_references(self):
229         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
230 
231     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
232         """
233         Provide the chance to do any preprocessing or validation before being
234         added to the query.
235 
236         Arguments:
237          * query: the backend query implementation
238          * allow_joins: boolean allowing or denying use of joins
239            in this query
240          * reuse: a set of reusable joins for multijoins
241          * summarize: a terminal aggregate clause
242          * for_save: whether this expression about to be used in a save or update
243 
244         Return: an Expression to be added to the query.
245         """
246         c = self.copy()
247         c.is_summary = summarize
248         c.set_source_expressions([
249             expr.resolve_expression(query, allow_joins, reuse, summarize)
250             if expr else None
251             for expr in c.get_source_expressions()
252         ])
253         return c
254 
255     @property
256     def conditional(self):
257         return isinstance(self.output_field, fields.BooleanField)
258 
259     @property
260     def field(self):
261         return self.output_field
262 
263     @cached_property
264     def output_field(self):
265         """Return the output type of this expressions."""
266         output_field = self._resolve_output_field()
267         if output_field is None:
268             self._output_field_resolved_to_none = True
269             raise FieldError('Cannot resolve expression type, unknown output_field')
270         return output_field
271 
272     @cached_property
273     def _output_field_or_none(self):
274         """
275         Return the output field of this expression, or None if
276         _resolve_output_field() didn't return an output type.
277         """
278         try:
279             return self.output_field
280         except FieldError:
281             if not self._output_field_resolved_to_none:
282                 raise
283 
284     def _resolve_output_field(self):
285         """
286         Attempt to infer the output type of the expression. If the output
287         fields of all source fields match then, simply infer the same type
288         here. This isn't always correct, but it makes sense most of the time.
289 
290         Consider the difference between `2 + 2` and `2 / 3`. Inferring
291         the type here is a convenience for the common case. The user should
292         supply their own output_field with more complex computations.
293 
294         If a source's output field resolves to None, exclude it from this check.
295         If all sources are None, then an error is raised higher up the stack in
296         the output_field property.
297         """
298         sources_iter = (source for source in self.get_source_fields() if source is not None)
299         for output_field in sources_iter:
300             for source in sources_iter:
301                 if not isinstance(output_field, source.__class__):
302                     raise FieldError(
303                         'Expression contains mixed types: %s, %s. You must '
304                         'set output_field.' % (
305                             output_field.__class__.__name__,
306                             source.__class__.__name__,
307                         )
308                     )
309             return output_field
310 
311     @staticmethod
312     def _convert_value_noop(value, expression, connection):
313         return value
314 
315     @cached_property
316     def convert_value(self):
317         """
318         Expressions provide their own converters because users have the option
319         of manually specifying the output_field which may be a different type
320         from the one the database returns.
321         """
322         field = self.output_field
323         internal_type = field.get_internal_type()
324         if internal_type == 'FloatField':
325             return lambda value, expression, connection: None if value is None else float(value)
326         elif internal_type.endswith('IntegerField'):
327             return lambda value, expression, connection: None if value is None else int(value)
328         elif internal_type == 'DecimalField':
329             return lambda value, expression, connection: None if value is None else Decimal(value)
330         return self._convert_value_noop
331 
332     def get_lookup(self, lookup):
333         return self.output_field.get_lookup(lookup)
334 
335     def get_transform(self, name):
336         return self.output_field.get_transform(name)
337 
338     def relabeled_clone(self, change_map):
339         clone = self.copy()
340         clone.set_source_expressions([
341             e.relabeled_clone(change_map) if e is not None else None
342             for e in self.get_source_expressions()
343         ])
344         return clone
345 
346     def copy(self):
347         return copy.copy(self)
348 
349     def get_group_by_cols(self, alias=None):
350         if not self.contains_aggregate:
351             return [self]
352         cols = []
353         for source in self.get_source_expressions():
354             cols.extend(source.get_group_by_cols())
355         return cols
356 
357     def get_source_fields(self):
358         """Return the underlying field types used by this aggregate."""
359         return [e._output_field_or_none for e in self.get_source_expressions()]
360 
361     def asc(self, **kwargs):
362         return OrderBy(self, **kwargs)
363 
364     def desc(self, **kwargs):
365         return OrderBy(self, descending=True, **kwargs)
366 
367     def reverse_ordering(self):
368         return self
369 
370     def flatten(self):
371         """
372         Recursively yield this expression and all subexpressions, in
373         depth-first order.
374         """
375         yield self
376         for expr in self.get_source_expressions():
377             if expr:
378                 if hasattr(expr, 'flatten'):
379                     yield from expr.flatten()
380                 else:
381                     yield expr
382 
383     def select_format(self, compiler, sql, params):
384         """
385         Custom format for select clauses. For example, EXISTS expressions need
386         to be wrapped in CASE WHEN on Oracle.
387         """
388         if hasattr(self.output_field, 'select_format'):
389             return self.output_field.select_format(compiler, sql, params)
390         return sql, params
391 
392 
393 @deconstructible
394 class Expression(BaseExpression, Combinable):
395     """An expression that can be combined with other expressions."""
396 
397     @cached_property
398     def identity(self):
399         constructor_signature = inspect.signature(self.__init__)
400         args, kwargs = self._constructor_args
401         signature = constructor_signature.bind_partial(*args, **kwargs)
402         signature.apply_defaults()
403         arguments = signature.arguments.items()
404         identity = [self.__class__]
405         for arg, value in arguments:
406             if isinstance(value, fields.Field):
407                 if value.name and value.model:
408                     value = (value.model._meta.label, value.name)
409                 else:
410                     value = type(value)
411             else:
412                 value = make_hashable(value)
413             identity.append((arg, value))
414         return tuple(identity)
415 
416     def __eq__(self, other):
417         if not isinstance(other, Expression):
418             return NotImplemented
419         return other.identity == self.identity
420 
421     def __hash__(self):
422         return hash(self.identity)
423 
424 
425 _connector_combinators = {
426     connector: [
427         (fields.IntegerField, fields.IntegerField, fields.IntegerField),
428         (fields.IntegerField, fields.DecimalField, fields.DecimalField),
429         (fields.DecimalField, fields.IntegerField, fields.DecimalField),
430         (fields.IntegerField, fields.FloatField, fields.FloatField),
431         (fields.FloatField, fields.IntegerField, fields.FloatField),
432     ]
433     for connector in (Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV)
434 }
435 
436 
437 @functools.lru_cache(maxsize=128)
438 def _resolve_combined_type(connector, lhs_type, rhs_type):
439     combinators = _connector_combinators.get(connector, ())
440     for combinator_lhs_type, combinator_rhs_type, combined_type in combinators:
441         if issubclass(lhs_type, combinator_lhs_type) and issubclass(rhs_type, combinator_rhs_type):
442             return combined_type
443 
444 
445 class CombinedExpression(SQLiteNumericMixin, Expression):
446 
447     def __init__(self, lhs, connector, rhs, output_field=None):
448         super().__init__(output_field=output_field)
449         self.connector = connector
450         self.lhs = lhs
451         self.rhs = rhs
452 
453     def __repr__(self):
454         return "<{}: {}>".format(self.__class__.__name__, self)
455 
456     def __str__(self):
457         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
458 
459     def get_source_expressions(self):
460         return [self.lhs, self.rhs]
461 
462     def set_source_expressions(self, exprs):
463         self.lhs, self.rhs = exprs
464 
465     def _resolve_output_field(self):
466         try:
467             return super()._resolve_output_field()
468         except FieldError:
469             combined_type = _resolve_combined_type(
470                 self.connector,
471                 type(self.lhs.output_field),
472                 type(self.rhs.output_field),
473             )
474             if combined_type is None:
475                 raise
476             return combined_type()
477 
478     def as_sql(self, compiler, connection):
479         expressions = []
480         expression_params = []
481         sql, params = compiler.compile(self.lhs)
482         expressions.append(sql)
483         expression_params.extend(params)
484         sql, params = compiler.compile(self.rhs)
485         expressions.append(sql)
486         expression_params.extend(params)
487         # order of precedence
488         expression_wrapper = '(%s)'
489         sql = connection.ops.combine_expression(self.connector, expressions)
490         return expression_wrapper % sql, expression_params
491 
492     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
493         lhs = self.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
494         rhs = self.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
495         if not isinstance(self, (DurationExpression, TemporalSubtraction)):
496             try:
497                 lhs_type = lhs.output_field.get_internal_type()
498             except (AttributeError, FieldError):
499                 lhs_type = None
500             try:
501                 rhs_type = rhs.output_field.get_internal_type()
502             except (AttributeError, FieldError):
503                 rhs_type = None
504             if 'DurationField' in {lhs_type, rhs_type} and lhs_type != rhs_type:
505                 return DurationExpression(self.lhs, self.connector, self.rhs).resolve_expression(
506                     query, allow_joins, reuse, summarize, for_save,
507                 )
508             datetime_fields = {'DateField', 'DateTimeField', 'TimeField'}
509             if self.connector == self.SUB and lhs_type in datetime_fields and lhs_type == rhs_type:
510                 return TemporalSubtraction(self.lhs, self.rhs).resolve_expression(
511                     query, allow_joins, reuse, summarize, for_save,
512                 )
513         c = self.copy()
514         c.is_summary = summarize
515         c.lhs = lhs
516         c.rhs = rhs
517         return c
518 
519 
520 class DurationExpression(CombinedExpression):
521     def compile(self, side, compiler, connection):
522         try:
523             output = side.output_field
524         except FieldError:
525             pass
526         else:
527             if output.get_internal_type() == 'DurationField':
528                 sql, params = compiler.compile(side)
529                 return connection.ops.format_for_duration_arithmetic(sql), params
530         return compiler.compile(side)
531 
532     def as_sql(self, compiler, connection):
533         if connection.features.has_native_duration_field:
534             return super().as_sql(compiler, connection)
535         connection.ops.check_expression_support(self)
536         expressions = []
537         expression_params = []
538         sql, params = self.compile(self.lhs, compiler, connection)
539         expressions.append(sql)
540         expression_params.extend(params)
541         sql, params = self.compile(self.rhs, compiler, connection)
542         expressions.append(sql)
543         expression_params.extend(params)
544         # order of precedence
545         expression_wrapper = '(%s)'
546         sql = connection.ops.combine_duration_expression(self.connector, expressions)
547         return expression_wrapper % sql, expression_params
548 
549     def as_sqlite(self, compiler, connection, **extra_context):
550         sql, params = self.as_sql(compiler, connection, **extra_context)
551         if self.connector in {Combinable.MUL, Combinable.DIV}:
552             try:
553                 lhs_type = self.lhs.output_field.get_internal_type()
554                 rhs_type = self.rhs.output_field.get_internal_type()
555             except (AttributeError, FieldError):
556                 pass
557             else:
558                 allowed_fields = {
559                     'DecimalField', 'DurationField', 'FloatField', 'IntegerField',
560                 }
561                 if lhs_type not in allowed_fields or rhs_type not in allowed_fields:
562                     raise DatabaseError(
563                         f'Invalid arguments for operator {self.connector}.'
564                     )
565         return sql, params
566 
567 
568 class TemporalSubtraction(CombinedExpression):
569     output_field = fields.DurationField()
570 
571     def __init__(self, lhs, rhs):
572         super().__init__(lhs, self.SUB, rhs)
573 
574     def as_sql(self, compiler, connection):
575         connection.ops.check_expression_support(self)
576         lhs = compiler.compile(self.lhs)
577         rhs = compiler.compile(self.rhs)
578         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
579 
580 
581 @deconstructible(path='django.db.models.F')
582 class F(Combinable):
583     """An object capable of resolving references to existing query objects."""
584 
585     def __init__(self, name):
586         """
587         Arguments:
588          * name: the name of the field this expression references
589         """
590         self.name = name
591 
592     def __repr__(self):
593         return "{}({})".format(self.__class__.__name__, self.name)
594 
595     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
596                            summarize=False, for_save=False):
597         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
598 
599     def asc(self, **kwargs):
600         return OrderBy(self, **kwargs)
601 
602     def desc(self, **kwargs):
603         return OrderBy(self, descending=True, **kwargs)
604 
605     def __eq__(self, other):
606         return self.__class__ == other.__class__ and self.name == other.name
607 
608     def __hash__(self):
609         return hash(self.name)
610 
611 
612 class ResolvedOuterRef(F):
613     """
614     An object that contains a reference to an outer query.
615 
616     In this case, the reference to the outer query has been resolved because
617     the inner query has been used as a subquery.
618     """
619     contains_aggregate = False
620 
621     def as_sql(self, *args, **kwargs):
622         raise ValueError(
623             'This queryset contains a reference to an outer query and may '
624             'only be used in a subquery.'
625         )
626 
627     def resolve_expression(self, *args, **kwargs):
628         col = super().resolve_expression(*args, **kwargs)
629         # FIXME: Rename possibly_multivalued to multivalued and fix detection
630         # for non-multivalued JOINs (e.g. foreign key fields). This should take
631         # into accountÂ only many-to-many and one-to-many relationships.
632         col.possibly_multivalued = LOOKUP_SEP in self.name
633         return col
634 
635     def relabeled_clone(self, relabels):
636         return self
637 
638     def get_group_by_cols(self, alias=None):
639         return []
640 
641 
642 class OuterRef(F):
643     contains_aggregate = False
644 
645     def resolve_expression(self, *args, **kwargs):
646         if isinstance(self.name, self.__class__):
647             return self.name
648         return ResolvedOuterRef(self.name)
649 
650     def relabeled_clone(self, relabels):
651         return self
652 
653 
654 @deconstructible(path='django.db.models.Func')
655 class Func(SQLiteNumericMixin, Expression):
656     """An SQL function call."""
657     function = None
658     template = '%(function)s(%(expressions)s)'
659     arg_joiner = ', '
660     arity = None  # The number of arguments the function accepts.
661 
662     def __init__(self, *expressions, output_field=None, **extra):
663         if self.arity is not None and len(expressions) != self.arity:
664             raise TypeError(
665                 "'%s' takes exactly %s %s (%s given)" % (
666                     self.__class__.__name__,
667                     self.arity,
668                     "argument" if self.arity == 1 else "arguments",
669                     len(expressions),
670                 )
671             )
672         super().__init__(output_field=output_field)
673         self.source_expressions = self._parse_expressions(*expressions)
674         self.extra = extra
675 
676     def __repr__(self):
677         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
678         extra = {**self.extra, **self._get_repr_options()}
679         if extra:
680             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
681             return "{}({}, {})".format(self.__class__.__name__, args, extra)
682         return "{}({})".format(self.__class__.__name__, args)
683 
684     def _get_repr_options(self):
685         """Return a dict of extra __init__() options to include in the repr."""
686         return {}
687 
688     def get_source_expressions(self):
689         return self.source_expressions
690 
691     def set_source_expressions(self, exprs):
692         self.source_expressions = exprs
693 
694     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
695         c = self.copy()
696         c.is_summary = summarize
697         for pos, arg in enumerate(c.source_expressions):
698             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
699         return c
700 
701     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
702         connection.ops.check_expression_support(self)
703         sql_parts = []
704         params = []
705         for arg in self.source_expressions:
706             try:
707                 arg_sql, arg_params = compiler.compile(arg)
708             except EmptyResultSet:
709                 empty_result_set_value = getattr(arg, 'empty_result_set_value', NotImplemented)
710                 if empty_result_set_value is NotImplemented:
711                     raise
712                 arg_sql, arg_params = compiler.compile(Value(empty_result_set_value))
713             sql_parts.append(arg_sql)
714             params.extend(arg_params)
715         data = {**self.extra, **extra_context}
716         # Use the first supplied value in this order: the parameter to this
717         # method, a value supplied in __init__()'s **extra (the value in
718         # `data`), or the value defined on the class.
719         if function is not None:
720             data['function'] = function
721         else:
722             data.setdefault('function', self.function)
723         template = template or data.get('template', self.template)
724         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
725         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
726         return template % data, params
727 
728     def copy(self):
729         copy = super().copy()
730         copy.source_expressions = self.source_expressions[:]
731         copy.extra = self.extra.copy()
732         return copy
733 
734 
735 @deconstructible(path='django.db.models.Value')
736 class Value(SQLiteNumericMixin, Expression):
737     """Represent a wrapped value as a node within an expression."""
738     # Provide a default value for `for_save` in order to allow unresolved
739     # instances to be compiled until a decision is taken in #25425.
740     for_save = False
741 
742     def __init__(self, value, output_field=None):
743         """
744         Arguments:
745          * value: the value this expression represents. The value will be
746            added into the sql parameter list and properly quoted.
747 
748          * output_field: an instance of the model field type that this
749            expression will return, such as IntegerField() or CharField().
750         """
751         super().__init__(output_field=output_field)
752         self.value = value
753 
754     def __repr__(self):
755         return f'{self.__class__.__name__}({self.value!r})'
756 
757     def as_sql(self, compiler, connection):
758         connection.ops.check_expression_support(self)
759         val = self.value
760         output_field = self._output_field_or_none
761         if output_field is not None:
762             if self.for_save:
763                 val = output_field.get_db_prep_save(val, connection=connection)
764             else:
765                 val = output_field.get_db_prep_value(val, connection=connection)
766             if hasattr(output_field, 'get_placeholder'):
767                 return output_field.get_placeholder(val, compiler, connection), [val]
768         if val is None:
769             # cx_Oracle does not always convert None to the appropriate
770             # NULL type (like in case expressions using numbers), so we
771             # use a literal SQL NULL
772             return 'NULL', []
773         return '%s', [val]
774 
775     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
776         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
777         c.for_save = for_save
778         return c
779 
780     def get_group_by_cols(self, alias=None):
781         return []
782 
783     def _resolve_output_field(self):
784         if isinstance(self.value, str):
785             return fields.CharField()
786         if isinstance(self.value, bool):
787             return fields.BooleanField()
788         if isinstance(self.value, int):
789             return fields.IntegerField()
790         if isinstance(self.value, float):
791             return fields.FloatField()
792         if isinstance(self.value, datetime.datetime):
793             return fields.DateTimeField()
794         if isinstance(self.value, datetime.date):
795             return fields.DateField()
796         if isinstance(self.value, datetime.time):
797             return fields.TimeField()
798         if isinstance(self.value, datetime.timedelta):
799             return fields.DurationField()
800         if isinstance(self.value, Decimal):
801             return fields.DecimalField()
802         if isinstance(self.value, bytes):
803             return fields.BinaryField()
804         if isinstance(self.value, UUID):
805             return fields.UUIDField()
806 
807     @property
808     def empty_result_set_value(self):
809         return self.value
810 
811 
812 class RawSQL(Expression):
813     def __init__(self, sql, params, output_field=None):
814         if output_field is None:
815             output_field = fields.Field()
816         self.sql, self.params = sql, params
817         super().__init__(output_field=output_field)
818 
819     def __repr__(self):
820         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
821 
822     def as_sql(self, compiler, connection):
823         return '(%s)' % self.sql, self.params
824 
825     def get_group_by_cols(self, alias=None):
826         return [self]
827 
828     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
829         # Resolve parents fields used in raw SQL.
830         for parent in query.model._meta.get_parent_list():
831             for parent_field in parent._meta.local_fields:
832                 _, column_name = parent_field.get_attname_column()
833                 if column_name.lower() in self.sql.lower():
834                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
835                     break
836         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
837 
838 
839 class Star(Expression):
840     def __repr__(self):
841         return "'*'"
842 
843     def as_sql(self, compiler, connection):
844         return '*', []
845 
846 
847 class Col(Expression):
848 
849     contains_column_references = True
850     possibly_multivalued = False
851 
852     def __init__(self, alias, target, output_field=None):
853         if output_field is None:
854             output_field = target
855         super().__init__(output_field=output_field)
856         self.alias, self.target = alias, target
857 
858     def __repr__(self):
859         alias, target = self.alias, self.target
860         identifiers = (alias, str(target)) if alias else (str(target),)
861         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
862 
863     def as_sql(self, compiler, connection):
864         alias, column = self.alias, self.target.column
865         identifiers = (alias, column) if alias else (column,)
866         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
867         return sql, []
868 
869     def relabeled_clone(self, relabels):
870         if self.alias is None:
871             return self
872         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
873 
874     def get_group_by_cols(self, alias=None):
875         return [self]
876 
877     def get_db_converters(self, connection):
878         if self.target == self.output_field:
879             return self.output_field.get_db_converters(connection)
880         return (self.output_field.get_db_converters(connection) +
881                 self.target.get_db_converters(connection))
882 
883 
884 class Ref(Expression):
885     """
886     Reference to column alias of the query. For example, Ref('sum_cost') in
887     qs.annotate(sum_cost=Sum('cost')) query.
888     """
889     def __init__(self, refs, source):
890         super().__init__()
891         self.refs, self.source = refs, source
892 
893     def __repr__(self):
894         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
895 
896     def get_source_expressions(self):
897         return [self.source]
898 
899     def set_source_expressions(self, exprs):
900         self.source, = exprs
901 
902     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
903         # The sub-expression `source` has already been resolved, as this is
904         # just a reference to the name of `source`.
905         return self
906 
907     def relabeled_clone(self, relabels):
908         return self
909 
910     def as_sql(self, compiler, connection):
911         return connection.ops.quote_name(self.refs), []
912 
913     def get_group_by_cols(self, alias=None):
914         return [self]
915 
916 
917 class ExpressionList(Func):
918     """
919     An expression containing multiple expressions. Can be used to provide a
920     list of expressions as an argument to another expression, like a partition
921     clause.
922     """
923     template = '%(expressions)s'
924 
925     def __init__(self, *expressions, **extra):
926         if not expressions:
927             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
928         super().__init__(*expressions, **extra)
929 
930     def __str__(self):
931         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
932 
933     def as_sqlite(self, compiler, connection, **extra_context):
934         # Casting to numeric is unnecessary.
935         return self.as_sql(compiler, connection, **extra_context)
936 
937 
938 class OrderByList(Func):
939     template = 'ORDER BY %(expressions)s'
940 
941     def __init__(self, *expressions, **extra):
942         expressions = (
943             (
944                 OrderBy(F(expr[1:]), descending=True)
945                 if isinstance(expr, str) and expr[0] == '-'
946                 else expr
947             )
948             for expr in expressions
949         )
950         super().__init__(*expressions, **extra)
951 
952     def as_sql(self, *args, **kwargs):
953         if not self.source_expressions:
954             return '', ()
955         return super().as_sql(*args, **kwargs)
956 
957 
958 @deconstructible(path='django.db.models.ExpressionWrapper')
959 class ExpressionWrapper(SQLiteNumericMixin, Expression):
960     """
961     An expression that can wrap another expression so that it can provide
962     extra context to the inner expression, such as the output_field.
963     """
964 
965     def __init__(self, expression, output_field):
966         super().__init__(output_field=output_field)
967         self.expression = expression
968 
969     def set_source_expressions(self, exprs):
970         self.expression = exprs[0]
971 
972     def get_source_expressions(self):
973         return [self.expression]
974 
975     def get_group_by_cols(self, alias=None):
976         if isinstance(self.expression, Expression):
977             expression = self.expression.copy()
978             expression.output_field = self.output_field
979             return expression.get_group_by_cols(alias=alias)
980         # For non-expressions e.g. an SQL WHERE clause, the entire
981         # `expression` must be included in the GROUP BY clause.
982         return super().get_group_by_cols()
983 
984     def as_sql(self, compiler, connection):
985         return compiler.compile(self.expression)
986 
987     def __repr__(self):
988         return "{}({})".format(self.__class__.__name__, self.expression)
989 
990 
991 @deconstructible(path='django.db.models.When')
992 class When(Expression):
993     template = 'WHEN %(condition)s THEN %(result)s'
994     # This isn't a complete conditional expression, must be used in Case().
995     conditional = False
996 
997     def __init__(self, condition=None, then=None, **lookups):
998         if lookups:
999             if condition is None:
1000                 condition, lookups = Q(**lookups), None
1001             elif getattr(condition, 'conditional', False):
1002                 condition, lookups = Q(condition, **lookups), None
1003         if condition is None or not getattr(condition, 'conditional', False) or lookups:
1004             raise TypeError(
1005                 'When() supports a Q object, a boolean expression, or lookups '
1006                 'as a condition.'
1007             )
1008         if isinstance(condition, Q) and not condition:
1009             raise ValueError("An empty Q() can't be used as a When() condition.")
1010         super().__init__(output_field=None)
1011         self.condition = condition
1012         self.result = self._parse_expressions(then)[0]
1013 
1014     def __str__(self):
1015         return "WHEN %r THEN %r" % (self.condition, self.result)
1016 
1017     def __repr__(self):
1018         return "<%s: %s>" % (self.__class__.__name__, self)
1019 
1020     def get_source_expressions(self):
1021         return [self.condition, self.result]
1022 
1023     def set_source_expressions(self, exprs):
1024         self.condition, self.result = exprs
1025 
1026     def get_source_fields(self):
1027         # We're only interested in the fields of the result expressions.
1028         return [self.result._output_field_or_none]
1029 
1030     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1031         c = self.copy()
1032         c.is_summary = summarize
1033         if hasattr(c.condition, 'resolve_expression'):
1034             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
1035         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1036         return c
1037 
1038     def as_sql(self, compiler, connection, template=None, **extra_context):
1039         connection.ops.check_expression_support(self)
1040         template_params = extra_context
1041         sql_params = []
1042         condition_sql, condition_params = compiler.compile(self.condition)
1043         template_params['condition'] = condition_sql
1044         sql_params.extend(condition_params)
1045         result_sql, result_params = compiler.compile(self.result)
1046         template_params['result'] = result_sql
1047         sql_params.extend(result_params)
1048         template = template or self.template
1049         return template % template_params, sql_params
1050 
1051     def get_group_by_cols(self, alias=None):
1052         # This is not a complete expression and cannot be used in GROUP BY.
1053         cols = []
1054         for source in self.get_source_expressions():
1055             cols.extend(source.get_group_by_cols())
1056         return cols
1057 
1058 
1059 @deconstructible(path='django.db.models.Case')
1060 class Case(SQLiteNumericMixin, Expression):
1061     """
1062     An SQL searched CASE expression:
1063 
1064         CASE
1065             WHEN n > 0
1066                 THEN 'positive'
1067             WHEN n < 0
1068                 THEN 'negative'
1069             ELSE 'zero'
1070         END
1071     """
1072     template = 'CASE %(cases)s ELSE %(default)s END'
1073     case_joiner = ' '
1074 
1075     def __init__(self, *cases, default=None, output_field=None, **extra):
1076         if not all(isinstance(case, When) for case in cases):
1077             raise TypeError("Positional arguments must all be When objects.")
1078         super().__init__(output_field)
1079         self.cases = list(cases)
1080         self.default = self._parse_expressions(default)[0]
1081         self.extra = extra
1082 
1083     def __str__(self):
1084         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
1085 
1086     def __repr__(self):
1087         return "<%s: %s>" % (self.__class__.__name__, self)
1088 
1089     def get_source_expressions(self):
1090         return self.cases + [self.default]
1091 
1092     def set_source_expressions(self, exprs):
1093         *self.cases, self.default = exprs
1094 
1095     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
1096         c = self.copy()
1097         c.is_summary = summarize
1098         for pos, case in enumerate(c.cases):
1099             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1100         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
1101         return c
1102 
1103     def copy(self):
1104         c = super().copy()
1105         c.cases = c.cases[:]
1106         return c
1107 
1108     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
1109         connection.ops.check_expression_support(self)
1110         if not self.cases:
1111             return compiler.compile(self.default)
1112         template_params = {**self.extra, **extra_context}
1113         case_parts = []
1114         sql_params = []
1115         for case in self.cases:
1116             try:
1117                 case_sql, case_params = compiler.compile(case)
1118             except EmptyResultSet:
1119                 continue
1120             case_parts.append(case_sql)
1121             sql_params.extend(case_params)
1122         default_sql, default_params = compiler.compile(self.default)
1123         if not case_parts:
1124             return default_sql, default_params
1125         case_joiner = case_joiner or self.case_joiner
1126         template_params['cases'] = case_joiner.join(case_parts)
1127         template_params['default'] = default_sql
1128         sql_params.extend(default_params)
1129         template = template or template_params.get('template', self.template)
1130         sql = template % template_params
1131         if self._output_field_or_none is not None:
1132             sql = connection.ops.unification_cast_sql(self.output_field) % sql
1133         return sql, sql_params
1134 
1135     def get_group_by_cols(self, alias=None):
1136         if not self.cases:
1137             return self.default.get_group_by_cols(alias)
1138         return super().get_group_by_cols(alias)
1139 
1140 
1141 class Subquery(BaseExpression, Combinable):
1142     """
1143     An explicit subquery. It may contain OuterRef() references to the outer
1144     query which will be resolved when it is applied to that query.
1145     """
1146     template = '(%(subquery)s)'
1147     contains_aggregate = False
1148     empty_result_set_value = None
1149 
1150     def __init__(self, queryset, output_field=None, **extra):
1151         # Allow the usage of both QuerySet and sql.Query objects.
1152         self.query = getattr(queryset, 'query', queryset).clone()
1153         self.query.subquery = True
1154         self.extra = extra
1155         super().__init__(output_field)
1156 
1157     def get_source_expressions(self):
1158         return [self.query]
1159 
1160     def set_source_expressions(self, exprs):
1161         self.query = exprs[0]
1162 
1163     def _resolve_output_field(self):
1164         return self.query.output_field
1165 
1166     def copy(self):
1167         clone = super().copy()
1168         clone.query = clone.query.clone()
1169         return clone
1170 
1171     @property
1172     def external_aliases(self):
1173         return self.query.external_aliases
1174 
1175     def get_external_cols(self):
1176         return self.query.get_external_cols()
1177 
1178     def as_sql(self, compiler, connection, template=None, query=None, **extra_context):
1179         connection.ops.check_expression_support(self)
1180         template_params = {**self.extra, **extra_context}
1181         query = query or self.query
1182         subquery_sql, sql_params = query.as_sql(compiler, connection)
1183         template_params['subquery'] = subquery_sql[1:-1]
1184 
1185         template = template or template_params.get('template', self.template)
1186         sql = template % template_params
1187         return sql, sql_params
1188 
1189     def get_group_by_cols(self, alias=None):
1190         # If this expression is referenced by an alias for an explicit GROUP BY
1191         # through values() a reference to this expression and not the
1192         # underlying .query must be returned to ensure external column
1193         # references are not grouped against as well.
1194         if alias:
1195             return [Ref(alias, self)]
1196         return self.query.get_group_by_cols()
1197 
1198 
1199 class Exists(Subquery):
1200     template = 'EXISTS(%(subquery)s)'
1201     output_field = fields.BooleanField()
1202 
1203     def __init__(self, queryset, negated=False, **kwargs):
1204         self.negated = negated
1205         super().__init__(queryset, **kwargs)
1206 
1207     def __invert__(self):
1208         clone = self.copy()
1209         clone.negated = not self.negated
1210         return clone
1211 
1212     def as_sql(self, compiler, connection, template=None, **extra_context):
1213         query = self.query.exists(using=connection.alias)
1214         sql, params = super().as_sql(
1215             compiler,
1216             connection,
1217             template=template,
1218             query=query,
1219             **extra_context,
1220         )
1221         if self.negated:
1222             sql = 'NOT {}'.format(sql)
1223         return sql, params
1224 
1225     def select_format(self, compiler, sql, params):
1226         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1227         # (e.g. Oracle) doesn't support boolean expression in SELECT or GROUP
1228         # BY list.
1229         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1230             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1231         return sql, params
1232 
1233 
1234 @deconstructible(path='django.db.models.OrderBy')
1235 class OrderBy(Expression):
1236     template = '%(expression)s %(ordering)s'
1237     conditional = False
1238 
1239     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1240         if nulls_first and nulls_last:
1241             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1242         self.nulls_first = nulls_first
1243         self.nulls_last = nulls_last
1244         self.descending = descending
1245         if not hasattr(expression, 'resolve_expression'):
1246             raise ValueError('expression must be an expression type')
1247         self.expression = expression
1248 
1249     def __repr__(self):
1250         return "{}({}, descending={})".format(
1251             self.__class__.__name__, self.expression, self.descending)
1252 
1253     def set_source_expressions(self, exprs):
1254         self.expression = exprs[0]
1255 
1256     def get_source_expressions(self):
1257         return [self.expression]
1258 
1259     def as_sql(self, compiler, connection, template=None, **extra_context):
1260         template = template or self.template
1261         if connection.features.supports_order_by_nulls_modifier:
1262             if self.nulls_last:
1263                 template = '%s NULLS LAST' % template
1264             elif self.nulls_first:
1265                 template = '%s NULLS FIRST' % template
1266         else:
1267             if self.nulls_last and not (
1268                 self.descending and connection.features.order_by_nulls_first
1269             ):
1270                 template = '%%(expression)s IS NULL, %s' % template
1271             elif self.nulls_first and not (
1272                 not self.descending and connection.features.order_by_nulls_first
1273             ):
1274                 template = '%%(expression)s IS NOT NULL, %s' % template
1275         connection.ops.check_expression_support(self)
1276         expression_sql, params = compiler.compile(self.expression)
1277         placeholders = {
1278             'expression': expression_sql,
1279             'ordering': 'DESC' if self.descending else 'ASC',
1280             **extra_context,
1281         }
1282         params *= template.count('%(expression)s')
1283         return (template % placeholders).rstrip(), params
1284 
1285     def as_oracle(self, compiler, connection):
1286         # Oracle doesn't allow ORDER BY EXISTS() or filters unless it's wrapped
1287         # in a CASE WHEN.
1288         if connection.ops.conditional_expression_supported_in_where_clause(self.expression):
1289             copy = self.copy()
1290             copy.expression = Case(
1291                 When(self.expression, then=True),
1292                 default=False,
1293             )
1294             return copy.as_sql(compiler, connection)
1295         return self.as_sql(compiler, connection)
1296 
1297     def get_group_by_cols(self, alias=None):
1298         cols = []
1299         for source in self.get_source_expressions():
1300             cols.extend(source.get_group_by_cols())
1301         return cols
1302 
1303     def reverse_ordering(self):
1304         self.descending = not self.descending
1305         if self.nulls_first or self.nulls_last:
1306             self.nulls_first = not self.nulls_first
1307             self.nulls_last = not self.nulls_last
1308         return self
1309 
1310     def asc(self):
1311         self.descending = False
1312 
1313     def desc(self):
1314         self.descending = True
1315 
1316 
1317 class Window(SQLiteNumericMixin, Expression):
1318     template = '%(expression)s OVER (%(window)s)'
1319     # Although the main expression may either be an aggregate or an
1320     # expression with an aggregate function, the GROUP BY that will
1321     # be introduced in the query as a result is not desired.
1322     contains_aggregate = False
1323     contains_over_clause = True
1324     filterable = False
1325 
1326     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1327         self.partition_by = partition_by
1328         self.order_by = order_by
1329         self.frame = frame
1330 
1331         if not getattr(expression, 'window_compatible', False):
1332             raise ValueError(
1333                 "Expression '%s' isn't compatible with OVER clauses." %
1334                 expression.__class__.__name__
1335             )
1336 
1337         if self.partition_by is not None:
1338             if not isinstance(self.partition_by, (tuple, list)):
1339                 self.partition_by = (self.partition_by,)
1340             self.partition_by = ExpressionList(*self.partition_by)
1341 
1342         if self.order_by is not None:
1343             if isinstance(self.order_by, (list, tuple)):
1344                 self.order_by = OrderByList(*self.order_by)
1345             elif isinstance(self.order_by, (BaseExpression, str)):
1346                 self.order_by = OrderByList(self.order_by)
1347             else:
1348                 raise ValueError(
1349                     'Window.order_by must be either a string reference to a '
1350                     'field, an expression, or a list or tuple of them.'
1351                 )
1352         super().__init__(output_field=output_field)
1353         self.source_expression = self._parse_expressions(expression)[0]
1354 
1355     def _resolve_output_field(self):
1356         return self.source_expression.output_field
1357 
1358     def get_source_expressions(self):
1359         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1360 
1361     def set_source_expressions(self, exprs):
1362         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1363 
1364     def as_sql(self, compiler, connection, template=None):
1365         connection.ops.check_expression_support(self)
1366         if not connection.features.supports_over_clause:
1367             raise NotSupportedError('This backend does not support window expressions.')
1368         expr_sql, params = compiler.compile(self.source_expression)
1369         window_sql, window_params = [], []
1370 
1371         if self.partition_by is not None:
1372             sql_expr, sql_params = self.partition_by.as_sql(
1373                 compiler=compiler, connection=connection,
1374                 template='PARTITION BY %(expressions)s',
1375             )
1376             window_sql.append(sql_expr)
1377             window_params.extend(sql_params)
1378 
1379         if self.order_by is not None:
1380             order_sql, order_params = compiler.compile(self.order_by)
1381             window_sql.append(order_sql)
1382             window_params.extend(order_params)
1383 
1384         if self.frame:
1385             frame_sql, frame_params = compiler.compile(self.frame)
1386             window_sql.append(frame_sql)
1387             window_params.extend(frame_params)
1388 
1389         params.extend(window_params)
1390         template = template or self.template
1391 
1392         return template % {
1393             'expression': expr_sql,
1394             'window': ' '.join(window_sql).strip()
1395         }, params
1396 
1397     def as_sqlite(self, compiler, connection):
1398         if isinstance(self.output_field, fields.DecimalField):
1399             # Casting to numeric must be outside of the window expression.
1400             copy = self.copy()
1401             source_expressions = copy.get_source_expressions()
1402             source_expressions[0].output_field = fields.FloatField()
1403             copy.set_source_expressions(source_expressions)
1404             return super(Window, copy).as_sqlite(compiler, connection)
1405         return self.as_sql(compiler, connection)
1406 
1407     def __str__(self):
1408         return '{} OVER ({}{}{})'.format(
1409             str(self.source_expression),
1410             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1411             str(self.order_by or ''),
1412             str(self.frame or ''),
1413         )
1414 
1415     def __repr__(self):
1416         return '<%s: %s>' % (self.__class__.__name__, self)
1417 
1418     def get_group_by_cols(self, alias=None):
1419         return []
1420 
1421 
1422 class WindowFrame(Expression):
1423     """
1424     Model the frame clause in window expressions. There are two types of frame
1425     clauses which are subclasses, however, all processing and validation (by no
1426     means intended to be complete) is done here. Thus, providing an end for a
1427     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1428     row in the frame).
1429     """
1430     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1431 
1432     def __init__(self, start=None, end=None):
1433         self.start = Value(start)
1434         self.end = Value(end)
1435 
1436     def set_source_expressions(self, exprs):
1437         self.start, self.end = exprs
1438 
1439     def get_source_expressions(self):
1440         return [self.start, self.end]
1441 
1442     def as_sql(self, compiler, connection):
1443         connection.ops.check_expression_support(self)
1444         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1445         return self.template % {
1446             'frame_type': self.frame_type,
1447             'start': start,
1448             'end': end,
1449         }, []
1450 
1451     def __repr__(self):
1452         return '<%s: %s>' % (self.__class__.__name__, self)
1453 
1454     def get_group_by_cols(self, alias=None):
1455         return []
1456 
1457     def __str__(self):
1458         if self.start.value is not None and self.start.value < 0:
1459             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1460         elif self.start.value is not None and self.start.value == 0:
1461             start = connection.ops.CURRENT_ROW
1462         else:
1463             start = connection.ops.UNBOUNDED_PRECEDING
1464 
1465         if self.end.value is not None and self.end.value > 0:
1466             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1467         elif self.end.value is not None and self.end.value == 0:
1468             end = connection.ops.CURRENT_ROW
1469         else:
1470             end = connection.ops.UNBOUNDED_FOLLOWING
1471         return self.template % {
1472             'frame_type': self.frame_type,
1473             'start': start,
1474             'end': end,
1475         }
1476 
1477     def window_frame_start_end(self, connection, start, end):
1478         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1479 
1480 
1481 class RowRange(WindowFrame):
1482     frame_type = 'ROWS'
1483 
1484     def window_frame_start_end(self, connection, start, end):
1485         return connection.ops.window_frame_rows_start_end(start, end)
1486 
1487 
1488 class ValueRange(WindowFrame):
1489     frame_type = 'RANGE'
1490 
1491     def window_frame_start_end(self, connection, start, end):
1492         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>In the implementation of `Subquery` and possibly other related expressions, there should be clear handling or documentation of how these expressions can be used with `union` and `OR` (`|`) operations. If there's a limitation within the Django ORM that prevents the direct use of `OuterRef` in conjunction with `union`, then a workaround or clear guidelines should be provided. For example, enhancing the `Subquery` expression to internally handle or adapt to `union` directives in a way that the outer references do not lose their context or lead to SQL generation errors.</intended_behavior>]
2025-10-17 10:42:24.958 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 10:42:24.958 | INFO     | Search-only: skipping patch selection
2025-10-17 10:42:25.221 | INFO     | Task django__django-11692 completed successfully.
2025-10-17 10:42:25.222 | INFO     | No patch generated. You can try running ACR again.
