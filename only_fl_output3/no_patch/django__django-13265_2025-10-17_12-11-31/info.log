2025-10-17 12:11:31.883 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 12:11:35.287 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=547, output_tokens=12, cost=0.005830
2025-10-17 12:11:35.287 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 12:11:35.291 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:11:40.475 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=804, output_tokens=175, cost=0.013290
2025-10-17 12:11:40.520 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:11:44.055 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=529, output_tokens=38, cost=0.006430
2025-10-17 12:11:44.056 | DEBUG    | Extracted a valid json.
2025-10-17 12:11:44.056 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LookImage\")",
        "search_code(\"AlterOrderWithRespectTo\")"
    ],
    "bug_locations": []
}
2025-10-17 12:11:44.099 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 12:11:44.100 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 12:12:00.714 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1209, output_tokens=658, cost=0.031830
2025-10-17 12:12:00.724 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:12:08.299 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2083, output_tokens=293, cost=0.029620
2025-10-17 12:12:08.305 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:12:17.601 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=647, output_tokens=237, cost=0.013580
2025-10-17 12:12:17.603 | DEBUG    | Extracted a valid json.
2025-10-17 12:12:17.603 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/migrations/autodetector.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify the migration autodetection logic to ensure that `AlterOrderWithRespectTo` operations are correctly identified and sequenced before any index creation operations involving fields affected by the `AlterOrderWithRespectTo`. This adjustment would account for the necessary creation or adjustment of fields like `_order` before attempts are made to index them, thus preventing the reported crash."
        },
        {
            "file": "django/db/migrations/operations/models.py",
            "class": "",
            "method": "AlterOrderWithRespectTo",
            "intended_behavior": "The `AlterOrderWithRespectTo` operation logic may require adjustments to ensure that when it runs, the migration system either checks for the existence of the `_order` field or explicitly defines it before any index operations referencing this field are executed. This might involve modifying how the operation is interpreted or executed within migrations to ensure dependency order is respected."
        }
    ]
}
2025-10-17 12:12:17.617 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject
13 from django.utils.topological_sort import stable_topological_sort
14 
15 
16 class MigrationAutodetector:
17     """
18     Take a pair of ProjectStates and compare them to see what the first would
19     need doing to make it match the second (the second usually being the
20     project's current state).
21 
22     Note that this naturally operates on entire projects at a time,
23     as it's likely that changes interact (for example, you can't
24     add a ForeignKey without having a migration to add the table it
25     depends on first). A user interface may offer single-app usage
26     if it wishes, with the caveat that it may not always be possible.
27     """
28 
29     def __init__(self, from_state, to_state, questioner=None):
30         self.from_state = from_state
31         self.to_state = to_state
32         self.questioner = questioner or MigrationQuestioner()
33         self.existing_apps = {app for app, model in from_state.models}
34 
35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
36         """
37         Main entry point to produce a list of applicable changes.
38         Take a graph to base names on and an optional set of apps
39         to try and restrict to (restriction is not guaranteed)
40         """
41         changes = self._detect_changes(convert_apps, graph)
42         changes = self.arrange_for_graph(changes, graph, migration_name)
43         if trim_to_apps:
44             changes = self._trim_to_apps(changes, trim_to_apps)
45         return changes
46 
47     def deep_deconstruct(self, obj):
48         """
49         Recursive deconstruction for a field and its arguments.
50         Used for full comparison for rename/alter; sometimes a single-level
51         deconstruction will not compare correctly.
52         """
53         if isinstance(obj, list):
54             return [self.deep_deconstruct(value) for value in obj]
55         elif isinstance(obj, tuple):
56             return tuple(self.deep_deconstruct(value) for value in obj)
57         elif isinstance(obj, dict):
58             return {
59                 key: self.deep_deconstruct(value)
60                 for key, value in obj.items()
61             }
62         elif isinstance(obj, functools.partial):
63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
64         elif isinstance(obj, COMPILED_REGEX_TYPE):
65             return RegexObject(obj)
66         elif isinstance(obj, type):
67             # If this is a type that implements 'deconstruct' as an instance method,
68             # avoid treating this as being deconstructible itself - see #22951
69             return obj
70         elif hasattr(obj, 'deconstruct'):
71             deconstructed = obj.deconstruct()
72             if isinstance(obj, models.Field):
73                 # we have a field which also returns a name
74                 deconstructed = deconstructed[1:]
75             path, args, kwargs = deconstructed
76             return (
77                 path,
78                 [self.deep_deconstruct(value) for value in args],
79                 {
80                     key: self.deep_deconstruct(value)
81                     for key, value in kwargs.items()
82                 },
83             )
84         else:
85             return obj
86 
87     def only_relation_agnostic_fields(self, fields):
88         """
89         Return a definition of the fields that ignores field names and
90         what related fields actually relate to. Used for detecting renames (as
91         the related fields change during renames).
92         """
93         fields_def = []
94         for name, field in sorted(fields.items()):
95             deconstruction = self.deep_deconstruct(field)
96             if field.remote_field and field.remote_field.model:
97                 del deconstruction[2]['to']
98             fields_def.append(deconstruction)
99         return fields_def
100 
101     def _detect_changes(self, convert_apps=None, graph=None):
102         """
103         Return a dict of migration plans which will achieve the
104         change from from_state to to_state. The dict has app labels
105         as keys and a list of migrations as values.
106 
107         The resulting migrations aren't specially named, but the names
108         do matter for dependencies inside the set.
109 
110         convert_apps is the list of apps to convert to use migrations
111         (i.e. to make initial migrations for, in the usual case)
112 
113         graph is an optional argument that, if provided, can help improve
114         dependency generation and avoid potential circular dependencies.
115         """
116         # The first phase is generating all the operations for each app
117         # and gathering them into a big per-app list.
118         # Then go through that list, order it, and split into migrations to
119         # resolve dependencies caused by M2Ms and FKs.
120         self.generated_operations = {}
121         self.altered_indexes = {}
122         self.altered_constraints = {}
123 
124         # Prepare some old/new state and model lists, separating
125         # proxy models and ignoring unmigrated apps.
126         self.old_apps = self.from_state.concrete_apps
127         self.new_apps = self.to_state.apps
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for al, mn in self.from_state.models:
135             model = self.old_apps.get_model(al, mn)
136             if not model._meta.managed:
137                 self.old_unmanaged_keys.add((al, mn))
138             elif al not in self.from_state.real_apps:
139                 if model._meta.proxy:
140                     self.old_proxy_keys.add((al, mn))
141                 else:
142                     self.old_model_keys.add((al, mn))
143 
144         for al, mn in self.to_state.models:
145             model = self.new_apps.get_model(al, mn)
146             if not model._meta.managed:
147                 self.new_unmanaged_keys.add((al, mn))
148             elif (
149                 al not in self.from_state.real_apps or
150                 (convert_apps and al in convert_apps)
151             ):
152                 if model._meta.proxy:
153                     self.new_proxy_keys.add((al, mn))
154                 else:
155                     self.new_model_keys.add((al, mn))
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field operations
181         self.generate_renamed_fields()
182         self.generate_removed_fields()
183         self.generate_added_fields()
184         self.generate_altered_fields()
185         self.generate_altered_unique_together()
186         self.generate_altered_index_together()
187         self.generate_added_indexes()
188         self.generate_added_constraints()
189         self.generate_altered_db_table()
190         self.generate_altered_order_with_respect_to()
191 
192         self._sort_migrations()
193         self._build_migration_list(graph)
194         self._optimize_migrations()
195 
196         return self.migrations
197 
198     def _prepare_field_lists(self):
199         """
200         Prepare field lists and a list of the fields that used through models
201         in the old state so dependencies can be made from the through model
202         deletion to the field that uses it.
203         """
204         self.kept_model_keys = self.old_model_keys & self.new_model_keys
205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
207         self.through_users = {}
208         self.old_field_keys = {
209             (app_label, model_name, field_name)
210             for app_label, model_name in self.kept_model_keys
211             for field_name in self.from_state.models[
212                 app_label,
213                 self.renamed_models.get((app_label, model_name), model_name)
214             ].fields
215         }
216         self.new_field_keys = {
217             (app_label, model_name, field_name)
218             for app_label, model_name in self.kept_model_keys
219             for field_name in self.to_state.models[app_label, model_name].fields
220         }
221 
222     def _generate_through_model_map(self):
223         """Through model map generation."""
224         for app_label, model_name in sorted(self.old_model_keys):
225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
226             old_model_state = self.from_state.models[app_label, old_model_name]
227             for field_name in old_model_state.fields:
228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
229                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
230                         not old_field.remote_field.through._meta.auto_created):
231                     through_key = (
232                         old_field.remote_field.through._meta.app_label,
233                         old_field.remote_field.through._meta.model_name,
234                     )
235                     self.through_users[through_key] = (app_label, old_model_name, field_name)
236 
237     @staticmethod
238     def _resolve_dependency(dependency):
239         """
240         Return the resolved dependency and a boolean denoting whether or not
241         it was swappable.
242         """
243         if dependency[0] != '__setting__':
244             return dependency, False
245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
247 
248     def _build_migration_list(self, graph=None):
249         """
250         Chop the lists of operations up into migrations with dependencies on
251         each other. Do this by going through an app's list of operations until
252         one is found that has an outgoing dependency that isn't in another
253         app's migration yet (hasn't been chopped off its list). Then chop off
254         the operations before it into a migration and move onto the next app.
255         If the loops completes without doing anything, there's a circular
256         dependency (which _should_ be impossible as the operations are
257         all split at this point so they can't depend and be depended on).
258         """
259         self.migrations = {}
260         num_ops = sum(len(x) for x in self.generated_operations.values())
261         chop_mode = False
262         while num_ops:
263             # On every iteration, we step through all the apps and see if there
264             # is a completed set of operations.
265             # If we find that a subset of the operations are complete we can
266             # try to chop it off from the rest and continue, but we only
267             # do this if we've already been through the list once before
268             # without any chopping and nothing has changed.
269             for app_label in sorted(self.generated_operations):
270                 chopped = []
271                 dependencies = set()
272                 for operation in list(self.generated_operations[app_label]):
273                     deps_satisfied = True
274                     operation_dependencies = set()
275                     for dep in operation._auto_deps:
276                         # Temporarily resolve the swappable dependency to
277                         # prevent circular references. While keeping the
278                         # dependency checks on the resolved model, add the
279                         # swappable dependencies.
280                         original_dep = dep
281                         dep, is_swappable_dep = self._resolve_dependency(dep)
282                         if dep[0] != app_label:
283                             # External app dependency. See if it's not yet
284                             # satisfied.
285                             for other_operation in self.generated_operations.get(dep[0], []):
286                                 if self.check_dependency(other_operation, dep):
287                                     deps_satisfied = False
288                                     break
289                             if not deps_satisfied:
290                                 break
291                             else:
292                                 if is_swappable_dep:
293                                     operation_dependencies.add((original_dep[0], original_dep[1]))
294                                 elif dep[0] in self.migrations:
295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
296                                 else:
297                                     # If we can't find the other app, we add a first/last dependency,
298                                     # but only if we've already been through once and checked everything
299                                     if chop_mode:
300                                         # If the app already exists, we add a dependency on the last migration,
301                                         # as we don't know which migration contains the target field.
302                                         # If it's not yet migrated or has no migrations, we use __first__
303                                         if graph and graph.leaf_nodes(dep[0]):
304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
305                                         else:
306                                             operation_dependencies.add((dep[0], "__first__"))
307                                     else:
308                                         deps_satisfied = False
309                     if deps_satisfied:
310                         chopped.append(operation)
311                         dependencies.update(operation_dependencies)
312                         del self.generated_operations[app_label][0]
313                     else:
314                         break
315                 # Make a migration! Well, only if there's stuff to put in it
316                 if dependencies or chopped:
317                     if not self.generated_operations[app_label] or chop_mode:
318                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
319                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
320                         instance.dependencies = list(dependencies)
321                         instance.operations = chopped
322                         instance.initial = app_label not in self.existing_apps
323                         self.migrations.setdefault(app_label, []).append(instance)
324                         chop_mode = False
325                     else:
326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
327             new_num_ops = sum(len(x) for x in self.generated_operations.values())
328             if new_num_ops == num_ops:
329                 if not chop_mode:
330                     chop_mode = True
331                 else:
332                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
333             num_ops = new_num_ops
334 
335     def _sort_migrations(self):
336         """
337         Reorder to make things possible. Reordering may be needed so FKs work
338         nicely inside the same app.
339         """
340         for app_label, ops in sorted(self.generated_operations.items()):
341             # construct a dependency graph for intra-app dependencies
342             dependency_graph = {op: set() for op in ops}
343             for op in ops:
344                 for dep in op._auto_deps:
345                     # Resolve intra-app dependencies to handle circular
346                     # references involving a swappable model.
347                     dep = self._resolve_dependency(dep)[0]
348                     if dep[0] == app_label:
349                         for op2 in ops:
350                             if self.check_dependency(op2, dep):
351                                 dependency_graph[op].add(op2)
352 
353             # we use a stable sort for deterministic tests & general behavior
354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
355 
356     def _optimize_migrations(self):
357         # Add in internal dependencies among the migrations
358         for app_label, migrations in self.migrations.items():
359             for m1, m2 in zip(migrations, migrations[1:]):
360                 m2.dependencies.append((app_label, m1.name))
361 
362         # De-dupe dependencies
363         for migrations in self.migrations.values():
364             for migration in migrations:
365                 migration.dependencies = list(set(migration.dependencies))
366 
367         # Optimize migrations
368         for app_label, migrations in self.migrations.items():
369             for migration in migrations:
370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
371 
372     def check_dependency(self, operation, dependency):
373         """
374         Return True if the given operation depends on the given dependency,
375         False otherwise.
376         """
377         # Created model
378         if dependency[2] is None and dependency[3] is True:
379             return (
380                 isinstance(operation, operations.CreateModel) and
381                 operation.name_lower == dependency[1].lower()
382             )
383         # Created field
384         elif dependency[2] is not None and dependency[3] is True:
385             return (
386                 (
387                     isinstance(operation, operations.CreateModel) and
388                     operation.name_lower == dependency[1].lower() and
389                     any(dependency[2] == x for x, y in operation.fields)
390                 ) or
391                 (
392                     isinstance(operation, operations.AddField) and
393                     operation.model_name_lower == dependency[1].lower() and
394                     operation.name_lower == dependency[2].lower()
395                 )
396             )
397         # Removed field
398         elif dependency[2] is not None and dependency[3] is False:
399             return (
400                 isinstance(operation, operations.RemoveField) and
401                 operation.model_name_lower == dependency[1].lower() and
402                 operation.name_lower == dependency[2].lower()
403             )
404         # Removed model
405         elif dependency[2] is None and dependency[3] is False:
406             return (
407                 isinstance(operation, operations.DeleteModel) and
408                 operation.name_lower == dependency[1].lower()
409             )
410         # Field being altered
411         elif dependency[2] is not None and dependency[3] == "alter":
412             return (
413                 isinstance(operation, operations.AlterField) and
414                 operation.model_name_lower == dependency[1].lower() and
415                 operation.name_lower == dependency[2].lower()
416             )
417         # order_with_respect_to being unset for a field
418         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
419             return (
420                 isinstance(operation, operations.AlterOrderWithRespectTo) and
421                 operation.name_lower == dependency[1].lower() and
422                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
423             )
424         # Field is removed and part of an index/unique_together
425         elif dependency[2] is not None and dependency[3] == "foo_together_change":
426             return (
427                 isinstance(operation, (operations.AlterUniqueTogether,
428                                        operations.AlterIndexTogether)) and
429                 operation.name_lower == dependency[1].lower()
430             )
431         # Unknown dependency. Raise an error.
432         else:
433             raise ValueError("Can't handle dependency %r" % (dependency,))
434 
435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
437         operation._auto_deps = dependencies or []
438         if beginning:
439             self.generated_operations.setdefault(app_label, []).insert(0, operation)
440         else:
441             self.generated_operations.setdefault(app_label, []).append(operation)
442 
443     def swappable_first_key(self, item):
444         """
445         Place potential swappable models first in lists of created models (only
446         real way to solve #22783).
447         """
448         try:
449             model = self.new_apps.get_model(item[0], item[1])
450             base_names = [base.__name__ for base in model.__bases__]
451             string_version = "%s.%s" % (item[0], item[1])
452             if (
453                 model._meta.swappable or
454                 "AbstractUser" in base_names or
455                 "AbstractBaseUser" in base_names or
456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
457             ):
458                 return ("___" + item[0], "___" + item[1])
459         except LookupError:
460             pass
461         return item
462 
463     def generate_renamed_models(self):
464         """
465         Find any renamed models, generate the operations for them, and remove
466         the old entry from the model lists. Must be run before other
467         model-level generation.
468         """
469         self.renamed_models = {}
470         self.renamed_models_rel = {}
471         added_models = self.new_model_keys - self.old_model_keys
472         for app_label, model_name in sorted(added_models):
473             model_state = self.to_state.models[app_label, model_name]
474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
475 
476             removed_models = self.old_model_keys - self.new_model_keys
477             for rem_app_label, rem_model_name in removed_models:
478                 if rem_app_label == app_label:
479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
481                     if model_fields_def == rem_model_fields_def:
482                         if self.questioner.ask_rename_model(rem_model_state, model_state):
483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
484                             dependencies = []
485                             for field in model_opts.get_fields():
486                                 if field.is_relation:
487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
488                             self.add_operation(
489                                 app_label,
490                                 operations.RenameModel(
491                                     old_name=rem_model_state.name,
492                                     new_name=model_state.name,
493                                 ),
494                                 dependencies=dependencies,
495                             )
496                             self.renamed_models[app_label, model_name] = rem_model_name
497                             renamed_models_rel_key = '%s.%s' % (
498                                 rem_model_state.app_label,
499                                 rem_model_state.name_lower,
500                             )
501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
502                                 model_state.app_label,
503                                 model_state.name_lower,
504                             )
505                             self.old_model_keys.remove((rem_app_label, rem_model_name))
506                             self.old_model_keys.add((app_label, model_name))
507                             break
508 
509     def generate_created_models(self):
510         """
511         Find all new models (both managed and unmanaged) and make create
512         operations for them as well as separate operations to create any
513         foreign key or M2M relationships (these are optimized later, if
514         possible).
515 
516         Defer any model options that refer to collections of fields that might
517         be deferred (e.g. unique_together, index_together).
518         """
519         old_keys = self.old_model_keys | self.old_unmanaged_keys
520         added_models = self.new_model_keys - old_keys
521         added_unmanaged_models = self.new_unmanaged_keys - old_keys
522         all_added_models = chain(
523             sorted(added_models, key=self.swappable_first_key, reverse=True),
524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
525         )
526         for app_label, model_name in all_added_models:
527             model_state = self.to_state.models[app_label, model_name]
528             model_opts = self.new_apps.get_model(app_label, model_name)._meta
529             # Gather related fields
530             related_fields = {}
531             primary_key_rel = None
532             for field in model_opts.local_fields:
533                 if field.remote_field:
534                     if field.remote_field.model:
535                         if field.primary_key:
536                             primary_key_rel = field.remote_field.model
537                         elif not field.remote_field.parent_link:
538                             related_fields[field.name] = field
539                     # through will be none on M2Ms on swapped-out models;
540                     # we can treat lack of through as auto_created=True, though.
541                     if (getattr(field.remote_field, "through", None) and
542                             not field.remote_field.through._meta.auto_created):
543                         related_fields[field.name] = field
544             for field in model_opts.local_many_to_many:
545                 if field.remote_field.model:
546                     related_fields[field.name] = field
547                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
548                     related_fields[field.name] = field
549             # Are there indexes/unique|index_together to defer?
550             indexes = model_state.options.pop('indexes')
551             constraints = model_state.options.pop('constraints')
552             unique_together = model_state.options.pop('unique_together', None)
553             index_together = model_state.options.pop('index_together', None)
554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
555             # Depend on the deletion of any possible proxy version of us
556             dependencies = [
557                 (app_label, model_name, None, False),
558             ]
559             # Depend on all bases
560             for base in model_state.bases:
561                 if isinstance(base, str) and "." in base:
562                     base_app_label, base_name = base.split(".", 1)
563                     dependencies.append((base_app_label, base_name, None, True))
564                     # Depend on the removal of base fields if the new model has
565                     # a field with the same name.
566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
568                     if old_base_model_state and new_base_model_state:
569                         removed_base_fields = set(old_base_model_state.fields).difference(
570                             new_base_model_state.fields,
571                         ).intersection(model_state.fields)
572                         for removed_base_field in removed_base_fields:
573                             dependencies.append((base_app_label, base_name, removed_base_field, False))
574             # Depend on the other end of the primary key if it's a relation
575             if primary_key_rel:
576                 dependencies.append((
577                     primary_key_rel._meta.app_label,
578                     primary_key_rel._meta.object_name,
579                     None,
580                     True
581                 ))
582             # Generate creation operation
583             self.add_operation(
584                 app_label,
585                 operations.CreateModel(
586                     name=model_state.name,
587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
588                     options=model_state.options,
589                     bases=model_state.bases,
590                     managers=model_state.managers,
591                 ),
592                 dependencies=dependencies,
593                 beginning=True,
594             )
595 
596             # Don't add operations which modify the database for unmanaged models
597             if not model_opts.managed:
598                 continue
599 
600             # Generate operations for each related field
601             for name, field in sorted(related_fields.items()):
602                 dependencies = self._get_dependencies_for_foreign_key(field)
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             related_dependencies = [
617                 (app_label, model_name, name, True)
618                 for name in sorted(related_fields)
619             ]
620             related_dependencies.append((app_label, model_name, None, True))
621             for index in indexes:
622                 self.add_operation(
623                     app_label,
624                     operations.AddIndex(
625                         model_name=model_name,
626                         index=index,
627                     ),
628                     dependencies=related_dependencies,
629                 )
630             for constraint in constraints:
631                 self.add_operation(
632                     app_label,
633                     operations.AddConstraint(
634                         model_name=model_name,
635                         constraint=constraint,
636                     ),
637                     dependencies=related_dependencies,
638                 )
639             if unique_together:
640                 self.add_operation(
641                     app_label,
642                     operations.AlterUniqueTogether(
643                         name=model_name,
644                         unique_together=unique_together,
645                     ),
646                     dependencies=related_dependencies
647                 )
648             if index_together:
649                 self.add_operation(
650                     app_label,
651                     operations.AlterIndexTogether(
652                         name=model_name,
653                         index_together=index_together,
654                     ),
655                     dependencies=related_dependencies
656                 )
657             if order_with_respect_to:
658                 self.add_operation(
659                     app_label,
660                     operations.AlterOrderWithRespectTo(
661                         name=model_name,
662                         order_with_respect_to=order_with_respect_to,
663                     ),
664                     dependencies=[
665                         (app_label, model_name, order_with_respect_to, True),
666                         (app_label, model_name, None, True),
667                     ]
668                 )
669 
670             # Fix relationships if the model changed from a proxy model to a
671             # concrete model.
672             if (app_label, model_name) in self.old_proxy_keys:
673                 for related_object in model_opts.related_objects:
674                     self.add_operation(
675                         related_object.related_model._meta.app_label,
676                         operations.AlterField(
677                             model_name=related_object.related_model._meta.object_name,
678                             name=related_object.field.name,
679                             field=related_object.field,
680                         ),
681                         dependencies=[(app_label, model_name, None, True)],
682                     )
683 
684     def generate_created_proxies(self):
685         """
686         Make CreateModel statements for proxy models. Use the same statements
687         as that way there's less code duplication, but for proxy models it's
688         safe to skip all the pointless field stuff and chuck out an operation.
689         """
690         added = self.new_proxy_keys - self.old_proxy_keys
691         for app_label, model_name in sorted(added):
692             model_state = self.to_state.models[app_label, model_name]
693             assert model_state.options.get("proxy")
694             # Depend on the deletion of any possible non-proxy version of us
695             dependencies = [
696                 (app_label, model_name, None, False),
697             ]
698             # Depend on all bases
699             for base in model_state.bases:
700                 if isinstance(base, str) and "." in base:
701                     base_app_label, base_name = base.split(".", 1)
702                     dependencies.append((base_app_label, base_name, None, True))
703             # Generate creation operation
704             self.add_operation(
705                 app_label,
706                 operations.CreateModel(
707                     name=model_state.name,
708                     fields=[],
709                     options=model_state.options,
710                     bases=model_state.bases,
711                     managers=model_state.managers,
712                 ),
713                 # Depend on the deletion of any possible non-proxy version of us
714                 dependencies=dependencies,
715             )
716 
717     def generate_deleted_models(self):
718         """
719         Find all deleted models (managed and unmanaged) and make delete
720         operations for them as well as separate operations to delete any
721         foreign key or M2M relationships (these are optimized later, if
722         possible).
723 
724         Also bring forward removal of any model options that refer to
725         collections of fields - the inverse of generate_created_models().
726         """
727         new_keys = self.new_model_keys | self.new_unmanaged_keys
728         deleted_models = self.old_model_keys - new_keys
729         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
730         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
731         for app_label, model_name in all_deleted_models:
732             model_state = self.from_state.models[app_label, model_name]
733             model = self.old_apps.get_model(app_label, model_name)
734             # Gather related fields
735             related_fields = {}
736             for field in model._meta.local_fields:
737                 if field.remote_field:
738                     if field.remote_field.model:
739                         related_fields[field.name] = field
740                     # through will be none on M2Ms on swapped-out models;
741                     # we can treat lack of through as auto_created=True, though.
742                     if (getattr(field.remote_field, "through", None) and
743                             not field.remote_field.through._meta.auto_created):
744                         related_fields[field.name] = field
745             for field in model._meta.local_many_to_many:
746                 if field.remote_field.model:
747                     related_fields[field.name] = field
748                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
749                     related_fields[field.name] = field
750             # Generate option removal first
751             unique_together = model_state.options.pop('unique_together', None)
752             index_together = model_state.options.pop('index_together', None)
753             if unique_together:
754                 self.add_operation(
755                     app_label,
756                     operations.AlterUniqueTogether(
757                         name=model_name,
758                         unique_together=None,
759                     )
760                 )
761             if index_together:
762                 self.add_operation(
763                     app_label,
764                     operations.AlterIndexTogether(
765                         name=model_name,
766                         index_together=None,
767                     )
768                 )
769             # Then remove each related field
770             for name in sorted(related_fields):
771                 self.add_operation(
772                     app_label,
773                     operations.RemoveField(
774                         model_name=model_name,
775                         name=name,
776                     )
777                 )
778             # Finally, remove the model.
779             # This depends on both the removal/alteration of all incoming fields
780             # and the removal of all its own related fields, and if it's
781             # a through model the field that references it.
782             dependencies = []
783             for related_object in model._meta.related_objects:
784                 related_object_app_label = related_object.related_model._meta.app_label
785                 object_name = related_object.related_model._meta.object_name
786                 field_name = related_object.field.name
787                 dependencies.append((related_object_app_label, object_name, field_name, False))
788                 if not related_object.many_to_many:
789                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
790 
791             for name in sorted(related_fields):
792                 dependencies.append((app_label, model_name, name, False))
793             # We're referenced in another field's through=
794             through_user = self.through_users.get((app_label, model_state.name_lower))
795             if through_user:
796                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
797             # Finally, make the operation, deduping any dependencies
798             self.add_operation(
799                 app_label,
800                 operations.DeleteModel(
801                     name=model_state.name,
802                 ),
803                 dependencies=list(set(dependencies)),
804             )
805 
806     def generate_deleted_proxies(self):
807         """Make DeleteModel options for proxy models."""
808         deleted = self.old_proxy_keys - self.new_proxy_keys
809         for app_label, model_name in sorted(deleted):
810             model_state = self.from_state.models[app_label, model_name]
811             assert model_state.options.get("proxy")
812             self.add_operation(
813                 app_label,
814                 operations.DeleteModel(
815                     name=model_state.name,
816                 ),
817             )
818 
819     def generate_renamed_fields(self):
820         """Work out renamed fields."""
821         self.renamed_fields = {}
822         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
823             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
824             old_model_state = self.from_state.models[app_label, old_model_name]
825             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
826             # Scan to see if this is actually a rename!
827             field_dec = self.deep_deconstruct(field)
828             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
829                 if rem_app_label == app_label and rem_model_name == model_name:
830                     old_field = old_model_state.fields[rem_field_name]
831                     old_field_dec = self.deep_deconstruct(old_field)
832                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
833                         old_rel_to = old_field_dec[2]['to']
834                         if old_rel_to in self.renamed_models_rel:
835                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
836                     old_field.set_attributes_from_name(rem_field_name)
837                     old_db_column = old_field.get_attname_column()[1]
838                     if (old_field_dec == field_dec or (
839                             # Was the field renamed and db_column equal to the
840                             # old field's column added?
841                             old_field_dec[0:2] == field_dec[0:2] and
842                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
843                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
844                             self.add_operation(
845                                 app_label,
846                                 operations.RenameField(
847                                     model_name=model_name,
848                                     old_name=rem_field_name,
849                                     new_name=field_name,
850                                 )
851                             )
852                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
853                             self.old_field_keys.add((app_label, model_name, field_name))
854                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
855                             break
856 
857     def generate_added_fields(self):
858         """Make AddField operations."""
859         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
860             self._generate_added_field(app_label, model_name, field_name)
861 
862     def _generate_added_field(self, app_label, model_name, field_name):
863         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
864         # Fields that are foreignkeys/m2ms depend on stuff
865         dependencies = []
866         if field.remote_field and field.remote_field.model:
867             dependencies.extend(self._get_dependencies_for_foreign_key(field))
868         # You can't just add NOT NULL fields with no default or fields
869         # which don't allow empty strings as default.
870         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
871         preserve_default = (
872             field.null or field.has_default() or field.many_to_many or
873             (field.blank and field.empty_strings_allowed) or
874             (isinstance(field, time_fields) and field.auto_now)
875         )
876         if not preserve_default:
877             field = field.clone()
878             if isinstance(field, time_fields) and field.auto_now_add:
879                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
880             else:
881                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
882         self.add_operation(
883             app_label,
884             operations.AddField(
885                 model_name=model_name,
886                 name=field_name,
887                 field=field,
888                 preserve_default=preserve_default,
889             ),
890             dependencies=dependencies,
891         )
892 
893     def generate_removed_fields(self):
894         """Make RemoveField operations."""
895         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
896             self._generate_removed_field(app_label, model_name, field_name)
897 
898     def _generate_removed_field(self, app_label, model_name, field_name):
899         self.add_operation(
900             app_label,
901             operations.RemoveField(
902                 model_name=model_name,
903                 name=field_name,
904             ),
905             # We might need to depend on the removal of an
906             # order_with_respect_to or index/unique_together operation;
907             # this is safely ignored if there isn't one
908             dependencies=[
909                 (app_label, model_name, field_name, "order_wrt_unset"),
910                 (app_label, model_name, field_name, "foo_together_change"),
911             ],
912         )
913 
914     def generate_altered_fields(self):
915         """
916         Make AlterField operations, or possibly RemovedField/AddField if alter
917         isn's possible.
918         """
919         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
920             # Did the field change?
921             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
922             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
923             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
924             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
925             dependencies = []
926             # Implement any model renames on relations; these are handled by RenameModel
927             # so we need to exclude them from the comparison
928             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
929                 rename_key = (
930                     new_field.remote_field.model._meta.app_label,
931                     new_field.remote_field.model._meta.model_name,
932                 )
933                 if rename_key in self.renamed_models:
934                     new_field.remote_field.model = old_field.remote_field.model
935                 # Handle ForeignKey which can only have a single to_field.
936                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
937                 if remote_field_name:
938                     to_field_rename_key = rename_key + (remote_field_name,)
939                     if to_field_rename_key in self.renamed_fields:
940                         # Repoint both model and field name because to_field
941                         # inclusion in ForeignKey.deconstruct() is based on
942                         # both.
943                         new_field.remote_field.model = old_field.remote_field.model
944                         new_field.remote_field.field_name = old_field.remote_field.field_name
945                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
946                 from_fields = getattr(new_field, 'from_fields', None)
947                 if from_fields:
948                     from_rename_key = (app_label, model_name)
949                     new_field.from_fields = tuple([
950                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
951                         for from_field in from_fields
952                     ])
953                     new_field.to_fields = tuple([
954                         self.renamed_fields.get(rename_key + (to_field,), to_field)
955                         for to_field in new_field.to_fields
956                     ])
957                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
958             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
959                 rename_key = (
960                     new_field.remote_field.through._meta.app_label,
961                     new_field.remote_field.through._meta.model_name,
962                 )
963                 if rename_key in self.renamed_models:
964                     new_field.remote_field.through = old_field.remote_field.through
965             old_field_dec = self.deep_deconstruct(old_field)
966             new_field_dec = self.deep_deconstruct(new_field)
967             if old_field_dec != new_field_dec:
968                 both_m2m = old_field.many_to_many and new_field.many_to_many
969                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
970                 if both_m2m or neither_m2m:
971                     # Either both fields are m2m or neither is
972                     preserve_default = True
973                     if (old_field.null and not new_field.null and not new_field.has_default() and
974                             not new_field.many_to_many):
975                         field = new_field.clone()
976                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
977                         if new_default is not models.NOT_PROVIDED:
978                             field.default = new_default
979                             preserve_default = False
980                     else:
981                         field = new_field
982                     self.add_operation(
983                         app_label,
984                         operations.AlterField(
985                             model_name=model_name,
986                             name=field_name,
987                             field=field,
988                             preserve_default=preserve_default,
989                         ),
990                         dependencies=dependencies,
991                     )
992                 else:
993                     # We cannot alter between m2m and concrete fields
994                     self._generate_removed_field(app_label, model_name, field_name)
995                     self._generate_added_field(app_label, model_name, field_name)
996 
997     def create_altered_indexes(self):
998         option_name = operations.AddIndex.option_name
999         for app_label, model_name in sorted(self.kept_model_keys):
1000             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1001             old_model_state = self.from_state.models[app_label, old_model_name]
1002             new_model_state = self.to_state.models[app_label, model_name]
1003 
1004             old_indexes = old_model_state.options[option_name]
1005             new_indexes = new_model_state.options[option_name]
1006             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1007             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1008 
1009             self.altered_indexes.update({
1010                 (app_label, model_name): {
1011                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1012                 }
1013             })
1014 
1015     def generate_added_indexes(self):
1016         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1017             for index in alt_indexes['added_indexes']:
1018                 self.add_operation(
1019                     app_label,
1020                     operations.AddIndex(
1021                         model_name=model_name,
1022                         index=index,
1023                     )
1024                 )
1025 
1026     def generate_removed_indexes(self):
1027         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1028             for index in alt_indexes['removed_indexes']:
1029                 self.add_operation(
1030                     app_label,
1031                     operations.RemoveIndex(
1032                         model_name=model_name,
1033                         name=index.name,
1034                     )
1035                 )
1036 
1037     def create_altered_constraints(self):
1038         option_name = operations.AddConstraint.option_name
1039         for app_label, model_name in sorted(self.kept_model_keys):
1040             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1041             old_model_state = self.from_state.models[app_label, old_model_name]
1042             new_model_state = self.to_state.models[app_label, model_name]
1043 
1044             old_constraints = old_model_state.options[option_name]
1045             new_constraints = new_model_state.options[option_name]
1046             add_constraints = [c for c in new_constraints if c not in old_constraints]
1047             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1048 
1049             self.altered_constraints.update({
1050                 (app_label, model_name): {
1051                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1052                 }
1053             })
1054 
1055     def generate_added_constraints(self):
1056         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1057             for constraint in alt_constraints['added_constraints']:
1058                 self.add_operation(
1059                     app_label,
1060                     operations.AddConstraint(
1061                         model_name=model_name,
1062                         constraint=constraint,
1063                     )
1064                 )
1065 
1066     def generate_removed_constraints(self):
1067         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1068             for constraint in alt_constraints['removed_constraints']:
1069                 self.add_operation(
1070                     app_label,
1071                     operations.RemoveConstraint(
1072                         model_name=model_name,
1073                         name=constraint.name,
1074                     )
1075                 )
1076 
1077     def _get_dependencies_for_foreign_key(self, field):
1078         # Account for FKs to swappable models
1079         swappable_setting = getattr(field, 'swappable_setting', None)
1080         if swappable_setting is not None:
1081             dep_app_label = "__setting__"
1082             dep_object_name = swappable_setting
1083         else:
1084             dep_app_label = field.remote_field.model._meta.app_label
1085             dep_object_name = field.remote_field.model._meta.object_name
1086         dependencies = [(dep_app_label, dep_object_name, None, True)]
1087         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1088             dependencies.append((
1089                 field.remote_field.through._meta.app_label,
1090                 field.remote_field.through._meta.object_name,
1091                 None,
1092                 True,
1093             ))
1094         return dependencies
1095 
1096     def _generate_altered_foo_together(self, operation):
1097         option_name = operation.option_name
1098         for app_label, model_name in sorted(self.kept_model_keys):
1099             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1100             old_model_state = self.from_state.models[app_label, old_model_name]
1101             new_model_state = self.to_state.models[app_label, model_name]
1102 
1103             # We run the old version through the field renames to account for those
1104             old_value = old_model_state.options.get(option_name)
1105             old_value = {
1106                 tuple(
1107                     self.renamed_fields.get((app_label, model_name, n), n)
1108                     for n in unique
1109                 )
1110                 for unique in old_value
1111             } if old_value else set()
1112 
1113             new_value = new_model_state.options.get(option_name)
1114             new_value = set(new_value) if new_value else set()
1115 
1116             if old_value != new_value:
1117                 dependencies = []
1118                 for foo_togethers in new_value:
1119                     for field_name in foo_togethers:
1120                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1121                         if field.remote_field and field.remote_field.model:
1122                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1123 
1124                 self.add_operation(
1125                     app_label,
1126                     operation(
1127                         name=model_name,
1128                         **{option_name: new_value}
1129                     ),
1130                     dependencies=dependencies,
1131                 )
1132 
1133     def generate_altered_unique_together(self):
1134         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1135 
1136     def generate_altered_index_together(self):
1137         self._generate_altered_foo_together(operations.AlterIndexTogether)
1138 
1139     def generate_altered_db_table(self):
1140         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1141         for app_label, model_name in sorted(models_to_check):
1142             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1143             old_model_state = self.from_state.models[app_label, old_model_name]
1144             new_model_state = self.to_state.models[app_label, model_name]
1145             old_db_table_name = old_model_state.options.get('db_table')
1146             new_db_table_name = new_model_state.options.get('db_table')
1147             if old_db_table_name != new_db_table_name:
1148                 self.add_operation(
1149                     app_label,
1150                     operations.AlterModelTable(
1151                         name=model_name,
1152                         table=new_db_table_name,
1153                     )
1154                 )
1155 
1156     def generate_altered_options(self):
1157         """
1158         Work out if any non-schema-affecting options have changed and make an
1159         operation to represent them in state changes (in case Python code in
1160         migrations needs them).
1161         """
1162         models_to_check = self.kept_model_keys.union(
1163             self.kept_proxy_keys,
1164             self.kept_unmanaged_keys,
1165             # unmanaged converted to managed
1166             self.old_unmanaged_keys & self.new_model_keys,
1167             # managed converted to unmanaged
1168             self.old_model_keys & self.new_unmanaged_keys,
1169         )
1170 
1171         for app_label, model_name in sorted(models_to_check):
1172             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1173             old_model_state = self.from_state.models[app_label, old_model_name]
1174             new_model_state = self.to_state.models[app_label, model_name]
1175             old_options = {
1176                 key: value for key, value in old_model_state.options.items()
1177                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1178             }
1179             new_options = {
1180                 key: value for key, value in new_model_state.options.items()
1181                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1182             }
1183             if old_options != new_options:
1184                 self.add_operation(
1185                     app_label,
1186                     operations.AlterModelOptions(
1187                         name=model_name,
1188                         options=new_options,
1189                     )
1190                 )
1191 
1192     def generate_altered_order_with_respect_to(self):
1193         for app_label, model_name in sorted(self.kept_model_keys):
1194             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1195             old_model_state = self.from_state.models[app_label, old_model_name]
1196             new_model_state = self.to_state.models[app_label, model_name]
1197             if (old_model_state.options.get("order_with_respect_to") !=
1198                     new_model_state.options.get("order_with_respect_to")):
1199                 # Make sure it comes second if we're adding
1200                 # (removal dependency is part of RemoveField)
1201                 dependencies = []
1202                 if new_model_state.options.get("order_with_respect_to"):
1203                     dependencies.append((
1204                         app_label,
1205                         model_name,
1206                         new_model_state.options["order_with_respect_to"],
1207                         True,
1208                     ))
1209                 # Actually generate the operation
1210                 self.add_operation(
1211                     app_label,
1212                     operations.AlterOrderWithRespectTo(
1213                         name=model_name,
1214                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1215                     ),
1216                     dependencies=dependencies,
1217                 )
1218 
1219     def generate_altered_managers(self):
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1222             old_model_state = self.from_state.models[app_label, old_model_name]
1223             new_model_state = self.to_state.models[app_label, model_name]
1224             if old_model_state.managers != new_model_state.managers:
1225                 self.add_operation(
1226                     app_label,
1227                     operations.AlterModelManagers(
1228                         name=model_name,
1229                         managers=new_model_state.managers,
1230                     )
1231                 )
1232 
1233     def arrange_for_graph(self, changes, graph, migration_name=None):
1234         """
1235         Take a result from changes() and a MigrationGraph, and fix the names
1236         and dependencies of the changes so they extend the graph from the leaf
1237         nodes for each app.
1238         """
1239         leaves = graph.leaf_nodes()
1240         name_map = {}
1241         for app_label, migrations in list(changes.items()):
1242             if not migrations:
1243                 continue
1244             # Find the app label's current leaf node
1245             app_leaf = None
1246             for leaf in leaves:
1247                 if leaf[0] == app_label:
1248                     app_leaf = leaf
1249                     break
1250             # Do they want an initial migration for this app?
1251             if app_leaf is None and not self.questioner.ask_initial(app_label):
1252                 # They don't.
1253                 for migration in migrations:
1254                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1255                 del changes[app_label]
1256                 continue
1257             # Work out the next number in the sequence
1258             if app_leaf is None:
1259                 next_number = 1
1260             else:
1261                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1262             # Name each migration
1263             for i, migration in enumerate(migrations):
1264                 if i == 0 and app_leaf:
1265                     migration.dependencies.append(app_leaf)
1266                 new_name_parts = ['%04i' % next_number]
1267                 if migration_name:
1268                     new_name_parts.append(migration_name)
1269                 elif i == 0 and not app_leaf:
1270                     new_name_parts.append('initial')
1271                 else:
1272                     new_name_parts.append(migration.suggest_name()[:100])
1273                 new_name = '_'.join(new_name_parts)
1274                 name_map[(app_label, migration.name)] = (app_label, new_name)
1275                 next_number += 1
1276                 migration.name = new_name
1277         # Now fix dependencies
1278         for migrations in changes.values():
1279             for migration in migrations:
1280                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1281         return changes
1282 
1283     def _trim_to_apps(self, changes, app_labels):
1284         """
1285         Take changes from arrange_for_graph() and set of app labels, and return
1286         a modified set of changes which trims out as many migrations that are
1287         not in app_labels as possible. Note that some other migrations may
1288         still be present as they may be required dependencies.
1289         """
1290         # Gather other app dependencies in a first pass
1291         app_dependencies = {}
1292         for app_label, migrations in changes.items():
1293             for migration in migrations:
1294                 for dep_app_label, name in migration.dependencies:
1295                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1296         required_apps = set(app_labels)
1297         # Keep resolving till there's no change
1298         old_required_apps = None
1299         while old_required_apps != required_apps:
1300             old_required_apps = set(required_apps)
1301             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1302         # Remove all migrations that aren't needed
1303         for app_label in list(changes):
1304             if app_label not in required_apps:
1305                 del changes[app_label]
1306         return changes
1307 
1308     @classmethod
1309     def parse_number(cls, name):
1310         """
1311         Given a migration name, try to extract a number from the beginning of
1312         it. If no number is found, return None.
1313         """
1314         match = re.match(r'^\d+', name)
1315         if match:
1316             return int(match[0])
1317         return None

</code><intended_behavior>Modify the migration autodetection logic to ensure that `AlterOrderWithRespectTo` operations are correctly identified and sequenced before any index creation operations involving fields affected by the `AlterOrderWithRespectTo`. This adjustment would account for the necessary creation or adjustment of fields like `_order` before attempts are made to index them, thus preventing the reported crash.</intended_behavior>, <file>django/db/migrations/operations/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db import models
2 from django.db.migrations.operations.base import Operation
3 from django.db.migrations.state import ModelState
4 from django.db.models.options import normalize_together
5 from django.utils.functional import cached_property
6 
7 from .fields import (
8     AddField, AlterField, FieldOperation, RemoveField, RenameField,
9 )
10 from .utils import field_references, get_references, resolve_relation
11 
12 
13 def _check_for_duplicates(arg_name, objs):
14     used_vals = set()
15     for val in objs:
16         if val in used_vals:
17             raise ValueError(
18                 "Found duplicate value %s in CreateModel %s argument." % (val, arg_name)
19             )
20         used_vals.add(val)
21 
22 
23 class ModelOperation(Operation):
24     def __init__(self, name):
25         self.name = name
26 
27     @cached_property
28     def name_lower(self):
29         return self.name.lower()
30 
31     def references_model(self, name, app_label):
32         return name.lower() == self.name_lower
33 
34     def reduce(self, operation, app_label):
35         return (
36             super().reduce(operation, app_label) or
37             not operation.references_model(self.name, app_label)
38         )
39 
40 
41 class CreateModel(ModelOperation):
42     """Create a model's table."""
43 
44     serialization_expand_args = ['fields', 'options', 'managers']
45 
46     def __init__(self, name, fields, options=None, bases=None, managers=None):
47         self.fields = fields
48         self.options = options or {}
49         self.bases = bases or (models.Model,)
50         self.managers = managers or []
51         super().__init__(name)
52         # Sanity-check that there are no duplicated field names, bases, or
53         # manager names
54         _check_for_duplicates('fields', (name for name, _ in self.fields))
55         _check_for_duplicates('bases', (
56             base._meta.label_lower if hasattr(base, '_meta') else
57             base.lower() if isinstance(base, str) else base
58             for base in self.bases
59         ))
60         _check_for_duplicates('managers', (name for name, _ in self.managers))
61 
62     def deconstruct(self):
63         kwargs = {
64             'name': self.name,
65             'fields': self.fields,
66         }
67         if self.options:
68             kwargs['options'] = self.options
69         if self.bases and self.bases != (models.Model,):
70             kwargs['bases'] = self.bases
71         if self.managers and self.managers != [('objects', models.Manager())]:
72             kwargs['managers'] = self.managers
73         return (
74             self.__class__.__qualname__,
75             [],
76             kwargs
77         )
78 
79     def state_forwards(self, app_label, state):
80         state.add_model(ModelState(
81             app_label,
82             self.name,
83             list(self.fields),
84             dict(self.options),
85             tuple(self.bases),
86             list(self.managers),
87         ))
88 
89     def database_forwards(self, app_label, schema_editor, from_state, to_state):
90         model = to_state.apps.get_model(app_label, self.name)
91         if self.allow_migrate_model(schema_editor.connection.alias, model):
92             schema_editor.create_model(model)
93 
94     def database_backwards(self, app_label, schema_editor, from_state, to_state):
95         model = from_state.apps.get_model(app_label, self.name)
96         if self.allow_migrate_model(schema_editor.connection.alias, model):
97             schema_editor.delete_model(model)
98 
99     def describe(self):
100         return "Create %smodel %s" % ("proxy " if self.options.get("proxy", False) else "", self.name)
101 
102     @property
103     def migration_name_fragment(self):
104         return self.name_lower
105 
106     def references_model(self, name, app_label):
107         name_lower = name.lower()
108         if name_lower == self.name_lower:
109             return True
110 
111         # Check we didn't inherit from the model
112         reference_model_tuple = (app_label, name_lower)
113         for base in self.bases:
114             if (base is not models.Model and isinstance(base, (models.base.ModelBase, str)) and
115                     resolve_relation(base, app_label) == reference_model_tuple):
116                 return True
117 
118         # Check we have no FKs/M2Ms with it
119         for _name, field in self.fields:
120             if field_references((app_label, self.name_lower), field, reference_model_tuple):
121                 return True
122         return False
123 
124     def reduce(self, operation, app_label):
125         if (isinstance(operation, DeleteModel) and
126                 self.name_lower == operation.name_lower and
127                 not self.options.get("proxy", False)):
128             return []
129         elif isinstance(operation, RenameModel) and self.name_lower == operation.old_name_lower:
130             return [
131                 CreateModel(
132                     operation.new_name,
133                     fields=self.fields,
134                     options=self.options,
135                     bases=self.bases,
136                     managers=self.managers,
137                 ),
138             ]
139         elif isinstance(operation, AlterModelOptions) and self.name_lower == operation.name_lower:
140             return [
141                 CreateModel(
142                     self.name,
143                     fields=self.fields,
144                     options={**self.options, **operation.options},
145                     bases=self.bases,
146                     managers=self.managers,
147                 ),
148             ]
149         elif isinstance(operation, AlterTogetherOptionOperation) and self.name_lower == operation.name_lower:
150             return [
151                 CreateModel(
152                     self.name,
153                     fields=self.fields,
154                     options={**self.options, **{operation.option_name: operation.option_value}},
155                     bases=self.bases,
156                     managers=self.managers,
157                 ),
158             ]
159         elif isinstance(operation, AlterOrderWithRespectTo) and self.name_lower == operation.name_lower:
160             return [
161                 CreateModel(
162                     self.name,
163                     fields=self.fields,
164                     options={**self.options, 'order_with_respect_to': operation.order_with_respect_to},
165                     bases=self.bases,
166                     managers=self.managers,
167                 ),
168             ]
169         elif isinstance(operation, FieldOperation) and self.name_lower == operation.model_name_lower:
170             if isinstance(operation, AddField):
171                 return [
172                     CreateModel(
173                         self.name,
174                         fields=self.fields + [(operation.name, operation.field)],
175                         options=self.options,
176                         bases=self.bases,
177                         managers=self.managers,
178                     ),
179                 ]
180             elif isinstance(operation, AlterField):
181                 return [
182                     CreateModel(
183                         self.name,
184                         fields=[
185                             (n, operation.field if n == operation.name else v)
186                             for n, v in self.fields
187                         ],
188                         options=self.options,
189                         bases=self.bases,
190                         managers=self.managers,
191                     ),
192                 ]
193             elif isinstance(operation, RemoveField):
194                 options = self.options.copy()
195                 for option_name in ('unique_together', 'index_together'):
196                     option = options.pop(option_name, None)
197                     if option:
198                         option = set(filter(bool, (
199                             tuple(f for f in fields if f != operation.name_lower) for fields in option
200                         )))
201                         if option:
202                             options[option_name] = option
203                 order_with_respect_to = options.get('order_with_respect_to')
204                 if order_with_respect_to == operation.name_lower:
205                     del options['order_with_respect_to']
206                 return [
207                     CreateModel(
208                         self.name,
209                         fields=[
210                             (n, v)
211                             for n, v in self.fields
212                             if n.lower() != operation.name_lower
213                         ],
214                         options=options,
215                         bases=self.bases,
216                         managers=self.managers,
217                     ),
218                 ]
219             elif isinstance(operation, RenameField):
220                 options = self.options.copy()
221                 for option_name in ('unique_together', 'index_together'):
222                     option = options.get(option_name)
223                     if option:
224                         options[option_name] = {
225                             tuple(operation.new_name if f == operation.old_name else f for f in fields)
226                             for fields in option
227                         }
228                 order_with_respect_to = options.get('order_with_respect_to')
229                 if order_with_respect_to == operation.old_name:
230                     options['order_with_respect_to'] = operation.new_name
231                 return [
232                     CreateModel(
233                         self.name,
234                         fields=[
235                             (operation.new_name if n == operation.old_name else n, v)
236                             for n, v in self.fields
237                         ],
238                         options=options,
239                         bases=self.bases,
240                         managers=self.managers,
241                     ),
242                 ]
243         return super().reduce(operation, app_label)
244 
245 
246 class DeleteModel(ModelOperation):
247     """Drop a model's table."""
248 
249     def deconstruct(self):
250         kwargs = {
251             'name': self.name,
252         }
253         return (
254             self.__class__.__qualname__,
255             [],
256             kwargs
257         )
258 
259     def state_forwards(self, app_label, state):
260         state.remove_model(app_label, self.name_lower)
261 
262     def database_forwards(self, app_label, schema_editor, from_state, to_state):
263         model = from_state.apps.get_model(app_label, self.name)
264         if self.allow_migrate_model(schema_editor.connection.alias, model):
265             schema_editor.delete_model(model)
266 
267     def database_backwards(self, app_label, schema_editor, from_state, to_state):
268         model = to_state.apps.get_model(app_label, self.name)
269         if self.allow_migrate_model(schema_editor.connection.alias, model):
270             schema_editor.create_model(model)
271 
272     def references_model(self, name, app_label):
273         # The deleted model could be referencing the specified model through
274         # related fields.
275         return True
276 
277     def describe(self):
278         return "Delete model %s" % self.name
279 
280     @property
281     def migration_name_fragment(self):
282         return 'delete_%s' % self.name_lower
283 
284 
285 class RenameModel(ModelOperation):
286     """Rename a model."""
287 
288     def __init__(self, old_name, new_name):
289         self.old_name = old_name
290         self.new_name = new_name
291         super().__init__(old_name)
292 
293     @cached_property
294     def old_name_lower(self):
295         return self.old_name.lower()
296 
297     @cached_property
298     def new_name_lower(self):
299         return self.new_name.lower()
300 
301     def deconstruct(self):
302         kwargs = {
303             'old_name': self.old_name,
304             'new_name': self.new_name,
305         }
306         return (
307             self.__class__.__qualname__,
308             [],
309             kwargs
310         )
311 
312     def state_forwards(self, app_label, state):
313         # Add a new model.
314         renamed_model = state.models[app_label, self.old_name_lower].clone()
315         renamed_model.name = self.new_name
316         state.models[app_label, self.new_name_lower] = renamed_model
317         # Repoint all fields pointing to the old model to the new one.
318         old_model_tuple = (app_label, self.old_name_lower)
319         new_remote_model = '%s.%s' % (app_label, self.new_name)
320         to_reload = set()
321         for model_state, name, field, reference in get_references(state, old_model_tuple):
322             changed_field = None
323             if reference.to:
324                 changed_field = field.clone()
325                 changed_field.remote_field.model = new_remote_model
326             if reference.through:
327                 if changed_field is None:
328                     changed_field = field.clone()
329                 changed_field.remote_field.through = new_remote_model
330             if changed_field:
331                 model_state.fields[name] = changed_field
332                 to_reload.add((model_state.app_label, model_state.name_lower))
333         # Reload models related to old model before removing the old model.
334         state.reload_models(to_reload, delay=True)
335         # Remove the old model.
336         state.remove_model(app_label, self.old_name_lower)
337         state.reload_model(app_label, self.new_name_lower, delay=True)
338 
339     def database_forwards(self, app_label, schema_editor, from_state, to_state):
340         new_model = to_state.apps.get_model(app_label, self.new_name)
341         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
342             old_model = from_state.apps.get_model(app_label, self.old_name)
343             # Move the main table
344             schema_editor.alter_db_table(
345                 new_model,
346                 old_model._meta.db_table,
347                 new_model._meta.db_table,
348             )
349             # Alter the fields pointing to us
350             for related_object in old_model._meta.related_objects:
351                 if related_object.related_model == old_model:
352                     model = new_model
353                     related_key = (app_label, self.new_name_lower)
354                 else:
355                     model = related_object.related_model
356                     related_key = (
357                         related_object.related_model._meta.app_label,
358                         related_object.related_model._meta.model_name,
359                     )
360                 to_field = to_state.apps.get_model(
361                     *related_key
362                 )._meta.get_field(related_object.field.name)
363                 schema_editor.alter_field(
364                     model,
365                     related_object.field,
366                     to_field,
367                 )
368             # Rename M2M fields whose name is based on this model's name.
369             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)
370             for (old_field, new_field) in fields:
371                 # Skip self-referential fields as these are renamed above.
372                 if new_field.model == new_field.related_model or not new_field.remote_field.through._meta.auto_created:
373                     continue
374                 # Rename the M2M table that's based on this model's name.
375                 old_m2m_model = old_field.remote_field.through
376                 new_m2m_model = new_field.remote_field.through
377                 schema_editor.alter_db_table(
378                     new_m2m_model,
379                     old_m2m_model._meta.db_table,
380                     new_m2m_model._meta.db_table,
381                 )
382                 # Rename the column in the M2M table that's based on this
383                 # model's name.
384                 schema_editor.alter_field(
385                     new_m2m_model,
386                     old_m2m_model._meta.get_field(old_model._meta.model_name),
387                     new_m2m_model._meta.get_field(new_model._meta.model_name),
388                 )
389 
390     def database_backwards(self, app_label, schema_editor, from_state, to_state):
391         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower
392         self.new_name, self.old_name = self.old_name, self.new_name
393 
394         self.database_forwards(app_label, schema_editor, from_state, to_state)
395 
396         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower
397         self.new_name, self.old_name = self.old_name, self.new_name
398 
399     def references_model(self, name, app_label):
400         return (
401             name.lower() == self.old_name_lower or
402             name.lower() == self.new_name_lower
403         )
404 
405     def describe(self):
406         return "Rename model %s to %s" % (self.old_name, self.new_name)
407 
408     @property
409     def migration_name_fragment(self):
410         return 'rename_%s_%s' % (self.old_name_lower, self.new_name_lower)
411 
412     def reduce(self, operation, app_label):
413         if (isinstance(operation, RenameModel) and
414                 self.new_name_lower == operation.old_name_lower):
415             return [
416                 RenameModel(
417                     self.old_name,
418                     operation.new_name,
419                 ),
420             ]
421         # Skip `ModelOperation.reduce` as we want to run `references_model`
422         # against self.new_name.
423         return (
424             super(ModelOperation, self).reduce(operation, app_label) or
425             not operation.references_model(self.new_name, app_label)
426         )
427 
428 
429 class ModelOptionOperation(ModelOperation):
430     def reduce(self, operation, app_label):
431         if isinstance(operation, (self.__class__, DeleteModel)) and self.name_lower == operation.name_lower:
432             return [operation]
433         return super().reduce(operation, app_label)
434 
435 
436 class AlterModelTable(ModelOptionOperation):
437     """Rename a model's table."""
438 
439     def __init__(self, name, table):
440         self.table = table
441         super().__init__(name)
442 
443     def deconstruct(self):
444         kwargs = {
445             'name': self.name,
446             'table': self.table,
447         }
448         return (
449             self.__class__.__qualname__,
450             [],
451             kwargs
452         )
453 
454     def state_forwards(self, app_label, state):
455         state.models[app_label, self.name_lower].options["db_table"] = self.table
456         state.reload_model(app_label, self.name_lower, delay=True)
457 
458     def database_forwards(self, app_label, schema_editor, from_state, to_state):
459         new_model = to_state.apps.get_model(app_label, self.name)
460         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
461             old_model = from_state.apps.get_model(app_label, self.name)
462             schema_editor.alter_db_table(
463                 new_model,
464                 old_model._meta.db_table,
465                 new_model._meta.db_table,
466             )
467             # Rename M2M fields whose name is based on this model's db_table
468             for (old_field, new_field) in zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many):
469                 if new_field.remote_field.through._meta.auto_created:
470                     schema_editor.alter_db_table(
471                         new_field.remote_field.through,
472                         old_field.remote_field.through._meta.db_table,
473                         new_field.remote_field.through._meta.db_table,
474                     )
475 
476     def database_backwards(self, app_label, schema_editor, from_state, to_state):
477         return self.database_forwards(app_label, schema_editor, from_state, to_state)
478 
479     def describe(self):
480         return "Rename table for %s to %s" % (
481             self.name,
482             self.table if self.table is not None else "(default)"
483         )
484 
485     @property
486     def migration_name_fragment(self):
487         return 'alter_%s_table' % self.name_lower
488 
489 
490 class AlterTogetherOptionOperation(ModelOptionOperation):
491     option_name = None
492 
493     def __init__(self, name, option_value):
494         if option_value:
495             option_value = set(normalize_together(option_value))
496         setattr(self, self.option_name, option_value)
497         super().__init__(name)
498 
499     @cached_property
500     def option_value(self):
501         return getattr(self, self.option_name)
502 
503     def deconstruct(self):
504         kwargs = {
505             'name': self.name,
506             self.option_name: self.option_value,
507         }
508         return (
509             self.__class__.__qualname__,
510             [],
511             kwargs
512         )
513 
514     def state_forwards(self, app_label, state):
515         model_state = state.models[app_label, self.name_lower]
516         model_state.options[self.option_name] = self.option_value
517         state.reload_model(app_label, self.name_lower, delay=True)
518 
519     def database_forwards(self, app_label, schema_editor, from_state, to_state):
520         new_model = to_state.apps.get_model(app_label, self.name)
521         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
522             old_model = from_state.apps.get_model(app_label, self.name)
523             alter_together = getattr(schema_editor, 'alter_%s' % self.option_name)
524             alter_together(
525                 new_model,
526                 getattr(old_model._meta, self.option_name, set()),
527                 getattr(new_model._meta, self.option_name, set()),
528             )
529 
530     def database_backwards(self, app_label, schema_editor, from_state, to_state):
531         return self.database_forwards(app_label, schema_editor, from_state, to_state)
532 
533     def references_field(self, model_name, name, app_label):
534         return (
535             self.references_model(model_name, app_label) and
536             (
537                 not self.option_value or
538                 any((name in fields) for fields in self.option_value)
539             )
540         )
541 
542     def describe(self):
543         return "Alter %s for %s (%s constraint(s))" % (self.option_name, self.name, len(self.option_value or ''))
544 
545     @property
546     def migration_name_fragment(self):
547         return 'alter_%s_%s' % (self.name_lower, self.option_name)
548 
549 
550 class AlterUniqueTogether(AlterTogetherOptionOperation):
551     """
552     Change the value of unique_together to the target one.
553     Input value of unique_together must be a set of tuples.
554     """
555     option_name = 'unique_together'
556 
557     def __init__(self, name, unique_together):
558         super().__init__(name, unique_together)
559 
560 
561 class AlterIndexTogether(AlterTogetherOptionOperation):
562     """
563     Change the value of index_together to the target one.
564     Input value of index_together must be a set of tuples.
565     """
566     option_name = "index_together"
567 
568     def __init__(self, name, index_together):
569         super().__init__(name, index_together)
570 
571 
572 class AlterOrderWithRespectTo(ModelOptionOperation):
573     """Represent a change with the order_with_respect_to option."""
574 
575     option_name = 'order_with_respect_to'
576 
577     def __init__(self, name, order_with_respect_to):
578         self.order_with_respect_to = order_with_respect_to
579         super().__init__(name)
580 
581     def deconstruct(self):
582         kwargs = {
583             'name': self.name,
584             'order_with_respect_to': self.order_with_respect_to,
585         }
586         return (
587             self.__class__.__qualname__,
588             [],
589             kwargs
590         )
591 
592     def state_forwards(self, app_label, state):
593         model_state = state.models[app_label, self.name_lower]
594         model_state.options['order_with_respect_to'] = self.order_with_respect_to
595         state.reload_model(app_label, self.name_lower, delay=True)
596 
597     def database_forwards(self, app_label, schema_editor, from_state, to_state):
598         to_model = to_state.apps.get_model(app_label, self.name)
599         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
600             from_model = from_state.apps.get_model(app_label, self.name)
601             # Remove a field if we need to
602             if from_model._meta.order_with_respect_to and not to_model._meta.order_with_respect_to:
603                 schema_editor.remove_field(from_model, from_model._meta.get_field("_order"))
604             # Add a field if we need to (altering the column is untouched as
605             # it's likely a rename)
606             elif to_model._meta.order_with_respect_to and not from_model._meta.order_with_respect_to:
607                 field = to_model._meta.get_field("_order")
608                 if not field.has_default():
609                     field.default = 0
610                 schema_editor.add_field(
611                     from_model,
612                     field,
613                 )
614 
615     def database_backwards(self, app_label, schema_editor, from_state, to_state):
616         self.database_forwards(app_label, schema_editor, from_state, to_state)
617 
618     def references_field(self, model_name, name, app_label):
619         return (
620             self.references_model(model_name, app_label) and
621             (
622                 self.order_with_respect_to is None or
623                 name == self.order_with_respect_to
624             )
625         )
626 
627     def describe(self):
628         return "Set order_with_respect_to on %s to %s" % (self.name, self.order_with_respect_to)
629 
630     @property
631     def migration_name_fragment(self):
632         return 'alter_%s_order_with_respect_to' % self.name_lower
633 
634 
635 class AlterModelOptions(ModelOptionOperation):
636     """
637     Set new model options that don't directly affect the database schema
638     (like verbose_name, permissions, ordering). Python code in migrations
639     may still need them.
640     """
641 
642     # Model options we want to compare and preserve in an AlterModelOptions op
643     ALTER_OPTION_KEYS = [
644         "base_manager_name",
645         "default_manager_name",
646         "default_related_name",
647         "get_latest_by",
648         "managed",
649         "ordering",
650         "permissions",
651         "default_permissions",
652         "select_on_save",
653         "verbose_name",
654         "verbose_name_plural",
655     ]
656 
657     def __init__(self, name, options):
658         self.options = options
659         super().__init__(name)
660 
661     def deconstruct(self):
662         kwargs = {
663             'name': self.name,
664             'options': self.options,
665         }
666         return (
667             self.__class__.__qualname__,
668             [],
669             kwargs
670         )
671 
672     def state_forwards(self, app_label, state):
673         model_state = state.models[app_label, self.name_lower]
674         model_state.options = {**model_state.options, **self.options}
675         for key in self.ALTER_OPTION_KEYS:
676             if key not in self.options:
677                 model_state.options.pop(key, False)
678         state.reload_model(app_label, self.name_lower, delay=True)
679 
680     def database_forwards(self, app_label, schema_editor, from_state, to_state):
681         pass
682 
683     def database_backwards(self, app_label, schema_editor, from_state, to_state):
684         pass
685 
686     def describe(self):
687         return "Change Meta options on %s" % self.name
688 
689     @property
690     def migration_name_fragment(self):
691         return 'alter_%s_options' % self.name_lower
692 
693 
694 class AlterModelManagers(ModelOptionOperation):
695     """Alter the model's managers."""
696 
697     serialization_expand_args = ['managers']
698 
699     def __init__(self, name, managers):
700         self.managers = managers
701         super().__init__(name)
702 
703     def deconstruct(self):
704         return (
705             self.__class__.__qualname__,
706             [self.name, self.managers],
707             {}
708         )
709 
710     def state_forwards(self, app_label, state):
711         model_state = state.models[app_label, self.name_lower]
712         model_state.managers = list(self.managers)
713         state.reload_model(app_label, self.name_lower, delay=True)
714 
715     def database_forwards(self, app_label, schema_editor, from_state, to_state):
716         pass
717 
718     def database_backwards(self, app_label, schema_editor, from_state, to_state):
719         pass
720 
721     def describe(self):
722         return "Change managers on %s" % self.name
723 
724     @property
725     def migration_name_fragment(self):
726         return 'alter_%s_managers' % self.name_lower
727 
728 
729 class IndexOperation(Operation):
730     option_name = 'indexes'
731 
732     @cached_property
733     def model_name_lower(self):
734         return self.model_name.lower()
735 
736 
737 class AddIndex(IndexOperation):
738     """Add an index on a model."""
739 
740     def __init__(self, model_name, index):
741         self.model_name = model_name
742         if not index.name:
743             raise ValueError(
744                 "Indexes passed to AddIndex operations require a name "
745                 "argument. %r doesn't have one." % index
746             )
747         self.index = index
748 
749     def state_forwards(self, app_label, state):
750         model_state = state.models[app_label, self.model_name_lower]
751         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.index.clone()]
752         state.reload_model(app_label, self.model_name_lower, delay=True)
753 
754     def database_forwards(self, app_label, schema_editor, from_state, to_state):
755         model = to_state.apps.get_model(app_label, self.model_name)
756         if self.allow_migrate_model(schema_editor.connection.alias, model):
757             schema_editor.add_index(model, self.index)
758 
759     def database_backwards(self, app_label, schema_editor, from_state, to_state):
760         model = from_state.apps.get_model(app_label, self.model_name)
761         if self.allow_migrate_model(schema_editor.connection.alias, model):
762             schema_editor.remove_index(model, self.index)
763 
764     def deconstruct(self):
765         kwargs = {
766             'model_name': self.model_name,
767             'index': self.index,
768         }
769         return (
770             self.__class__.__qualname__,
771             [],
772             kwargs,
773         )
774 
775     def describe(self):
776         return 'Create index %s on field(s) %s of model %s' % (
777             self.index.name,
778             ', '.join(self.index.fields),
779             self.model_name,
780         )
781 
782     @property
783     def migration_name_fragment(self):
784         return '%s_%s' % (self.model_name_lower, self.index.name.lower())
785 
786 
787 class RemoveIndex(IndexOperation):
788     """Remove an index from a model."""
789 
790     def __init__(self, model_name, name):
791         self.model_name = model_name
792         self.name = name
793 
794     def state_forwards(self, app_label, state):
795         model_state = state.models[app_label, self.model_name_lower]
796         indexes = model_state.options[self.option_name]
797         model_state.options[self.option_name] = [idx for idx in indexes if idx.name != self.name]
798         state.reload_model(app_label, self.model_name_lower, delay=True)
799 
800     def database_forwards(self, app_label, schema_editor, from_state, to_state):
801         model = from_state.apps.get_model(app_label, self.model_name)
802         if self.allow_migrate_model(schema_editor.connection.alias, model):
803             from_model_state = from_state.models[app_label, self.model_name_lower]
804             index = from_model_state.get_index_by_name(self.name)
805             schema_editor.remove_index(model, index)
806 
807     def database_backwards(self, app_label, schema_editor, from_state, to_state):
808         model = to_state.apps.get_model(app_label, self.model_name)
809         if self.allow_migrate_model(schema_editor.connection.alias, model):
810             to_model_state = to_state.models[app_label, self.model_name_lower]
811             index = to_model_state.get_index_by_name(self.name)
812             schema_editor.add_index(model, index)
813 
814     def deconstruct(self):
815         kwargs = {
816             'model_name': self.model_name,
817             'name': self.name,
818         }
819         return (
820             self.__class__.__qualname__,
821             [],
822             kwargs,
823         )
824 
825     def describe(self):
826         return 'Remove index %s from %s' % (self.name, self.model_name)
827 
828     @property
829     def migration_name_fragment(self):
830         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())
831 
832 
833 class AddConstraint(IndexOperation):
834     option_name = 'constraints'
835 
836     def __init__(self, model_name, constraint):
837         self.model_name = model_name
838         self.constraint = constraint
839 
840     def state_forwards(self, app_label, state):
841         model_state = state.models[app_label, self.model_name_lower]
842         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.constraint]
843         state.reload_model(app_label, self.model_name_lower, delay=True)
844 
845     def database_forwards(self, app_label, schema_editor, from_state, to_state):
846         model = to_state.apps.get_model(app_label, self.model_name)
847         if self.allow_migrate_model(schema_editor.connection.alias, model):
848             schema_editor.add_constraint(model, self.constraint)
849 
850     def database_backwards(self, app_label, schema_editor, from_state, to_state):
851         model = to_state.apps.get_model(app_label, self.model_name)
852         if self.allow_migrate_model(schema_editor.connection.alias, model):
853             schema_editor.remove_constraint(model, self.constraint)
854 
855     def deconstruct(self):
856         return self.__class__.__name__, [], {
857             'model_name': self.model_name,
858             'constraint': self.constraint,
859         }
860 
861     def describe(self):
862         return 'Create constraint %s on model %s' % (self.constraint.name, self.model_name)
863 
864     @property
865     def migration_name_fragment(self):
866         return '%s_%s' % (self.model_name_lower, self.constraint.name.lower())
867 
868 
869 class RemoveConstraint(IndexOperation):
870     option_name = 'constraints'
871 
872     def __init__(self, model_name, name):
873         self.model_name = model_name
874         self.name = name
875 
876     def state_forwards(self, app_label, state):
877         model_state = state.models[app_label, self.model_name_lower]
878         constraints = model_state.options[self.option_name]
879         model_state.options[self.option_name] = [c for c in constraints if c.name != self.name]
880         state.reload_model(app_label, self.model_name_lower, delay=True)
881 
882     def database_forwards(self, app_label, schema_editor, from_state, to_state):
883         model = to_state.apps.get_model(app_label, self.model_name)
884         if self.allow_migrate_model(schema_editor.connection.alias, model):
885             from_model_state = from_state.models[app_label, self.model_name_lower]
886             constraint = from_model_state.get_constraint_by_name(self.name)
887             schema_editor.remove_constraint(model, constraint)
888 
889     def database_backwards(self, app_label, schema_editor, from_state, to_state):
890         model = to_state.apps.get_model(app_label, self.model_name)
891         if self.allow_migrate_model(schema_editor.connection.alias, model):
892             to_model_state = to_state.models[app_label, self.model_name_lower]
893             constraint = to_model_state.get_constraint_by_name(self.name)
894             schema_editor.add_constraint(model, constraint)
895 
896     def deconstruct(self):
897         return self.__class__.__name__, [], {
898             'model_name': self.model_name,
899             'name': self.name,
900         }
901 
902     def describe(self):
903         return 'Remove constraint %s from model %s' % (self.name, self.model_name)
904 
905     @property
906     def migration_name_fragment(self):
907         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())

</code><intended_behavior>The `AlterOrderWithRespectTo` operation logic may require adjustments to ensure that when it runs, the migration system either checks for the existence of the `_order` field or explicitly defines it before any index operations referencing this field are executed. This might involve modifying how the operation is interpreted or executed within migrations to ensure dependency order is respected.</intended_behavior>]
2025-10-17 12:12:17.618 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/autodetector.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import re
3 from itertools import chain
4 
5 from django.conf import settings
6 from django.db import models
7 from django.db.migrations import operations
8 from django.db.migrations.migration import Migration
9 from django.db.migrations.operations.models import AlterModelOptions
10 from django.db.migrations.optimizer import MigrationOptimizer
11 from django.db.migrations.questioner import MigrationQuestioner
12 from django.db.migrations.utils import COMPILED_REGEX_TYPE, RegexObject
13 from django.utils.topological_sort import stable_topological_sort
14 
15 
16 class MigrationAutodetector:
17     """
18     Take a pair of ProjectStates and compare them to see what the first would
19     need doing to make it match the second (the second usually being the
20     project's current state).
21 
22     Note that this naturally operates on entire projects at a time,
23     as it's likely that changes interact (for example, you can't
24     add a ForeignKey without having a migration to add the table it
25     depends on first). A user interface may offer single-app usage
26     if it wishes, with the caveat that it may not always be possible.
27     """
28 
29     def __init__(self, from_state, to_state, questioner=None):
30         self.from_state = from_state
31         self.to_state = to_state
32         self.questioner = questioner or MigrationQuestioner()
33         self.existing_apps = {app for app, model in from_state.models}
34 
35     def changes(self, graph, trim_to_apps=None, convert_apps=None, migration_name=None):
36         """
37         Main entry point to produce a list of applicable changes.
38         Take a graph to base names on and an optional set of apps
39         to try and restrict to (restriction is not guaranteed)
40         """
41         changes = self._detect_changes(convert_apps, graph)
42         changes = self.arrange_for_graph(changes, graph, migration_name)
43         if trim_to_apps:
44             changes = self._trim_to_apps(changes, trim_to_apps)
45         return changes
46 
47     def deep_deconstruct(self, obj):
48         """
49         Recursive deconstruction for a field and its arguments.
50         Used for full comparison for rename/alter; sometimes a single-level
51         deconstruction will not compare correctly.
52         """
53         if isinstance(obj, list):
54             return [self.deep_deconstruct(value) for value in obj]
55         elif isinstance(obj, tuple):
56             return tuple(self.deep_deconstruct(value) for value in obj)
57         elif isinstance(obj, dict):
58             return {
59                 key: self.deep_deconstruct(value)
60                 for key, value in obj.items()
61             }
62         elif isinstance(obj, functools.partial):
63             return (obj.func, self.deep_deconstruct(obj.args), self.deep_deconstruct(obj.keywords))
64         elif isinstance(obj, COMPILED_REGEX_TYPE):
65             return RegexObject(obj)
66         elif isinstance(obj, type):
67             # If this is a type that implements 'deconstruct' as an instance method,
68             # avoid treating this as being deconstructible itself - see #22951
69             return obj
70         elif hasattr(obj, 'deconstruct'):
71             deconstructed = obj.deconstruct()
72             if isinstance(obj, models.Field):
73                 # we have a field which also returns a name
74                 deconstructed = deconstructed[1:]
75             path, args, kwargs = deconstructed
76             return (
77                 path,
78                 [self.deep_deconstruct(value) for value in args],
79                 {
80                     key: self.deep_deconstruct(value)
81                     for key, value in kwargs.items()
82                 },
83             )
84         else:
85             return obj
86 
87     def only_relation_agnostic_fields(self, fields):
88         """
89         Return a definition of the fields that ignores field names and
90         what related fields actually relate to. Used for detecting renames (as
91         the related fields change during renames).
92         """
93         fields_def = []
94         for name, field in sorted(fields.items()):
95             deconstruction = self.deep_deconstruct(field)
96             if field.remote_field and field.remote_field.model:
97                 del deconstruction[2]['to']
98             fields_def.append(deconstruction)
99         return fields_def
100 
101     def _detect_changes(self, convert_apps=None, graph=None):
102         """
103         Return a dict of migration plans which will achieve the
104         change from from_state to to_state. The dict has app labels
105         as keys and a list of migrations as values.
106 
107         The resulting migrations aren't specially named, but the names
108         do matter for dependencies inside the set.
109 
110         convert_apps is the list of apps to convert to use migrations
111         (i.e. to make initial migrations for, in the usual case)
112 
113         graph is an optional argument that, if provided, can help improve
114         dependency generation and avoid potential circular dependencies.
115         """
116         # The first phase is generating all the operations for each app
117         # and gathering them into a big per-app list.
118         # Then go through that list, order it, and split into migrations to
119         # resolve dependencies caused by M2Ms and FKs.
120         self.generated_operations = {}
121         self.altered_indexes = {}
122         self.altered_constraints = {}
123 
124         # Prepare some old/new state and model lists, separating
125         # proxy models and ignoring unmigrated apps.
126         self.old_apps = self.from_state.concrete_apps
127         self.new_apps = self.to_state.apps
128         self.old_model_keys = set()
129         self.old_proxy_keys = set()
130         self.old_unmanaged_keys = set()
131         self.new_model_keys = set()
132         self.new_proxy_keys = set()
133         self.new_unmanaged_keys = set()
134         for al, mn in self.from_state.models:
135             model = self.old_apps.get_model(al, mn)
136             if not model._meta.managed:
137                 self.old_unmanaged_keys.add((al, mn))
138             elif al not in self.from_state.real_apps:
139                 if model._meta.proxy:
140                     self.old_proxy_keys.add((al, mn))
141                 else:
142                     self.old_model_keys.add((al, mn))
143 
144         for al, mn in self.to_state.models:
145             model = self.new_apps.get_model(al, mn)
146             if not model._meta.managed:
147                 self.new_unmanaged_keys.add((al, mn))
148             elif (
149                 al not in self.from_state.real_apps or
150                 (convert_apps and al in convert_apps)
151             ):
152                 if model._meta.proxy:
153                     self.new_proxy_keys.add((al, mn))
154                 else:
155                     self.new_model_keys.add((al, mn))
156 
157         # Renames have to come first
158         self.generate_renamed_models()
159 
160         # Prepare lists of fields and generate through model map
161         self._prepare_field_lists()
162         self._generate_through_model_map()
163 
164         # Generate non-rename model operations
165         self.generate_deleted_models()
166         self.generate_created_models()
167         self.generate_deleted_proxies()
168         self.generate_created_proxies()
169         self.generate_altered_options()
170         self.generate_altered_managers()
171 
172         # Create the altered indexes and store them in self.altered_indexes.
173         # This avoids the same computation in generate_removed_indexes()
174         # and generate_added_indexes().
175         self.create_altered_indexes()
176         self.create_altered_constraints()
177         # Generate index removal operations before field is removed
178         self.generate_removed_constraints()
179         self.generate_removed_indexes()
180         # Generate field operations
181         self.generate_renamed_fields()
182         self.generate_removed_fields()
183         self.generate_added_fields()
184         self.generate_altered_fields()
185         self.generate_altered_unique_together()
186         self.generate_altered_index_together()
187         self.generate_added_indexes()
188         self.generate_added_constraints()
189         self.generate_altered_db_table()
190         self.generate_altered_order_with_respect_to()
191 
192         self._sort_migrations()
193         self._build_migration_list(graph)
194         self._optimize_migrations()
195 
196         return self.migrations
197 
198     def _prepare_field_lists(self):
199         """
200         Prepare field lists and a list of the fields that used through models
201         in the old state so dependencies can be made from the through model
202         deletion to the field that uses it.
203         """
204         self.kept_model_keys = self.old_model_keys & self.new_model_keys
205         self.kept_proxy_keys = self.old_proxy_keys & self.new_proxy_keys
206         self.kept_unmanaged_keys = self.old_unmanaged_keys & self.new_unmanaged_keys
207         self.through_users = {}
208         self.old_field_keys = {
209             (app_label, model_name, field_name)
210             for app_label, model_name in self.kept_model_keys
211             for field_name in self.from_state.models[
212                 app_label,
213                 self.renamed_models.get((app_label, model_name), model_name)
214             ].fields
215         }
216         self.new_field_keys = {
217             (app_label, model_name, field_name)
218             for app_label, model_name in self.kept_model_keys
219             for field_name in self.to_state.models[app_label, model_name].fields
220         }
221 
222     def _generate_through_model_map(self):
223         """Through model map generation."""
224         for app_label, model_name in sorted(self.old_model_keys):
225             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
226             old_model_state = self.from_state.models[app_label, old_model_name]
227             for field_name in old_model_state.fields:
228                 old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(field_name)
229                 if (hasattr(old_field, "remote_field") and getattr(old_field.remote_field, "through", None) and
230                         not old_field.remote_field.through._meta.auto_created):
231                     through_key = (
232                         old_field.remote_field.through._meta.app_label,
233                         old_field.remote_field.through._meta.model_name,
234                     )
235                     self.through_users[through_key] = (app_label, old_model_name, field_name)
236 
237     @staticmethod
238     def _resolve_dependency(dependency):
239         """
240         Return the resolved dependency and a boolean denoting whether or not
241         it was swappable.
242         """
243         if dependency[0] != '__setting__':
244             return dependency, False
245         resolved_app_label, resolved_object_name = getattr(settings, dependency[1]).split('.')
246         return (resolved_app_label, resolved_object_name.lower()) + dependency[2:], True
247 
248     def _build_migration_list(self, graph=None):
249         """
250         Chop the lists of operations up into migrations with dependencies on
251         each other. Do this by going through an app's list of operations until
252         one is found that has an outgoing dependency that isn't in another
253         app's migration yet (hasn't been chopped off its list). Then chop off
254         the operations before it into a migration and move onto the next app.
255         If the loops completes without doing anything, there's a circular
256         dependency (which _should_ be impossible as the operations are
257         all split at this point so they can't depend and be depended on).
258         """
259         self.migrations = {}
260         num_ops = sum(len(x) for x in self.generated_operations.values())
261         chop_mode = False
262         while num_ops:
263             # On every iteration, we step through all the apps and see if there
264             # is a completed set of operations.
265             # If we find that a subset of the operations are complete we can
266             # try to chop it off from the rest and continue, but we only
267             # do this if we've already been through the list once before
268             # without any chopping and nothing has changed.
269             for app_label in sorted(self.generated_operations):
270                 chopped = []
271                 dependencies = set()
272                 for operation in list(self.generated_operations[app_label]):
273                     deps_satisfied = True
274                     operation_dependencies = set()
275                     for dep in operation._auto_deps:
276                         # Temporarily resolve the swappable dependency to
277                         # prevent circular references. While keeping the
278                         # dependency checks on the resolved model, add the
279                         # swappable dependencies.
280                         original_dep = dep
281                         dep, is_swappable_dep = self._resolve_dependency(dep)
282                         if dep[0] != app_label:
283                             # External app dependency. See if it's not yet
284                             # satisfied.
285                             for other_operation in self.generated_operations.get(dep[0], []):
286                                 if self.check_dependency(other_operation, dep):
287                                     deps_satisfied = False
288                                     break
289                             if not deps_satisfied:
290                                 break
291                             else:
292                                 if is_swappable_dep:
293                                     operation_dependencies.add((original_dep[0], original_dep[1]))
294                                 elif dep[0] in self.migrations:
295                                     operation_dependencies.add((dep[0], self.migrations[dep[0]][-1].name))
296                                 else:
297                                     # If we can't find the other app, we add a first/last dependency,
298                                     # but only if we've already been through once and checked everything
299                                     if chop_mode:
300                                         # If the app already exists, we add a dependency on the last migration,
301                                         # as we don't know which migration contains the target field.
302                                         # If it's not yet migrated or has no migrations, we use __first__
303                                         if graph and graph.leaf_nodes(dep[0]):
304                                             operation_dependencies.add(graph.leaf_nodes(dep[0])[0])
305                                         else:
306                                             operation_dependencies.add((dep[0], "__first__"))
307                                     else:
308                                         deps_satisfied = False
309                     if deps_satisfied:
310                         chopped.append(operation)
311                         dependencies.update(operation_dependencies)
312                         del self.generated_operations[app_label][0]
313                     else:
314                         break
315                 # Make a migration! Well, only if there's stuff to put in it
316                 if dependencies or chopped:
317                     if not self.generated_operations[app_label] or chop_mode:
318                         subclass = type("Migration", (Migration,), {"operations": [], "dependencies": []})
319                         instance = subclass("auto_%i" % (len(self.migrations.get(app_label, [])) + 1), app_label)
320                         instance.dependencies = list(dependencies)
321                         instance.operations = chopped
322                         instance.initial = app_label not in self.existing_apps
323                         self.migrations.setdefault(app_label, []).append(instance)
324                         chop_mode = False
325                     else:
326                         self.generated_operations[app_label] = chopped + self.generated_operations[app_label]
327             new_num_ops = sum(len(x) for x in self.generated_operations.values())
328             if new_num_ops == num_ops:
329                 if not chop_mode:
330                     chop_mode = True
331                 else:
332                     raise ValueError("Cannot resolve operation dependencies: %r" % self.generated_operations)
333             num_ops = new_num_ops
334 
335     def _sort_migrations(self):
336         """
337         Reorder to make things possible. Reordering may be needed so FKs work
338         nicely inside the same app.
339         """
340         for app_label, ops in sorted(self.generated_operations.items()):
341             # construct a dependency graph for intra-app dependencies
342             dependency_graph = {op: set() for op in ops}
343             for op in ops:
344                 for dep in op._auto_deps:
345                     # Resolve intra-app dependencies to handle circular
346                     # references involving a swappable model.
347                     dep = self._resolve_dependency(dep)[0]
348                     if dep[0] == app_label:
349                         for op2 in ops:
350                             if self.check_dependency(op2, dep):
351                                 dependency_graph[op].add(op2)
352 
353             # we use a stable sort for deterministic tests & general behavior
354             self.generated_operations[app_label] = stable_topological_sort(ops, dependency_graph)
355 
356     def _optimize_migrations(self):
357         # Add in internal dependencies among the migrations
358         for app_label, migrations in self.migrations.items():
359             for m1, m2 in zip(migrations, migrations[1:]):
360                 m2.dependencies.append((app_label, m1.name))
361 
362         # De-dupe dependencies
363         for migrations in self.migrations.values():
364             for migration in migrations:
365                 migration.dependencies = list(set(migration.dependencies))
366 
367         # Optimize migrations
368         for app_label, migrations in self.migrations.items():
369             for migration in migrations:
370                 migration.operations = MigrationOptimizer().optimize(migration.operations, app_label)
371 
372     def check_dependency(self, operation, dependency):
373         """
374         Return True if the given operation depends on the given dependency,
375         False otherwise.
376         """
377         # Created model
378         if dependency[2] is None and dependency[3] is True:
379             return (
380                 isinstance(operation, operations.CreateModel) and
381                 operation.name_lower == dependency[1].lower()
382             )
383         # Created field
384         elif dependency[2] is not None and dependency[3] is True:
385             return (
386                 (
387                     isinstance(operation, operations.CreateModel) and
388                     operation.name_lower == dependency[1].lower() and
389                     any(dependency[2] == x for x, y in operation.fields)
390                 ) or
391                 (
392                     isinstance(operation, operations.AddField) and
393                     operation.model_name_lower == dependency[1].lower() and
394                     operation.name_lower == dependency[2].lower()
395                 )
396             )
397         # Removed field
398         elif dependency[2] is not None and dependency[3] is False:
399             return (
400                 isinstance(operation, operations.RemoveField) and
401                 operation.model_name_lower == dependency[1].lower() and
402                 operation.name_lower == dependency[2].lower()
403             )
404         # Removed model
405         elif dependency[2] is None and dependency[3] is False:
406             return (
407                 isinstance(operation, operations.DeleteModel) and
408                 operation.name_lower == dependency[1].lower()
409             )
410         # Field being altered
411         elif dependency[2] is not None and dependency[3] == "alter":
412             return (
413                 isinstance(operation, operations.AlterField) and
414                 operation.model_name_lower == dependency[1].lower() and
415                 operation.name_lower == dependency[2].lower()
416             )
417         # order_with_respect_to being unset for a field
418         elif dependency[2] is not None and dependency[3] == "order_wrt_unset":
419             return (
420                 isinstance(operation, operations.AlterOrderWithRespectTo) and
421                 operation.name_lower == dependency[1].lower() and
422                 (operation.order_with_respect_to or "").lower() != dependency[2].lower()
423             )
424         # Field is removed and part of an index/unique_together
425         elif dependency[2] is not None and dependency[3] == "foo_together_change":
426             return (
427                 isinstance(operation, (operations.AlterUniqueTogether,
428                                        operations.AlterIndexTogether)) and
429                 operation.name_lower == dependency[1].lower()
430             )
431         # Unknown dependency. Raise an error.
432         else:
433             raise ValueError("Can't handle dependency %r" % (dependency,))
434 
435     def add_operation(self, app_label, operation, dependencies=None, beginning=False):
436         # Dependencies are (app_label, model_name, field_name, create/delete as True/False)
437         operation._auto_deps = dependencies or []
438         if beginning:
439             self.generated_operations.setdefault(app_label, []).insert(0, operation)
440         else:
441             self.generated_operations.setdefault(app_label, []).append(operation)
442 
443     def swappable_first_key(self, item):
444         """
445         Place potential swappable models first in lists of created models (only
446         real way to solve #22783).
447         """
448         try:
449             model = self.new_apps.get_model(item[0], item[1])
450             base_names = [base.__name__ for base in model.__bases__]
451             string_version = "%s.%s" % (item[0], item[1])
452             if (
453                 model._meta.swappable or
454                 "AbstractUser" in base_names or
455                 "AbstractBaseUser" in base_names or
456                 settings.AUTH_USER_MODEL.lower() == string_version.lower()
457             ):
458                 return ("___" + item[0], "___" + item[1])
459         except LookupError:
460             pass
461         return item
462 
463     def generate_renamed_models(self):
464         """
465         Find any renamed models, generate the operations for them, and remove
466         the old entry from the model lists. Must be run before other
467         model-level generation.
468         """
469         self.renamed_models = {}
470         self.renamed_models_rel = {}
471         added_models = self.new_model_keys - self.old_model_keys
472         for app_label, model_name in sorted(added_models):
473             model_state = self.to_state.models[app_label, model_name]
474             model_fields_def = self.only_relation_agnostic_fields(model_state.fields)
475 
476             removed_models = self.old_model_keys - self.new_model_keys
477             for rem_app_label, rem_model_name in removed_models:
478                 if rem_app_label == app_label:
479                     rem_model_state = self.from_state.models[rem_app_label, rem_model_name]
480                     rem_model_fields_def = self.only_relation_agnostic_fields(rem_model_state.fields)
481                     if model_fields_def == rem_model_fields_def:
482                         if self.questioner.ask_rename_model(rem_model_state, model_state):
483                             model_opts = self.new_apps.get_model(app_label, model_name)._meta
484                             dependencies = []
485                             for field in model_opts.get_fields():
486                                 if field.is_relation:
487                                     dependencies.extend(self._get_dependencies_for_foreign_key(field))
488                             self.add_operation(
489                                 app_label,
490                                 operations.RenameModel(
491                                     old_name=rem_model_state.name,
492                                     new_name=model_state.name,
493                                 ),
494                                 dependencies=dependencies,
495                             )
496                             self.renamed_models[app_label, model_name] = rem_model_name
497                             renamed_models_rel_key = '%s.%s' % (
498                                 rem_model_state.app_label,
499                                 rem_model_state.name_lower,
500                             )
501                             self.renamed_models_rel[renamed_models_rel_key] = '%s.%s' % (
502                                 model_state.app_label,
503                                 model_state.name_lower,
504                             )
505                             self.old_model_keys.remove((rem_app_label, rem_model_name))
506                             self.old_model_keys.add((app_label, model_name))
507                             break
508 
509     def generate_created_models(self):
510         """
511         Find all new models (both managed and unmanaged) and make create
512         operations for them as well as separate operations to create any
513         foreign key or M2M relationships (these are optimized later, if
514         possible).
515 
516         Defer any model options that refer to collections of fields that might
517         be deferred (e.g. unique_together, index_together).
518         """
519         old_keys = self.old_model_keys | self.old_unmanaged_keys
520         added_models = self.new_model_keys - old_keys
521         added_unmanaged_models = self.new_unmanaged_keys - old_keys
522         all_added_models = chain(
523             sorted(added_models, key=self.swappable_first_key, reverse=True),
524             sorted(added_unmanaged_models, key=self.swappable_first_key, reverse=True)
525         )
526         for app_label, model_name in all_added_models:
527             model_state = self.to_state.models[app_label, model_name]
528             model_opts = self.new_apps.get_model(app_label, model_name)._meta
529             # Gather related fields
530             related_fields = {}
531             primary_key_rel = None
532             for field in model_opts.local_fields:
533                 if field.remote_field:
534                     if field.remote_field.model:
535                         if field.primary_key:
536                             primary_key_rel = field.remote_field.model
537                         elif not field.remote_field.parent_link:
538                             related_fields[field.name] = field
539                     # through will be none on M2Ms on swapped-out models;
540                     # we can treat lack of through as auto_created=True, though.
541                     if (getattr(field.remote_field, "through", None) and
542                             not field.remote_field.through._meta.auto_created):
543                         related_fields[field.name] = field
544             for field in model_opts.local_many_to_many:
545                 if field.remote_field.model:
546                     related_fields[field.name] = field
547                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
548                     related_fields[field.name] = field
549             # Are there indexes/unique|index_together to defer?
550             indexes = model_state.options.pop('indexes')
551             constraints = model_state.options.pop('constraints')
552             unique_together = model_state.options.pop('unique_together', None)
553             index_together = model_state.options.pop('index_together', None)
554             order_with_respect_to = model_state.options.pop('order_with_respect_to', None)
555             # Depend on the deletion of any possible proxy version of us
556             dependencies = [
557                 (app_label, model_name, None, False),
558             ]
559             # Depend on all bases
560             for base in model_state.bases:
561                 if isinstance(base, str) and "." in base:
562                     base_app_label, base_name = base.split(".", 1)
563                     dependencies.append((base_app_label, base_name, None, True))
564                     # Depend on the removal of base fields if the new model has
565                     # a field with the same name.
566                     old_base_model_state = self.from_state.models.get((base_app_label, base_name))
567                     new_base_model_state = self.to_state.models.get((base_app_label, base_name))
568                     if old_base_model_state and new_base_model_state:
569                         removed_base_fields = set(old_base_model_state.fields).difference(
570                             new_base_model_state.fields,
571                         ).intersection(model_state.fields)
572                         for removed_base_field in removed_base_fields:
573                             dependencies.append((base_app_label, base_name, removed_base_field, False))
574             # Depend on the other end of the primary key if it's a relation
575             if primary_key_rel:
576                 dependencies.append((
577                     primary_key_rel._meta.app_label,
578                     primary_key_rel._meta.object_name,
579                     None,
580                     True
581                 ))
582             # Generate creation operation
583             self.add_operation(
584                 app_label,
585                 operations.CreateModel(
586                     name=model_state.name,
587                     fields=[d for d in model_state.fields.items() if d[0] not in related_fields],
588                     options=model_state.options,
589                     bases=model_state.bases,
590                     managers=model_state.managers,
591                 ),
592                 dependencies=dependencies,
593                 beginning=True,
594             )
595 
596             # Don't add operations which modify the database for unmanaged models
597             if not model_opts.managed:
598                 continue
599 
600             # Generate operations for each related field
601             for name, field in sorted(related_fields.items()):
602                 dependencies = self._get_dependencies_for_foreign_key(field)
603                 # Depend on our own model being created
604                 dependencies.append((app_label, model_name, None, True))
605                 # Make operation
606                 self.add_operation(
607                     app_label,
608                     operations.AddField(
609                         model_name=model_name,
610                         name=name,
611                         field=field,
612                     ),
613                     dependencies=list(set(dependencies)),
614                 )
615             # Generate other opns
616             related_dependencies = [
617                 (app_label, model_name, name, True)
618                 for name in sorted(related_fields)
619             ]
620             related_dependencies.append((app_label, model_name, None, True))
621             for index in indexes:
622                 self.add_operation(
623                     app_label,
624                     operations.AddIndex(
625                         model_name=model_name,
626                         index=index,
627                     ),
628                     dependencies=related_dependencies,
629                 )
630             for constraint in constraints:
631                 self.add_operation(
632                     app_label,
633                     operations.AddConstraint(
634                         model_name=model_name,
635                         constraint=constraint,
636                     ),
637                     dependencies=related_dependencies,
638                 )
639             if unique_together:
640                 self.add_operation(
641                     app_label,
642                     operations.AlterUniqueTogether(
643                         name=model_name,
644                         unique_together=unique_together,
645                     ),
646                     dependencies=related_dependencies
647                 )
648             if index_together:
649                 self.add_operation(
650                     app_label,
651                     operations.AlterIndexTogether(
652                         name=model_name,
653                         index_together=index_together,
654                     ),
655                     dependencies=related_dependencies
656                 )
657             if order_with_respect_to:
658                 self.add_operation(
659                     app_label,
660                     operations.AlterOrderWithRespectTo(
661                         name=model_name,
662                         order_with_respect_to=order_with_respect_to,
663                     ),
664                     dependencies=[
665                         (app_label, model_name, order_with_respect_to, True),
666                         (app_label, model_name, None, True),
667                     ]
668                 )
669 
670             # Fix relationships if the model changed from a proxy model to a
671             # concrete model.
672             if (app_label, model_name) in self.old_proxy_keys:
673                 for related_object in model_opts.related_objects:
674                     self.add_operation(
675                         related_object.related_model._meta.app_label,
676                         operations.AlterField(
677                             model_name=related_object.related_model._meta.object_name,
678                             name=related_object.field.name,
679                             field=related_object.field,
680                         ),
681                         dependencies=[(app_label, model_name, None, True)],
682                     )
683 
684     def generate_created_proxies(self):
685         """
686         Make CreateModel statements for proxy models. Use the same statements
687         as that way there's less code duplication, but for proxy models it's
688         safe to skip all the pointless field stuff and chuck out an operation.
689         """
690         added = self.new_proxy_keys - self.old_proxy_keys
691         for app_label, model_name in sorted(added):
692             model_state = self.to_state.models[app_label, model_name]
693             assert model_state.options.get("proxy")
694             # Depend on the deletion of any possible non-proxy version of us
695             dependencies = [
696                 (app_label, model_name, None, False),
697             ]
698             # Depend on all bases
699             for base in model_state.bases:
700                 if isinstance(base, str) and "." in base:
701                     base_app_label, base_name = base.split(".", 1)
702                     dependencies.append((base_app_label, base_name, None, True))
703             # Generate creation operation
704             self.add_operation(
705                 app_label,
706                 operations.CreateModel(
707                     name=model_state.name,
708                     fields=[],
709                     options=model_state.options,
710                     bases=model_state.bases,
711                     managers=model_state.managers,
712                 ),
713                 # Depend on the deletion of any possible non-proxy version of us
714                 dependencies=dependencies,
715             )
716 
717     def generate_deleted_models(self):
718         """
719         Find all deleted models (managed and unmanaged) and make delete
720         operations for them as well as separate operations to delete any
721         foreign key or M2M relationships (these are optimized later, if
722         possible).
723 
724         Also bring forward removal of any model options that refer to
725         collections of fields - the inverse of generate_created_models().
726         """
727         new_keys = self.new_model_keys | self.new_unmanaged_keys
728         deleted_models = self.old_model_keys - new_keys
729         deleted_unmanaged_models = self.old_unmanaged_keys - new_keys
730         all_deleted_models = chain(sorted(deleted_models), sorted(deleted_unmanaged_models))
731         for app_label, model_name in all_deleted_models:
732             model_state = self.from_state.models[app_label, model_name]
733             model = self.old_apps.get_model(app_label, model_name)
734             # Gather related fields
735             related_fields = {}
736             for field in model._meta.local_fields:
737                 if field.remote_field:
738                     if field.remote_field.model:
739                         related_fields[field.name] = field
740                     # through will be none on M2Ms on swapped-out models;
741                     # we can treat lack of through as auto_created=True, though.
742                     if (getattr(field.remote_field, "through", None) and
743                             not field.remote_field.through._meta.auto_created):
744                         related_fields[field.name] = field
745             for field in model._meta.local_many_to_many:
746                 if field.remote_field.model:
747                     related_fields[field.name] = field
748                 if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
749                     related_fields[field.name] = field
750             # Generate option removal first
751             unique_together = model_state.options.pop('unique_together', None)
752             index_together = model_state.options.pop('index_together', None)
753             if unique_together:
754                 self.add_operation(
755                     app_label,
756                     operations.AlterUniqueTogether(
757                         name=model_name,
758                         unique_together=None,
759                     )
760                 )
761             if index_together:
762                 self.add_operation(
763                     app_label,
764                     operations.AlterIndexTogether(
765                         name=model_name,
766                         index_together=None,
767                     )
768                 )
769             # Then remove each related field
770             for name in sorted(related_fields):
771                 self.add_operation(
772                     app_label,
773                     operations.RemoveField(
774                         model_name=model_name,
775                         name=name,
776                     )
777                 )
778             # Finally, remove the model.
779             # This depends on both the removal/alteration of all incoming fields
780             # and the removal of all its own related fields, and if it's
781             # a through model the field that references it.
782             dependencies = []
783             for related_object in model._meta.related_objects:
784                 related_object_app_label = related_object.related_model._meta.app_label
785                 object_name = related_object.related_model._meta.object_name
786                 field_name = related_object.field.name
787                 dependencies.append((related_object_app_label, object_name, field_name, False))
788                 if not related_object.many_to_many:
789                     dependencies.append((related_object_app_label, object_name, field_name, "alter"))
790 
791             for name in sorted(related_fields):
792                 dependencies.append((app_label, model_name, name, False))
793             # We're referenced in another field's through=
794             through_user = self.through_users.get((app_label, model_state.name_lower))
795             if through_user:
796                 dependencies.append((through_user[0], through_user[1], through_user[2], False))
797             # Finally, make the operation, deduping any dependencies
798             self.add_operation(
799                 app_label,
800                 operations.DeleteModel(
801                     name=model_state.name,
802                 ),
803                 dependencies=list(set(dependencies)),
804             )
805 
806     def generate_deleted_proxies(self):
807         """Make DeleteModel options for proxy models."""
808         deleted = self.old_proxy_keys - self.new_proxy_keys
809         for app_label, model_name in sorted(deleted):
810             model_state = self.from_state.models[app_label, model_name]
811             assert model_state.options.get("proxy")
812             self.add_operation(
813                 app_label,
814                 operations.DeleteModel(
815                     name=model_state.name,
816                 ),
817             )
818 
819     def generate_renamed_fields(self):
820         """Work out renamed fields."""
821         self.renamed_fields = {}
822         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
823             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
824             old_model_state = self.from_state.models[app_label, old_model_name]
825             field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
826             # Scan to see if this is actually a rename!
827             field_dec = self.deep_deconstruct(field)
828             for rem_app_label, rem_model_name, rem_field_name in sorted(self.old_field_keys - self.new_field_keys):
829                 if rem_app_label == app_label and rem_model_name == model_name:
830                     old_field = old_model_state.fields[rem_field_name]
831                     old_field_dec = self.deep_deconstruct(old_field)
832                     if field.remote_field and field.remote_field.model and 'to' in old_field_dec[2]:
833                         old_rel_to = old_field_dec[2]['to']
834                         if old_rel_to in self.renamed_models_rel:
835                             old_field_dec[2]['to'] = self.renamed_models_rel[old_rel_to]
836                     old_field.set_attributes_from_name(rem_field_name)
837                     old_db_column = old_field.get_attname_column()[1]
838                     if (old_field_dec == field_dec or (
839                             # Was the field renamed and db_column equal to the
840                             # old field's column added?
841                             old_field_dec[0:2] == field_dec[0:2] and
842                             dict(old_field_dec[2], db_column=old_db_column) == field_dec[2])):
843                         if self.questioner.ask_rename(model_name, rem_field_name, field_name, field):
844                             self.add_operation(
845                                 app_label,
846                                 operations.RenameField(
847                                     model_name=model_name,
848                                     old_name=rem_field_name,
849                                     new_name=field_name,
850                                 )
851                             )
852                             self.old_field_keys.remove((rem_app_label, rem_model_name, rem_field_name))
853                             self.old_field_keys.add((app_label, model_name, field_name))
854                             self.renamed_fields[app_label, model_name, field_name] = rem_field_name
855                             break
856 
857     def generate_added_fields(self):
858         """Make AddField operations."""
859         for app_label, model_name, field_name in sorted(self.new_field_keys - self.old_field_keys):
860             self._generate_added_field(app_label, model_name, field_name)
861 
862     def _generate_added_field(self, app_label, model_name, field_name):
863         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
864         # Fields that are foreignkeys/m2ms depend on stuff
865         dependencies = []
866         if field.remote_field and field.remote_field.model:
867             dependencies.extend(self._get_dependencies_for_foreign_key(field))
868         # You can't just add NOT NULL fields with no default or fields
869         # which don't allow empty strings as default.
870         time_fields = (models.DateField, models.DateTimeField, models.TimeField)
871         preserve_default = (
872             field.null or field.has_default() or field.many_to_many or
873             (field.blank and field.empty_strings_allowed) or
874             (isinstance(field, time_fields) and field.auto_now)
875         )
876         if not preserve_default:
877             field = field.clone()
878             if isinstance(field, time_fields) and field.auto_now_add:
879                 field.default = self.questioner.ask_auto_now_add_addition(field_name, model_name)
880             else:
881                 field.default = self.questioner.ask_not_null_addition(field_name, model_name)
882         self.add_operation(
883             app_label,
884             operations.AddField(
885                 model_name=model_name,
886                 name=field_name,
887                 field=field,
888                 preserve_default=preserve_default,
889             ),
890             dependencies=dependencies,
891         )
892 
893     def generate_removed_fields(self):
894         """Make RemoveField operations."""
895         for app_label, model_name, field_name in sorted(self.old_field_keys - self.new_field_keys):
896             self._generate_removed_field(app_label, model_name, field_name)
897 
898     def _generate_removed_field(self, app_label, model_name, field_name):
899         self.add_operation(
900             app_label,
901             operations.RemoveField(
902                 model_name=model_name,
903                 name=field_name,
904             ),
905             # We might need to depend on the removal of an
906             # order_with_respect_to or index/unique_together operation;
907             # this is safely ignored if there isn't one
908             dependencies=[
909                 (app_label, model_name, field_name, "order_wrt_unset"),
910                 (app_label, model_name, field_name, "foo_together_change"),
911             ],
912         )
913 
914     def generate_altered_fields(self):
915         """
916         Make AlterField operations, or possibly RemovedField/AddField if alter
917         isn's possible.
918         """
919         for app_label, model_name, field_name in sorted(self.old_field_keys & self.new_field_keys):
920             # Did the field change?
921             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
922             old_field_name = self.renamed_fields.get((app_label, model_name, field_name), field_name)
923             old_field = self.old_apps.get_model(app_label, old_model_name)._meta.get_field(old_field_name)
924             new_field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
925             dependencies = []
926             # Implement any model renames on relations; these are handled by RenameModel
927             # so we need to exclude them from the comparison
928             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "model", None):
929                 rename_key = (
930                     new_field.remote_field.model._meta.app_label,
931                     new_field.remote_field.model._meta.model_name,
932                 )
933                 if rename_key in self.renamed_models:
934                     new_field.remote_field.model = old_field.remote_field.model
935                 # Handle ForeignKey which can only have a single to_field.
936                 remote_field_name = getattr(new_field.remote_field, 'field_name', None)
937                 if remote_field_name:
938                     to_field_rename_key = rename_key + (remote_field_name,)
939                     if to_field_rename_key in self.renamed_fields:
940                         # Repoint both model and field name because to_field
941                         # inclusion in ForeignKey.deconstruct() is based on
942                         # both.
943                         new_field.remote_field.model = old_field.remote_field.model
944                         new_field.remote_field.field_name = old_field.remote_field.field_name
945                 # Handle ForeignObjects which can have multiple from_fields/to_fields.
946                 from_fields = getattr(new_field, 'from_fields', None)
947                 if from_fields:
948                     from_rename_key = (app_label, model_name)
949                     new_field.from_fields = tuple([
950                         self.renamed_fields.get(from_rename_key + (from_field,), from_field)
951                         for from_field in from_fields
952                     ])
953                     new_field.to_fields = tuple([
954                         self.renamed_fields.get(rename_key + (to_field,), to_field)
955                         for to_field in new_field.to_fields
956                     ])
957                 dependencies.extend(self._get_dependencies_for_foreign_key(new_field))
958             if hasattr(new_field, "remote_field") and getattr(new_field.remote_field, "through", None):
959                 rename_key = (
960                     new_field.remote_field.through._meta.app_label,
961                     new_field.remote_field.through._meta.model_name,
962                 )
963                 if rename_key in self.renamed_models:
964                     new_field.remote_field.through = old_field.remote_field.through
965             old_field_dec = self.deep_deconstruct(old_field)
966             new_field_dec = self.deep_deconstruct(new_field)
967             if old_field_dec != new_field_dec:
968                 both_m2m = old_field.many_to_many and new_field.many_to_many
969                 neither_m2m = not old_field.many_to_many and not new_field.many_to_many
970                 if both_m2m or neither_m2m:
971                     # Either both fields are m2m or neither is
972                     preserve_default = True
973                     if (old_field.null and not new_field.null and not new_field.has_default() and
974                             not new_field.many_to_many):
975                         field = new_field.clone()
976                         new_default = self.questioner.ask_not_null_alteration(field_name, model_name)
977                         if new_default is not models.NOT_PROVIDED:
978                             field.default = new_default
979                             preserve_default = False
980                     else:
981                         field = new_field
982                     self.add_operation(
983                         app_label,
984                         operations.AlterField(
985                             model_name=model_name,
986                             name=field_name,
987                             field=field,
988                             preserve_default=preserve_default,
989                         ),
990                         dependencies=dependencies,
991                     )
992                 else:
993                     # We cannot alter between m2m and concrete fields
994                     self._generate_removed_field(app_label, model_name, field_name)
995                     self._generate_added_field(app_label, model_name, field_name)
996 
997     def create_altered_indexes(self):
998         option_name = operations.AddIndex.option_name
999         for app_label, model_name in sorted(self.kept_model_keys):
1000             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1001             old_model_state = self.from_state.models[app_label, old_model_name]
1002             new_model_state = self.to_state.models[app_label, model_name]
1003 
1004             old_indexes = old_model_state.options[option_name]
1005             new_indexes = new_model_state.options[option_name]
1006             add_idx = [idx for idx in new_indexes if idx not in old_indexes]
1007             rem_idx = [idx for idx in old_indexes if idx not in new_indexes]
1008 
1009             self.altered_indexes.update({
1010                 (app_label, model_name): {
1011                     'added_indexes': add_idx, 'removed_indexes': rem_idx,
1012                 }
1013             })
1014 
1015     def generate_added_indexes(self):
1016         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1017             for index in alt_indexes['added_indexes']:
1018                 self.add_operation(
1019                     app_label,
1020                     operations.AddIndex(
1021                         model_name=model_name,
1022                         index=index,
1023                     )
1024                 )
1025 
1026     def generate_removed_indexes(self):
1027         for (app_label, model_name), alt_indexes in self.altered_indexes.items():
1028             for index in alt_indexes['removed_indexes']:
1029                 self.add_operation(
1030                     app_label,
1031                     operations.RemoveIndex(
1032                         model_name=model_name,
1033                         name=index.name,
1034                     )
1035                 )
1036 
1037     def create_altered_constraints(self):
1038         option_name = operations.AddConstraint.option_name
1039         for app_label, model_name in sorted(self.kept_model_keys):
1040             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1041             old_model_state = self.from_state.models[app_label, old_model_name]
1042             new_model_state = self.to_state.models[app_label, model_name]
1043 
1044             old_constraints = old_model_state.options[option_name]
1045             new_constraints = new_model_state.options[option_name]
1046             add_constraints = [c for c in new_constraints if c not in old_constraints]
1047             rem_constraints = [c for c in old_constraints if c not in new_constraints]
1048 
1049             self.altered_constraints.update({
1050                 (app_label, model_name): {
1051                     'added_constraints': add_constraints, 'removed_constraints': rem_constraints,
1052                 }
1053             })
1054 
1055     def generate_added_constraints(self):
1056         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1057             for constraint in alt_constraints['added_constraints']:
1058                 self.add_operation(
1059                     app_label,
1060                     operations.AddConstraint(
1061                         model_name=model_name,
1062                         constraint=constraint,
1063                     )
1064                 )
1065 
1066     def generate_removed_constraints(self):
1067         for (app_label, model_name), alt_constraints in self.altered_constraints.items():
1068             for constraint in alt_constraints['removed_constraints']:
1069                 self.add_operation(
1070                     app_label,
1071                     operations.RemoveConstraint(
1072                         model_name=model_name,
1073                         name=constraint.name,
1074                     )
1075                 )
1076 
1077     def _get_dependencies_for_foreign_key(self, field):
1078         # Account for FKs to swappable models
1079         swappable_setting = getattr(field, 'swappable_setting', None)
1080         if swappable_setting is not None:
1081             dep_app_label = "__setting__"
1082             dep_object_name = swappable_setting
1083         else:
1084             dep_app_label = field.remote_field.model._meta.app_label
1085             dep_object_name = field.remote_field.model._meta.object_name
1086         dependencies = [(dep_app_label, dep_object_name, None, True)]
1087         if getattr(field.remote_field, "through", None) and not field.remote_field.through._meta.auto_created:
1088             dependencies.append((
1089                 field.remote_field.through._meta.app_label,
1090                 field.remote_field.through._meta.object_name,
1091                 None,
1092                 True,
1093             ))
1094         return dependencies
1095 
1096     def _generate_altered_foo_together(self, operation):
1097         option_name = operation.option_name
1098         for app_label, model_name in sorted(self.kept_model_keys):
1099             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1100             old_model_state = self.from_state.models[app_label, old_model_name]
1101             new_model_state = self.to_state.models[app_label, model_name]
1102 
1103             # We run the old version through the field renames to account for those
1104             old_value = old_model_state.options.get(option_name)
1105             old_value = {
1106                 tuple(
1107                     self.renamed_fields.get((app_label, model_name, n), n)
1108                     for n in unique
1109                 )
1110                 for unique in old_value
1111             } if old_value else set()
1112 
1113             new_value = new_model_state.options.get(option_name)
1114             new_value = set(new_value) if new_value else set()
1115 
1116             if old_value != new_value:
1117                 dependencies = []
1118                 for foo_togethers in new_value:
1119                     for field_name in foo_togethers:
1120                         field = self.new_apps.get_model(app_label, model_name)._meta.get_field(field_name)
1121                         if field.remote_field and field.remote_field.model:
1122                             dependencies.extend(self._get_dependencies_for_foreign_key(field))
1123 
1124                 self.add_operation(
1125                     app_label,
1126                     operation(
1127                         name=model_name,
1128                         **{option_name: new_value}
1129                     ),
1130                     dependencies=dependencies,
1131                 )
1132 
1133     def generate_altered_unique_together(self):
1134         self._generate_altered_foo_together(operations.AlterUniqueTogether)
1135 
1136     def generate_altered_index_together(self):
1137         self._generate_altered_foo_together(operations.AlterIndexTogether)
1138 
1139     def generate_altered_db_table(self):
1140         models_to_check = self.kept_model_keys.union(self.kept_proxy_keys, self.kept_unmanaged_keys)
1141         for app_label, model_name in sorted(models_to_check):
1142             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1143             old_model_state = self.from_state.models[app_label, old_model_name]
1144             new_model_state = self.to_state.models[app_label, model_name]
1145             old_db_table_name = old_model_state.options.get('db_table')
1146             new_db_table_name = new_model_state.options.get('db_table')
1147             if old_db_table_name != new_db_table_name:
1148                 self.add_operation(
1149                     app_label,
1150                     operations.AlterModelTable(
1151                         name=model_name,
1152                         table=new_db_table_name,
1153                     )
1154                 )
1155 
1156     def generate_altered_options(self):
1157         """
1158         Work out if any non-schema-affecting options have changed and make an
1159         operation to represent them in state changes (in case Python code in
1160         migrations needs them).
1161         """
1162         models_to_check = self.kept_model_keys.union(
1163             self.kept_proxy_keys,
1164             self.kept_unmanaged_keys,
1165             # unmanaged converted to managed
1166             self.old_unmanaged_keys & self.new_model_keys,
1167             # managed converted to unmanaged
1168             self.old_model_keys & self.new_unmanaged_keys,
1169         )
1170 
1171         for app_label, model_name in sorted(models_to_check):
1172             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1173             old_model_state = self.from_state.models[app_label, old_model_name]
1174             new_model_state = self.to_state.models[app_label, model_name]
1175             old_options = {
1176                 key: value for key, value in old_model_state.options.items()
1177                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1178             }
1179             new_options = {
1180                 key: value for key, value in new_model_state.options.items()
1181                 if key in AlterModelOptions.ALTER_OPTION_KEYS
1182             }
1183             if old_options != new_options:
1184                 self.add_operation(
1185                     app_label,
1186                     operations.AlterModelOptions(
1187                         name=model_name,
1188                         options=new_options,
1189                     )
1190                 )
1191 
1192     def generate_altered_order_with_respect_to(self):
1193         for app_label, model_name in sorted(self.kept_model_keys):
1194             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1195             old_model_state = self.from_state.models[app_label, old_model_name]
1196             new_model_state = self.to_state.models[app_label, model_name]
1197             if (old_model_state.options.get("order_with_respect_to") !=
1198                     new_model_state.options.get("order_with_respect_to")):
1199                 # Make sure it comes second if we're adding
1200                 # (removal dependency is part of RemoveField)
1201                 dependencies = []
1202                 if new_model_state.options.get("order_with_respect_to"):
1203                     dependencies.append((
1204                         app_label,
1205                         model_name,
1206                         new_model_state.options["order_with_respect_to"],
1207                         True,
1208                     ))
1209                 # Actually generate the operation
1210                 self.add_operation(
1211                     app_label,
1212                     operations.AlterOrderWithRespectTo(
1213                         name=model_name,
1214                         order_with_respect_to=new_model_state.options.get('order_with_respect_to'),
1215                     ),
1216                     dependencies=dependencies,
1217                 )
1218 
1219     def generate_altered_managers(self):
1220         for app_label, model_name in sorted(self.kept_model_keys):
1221             old_model_name = self.renamed_models.get((app_label, model_name), model_name)
1222             old_model_state = self.from_state.models[app_label, old_model_name]
1223             new_model_state = self.to_state.models[app_label, model_name]
1224             if old_model_state.managers != new_model_state.managers:
1225                 self.add_operation(
1226                     app_label,
1227                     operations.AlterModelManagers(
1228                         name=model_name,
1229                         managers=new_model_state.managers,
1230                     )
1231                 )
1232 
1233     def arrange_for_graph(self, changes, graph, migration_name=None):
1234         """
1235         Take a result from changes() and a MigrationGraph, and fix the names
1236         and dependencies of the changes so they extend the graph from the leaf
1237         nodes for each app.
1238         """
1239         leaves = graph.leaf_nodes()
1240         name_map = {}
1241         for app_label, migrations in list(changes.items()):
1242             if not migrations:
1243                 continue
1244             # Find the app label's current leaf node
1245             app_leaf = None
1246             for leaf in leaves:
1247                 if leaf[0] == app_label:
1248                     app_leaf = leaf
1249                     break
1250             # Do they want an initial migration for this app?
1251             if app_leaf is None and not self.questioner.ask_initial(app_label):
1252                 # They don't.
1253                 for migration in migrations:
1254                     name_map[(app_label, migration.name)] = (app_label, "__first__")
1255                 del changes[app_label]
1256                 continue
1257             # Work out the next number in the sequence
1258             if app_leaf is None:
1259                 next_number = 1
1260             else:
1261                 next_number = (self.parse_number(app_leaf[1]) or 0) + 1
1262             # Name each migration
1263             for i, migration in enumerate(migrations):
1264                 if i == 0 and app_leaf:
1265                     migration.dependencies.append(app_leaf)
1266                 new_name_parts = ['%04i' % next_number]
1267                 if migration_name:
1268                     new_name_parts.append(migration_name)
1269                 elif i == 0 and not app_leaf:
1270                     new_name_parts.append('initial')
1271                 else:
1272                     new_name_parts.append(migration.suggest_name()[:100])
1273                 new_name = '_'.join(new_name_parts)
1274                 name_map[(app_label, migration.name)] = (app_label, new_name)
1275                 next_number += 1
1276                 migration.name = new_name
1277         # Now fix dependencies
1278         for migrations in changes.values():
1279             for migration in migrations:
1280                 migration.dependencies = [name_map.get(d, d) for d in migration.dependencies]
1281         return changes
1282 
1283     def _trim_to_apps(self, changes, app_labels):
1284         """
1285         Take changes from arrange_for_graph() and set of app labels, and return
1286         a modified set of changes which trims out as many migrations that are
1287         not in app_labels as possible. Note that some other migrations may
1288         still be present as they may be required dependencies.
1289         """
1290         # Gather other app dependencies in a first pass
1291         app_dependencies = {}
1292         for app_label, migrations in changes.items():
1293             for migration in migrations:
1294                 for dep_app_label, name in migration.dependencies:
1295                     app_dependencies.setdefault(app_label, set()).add(dep_app_label)
1296         required_apps = set(app_labels)
1297         # Keep resolving till there's no change
1298         old_required_apps = None
1299         while old_required_apps != required_apps:
1300             old_required_apps = set(required_apps)
1301             required_apps.update(*[app_dependencies.get(app_label, ()) for app_label in required_apps])
1302         # Remove all migrations that aren't needed
1303         for app_label in list(changes):
1304             if app_label not in required_apps:
1305                 del changes[app_label]
1306         return changes
1307 
1308     @classmethod
1309     def parse_number(cls, name):
1310         """
1311         Given a migration name, try to extract a number from the beginning of
1312         it. If no number is found, return None.
1313         """
1314         match = re.match(r'^\d+', name)
1315         if match:
1316             return int(match[0])
1317         return None

</code><intended_behavior>Modify the migration autodetection logic to ensure that `AlterOrderWithRespectTo` operations are correctly identified and sequenced before any index creation operations involving fields affected by the `AlterOrderWithRespectTo`. This adjustment would account for the necessary creation or adjustment of fields like `_order` before attempts are made to index them, thus preventing the reported crash.</intended_behavior>, <file>django/db/migrations/operations/models.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.db import models
2 from django.db.migrations.operations.base import Operation
3 from django.db.migrations.state import ModelState
4 from django.db.models.options import normalize_together
5 from django.utils.functional import cached_property
6 
7 from .fields import (
8     AddField, AlterField, FieldOperation, RemoveField, RenameField,
9 )
10 from .utils import field_references, get_references, resolve_relation
11 
12 
13 def _check_for_duplicates(arg_name, objs):
14     used_vals = set()
15     for val in objs:
16         if val in used_vals:
17             raise ValueError(
18                 "Found duplicate value %s in CreateModel %s argument." % (val, arg_name)
19             )
20         used_vals.add(val)
21 
22 
23 class ModelOperation(Operation):
24     def __init__(self, name):
25         self.name = name
26 
27     @cached_property
28     def name_lower(self):
29         return self.name.lower()
30 
31     def references_model(self, name, app_label):
32         return name.lower() == self.name_lower
33 
34     def reduce(self, operation, app_label):
35         return (
36             super().reduce(operation, app_label) or
37             not operation.references_model(self.name, app_label)
38         )
39 
40 
41 class CreateModel(ModelOperation):
42     """Create a model's table."""
43 
44     serialization_expand_args = ['fields', 'options', 'managers']
45 
46     def __init__(self, name, fields, options=None, bases=None, managers=None):
47         self.fields = fields
48         self.options = options or {}
49         self.bases = bases or (models.Model,)
50         self.managers = managers or []
51         super().__init__(name)
52         # Sanity-check that there are no duplicated field names, bases, or
53         # manager names
54         _check_for_duplicates('fields', (name for name, _ in self.fields))
55         _check_for_duplicates('bases', (
56             base._meta.label_lower if hasattr(base, '_meta') else
57             base.lower() if isinstance(base, str) else base
58             for base in self.bases
59         ))
60         _check_for_duplicates('managers', (name for name, _ in self.managers))
61 
62     def deconstruct(self):
63         kwargs = {
64             'name': self.name,
65             'fields': self.fields,
66         }
67         if self.options:
68             kwargs['options'] = self.options
69         if self.bases and self.bases != (models.Model,):
70             kwargs['bases'] = self.bases
71         if self.managers and self.managers != [('objects', models.Manager())]:
72             kwargs['managers'] = self.managers
73         return (
74             self.__class__.__qualname__,
75             [],
76             kwargs
77         )
78 
79     def state_forwards(self, app_label, state):
80         state.add_model(ModelState(
81             app_label,
82             self.name,
83             list(self.fields),
84             dict(self.options),
85             tuple(self.bases),
86             list(self.managers),
87         ))
88 
89     def database_forwards(self, app_label, schema_editor, from_state, to_state):
90         model = to_state.apps.get_model(app_label, self.name)
91         if self.allow_migrate_model(schema_editor.connection.alias, model):
92             schema_editor.create_model(model)
93 
94     def database_backwards(self, app_label, schema_editor, from_state, to_state):
95         model = from_state.apps.get_model(app_label, self.name)
96         if self.allow_migrate_model(schema_editor.connection.alias, model):
97             schema_editor.delete_model(model)
98 
99     def describe(self):
100         return "Create %smodel %s" % ("proxy " if self.options.get("proxy", False) else "", self.name)
101 
102     @property
103     def migration_name_fragment(self):
104         return self.name_lower
105 
106     def references_model(self, name, app_label):
107         name_lower = name.lower()
108         if name_lower == self.name_lower:
109             return True
110 
111         # Check we didn't inherit from the model
112         reference_model_tuple = (app_label, name_lower)
113         for base in self.bases:
114             if (base is not models.Model and isinstance(base, (models.base.ModelBase, str)) and
115                     resolve_relation(base, app_label) == reference_model_tuple):
116                 return True
117 
118         # Check we have no FKs/M2Ms with it
119         for _name, field in self.fields:
120             if field_references((app_label, self.name_lower), field, reference_model_tuple):
121                 return True
122         return False
123 
124     def reduce(self, operation, app_label):
125         if (isinstance(operation, DeleteModel) and
126                 self.name_lower == operation.name_lower and
127                 not self.options.get("proxy", False)):
128             return []
129         elif isinstance(operation, RenameModel) and self.name_lower == operation.old_name_lower:
130             return [
131                 CreateModel(
132                     operation.new_name,
133                     fields=self.fields,
134                     options=self.options,
135                     bases=self.bases,
136                     managers=self.managers,
137                 ),
138             ]
139         elif isinstance(operation, AlterModelOptions) and self.name_lower == operation.name_lower:
140             return [
141                 CreateModel(
142                     self.name,
143                     fields=self.fields,
144                     options={**self.options, **operation.options},
145                     bases=self.bases,
146                     managers=self.managers,
147                 ),
148             ]
149         elif isinstance(operation, AlterTogetherOptionOperation) and self.name_lower == operation.name_lower:
150             return [
151                 CreateModel(
152                     self.name,
153                     fields=self.fields,
154                     options={**self.options, **{operation.option_name: operation.option_value}},
155                     bases=self.bases,
156                     managers=self.managers,
157                 ),
158             ]
159         elif isinstance(operation, AlterOrderWithRespectTo) and self.name_lower == operation.name_lower:
160             return [
161                 CreateModel(
162                     self.name,
163                     fields=self.fields,
164                     options={**self.options, 'order_with_respect_to': operation.order_with_respect_to},
165                     bases=self.bases,
166                     managers=self.managers,
167                 ),
168             ]
169         elif isinstance(operation, FieldOperation) and self.name_lower == operation.model_name_lower:
170             if isinstance(operation, AddField):
171                 return [
172                     CreateModel(
173                         self.name,
174                         fields=self.fields + [(operation.name, operation.field)],
175                         options=self.options,
176                         bases=self.bases,
177                         managers=self.managers,
178                     ),
179                 ]
180             elif isinstance(operation, AlterField):
181                 return [
182                     CreateModel(
183                         self.name,
184                         fields=[
185                             (n, operation.field if n == operation.name else v)
186                             for n, v in self.fields
187                         ],
188                         options=self.options,
189                         bases=self.bases,
190                         managers=self.managers,
191                     ),
192                 ]
193             elif isinstance(operation, RemoveField):
194                 options = self.options.copy()
195                 for option_name in ('unique_together', 'index_together'):
196                     option = options.pop(option_name, None)
197                     if option:
198                         option = set(filter(bool, (
199                             tuple(f for f in fields if f != operation.name_lower) for fields in option
200                         )))
201                         if option:
202                             options[option_name] = option
203                 order_with_respect_to = options.get('order_with_respect_to')
204                 if order_with_respect_to == operation.name_lower:
205                     del options['order_with_respect_to']
206                 return [
207                     CreateModel(
208                         self.name,
209                         fields=[
210                             (n, v)
211                             for n, v in self.fields
212                             if n.lower() != operation.name_lower
213                         ],
214                         options=options,
215                         bases=self.bases,
216                         managers=self.managers,
217                     ),
218                 ]
219             elif isinstance(operation, RenameField):
220                 options = self.options.copy()
221                 for option_name in ('unique_together', 'index_together'):
222                     option = options.get(option_name)
223                     if option:
224                         options[option_name] = {
225                             tuple(operation.new_name if f == operation.old_name else f for f in fields)
226                             for fields in option
227                         }
228                 order_with_respect_to = options.get('order_with_respect_to')
229                 if order_with_respect_to == operation.old_name:
230                     options['order_with_respect_to'] = operation.new_name
231                 return [
232                     CreateModel(
233                         self.name,
234                         fields=[
235                             (operation.new_name if n == operation.old_name else n, v)
236                             for n, v in self.fields
237                         ],
238                         options=options,
239                         bases=self.bases,
240                         managers=self.managers,
241                     ),
242                 ]
243         return super().reduce(operation, app_label)
244 
245 
246 class DeleteModel(ModelOperation):
247     """Drop a model's table."""
248 
249     def deconstruct(self):
250         kwargs = {
251             'name': self.name,
252         }
253         return (
254             self.__class__.__qualname__,
255             [],
256             kwargs
257         )
258 
259     def state_forwards(self, app_label, state):
260         state.remove_model(app_label, self.name_lower)
261 
262     def database_forwards(self, app_label, schema_editor, from_state, to_state):
263         model = from_state.apps.get_model(app_label, self.name)
264         if self.allow_migrate_model(schema_editor.connection.alias, model):
265             schema_editor.delete_model(model)
266 
267     def database_backwards(self, app_label, schema_editor, from_state, to_state):
268         model = to_state.apps.get_model(app_label, self.name)
269         if self.allow_migrate_model(schema_editor.connection.alias, model):
270             schema_editor.create_model(model)
271 
272     def references_model(self, name, app_label):
273         # The deleted model could be referencing the specified model through
274         # related fields.
275         return True
276 
277     def describe(self):
278         return "Delete model %s" % self.name
279 
280     @property
281     def migration_name_fragment(self):
282         return 'delete_%s' % self.name_lower
283 
284 
285 class RenameModel(ModelOperation):
286     """Rename a model."""
287 
288     def __init__(self, old_name, new_name):
289         self.old_name = old_name
290         self.new_name = new_name
291         super().__init__(old_name)
292 
293     @cached_property
294     def old_name_lower(self):
295         return self.old_name.lower()
296 
297     @cached_property
298     def new_name_lower(self):
299         return self.new_name.lower()
300 
301     def deconstruct(self):
302         kwargs = {
303             'old_name': self.old_name,
304             'new_name': self.new_name,
305         }
306         return (
307             self.__class__.__qualname__,
308             [],
309             kwargs
310         )
311 
312     def state_forwards(self, app_label, state):
313         # Add a new model.
314         renamed_model = state.models[app_label, self.old_name_lower].clone()
315         renamed_model.name = self.new_name
316         state.models[app_label, self.new_name_lower] = renamed_model
317         # Repoint all fields pointing to the old model to the new one.
318         old_model_tuple = (app_label, self.old_name_lower)
319         new_remote_model = '%s.%s' % (app_label, self.new_name)
320         to_reload = set()
321         for model_state, name, field, reference in get_references(state, old_model_tuple):
322             changed_field = None
323             if reference.to:
324                 changed_field = field.clone()
325                 changed_field.remote_field.model = new_remote_model
326             if reference.through:
327                 if changed_field is None:
328                     changed_field = field.clone()
329                 changed_field.remote_field.through = new_remote_model
330             if changed_field:
331                 model_state.fields[name] = changed_field
332                 to_reload.add((model_state.app_label, model_state.name_lower))
333         # Reload models related to old model before removing the old model.
334         state.reload_models(to_reload, delay=True)
335         # Remove the old model.
336         state.remove_model(app_label, self.old_name_lower)
337         state.reload_model(app_label, self.new_name_lower, delay=True)
338 
339     def database_forwards(self, app_label, schema_editor, from_state, to_state):
340         new_model = to_state.apps.get_model(app_label, self.new_name)
341         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
342             old_model = from_state.apps.get_model(app_label, self.old_name)
343             # Move the main table
344             schema_editor.alter_db_table(
345                 new_model,
346                 old_model._meta.db_table,
347                 new_model._meta.db_table,
348             )
349             # Alter the fields pointing to us
350             for related_object in old_model._meta.related_objects:
351                 if related_object.related_model == old_model:
352                     model = new_model
353                     related_key = (app_label, self.new_name_lower)
354                 else:
355                     model = related_object.related_model
356                     related_key = (
357                         related_object.related_model._meta.app_label,
358                         related_object.related_model._meta.model_name,
359                     )
360                 to_field = to_state.apps.get_model(
361                     *related_key
362                 )._meta.get_field(related_object.field.name)
363                 schema_editor.alter_field(
364                     model,
365                     related_object.field,
366                     to_field,
367                 )
368             # Rename M2M fields whose name is based on this model's name.
369             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)
370             for (old_field, new_field) in fields:
371                 # Skip self-referential fields as these are renamed above.
372                 if new_field.model == new_field.related_model or not new_field.remote_field.through._meta.auto_created:
373                     continue
374                 # Rename the M2M table that's based on this model's name.
375                 old_m2m_model = old_field.remote_field.through
376                 new_m2m_model = new_field.remote_field.through
377                 schema_editor.alter_db_table(
378                     new_m2m_model,
379                     old_m2m_model._meta.db_table,
380                     new_m2m_model._meta.db_table,
381                 )
382                 # Rename the column in the M2M table that's based on this
383                 # model's name.
384                 schema_editor.alter_field(
385                     new_m2m_model,
386                     old_m2m_model._meta.get_field(old_model._meta.model_name),
387                     new_m2m_model._meta.get_field(new_model._meta.model_name),
388                 )
389 
390     def database_backwards(self, app_label, schema_editor, from_state, to_state):
391         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower
392         self.new_name, self.old_name = self.old_name, self.new_name
393 
394         self.database_forwards(app_label, schema_editor, from_state, to_state)
395 
396         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower
397         self.new_name, self.old_name = self.old_name, self.new_name
398 
399     def references_model(self, name, app_label):
400         return (
401             name.lower() == self.old_name_lower or
402             name.lower() == self.new_name_lower
403         )
404 
405     def describe(self):
406         return "Rename model %s to %s" % (self.old_name, self.new_name)
407 
408     @property
409     def migration_name_fragment(self):
410         return 'rename_%s_%s' % (self.old_name_lower, self.new_name_lower)
411 
412     def reduce(self, operation, app_label):
413         if (isinstance(operation, RenameModel) and
414                 self.new_name_lower == operation.old_name_lower):
415             return [
416                 RenameModel(
417                     self.old_name,
418                     operation.new_name,
419                 ),
420             ]
421         # Skip `ModelOperation.reduce` as we want to run `references_model`
422         # against self.new_name.
423         return (
424             super(ModelOperation, self).reduce(operation, app_label) or
425             not operation.references_model(self.new_name, app_label)
426         )
427 
428 
429 class ModelOptionOperation(ModelOperation):
430     def reduce(self, operation, app_label):
431         if isinstance(operation, (self.__class__, DeleteModel)) and self.name_lower == operation.name_lower:
432             return [operation]
433         return super().reduce(operation, app_label)
434 
435 
436 class AlterModelTable(ModelOptionOperation):
437     """Rename a model's table."""
438 
439     def __init__(self, name, table):
440         self.table = table
441         super().__init__(name)
442 
443     def deconstruct(self):
444         kwargs = {
445             'name': self.name,
446             'table': self.table,
447         }
448         return (
449             self.__class__.__qualname__,
450             [],
451             kwargs
452         )
453 
454     def state_forwards(self, app_label, state):
455         state.models[app_label, self.name_lower].options["db_table"] = self.table
456         state.reload_model(app_label, self.name_lower, delay=True)
457 
458     def database_forwards(self, app_label, schema_editor, from_state, to_state):
459         new_model = to_state.apps.get_model(app_label, self.name)
460         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
461             old_model = from_state.apps.get_model(app_label, self.name)
462             schema_editor.alter_db_table(
463                 new_model,
464                 old_model._meta.db_table,
465                 new_model._meta.db_table,
466             )
467             # Rename M2M fields whose name is based on this model's db_table
468             for (old_field, new_field) in zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many):
469                 if new_field.remote_field.through._meta.auto_created:
470                     schema_editor.alter_db_table(
471                         new_field.remote_field.through,
472                         old_field.remote_field.through._meta.db_table,
473                         new_field.remote_field.through._meta.db_table,
474                     )
475 
476     def database_backwards(self, app_label, schema_editor, from_state, to_state):
477         return self.database_forwards(app_label, schema_editor, from_state, to_state)
478 
479     def describe(self):
480         return "Rename table for %s to %s" % (
481             self.name,
482             self.table if self.table is not None else "(default)"
483         )
484 
485     @property
486     def migration_name_fragment(self):
487         return 'alter_%s_table' % self.name_lower
488 
489 
490 class AlterTogetherOptionOperation(ModelOptionOperation):
491     option_name = None
492 
493     def __init__(self, name, option_value):
494         if option_value:
495             option_value = set(normalize_together(option_value))
496         setattr(self, self.option_name, option_value)
497         super().__init__(name)
498 
499     @cached_property
500     def option_value(self):
501         return getattr(self, self.option_name)
502 
503     def deconstruct(self):
504         kwargs = {
505             'name': self.name,
506             self.option_name: self.option_value,
507         }
508         return (
509             self.__class__.__qualname__,
510             [],
511             kwargs
512         )
513 
514     def state_forwards(self, app_label, state):
515         model_state = state.models[app_label, self.name_lower]
516         model_state.options[self.option_name] = self.option_value
517         state.reload_model(app_label, self.name_lower, delay=True)
518 
519     def database_forwards(self, app_label, schema_editor, from_state, to_state):
520         new_model = to_state.apps.get_model(app_label, self.name)
521         if self.allow_migrate_model(schema_editor.connection.alias, new_model):
522             old_model = from_state.apps.get_model(app_label, self.name)
523             alter_together = getattr(schema_editor, 'alter_%s' % self.option_name)
524             alter_together(
525                 new_model,
526                 getattr(old_model._meta, self.option_name, set()),
527                 getattr(new_model._meta, self.option_name, set()),
528             )
529 
530     def database_backwards(self, app_label, schema_editor, from_state, to_state):
531         return self.database_forwards(app_label, schema_editor, from_state, to_state)
532 
533     def references_field(self, model_name, name, app_label):
534         return (
535             self.references_model(model_name, app_label) and
536             (
537                 not self.option_value or
538                 any((name in fields) for fields in self.option_value)
539             )
540         )
541 
542     def describe(self):
543         return "Alter %s for %s (%s constraint(s))" % (self.option_name, self.name, len(self.option_value or ''))
544 
545     @property
546     def migration_name_fragment(self):
547         return 'alter_%s_%s' % (self.name_lower, self.option_name)
548 
549 
550 class AlterUniqueTogether(AlterTogetherOptionOperation):
551     """
552     Change the value of unique_together to the target one.
553     Input value of unique_together must be a set of tuples.
554     """
555     option_name = 'unique_together'
556 
557     def __init__(self, name, unique_together):
558         super().__init__(name, unique_together)
559 
560 
561 class AlterIndexTogether(AlterTogetherOptionOperation):
562     """
563     Change the value of index_together to the target one.
564     Input value of index_together must be a set of tuples.
565     """
566     option_name = "index_together"
567 
568     def __init__(self, name, index_together):
569         super().__init__(name, index_together)
570 
571 
572 class AlterOrderWithRespectTo(ModelOptionOperation):
573     """Represent a change with the order_with_respect_to option."""
574 
575     option_name = 'order_with_respect_to'
576 
577     def __init__(self, name, order_with_respect_to):
578         self.order_with_respect_to = order_with_respect_to
579         super().__init__(name)
580 
581     def deconstruct(self):
582         kwargs = {
583             'name': self.name,
584             'order_with_respect_to': self.order_with_respect_to,
585         }
586         return (
587             self.__class__.__qualname__,
588             [],
589             kwargs
590         )
591 
592     def state_forwards(self, app_label, state):
593         model_state = state.models[app_label, self.name_lower]
594         model_state.options['order_with_respect_to'] = self.order_with_respect_to
595         state.reload_model(app_label, self.name_lower, delay=True)
596 
597     def database_forwards(self, app_label, schema_editor, from_state, to_state):
598         to_model = to_state.apps.get_model(app_label, self.name)
599         if self.allow_migrate_model(schema_editor.connection.alias, to_model):
600             from_model = from_state.apps.get_model(app_label, self.name)
601             # Remove a field if we need to
602             if from_model._meta.order_with_respect_to and not to_model._meta.order_with_respect_to:
603                 schema_editor.remove_field(from_model, from_model._meta.get_field("_order"))
604             # Add a field if we need to (altering the column is untouched as
605             # it's likely a rename)
606             elif to_model._meta.order_with_respect_to and not from_model._meta.order_with_respect_to:
607                 field = to_model._meta.get_field("_order")
608                 if not field.has_default():
609                     field.default = 0
610                 schema_editor.add_field(
611                     from_model,
612                     field,
613                 )
614 
615     def database_backwards(self, app_label, schema_editor, from_state, to_state):
616         self.database_forwards(app_label, schema_editor, from_state, to_state)
617 
618     def references_field(self, model_name, name, app_label):
619         return (
620             self.references_model(model_name, app_label) and
621             (
622                 self.order_with_respect_to is None or
623                 name == self.order_with_respect_to
624             )
625         )
626 
627     def describe(self):
628         return "Set order_with_respect_to on %s to %s" % (self.name, self.order_with_respect_to)
629 
630     @property
631     def migration_name_fragment(self):
632         return 'alter_%s_order_with_respect_to' % self.name_lower
633 
634 
635 class AlterModelOptions(ModelOptionOperation):
636     """
637     Set new model options that don't directly affect the database schema
638     (like verbose_name, permissions, ordering). Python code in migrations
639     may still need them.
640     """
641 
642     # Model options we want to compare and preserve in an AlterModelOptions op
643     ALTER_OPTION_KEYS = [
644         "base_manager_name",
645         "default_manager_name",
646         "default_related_name",
647         "get_latest_by",
648         "managed",
649         "ordering",
650         "permissions",
651         "default_permissions",
652         "select_on_save",
653         "verbose_name",
654         "verbose_name_plural",
655     ]
656 
657     def __init__(self, name, options):
658         self.options = options
659         super().__init__(name)
660 
661     def deconstruct(self):
662         kwargs = {
663             'name': self.name,
664             'options': self.options,
665         }
666         return (
667             self.__class__.__qualname__,
668             [],
669             kwargs
670         )
671 
672     def state_forwards(self, app_label, state):
673         model_state = state.models[app_label, self.name_lower]
674         model_state.options = {**model_state.options, **self.options}
675         for key in self.ALTER_OPTION_KEYS:
676             if key not in self.options:
677                 model_state.options.pop(key, False)
678         state.reload_model(app_label, self.name_lower, delay=True)
679 
680     def database_forwards(self, app_label, schema_editor, from_state, to_state):
681         pass
682 
683     def database_backwards(self, app_label, schema_editor, from_state, to_state):
684         pass
685 
686     def describe(self):
687         return "Change Meta options on %s" % self.name
688 
689     @property
690     def migration_name_fragment(self):
691         return 'alter_%s_options' % self.name_lower
692 
693 
694 class AlterModelManagers(ModelOptionOperation):
695     """Alter the model's managers."""
696 
697     serialization_expand_args = ['managers']
698 
699     def __init__(self, name, managers):
700         self.managers = managers
701         super().__init__(name)
702 
703     def deconstruct(self):
704         return (
705             self.__class__.__qualname__,
706             [self.name, self.managers],
707             {}
708         )
709 
710     def state_forwards(self, app_label, state):
711         model_state = state.models[app_label, self.name_lower]
712         model_state.managers = list(self.managers)
713         state.reload_model(app_label, self.name_lower, delay=True)
714 
715     def database_forwards(self, app_label, schema_editor, from_state, to_state):
716         pass
717 
718     def database_backwards(self, app_label, schema_editor, from_state, to_state):
719         pass
720 
721     def describe(self):
722         return "Change managers on %s" % self.name
723 
724     @property
725     def migration_name_fragment(self):
726         return 'alter_%s_managers' % self.name_lower
727 
728 
729 class IndexOperation(Operation):
730     option_name = 'indexes'
731 
732     @cached_property
733     def model_name_lower(self):
734         return self.model_name.lower()
735 
736 
737 class AddIndex(IndexOperation):
738     """Add an index on a model."""
739 
740     def __init__(self, model_name, index):
741         self.model_name = model_name
742         if not index.name:
743             raise ValueError(
744                 "Indexes passed to AddIndex operations require a name "
745                 "argument. %r doesn't have one." % index
746             )
747         self.index = index
748 
749     def state_forwards(self, app_label, state):
750         model_state = state.models[app_label, self.model_name_lower]
751         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.index.clone()]
752         state.reload_model(app_label, self.model_name_lower, delay=True)
753 
754     def database_forwards(self, app_label, schema_editor, from_state, to_state):
755         model = to_state.apps.get_model(app_label, self.model_name)
756         if self.allow_migrate_model(schema_editor.connection.alias, model):
757             schema_editor.add_index(model, self.index)
758 
759     def database_backwards(self, app_label, schema_editor, from_state, to_state):
760         model = from_state.apps.get_model(app_label, self.model_name)
761         if self.allow_migrate_model(schema_editor.connection.alias, model):
762             schema_editor.remove_index(model, self.index)
763 
764     def deconstruct(self):
765         kwargs = {
766             'model_name': self.model_name,
767             'index': self.index,
768         }
769         return (
770             self.__class__.__qualname__,
771             [],
772             kwargs,
773         )
774 
775     def describe(self):
776         return 'Create index %s on field(s) %s of model %s' % (
777             self.index.name,
778             ', '.join(self.index.fields),
779             self.model_name,
780         )
781 
782     @property
783     def migration_name_fragment(self):
784         return '%s_%s' % (self.model_name_lower, self.index.name.lower())
785 
786 
787 class RemoveIndex(IndexOperation):
788     """Remove an index from a model."""
789 
790     def __init__(self, model_name, name):
791         self.model_name = model_name
792         self.name = name
793 
794     def state_forwards(self, app_label, state):
795         model_state = state.models[app_label, self.model_name_lower]
796         indexes = model_state.options[self.option_name]
797         model_state.options[self.option_name] = [idx for idx in indexes if idx.name != self.name]
798         state.reload_model(app_label, self.model_name_lower, delay=True)
799 
800     def database_forwards(self, app_label, schema_editor, from_state, to_state):
801         model = from_state.apps.get_model(app_label, self.model_name)
802         if self.allow_migrate_model(schema_editor.connection.alias, model):
803             from_model_state = from_state.models[app_label, self.model_name_lower]
804             index = from_model_state.get_index_by_name(self.name)
805             schema_editor.remove_index(model, index)
806 
807     def database_backwards(self, app_label, schema_editor, from_state, to_state):
808         model = to_state.apps.get_model(app_label, self.model_name)
809         if self.allow_migrate_model(schema_editor.connection.alias, model):
810             to_model_state = to_state.models[app_label, self.model_name_lower]
811             index = to_model_state.get_index_by_name(self.name)
812             schema_editor.add_index(model, index)
813 
814     def deconstruct(self):
815         kwargs = {
816             'model_name': self.model_name,
817             'name': self.name,
818         }
819         return (
820             self.__class__.__qualname__,
821             [],
822             kwargs,
823         )
824 
825     def describe(self):
826         return 'Remove index %s from %s' % (self.name, self.model_name)
827 
828     @property
829     def migration_name_fragment(self):
830         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())
831 
832 
833 class AddConstraint(IndexOperation):
834     option_name = 'constraints'
835 
836     def __init__(self, model_name, constraint):
837         self.model_name = model_name
838         self.constraint = constraint
839 
840     def state_forwards(self, app_label, state):
841         model_state = state.models[app_label, self.model_name_lower]
842         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.constraint]
843         state.reload_model(app_label, self.model_name_lower, delay=True)
844 
845     def database_forwards(self, app_label, schema_editor, from_state, to_state):
846         model = to_state.apps.get_model(app_label, self.model_name)
847         if self.allow_migrate_model(schema_editor.connection.alias, model):
848             schema_editor.add_constraint(model, self.constraint)
849 
850     def database_backwards(self, app_label, schema_editor, from_state, to_state):
851         model = to_state.apps.get_model(app_label, self.model_name)
852         if self.allow_migrate_model(schema_editor.connection.alias, model):
853             schema_editor.remove_constraint(model, self.constraint)
854 
855     def deconstruct(self):
856         return self.__class__.__name__, [], {
857             'model_name': self.model_name,
858             'constraint': self.constraint,
859         }
860 
861     def describe(self):
862         return 'Create constraint %s on model %s' % (self.constraint.name, self.model_name)
863 
864     @property
865     def migration_name_fragment(self):
866         return '%s_%s' % (self.model_name_lower, self.constraint.name.lower())
867 
868 
869 class RemoveConstraint(IndexOperation):
870     option_name = 'constraints'
871 
872     def __init__(self, model_name, name):
873         self.model_name = model_name
874         self.name = name
875 
876     def state_forwards(self, app_label, state):
877         model_state = state.models[app_label, self.model_name_lower]
878         constraints = model_state.options[self.option_name]
879         model_state.options[self.option_name] = [c for c in constraints if c.name != self.name]
880         state.reload_model(app_label, self.model_name_lower, delay=True)
881 
882     def database_forwards(self, app_label, schema_editor, from_state, to_state):
883         model = to_state.apps.get_model(app_label, self.model_name)
884         if self.allow_migrate_model(schema_editor.connection.alias, model):
885             from_model_state = from_state.models[app_label, self.model_name_lower]
886             constraint = from_model_state.get_constraint_by_name(self.name)
887             schema_editor.remove_constraint(model, constraint)
888 
889     def database_backwards(self, app_label, schema_editor, from_state, to_state):
890         model = to_state.apps.get_model(app_label, self.model_name)
891         if self.allow_migrate_model(schema_editor.connection.alias, model):
892             to_model_state = to_state.models[app_label, self.model_name_lower]
893             constraint = to_model_state.get_constraint_by_name(self.name)
894             schema_editor.add_constraint(model, constraint)
895 
896     def deconstruct(self):
897         return self.__class__.__name__, [], {
898             'model_name': self.model_name,
899             'name': self.name,
900         }
901 
902     def describe(self):
903         return 'Remove constraint %s from model %s' % (self.name, self.model_name)
904 
905     @property
906     def migration_name_fragment(self):
907         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())

</code><intended_behavior>The `AlterOrderWithRespectTo` operation logic may require adjustments to ensure that when it runs, the migration system either checks for the existence of the `_order` field or explicitly defines it before any index operations referencing this field are executed. This might involve modifying how the operation is interpreted or executed within migrations to ensure dependency order is respected.</intended_behavior>]
2025-10-17 12:12:17.618 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 12:12:17.618 | INFO     | Search-only: skipping patch selection
2025-10-17 12:12:17.804 | INFO     | Task django__django-13265 completed successfully.
2025-10-17 12:12:17.804 | INFO     | No patch generated. You can try running ACR again.
