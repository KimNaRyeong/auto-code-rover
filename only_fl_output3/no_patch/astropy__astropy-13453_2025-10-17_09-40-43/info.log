2025-10-17 09:40:43.528 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 09:40:46.792 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2248, output_tokens=13, cost=0.022870
2025-10-17 09:41:03.209 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2428, output_tokens=621, cost=0.042910
2025-10-17 09:41:04.234 | INFO     | registered non reproducing test 0
2025-10-17 09:41:15.994 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3812, output_tokens=507, cost=0.053330
2025-10-17 09:41:16.998 | INFO     | registered non reproducing test 1
2025-10-17 09:41:30.891 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3695, output_tokens=662, cost=0.056810
2025-10-17 09:41:31.895 | INFO     | registered non reproducing test 2
2025-10-17 09:41:31.895 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 09:41:31.901 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 09:41:38.576 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1683, output_tokens=256, cost=0.024510
2025-10-17 09:41:38.583 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 09:41:40.829 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=610, output_tokens=48, cost=0.007540
2025-10-17 09:41:40.830 | DEBUG    | Extracted a valid json.
2025-10-17 09:41:40.830 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Table\")",
        "search_method_in_class(\"write\", \"Table\")",
        "search_code(\"format='html'\")"
    ],
    "bug_locations": []
}
2025-10-17 09:41:40.929 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 09:41:40.930 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 09:42:00.159 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4650, output_tokens=754, cost=0.069120
2025-10-17 09:42:00.173 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 09:42:11.919 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5620, output_tokens=484, cost=0.070720
2025-10-17 09:42:11.928 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 09:42:17.608 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=838, output_tokens=124, cost=0.012100
2025-10-17 09:42:17.609 | DEBUG    | Extracted a valid json.
2025-10-17 09:42:17.610 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"write_table_html\")",
        "search_code(\"write('html'\")"
    ],
    "bug_locations": [
        {
            "file": "astropy/table/table.py",
            "class": "Table",
            "method": "write",
            "intended_behavior": "The method responsible for generating HTML output should be modified or ensured to adequately process the `formats` argument for each column. This involves ensuring that any specified formatting functions or rules are applied to the corresponding table column values before the HTML code is generated."
        }
    ]
}
2025-10-17 09:42:17.637 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 09:42:17.638 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 09:42:29.768 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6261, output_tokens=506, cost=0.077790
2025-10-17 09:42:29.779 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 09:42:40.645 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6983, output_tokens=401, cost=0.081860
2025-10-17 09:42:40.654 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 09:42:48.808 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=755, output_tokens=300, cost=0.016550
2025-10-17 09:42:48.810 | DEBUG    | Extracted a valid json.
2025-10-17 09:42:48.810 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"write\")", "search_code(\"HTML\")"],
    "bug_locations": [
        {
            "file": "astropy/table/table.py",
            "class": "Table",
            "method": "write",
            "intended_behavior": "The method responsible for rendering or serializing Astropy tables to HTML should interpret and apply the `formats` dictionary argument consistently with how it behaves in other formats (CSV, RST, etc.). It should iterate over each column that has a formatting specification within the `formats` argument, apply the specified formatting to each cell's value within that column, and then proceed to construct the HTML representation of the table. This behavior should be implemented in a way that does not disrupt existing functionalities or expected outputs when `formats` is not specified, thereby ensuring backward compatibility and maintaining user experience for those not leveraging the `formats` argument. Additional error handling or validation might be necessary to ensure that the formats specified are applicable or can be correctly applied within an HTML context. This might include, for example, ensuring that any lambda functions or format strings are viable when converting column values to strings. Detailed examination and potentially refactoring of how format specifications are disseminated and applied to output formats would be the likely next steps. Attention must also be paid to how these specific functionalities integrate within the broader framework of the Astropy `Table` class to ensure a cohesive and consistent user experience across all functionalities."
        }
    ]
}
2025-10-17 09:42:48.963 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 09:42:48.963 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 09:43:04.802 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8195, output_tokens=657, cost=0.101660
2025-10-17 09:43:04.809 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 09:43:17.605 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9068, output_tokens=518, cost=0.106220
2025-10-17 09:43:17.610 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 09:43:25.760 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=872, output_tokens=315, cost=0.018170
2025-10-17 09:43:25.761 | DEBUG    | Extracted a valid json.
2025-10-17 09:43:25.761 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "astropy/io/ascii/html.py",
            "class": "",
            "method": "write",
            "intended_behavior": "The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility."
        },
        {
            "file": "astropy/table/table.py",
            "class": "Table",
            "method": "",
            "intended_behavior": "Ensure that any method within the `Table` class that leads to HTML output generation (either directly or indirectly through utility methods or class instantiation) properly propagates the `formats` argument to the HTML writing logic. The precise adjustment needed may vary based on the method's current responsibilities and its role in HTML output generation. The goal is to provide a seamless and consistent interface for users, where specifying formats for table output produces the expected results regardless of the output format chosen."
        }
    ]
}
2025-10-17 09:43:25.785 | DEBUG    | Bug location extracted successfully: [<file>astropy/io/ascii/html.py</file>
<class>None</class>
<method>write</method>
<code>
40     def write(self, data):
41         self.out.append(data)

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/io/ascii/html.py</file>
<class>None</class>
<method>write</method>
<code>
342     def write(self, table):
343         """
344         Return data in ``table`` converted to HTML as a list of strings.
345         """
346         # Check that table has only 1-d or 2-d columns. Above that fails.
347         self._check_multidim_table(table)
348 
349         cols = list(table.columns.values())
350 
351         self.data.header.cols = cols
352 
353         if isinstance(self.data.fill_values, tuple):
354             self.data.fill_values = [self.data.fill_values]
355 
356         self.data._set_fill_values(cols)
357 
358         lines = []
359 
360         # Set HTML escaping to False for any column in the raw_html_cols input
361         raw_html_cols = self.html.get('raw_html_cols', [])
362         if isinstance(raw_html_cols, str):
363             raw_html_cols = [raw_html_cols]  # Allow for a single string as input
364         cols_escaped = [col.info.name not in raw_html_cols for col in cols]
365 
366         # Kwargs that get passed on to bleach.clean() if that is available.
367         raw_html_clean_kwargs = self.html.get('raw_html_clean_kwargs', {})
368 
369         # Use XMLWriter to output HTML to lines
370         w = writer.XMLWriter(ListWriter(lines))
371 
372         with w.tag('html'):
373             with w.tag('head'):
374                 # Declare encoding and set CSS style for table
375                 with w.tag('meta', attrib={'charset': 'utf-8'}):
376                     pass
377                 with w.tag('meta', attrib={'http-equiv': 'Content-type',
378                                            'content': 'text/html;charset=UTF-8'}):
379                     pass
380                 if 'css' in self.html:
381                     with w.tag('style'):
382                         w.data(self.html['css'])
383                 if 'cssfiles' in self.html:
384                     for filename in self.html['cssfiles']:
385                         with w.tag('link', rel="stylesheet", href=filename, type='text/css'):
386                             pass
387                 if 'jsfiles' in self.html:
388                     for filename in self.html['jsfiles']:
389                         with w.tag('script', src=filename):
390                             w.data('')  # need this instead of pass to get <script></script>
391             with w.tag('body'):
392                 if 'js' in self.html:
393                     with w.xml_cleaning_method('none'):
394                         with w.tag('script'):
395                             w.data(self.html['js'])
396                 if isinstance(self.html['table_id'], str):
397                     html_table_id = self.html['table_id']
398                 else:
399                     html_table_id = None
400                 if 'table_class' in self.html:
401                     html_table_class = self.html['table_class']
402                     attrib = {"class": html_table_class}
403                 else:
404                     attrib = {}
405                 with w.tag('table', id=html_table_id, attrib=attrib):
406                     with w.tag('thead'):
407                         with w.tag('tr'):
408                             for col in cols:
409                                 if len(col.shape) > 1 and self.html['multicol']:
410                                     # Set colspan attribute for multicolumns
411                                     w.start('th', colspan=col.shape[1])
412                                 else:
413                                     w.start('th')
414                                 w.data(col.info.name.strip())
415                                 w.end(indent=False)
416                         col_str_iters = []
417                         new_cols_escaped = []
418 
419                         # Make a container to hold any new_col objects created
420                         # below for multicolumn elements.  This is purely to
421                         # maintain a reference for these objects during
422                         # subsequent iteration to format column values.  This
423                         # requires that the weakref info._parent be maintained.
424                         new_cols = []
425 
426                         for col, col_escaped in zip(cols, cols_escaped):
427                             if len(col.shape) > 1 and self.html['multicol']:
428                                 span = col.shape[1]
429                                 for i in range(span):
430                                     # Split up multicolumns into separate columns
431                                     new_col = Column([el[i] for el in col])
432 
433                                     new_col_iter_str_vals = self.fill_values(
434                                         col, new_col.info.iter_str_vals())
435                                     col_str_iters.append(new_col_iter_str_vals)
436                                     new_cols_escaped.append(col_escaped)
437                                     new_cols.append(new_col)
438                             else:
439 
440                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())
441                                 col_str_iters.append(col_iter_str_vals)
442 
443                                 new_cols_escaped.append(col_escaped)
444 
445                     for row in zip(*col_str_iters):
446                         with w.tag('tr'):
447                             for el, col_escaped in zip(row, new_cols_escaped):
448                                 # Potentially disable HTML escaping for column
449                                 method = ('escape_xml' if col_escaped else 'bleach_clean')
450                                 with w.xml_cleaning_method(method, **raw_html_clean_kwargs):
451                                     w.start('td')
452                                     w.data(el.strip())
453                                     w.end(indent=False)
454 
455         # Fixes XMLWriter's insertion of unwanted line breaks
456         return [''.join(lines)]

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/io/ascii/html.py</file>
<class>ListWriter</class>
<method>write</method>
<code>
40     def write(self, data):
41         self.out.append(data)

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/io/ascii/html.py</file>
<class>HTML</class>
<method>write</method>
<code>
342     def write(self, table):
343         """
344         Return data in ``table`` converted to HTML as a list of strings.
345         """
346         # Check that table has only 1-d or 2-d columns. Above that fails.
347         self._check_multidim_table(table)
348 
349         cols = list(table.columns.values())
350 
351         self.data.header.cols = cols
352 
353         if isinstance(self.data.fill_values, tuple):
354             self.data.fill_values = [self.data.fill_values]
355 
356         self.data._set_fill_values(cols)
357 
358         lines = []
359 
360         # Set HTML escaping to False for any column in the raw_html_cols input
361         raw_html_cols = self.html.get('raw_html_cols', [])
362         if isinstance(raw_html_cols, str):
363             raw_html_cols = [raw_html_cols]  # Allow for a single string as input
364         cols_escaped = [col.info.name not in raw_html_cols for col in cols]
365 
366         # Kwargs that get passed on to bleach.clean() if that is available.
367         raw_html_clean_kwargs = self.html.get('raw_html_clean_kwargs', {})
368 
369         # Use XMLWriter to output HTML to lines
370         w = writer.XMLWriter(ListWriter(lines))
371 
372         with w.tag('html'):
373             with w.tag('head'):
374                 # Declare encoding and set CSS style for table
375                 with w.tag('meta', attrib={'charset': 'utf-8'}):
376                     pass
377                 with w.tag('meta', attrib={'http-equiv': 'Content-type',
378                                            'content': 'text/html;charset=UTF-8'}):
379                     pass
380                 if 'css' in self.html:
381                     with w.tag('style'):
382                         w.data(self.html['css'])
383                 if 'cssfiles' in self.html:
384                     for filename in self.html['cssfiles']:
385                         with w.tag('link', rel="stylesheet", href=filename, type='text/css'):
386                             pass
387                 if 'jsfiles' in self.html:
388                     for filename in self.html['jsfiles']:
389                         with w.tag('script', src=filename):
390                             w.data('')  # need this instead of pass to get <script></script>
391             with w.tag('body'):
392                 if 'js' in self.html:
393                     with w.xml_cleaning_method('none'):
394                         with w.tag('script'):
395                             w.data(self.html['js'])
396                 if isinstance(self.html['table_id'], str):
397                     html_table_id = self.html['table_id']
398                 else:
399                     html_table_id = None
400                 if 'table_class' in self.html:
401                     html_table_class = self.html['table_class']
402                     attrib = {"class": html_table_class}
403                 else:
404                     attrib = {}
405                 with w.tag('table', id=html_table_id, attrib=attrib):
406                     with w.tag('thead'):
407                         with w.tag('tr'):
408                             for col in cols:
409                                 if len(col.shape) > 1 and self.html['multicol']:
410                                     # Set colspan attribute for multicolumns
411                                     w.start('th', colspan=col.shape[1])
412                                 else:
413                                     w.start('th')
414                                 w.data(col.info.name.strip())
415                                 w.end(indent=False)
416                         col_str_iters = []
417                         new_cols_escaped = []
418 
419                         # Make a container to hold any new_col objects created
420                         # below for multicolumn elements.  This is purely to
421                         # maintain a reference for these objects during
422                         # subsequent iteration to format column values.  This
423                         # requires that the weakref info._parent be maintained.
424                         new_cols = []
425 
426                         for col, col_escaped in zip(cols, cols_escaped):
427                             if len(col.shape) > 1 and self.html['multicol']:
428                                 span = col.shape[1]
429                                 for i in range(span):
430                                     # Split up multicolumns into separate columns
431                                     new_col = Column([el[i] for el in col])
432 
433                                     new_col_iter_str_vals = self.fill_values(
434                                         col, new_col.info.iter_str_vals())
435                                     col_str_iters.append(new_col_iter_str_vals)
436                                     new_cols_escaped.append(col_escaped)
437                                     new_cols.append(new_col)
438                             else:
439 
440                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())
441                                 col_str_iters.append(col_iter_str_vals)
442 
443                                 new_cols_escaped.append(col_escaped)
444 
445                     for row in zip(*col_str_iters):
446                         with w.tag('tr'):
447                             for el, col_escaped in zip(row, new_cols_escaped):
448                                 # Potentially disable HTML escaping for column
449                                 method = ('escape_xml' if col_escaped else 'bleach_clean')
450                                 with w.xml_cleaning_method(method, **raw_html_clean_kwargs):
451                                     w.start('td')
452                                     w.data(el.strip())
453                                     w.end(indent=False)
454 
455         # Fixes XMLWriter's insertion of unwanted line breaks
456         return [''.join(lines)]

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/table/table.py</file>
<class>Table</class>
<method>None</method>
<code>
542 class Table:
543     """A class to represent tables of heterogeneous data.
544 
545     `~astropy.table.Table` provides a class for heterogeneous tabular data.
546     A key enhancement provided by the `~astropy.table.Table` class over
547     e.g. a `numpy` structured array is the ability to easily modify the
548     structure of the table by adding or removing columns, or adding new
549     rows of data.  In addition table and column metadata are fully supported.
550 
551     `~astropy.table.Table` differs from `~astropy.nddata.NDData` by the
552     assumption that the input data consists of columns of homogeneous data,
553     where each column has a unique identifier and may contain additional
554     metadata such as the data unit, format, and description.
555 
556     See also: https://docs.astropy.org/en/stable/table/
557 
558     Parameters
559     ----------
560     data : numpy ndarray, dict, list, table-like object, optional
561         Data to initialize table.
562     masked : bool, optional
563         Specify whether the table is masked.
564     names : list, optional
565         Specify column names.
566     dtype : list, optional
567         Specify column data types.
568     meta : dict, optional
569         Metadata associated with the table.
570     copy : bool, optional
571         Copy the input data. If the input is a Table the ``meta`` is always
572         copied regardless of the ``copy`` parameter.
573         Default is True.
574     rows : numpy ndarray, list of list, optional
575         Row-oriented data for table instead of ``data`` argument.
576     copy_indices : bool, optional
577         Copy any indices in the input data. Default is True.
578     units : list, dict, optional
579         List or dict of units to apply to columns.
580     descriptions : list, dict, optional
581         List or dict of descriptions to apply to columns.
582     **kwargs : dict, optional
583         Additional keyword args when converting table-like object.
584     """
585 
586     meta = MetaData(copy=False)
587 
588     # Define class attributes for core container objects to allow for subclass
589     # customization.
590     Row = Row
591     Column = Column
592     MaskedColumn = MaskedColumn
593     TableColumns = TableColumns
594     TableFormatter = TableFormatter
595 
596     # Unified I/O read and write methods from .connect
597     read = UnifiedReadWriteMethod(TableRead)
598     write = UnifiedReadWriteMethod(TableWrite)
599 
600     pprint_exclude_names = PprintIncludeExclude()
601     pprint_include_names = PprintIncludeExclude()
602 
603     def as_array(self, keep_byteorder=False, names=None):
604         """
605         Return a new copy of the table in the form of a structured np.ndarray or
606         np.ma.MaskedArray object (as appropriate).
607 
608         Parameters
609         ----------
610         keep_byteorder : bool, optional
611             By default the returned array has all columns in native byte
612             order.  However, if this option is `True` this preserves the
613             byte order of all columns (if any are non-native).
614 
615         names : list, optional:
616             List of column names to include for returned structured array.
617             Default is to include all table columns.
618 
619         Returns
620         -------
621         table_array : array or `~numpy.ma.MaskedArray`
622             Copy of table as a numpy structured array.
623             ndarray for unmasked or `~numpy.ma.MaskedArray` for masked.
624         """
625         masked = self.masked or self.has_masked_columns or self.has_masked_values
626         empty_init = ma.empty if masked else np.empty
627         if len(self.columns) == 0:
628             return empty_init(0, dtype=None)
629 
630         dtype = []
631 
632         cols = self.columns.values()
633 
634         if names is not None:
635             cols = [col for col in cols if col.info.name in names]
636 
637         for col in cols:
638             col_descr = descr(col)
639 
640             if not (col.info.dtype.isnative or keep_byteorder):
641                 new_dt = np.dtype(col_descr[1]).newbyteorder('=')
642                 col_descr = (col_descr[0], new_dt, col_descr[2])
643 
644             dtype.append(col_descr)
645 
646         data = empty_init(len(self), dtype=dtype)
647         for col in cols:
648             # When assigning from one array into a field of a structured array,
649             # Numpy will automatically swap those columns to their destination
650             # byte order where applicable
651             data[col.info.name] = col
652 
653             # For masked out, masked mixin columns need to set output mask attribute.
654             if masked and has_info_class(col, MixinInfo) and hasattr(col, 'mask'):
655                 data[col.info.name].mask = col.mask
656 
657         return data
658 
659     def __init__(self, data=None, masked=False, names=None, dtype=None,
660                  meta=None, copy=True, rows=None, copy_indices=True,
661                  units=None, descriptions=None,
662                  **kwargs):
663 
664         # Set up a placeholder empty table
665         self._set_masked(masked)
666         self.columns = self.TableColumns()
667         self.formatter = self.TableFormatter()
668         self._copy_indices = True  # copy indices from this Table by default
669         self._init_indices = copy_indices  # whether to copy indices in init
670         self.primary_key = None
671 
672         # Must copy if dtype are changing
673         if not copy and dtype is not None:
674             raise ValueError('Cannot specify dtype when copy=False')
675 
676         # Specifies list of names found for the case of initializing table with
677         # a list of dict. If data are not list of dict then this is None.
678         names_from_list_of_dict = None
679 
680         # Row-oriented input, e.g. list of lists or list of tuples, list of
681         # dict, Row instance.  Set data to something that the subsequent code
682         # will parse correctly.
683         if rows is not None:
684             if data is not None:
685                 raise ValueError('Cannot supply both `data` and `rows` values')
686             if isinstance(rows, types.GeneratorType):
687                 # Without this then the all(..) test below uses up the generator
688                 rows = list(rows)
689 
690             # Get column names if `rows` is a list of dict, otherwise this is None
691             names_from_list_of_dict = _get_names_from_list_of_dict(rows)
692             if names_from_list_of_dict:
693                 data = rows
694             elif isinstance(rows, self.Row):
695                 data = rows
696             else:
697                 data = list(zip(*rows))
698 
699         # Infer the type of the input data and set up the initialization
700         # function, number of columns, and potentially the default col names
701 
702         default_names = None
703 
704         # Handle custom (subclass) table attributes that are stored in meta.
705         # These are defined as class attributes using the TableAttribute
706         # descriptor.  Any such attributes get removed from kwargs here and
707         # stored for use after the table is otherwise initialized. Any values
708         # provided via kwargs will have precedence over existing values from
709         # meta (e.g. from data as a Table or meta via kwargs).
710         meta_table_attrs = {}
711         if kwargs:
712             for attr in list(kwargs):
713                 descr = getattr(self.__class__, attr, None)
714                 if isinstance(descr, TableAttribute):
715                     meta_table_attrs[attr] = kwargs.pop(attr)
716 
717         if hasattr(data, '__astropy_table__'):
718             # Data object implements the __astropy_table__ interface method.
719             # Calling that method returns an appropriate instance of
720             # self.__class__ and respects the `copy` arg.  The returned
721             # Table object should NOT then be copied.
722             data = data.__astropy_table__(self.__class__, copy, **kwargs)
723             copy = False
724         elif kwargs:
725             raise TypeError('__init__() got unexpected keyword argument {!r}'
726                             .format(list(kwargs.keys())[0]))
727 
728         if (isinstance(data, np.ndarray)
729                 and data.shape == (0,)
730                 and not data.dtype.names):
731             data = None
732 
733         if isinstance(data, self.Row):
734             data = data._table[data._index:data._index + 1]
735 
736         if isinstance(data, (list, tuple)):
737             # Get column names from `data` if it is a list of dict, otherwise this is None.
738             # This might be previously defined if `rows` was supplied as an init arg.
739             names_from_list_of_dict = (names_from_list_of_dict
740                                        or _get_names_from_list_of_dict(data))
741             if names_from_list_of_dict:
742                 init_func = self._init_from_list_of_dicts
743                 n_cols = len(names_from_list_of_dict)
744             else:
745                 init_func = self._init_from_list
746                 n_cols = len(data)
747 
748         elif isinstance(data, np.ndarray):
749             if data.dtype.names:
750                 init_func = self._init_from_ndarray  # _struct
751                 n_cols = len(data.dtype.names)
752                 default_names = data.dtype.names
753             else:
754                 init_func = self._init_from_ndarray  # _homog
755                 if data.shape == ():
756                     raise ValueError('Can not initialize a Table with a scalar')
757                 elif len(data.shape) == 1:
758                     data = data[np.newaxis, :]
759                 n_cols = data.shape[1]
760 
761         elif isinstance(data, Mapping):
762             init_func = self._init_from_dict
763             default_names = list(data)
764             n_cols = len(default_names)
765 
766         elif isinstance(data, Table):
767             # If user-input meta is None then use data.meta (if non-trivial)
768             if meta is None and data.meta:
769                 # At this point do NOT deepcopy data.meta as this will happen after
770                 # table init_func() is called.  But for table input the table meta
771                 # gets a key copy here if copy=False because later a direct object ref
772                 # is used.
773                 meta = data.meta if copy else data.meta.copy()
774 
775             # Handle indices on input table. Copy primary key and don't copy indices
776             # if the input Table is in non-copy mode.
777             self.primary_key = data.primary_key
778             self._init_indices = self._init_indices and data._copy_indices
779 
780             # Extract default names, n_cols, and then overwrite ``data`` to be the
781             # table columns so we can use _init_from_list.
782             default_names = data.colnames
783             n_cols = len(default_names)
784             data = list(data.columns.values())
785 
786             init_func = self._init_from_list
787 
788         elif data is None:
789             if names is None:
790                 if dtype is None:
791                     # Table was initialized as `t = Table()`. Set up for empty
792                     # table with names=[], data=[], and n_cols=0.
793                     # self._init_from_list() will simply return, giving the
794                     # expected empty table.
795                     names = []
796                 else:
797                     try:
798                         # No data nor names but dtype is available.  This must be
799                         # valid to initialize a structured array.
800                         dtype = np.dtype(dtype)
801                         names = dtype.names
802                         dtype = [dtype[name] for name in names]
803                     except Exception:
804                         raise ValueError('dtype was specified but could not be '
805                                          'parsed for column names')
806             # names is guaranteed to be set at this point
807             init_func = self._init_from_list
808             n_cols = len(names)
809             data = [[]] * n_cols
810 
811         else:
812             raise ValueError(f'Data type {type(data)} not allowed to init Table')
813 
814         # Set up defaults if names and/or dtype are not specified.
815         # A value of None means the actual value will be inferred
816         # within the appropriate initialization routine, either from
817         # existing specification or auto-generated.
818 
819         if dtype is None:
820             dtype = [None] * n_cols
821         elif isinstance(dtype, np.dtype):
822             if default_names is None:
823                 default_names = dtype.names
824             # Convert a numpy dtype input to a list of dtypes for later use.
825             dtype = [dtype[name] for name in dtype.names]
826 
827         if names is None:
828             names = default_names or [None] * n_cols
829 
830         names = [None if name is None else str(name) for name in names]
831 
832         self._check_names_dtype(names, dtype, n_cols)
833 
834         # Finally do the real initialization
835         init_func(data, names, dtype, n_cols, copy)
836 
837         # Set table meta.  If copy=True then deepcopy meta otherwise use the
838         # user-supplied meta directly.
839         if meta is not None:
840             self.meta = deepcopy(meta) if copy else meta
841 
842         # Update meta with TableAttributes supplied as kwargs in Table init.
843         # This takes precedence over previously-defined meta.
844         if meta_table_attrs:
845             for attr, value in meta_table_attrs.items():
846                 setattr(self, attr, value)
847 
848         # Whatever happens above, the masked property should be set to a boolean
849         if self.masked not in (None, True, False):
850             raise TypeError("masked property must be None, True or False")
851 
852         self._set_column_attribute('unit', units)
853         self._set_column_attribute('description', descriptions)
854 
855     def _set_column_attribute(self, attr, values):
856         """Set ``attr`` for columns to ``values``, which can be either a dict (keyed by column
857         name) or a dict of name: value pairs.  This is used for handling the ``units`` and
858         ``descriptions`` kwargs to ``__init__``.
859         """
860         if not values:
861             return
862 
863         if isinstance(values, Row):
864             # For a Row object transform to an equivalent dict.
865             values = {name: values[name] for name in values.colnames}
866 
867         if not isinstance(values, Mapping):
868             # If not a dict map, assume iterable and map to dict if the right length
869             if len(values) != len(self.columns):
870                 raise ValueError(f'sequence of {attr} values must match number of columns')
871             values = dict(zip(self.colnames, values))
872 
873         for name, value in values.items():
874             if name not in self.columns:
875                 raise ValueError(f'invalid column name {name} for setting {attr} attribute')
876 
877             # Special case: ignore unit if it is an empty or blank string
878             if attr == 'unit' and isinstance(value, str):
879                 if value.strip() == '':
880                     value = None
881 
882             if value not in (np.ma.masked, None):
883                 setattr(self[name].info, attr, value)
884 
885     def __getstate__(self):
886         columns = OrderedDict((key, col if isinstance(col, BaseColumn) else col_copy(col))
887                               for key, col in self.columns.items())
888         return (columns, self.meta)
889 
890     def __setstate__(self, state):
891         columns, meta = state
892         self.__init__(columns, meta=meta)
893 
894     @property
895     def mask(self):
896         # Dynamic view of available masks
897         if self.masked or self.has_masked_columns or self.has_masked_values:
898             mask_table = Table([getattr(col, 'mask', FalseArray(col.shape))
899                                 for col in self.itercols()],
900                                names=self.colnames, copy=False)
901 
902             # Set hidden attribute to force inplace setitem so that code like
903             # t.mask['a'] = [1, 0, 1] will correctly set the underlying mask.
904             # See #5556 for discussion.
905             mask_table._setitem_inplace = True
906         else:
907             mask_table = None
908 
909         return mask_table
910 
911     @mask.setter
912     def mask(self, val):
913         self.mask[:] = val
914 
915     @property
916     def _mask(self):
917         """This is needed so that comparison of a masked Table and a
918         MaskedArray works.  The requirement comes from numpy.ma.core
919         so don't remove this property."""
920         return self.as_array().mask
921 
922     def filled(self, fill_value=None):
923         """Return copy of self, with masked values filled.
924 
925         If input ``fill_value`` supplied then that value is used for all
926         masked entries in the table.  Otherwise the individual
927         ``fill_value`` defined for each table column is used.
928 
929         Parameters
930         ----------
931         fill_value : str
932             If supplied, this ``fill_value`` is used for all masked entries
933             in the entire table.
934 
935         Returns
936         -------
937         filled_table : `~astropy.table.Table`
938             New table with masked values filled
939         """
940         if self.masked or self.has_masked_columns or self.has_masked_values:
941             # Get new columns with masked values filled, then create Table with those
942             # new cols (copy=False) but deepcopy the meta.
943             data = [col.filled(fill_value) if hasattr(col, 'filled') else col
944                     for col in self.itercols()]
945             return self.__class__(data, meta=deepcopy(self.meta), copy=False)
946         else:
947             # Return copy of the original object.
948             return self.copy()
949 
950     @property
951     def indices(self):
952         '''
953         Return the indices associated with columns of the table
954         as a TableIndices object.
955         '''
956         lst = []
957         for column in self.columns.values():
958             for index in column.info.indices:
959                 if sum(index is x for x in lst) == 0:  # ensure uniqueness
960                     lst.append(index)
961         return TableIndices(lst)
962 
963     @property
964     def loc(self):
965         '''
966         Return a TableLoc object that can be used for retrieving
967         rows by index in a given data range. Note that both loc
968         and iloc work only with single-column indices.
969         '''
970         return TableLoc(self)
971 
972     @property
973     def loc_indices(self):
974         """
975         Return a TableLocIndices object that can be used for retrieving
976         the row indices corresponding to given table index key value or values.
977         """
978         return TableLocIndices(self)
979 
980     @property
981     def iloc(self):
982         '''
983         Return a TableILoc object that can be used for retrieving
984         indexed rows in the order they appear in the index.
985         '''
986         return TableILoc(self)
987 
988     def add_index(self, colnames, engine=None, unique=False):
989         '''
990         Insert a new index among one or more columns.
991         If there are no indices, make this index the
992         primary table index.
993 
994         Parameters
995         ----------
996         colnames : str or list
997             List of column names (or a single column name) to index
998         engine : type or None
999             Indexing engine class to use, either `~astropy.table.SortedArray`,
1000             `~astropy.table.BST`, or `~astropy.table.SCEngine`. If the supplied
1001             argument is None (by default), use `~astropy.table.SortedArray`.
1002         unique : bool
1003             Whether the values of the index must be unique. Default is False.
1004         '''
1005         if isinstance(colnames, str):
1006             colnames = (colnames,)
1007         columns = self.columns[tuple(colnames)].values()
1008 
1009         # make sure all columns support indexing
1010         for col in columns:
1011             if not getattr(col.info, '_supports_indexing', False):
1012                 raise ValueError('Cannot create an index on column "{}", of '
1013                                  'type "{}"'.format(col.info.name, type(col)))
1014 
1015         is_primary = not self.indices
1016         index = Index(columns, engine=engine, unique=unique)
1017         sliced_index = SlicedIndex(index, slice(0, 0, None), original=True)
1018         if is_primary:
1019             self.primary_key = colnames
1020         for col in columns:
1021             col.info.indices.append(sliced_index)
1022 
1023     def remove_indices(self, colname):
1024         '''
1025         Remove all indices involving the given column.
1026         If the primary index is removed, the new primary
1027         index will be the most recently added remaining
1028         index.
1029 
1030         Parameters
1031         ----------
1032         colname : str
1033             Name of column
1034         '''
1035         col = self.columns[colname]
1036         for index in self.indices:
1037             try:
1038                 index.col_position(col.info.name)
1039             except ValueError:
1040                 pass
1041             else:
1042                 for c in index.columns:
1043                     c.info.indices.remove(index)
1044 
1045     def index_mode(self, mode):
1046         '''
1047         Return a context manager for an indexing mode.
1048 
1049         Parameters
1050         ----------
1051         mode : str
1052             Either 'freeze', 'copy_on_getitem', or 'discard_on_copy'.
1053             In 'discard_on_copy' mode,
1054             indices are not copied whenever columns or tables are copied.
1055             In 'freeze' mode, indices are not modified whenever columns are
1056             modified; at the exit of the context, indices refresh themselves
1057             based on column values. This mode is intended for scenarios in
1058             which one intends to make many additions or modifications in an
1059             indexed column.
1060             In 'copy_on_getitem' mode, indices are copied when taking column
1061             slices as well as table slices, so col[i0:i1] will preserve
1062             indices.
1063         '''
1064         return _IndexModeContext(self, mode)
1065 
1066     def __array__(self, dtype=None):
1067         """Support converting Table to np.array via np.array(table).
1068 
1069         Coercion to a different dtype via np.array(table, dtype) is not
1070         supported and will raise a ValueError.
1071         """
1072         if dtype is not None:
1073             raise ValueError('Datatype coercion is not allowed')
1074 
1075         # This limitation is because of the following unexpected result that
1076         # should have made a table copy while changing the column names.
1077         #
1078         # >>> d = astropy.table.Table([[1,2],[3,4]])
1079         # >>> np.array(d, dtype=[('a', 'i8'), ('b', 'i8')])
1080         # array([(0, 0), (0, 0)],
1081         #       dtype=[('a', '<i8'), ('b', '<i8')])
1082 
1083         out = self.as_array()
1084         return out.data if isinstance(out, np.ma.MaskedArray) else out
1085 
1086     def _check_names_dtype(self, names, dtype, n_cols):
1087         """Make sure that names and dtype are both iterable and have
1088         the same length as data.
1089         """
1090         for inp_list, inp_str in ((dtype, 'dtype'), (names, 'names')):
1091             if not isiterable(inp_list):
1092                 raise ValueError(f'{inp_str} must be a list or None')
1093 
1094         if len(names) != n_cols or len(dtype) != n_cols:
1095             raise ValueError(
1096                 'Arguments "names" and "dtype" must match number of columns')
1097 
1098     def _init_from_list_of_dicts(self, data, names, dtype, n_cols, copy):
1099         """Initialize table from a list of dictionaries representing rows."""
1100         # Define placeholder for missing values as a unique object that cannot
1101         # every occur in user data.
1102         MISSING = object()
1103 
1104         # Gather column names that exist in the input `data`.
1105         names_from_data = set()
1106         for row in data:
1107             names_from_data.update(row)
1108 
1109         if set(data[0].keys()) == names_from_data:
1110             names_from_data = list(data[0].keys())
1111         else:
1112             names_from_data = sorted(names_from_data)
1113 
1114         # Note: if set(data[0].keys()) != names_from_data, this will give an
1115         # exception later, so NO need to catch here.
1116 
1117         # Convert list of dict into dict of list (cols), keep track of missing
1118         # indexes and put in MISSING placeholders in the `cols` lists.
1119         cols = {}
1120         missing_indexes = defaultdict(list)
1121         for name in names_from_data:
1122             cols[name] = []
1123             for ii, row in enumerate(data):
1124                 try:
1125                     val = row[name]
1126                 except KeyError:
1127                     missing_indexes[name].append(ii)
1128                     val = MISSING
1129                 cols[name].append(val)
1130 
1131         # Fill the missing entries with first values
1132         if missing_indexes:
1133             for name, indexes in missing_indexes.items():
1134                 col = cols[name]
1135                 first_val = next(val for val in col if val is not MISSING)
1136                 for index in indexes:
1137                     col[index] = first_val
1138 
1139         # prepare initialization
1140         if all(name is None for name in names):
1141             names = names_from_data
1142 
1143         self._init_from_dict(cols, names, dtype, n_cols, copy)
1144 
1145         # Mask the missing values if necessary, converting columns to MaskedColumn
1146         # as needed.
1147         if missing_indexes:
1148             for name, indexes in missing_indexes.items():
1149                 col = self[name]
1150                 # Ensure that any Column subclasses with MISSING values can support
1151                 # setting masked values. As of astropy 4.0 the test condition below is
1152                 # always True since _init_from_dict cannot result in mixin columns.
1153                 if isinstance(col, Column) and not isinstance(col, MaskedColumn):
1154                     self[name] = self.MaskedColumn(col, copy=False)
1155 
1156                 # Finally do the masking in a mixin-safe way.
1157                 self[name][indexes] = np.ma.masked
1158         return
1159 
1160     def _init_from_list(self, data, names, dtype, n_cols, copy):
1161         """Initialize table from a list of column data.  A column can be a
1162         Column object, np.ndarray, mixin, or any other iterable object.
1163         """
1164         # Special case of initializing an empty table like `t = Table()`. No
1165         # action required at this point.
1166         if n_cols == 0:
1167             return
1168 
1169         cols = []
1170         default_names = _auto_names(n_cols)
1171 
1172         for col, name, default_name, dtype in zip(data, names, default_names, dtype):
1173             col = self._convert_data_to_col(col, copy, default_name, dtype, name)
1174 
1175             cols.append(col)
1176 
1177         self._init_from_cols(cols)
1178 
1179     def _convert_data_to_col(self, data, copy=True, default_name=None, dtype=None, name=None):
1180         """
1181         Convert any allowed sequence data ``col`` to a column object that can be used
1182         directly in the self.columns dict.  This could be a Column, MaskedColumn,
1183         or mixin column.
1184 
1185         The final column name is determined by::
1186 
1187             name or data.info.name or def_name
1188 
1189         If ``data`` has no ``info`` then ``name = name or def_name``.
1190 
1191         The behavior of ``copy`` for Column objects is:
1192         - copy=True: new class instance with a copy of data and deep copy of meta
1193         - copy=False: new class instance with same data and a key-only copy of meta
1194 
1195         For mixin columns:
1196         - copy=True: new class instance with copy of data and deep copy of meta
1197         - copy=False: original instance (no copy at all)
1198 
1199         Parameters
1200         ----------
1201         data : object (column-like sequence)
1202             Input column data
1203         copy : bool
1204             Make a copy
1205         default_name : str
1206             Default name
1207         dtype : np.dtype or None
1208             Data dtype
1209         name : str or None
1210             Column name
1211 
1212         Returns
1213         -------
1214         col : Column, MaskedColumn, mixin-column type
1215             Object that can be used as a column in self
1216         """
1217 
1218         data_is_mixin = self._is_mixin_for_table(data)
1219         masked_col_cls = (self.ColumnClass
1220                           if issubclass(self.ColumnClass, self.MaskedColumn)
1221                           else self.MaskedColumn)
1222 
1223         try:
1224             data0_is_mixin = self._is_mixin_for_table(data[0])
1225         except Exception:
1226             # Need broad exception, cannot predict what data[0] raises for arbitrary data
1227             data0_is_mixin = False
1228 
1229         # If the data is not an instance of Column or a mixin class, we can
1230         # check the registry of mixin 'handlers' to see if the column can be
1231         # converted to a mixin class
1232         if (handler := get_mixin_handler(data)) is not None:
1233             original_data = data
1234             data = handler(data)
1235             if not (data_is_mixin := self._is_mixin_for_table(data)):
1236                 fully_qualified_name = (original_data.__class__.__module__ + '.'
1237                                         + original_data.__class__.__name__)
1238                 raise TypeError('Mixin handler for object of type '
1239                                 f'{fully_qualified_name} '
1240                                 'did not return a valid mixin column')
1241 
1242         # Get the final column name using precedence.  Some objects may not
1243         # have an info attribute. Also avoid creating info as a side effect.
1244         if not name:
1245             if isinstance(data, Column):
1246                 name = data.name or default_name
1247             elif 'info' in getattr(data, '__dict__', ()):
1248                 name = data.info.name or default_name
1249             else:
1250                 name = default_name
1251 
1252         if isinstance(data, Column):
1253             # If self.ColumnClass is a subclass of col, then "upgrade" to ColumnClass,
1254             # otherwise just use the original class.  The most common case is a
1255             # table with masked=True and ColumnClass=MaskedColumn.  Then a Column
1256             # gets upgraded to MaskedColumn, but the converse (pre-4.0) behavior
1257             # of downgrading from MaskedColumn to Column (for non-masked table)
1258             # does not happen.
1259             col_cls = self._get_col_cls_for_table(data)
1260 
1261         elif data_is_mixin:
1262             # Copy the mixin column attributes if they exist since the copy below
1263             # may not get this attribute.
1264             col = col_copy(data, copy_indices=self._init_indices) if copy else data
1265             col.info.name = name
1266             return col
1267 
1268         elif data0_is_mixin:
1269             # Handle case of a sequence of a mixin, e.g. [1*u.m, 2*u.m].
1270             try:
1271                 col = data[0].__class__(data)
1272                 col.info.name = name
1273                 return col
1274             except Exception:
1275                 # If that didn't work for some reason, just turn it into np.array of object
1276                 data = np.array(data, dtype=object)
1277                 col_cls = self.ColumnClass
1278 
1279         elif isinstance(data, (np.ma.MaskedArray, Masked)):
1280             # Require that col_cls be a subclass of MaskedColumn, remembering
1281             # that ColumnClass could be a user-defined subclass (though more-likely
1282             # could be MaskedColumn).
1283             col_cls = masked_col_cls
1284 
1285         elif data is None:
1286             # Special case for data passed as the None object (for broadcasting
1287             # to an object column). Need to turn data into numpy `None` scalar
1288             # object, otherwise `Column` interprets data=None as no data instead
1289             # of a object column of `None`.
1290             data = np.array(None)
1291             col_cls = self.ColumnClass
1292 
1293         elif not hasattr(data, 'dtype'):
1294             # `data` is none of the above, convert to numpy array or MaskedArray
1295             # assuming only that it is a scalar or sequence or N-d nested
1296             # sequence. This function is relatively intricate and tries to
1297             # maintain performance for common cases while handling things like
1298             # list input with embedded np.ma.masked entries. If `data` is a
1299             # scalar then it gets returned unchanged so the original object gets
1300             # passed to `Column` later.
1301             data = _convert_sequence_data_to_array(data, dtype)
1302             copy = False  # Already made a copy above
1303             col_cls = masked_col_cls if isinstance(data, np.ma.MaskedArray) else self.ColumnClass
1304 
1305         else:
1306             col_cls = self.ColumnClass
1307 
1308         try:
1309             col = col_cls(name=name, data=data, dtype=dtype,
1310                           copy=copy, copy_indices=self._init_indices)
1311         except Exception:
1312             # Broad exception class since we don't know what might go wrong
1313             raise ValueError('unable to convert data to Column for Table')
1314 
1315         col = self._convert_col_for_table(col)
1316 
1317         return col
1318 
1319     def _init_from_ndarray(self, data, names, dtype, n_cols, copy):
1320         """Initialize table from an ndarray structured array"""
1321 
1322         data_names = data.dtype.names or _auto_names(n_cols)
1323         struct = data.dtype.names is not None
1324         names = [name or data_names[i] for i, name in enumerate(names)]
1325 
1326         cols = ([data[name] for name in data_names] if struct else
1327                 [data[:, i] for i in range(n_cols)])
1328 
1329         self._init_from_list(cols, names, dtype, n_cols, copy)
1330 
1331     def _init_from_dict(self, data, names, dtype, n_cols, copy):
1332         """Initialize table from a dictionary of columns"""
1333 
1334         data_list = [data[name] for name in names]
1335         self._init_from_list(data_list, names, dtype, n_cols, copy)
1336 
1337     def _get_col_cls_for_table(self, col):
1338         """Get the correct column class to use for upgrading any Column-like object.
1339 
1340         For a masked table, ensure any Column-like object is a subclass
1341         of the table MaskedColumn.
1342 
1343         For unmasked table, ensure any MaskedColumn-like object is a subclass
1344         of the table MaskedColumn.  If not a MaskedColumn, then ensure that any
1345         Column-like object is a subclass of the table Column.
1346         """
1347 
1348         col_cls = col.__class__
1349 
1350         if self.masked:
1351             if isinstance(col, Column) and not isinstance(col, self.MaskedColumn):
1352                 col_cls = self.MaskedColumn
1353         else:
1354             if isinstance(col, MaskedColumn):
1355                 if not isinstance(col, self.MaskedColumn):
1356                     col_cls = self.MaskedColumn
1357             elif isinstance(col, Column) and not isinstance(col, self.Column):
1358                 col_cls = self.Column
1359 
1360         return col_cls
1361 
1362     def _convert_col_for_table(self, col):
1363         """
1364         Make sure that all Column objects have correct base class for this type of
1365         Table.  For a base Table this most commonly means setting to
1366         MaskedColumn if the table is masked.  Table subclasses like QTable
1367         override this method.
1368         """
1369         if isinstance(col, Column) and not isinstance(col, self.ColumnClass):
1370             col_cls = self._get_col_cls_for_table(col)
1371             if col_cls is not col.__class__:
1372                 col = col_cls(col, copy=False)
1373 
1374         return col
1375 
1376     def _init_from_cols(self, cols):
1377         """Initialize table from a list of Column or mixin objects"""
1378 
1379         lengths = {len(col) for col in cols}
1380         if len(lengths) > 1:
1381             raise ValueError(f'Inconsistent data column lengths: {lengths}')
1382 
1383         # Make sure that all Column-based objects have correct class.  For
1384         # plain Table this is self.ColumnClass, but for instance QTable will
1385         # convert columns with units to a Quantity mixin.
1386         newcols = [self._convert_col_for_table(col) for col in cols]
1387         self._make_table_from_cols(self, newcols)
1388 
1389         # Deduplicate indices.  It may happen that after pickling or when
1390         # initing from an existing table that column indices which had been
1391         # references to a single index object got *copied* into an independent
1392         # object.  This results in duplicates which will cause downstream problems.
1393         index_dict = {}
1394         for col in self.itercols():
1395             for i, index in enumerate(col.info.indices or []):
1396                 names = tuple(ind_col.info.name for ind_col in index.columns)
1397                 if names in index_dict:
1398                     col.info.indices[i] = index_dict[names]
1399                 else:
1400                     index_dict[names] = index
1401 
1402     def _new_from_slice(self, slice_):
1403         """Create a new table as a referenced slice from self."""
1404 
1405         table = self.__class__(masked=self.masked)
1406         if self.meta:
1407             table.meta = self.meta.copy()  # Shallow copy for slice
1408         table.primary_key = self.primary_key
1409 
1410         newcols = []
1411         for col in self.columns.values():
1412             newcol = col[slice_]
1413 
1414             # Note in line below, use direct attribute access to col.indices for Column
1415             # instances instead of the generic col.info.indices.  This saves about 4 usec
1416             # per column.
1417             if (col if isinstance(col, Column) else col.info).indices:
1418                 # TODO : as far as I can tell the only purpose of setting _copy_indices
1419                 # here is to communicate that to the initial test in `slice_indices`.
1420                 # Why isn't that just sent as an arg to the function?
1421                 col.info._copy_indices = self._copy_indices
1422                 newcol = col.info.slice_indices(newcol, slice_, len(col))
1423 
1424                 # Don't understand why this is forcing a value on the original column.
1425                 # Normally col.info does not even have a _copy_indices attribute.  Tests
1426                 # still pass if this line is deleted.  (Each col.info attribute access
1427                 # is expensive).
1428                 col.info._copy_indices = True
1429 
1430             newcols.append(newcol)
1431 
1432         self._make_table_from_cols(table, newcols, verify=False, names=self.columns.keys())
1433         return table
1434 
1435     @staticmethod
1436     def _make_table_from_cols(table, cols, verify=True, names=None):
1437         """
1438         Make ``table`` in-place so that it represents the given list of ``cols``.
1439         """
1440         if names is None:
1441             names = [col.info.name for col in cols]
1442 
1443         # Note: we do not test for len(names) == len(cols) if names is not None.  In that
1444         # case the function is being called by from "trusted" source (e.g. right above here)
1445         # that is assumed to provide valid inputs.  In that case verify=False.
1446 
1447         if verify:
1448             if None in names:
1449                 raise TypeError('Cannot have None for column name')
1450             if len(set(names)) != len(names):
1451                 raise ValueError('Duplicate column names')
1452 
1453         table.columns = table.TableColumns((name, col) for name, col in zip(names, cols))
1454 
1455         for col in cols:
1456             table._set_col_parent_table_and_mask(col)
1457 
1458     def _set_col_parent_table_and_mask(self, col):
1459         """
1460         Set ``col.parent_table = self`` and force ``col`` to have ``mask``
1461         attribute if the table is masked and ``col.mask`` does not exist.
1462         """
1463         # For Column instances it is much faster to do direct attribute access
1464         # instead of going through .info
1465         col_info = col if isinstance(col, Column) else col.info
1466         col_info.parent_table = self
1467 
1468         # Legacy behavior for masked table
1469         if self.masked and not hasattr(col, 'mask'):
1470             col.mask = FalseArray(col.shape)
1471 
1472     def itercols(self):
1473         """
1474         Iterate over the columns of this table.
1475 
1476         Examples
1477         --------
1478 
1479         To iterate over the columns of a table::
1480 
1481             >>> t = Table([[1], [2]])
1482             >>> for col in t.itercols():
1483             ...     print(col)
1484             col0
1485             ----
1486                1
1487             col1
1488             ----
1489                2
1490 
1491         Using ``itercols()`` is similar to  ``for col in t.columns.values()``
1492         but is syntactically preferred.
1493         """
1494         for colname in self.columns:
1495             yield self[colname]
1496 
1497     def _base_repr_(self, html=False, descr_vals=None, max_width=None,
1498                     tableid=None, show_dtype=True, max_lines=None,
1499                     tableclass=None):
1500         if descr_vals is None:
1501             descr_vals = [self.__class__.__name__]
1502             if self.masked:
1503                 descr_vals.append('masked=True')
1504             descr_vals.append(f'length={len(self)}')
1505 
1506         descr = ' '.join(descr_vals)
1507         if html:
1508             from astropy.utils.xml.writer import xml_escape
1509             descr = f'<i>{xml_escape(descr)}</i>\n'
1510         else:
1511             descr = f'<{descr}>\n'
1512 
1513         if tableid is None:
1514             tableid = f'table{id(self)}'
1515 
1516         data_lines, outs = self.formatter._pformat_table(
1517             self, tableid=tableid, html=html, max_width=max_width,
1518             show_name=True, show_unit=None, show_dtype=show_dtype,
1519             max_lines=max_lines, tableclass=tableclass)
1520 
1521         out = descr + '\n'.join(data_lines)
1522 
1523         return out
1524 
1525     def _repr_html_(self):
1526         out = self._base_repr_(html=True, max_width=-1,
1527                                tableclass=conf.default_notebook_table_class)
1528         # Wrap <table> in <div>. This follows the pattern in pandas and allows
1529         # table to be scrollable horizontally in VS Code notebook display.
1530         out = f'<div>{out}</div>'
1531         return out
1532 
1533     def __repr__(self):
1534         return self._base_repr_(html=False, max_width=None)
1535 
1536     def __str__(self):
1537         return '\n'.join(self.pformat())
1538 
1539     def __bytes__(self):
1540         return str(self).encode('utf-8')
1541 
1542     @property
1543     def has_mixin_columns(self):
1544         """
1545         True if table has any mixin columns (defined as columns that are not Column
1546         subclasses).
1547         """
1548         return any(has_info_class(col, MixinInfo) for col in self.columns.values())
1549 
1550     @property
1551     def has_masked_columns(self):
1552         """True if table has any ``MaskedColumn`` columns.
1553 
1554         This does not check for mixin columns that may have masked values, use the
1555         ``has_masked_values`` property in that case.
1556 
1557         """
1558         return any(isinstance(col, MaskedColumn) for col in self.itercols())
1559 
1560     @property
1561     def has_masked_values(self):
1562         """True if column in the table has values which are masked.
1563 
1564         This may be relatively slow for large tables as it requires checking the mask
1565         values of each column.
1566         """
1567         for col in self.itercols():
1568             if hasattr(col, 'mask') and np.any(col.mask):
1569                 return True
1570         else:
1571             return False
1572 
1573     def _is_mixin_for_table(self, col):
1574         """
1575         Determine if ``col`` should be added to the table directly as
1576         a mixin column.
1577         """
1578         if isinstance(col, BaseColumn):
1579             return False
1580 
1581         # Is it a mixin but not [Masked]Quantity (which gets converted to
1582         # [Masked]Column with unit set).
1583         return has_info_class(col, MixinInfo) and not has_info_class(col, QuantityInfo)
1584 
1585     @format_doc(_pprint_docs)
1586     def pprint(self, max_lines=None, max_width=None, show_name=True,
1587                show_unit=None, show_dtype=False, align=None):
1588         """Print a formatted string representation of the table.
1589 
1590         If no value of ``max_lines`` is supplied then the height of the
1591         screen terminal is used to set ``max_lines``.  If the terminal
1592         height cannot be determined then the default is taken from the
1593         configuration item ``astropy.conf.max_lines``.  If a negative
1594         value of ``max_lines`` is supplied then there is no line limit
1595         applied.
1596 
1597         The same applies for max_width except the configuration item is
1598         ``astropy.conf.max_width``.
1599 
1600         """
1601         lines, outs = self.formatter._pformat_table(self, max_lines, max_width,
1602                                                     show_name=show_name, show_unit=show_unit,
1603                                                     show_dtype=show_dtype, align=align)
1604         if outs['show_length']:
1605             lines.append(f'Length = {len(self)} rows')
1606 
1607         n_header = outs['n_header']
1608 
1609         for i, line in enumerate(lines):
1610             if i < n_header:
1611                 color_print(line, 'red')
1612             else:
1613                 print(line)
1614 
1615     @format_doc(_pprint_docs)
1616     def pprint_all(self, max_lines=-1, max_width=-1, show_name=True,
1617                    show_unit=None, show_dtype=False, align=None):
1618         """Print a formatted string representation of the entire table.
1619 
1620         This method is the same as `astropy.table.Table.pprint` except that
1621         the default ``max_lines`` and ``max_width`` are both -1 so that by
1622         default the entire table is printed instead of restricting to the size
1623         of the screen terminal.
1624 
1625         """
1626         return self.pprint(max_lines, max_width, show_name,
1627                            show_unit, show_dtype, align)
1628 
1629     def _make_index_row_display_table(self, index_row_name):
1630         if index_row_name not in self.columns:
1631             idx_col = self.ColumnClass(name=index_row_name, data=np.arange(len(self)))
1632             return self.__class__([idx_col] + list(self.columns.values()),
1633                                   copy=False)
1634         else:
1635             return self
1636 
1637     def show_in_notebook(self, tableid=None, css=None, display_length=50,
1638                          table_class='astropy-default', show_row_index='idx'):
1639         """Render the table in HTML and show it in the IPython notebook.
1640 
1641         Parameters
1642         ----------
1643         tableid : str or None
1644             An html ID tag for the table.  Default is ``table{id}-XXX``, where
1645             id is the unique integer id of the table object, id(self), and XXX
1646             is a random number to avoid conflicts when printing the same table
1647             multiple times.
1648         table_class : str or None
1649             A string with a list of HTML classes used to style the table.
1650             The special default string ('astropy-default') means that the string
1651             will be retrieved from the configuration item
1652             ``astropy.table.default_notebook_table_class``. Note that these
1653             table classes may make use of bootstrap, as this is loaded with the
1654             notebook.  See `this page <https://getbootstrap.com/css/#tables>`_
1655             for the list of classes.
1656         css : str
1657             A valid CSS string declaring the formatting for the table. Defaults
1658             to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.
1659         display_length : int, optional
1660             Number or rows to show. Defaults to 50.
1661         show_row_index : str or False
1662             If this does not evaluate to False, a column with the given name
1663             will be added to the version of the table that gets displayed.
1664             This new column shows the index of the row in the table itself,
1665             even when the displayed table is re-sorted by another column. Note
1666             that if a column with this name already exists, this option will be
1667             ignored. Defaults to "idx".
1668 
1669         Notes
1670         -----
1671         Currently, unlike `show_in_browser` (with ``jsviewer=True``), this
1672         method needs to access online javascript code repositories.  This is due
1673         to modern browsers' limitations on accessing local files.  Hence, if you
1674         call this method while offline (and don't have a cached version of
1675         jquery and jquery.dataTables), you will not get the jsviewer features.
1676         """
1677 
1678         from .jsviewer import JSViewer
1679         from IPython.display import HTML
1680 
1681         if tableid is None:
1682             tableid = f'table{id(self)}-{np.random.randint(1, 1e6)}'
1683 
1684         jsv = JSViewer(display_length=display_length)
1685         if show_row_index:
1686             display_table = self._make_index_row_display_table(show_row_index)
1687         else:
1688             display_table = self
1689         if table_class == 'astropy-default':
1690             table_class = conf.default_notebook_table_class
1691         html = display_table._base_repr_(html=True, max_width=-1, tableid=tableid,
1692                                          max_lines=-1, show_dtype=False,
1693                                          tableclass=table_class)
1694 
1695         columns = display_table.columns.values()
1696         sortable_columns = [i for i, col in enumerate(columns)
1697                             if col.info.dtype.kind in 'iufc']
1698         html += jsv.ipynb(tableid, css=css, sort_columns=sortable_columns)
1699         return HTML(html)
1700 
1701     def show_in_browser(self, max_lines=5000, jsviewer=False,
1702                         browser='default', jskwargs={'use_local_files': True},
1703                         tableid=None, table_class="display compact",
1704                         css=None, show_row_index='idx'):
1705         """Render the table in HTML and show it in a web browser.
1706 
1707         Parameters
1708         ----------
1709         max_lines : int
1710             Maximum number of rows to export to the table (set low by default
1711             to avoid memory issues, since the browser view requires duplicating
1712             the table in memory).  A negative value of ``max_lines`` indicates
1713             no row limit.
1714         jsviewer : bool
1715             If `True`, prepends some javascript headers so that the table is
1716             rendered as a `DataTables <https://datatables.net>`_ data table.
1717             This allows in-browser searching & sorting.
1718         browser : str
1719             Any legal browser name, e.g. ``'firefox'``, ``'chrome'``,
1720             ``'safari'`` (for mac, you may need to use ``'open -a
1721             "/Applications/Google Chrome.app" {}'`` for Chrome).  If
1722             ``'default'``, will use the system default browser.
1723         jskwargs : dict
1724             Passed to the `astropy.table.JSViewer` init. Defaults to
1725             ``{'use_local_files': True}`` which means that the JavaScript
1726             libraries will be served from local copies.
1727         tableid : str or None
1728             An html ID tag for the table.  Default is ``table{id}``, where id
1729             is the unique integer id of the table object, id(self).
1730         table_class : str or None
1731             A string with a list of HTML classes used to style the table.
1732             Default is "display compact", and other possible values can be
1733             found in https://www.datatables.net/manual/styling/classes
1734         css : str
1735             A valid CSS string declaring the formatting for the table. Defaults
1736             to ``astropy.table.jsviewer.DEFAULT_CSS``.
1737         show_row_index : str or False
1738             If this does not evaluate to False, a column with the given name
1739             will be added to the version of the table that gets displayed.
1740             This new column shows the index of the row in the table itself,
1741             even when the displayed table is re-sorted by another column. Note
1742             that if a column with this name already exists, this option will be
1743             ignored. Defaults to "idx".
1744         """
1745 
1746         import os
1747         import webbrowser
1748         import tempfile
1749         from .jsviewer import DEFAULT_CSS
1750         from urllib.parse import urljoin
1751         from urllib.request import pathname2url
1752 
1753         if css is None:
1754             css = DEFAULT_CSS
1755 
1756         # We can't use NamedTemporaryFile here because it gets deleted as
1757         # soon as it gets garbage collected.
1758         tmpdir = tempfile.mkdtemp()
1759         path = os.path.join(tmpdir, 'table.html')
1760 
1761         with open(path, 'w') as tmp:
1762             if jsviewer:
1763                 if show_row_index:
1764                     display_table = self._make_index_row_display_table(show_row_index)
1765                 else:
1766                     display_table = self
1767                 display_table.write(tmp, format='jsviewer', css=css,
1768                                     max_lines=max_lines, jskwargs=jskwargs,
1769                                     table_id=tableid, table_class=table_class)
1770             else:
1771                 self.write(tmp, format='html')
1772 
1773         try:
1774             br = webbrowser.get(None if browser == 'default' else browser)
1775         except webbrowser.Error:
1776             log.error(f"Browser '{browser}' not found.")
1777         else:
1778             br.open(urljoin('file:', pathname2url(path)))
1779 
1780     @format_doc(_pformat_docs, id="{id}")
1781     def pformat(self, max_lines=None, max_width=None, show_name=True,
1782                 show_unit=None, show_dtype=False, html=False, tableid=None,
1783                 align=None, tableclass=None):
1784         """Return a list of lines for the formatted string representation of
1785         the table.
1786 
1787         If no value of ``max_lines`` is supplied then the height of the
1788         screen terminal is used to set ``max_lines``.  If the terminal
1789         height cannot be determined then the default is taken from the
1790         configuration item ``astropy.conf.max_lines``.  If a negative
1791         value of ``max_lines`` is supplied then there is no line limit
1792         applied.
1793 
1794         The same applies for ``max_width`` except the configuration item  is
1795         ``astropy.conf.max_width``.
1796 
1797         """
1798 
1799         lines, outs = self.formatter._pformat_table(
1800             self, max_lines, max_width, show_name=show_name,
1801             show_unit=show_unit, show_dtype=show_dtype, html=html,
1802             tableid=tableid, tableclass=tableclass, align=align)
1803 
1804         if outs['show_length']:
1805             lines.append(f'Length = {len(self)} rows')
1806 
1807         return lines
1808 
1809     @format_doc(_pformat_docs, id="{id}")
1810     def pformat_all(self, max_lines=-1, max_width=-1, show_name=True,
1811                     show_unit=None, show_dtype=False, html=False, tableid=None,
1812                     align=None, tableclass=None):
1813         """Return a list of lines for the formatted string representation of
1814         the entire table.
1815 
1816         If no value of ``max_lines`` is supplied then the height of the
1817         screen terminal is used to set ``max_lines``.  If the terminal
1818         height cannot be determined then the default is taken from the
1819         configuration item ``astropy.conf.max_lines``.  If a negative
1820         value of ``max_lines`` is supplied then there is no line limit
1821         applied.
1822 
1823         The same applies for ``max_width`` except the configuration item  is
1824         ``astropy.conf.max_width``.
1825 
1826         """
1827 
1828         return self.pformat(max_lines, max_width, show_name,
1829                             show_unit, show_dtype, html, tableid,
1830                             align, tableclass)
1831 
1832     def more(self, max_lines=None, max_width=None, show_name=True,
1833              show_unit=None, show_dtype=False):
1834         """Interactively browse table with a paging interface.
1835 
1836         Supported keys::
1837 
1838           f, <space> : forward one page
1839           b : back one page
1840           r : refresh same page
1841           n : next row
1842           p : previous row
1843           < : go to beginning
1844           > : go to end
1845           q : quit browsing
1846           h : print this help
1847 
1848         Parameters
1849         ----------
1850         max_lines : int
1851             Maximum number of lines in table output
1852 
1853         max_width : int or None
1854             Maximum character width of output
1855 
1856         show_name : bool
1857             Include a header row for column names. Default is True.
1858 
1859         show_unit : bool
1860             Include a header row for unit.  Default is to show a row
1861             for units only if one or more columns has a defined value
1862             for the unit.
1863 
1864         show_dtype : bool
1865             Include a header row for column dtypes. Default is False.
1866         """
1867         self.formatter._more_tabcol(self, max_lines, max_width, show_name=show_name,
1868                                     show_unit=show_unit, show_dtype=show_dtype)
1869 
1870     def __getitem__(self, item):
1871         if isinstance(item, str):
1872             return self.columns[item]
1873         elif isinstance(item, (int, np.integer)):
1874             return self.Row(self, item)
1875         elif (isinstance(item, np.ndarray) and item.shape == () and item.dtype.kind == 'i'):
1876             return self.Row(self, item.item())
1877         elif self._is_list_or_tuple_of_str(item):
1878             out = self.__class__([self[x] for x in item],
1879                                  copy_indices=self._copy_indices)
1880             out._groups = groups.TableGroups(out, indices=self.groups._indices,
1881                                              keys=self.groups._keys)
1882             out.meta = self.meta.copy()  # Shallow copy for meta
1883             return out
1884         elif ((isinstance(item, np.ndarray) and item.size == 0)
1885               or (isinstance(item, (tuple, list)) and not item)):
1886             # If item is an empty array/list/tuple then return the table with no rows
1887             return self._new_from_slice([])
1888         elif (isinstance(item, slice)
1889               or isinstance(item, np.ndarray)
1890               or isinstance(item, list)
1891               or isinstance(item, tuple) and all(isinstance(x, np.ndarray)
1892                                                  for x in item)):
1893             # here for the many ways to give a slice; a tuple of ndarray
1894             # is produced by np.where, as in t[np.where(t['a'] > 2)]
1895             # For all, a new table is constructed with slice of all columns
1896             return self._new_from_slice(item)
1897         else:
1898             raise ValueError(f'Illegal type {type(item)} for table item access')
1899 
1900     def __setitem__(self, item, value):
1901         # If the item is a string then it must be the name of a column.
1902         # If that column doesn't already exist then create it now.
1903         if isinstance(item, str) and item not in self.colnames:
1904             self.add_column(value, name=item, copy=True)
1905 
1906         else:
1907             n_cols = len(self.columns)
1908 
1909             if isinstance(item, str):
1910                 # Set an existing column by first trying to replace, and if
1911                 # this fails do an in-place update.  See definition of mask
1912                 # property for discussion of the _setitem_inplace attribute.
1913                 if (not getattr(self, '_setitem_inplace', False)
1914                         and not conf.replace_inplace):
1915                     try:
1916                         self._replace_column_warnings(item, value)
1917                         return
1918                     except Exception:
1919                         pass
1920                 self.columns[item][:] = value
1921 
1922             elif isinstance(item, (int, np.integer)):
1923                 self._set_row(idx=item, colnames=self.colnames, vals=value)
1924 
1925             elif (isinstance(item, slice)
1926                   or isinstance(item, np.ndarray)
1927                   or isinstance(item, list)
1928                   or (isinstance(item, tuple)  # output from np.where
1929                       and all(isinstance(x, np.ndarray) for x in item))):
1930 
1931                 if isinstance(value, Table):
1932                     vals = (col for col in value.columns.values())
1933 
1934                 elif isinstance(value, np.ndarray) and value.dtype.names:
1935                     vals = (value[name] for name in value.dtype.names)
1936 
1937                 elif np.isscalar(value):
1938                     vals = itertools.repeat(value, n_cols)
1939 
1940                 else:  # Assume this is an iterable that will work
1941                     if len(value) != n_cols:
1942                         raise ValueError('Right side value needs {} elements (one for each column)'
1943                                          .format(n_cols))
1944                     vals = value
1945 
1946                 for col, val in zip(self.columns.values(), vals):
1947                     col[item] = val
1948 
1949             else:
1950                 raise ValueError(f'Illegal type {type(item)} for table item access')
1951 
1952     def __delitem__(self, item):
1953         if isinstance(item, str):
1954             self.remove_column(item)
1955         elif isinstance(item, (int, np.integer)):
1956             self.remove_row(item)
1957         elif (isinstance(item, (list, tuple, np.ndarray))
1958               and all(isinstance(x, str) for x in item)):
1959             self.remove_columns(item)
1960         elif (isinstance(item, (list, np.ndarray))
1961               and np.asarray(item).dtype.kind == 'i'):
1962             self.remove_rows(item)
1963         elif isinstance(item, slice):
1964             self.remove_rows(item)
1965         else:
1966             raise IndexError('illegal key or index value')
1967 
1968     def _ipython_key_completions_(self):
1969         return self.colnames
1970 
1971     def field(self, item):
1972         """Return column[item] for recarray compatibility."""
1973         return self.columns[item]
1974 
1975     @property
1976     def masked(self):
1977         return self._masked
1978 
1979     @masked.setter
1980     def masked(self, masked):
1981         raise Exception('Masked attribute is read-only (use t = Table(t, masked=True)'
1982                         ' to convert to a masked table)')
1983 
1984     def _set_masked(self, masked):
1985         """
1986         Set the table masked property.
1987 
1988         Parameters
1989         ----------
1990         masked : bool
1991             State of table masking (`True` or `False`)
1992         """
1993         if masked in [True, False, None]:
1994             self._masked = masked
1995         else:
1996             raise ValueError("masked should be one of True, False, None")
1997 
1998         self._column_class = self.MaskedColumn if self._masked else self.Column
1999 
2000     @property
2001     def ColumnClass(self):
2002         if self._column_class is None:
2003             return self.Column
2004         else:
2005             return self._column_class
2006 
2007     @property
2008     def dtype(self):
2009         return np.dtype([descr(col) for col in self.columns.values()])
2010 
2011     @property
2012     def colnames(self):
2013         return list(self.columns.keys())
2014 
2015     @staticmethod
2016     def _is_list_or_tuple_of_str(names):
2017         """Check that ``names`` is a tuple or list of strings"""
2018         return (isinstance(names, (tuple, list)) and names
2019                 and all(isinstance(x, str) for x in names))
2020 
2021     def keys(self):
2022         return list(self.columns.keys())
2023 
2024     def values(self):
2025         return self.columns.values()
2026 
2027     def items(self):
2028         return self.columns.items()
2029 
2030     def __len__(self):
2031         # For performance reasons (esp. in Row) cache the first column name
2032         # and use that subsequently for the table length.  If might not be
2033         # available yet or the column might be gone now, in which case
2034         # try again in the except block.
2035         try:
2036             return len(OrderedDict.__getitem__(self.columns, self._first_colname))
2037         except (AttributeError, KeyError):
2038             if len(self.columns) == 0:
2039                 return 0
2040 
2041             # Get the first column name
2042             self._first_colname = next(iter(self.columns))
2043             return len(self.columns[self._first_colname])
2044 
2045     def index_column(self, name):
2046         """
2047         Return the positional index of column ``name``.
2048 
2049         Parameters
2050         ----------
2051         name : str
2052             column name
2053 
2054         Returns
2055         -------
2056         index : int
2057             Positional index of column ``name``.
2058 
2059         Examples
2060         --------
2061         Create a table with three columns 'a', 'b' and 'c'::
2062 
2063             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2064             ...           names=('a', 'b', 'c'))
2065             >>> print(t)
2066              a   b   c
2067             --- --- ---
2068               1 0.1   x
2069               2 0.2   y
2070               3 0.3   z
2071 
2072         Get index of column 'b' of the table::
2073 
2074             >>> t.index_column('b')
2075             1
2076         """
2077         try:
2078             return self.colnames.index(name)
2079         except ValueError:
2080             raise ValueError(f"Column {name} does not exist")
2081 
2082     def add_column(self, col, index=None, name=None, rename_duplicate=False, copy=True,
2083                    default_name=None):
2084         """
2085         Add a new column to the table using ``col`` as input.  If ``index``
2086         is supplied then insert column before ``index`` position
2087         in the list of columns, otherwise append column to the end
2088         of the list.
2089 
2090         The ``col`` input can be any data object which is acceptable as a
2091         `~astropy.table.Table` column object or can be converted.  This includes
2092         mixin columns and scalar or length=1 objects which get broadcast to match
2093         the table length.
2094 
2095         To add several columns at once use ``add_columns()`` or simply call
2096         ``add_column()`` for each one.  There is very little performance difference
2097         in the two approaches.
2098 
2099         Parameters
2100         ----------
2101         col : object
2102             Data object for the new column
2103         index : int or None
2104             Insert column before this position or at end (default).
2105         name : str
2106             Column name
2107         rename_duplicate : bool
2108             Uniquify column name if it already exist. Default is False.
2109         copy : bool
2110             Make a copy of the new column. Default is True.
2111         default_name : str or None
2112             Name to use if both ``name`` and ``col.info.name`` are not available.
2113             Defaults to ``col{number_of_columns}``.
2114 
2115         Examples
2116         --------
2117         Create a table with two columns 'a' and 'b', then create a third column 'c'
2118         and append it to the end of the table::
2119 
2120             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2121             >>> col_c = Column(name='c', data=['x', 'y'])
2122             >>> t.add_column(col_c)
2123             >>> print(t)
2124              a   b   c
2125             --- --- ---
2126               1 0.1   x
2127               2 0.2   y
2128 
2129         Add column 'd' at position 1. Note that the column is inserted
2130         before the given index::
2131 
2132             >>> t.add_column(['a', 'b'], name='d', index=1)
2133             >>> print(t)
2134              a   d   b   c
2135             --- --- --- ---
2136               1   a 0.1   x
2137               2   b 0.2   y
2138 
2139         Add second column named 'b' with rename_duplicate::
2140 
2141             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2142             >>> t.add_column(1.1, name='b', rename_duplicate=True)
2143             >>> print(t)
2144              a   b  b_1
2145             --- --- ---
2146               1 0.1 1.1
2147               2 0.2 1.1
2148 
2149         Add an unnamed column or mixin object in the table using a default name
2150         or by specifying an explicit name with ``name``. Name can also be overridden::
2151 
2152             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2153             >>> t.add_column(['a', 'b'])
2154             >>> t.add_column(col_c, name='d')
2155             >>> print(t)
2156              a   b  col2  d
2157             --- --- ---- ---
2158               1 0.1    a   x
2159               2 0.2    b   y
2160         """
2161         if default_name is None:
2162             default_name = f'col{len(self.columns)}'
2163 
2164         # Convert col data to acceptable object for insertion into self.columns.
2165         # Note that along with the lines above and below, this allows broadcasting
2166         # of scalars to the correct shape for adding to table.
2167         col = self._convert_data_to_col(col, name=name, copy=copy,
2168                                         default_name=default_name)
2169 
2170         # Assigning a scalar column to an empty table should result in an
2171         # exception (see #3811).
2172         if col.shape == () and len(self) == 0:
2173             raise TypeError('Empty table cannot have column set to scalar value')
2174         # Make col data shape correct for scalars.  The second test is to allow
2175         # broadcasting an N-d element to a column, e.g. t['new'] = [[1, 2]].
2176         elif (col.shape == () or col.shape[0] == 1) and len(self) > 0:
2177             new_shape = (len(self),) + getattr(col, 'shape', ())[1:]
2178             if isinstance(col, np.ndarray):
2179                 col = np.broadcast_to(col, shape=new_shape,
2180                                       subok=True)
2181             elif isinstance(col, ShapedLikeNDArray):
2182                 col = col._apply(np.broadcast_to, shape=new_shape,
2183                                  subok=True)
2184 
2185             # broadcast_to() results in a read-only array.  Apparently it only changes
2186             # the view to look like the broadcasted array.  So copy.
2187             col = col_copy(col)
2188 
2189         name = col.info.name
2190 
2191         # Ensure that new column is the right length
2192         if len(self.columns) > 0 and len(col) != len(self):
2193             raise ValueError('Inconsistent data column lengths')
2194 
2195         if rename_duplicate:
2196             orig_name = name
2197             i = 1
2198             while name in self.columns:
2199                 # Iterate until a unique name is found
2200                 name = orig_name + '_' + str(i)
2201                 i += 1
2202             col.info.name = name
2203 
2204         # Set col parent_table weakref and ensure col has mask attribute if table.masked
2205         self._set_col_parent_table_and_mask(col)
2206 
2207         # Add new column as last column
2208         self.columns[name] = col
2209 
2210         if index is not None:
2211             # Move the other cols to the right of the new one
2212             move_names = self.colnames[index:-1]
2213             for move_name in move_names:
2214                 self.columns.move_to_end(move_name, last=True)
2215 
2216     def add_columns(self, cols, indexes=None, names=None, copy=True, rename_duplicate=False):
2217         """
2218         Add a list of new columns the table using ``cols`` data objects.  If a
2219         corresponding list of ``indexes`` is supplied then insert column
2220         before each ``index`` position in the *original* list of columns,
2221         otherwise append columns to the end of the list.
2222 
2223         The ``cols`` input can include any data objects which are acceptable as
2224         `~astropy.table.Table` column objects or can be converted.  This includes
2225         mixin columns and scalar or length=1 objects which get broadcast to match
2226         the table length.
2227 
2228         From a performance perspective there is little difference between calling
2229         this method once or looping over the new columns and calling ``add_column()``
2230         for each column.
2231 
2232         Parameters
2233         ----------
2234         cols : list of object
2235             List of data objects for the new columns
2236         indexes : list of int or None
2237             Insert column before this position or at end (default).
2238         names : list of str
2239             Column names
2240         copy : bool
2241             Make a copy of the new columns. Default is True.
2242         rename_duplicate : bool
2243             Uniquify new column names if they duplicate the existing ones.
2244             Default is False.
2245 
2246         See Also
2247         --------
2248         astropy.table.hstack, update, replace_column
2249 
2250         Examples
2251         --------
2252         Create a table with two columns 'a' and 'b', then create columns 'c' and 'd'
2253         and append them to the end of the table::
2254 
2255             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2256             >>> col_c = Column(name='c', data=['x', 'y'])
2257             >>> col_d = Column(name='d', data=['u', 'v'])
2258             >>> t.add_columns([col_c, col_d])
2259             >>> print(t)
2260              a   b   c   d
2261             --- --- --- ---
2262               1 0.1   x   u
2263               2 0.2   y   v
2264 
2265         Add column 'c' at position 0 and column 'd' at position 1. Note that
2266         the columns are inserted before the given position::
2267 
2268             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2269             >>> t.add_columns([['x', 'y'], ['u', 'v']], names=['c', 'd'],
2270             ...               indexes=[0, 1])
2271             >>> print(t)
2272              c   a   d   b
2273             --- --- --- ---
2274               x   1   u 0.1
2275               y   2   v 0.2
2276 
2277         Add second column 'b' and column 'c' with ``rename_duplicate``::
2278 
2279             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2280             >>> t.add_columns([[1.1, 1.2], ['x', 'y']], names=('b', 'c'),
2281             ...               rename_duplicate=True)
2282             >>> print(t)
2283              a   b  b_1  c
2284             --- --- --- ---
2285               1 0.1 1.1  x
2286               2 0.2 1.2  y
2287 
2288         Add unnamed columns or mixin objects in the table using default names
2289         or by specifying explicit names with ``names``. Names can also be overridden::
2290 
2291             >>> t = Table()
2292             >>> col_b = Column(name='b', data=['u', 'v'])
2293             >>> t.add_columns([[1, 2], col_b])
2294             >>> t.add_columns([[3, 4], col_b], names=['c', 'd'])
2295             >>> print(t)
2296             col0  b   c   d
2297             ---- --- --- ---
2298                1   u   3   u
2299                2   v   4   v
2300         """
2301         if indexes is None:
2302             indexes = [len(self.columns)] * len(cols)
2303         elif len(indexes) != len(cols):
2304             raise ValueError('Number of indexes must match number of cols')
2305 
2306         if names is None:
2307             names = (None,) * len(cols)
2308         elif len(names) != len(cols):
2309             raise ValueError('Number of names must match number of cols')
2310 
2311         default_names = [f'col{ii + len(self.columns)}'
2312                          for ii in range(len(cols))]
2313 
2314         for ii in reversed(np.argsort(indexes)):
2315             self.add_column(cols[ii], index=indexes[ii], name=names[ii],
2316                             default_name=default_names[ii],
2317                             rename_duplicate=rename_duplicate, copy=copy)
2318 
2319     def _replace_column_warnings(self, name, col):
2320         """
2321         Same as replace_column but issues warnings under various circumstances.
2322         """
2323         warns = conf.replace_warnings
2324         refcount = None
2325         old_col = None
2326 
2327         if 'refcount' in warns and name in self.colnames:
2328             refcount = sys.getrefcount(self[name])
2329 
2330         if name in self.colnames:
2331             old_col = self[name]
2332 
2333         # This may raise an exception (e.g. t['a'] = 1) in which case none of
2334         # the downstream code runs.
2335         self.replace_column(name, col)
2336 
2337         if 'always' in warns:
2338             warnings.warn(f"replaced column '{name}'",
2339                           TableReplaceWarning, stacklevel=3)
2340 
2341         if 'slice' in warns:
2342             try:
2343                 # Check for ndarray-subclass slice.  An unsliced instance
2344                 # has an ndarray for the base while sliced has the same class
2345                 # as parent.
2346                 if isinstance(old_col.base, old_col.__class__):
2347                     msg = ("replaced column '{}' which looks like an array slice. "
2348                            "The new column no longer shares memory with the "
2349                            "original array.".format(name))
2350                     warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2351             except AttributeError:
2352                 pass
2353 
2354         if 'refcount' in warns:
2355             # Did reference count change?
2356             new_refcount = sys.getrefcount(self[name])
2357             if refcount != new_refcount:
2358                 msg = ("replaced column '{}' and the number of references "
2359                        "to the column changed.".format(name))
2360                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2361 
2362         if 'attributes' in warns:
2363             # Any of the standard column attributes changed?
2364             changed_attrs = []
2365             new_col = self[name]
2366             # Check base DataInfo attributes that any column will have
2367             for attr in DataInfo.attr_names:
2368                 if getattr(old_col.info, attr) != getattr(new_col.info, attr):
2369                     changed_attrs.append(attr)
2370 
2371             if changed_attrs:
2372                 msg = ("replaced column '{}' and column attributes {} changed."
2373                        .format(name, changed_attrs))
2374                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2375 
2376     def replace_column(self, name, col, copy=True):
2377         """
2378         Replace column ``name`` with the new ``col`` object.
2379 
2380         The behavior of ``copy`` for Column objects is:
2381         - copy=True: new class instance with a copy of data and deep copy of meta
2382         - copy=False: new class instance with same data and a key-only copy of meta
2383 
2384         For mixin columns:
2385         - copy=True: new class instance with copy of data and deep copy of meta
2386         - copy=False: original instance (no copy at all)
2387 
2388         Parameters
2389         ----------
2390         name : str
2391             Name of column to replace
2392         col : `~astropy.table.Column` or `~numpy.ndarray` or sequence
2393             New column object to replace the existing column.
2394         copy : bool
2395             Make copy of the input ``col``, default=True
2396 
2397         See Also
2398         --------
2399         add_columns, astropy.table.hstack, update
2400 
2401         Examples
2402         --------
2403         Replace column 'a' with a float version of itself::
2404 
2405             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3]], names=('a', 'b'))
2406             >>> float_a = t['a'].astype(float)
2407             >>> t.replace_column('a', float_a)
2408         """
2409         if name not in self.colnames:
2410             raise ValueError(f'column name {name} is not in the table')
2411 
2412         if self[name].info.indices:
2413             raise ValueError('cannot replace a table index column')
2414 
2415         col = self._convert_data_to_col(col, name=name, copy=copy)
2416         self._set_col_parent_table_and_mask(col)
2417 
2418         # Ensure that new column is the right length, unless it is the only column
2419         # in which case re-sizing is allowed.
2420         if len(self.columns) > 1 and len(col) != len(self[name]):
2421             raise ValueError('length of new column must match table length')
2422 
2423         self.columns.__setitem__(name, col, validated=True)
2424 
2425     def remove_row(self, index):
2426         """
2427         Remove a row from the table.
2428 
2429         Parameters
2430         ----------
2431         index : int
2432             Index of row to remove
2433 
2434         Examples
2435         --------
2436         Create a table with three columns 'a', 'b' and 'c'::
2437 
2438             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2439             ...           names=('a', 'b', 'c'))
2440             >>> print(t)
2441              a   b   c
2442             --- --- ---
2443               1 0.1   x
2444               2 0.2   y
2445               3 0.3   z
2446 
2447         Remove row 1 from the table::
2448 
2449             >>> t.remove_row(1)
2450             >>> print(t)
2451              a   b   c
2452             --- --- ---
2453               1 0.1   x
2454               3 0.3   z
2455 
2456         To remove several rows at the same time use remove_rows.
2457         """
2458         # check the index against the types that work with np.delete
2459         if not isinstance(index, (int, np.integer)):
2460             raise TypeError("Row index must be an integer")
2461         self.remove_rows(index)
2462 
2463     def remove_rows(self, row_specifier):
2464         """
2465         Remove rows from the table.
2466 
2467         Parameters
2468         ----------
2469         row_specifier : slice or int or array of int
2470             Specification for rows to remove
2471 
2472         Examples
2473         --------
2474         Create a table with three columns 'a', 'b' and 'c'::
2475 
2476             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2477             ...           names=('a', 'b', 'c'))
2478             >>> print(t)
2479              a   b   c
2480             --- --- ---
2481               1 0.1   x
2482               2 0.2   y
2483               3 0.3   z
2484 
2485         Remove rows 0 and 2 from the table::
2486 
2487             >>> t.remove_rows([0, 2])
2488             >>> print(t)
2489              a   b   c
2490             --- --- ---
2491               2 0.2   y
2492 
2493 
2494         Note that there are no warnings if the slice operator extends
2495         outside the data::
2496 
2497             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2498             ...           names=('a', 'b', 'c'))
2499             >>> t.remove_rows(slice(10, 20, 1))
2500             >>> print(t)
2501              a   b   c
2502             --- --- ---
2503               1 0.1   x
2504               2 0.2   y
2505               3 0.3   z
2506         """
2507         # Update indices
2508         for index in self.indices:
2509             index.remove_rows(row_specifier)
2510 
2511         keep_mask = np.ones(len(self), dtype=bool)
2512         keep_mask[row_specifier] = False
2513 
2514         columns = self.TableColumns()
2515         for name, col in self.columns.items():
2516             newcol = col[keep_mask]
2517             newcol.info.parent_table = self
2518             columns[name] = newcol
2519 
2520         self._replace_cols(columns)
2521 
2522         # Revert groups to default (ungrouped) state
2523         if hasattr(self, '_groups'):
2524             del self._groups
2525 
2526     def iterrows(self, *names):
2527         """
2528         Iterate over rows of table returning a tuple of values for each row.
2529 
2530         This method is especially useful when only a subset of columns are needed.
2531 
2532         The ``iterrows`` method can be substantially faster than using the standard
2533         Table row iteration (e.g. ``for row in tbl:``), since that returns a new
2534         ``~astropy.table.Row`` object for each row and accessing a column in that
2535         row (e.g. ``row['col0']``) is slower than tuple access.
2536 
2537         Parameters
2538         ----------
2539         names : list
2540             List of column names (default to all columns if no names provided)
2541 
2542         Returns
2543         -------
2544         rows : iterable
2545             Iterator returns tuples of row values
2546 
2547         Examples
2548         --------
2549         Create a table with three columns 'a', 'b' and 'c'::
2550 
2551             >>> t = Table({'a': [1, 2, 3],
2552             ...            'b': [1.0, 2.5, 3.0],
2553             ...            'c': ['x', 'y', 'z']})
2554 
2555         To iterate row-wise using column names::
2556 
2557             >>> for a, c in t.iterrows('a', 'c'):
2558             ...     print(a, c)
2559             1 x
2560             2 y
2561             3 z
2562 
2563         """
2564         if len(names) == 0:
2565             names = self.colnames
2566         else:
2567             for name in names:
2568                 if name not in self.colnames:
2569                     raise ValueError(f'{name} is not a valid column name')
2570 
2571         cols = (self[name] for name in names)
2572         out = zip(*cols)
2573         return out
2574 
2575     def _set_of_names_in_colnames(self, names):
2576         """Return ``names`` as a set if valid, or raise a `KeyError`.
2577 
2578         ``names`` is valid if all elements in it are in ``self.colnames``.
2579         If ``names`` is a string then it is interpreted as a single column
2580         name.
2581         """
2582         names = {names} if isinstance(names, str) else set(names)
2583         invalid_names = names.difference(self.colnames)
2584         if len(invalid_names) == 1:
2585             raise KeyError(f'column "{invalid_names.pop()}" does not exist')
2586         elif len(invalid_names) > 1:
2587             raise KeyError(f'columns {invalid_names} do not exist')
2588         return names
2589 
2590     def remove_column(self, name):
2591         """
2592         Remove a column from the table.
2593 
2594         This can also be done with::
2595 
2596           del table[name]
2597 
2598         Parameters
2599         ----------
2600         name : str
2601             Name of column to remove
2602 
2603         Examples
2604         --------
2605         Create a table with three columns 'a', 'b' and 'c'::
2606 
2607             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2608             ...           names=('a', 'b', 'c'))
2609             >>> print(t)
2610              a   b   c
2611             --- --- ---
2612               1 0.1   x
2613               2 0.2   y
2614               3 0.3   z
2615 
2616         Remove column 'b' from the table::
2617 
2618             >>> t.remove_column('b')
2619             >>> print(t)
2620              a   c
2621             --- ---
2622               1   x
2623               2   y
2624               3   z
2625 
2626         To remove several columns at the same time use remove_columns.
2627         """
2628 
2629         self.remove_columns([name])
2630 
2631     def remove_columns(self, names):
2632         '''
2633         Remove several columns from the table.
2634 
2635         Parameters
2636         ----------
2637         names : str or iterable of str
2638             Names of the columns to remove
2639 
2640         Examples
2641         --------
2642         Create a table with three columns 'a', 'b' and 'c'::
2643 
2644             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2645             ...     names=('a', 'b', 'c'))
2646             >>> print(t)
2647              a   b   c
2648             --- --- ---
2649               1 0.1   x
2650               2 0.2   y
2651               3 0.3   z
2652 
2653         Remove columns 'b' and 'c' from the table::
2654 
2655             >>> t.remove_columns(['b', 'c'])
2656             >>> print(t)
2657              a
2658             ---
2659               1
2660               2
2661               3
2662 
2663         Specifying only a single column also works. Remove column 'b' from the table::
2664 
2665             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2666             ...     names=('a', 'b', 'c'))
2667             >>> t.remove_columns('b')
2668             >>> print(t)
2669              a   c
2670             --- ---
2671               1   x
2672               2   y
2673               3   z
2674 
2675         This gives the same as using remove_column.
2676         '''
2677         for name in self._set_of_names_in_colnames(names):
2678             self.columns.pop(name)
2679 
2680     def _convert_string_dtype(self, in_kind, out_kind, encode_decode_func):
2681         """
2682         Convert string-like columns to/from bytestring and unicode (internal only).
2683 
2684         Parameters
2685         ----------
2686         in_kind : str
2687             Input dtype.kind
2688         out_kind : str
2689             Output dtype.kind
2690         """
2691 
2692         for col in self.itercols():
2693             if col.dtype.kind == in_kind:
2694                 try:
2695                     # This requires ASCII and is faster by a factor of up to ~8, so
2696                     # try that first.
2697                     newcol = col.__class__(col, dtype=out_kind)
2698                 except (UnicodeEncodeError, UnicodeDecodeError):
2699                     newcol = col.__class__(encode_decode_func(col, 'utf-8'))
2700 
2701                     # Quasi-manually copy info attributes.  Unfortunately
2702                     # DataInfo.__set__ does not do the right thing in this case
2703                     # so newcol.info = col.info does not get the old info attributes.
2704                     for attr in col.info.attr_names - col.info._attrs_no_copy - {'dtype'}:
2705                         value = deepcopy(getattr(col.info, attr))
2706                         setattr(newcol.info, attr, value)
2707 
2708                 self[col.name] = newcol
2709 
2710     def convert_bytestring_to_unicode(self):
2711         """
2712         Convert bytestring columns (dtype.kind='S') to unicode (dtype.kind='U')
2713         using UTF-8 encoding.
2714 
2715         Internally this changes string columns to represent each character
2716         in the string with a 4-byte UCS-4 equivalent, so it is inefficient
2717         for memory but allows scripts to manipulate string arrays with
2718         natural syntax.
2719         """
2720         self._convert_string_dtype('S', 'U', np.char.decode)
2721 
2722     def convert_unicode_to_bytestring(self):
2723         """
2724         Convert unicode columns (dtype.kind='U') to bytestring (dtype.kind='S')
2725         using UTF-8 encoding.
2726 
2727         When exporting a unicode string array to a file, it may be desirable
2728         to encode unicode columns as bytestrings.
2729         """
2730         self._convert_string_dtype('U', 'S', np.char.encode)
2731 
2732     def keep_columns(self, names):
2733         '''
2734         Keep only the columns specified (remove the others).
2735 
2736         Parameters
2737         ----------
2738         names : str or iterable of str
2739             The columns to keep. All other columns will be removed.
2740 
2741         Examples
2742         --------
2743         Create a table with three columns 'a', 'b' and 'c'::
2744 
2745             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
2746             ...           names=('a', 'b', 'c'))
2747             >>> print(t)
2748              a   b   c
2749             --- --- ---
2750               1 0.1   x
2751               2 0.2   y
2752               3 0.3   z
2753 
2754         Keep only column 'a' of the table::
2755 
2756             >>> t.keep_columns('a')
2757             >>> print(t)
2758              a
2759             ---
2760               1
2761               2
2762               3
2763 
2764         Keep columns 'a' and 'c' of the table::
2765 
2766             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
2767             ...           names=('a', 'b', 'c'))
2768             >>> t.keep_columns(['a', 'c'])
2769             >>> print(t)
2770              a   c
2771             --- ---
2772               1   x
2773               2   y
2774               3   z
2775         '''
2776         names = self._set_of_names_in_colnames(names)
2777         for colname in self.colnames:
2778             if colname not in names:
2779                 self.columns.pop(colname)
2780 
2781     def rename_column(self, name, new_name):
2782         '''
2783         Rename a column.
2784 
2785         This can also be done directly with by setting the ``name`` attribute
2786         for a column::
2787 
2788           table[name].name = new_name
2789 
2790         TODO: this won't work for mixins
2791 
2792         Parameters
2793         ----------
2794         name : str
2795             The current name of the column.
2796         new_name : str
2797             The new name for the column
2798 
2799         Examples
2800         --------
2801         Create a table with three columns 'a', 'b' and 'c'::
2802 
2803             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
2804             >>> print(t)
2805              a   b   c
2806             --- --- ---
2807               1   3   5
2808               2   4   6
2809 
2810         Renaming column 'a' to 'aa'::
2811 
2812             >>> t.rename_column('a' , 'aa')
2813             >>> print(t)
2814              aa  b   c
2815             --- --- ---
2816               1   3   5
2817               2   4   6
2818         '''
2819 
2820         if name not in self.keys():
2821             raise KeyError(f"Column {name} does not exist")
2822 
2823         self.columns[name].info.name = new_name
2824 
2825     def rename_columns(self, names, new_names):
2826         '''
2827         Rename multiple columns.
2828 
2829         Parameters
2830         ----------
2831         names : list, tuple
2832             A list or tuple of existing column names.
2833         new_names : list, tuple
2834             A list or tuple of new column names.
2835 
2836         Examples
2837         --------
2838         Create a table with three columns 'a', 'b', 'c'::
2839 
2840             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
2841             >>> print(t)
2842               a   b   c
2843              --- --- ---
2844               1   3   5
2845               2   4   6
2846 
2847         Renaming columns 'a' to 'aa' and 'b' to 'bb'::
2848 
2849             >>> names = ('a','b')
2850             >>> new_names = ('aa','bb')
2851             >>> t.rename_columns(names, new_names)
2852             >>> print(t)
2853              aa  bb   c
2854             --- --- ---
2855               1   3   5
2856               2   4   6
2857         '''
2858 
2859         if not self._is_list_or_tuple_of_str(names):
2860             raise TypeError("input 'names' must be a tuple or a list of column names")
2861 
2862         if not self._is_list_or_tuple_of_str(new_names):
2863             raise TypeError("input 'new_names' must be a tuple or a list of column names")
2864 
2865         if len(names) != len(new_names):
2866             raise ValueError("input 'names' and 'new_names' list arguments must be the same length")
2867 
2868         for name, new_name in zip(names, new_names):
2869             self.rename_column(name, new_name)
2870 
2871     def _set_row(self, idx, colnames, vals):
2872         try:
2873             assert len(vals) == len(colnames)
2874         except Exception:
2875             raise ValueError('right hand side must be a sequence of values with '
2876                              'the same length as the number of selected columns')
2877 
2878         # Keep track of original values before setting each column so that
2879         # setting row can be transactional.
2880         orig_vals = []
2881         cols = self.columns
2882         try:
2883             for name, val in zip(colnames, vals):
2884                 orig_vals.append(cols[name][idx])
2885                 cols[name][idx] = val
2886         except Exception:
2887             # If anything went wrong first revert the row update then raise
2888             for name, val in zip(colnames, orig_vals[:-1]):
2889                 cols[name][idx] = val
2890             raise
2891 
2892     def add_row(self, vals=None, mask=None):
2893         """Add a new row to the end of the table.
2894 
2895         The ``vals`` argument can be:
2896 
2897         sequence (e.g. tuple or list)
2898             Column values in the same order as table columns.
2899         mapping (e.g. dict)
2900             Keys corresponding to column names.  Missing values will be
2901             filled with np.zeros for the column dtype.
2902         `None`
2903             All values filled with np.zeros for the column dtype.
2904 
2905         This method requires that the Table object "owns" the underlying array
2906         data.  In particular one cannot add a row to a Table that was
2907         initialized with copy=False from an existing array.
2908 
2909         The ``mask`` attribute should give (if desired) the mask for the
2910         values. The type of the mask should match that of the values, i.e. if
2911         ``vals`` is an iterable, then ``mask`` should also be an iterable
2912         with the same length, and if ``vals`` is a mapping, then ``mask``
2913         should be a dictionary.
2914 
2915         Parameters
2916         ----------
2917         vals : tuple, list, dict or None
2918             Use the specified values in the new row
2919         mask : tuple, list, dict or None
2920             Use the specified mask values in the new row
2921 
2922         Examples
2923         --------
2924         Create a table with three columns 'a', 'b' and 'c'::
2925 
2926            >>> t = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
2927            >>> print(t)
2928             a   b   c
2929            --- --- ---
2930              1   4   7
2931              2   5   8
2932 
2933         Adding a new row with entries '3' in 'a', '6' in 'b' and '9' in 'c'::
2934 
2935            >>> t.add_row([3,6,9])
2936            >>> print(t)
2937              a   b   c
2938              --- --- ---
2939              1   4   7
2940              2   5   8
2941              3   6   9
2942         """
2943         self.insert_row(len(self), vals, mask)
2944 
2945     def insert_row(self, index, vals=None, mask=None):
2946         """Add a new row before the given ``index`` position in the table.
2947 
2948         The ``vals`` argument can be:
2949 
2950         sequence (e.g. tuple or list)
2951             Column values in the same order as table columns.
2952         mapping (e.g. dict)
2953             Keys corresponding to column names.  Missing values will be
2954             filled with np.zeros for the column dtype.
2955         `None`
2956             All values filled with np.zeros for the column dtype.
2957 
2958         The ``mask`` attribute should give (if desired) the mask for the
2959         values. The type of the mask should match that of the values, i.e. if
2960         ``vals`` is an iterable, then ``mask`` should also be an iterable
2961         with the same length, and if ``vals`` is a mapping, then ``mask``
2962         should be a dictionary.
2963 
2964         Parameters
2965         ----------
2966         vals : tuple, list, dict or None
2967             Use the specified values in the new row
2968         mask : tuple, list, dict or None
2969             Use the specified mask values in the new row
2970         """
2971         colnames = self.colnames
2972 
2973         N = len(self)
2974         if index < -N or index > N:
2975             raise IndexError("Index {} is out of bounds for table with length {}"
2976                              .format(index, N))
2977         if index < 0:
2978             index += N
2979 
2980         if isinstance(vals, Mapping) or vals is None:
2981             # From the vals and/or mask mappings create the corresponding lists
2982             # that have entries for each table column.
2983             if mask is not None and not isinstance(mask, Mapping):
2984                 raise TypeError("Mismatch between type of vals and mask")
2985 
2986             # Now check that the mask is specified for the same keys as the
2987             # values, otherwise things get really confusing.
2988             if mask is not None and set(vals.keys()) != set(mask.keys()):
2989                 raise ValueError('keys in mask should match keys in vals')
2990 
2991             if vals and any(name not in colnames for name in vals):
2992                 raise ValueError('Keys in vals must all be valid column names')
2993 
2994             vals_list = []
2995             mask_list = []
2996 
2997             for name in colnames:
2998                 if vals and name in vals:
2999                     vals_list.append(vals[name])
3000                     mask_list.append(False if mask is None else mask[name])
3001                 else:
3002                     col = self[name]
3003                     if hasattr(col, 'dtype'):
3004                         # Make a placeholder zero element of the right type which is masked.
3005                         # This assumes the appropriate insert() method will broadcast a
3006                         # numpy scalar to the right shape.
3007                         vals_list.append(np.zeros(shape=(), dtype=col.dtype))
3008 
3009                         # For masked table any unsupplied values are masked by default.
3010                         mask_list.append(self.masked and vals is not None)
3011                     else:
3012                         raise ValueError(f"Value must be supplied for column '{name}'")
3013 
3014             vals = vals_list
3015             mask = mask_list
3016 
3017         if isiterable(vals):
3018             if mask is not None and (not isiterable(mask) or isinstance(mask, Mapping)):
3019                 raise TypeError("Mismatch between type of vals and mask")
3020 
3021             if len(self.columns) != len(vals):
3022                 raise ValueError('Mismatch between number of vals and columns')
3023 
3024             if mask is not None:
3025                 if len(self.columns) != len(mask):
3026                     raise ValueError('Mismatch between number of masks and columns')
3027             else:
3028                 mask = [False] * len(self.columns)
3029 
3030         else:
3031             raise TypeError('Vals must be an iterable or mapping or None')
3032 
3033         # Insert val at index for each column
3034         columns = self.TableColumns()
3035         for name, col, val, mask_ in zip(colnames, self.columns.values(), vals, mask):
3036             try:
3037                 # If new val is masked and the existing column does not support masking
3038                 # then upgrade the column to a mask-enabled type: either the table-level
3039                 # default ColumnClass or else MaskedColumn.
3040                 if mask_ and isinstance(col, Column) and not isinstance(col, MaskedColumn):
3041                     col_cls = (self.ColumnClass
3042                                if issubclass(self.ColumnClass, self.MaskedColumn)
3043                                else self.MaskedColumn)
3044                     col = col_cls(col, copy=False)
3045 
3046                 newcol = col.insert(index, val, axis=0)
3047 
3048                 if len(newcol) != N + 1:
3049                     raise ValueError('Incorrect length for column {} after inserting {}'
3050                                      ' (expected {}, got {})'
3051                                      .format(name, val, len(newcol), N + 1))
3052                 newcol.info.parent_table = self
3053 
3054                 # Set mask if needed and possible
3055                 if mask_:
3056                     if hasattr(newcol, 'mask'):
3057                         newcol[index] = np.ma.masked
3058                     else:
3059                         raise TypeError("mask was supplied for column '{}' but it does not "
3060                                         "support masked values".format(col.info.name))
3061 
3062                 columns[name] = newcol
3063 
3064             except Exception as err:
3065                 raise ValueError("Unable to insert row because of exception in column '{}':\n{}"
3066                                  .format(name, err)) from err
3067 
3068         for table_index in self.indices:
3069             table_index.insert_row(index, vals, self.columns.values())
3070 
3071         self._replace_cols(columns)
3072 
3073         # Revert groups to default (ungrouped) state
3074         if hasattr(self, '_groups'):
3075             del self._groups
3076 
3077     def _replace_cols(self, columns):
3078         for col, new_col in zip(self.columns.values(), columns.values()):
3079             new_col.info.indices = []
3080             for index in col.info.indices:
3081                 index.columns[index.col_position(col.info.name)] = new_col
3082                 new_col.info.indices.append(index)
3083 
3084         self.columns = columns
3085 
3086     def update(self, other, copy=True):
3087         """
3088         Perform a dictionary-style update and merge metadata.
3089 
3090         The argument ``other`` must be a |Table|, or something that can be used
3091         to initialize a table. Columns from (possibly converted) ``other`` are
3092         added to this table. In case of matching column names the column from
3093         this table is replaced with the one from ``other``.
3094 
3095         Parameters
3096         ----------
3097         other : table-like
3098             Data to update this table with.
3099         copy : bool
3100             Whether the updated columns should be copies of or references to
3101             the originals.
3102 
3103         See Also
3104         --------
3105         add_columns, astropy.table.hstack, replace_column
3106 
3107         Examples
3108         --------
3109         Update a table with another table::
3110 
3111             >>> t1 = Table({'a': ['foo', 'bar'], 'b': [0., 0.]}, meta={'i': 0})
3112             >>> t2 = Table({'b': [1., 2.], 'c': [7., 11.]}, meta={'n': 2})
3113             >>> t1.update(t2)
3114             >>> t1
3115             <Table length=2>
3116              a      b       c
3117             str3 float64 float64
3118             ---- ------- -------
3119              foo     1.0     7.0
3120              bar     2.0    11.0
3121             >>> t1.meta
3122             {'i': 0, 'n': 2}
3123 
3124         Update a table with a dictionary::
3125 
3126             >>> t = Table({'a': ['foo', 'bar'], 'b': [0., 0.]})
3127             >>> t.update({'b': [1., 2.]})
3128             >>> t
3129             <Table length=2>
3130              a      b
3131             str3 float64
3132             ---- -------
3133              foo     1.0
3134              bar     2.0
3135         """
3136         from .operations import _merge_table_meta
3137         if not isinstance(other, Table):
3138             other = self.__class__(other, copy=copy)
3139         common_cols = set(self.colnames).intersection(other.colnames)
3140         for name, col in other.items():
3141             if name in common_cols:
3142                 self.replace_column(name, col, copy=copy)
3143             else:
3144                 self.add_column(col, name=name, copy=copy)
3145         _merge_table_meta(self, [self, other], metadata_conflicts='silent')
3146 
3147     def argsort(self, keys=None, kind=None, reverse=False):
3148         """
3149         Return the indices which would sort the table according to one or
3150         more key columns.  This simply calls the `numpy.argsort` function on
3151         the table with the ``order`` parameter set to ``keys``.
3152 
3153         Parameters
3154         ----------
3155         keys : str or list of str
3156             The column name(s) to order the table by
3157         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3158             Sorting algorithm used by ``numpy.argsort``.
3159         reverse : bool
3160             Sort in reverse order (default=False)
3161 
3162         Returns
3163         -------
3164         index_array : ndarray, int
3165             Array of indices that sorts the table by the specified key
3166             column(s).
3167         """
3168         if isinstance(keys, str):
3169             keys = [keys]
3170 
3171         # use index sorted order if possible
3172         if keys is not None:
3173             index = get_index(self, names=keys)
3174             if index is not None:
3175                 idx = np.asarray(index.sorted_data())
3176                 return idx[::-1] if reverse else idx
3177 
3178         kwargs = {}
3179         if keys:
3180             # For multiple keys return a structured array which gets sorted,
3181             # while for a single key return a single ndarray.  Sorting a
3182             # one-column structured array is slower than ndarray (e.g. a
3183             # factor of ~6 for a 10 million long random array), and much slower
3184             # for in principle sortable columns like Time, which get stored as
3185             # object arrays.
3186             if len(keys) > 1:
3187                 kwargs['order'] = keys
3188                 data = self.as_array(names=keys)
3189             else:
3190                 data = self[keys[0]]
3191         else:
3192             # No keys provided so sort on all columns.
3193             data = self.as_array()
3194 
3195         if kind:
3196             kwargs['kind'] = kind
3197 
3198         # np.argsort will look for a possible .argsort method (e.g., for Time),
3199         # and if that fails cast to an array and try sorting that way.
3200         idx = np.argsort(data, **kwargs)
3201 
3202         return idx[::-1] if reverse else idx
3203 
3204     def sort(self, keys=None, *, kind=None, reverse=False):
3205         '''
3206         Sort the table according to one or more keys. This operates
3207         on the existing table and does not return a new table.
3208 
3209         Parameters
3210         ----------
3211         keys : str or list of str
3212             The key(s) to order the table by. If None, use the
3213             primary index of the Table.
3214         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3215             Sorting algorithm used by ``numpy.argsort``.
3216         reverse : bool
3217             Sort in reverse order (default=False)
3218 
3219         Examples
3220         --------
3221         Create a table with 3 columns::
3222 
3223             >>> t = Table([['Max', 'Jo', 'John'], ['Miller', 'Miller', 'Jackson'],
3224             ...            [12, 15, 18]], names=('firstname', 'name', 'tel'))
3225             >>> print(t)
3226             firstname   name  tel
3227             --------- ------- ---
3228                   Max  Miller  12
3229                    Jo  Miller  15
3230                  John Jackson  18
3231 
3232         Sorting according to standard sorting rules, first 'name' then 'firstname'::
3233 
3234             >>> t.sort(['name', 'firstname'])
3235             >>> print(t)
3236             firstname   name  tel
3237             --------- ------- ---
3238                  John Jackson  18
3239                    Jo  Miller  15
3240                   Max  Miller  12
3241 
3242         Sorting according to standard sorting rules, first 'firstname' then 'tel',
3243         in reverse order::
3244 
3245             >>> t.sort(['firstname', 'tel'], reverse=True)
3246             >>> print(t)
3247             firstname   name  tel
3248             --------- ------- ---
3249                   Max  Miller  12
3250                  John Jackson  18
3251                    Jo  Miller  15
3252         '''
3253         if keys is None:
3254             if not self.indices:
3255                 raise ValueError("Table sort requires input keys or a table index")
3256             keys = [x.info.name for x in self.indices[0].columns]
3257 
3258         if isinstance(keys, str):
3259             keys = [keys]
3260 
3261         indexes = self.argsort(keys, kind=kind, reverse=reverse)
3262 
3263         with self.index_mode('freeze'):
3264             for name, col in self.columns.items():
3265                 # Make a new sorted column.  This requires that take() also copies
3266                 # relevant info attributes for mixin columns.
3267                 new_col = col.take(indexes, axis=0)
3268 
3269                 # First statement in try: will succeed if the column supports an in-place
3270                 # update, and matches the legacy behavior of astropy Table.  However,
3271                 # some mixin classes may not support this, so in that case just drop
3272                 # in the entire new column. See #9553 and #9536 for discussion.
3273                 try:
3274                     col[:] = new_col
3275                 except Exception:
3276                     # In-place update failed for some reason, exception class not
3277                     # predictable for arbitrary mixin.
3278                     self[col.info.name] = new_col
3279 
3280     def reverse(self):
3281         '''
3282         Reverse the row order of table rows.  The table is reversed
3283         in place and there are no function arguments.
3284 
3285         Examples
3286         --------
3287         Create a table with three columns::
3288 
3289             >>> t = Table([['Max', 'Jo', 'John'], ['Miller','Miller','Jackson'],
3290             ...         [12,15,18]], names=('firstname','name','tel'))
3291             >>> print(t)
3292             firstname   name  tel
3293             --------- ------- ---
3294                   Max  Miller  12
3295                    Jo  Miller  15
3296                  John Jackson  18
3297 
3298         Reversing order::
3299 
3300             >>> t.reverse()
3301             >>> print(t)
3302             firstname   name  tel
3303             --------- ------- ---
3304                  John Jackson  18
3305                    Jo  Miller  15
3306                   Max  Miller  12
3307         '''
3308         for col in self.columns.values():
3309             # First statement in try: will succeed if the column supports an in-place
3310             # update, and matches the legacy behavior of astropy Table.  However,
3311             # some mixin classes may not support this, so in that case just drop
3312             # in the entire new column. See #9836, #9553, and #9536 for discussion.
3313             new_col = col[::-1]
3314             try:
3315                 col[:] = new_col
3316             except Exception:
3317                 # In-place update failed for some reason, exception class not
3318                 # predictable for arbitrary mixin.
3319                 self[col.info.name] = new_col
3320 
3321         for index in self.indices:
3322             index.reverse()
3323 
3324     def round(self, decimals=0):
3325         '''
3326         Round numeric columns in-place to the specified number of decimals.
3327         Non-numeric columns will be ignored.
3328 
3329         Examples
3330         --------
3331         Create three columns with different types:
3332 
3333             >>> t = Table([[1, 4, 5], [-25.55, 12.123, 85],
3334             ...     ['a', 'b', 'c']], names=('a', 'b', 'c'))
3335             >>> print(t)
3336              a    b     c
3337             --- ------ ---
3338               1 -25.55   a
3339               4 12.123   b
3340               5   85.0   c
3341 
3342         Round them all to 0:
3343 
3344             >>> t.round(0)
3345             >>> print(t)
3346              a    b    c
3347             --- ----- ---
3348               1 -26.0   a
3349               4  12.0   b
3350               5  85.0   c
3351 
3352         Round column 'a' to -1 decimal:
3353 
3354             >>> t.round({'a':-1})
3355             >>> print(t)
3356              a    b    c
3357             --- ----- ---
3358               0 -26.0   a
3359               0  12.0   b
3360               0  85.0   c
3361 
3362         Parameters
3363         ----------
3364         decimals: int, dict
3365             Number of decimals to round the columns to. If a dict is given,
3366             the columns will be rounded to the number specified as the value.
3367             If a certain column is not in the dict given, it will remain the
3368             same.
3369         '''
3370         if isinstance(decimals, Mapping):
3371             decimal_values = decimals.values()
3372             column_names = decimals.keys()
3373         elif isinstance(decimals, int):
3374             decimal_values = itertools.repeat(decimals)
3375             column_names = self.colnames
3376         else:
3377             raise ValueError("'decimals' argument must be an int or a dict")
3378 
3379         for colname, decimal in zip(column_names, decimal_values):
3380             col = self.columns[colname]
3381             if np.issubdtype(col.info.dtype, np.number):
3382                 try:
3383                     np.around(col, decimals=decimal, out=col)
3384                 except TypeError:
3385                     # Bug in numpy see https://github.com/numpy/numpy/issues/15438
3386                     col[()] = np.around(col, decimals=decimal)
3387 
3388     def copy(self, copy_data=True):
3389         '''
3390         Return a copy of the table.
3391 
3392         Parameters
3393         ----------
3394         copy_data : bool
3395             If `True` (the default), copy the underlying data array.
3396             Otherwise, use the same data array. The ``meta`` is always
3397             deepcopied regardless of the value for ``copy_data``.
3398         '''
3399         out = self.__class__(self, copy=copy_data)
3400 
3401         # If the current table is grouped then do the same in the copy
3402         if hasattr(self, '_groups'):
3403             out._groups = groups.TableGroups(out, indices=self._groups._indices,
3404                                              keys=self._groups._keys)
3405         return out
3406 
3407     def __deepcopy__(self, memo=None):
3408         return self.copy(True)
3409 
3410     def __copy__(self):
3411         return self.copy(False)
3412 
3413     def __lt__(self, other):
3414         return super().__lt__(other)
3415 
3416     def __gt__(self, other):
3417         return super().__gt__(other)
3418 
3419     def __le__(self, other):
3420         return super().__le__(other)
3421 
3422     def __ge__(self, other):
3423         return super().__ge__(other)
3424 
3425     def __eq__(self, other):
3426         return self._rows_equal(other)
3427 
3428     def __ne__(self, other):
3429         return ~self.__eq__(other)
3430 
3431     def _rows_equal(self, other):
3432         """
3433         Row-wise comparison of table with any other object.
3434 
3435         This is actual implementation for __eq__.
3436 
3437         Returns a 1-D boolean numpy array showing result of row-wise comparison.
3438         This is the same as the ``==`` comparison for tables.
3439 
3440         Parameters
3441         ----------
3442         other : Table or DataFrame or ndarray
3443              An object to compare with table
3444 
3445         Examples
3446         --------
3447         Comparing one Table with other::
3448 
3449             >>> t1 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3450             >>> t2 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3451             >>> t1._rows_equal(t2)
3452             array([ True,  True])
3453 
3454         """
3455 
3456         if isinstance(other, Table):
3457             other = other.as_array()
3458 
3459         if self.has_masked_columns:
3460             if isinstance(other, np.ma.MaskedArray):
3461                 result = self.as_array() == other
3462             else:
3463                 # If mask is True, then by definition the row doesn't match
3464                 # because the other array is not masked.
3465                 false_mask = np.zeros(1, dtype=[(n, bool) for n in self.dtype.names])
3466                 result = (self.as_array().data == other) & (self.mask == false_mask)
3467         else:
3468             if isinstance(other, np.ma.MaskedArray):
3469                 # If mask is True, then by definition the row doesn't match
3470                 # because the other array is not masked.
3471                 false_mask = np.zeros(1, dtype=[(n, bool) for n in other.dtype.names])
3472                 result = (self.as_array() == other.data) & (other.mask == false_mask)
3473             else:
3474                 result = self.as_array() == other
3475 
3476         return result
3477 
3478     def values_equal(self, other):
3479         """
3480         Element-wise comparison of table with another table, list, or scalar.
3481 
3482         Returns a ``Table`` with the same columns containing boolean values
3483         showing result of comparison.
3484 
3485         Parameters
3486         ----------
3487         other : table-like object or list or scalar
3488              Object to compare with table
3489 
3490         Examples
3491         --------
3492         Compare one Table with other::
3493 
3494           >>> t1 = Table([[1, 2], [4, 5], [-7, 8]], names=('a', 'b', 'c'))
3495           >>> t2 = Table([[1, 2], [-4, 5], [7, 8]], names=('a', 'b', 'c'))
3496           >>> t1.values_equal(t2)
3497           <Table length=2>
3498            a     b     c
3499           bool  bool  bool
3500           ---- ----- -----
3501           True False False
3502           True  True  True
3503 
3504         """
3505         if isinstance(other, Table):
3506             names = other.colnames
3507         else:
3508             try:
3509                 other = Table(other, copy=False)
3510                 names = other.colnames
3511             except Exception:
3512                 # Broadcast other into a dict, so e.g. other = 2 will turn into
3513                 # other = {'a': 2, 'b': 2} and then equality does a
3514                 # column-by-column broadcasting.
3515                 names = self.colnames
3516                 other = {name: other for name in names}
3517 
3518         # Require column names match but do not require same column order
3519         if set(self.colnames) != set(names):
3520             raise ValueError('cannot compare tables with different column names')
3521 
3522         eqs = []
3523         for name in names:
3524             try:
3525                 np.broadcast(self[name], other[name])  # Check if broadcast-able
3526                 # Catch the numpy FutureWarning related to equality checking,
3527                 # "elementwise comparison failed; returning scalar instead, but
3528                 #  in the future will perform elementwise comparison".  Turn this
3529                 # into an exception since the scalar answer is not what we want.
3530                 with warnings.catch_warnings(record=True) as warns:
3531                     warnings.simplefilter('always')
3532                     eq = self[name] == other[name]
3533                     if (warns and issubclass(warns[-1].category, FutureWarning)
3534                             and 'elementwise comparison failed' in str(warns[-1].message)):
3535                         raise FutureWarning(warns[-1].message)
3536             except Exception as err:
3537                 raise ValueError(f'unable to compare column {name}') from err
3538 
3539             # Be strict about the result from the comparison. E.g. SkyCoord __eq__ is just
3540             # broken and completely ignores that it should return an array.
3541             if not (isinstance(eq, np.ndarray)
3542                     and eq.dtype is np.dtype('bool')
3543                     and len(eq) == len(self)):
3544                 raise TypeError(f'comparison for column {name} returned {eq} '
3545                                 f'instead of the expected boolean ndarray')
3546 
3547             eqs.append(eq)
3548 
3549         out = Table(eqs, names=names)
3550 
3551         return out
3552 
3553     @property
3554     def groups(self):
3555         if not hasattr(self, '_groups'):
3556             self._groups = groups.TableGroups(self)
3557         return self._groups
3558 
3559     def group_by(self, keys):
3560         """
3561         Group this table by the specified ``keys``
3562 
3563         This effectively splits the table into groups which correspond to unique
3564         values of the ``keys`` grouping object.  The output is a new
3565         `~astropy.table.TableGroups` which contains a copy of this table but
3566         sorted by row according to ``keys``.
3567 
3568         The ``keys`` input to `group_by` can be specified in different ways:
3569 
3570           - String or list of strings corresponding to table column name(s)
3571           - Numpy array (homogeneous or structured) with same length as this table
3572           - `~astropy.table.Table` with same length as this table
3573 
3574         Parameters
3575         ----------
3576         keys : str, list of str, numpy array, or `~astropy.table.Table`
3577             Key grouping object
3578 
3579         Returns
3580         -------
3581         out : `~astropy.table.Table`
3582             New table with groups set
3583         """
3584         return groups.table_group_by(self, keys)
3585 
3586     def to_pandas(self, index=None, use_nullable_int=True):
3587         """
3588         Return a :class:`pandas.DataFrame` instance
3589 
3590         The index of the created DataFrame is controlled by the ``index``
3591         argument.  For ``index=True`` or the default ``None``, an index will be
3592         specified for the DataFrame if there is a primary key index on the
3593         Table *and* if it corresponds to a single column.  If ``index=False``
3594         then no DataFrame index will be specified.  If ``index`` is the name of
3595         a column in the table then that will be the DataFrame index.
3596 
3597         In addition to vanilla columns or masked columns, this supports Table
3598         mixin columns like Quantity, Time, or SkyCoord.  In many cases these
3599         objects have no analog in pandas and will be converted to a "encoded"
3600         representation using only Column or MaskedColumn.  The exception is
3601         Time or TimeDelta columns, which will be converted to the corresponding
3602         representation in pandas using ``np.datetime64`` or ``np.timedelta64``.
3603         See the example below.
3604 
3605         Parameters
3606         ----------
3607         index : None, bool, str
3608             Specify DataFrame index mode
3609         use_nullable_int : bool, default=True
3610             Convert integer MaskedColumn to pandas nullable integer type.
3611             If ``use_nullable_int=False`` or the pandas version does not support
3612             nullable integer types (version < 0.24), then the column is converted
3613             to float with NaN for missing elements and a warning is issued.
3614 
3615         Returns
3616         -------
3617         dataframe : :class:`pandas.DataFrame`
3618             A pandas :class:`pandas.DataFrame` instance
3619 
3620         Raises
3621         ------
3622         ImportError
3623             If pandas is not installed
3624         ValueError
3625             If the Table has multi-dimensional columns
3626 
3627         Examples
3628         --------
3629         Here we convert a table with a few mixins to a
3630         :class:`pandas.DataFrame` instance.
3631 
3632           >>> import pandas as pd
3633           >>> from astropy.table import QTable
3634           >>> import astropy.units as u
3635           >>> from astropy.time import Time, TimeDelta
3636           >>> from astropy.coordinates import SkyCoord
3637 
3638           >>> q = [1, 2] * u.m
3639           >>> tm = Time([1998, 2002], format='jyear')
3640           >>> sc = SkyCoord([5, 6], [7, 8], unit='deg')
3641           >>> dt = TimeDelta([3, 200] * u.s)
3642 
3643           >>> t = QTable([q, tm, sc, dt], names=['q', 'tm', 'sc', 'dt'])
3644 
3645           >>> df = t.to_pandas(index='tm')
3646           >>> with pd.option_context('display.max_columns', 20):
3647           ...     print(df)
3648                         q  sc.ra  sc.dec              dt
3649           tm
3650           1998-01-01  1.0    5.0     7.0 0 days 00:00:03
3651           2002-01-01  2.0    6.0     8.0 0 days 00:03:20
3652 
3653         """
3654         from pandas import DataFrame, Series
3655 
3656         if index is not False:
3657             if index in (None, True):
3658                 # Default is to use the table primary key if available and a single column
3659                 if self.primary_key and len(self.primary_key) == 1:
3660                     index = self.primary_key[0]
3661                 else:
3662                     index = False
3663             else:
3664                 if index not in self.colnames:
3665                     raise ValueError('index must be None, False, True or a table '
3666                                      'column name')
3667 
3668         def _encode_mixins(tbl):
3669             """Encode a Table ``tbl`` that may have mixin columns to a Table with only
3670             astropy Columns + appropriate meta-data to allow subsequent decoding.
3671             """
3672             from . import serialize
3673             from astropy.time import TimeBase, TimeDelta
3674 
3675             # Convert any Time or TimeDelta columns and pay attention to masking
3676             time_cols = [col for col in tbl.itercols() if isinstance(col, TimeBase)]
3677             if time_cols:
3678 
3679                 # Make a light copy of table and clear any indices
3680                 new_cols = []
3681                 for col in tbl.itercols():
3682                     new_col = col_copy(col, copy_indices=False) if col.info.indices else col
3683                     new_cols.append(new_col)
3684                 tbl = tbl.__class__(new_cols, copy=False)
3685 
3686                 # Certain subclasses (e.g. TimeSeries) may generate new indices on
3687                 # table creation, so make sure there are no indices on the table.
3688                 for col in tbl.itercols():
3689                     col.info.indices.clear()
3690 
3691                 for col in time_cols:
3692                     if isinstance(col, TimeDelta):
3693                         # Convert to nanoseconds (matches astropy datetime64 support)
3694                         new_col = (col.sec * 1e9).astype('timedelta64[ns]')
3695                         nat = np.timedelta64('NaT')
3696                     else:
3697                         new_col = col.datetime64.copy()
3698                         nat = np.datetime64('NaT')
3699                     if col.masked:
3700                         new_col[col.mask] = nat
3701                     tbl[col.info.name] = new_col
3702 
3703             # Convert the table to one with no mixins, only Column objects.
3704             encode_tbl = serialize.represent_mixins_as_columns(tbl)
3705             return encode_tbl
3706 
3707         tbl = _encode_mixins(self)
3708 
3709         badcols = [name for name, col in self.columns.items() if len(col.shape) > 1]
3710         if badcols:
3711             raise ValueError(
3712                 f'Cannot convert a table with multidimensional columns to a '
3713                 f'pandas DataFrame. Offending columns are: {badcols}\n'
3714                 f'One can filter out such columns using:\n'
3715                 f'names = [name for name in tbl.colnames if len(tbl[name].shape) <= 1]\n'
3716                 f'tbl[names].to_pandas(...)')
3717 
3718         out = OrderedDict()
3719 
3720         for name, column in tbl.columns.items():
3721             if getattr(column.dtype, 'isnative', True):
3722                 out[name] = column
3723             else:
3724                 out[name] = column.data.byteswap().newbyteorder('=')
3725 
3726             if isinstance(column, MaskedColumn) and np.any(column.mask):
3727                 if column.dtype.kind in ['i', 'u']:
3728                     pd_dtype = column.dtype.name
3729                     if use_nullable_int:
3730                         # Convert int64 to Int64, uint32 to UInt32, etc for nullable types
3731                         pd_dtype = pd_dtype.replace('i', 'I').replace('u', 'U')
3732                     out[name] = Series(out[name], dtype=pd_dtype)
3733 
3734                     # If pandas is older than 0.24 the type may have turned to float
3735                     if column.dtype.kind != out[name].dtype.kind:
3736                         warnings.warn(
3737                             f"converted column '{name}' from {column.dtype} to {out[name].dtype}",
3738                             TableReplaceWarning, stacklevel=3)
3739                 elif column.dtype.kind not in ['f', 'c']:
3740                     out[name] = column.astype(object).filled(np.nan)
3741 
3742         kwargs = {}
3743 
3744         if index:
3745             idx = out.pop(index)
3746 
3747             kwargs['index'] = idx
3748 
3749             # We add the table index to Series inputs (MaskedColumn with int values) to override
3750             # its default RangeIndex, see #11432
3751             for v in out.values():
3752                 if isinstance(v, Series):
3753                     v.index = idx
3754 
3755         df = DataFrame(out, **kwargs)
3756         if index:
3757             # Explicitly set the pandas DataFrame index to the original table
3758             # index name.
3759             df.index.name = idx.info.name
3760 
3761         return df
3762 
3763     @classmethod
3764     def from_pandas(cls, dataframe, index=False, units=None):
3765         """
3766         Create a `~astropy.table.Table` from a :class:`pandas.DataFrame` instance
3767 
3768         In addition to converting generic numeric or string columns, this supports
3769         conversion of pandas Date and Time delta columns to `~astropy.time.Time`
3770         and `~astropy.time.TimeDelta` columns, respectively.
3771 
3772         Parameters
3773         ----------
3774         dataframe : :class:`pandas.DataFrame`
3775             A pandas :class:`pandas.DataFrame` instance
3776         index : bool
3777             Include the index column in the returned table (default=False)
3778         units: dict
3779             A dict mapping column names to to a `~astropy.units.Unit`.
3780             The columns will have the specified unit in the Table.
3781 
3782         Returns
3783         -------
3784         table : `~astropy.table.Table`
3785             A `~astropy.table.Table` (or subclass) instance
3786 
3787         Raises
3788         ------
3789         ImportError
3790             If pandas is not installed
3791 
3792         Examples
3793         --------
3794         Here we convert a :class:`pandas.DataFrame` instance
3795         to a `~astropy.table.QTable`.
3796 
3797           >>> import numpy as np
3798           >>> import pandas as pd
3799           >>> from astropy.table import QTable
3800 
3801           >>> time = pd.Series(['1998-01-01', '2002-01-01'], dtype='datetime64[ns]')
3802           >>> dt = pd.Series(np.array([1, 300], dtype='timedelta64[s]'))
3803           >>> df = pd.DataFrame({'time': time})
3804           >>> df['dt'] = dt
3805           >>> df['x'] = [3., 4.]
3806           >>> with pd.option_context('display.max_columns', 20):
3807           ...     print(df)
3808                   time              dt    x
3809           0 1998-01-01 0 days 00:00:01  3.0
3810           1 2002-01-01 0 days 00:05:00  4.0
3811 
3812           >>> QTable.from_pandas(df)
3813           <QTable length=2>
3814                     time              dt       x
3815                     Time          TimeDelta float64
3816           ----------------------- --------- -------
3817           1998-01-01T00:00:00.000       1.0     3.0
3818           2002-01-01T00:00:00.000     300.0     4.0
3819 
3820         """
3821 
3822         out = OrderedDict()
3823 
3824         names = list(dataframe.columns)
3825         columns = [dataframe[name] for name in names]
3826         datas = [np.array(column) for column in columns]
3827         masks = [np.array(column.isnull()) for column in columns]
3828 
3829         if index:
3830             index_name = dataframe.index.name or 'index'
3831             while index_name in names:
3832                 index_name = '_' + index_name + '_'
3833             names.insert(0, index_name)
3834             columns.insert(0, dataframe.index)
3835             datas.insert(0, np.array(dataframe.index))
3836             masks.insert(0, np.zeros(len(dataframe), dtype=bool))
3837 
3838         if units is None:
3839             units = [None] * len(names)
3840         else:
3841             if not isinstance(units, Mapping):
3842                 raise TypeError('Expected a Mapping "column-name" -> "unit"')
3843 
3844             not_found = set(units.keys()) - set(names)
3845             if not_found:
3846                 warnings.warn(f'`units` contains additional columns: {not_found}')
3847 
3848             units = [units.get(name) for name in names]
3849 
3850         for name, column, data, mask, unit in zip(names, columns, datas, masks, units):
3851 
3852             if column.dtype.kind in ['u', 'i'] and np.any(mask):
3853                 # Special-case support for pandas nullable int
3854                 np_dtype = str(column.dtype).lower()
3855                 data = np.zeros(shape=column.shape, dtype=np_dtype)
3856                 data[~mask] = column[~mask]
3857                 out[name] = MaskedColumn(data=data, name=name, mask=mask, unit=unit, copy=False)
3858                 continue
3859 
3860             if data.dtype.kind == 'O':
3861                 # If all elements of an object array are string-like or np.nan
3862                 # then coerce back to a native numpy str/unicode array.
3863                 string_types = (str, bytes)
3864                 nan = np.nan
3865                 if all(isinstance(x, string_types) or x is nan for x in data):
3866                     # Force any missing (null) values to b''.  Numpy will
3867                     # upcast to str/unicode as needed.
3868                     data[mask] = b''
3869 
3870                     # When the numpy object array is represented as a list then
3871                     # numpy initializes to the correct string or unicode type.
3872                     data = np.array([x for x in data])
3873 
3874             # Numpy datetime64
3875             if data.dtype.kind == 'M':
3876                 from astropy.time import Time
3877                 out[name] = Time(data, format='datetime64')
3878                 if np.any(mask):
3879                     out[name][mask] = np.ma.masked
3880                 out[name].format = 'isot'
3881 
3882             # Numpy timedelta64
3883             elif data.dtype.kind == 'm':
3884                 from astropy.time import TimeDelta
3885                 data_sec = data.astype('timedelta64[ns]').astype(np.float64) / 1e9
3886                 out[name] = TimeDelta(data_sec, format='sec')
3887                 if np.any(mask):
3888                     out[name][mask] = np.ma.masked
3889 
3890             else:
3891                 if np.any(mask):
3892                     out[name] = MaskedColumn(data=data, name=name, mask=mask, unit=unit)
3893                 else:
3894                     out[name] = Column(data=data, name=name, unit=unit)
3895 
3896         return cls(out)
3897 
3898     info = TableInfo()

</code><intended_behavior>Ensure that any method within the `Table` class that leads to HTML output generation (either directly or indirectly through utility methods or class instantiation) properly propagates the `formats` argument to the HTML writing logic. The precise adjustment needed may vary based on the method's current responsibilities and its role in HTML output generation. The goal is to provide a seamless and consistent interface for users, where specifying formats for table output produces the expected results regardless of the output format chosen.</intended_behavior>]
2025-10-17 09:43:25.786 | INFO     | Search completed. Bug locations: [<file>astropy/io/ascii/html.py</file>
<class>None</class>
<method>write</method>
<code>
40     def write(self, data):
41         self.out.append(data)

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/io/ascii/html.py</file>
<class>None</class>
<method>write</method>
<code>
342     def write(self, table):
343         """
344         Return data in ``table`` converted to HTML as a list of strings.
345         """
346         # Check that table has only 1-d or 2-d columns. Above that fails.
347         self._check_multidim_table(table)
348 
349         cols = list(table.columns.values())
350 
351         self.data.header.cols = cols
352 
353         if isinstance(self.data.fill_values, tuple):
354             self.data.fill_values = [self.data.fill_values]
355 
356         self.data._set_fill_values(cols)
357 
358         lines = []
359 
360         # Set HTML escaping to False for any column in the raw_html_cols input
361         raw_html_cols = self.html.get('raw_html_cols', [])
362         if isinstance(raw_html_cols, str):
363             raw_html_cols = [raw_html_cols]  # Allow for a single string as input
364         cols_escaped = [col.info.name not in raw_html_cols for col in cols]
365 
366         # Kwargs that get passed on to bleach.clean() if that is available.
367         raw_html_clean_kwargs = self.html.get('raw_html_clean_kwargs', {})
368 
369         # Use XMLWriter to output HTML to lines
370         w = writer.XMLWriter(ListWriter(lines))
371 
372         with w.tag('html'):
373             with w.tag('head'):
374                 # Declare encoding and set CSS style for table
375                 with w.tag('meta', attrib={'charset': 'utf-8'}):
376                     pass
377                 with w.tag('meta', attrib={'http-equiv': 'Content-type',
378                                            'content': 'text/html;charset=UTF-8'}):
379                     pass
380                 if 'css' in self.html:
381                     with w.tag('style'):
382                         w.data(self.html['css'])
383                 if 'cssfiles' in self.html:
384                     for filename in self.html['cssfiles']:
385                         with w.tag('link', rel="stylesheet", href=filename, type='text/css'):
386                             pass
387                 if 'jsfiles' in self.html:
388                     for filename in self.html['jsfiles']:
389                         with w.tag('script', src=filename):
390                             w.data('')  # need this instead of pass to get <script></script>
391             with w.tag('body'):
392                 if 'js' in self.html:
393                     with w.xml_cleaning_method('none'):
394                         with w.tag('script'):
395                             w.data(self.html['js'])
396                 if isinstance(self.html['table_id'], str):
397                     html_table_id = self.html['table_id']
398                 else:
399                     html_table_id = None
400                 if 'table_class' in self.html:
401                     html_table_class = self.html['table_class']
402                     attrib = {"class": html_table_class}
403                 else:
404                     attrib = {}
405                 with w.tag('table', id=html_table_id, attrib=attrib):
406                     with w.tag('thead'):
407                         with w.tag('tr'):
408                             for col in cols:
409                                 if len(col.shape) > 1 and self.html['multicol']:
410                                     # Set colspan attribute for multicolumns
411                                     w.start('th', colspan=col.shape[1])
412                                 else:
413                                     w.start('th')
414                                 w.data(col.info.name.strip())
415                                 w.end(indent=False)
416                         col_str_iters = []
417                         new_cols_escaped = []
418 
419                         # Make a container to hold any new_col objects created
420                         # below for multicolumn elements.  This is purely to
421                         # maintain a reference for these objects during
422                         # subsequent iteration to format column values.  This
423                         # requires that the weakref info._parent be maintained.
424                         new_cols = []
425 
426                         for col, col_escaped in zip(cols, cols_escaped):
427                             if len(col.shape) > 1 and self.html['multicol']:
428                                 span = col.shape[1]
429                                 for i in range(span):
430                                     # Split up multicolumns into separate columns
431                                     new_col = Column([el[i] for el in col])
432 
433                                     new_col_iter_str_vals = self.fill_values(
434                                         col, new_col.info.iter_str_vals())
435                                     col_str_iters.append(new_col_iter_str_vals)
436                                     new_cols_escaped.append(col_escaped)
437                                     new_cols.append(new_col)
438                             else:
439 
440                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())
441                                 col_str_iters.append(col_iter_str_vals)
442 
443                                 new_cols_escaped.append(col_escaped)
444 
445                     for row in zip(*col_str_iters):
446                         with w.tag('tr'):
447                             for el, col_escaped in zip(row, new_cols_escaped):
448                                 # Potentially disable HTML escaping for column
449                                 method = ('escape_xml' if col_escaped else 'bleach_clean')
450                                 with w.xml_cleaning_method(method, **raw_html_clean_kwargs):
451                                     w.start('td')
452                                     w.data(el.strip())
453                                     w.end(indent=False)
454 
455         # Fixes XMLWriter's insertion of unwanted line breaks
456         return [''.join(lines)]

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/io/ascii/html.py</file>
<class>ListWriter</class>
<method>write</method>
<code>
40     def write(self, data):
41         self.out.append(data)

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/io/ascii/html.py</file>
<class>HTML</class>
<method>write</method>
<code>
342     def write(self, table):
343         """
344         Return data in ``table`` converted to HTML as a list of strings.
345         """
346         # Check that table has only 1-d or 2-d columns. Above that fails.
347         self._check_multidim_table(table)
348 
349         cols = list(table.columns.values())
350 
351         self.data.header.cols = cols
352 
353         if isinstance(self.data.fill_values, tuple):
354             self.data.fill_values = [self.data.fill_values]
355 
356         self.data._set_fill_values(cols)
357 
358         lines = []
359 
360         # Set HTML escaping to False for any column in the raw_html_cols input
361         raw_html_cols = self.html.get('raw_html_cols', [])
362         if isinstance(raw_html_cols, str):
363             raw_html_cols = [raw_html_cols]  # Allow for a single string as input
364         cols_escaped = [col.info.name not in raw_html_cols for col in cols]
365 
366         # Kwargs that get passed on to bleach.clean() if that is available.
367         raw_html_clean_kwargs = self.html.get('raw_html_clean_kwargs', {})
368 
369         # Use XMLWriter to output HTML to lines
370         w = writer.XMLWriter(ListWriter(lines))
371 
372         with w.tag('html'):
373             with w.tag('head'):
374                 # Declare encoding and set CSS style for table
375                 with w.tag('meta', attrib={'charset': 'utf-8'}):
376                     pass
377                 with w.tag('meta', attrib={'http-equiv': 'Content-type',
378                                            'content': 'text/html;charset=UTF-8'}):
379                     pass
380                 if 'css' in self.html:
381                     with w.tag('style'):
382                         w.data(self.html['css'])
383                 if 'cssfiles' in self.html:
384                     for filename in self.html['cssfiles']:
385                         with w.tag('link', rel="stylesheet", href=filename, type='text/css'):
386                             pass
387                 if 'jsfiles' in self.html:
388                     for filename in self.html['jsfiles']:
389                         with w.tag('script', src=filename):
390                             w.data('')  # need this instead of pass to get <script></script>
391             with w.tag('body'):
392                 if 'js' in self.html:
393                     with w.xml_cleaning_method('none'):
394                         with w.tag('script'):
395                             w.data(self.html['js'])
396                 if isinstance(self.html['table_id'], str):
397                     html_table_id = self.html['table_id']
398                 else:
399                     html_table_id = None
400                 if 'table_class' in self.html:
401                     html_table_class = self.html['table_class']
402                     attrib = {"class": html_table_class}
403                 else:
404                     attrib = {}
405                 with w.tag('table', id=html_table_id, attrib=attrib):
406                     with w.tag('thead'):
407                         with w.tag('tr'):
408                             for col in cols:
409                                 if len(col.shape) > 1 and self.html['multicol']:
410                                     # Set colspan attribute for multicolumns
411                                     w.start('th', colspan=col.shape[1])
412                                 else:
413                                     w.start('th')
414                                 w.data(col.info.name.strip())
415                                 w.end(indent=False)
416                         col_str_iters = []
417                         new_cols_escaped = []
418 
419                         # Make a container to hold any new_col objects created
420                         # below for multicolumn elements.  This is purely to
421                         # maintain a reference for these objects during
422                         # subsequent iteration to format column values.  This
423                         # requires that the weakref info._parent be maintained.
424                         new_cols = []
425 
426                         for col, col_escaped in zip(cols, cols_escaped):
427                             if len(col.shape) > 1 and self.html['multicol']:
428                                 span = col.shape[1]
429                                 for i in range(span):
430                                     # Split up multicolumns into separate columns
431                                     new_col = Column([el[i] for el in col])
432 
433                                     new_col_iter_str_vals = self.fill_values(
434                                         col, new_col.info.iter_str_vals())
435                                     col_str_iters.append(new_col_iter_str_vals)
436                                     new_cols_escaped.append(col_escaped)
437                                     new_cols.append(new_col)
438                             else:
439 
440                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())
441                                 col_str_iters.append(col_iter_str_vals)
442 
443                                 new_cols_escaped.append(col_escaped)
444 
445                     for row in zip(*col_str_iters):
446                         with w.tag('tr'):
447                             for el, col_escaped in zip(row, new_cols_escaped):
448                                 # Potentially disable HTML escaping for column
449                                 method = ('escape_xml' if col_escaped else 'bleach_clean')
450                                 with w.xml_cleaning_method(method, **raw_html_clean_kwargs):
451                                     w.start('td')
452                                     w.data(el.strip())
453                                     w.end(indent=False)
454 
455         # Fixes XMLWriter's insertion of unwanted line breaks
456         return [''.join(lines)]

</code><intended_behavior>The `write` method responsible for outputting the table data in HTML format must be adjusted or verified to ensure that it respects the `formats` parameter. This entails modifying the method to iterate over each column of the table, check if there is a specified format for that column in the `formats` argument, and apply this format to each value in the column before generating the HTML output. This ensures consistency with the behavior of the `write` method across other formats (e.g., CSV, LaTeX) that do respect the `formats` argument. It's crucial that existing functionalities, such as default formatting and handling of non-specified columns, remain unchanged to preserve backward compatibility.</intended_behavior>, <file>astropy/table/table.py</file>
<class>Table</class>
<method>None</method>
<code>
542 class Table:
543     """A class to represent tables of heterogeneous data.
544 
545     `~astropy.table.Table` provides a class for heterogeneous tabular data.
546     A key enhancement provided by the `~astropy.table.Table` class over
547     e.g. a `numpy` structured array is the ability to easily modify the
548     structure of the table by adding or removing columns, or adding new
549     rows of data.  In addition table and column metadata are fully supported.
550 
551     `~astropy.table.Table` differs from `~astropy.nddata.NDData` by the
552     assumption that the input data consists of columns of homogeneous data,
553     where each column has a unique identifier and may contain additional
554     metadata such as the data unit, format, and description.
555 
556     See also: https://docs.astropy.org/en/stable/table/
557 
558     Parameters
559     ----------
560     data : numpy ndarray, dict, list, table-like object, optional
561         Data to initialize table.
562     masked : bool, optional
563         Specify whether the table is masked.
564     names : list, optional
565         Specify column names.
566     dtype : list, optional
567         Specify column data types.
568     meta : dict, optional
569         Metadata associated with the table.
570     copy : bool, optional
571         Copy the input data. If the input is a Table the ``meta`` is always
572         copied regardless of the ``copy`` parameter.
573         Default is True.
574     rows : numpy ndarray, list of list, optional
575         Row-oriented data for table instead of ``data`` argument.
576     copy_indices : bool, optional
577         Copy any indices in the input data. Default is True.
578     units : list, dict, optional
579         List or dict of units to apply to columns.
580     descriptions : list, dict, optional
581         List or dict of descriptions to apply to columns.
582     **kwargs : dict, optional
583         Additional keyword args when converting table-like object.
584     """
585 
586     meta = MetaData(copy=False)
587 
588     # Define class attributes for core container objects to allow for subclass
589     # customization.
590     Row = Row
591     Column = Column
592     MaskedColumn = MaskedColumn
593     TableColumns = TableColumns
594     TableFormatter = TableFormatter
595 
596     # Unified I/O read and write methods from .connect
597     read = UnifiedReadWriteMethod(TableRead)
598     write = UnifiedReadWriteMethod(TableWrite)
599 
600     pprint_exclude_names = PprintIncludeExclude()
601     pprint_include_names = PprintIncludeExclude()
602 
603     def as_array(self, keep_byteorder=False, names=None):
604         """
605         Return a new copy of the table in the form of a structured np.ndarray or
606         np.ma.MaskedArray object (as appropriate).
607 
608         Parameters
609         ----------
610         keep_byteorder : bool, optional
611             By default the returned array has all columns in native byte
612             order.  However, if this option is `True` this preserves the
613             byte order of all columns (if any are non-native).
614 
615         names : list, optional:
616             List of column names to include for returned structured array.
617             Default is to include all table columns.
618 
619         Returns
620         -------
621         table_array : array or `~numpy.ma.MaskedArray`
622             Copy of table as a numpy structured array.
623             ndarray for unmasked or `~numpy.ma.MaskedArray` for masked.
624         """
625         masked = self.masked or self.has_masked_columns or self.has_masked_values
626         empty_init = ma.empty if masked else np.empty
627         if len(self.columns) == 0:
628             return empty_init(0, dtype=None)
629 
630         dtype = []
631 
632         cols = self.columns.values()
633 
634         if names is not None:
635             cols = [col for col in cols if col.info.name in names]
636 
637         for col in cols:
638             col_descr = descr(col)
639 
640             if not (col.info.dtype.isnative or keep_byteorder):
641                 new_dt = np.dtype(col_descr[1]).newbyteorder('=')
642                 col_descr = (col_descr[0], new_dt, col_descr[2])
643 
644             dtype.append(col_descr)
645 
646         data = empty_init(len(self), dtype=dtype)
647         for col in cols:
648             # When assigning from one array into a field of a structured array,
649             # Numpy will automatically swap those columns to their destination
650             # byte order where applicable
651             data[col.info.name] = col
652 
653             # For masked out, masked mixin columns need to set output mask attribute.
654             if masked and has_info_class(col, MixinInfo) and hasattr(col, 'mask'):
655                 data[col.info.name].mask = col.mask
656 
657         return data
658 
659     def __init__(self, data=None, masked=False, names=None, dtype=None,
660                  meta=None, copy=True, rows=None, copy_indices=True,
661                  units=None, descriptions=None,
662                  **kwargs):
663 
664         # Set up a placeholder empty table
665         self._set_masked(masked)
666         self.columns = self.TableColumns()
667         self.formatter = self.TableFormatter()
668         self._copy_indices = True  # copy indices from this Table by default
669         self._init_indices = copy_indices  # whether to copy indices in init
670         self.primary_key = None
671 
672         # Must copy if dtype are changing
673         if not copy and dtype is not None:
674             raise ValueError('Cannot specify dtype when copy=False')
675 
676         # Specifies list of names found for the case of initializing table with
677         # a list of dict. If data are not list of dict then this is None.
678         names_from_list_of_dict = None
679 
680         # Row-oriented input, e.g. list of lists or list of tuples, list of
681         # dict, Row instance.  Set data to something that the subsequent code
682         # will parse correctly.
683         if rows is not None:
684             if data is not None:
685                 raise ValueError('Cannot supply both `data` and `rows` values')
686             if isinstance(rows, types.GeneratorType):
687                 # Without this then the all(..) test below uses up the generator
688                 rows = list(rows)
689 
690             # Get column names if `rows` is a list of dict, otherwise this is None
691             names_from_list_of_dict = _get_names_from_list_of_dict(rows)
692             if names_from_list_of_dict:
693                 data = rows
694             elif isinstance(rows, self.Row):
695                 data = rows
696             else:
697                 data = list(zip(*rows))
698 
699         # Infer the type of the input data and set up the initialization
700         # function, number of columns, and potentially the default col names
701 
702         default_names = None
703 
704         # Handle custom (subclass) table attributes that are stored in meta.
705         # These are defined as class attributes using the TableAttribute
706         # descriptor.  Any such attributes get removed from kwargs here and
707         # stored for use after the table is otherwise initialized. Any values
708         # provided via kwargs will have precedence over existing values from
709         # meta (e.g. from data as a Table or meta via kwargs).
710         meta_table_attrs = {}
711         if kwargs:
712             for attr in list(kwargs):
713                 descr = getattr(self.__class__, attr, None)
714                 if isinstance(descr, TableAttribute):
715                     meta_table_attrs[attr] = kwargs.pop(attr)
716 
717         if hasattr(data, '__astropy_table__'):
718             # Data object implements the __astropy_table__ interface method.
719             # Calling that method returns an appropriate instance of
720             # self.__class__ and respects the `copy` arg.  The returned
721             # Table object should NOT then be copied.
722             data = data.__astropy_table__(self.__class__, copy, **kwargs)
723             copy = False
724         elif kwargs:
725             raise TypeError('__init__() got unexpected keyword argument {!r}'
726                             .format(list(kwargs.keys())[0]))
727 
728         if (isinstance(data, np.ndarray)
729                 and data.shape == (0,)
730                 and not data.dtype.names):
731             data = None
732 
733         if isinstance(data, self.Row):
734             data = data._table[data._index:data._index + 1]
735 
736         if isinstance(data, (list, tuple)):
737             # Get column names from `data` if it is a list of dict, otherwise this is None.
738             # This might be previously defined if `rows` was supplied as an init arg.
739             names_from_list_of_dict = (names_from_list_of_dict
740                                        or _get_names_from_list_of_dict(data))
741             if names_from_list_of_dict:
742                 init_func = self._init_from_list_of_dicts
743                 n_cols = len(names_from_list_of_dict)
744             else:
745                 init_func = self._init_from_list
746                 n_cols = len(data)
747 
748         elif isinstance(data, np.ndarray):
749             if data.dtype.names:
750                 init_func = self._init_from_ndarray  # _struct
751                 n_cols = len(data.dtype.names)
752                 default_names = data.dtype.names
753             else:
754                 init_func = self._init_from_ndarray  # _homog
755                 if data.shape == ():
756                     raise ValueError('Can not initialize a Table with a scalar')
757                 elif len(data.shape) == 1:
758                     data = data[np.newaxis, :]
759                 n_cols = data.shape[1]
760 
761         elif isinstance(data, Mapping):
762             init_func = self._init_from_dict
763             default_names = list(data)
764             n_cols = len(default_names)
765 
766         elif isinstance(data, Table):
767             # If user-input meta is None then use data.meta (if non-trivial)
768             if meta is None and data.meta:
769                 # At this point do NOT deepcopy data.meta as this will happen after
770                 # table init_func() is called.  But for table input the table meta
771                 # gets a key copy here if copy=False because later a direct object ref
772                 # is used.
773                 meta = data.meta if copy else data.meta.copy()
774 
775             # Handle indices on input table. Copy primary key and don't copy indices
776             # if the input Table is in non-copy mode.
777             self.primary_key = data.primary_key
778             self._init_indices = self._init_indices and data._copy_indices
779 
780             # Extract default names, n_cols, and then overwrite ``data`` to be the
781             # table columns so we can use _init_from_list.
782             default_names = data.colnames
783             n_cols = len(default_names)
784             data = list(data.columns.values())
785 
786             init_func = self._init_from_list
787 
788         elif data is None:
789             if names is None:
790                 if dtype is None:
791                     # Table was initialized as `t = Table()`. Set up for empty
792                     # table with names=[], data=[], and n_cols=0.
793                     # self._init_from_list() will simply return, giving the
794                     # expected empty table.
795                     names = []
796                 else:
797                     try:
798                         # No data nor names but dtype is available.  This must be
799                         # valid to initialize a structured array.
800                         dtype = np.dtype(dtype)
801                         names = dtype.names
802                         dtype = [dtype[name] for name in names]
803                     except Exception:
804                         raise ValueError('dtype was specified but could not be '
805                                          'parsed for column names')
806             # names is guaranteed to be set at this point
807             init_func = self._init_from_list
808             n_cols = len(names)
809             data = [[]] * n_cols
810 
811         else:
812             raise ValueError(f'Data type {type(data)} not allowed to init Table')
813 
814         # Set up defaults if names and/or dtype are not specified.
815         # A value of None means the actual value will be inferred
816         # within the appropriate initialization routine, either from
817         # existing specification or auto-generated.
818 
819         if dtype is None:
820             dtype = [None] * n_cols
821         elif isinstance(dtype, np.dtype):
822             if default_names is None:
823                 default_names = dtype.names
824             # Convert a numpy dtype input to a list of dtypes for later use.
825             dtype = [dtype[name] for name in dtype.names]
826 
827         if names is None:
828             names = default_names or [None] * n_cols
829 
830         names = [None if name is None else str(name) for name in names]
831 
832         self._check_names_dtype(names, dtype, n_cols)
833 
834         # Finally do the real initialization
835         init_func(data, names, dtype, n_cols, copy)
836 
837         # Set table meta.  If copy=True then deepcopy meta otherwise use the
838         # user-supplied meta directly.
839         if meta is not None:
840             self.meta = deepcopy(meta) if copy else meta
841 
842         # Update meta with TableAttributes supplied as kwargs in Table init.
843         # This takes precedence over previously-defined meta.
844         if meta_table_attrs:
845             for attr, value in meta_table_attrs.items():
846                 setattr(self, attr, value)
847 
848         # Whatever happens above, the masked property should be set to a boolean
849         if self.masked not in (None, True, False):
850             raise TypeError("masked property must be None, True or False")
851 
852         self._set_column_attribute('unit', units)
853         self._set_column_attribute('description', descriptions)
854 
855     def _set_column_attribute(self, attr, values):
856         """Set ``attr`` for columns to ``values``, which can be either a dict (keyed by column
857         name) or a dict of name: value pairs.  This is used for handling the ``units`` and
858         ``descriptions`` kwargs to ``__init__``.
859         """
860         if not values:
861             return
862 
863         if isinstance(values, Row):
864             # For a Row object transform to an equivalent dict.
865             values = {name: values[name] for name in values.colnames}
866 
867         if not isinstance(values, Mapping):
868             # If not a dict map, assume iterable and map to dict if the right length
869             if len(values) != len(self.columns):
870                 raise ValueError(f'sequence of {attr} values must match number of columns')
871             values = dict(zip(self.colnames, values))
872 
873         for name, value in values.items():
874             if name not in self.columns:
875                 raise ValueError(f'invalid column name {name} for setting {attr} attribute')
876 
877             # Special case: ignore unit if it is an empty or blank string
878             if attr == 'unit' and isinstance(value, str):
879                 if value.strip() == '':
880                     value = None
881 
882             if value not in (np.ma.masked, None):
883                 setattr(self[name].info, attr, value)
884 
885     def __getstate__(self):
886         columns = OrderedDict((key, col if isinstance(col, BaseColumn) else col_copy(col))
887                               for key, col in self.columns.items())
888         return (columns, self.meta)
889 
890     def __setstate__(self, state):
891         columns, meta = state
892         self.__init__(columns, meta=meta)
893 
894     @property
895     def mask(self):
896         # Dynamic view of available masks
897         if self.masked or self.has_masked_columns or self.has_masked_values:
898             mask_table = Table([getattr(col, 'mask', FalseArray(col.shape))
899                                 for col in self.itercols()],
900                                names=self.colnames, copy=False)
901 
902             # Set hidden attribute to force inplace setitem so that code like
903             # t.mask['a'] = [1, 0, 1] will correctly set the underlying mask.
904             # See #5556 for discussion.
905             mask_table._setitem_inplace = True
906         else:
907             mask_table = None
908 
909         return mask_table
910 
911     @mask.setter
912     def mask(self, val):
913         self.mask[:] = val
914 
915     @property
916     def _mask(self):
917         """This is needed so that comparison of a masked Table and a
918         MaskedArray works.  The requirement comes from numpy.ma.core
919         so don't remove this property."""
920         return self.as_array().mask
921 
922     def filled(self, fill_value=None):
923         """Return copy of self, with masked values filled.
924 
925         If input ``fill_value`` supplied then that value is used for all
926         masked entries in the table.  Otherwise the individual
927         ``fill_value`` defined for each table column is used.
928 
929         Parameters
930         ----------
931         fill_value : str
932             If supplied, this ``fill_value`` is used for all masked entries
933             in the entire table.
934 
935         Returns
936         -------
937         filled_table : `~astropy.table.Table`
938             New table with masked values filled
939         """
940         if self.masked or self.has_masked_columns or self.has_masked_values:
941             # Get new columns with masked values filled, then create Table with those
942             # new cols (copy=False) but deepcopy the meta.
943             data = [col.filled(fill_value) if hasattr(col, 'filled') else col
944                     for col in self.itercols()]
945             return self.__class__(data, meta=deepcopy(self.meta), copy=False)
946         else:
947             # Return copy of the original object.
948             return self.copy()
949 
950     @property
951     def indices(self):
952         '''
953         Return the indices associated with columns of the table
954         as a TableIndices object.
955         '''
956         lst = []
957         for column in self.columns.values():
958             for index in column.info.indices:
959                 if sum(index is x for x in lst) == 0:  # ensure uniqueness
960                     lst.append(index)
961         return TableIndices(lst)
962 
963     @property
964     def loc(self):
965         '''
966         Return a TableLoc object that can be used for retrieving
967         rows by index in a given data range. Note that both loc
968         and iloc work only with single-column indices.
969         '''
970         return TableLoc(self)
971 
972     @property
973     def loc_indices(self):
974         """
975         Return a TableLocIndices object that can be used for retrieving
976         the row indices corresponding to given table index key value or values.
977         """
978         return TableLocIndices(self)
979 
980     @property
981     def iloc(self):
982         '''
983         Return a TableILoc object that can be used for retrieving
984         indexed rows in the order they appear in the index.
985         '''
986         return TableILoc(self)
987 
988     def add_index(self, colnames, engine=None, unique=False):
989         '''
990         Insert a new index among one or more columns.
991         If there are no indices, make this index the
992         primary table index.
993 
994         Parameters
995         ----------
996         colnames : str or list
997             List of column names (or a single column name) to index
998         engine : type or None
999             Indexing engine class to use, either `~astropy.table.SortedArray`,
1000             `~astropy.table.BST`, or `~astropy.table.SCEngine`. If the supplied
1001             argument is None (by default), use `~astropy.table.SortedArray`.
1002         unique : bool
1003             Whether the values of the index must be unique. Default is False.
1004         '''
1005         if isinstance(colnames, str):
1006             colnames = (colnames,)
1007         columns = self.columns[tuple(colnames)].values()
1008 
1009         # make sure all columns support indexing
1010         for col in columns:
1011             if not getattr(col.info, '_supports_indexing', False):
1012                 raise ValueError('Cannot create an index on column "{}", of '
1013                                  'type "{}"'.format(col.info.name, type(col)))
1014 
1015         is_primary = not self.indices
1016         index = Index(columns, engine=engine, unique=unique)
1017         sliced_index = SlicedIndex(index, slice(0, 0, None), original=True)
1018         if is_primary:
1019             self.primary_key = colnames
1020         for col in columns:
1021             col.info.indices.append(sliced_index)
1022 
1023     def remove_indices(self, colname):
1024         '''
1025         Remove all indices involving the given column.
1026         If the primary index is removed, the new primary
1027         index will be the most recently added remaining
1028         index.
1029 
1030         Parameters
1031         ----------
1032         colname : str
1033             Name of column
1034         '''
1035         col = self.columns[colname]
1036         for index in self.indices:
1037             try:
1038                 index.col_position(col.info.name)
1039             except ValueError:
1040                 pass
1041             else:
1042                 for c in index.columns:
1043                     c.info.indices.remove(index)
1044 
1045     def index_mode(self, mode):
1046         '''
1047         Return a context manager for an indexing mode.
1048 
1049         Parameters
1050         ----------
1051         mode : str
1052             Either 'freeze', 'copy_on_getitem', or 'discard_on_copy'.
1053             In 'discard_on_copy' mode,
1054             indices are not copied whenever columns or tables are copied.
1055             In 'freeze' mode, indices are not modified whenever columns are
1056             modified; at the exit of the context, indices refresh themselves
1057             based on column values. This mode is intended for scenarios in
1058             which one intends to make many additions or modifications in an
1059             indexed column.
1060             In 'copy_on_getitem' mode, indices are copied when taking column
1061             slices as well as table slices, so col[i0:i1] will preserve
1062             indices.
1063         '''
1064         return _IndexModeContext(self, mode)
1065 
1066     def __array__(self, dtype=None):
1067         """Support converting Table to np.array via np.array(table).
1068 
1069         Coercion to a different dtype via np.array(table, dtype) is not
1070         supported and will raise a ValueError.
1071         """
1072         if dtype is not None:
1073             raise ValueError('Datatype coercion is not allowed')
1074 
1075         # This limitation is because of the following unexpected result that
1076         # should have made a table copy while changing the column names.
1077         #
1078         # >>> d = astropy.table.Table([[1,2],[3,4]])
1079         # >>> np.array(d, dtype=[('a', 'i8'), ('b', 'i8')])
1080         # array([(0, 0), (0, 0)],
1081         #       dtype=[('a', '<i8'), ('b', '<i8')])
1082 
1083         out = self.as_array()
1084         return out.data if isinstance(out, np.ma.MaskedArray) else out
1085 
1086     def _check_names_dtype(self, names, dtype, n_cols):
1087         """Make sure that names and dtype are both iterable and have
1088         the same length as data.
1089         """
1090         for inp_list, inp_str in ((dtype, 'dtype'), (names, 'names')):
1091             if not isiterable(inp_list):
1092                 raise ValueError(f'{inp_str} must be a list or None')
1093 
1094         if len(names) != n_cols or len(dtype) != n_cols:
1095             raise ValueError(
1096                 'Arguments "names" and "dtype" must match number of columns')
1097 
1098     def _init_from_list_of_dicts(self, data, names, dtype, n_cols, copy):
1099         """Initialize table from a list of dictionaries representing rows."""
1100         # Define placeholder for missing values as a unique object that cannot
1101         # every occur in user data.
1102         MISSING = object()
1103 
1104         # Gather column names that exist in the input `data`.
1105         names_from_data = set()
1106         for row in data:
1107             names_from_data.update(row)
1108 
1109         if set(data[0].keys()) == names_from_data:
1110             names_from_data = list(data[0].keys())
1111         else:
1112             names_from_data = sorted(names_from_data)
1113 
1114         # Note: if set(data[0].keys()) != names_from_data, this will give an
1115         # exception later, so NO need to catch here.
1116 
1117         # Convert list of dict into dict of list (cols), keep track of missing
1118         # indexes and put in MISSING placeholders in the `cols` lists.
1119         cols = {}
1120         missing_indexes = defaultdict(list)
1121         for name in names_from_data:
1122             cols[name] = []
1123             for ii, row in enumerate(data):
1124                 try:
1125                     val = row[name]
1126                 except KeyError:
1127                     missing_indexes[name].append(ii)
1128                     val = MISSING
1129                 cols[name].append(val)
1130 
1131         # Fill the missing entries with first values
1132         if missing_indexes:
1133             for name, indexes in missing_indexes.items():
1134                 col = cols[name]
1135                 first_val = next(val for val in col if val is not MISSING)
1136                 for index in indexes:
1137                     col[index] = first_val
1138 
1139         # prepare initialization
1140         if all(name is None for name in names):
1141             names = names_from_data
1142 
1143         self._init_from_dict(cols, names, dtype, n_cols, copy)
1144 
1145         # Mask the missing values if necessary, converting columns to MaskedColumn
1146         # as needed.
1147         if missing_indexes:
1148             for name, indexes in missing_indexes.items():
1149                 col = self[name]
1150                 # Ensure that any Column subclasses with MISSING values can support
1151                 # setting masked values. As of astropy 4.0 the test condition below is
1152                 # always True since _init_from_dict cannot result in mixin columns.
1153                 if isinstance(col, Column) and not isinstance(col, MaskedColumn):
1154                     self[name] = self.MaskedColumn(col, copy=False)
1155 
1156                 # Finally do the masking in a mixin-safe way.
1157                 self[name][indexes] = np.ma.masked
1158         return
1159 
1160     def _init_from_list(self, data, names, dtype, n_cols, copy):
1161         """Initialize table from a list of column data.  A column can be a
1162         Column object, np.ndarray, mixin, or any other iterable object.
1163         """
1164         # Special case of initializing an empty table like `t = Table()`. No
1165         # action required at this point.
1166         if n_cols == 0:
1167             return
1168 
1169         cols = []
1170         default_names = _auto_names(n_cols)
1171 
1172         for col, name, default_name, dtype in zip(data, names, default_names, dtype):
1173             col = self._convert_data_to_col(col, copy, default_name, dtype, name)
1174 
1175             cols.append(col)
1176 
1177         self._init_from_cols(cols)
1178 
1179     def _convert_data_to_col(self, data, copy=True, default_name=None, dtype=None, name=None):
1180         """
1181         Convert any allowed sequence data ``col`` to a column object that can be used
1182         directly in the self.columns dict.  This could be a Column, MaskedColumn,
1183         or mixin column.
1184 
1185         The final column name is determined by::
1186 
1187             name or data.info.name or def_name
1188 
1189         If ``data`` has no ``info`` then ``name = name or def_name``.
1190 
1191         The behavior of ``copy`` for Column objects is:
1192         - copy=True: new class instance with a copy of data and deep copy of meta
1193         - copy=False: new class instance with same data and a key-only copy of meta
1194 
1195         For mixin columns:
1196         - copy=True: new class instance with copy of data and deep copy of meta
1197         - copy=False: original instance (no copy at all)
1198 
1199         Parameters
1200         ----------
1201         data : object (column-like sequence)
1202             Input column data
1203         copy : bool
1204             Make a copy
1205         default_name : str
1206             Default name
1207         dtype : np.dtype or None
1208             Data dtype
1209         name : str or None
1210             Column name
1211 
1212         Returns
1213         -------
1214         col : Column, MaskedColumn, mixin-column type
1215             Object that can be used as a column in self
1216         """
1217 
1218         data_is_mixin = self._is_mixin_for_table(data)
1219         masked_col_cls = (self.ColumnClass
1220                           if issubclass(self.ColumnClass, self.MaskedColumn)
1221                           else self.MaskedColumn)
1222 
1223         try:
1224             data0_is_mixin = self._is_mixin_for_table(data[0])
1225         except Exception:
1226             # Need broad exception, cannot predict what data[0] raises for arbitrary data
1227             data0_is_mixin = False
1228 
1229         # If the data is not an instance of Column or a mixin class, we can
1230         # check the registry of mixin 'handlers' to see if the column can be
1231         # converted to a mixin class
1232         if (handler := get_mixin_handler(data)) is not None:
1233             original_data = data
1234             data = handler(data)
1235             if not (data_is_mixin := self._is_mixin_for_table(data)):
1236                 fully_qualified_name = (original_data.__class__.__module__ + '.'
1237                                         + original_data.__class__.__name__)
1238                 raise TypeError('Mixin handler for object of type '
1239                                 f'{fully_qualified_name} '
1240                                 'did not return a valid mixin column')
1241 
1242         # Get the final column name using precedence.  Some objects may not
1243         # have an info attribute. Also avoid creating info as a side effect.
1244         if not name:
1245             if isinstance(data, Column):
1246                 name = data.name or default_name
1247             elif 'info' in getattr(data, '__dict__', ()):
1248                 name = data.info.name or default_name
1249             else:
1250                 name = default_name
1251 
1252         if isinstance(data, Column):
1253             # If self.ColumnClass is a subclass of col, then "upgrade" to ColumnClass,
1254             # otherwise just use the original class.  The most common case is a
1255             # table with masked=True and ColumnClass=MaskedColumn.  Then a Column
1256             # gets upgraded to MaskedColumn, but the converse (pre-4.0) behavior
1257             # of downgrading from MaskedColumn to Column (for non-masked table)
1258             # does not happen.
1259             col_cls = self._get_col_cls_for_table(data)
1260 
1261         elif data_is_mixin:
1262             # Copy the mixin column attributes if they exist since the copy below
1263             # may not get this attribute.
1264             col = col_copy(data, copy_indices=self._init_indices) if copy else data
1265             col.info.name = name
1266             return col
1267 
1268         elif data0_is_mixin:
1269             # Handle case of a sequence of a mixin, e.g. [1*u.m, 2*u.m].
1270             try:
1271                 col = data[0].__class__(data)
1272                 col.info.name = name
1273                 return col
1274             except Exception:
1275                 # If that didn't work for some reason, just turn it into np.array of object
1276                 data = np.array(data, dtype=object)
1277                 col_cls = self.ColumnClass
1278 
1279         elif isinstance(data, (np.ma.MaskedArray, Masked)):
1280             # Require that col_cls be a subclass of MaskedColumn, remembering
1281             # that ColumnClass could be a user-defined subclass (though more-likely
1282             # could be MaskedColumn).
1283             col_cls = masked_col_cls
1284 
1285         elif data is None:
1286             # Special case for data passed as the None object (for broadcasting
1287             # to an object column). Need to turn data into numpy `None` scalar
1288             # object, otherwise `Column` interprets data=None as no data instead
1289             # of a object column of `None`.
1290             data = np.array(None)
1291             col_cls = self.ColumnClass
1292 
1293         elif not hasattr(data, 'dtype'):
1294             # `data` is none of the above, convert to numpy array or MaskedArray
1295             # assuming only that it is a scalar or sequence or N-d nested
1296             # sequence. This function is relatively intricate and tries to
1297             # maintain performance for common cases while handling things like
1298             # list input with embedded np.ma.masked entries. If `data` is a
1299             # scalar then it gets returned unchanged so the original object gets
1300             # passed to `Column` later.
1301             data = _convert_sequence_data_to_array(data, dtype)
1302             copy = False  # Already made a copy above
1303             col_cls = masked_col_cls if isinstance(data, np.ma.MaskedArray) else self.ColumnClass
1304 
1305         else:
1306             col_cls = self.ColumnClass
1307 
1308         try:
1309             col = col_cls(name=name, data=data, dtype=dtype,
1310                           copy=copy, copy_indices=self._init_indices)
1311         except Exception:
1312             # Broad exception class since we don't know what might go wrong
1313             raise ValueError('unable to convert data to Column for Table')
1314 
1315         col = self._convert_col_for_table(col)
1316 
1317         return col
1318 
1319     def _init_from_ndarray(self, data, names, dtype, n_cols, copy):
1320         """Initialize table from an ndarray structured array"""
1321 
1322         data_names = data.dtype.names or _auto_names(n_cols)
1323         struct = data.dtype.names is not None
1324         names = [name or data_names[i] for i, name in enumerate(names)]
1325 
1326         cols = ([data[name] for name in data_names] if struct else
1327                 [data[:, i] for i in range(n_cols)])
1328 
1329         self._init_from_list(cols, names, dtype, n_cols, copy)
1330 
1331     def _init_from_dict(self, data, names, dtype, n_cols, copy):
1332         """Initialize table from a dictionary of columns"""
1333 
1334         data_list = [data[name] for name in names]
1335         self._init_from_list(data_list, names, dtype, n_cols, copy)
1336 
1337     def _get_col_cls_for_table(self, col):
1338         """Get the correct column class to use for upgrading any Column-like object.
1339 
1340         For a masked table, ensure any Column-like object is a subclass
1341         of the table MaskedColumn.
1342 
1343         For unmasked table, ensure any MaskedColumn-like object is a subclass
1344         of the table MaskedColumn.  If not a MaskedColumn, then ensure that any
1345         Column-like object is a subclass of the table Column.
1346         """
1347 
1348         col_cls = col.__class__
1349 
1350         if self.masked:
1351             if isinstance(col, Column) and not isinstance(col, self.MaskedColumn):
1352                 col_cls = self.MaskedColumn
1353         else:
1354             if isinstance(col, MaskedColumn):
1355                 if not isinstance(col, self.MaskedColumn):
1356                     col_cls = self.MaskedColumn
1357             elif isinstance(col, Column) and not isinstance(col, self.Column):
1358                 col_cls = self.Column
1359 
1360         return col_cls
1361 
1362     def _convert_col_for_table(self, col):
1363         """
1364         Make sure that all Column objects have correct base class for this type of
1365         Table.  For a base Table this most commonly means setting to
1366         MaskedColumn if the table is masked.  Table subclasses like QTable
1367         override this method.
1368         """
1369         if isinstance(col, Column) and not isinstance(col, self.ColumnClass):
1370             col_cls = self._get_col_cls_for_table(col)
1371             if col_cls is not col.__class__:
1372                 col = col_cls(col, copy=False)
1373 
1374         return col
1375 
1376     def _init_from_cols(self, cols):
1377         """Initialize table from a list of Column or mixin objects"""
1378 
1379         lengths = {len(col) for col in cols}
1380         if len(lengths) > 1:
1381             raise ValueError(f'Inconsistent data column lengths: {lengths}')
1382 
1383         # Make sure that all Column-based objects have correct class.  For
1384         # plain Table this is self.ColumnClass, but for instance QTable will
1385         # convert columns with units to a Quantity mixin.
1386         newcols = [self._convert_col_for_table(col) for col in cols]
1387         self._make_table_from_cols(self, newcols)
1388 
1389         # Deduplicate indices.  It may happen that after pickling or when
1390         # initing from an existing table that column indices which had been
1391         # references to a single index object got *copied* into an independent
1392         # object.  This results in duplicates which will cause downstream problems.
1393         index_dict = {}
1394         for col in self.itercols():
1395             for i, index in enumerate(col.info.indices or []):
1396                 names = tuple(ind_col.info.name for ind_col in index.columns)
1397                 if names in index_dict:
1398                     col.info.indices[i] = index_dict[names]
1399                 else:
1400                     index_dict[names] = index
1401 
1402     def _new_from_slice(self, slice_):
1403         """Create a new table as a referenced slice from self."""
1404 
1405         table = self.__class__(masked=self.masked)
1406         if self.meta:
1407             table.meta = self.meta.copy()  # Shallow copy for slice
1408         table.primary_key = self.primary_key
1409 
1410         newcols = []
1411         for col in self.columns.values():
1412             newcol = col[slice_]
1413 
1414             # Note in line below, use direct attribute access to col.indices for Column
1415             # instances instead of the generic col.info.indices.  This saves about 4 usec
1416             # per column.
1417             if (col if isinstance(col, Column) else col.info).indices:
1418                 # TODO : as far as I can tell the only purpose of setting _copy_indices
1419                 # here is to communicate that to the initial test in `slice_indices`.
1420                 # Why isn't that just sent as an arg to the function?
1421                 col.info._copy_indices = self._copy_indices
1422                 newcol = col.info.slice_indices(newcol, slice_, len(col))
1423 
1424                 # Don't understand why this is forcing a value on the original column.
1425                 # Normally col.info does not even have a _copy_indices attribute.  Tests
1426                 # still pass if this line is deleted.  (Each col.info attribute access
1427                 # is expensive).
1428                 col.info._copy_indices = True
1429 
1430             newcols.append(newcol)
1431 
1432         self._make_table_from_cols(table, newcols, verify=False, names=self.columns.keys())
1433         return table
1434 
1435     @staticmethod
1436     def _make_table_from_cols(table, cols, verify=True, names=None):
1437         """
1438         Make ``table`` in-place so that it represents the given list of ``cols``.
1439         """
1440         if names is None:
1441             names = [col.info.name for col in cols]
1442 
1443         # Note: we do not test for len(names) == len(cols) if names is not None.  In that
1444         # case the function is being called by from "trusted" source (e.g. right above here)
1445         # that is assumed to provide valid inputs.  In that case verify=False.
1446 
1447         if verify:
1448             if None in names:
1449                 raise TypeError('Cannot have None for column name')
1450             if len(set(names)) != len(names):
1451                 raise ValueError('Duplicate column names')
1452 
1453         table.columns = table.TableColumns((name, col) for name, col in zip(names, cols))
1454 
1455         for col in cols:
1456             table._set_col_parent_table_and_mask(col)
1457 
1458     def _set_col_parent_table_and_mask(self, col):
1459         """
1460         Set ``col.parent_table = self`` and force ``col`` to have ``mask``
1461         attribute if the table is masked and ``col.mask`` does not exist.
1462         """
1463         # For Column instances it is much faster to do direct attribute access
1464         # instead of going through .info
1465         col_info = col if isinstance(col, Column) else col.info
1466         col_info.parent_table = self
1467 
1468         # Legacy behavior for masked table
1469         if self.masked and not hasattr(col, 'mask'):
1470             col.mask = FalseArray(col.shape)
1471 
1472     def itercols(self):
1473         """
1474         Iterate over the columns of this table.
1475 
1476         Examples
1477         --------
1478 
1479         To iterate over the columns of a table::
1480 
1481             >>> t = Table([[1], [2]])
1482             >>> for col in t.itercols():
1483             ...     print(col)
1484             col0
1485             ----
1486                1
1487             col1
1488             ----
1489                2
1490 
1491         Using ``itercols()`` is similar to  ``for col in t.columns.values()``
1492         but is syntactically preferred.
1493         """
1494         for colname in self.columns:
1495             yield self[colname]
1496 
1497     def _base_repr_(self, html=False, descr_vals=None, max_width=None,
1498                     tableid=None, show_dtype=True, max_lines=None,
1499                     tableclass=None):
1500         if descr_vals is None:
1501             descr_vals = [self.__class__.__name__]
1502             if self.masked:
1503                 descr_vals.append('masked=True')
1504             descr_vals.append(f'length={len(self)}')
1505 
1506         descr = ' '.join(descr_vals)
1507         if html:
1508             from astropy.utils.xml.writer import xml_escape
1509             descr = f'<i>{xml_escape(descr)}</i>\n'
1510         else:
1511             descr = f'<{descr}>\n'
1512 
1513         if tableid is None:
1514             tableid = f'table{id(self)}'
1515 
1516         data_lines, outs = self.formatter._pformat_table(
1517             self, tableid=tableid, html=html, max_width=max_width,
1518             show_name=True, show_unit=None, show_dtype=show_dtype,
1519             max_lines=max_lines, tableclass=tableclass)
1520 
1521         out = descr + '\n'.join(data_lines)
1522 
1523         return out
1524 
1525     def _repr_html_(self):
1526         out = self._base_repr_(html=True, max_width=-1,
1527                                tableclass=conf.default_notebook_table_class)
1528         # Wrap <table> in <div>. This follows the pattern in pandas and allows
1529         # table to be scrollable horizontally in VS Code notebook display.
1530         out = f'<div>{out}</div>'
1531         return out
1532 
1533     def __repr__(self):
1534         return self._base_repr_(html=False, max_width=None)
1535 
1536     def __str__(self):
1537         return '\n'.join(self.pformat())
1538 
1539     def __bytes__(self):
1540         return str(self).encode('utf-8')
1541 
1542     @property
1543     def has_mixin_columns(self):
1544         """
1545         True if table has any mixin columns (defined as columns that are not Column
1546         subclasses).
1547         """
1548         return any(has_info_class(col, MixinInfo) for col in self.columns.values())
1549 
1550     @property
1551     def has_masked_columns(self):
1552         """True if table has any ``MaskedColumn`` columns.
1553 
1554         This does not check for mixin columns that may have masked values, use the
1555         ``has_masked_values`` property in that case.
1556 
1557         """
1558         return any(isinstance(col, MaskedColumn) for col in self.itercols())
1559 
1560     @property
1561     def has_masked_values(self):
1562         """True if column in the table has values which are masked.
1563 
1564         This may be relatively slow for large tables as it requires checking the mask
1565         values of each column.
1566         """
1567         for col in self.itercols():
1568             if hasattr(col, 'mask') and np.any(col.mask):
1569                 return True
1570         else:
1571             return False
1572 
1573     def _is_mixin_for_table(self, col):
1574         """
1575         Determine if ``col`` should be added to the table directly as
1576         a mixin column.
1577         """
1578         if isinstance(col, BaseColumn):
1579             return False
1580 
1581         # Is it a mixin but not [Masked]Quantity (which gets converted to
1582         # [Masked]Column with unit set).
1583         return has_info_class(col, MixinInfo) and not has_info_class(col, QuantityInfo)
1584 
1585     @format_doc(_pprint_docs)
1586     def pprint(self, max_lines=None, max_width=None, show_name=True,
1587                show_unit=None, show_dtype=False, align=None):
1588         """Print a formatted string representation of the table.
1589 
1590         If no value of ``max_lines`` is supplied then the height of the
1591         screen terminal is used to set ``max_lines``.  If the terminal
1592         height cannot be determined then the default is taken from the
1593         configuration item ``astropy.conf.max_lines``.  If a negative
1594         value of ``max_lines`` is supplied then there is no line limit
1595         applied.
1596 
1597         The same applies for max_width except the configuration item is
1598         ``astropy.conf.max_width``.
1599 
1600         """
1601         lines, outs = self.formatter._pformat_table(self, max_lines, max_width,
1602                                                     show_name=show_name, show_unit=show_unit,
1603                                                     show_dtype=show_dtype, align=align)
1604         if outs['show_length']:
1605             lines.append(f'Length = {len(self)} rows')
1606 
1607         n_header = outs['n_header']
1608 
1609         for i, line in enumerate(lines):
1610             if i < n_header:
1611                 color_print(line, 'red')
1612             else:
1613                 print(line)
1614 
1615     @format_doc(_pprint_docs)
1616     def pprint_all(self, max_lines=-1, max_width=-1, show_name=True,
1617                    show_unit=None, show_dtype=False, align=None):
1618         """Print a formatted string representation of the entire table.
1619 
1620         This method is the same as `astropy.table.Table.pprint` except that
1621         the default ``max_lines`` and ``max_width`` are both -1 so that by
1622         default the entire table is printed instead of restricting to the size
1623         of the screen terminal.
1624 
1625         """
1626         return self.pprint(max_lines, max_width, show_name,
1627                            show_unit, show_dtype, align)
1628 
1629     def _make_index_row_display_table(self, index_row_name):
1630         if index_row_name not in self.columns:
1631             idx_col = self.ColumnClass(name=index_row_name, data=np.arange(len(self)))
1632             return self.__class__([idx_col] + list(self.columns.values()),
1633                                   copy=False)
1634         else:
1635             return self
1636 
1637     def show_in_notebook(self, tableid=None, css=None, display_length=50,
1638                          table_class='astropy-default', show_row_index='idx'):
1639         """Render the table in HTML and show it in the IPython notebook.
1640 
1641         Parameters
1642         ----------
1643         tableid : str or None
1644             An html ID tag for the table.  Default is ``table{id}-XXX``, where
1645             id is the unique integer id of the table object, id(self), and XXX
1646             is a random number to avoid conflicts when printing the same table
1647             multiple times.
1648         table_class : str or None
1649             A string with a list of HTML classes used to style the table.
1650             The special default string ('astropy-default') means that the string
1651             will be retrieved from the configuration item
1652             ``astropy.table.default_notebook_table_class``. Note that these
1653             table classes may make use of bootstrap, as this is loaded with the
1654             notebook.  See `this page <https://getbootstrap.com/css/#tables>`_
1655             for the list of classes.
1656         css : str
1657             A valid CSS string declaring the formatting for the table. Defaults
1658             to ``astropy.table.jsviewer.DEFAULT_CSS_NB``.
1659         display_length : int, optional
1660             Number or rows to show. Defaults to 50.
1661         show_row_index : str or False
1662             If this does not evaluate to False, a column with the given name
1663             will be added to the version of the table that gets displayed.
1664             This new column shows the index of the row in the table itself,
1665             even when the displayed table is re-sorted by another column. Note
1666             that if a column with this name already exists, this option will be
1667             ignored. Defaults to "idx".
1668 
1669         Notes
1670         -----
1671         Currently, unlike `show_in_browser` (with ``jsviewer=True``), this
1672         method needs to access online javascript code repositories.  This is due
1673         to modern browsers' limitations on accessing local files.  Hence, if you
1674         call this method while offline (and don't have a cached version of
1675         jquery and jquery.dataTables), you will not get the jsviewer features.
1676         """
1677 
1678         from .jsviewer import JSViewer
1679         from IPython.display import HTML
1680 
1681         if tableid is None:
1682             tableid = f'table{id(self)}-{np.random.randint(1, 1e6)}'
1683 
1684         jsv = JSViewer(display_length=display_length)
1685         if show_row_index:
1686             display_table = self._make_index_row_display_table(show_row_index)
1687         else:
1688             display_table = self
1689         if table_class == 'astropy-default':
1690             table_class = conf.default_notebook_table_class
1691         html = display_table._base_repr_(html=True, max_width=-1, tableid=tableid,
1692                                          max_lines=-1, show_dtype=False,
1693                                          tableclass=table_class)
1694 
1695         columns = display_table.columns.values()
1696         sortable_columns = [i for i, col in enumerate(columns)
1697                             if col.info.dtype.kind in 'iufc']
1698         html += jsv.ipynb(tableid, css=css, sort_columns=sortable_columns)
1699         return HTML(html)
1700 
1701     def show_in_browser(self, max_lines=5000, jsviewer=False,
1702                         browser='default', jskwargs={'use_local_files': True},
1703                         tableid=None, table_class="display compact",
1704                         css=None, show_row_index='idx'):
1705         """Render the table in HTML and show it in a web browser.
1706 
1707         Parameters
1708         ----------
1709         max_lines : int
1710             Maximum number of rows to export to the table (set low by default
1711             to avoid memory issues, since the browser view requires duplicating
1712             the table in memory).  A negative value of ``max_lines`` indicates
1713             no row limit.
1714         jsviewer : bool
1715             If `True`, prepends some javascript headers so that the table is
1716             rendered as a `DataTables <https://datatables.net>`_ data table.
1717             This allows in-browser searching & sorting.
1718         browser : str
1719             Any legal browser name, e.g. ``'firefox'``, ``'chrome'``,
1720             ``'safari'`` (for mac, you may need to use ``'open -a
1721             "/Applications/Google Chrome.app" {}'`` for Chrome).  If
1722             ``'default'``, will use the system default browser.
1723         jskwargs : dict
1724             Passed to the `astropy.table.JSViewer` init. Defaults to
1725             ``{'use_local_files': True}`` which means that the JavaScript
1726             libraries will be served from local copies.
1727         tableid : str or None
1728             An html ID tag for the table.  Default is ``table{id}``, where id
1729             is the unique integer id of the table object, id(self).
1730         table_class : str or None
1731             A string with a list of HTML classes used to style the table.
1732             Default is "display compact", and other possible values can be
1733             found in https://www.datatables.net/manual/styling/classes
1734         css : str
1735             A valid CSS string declaring the formatting for the table. Defaults
1736             to ``astropy.table.jsviewer.DEFAULT_CSS``.
1737         show_row_index : str or False
1738             If this does not evaluate to False, a column with the given name
1739             will be added to the version of the table that gets displayed.
1740             This new column shows the index of the row in the table itself,
1741             even when the displayed table is re-sorted by another column. Note
1742             that if a column with this name already exists, this option will be
1743             ignored. Defaults to "idx".
1744         """
1745 
1746         import os
1747         import webbrowser
1748         import tempfile
1749         from .jsviewer import DEFAULT_CSS
1750         from urllib.parse import urljoin
1751         from urllib.request import pathname2url
1752 
1753         if css is None:
1754             css = DEFAULT_CSS
1755 
1756         # We can't use NamedTemporaryFile here because it gets deleted as
1757         # soon as it gets garbage collected.
1758         tmpdir = tempfile.mkdtemp()
1759         path = os.path.join(tmpdir, 'table.html')
1760 
1761         with open(path, 'w') as tmp:
1762             if jsviewer:
1763                 if show_row_index:
1764                     display_table = self._make_index_row_display_table(show_row_index)
1765                 else:
1766                     display_table = self
1767                 display_table.write(tmp, format='jsviewer', css=css,
1768                                     max_lines=max_lines, jskwargs=jskwargs,
1769                                     table_id=tableid, table_class=table_class)
1770             else:
1771                 self.write(tmp, format='html')
1772 
1773         try:
1774             br = webbrowser.get(None if browser == 'default' else browser)
1775         except webbrowser.Error:
1776             log.error(f"Browser '{browser}' not found.")
1777         else:
1778             br.open(urljoin('file:', pathname2url(path)))
1779 
1780     @format_doc(_pformat_docs, id="{id}")
1781     def pformat(self, max_lines=None, max_width=None, show_name=True,
1782                 show_unit=None, show_dtype=False, html=False, tableid=None,
1783                 align=None, tableclass=None):
1784         """Return a list of lines for the formatted string representation of
1785         the table.
1786 
1787         If no value of ``max_lines`` is supplied then the height of the
1788         screen terminal is used to set ``max_lines``.  If the terminal
1789         height cannot be determined then the default is taken from the
1790         configuration item ``astropy.conf.max_lines``.  If a negative
1791         value of ``max_lines`` is supplied then there is no line limit
1792         applied.
1793 
1794         The same applies for ``max_width`` except the configuration item  is
1795         ``astropy.conf.max_width``.
1796 
1797         """
1798 
1799         lines, outs = self.formatter._pformat_table(
1800             self, max_lines, max_width, show_name=show_name,
1801             show_unit=show_unit, show_dtype=show_dtype, html=html,
1802             tableid=tableid, tableclass=tableclass, align=align)
1803 
1804         if outs['show_length']:
1805             lines.append(f'Length = {len(self)} rows')
1806 
1807         return lines
1808 
1809     @format_doc(_pformat_docs, id="{id}")
1810     def pformat_all(self, max_lines=-1, max_width=-1, show_name=True,
1811                     show_unit=None, show_dtype=False, html=False, tableid=None,
1812                     align=None, tableclass=None):
1813         """Return a list of lines for the formatted string representation of
1814         the entire table.
1815 
1816         If no value of ``max_lines`` is supplied then the height of the
1817         screen terminal is used to set ``max_lines``.  If the terminal
1818         height cannot be determined then the default is taken from the
1819         configuration item ``astropy.conf.max_lines``.  If a negative
1820         value of ``max_lines`` is supplied then there is no line limit
1821         applied.
1822 
1823         The same applies for ``max_width`` except the configuration item  is
1824         ``astropy.conf.max_width``.
1825 
1826         """
1827 
1828         return self.pformat(max_lines, max_width, show_name,
1829                             show_unit, show_dtype, html, tableid,
1830                             align, tableclass)
1831 
1832     def more(self, max_lines=None, max_width=None, show_name=True,
1833              show_unit=None, show_dtype=False):
1834         """Interactively browse table with a paging interface.
1835 
1836         Supported keys::
1837 
1838           f, <space> : forward one page
1839           b : back one page
1840           r : refresh same page
1841           n : next row
1842           p : previous row
1843           < : go to beginning
1844           > : go to end
1845           q : quit browsing
1846           h : print this help
1847 
1848         Parameters
1849         ----------
1850         max_lines : int
1851             Maximum number of lines in table output
1852 
1853         max_width : int or None
1854             Maximum character width of output
1855 
1856         show_name : bool
1857             Include a header row for column names. Default is True.
1858 
1859         show_unit : bool
1860             Include a header row for unit.  Default is to show a row
1861             for units only if one or more columns has a defined value
1862             for the unit.
1863 
1864         show_dtype : bool
1865             Include a header row for column dtypes. Default is False.
1866         """
1867         self.formatter._more_tabcol(self, max_lines, max_width, show_name=show_name,
1868                                     show_unit=show_unit, show_dtype=show_dtype)
1869 
1870     def __getitem__(self, item):
1871         if isinstance(item, str):
1872             return self.columns[item]
1873         elif isinstance(item, (int, np.integer)):
1874             return self.Row(self, item)
1875         elif (isinstance(item, np.ndarray) and item.shape == () and item.dtype.kind == 'i'):
1876             return self.Row(self, item.item())
1877         elif self._is_list_or_tuple_of_str(item):
1878             out = self.__class__([self[x] for x in item],
1879                                  copy_indices=self._copy_indices)
1880             out._groups = groups.TableGroups(out, indices=self.groups._indices,
1881                                              keys=self.groups._keys)
1882             out.meta = self.meta.copy()  # Shallow copy for meta
1883             return out
1884         elif ((isinstance(item, np.ndarray) and item.size == 0)
1885               or (isinstance(item, (tuple, list)) and not item)):
1886             # If item is an empty array/list/tuple then return the table with no rows
1887             return self._new_from_slice([])
1888         elif (isinstance(item, slice)
1889               or isinstance(item, np.ndarray)
1890               or isinstance(item, list)
1891               or isinstance(item, tuple) and all(isinstance(x, np.ndarray)
1892                                                  for x in item)):
1893             # here for the many ways to give a slice; a tuple of ndarray
1894             # is produced by np.where, as in t[np.where(t['a'] > 2)]
1895             # For all, a new table is constructed with slice of all columns
1896             return self._new_from_slice(item)
1897         else:
1898             raise ValueError(f'Illegal type {type(item)} for table item access')
1899 
1900     def __setitem__(self, item, value):
1901         # If the item is a string then it must be the name of a column.
1902         # If that column doesn't already exist then create it now.
1903         if isinstance(item, str) and item not in self.colnames:
1904             self.add_column(value, name=item, copy=True)
1905 
1906         else:
1907             n_cols = len(self.columns)
1908 
1909             if isinstance(item, str):
1910                 # Set an existing column by first trying to replace, and if
1911                 # this fails do an in-place update.  See definition of mask
1912                 # property for discussion of the _setitem_inplace attribute.
1913                 if (not getattr(self, '_setitem_inplace', False)
1914                         and not conf.replace_inplace):
1915                     try:
1916                         self._replace_column_warnings(item, value)
1917                         return
1918                     except Exception:
1919                         pass
1920                 self.columns[item][:] = value
1921 
1922             elif isinstance(item, (int, np.integer)):
1923                 self._set_row(idx=item, colnames=self.colnames, vals=value)
1924 
1925             elif (isinstance(item, slice)
1926                   or isinstance(item, np.ndarray)
1927                   or isinstance(item, list)
1928                   or (isinstance(item, tuple)  # output from np.where
1929                       and all(isinstance(x, np.ndarray) for x in item))):
1930 
1931                 if isinstance(value, Table):
1932                     vals = (col for col in value.columns.values())
1933 
1934                 elif isinstance(value, np.ndarray) and value.dtype.names:
1935                     vals = (value[name] for name in value.dtype.names)
1936 
1937                 elif np.isscalar(value):
1938                     vals = itertools.repeat(value, n_cols)
1939 
1940                 else:  # Assume this is an iterable that will work
1941                     if len(value) != n_cols:
1942                         raise ValueError('Right side value needs {} elements (one for each column)'
1943                                          .format(n_cols))
1944                     vals = value
1945 
1946                 for col, val in zip(self.columns.values(), vals):
1947                     col[item] = val
1948 
1949             else:
1950                 raise ValueError(f'Illegal type {type(item)} for table item access')
1951 
1952     def __delitem__(self, item):
1953         if isinstance(item, str):
1954             self.remove_column(item)
1955         elif isinstance(item, (int, np.integer)):
1956             self.remove_row(item)
1957         elif (isinstance(item, (list, tuple, np.ndarray))
1958               and all(isinstance(x, str) for x in item)):
1959             self.remove_columns(item)
1960         elif (isinstance(item, (list, np.ndarray))
1961               and np.asarray(item).dtype.kind == 'i'):
1962             self.remove_rows(item)
1963         elif isinstance(item, slice):
1964             self.remove_rows(item)
1965         else:
1966             raise IndexError('illegal key or index value')
1967 
1968     def _ipython_key_completions_(self):
1969         return self.colnames
1970 
1971     def field(self, item):
1972         """Return column[item] for recarray compatibility."""
1973         return self.columns[item]
1974 
1975     @property
1976     def masked(self):
1977         return self._masked
1978 
1979     @masked.setter
1980     def masked(self, masked):
1981         raise Exception('Masked attribute is read-only (use t = Table(t, masked=True)'
1982                         ' to convert to a masked table)')
1983 
1984     def _set_masked(self, masked):
1985         """
1986         Set the table masked property.
1987 
1988         Parameters
1989         ----------
1990         masked : bool
1991             State of table masking (`True` or `False`)
1992         """
1993         if masked in [True, False, None]:
1994             self._masked = masked
1995         else:
1996             raise ValueError("masked should be one of True, False, None")
1997 
1998         self._column_class = self.MaskedColumn if self._masked else self.Column
1999 
2000     @property
2001     def ColumnClass(self):
2002         if self._column_class is None:
2003             return self.Column
2004         else:
2005             return self._column_class
2006 
2007     @property
2008     def dtype(self):
2009         return np.dtype([descr(col) for col in self.columns.values()])
2010 
2011     @property
2012     def colnames(self):
2013         return list(self.columns.keys())
2014 
2015     @staticmethod
2016     def _is_list_or_tuple_of_str(names):
2017         """Check that ``names`` is a tuple or list of strings"""
2018         return (isinstance(names, (tuple, list)) and names
2019                 and all(isinstance(x, str) for x in names))
2020 
2021     def keys(self):
2022         return list(self.columns.keys())
2023 
2024     def values(self):
2025         return self.columns.values()
2026 
2027     def items(self):
2028         return self.columns.items()
2029 
2030     def __len__(self):
2031         # For performance reasons (esp. in Row) cache the first column name
2032         # and use that subsequently for the table length.  If might not be
2033         # available yet or the column might be gone now, in which case
2034         # try again in the except block.
2035         try:
2036             return len(OrderedDict.__getitem__(self.columns, self._first_colname))
2037         except (AttributeError, KeyError):
2038             if len(self.columns) == 0:
2039                 return 0
2040 
2041             # Get the first column name
2042             self._first_colname = next(iter(self.columns))
2043             return len(self.columns[self._first_colname])
2044 
2045     def index_column(self, name):
2046         """
2047         Return the positional index of column ``name``.
2048 
2049         Parameters
2050         ----------
2051         name : str
2052             column name
2053 
2054         Returns
2055         -------
2056         index : int
2057             Positional index of column ``name``.
2058 
2059         Examples
2060         --------
2061         Create a table with three columns 'a', 'b' and 'c'::
2062 
2063             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2064             ...           names=('a', 'b', 'c'))
2065             >>> print(t)
2066              a   b   c
2067             --- --- ---
2068               1 0.1   x
2069               2 0.2   y
2070               3 0.3   z
2071 
2072         Get index of column 'b' of the table::
2073 
2074             >>> t.index_column('b')
2075             1
2076         """
2077         try:
2078             return self.colnames.index(name)
2079         except ValueError:
2080             raise ValueError(f"Column {name} does not exist")
2081 
2082     def add_column(self, col, index=None, name=None, rename_duplicate=False, copy=True,
2083                    default_name=None):
2084         """
2085         Add a new column to the table using ``col`` as input.  If ``index``
2086         is supplied then insert column before ``index`` position
2087         in the list of columns, otherwise append column to the end
2088         of the list.
2089 
2090         The ``col`` input can be any data object which is acceptable as a
2091         `~astropy.table.Table` column object or can be converted.  This includes
2092         mixin columns and scalar or length=1 objects which get broadcast to match
2093         the table length.
2094 
2095         To add several columns at once use ``add_columns()`` or simply call
2096         ``add_column()`` for each one.  There is very little performance difference
2097         in the two approaches.
2098 
2099         Parameters
2100         ----------
2101         col : object
2102             Data object for the new column
2103         index : int or None
2104             Insert column before this position or at end (default).
2105         name : str
2106             Column name
2107         rename_duplicate : bool
2108             Uniquify column name if it already exist. Default is False.
2109         copy : bool
2110             Make a copy of the new column. Default is True.
2111         default_name : str or None
2112             Name to use if both ``name`` and ``col.info.name`` are not available.
2113             Defaults to ``col{number_of_columns}``.
2114 
2115         Examples
2116         --------
2117         Create a table with two columns 'a' and 'b', then create a third column 'c'
2118         and append it to the end of the table::
2119 
2120             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2121             >>> col_c = Column(name='c', data=['x', 'y'])
2122             >>> t.add_column(col_c)
2123             >>> print(t)
2124              a   b   c
2125             --- --- ---
2126               1 0.1   x
2127               2 0.2   y
2128 
2129         Add column 'd' at position 1. Note that the column is inserted
2130         before the given index::
2131 
2132             >>> t.add_column(['a', 'b'], name='d', index=1)
2133             >>> print(t)
2134              a   d   b   c
2135             --- --- --- ---
2136               1   a 0.1   x
2137               2   b 0.2   y
2138 
2139         Add second column named 'b' with rename_duplicate::
2140 
2141             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2142             >>> t.add_column(1.1, name='b', rename_duplicate=True)
2143             >>> print(t)
2144              a   b  b_1
2145             --- --- ---
2146               1 0.1 1.1
2147               2 0.2 1.1
2148 
2149         Add an unnamed column or mixin object in the table using a default name
2150         or by specifying an explicit name with ``name``. Name can also be overridden::
2151 
2152             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2153             >>> t.add_column(['a', 'b'])
2154             >>> t.add_column(col_c, name='d')
2155             >>> print(t)
2156              a   b  col2  d
2157             --- --- ---- ---
2158               1 0.1    a   x
2159               2 0.2    b   y
2160         """
2161         if default_name is None:
2162             default_name = f'col{len(self.columns)}'
2163 
2164         # Convert col data to acceptable object for insertion into self.columns.
2165         # Note that along with the lines above and below, this allows broadcasting
2166         # of scalars to the correct shape for adding to table.
2167         col = self._convert_data_to_col(col, name=name, copy=copy,
2168                                         default_name=default_name)
2169 
2170         # Assigning a scalar column to an empty table should result in an
2171         # exception (see #3811).
2172         if col.shape == () and len(self) == 0:
2173             raise TypeError('Empty table cannot have column set to scalar value')
2174         # Make col data shape correct for scalars.  The second test is to allow
2175         # broadcasting an N-d element to a column, e.g. t['new'] = [[1, 2]].
2176         elif (col.shape == () or col.shape[0] == 1) and len(self) > 0:
2177             new_shape = (len(self),) + getattr(col, 'shape', ())[1:]
2178             if isinstance(col, np.ndarray):
2179                 col = np.broadcast_to(col, shape=new_shape,
2180                                       subok=True)
2181             elif isinstance(col, ShapedLikeNDArray):
2182                 col = col._apply(np.broadcast_to, shape=new_shape,
2183                                  subok=True)
2184 
2185             # broadcast_to() results in a read-only array.  Apparently it only changes
2186             # the view to look like the broadcasted array.  So copy.
2187             col = col_copy(col)
2188 
2189         name = col.info.name
2190 
2191         # Ensure that new column is the right length
2192         if len(self.columns) > 0 and len(col) != len(self):
2193             raise ValueError('Inconsistent data column lengths')
2194 
2195         if rename_duplicate:
2196             orig_name = name
2197             i = 1
2198             while name in self.columns:
2199                 # Iterate until a unique name is found
2200                 name = orig_name + '_' + str(i)
2201                 i += 1
2202             col.info.name = name
2203 
2204         # Set col parent_table weakref and ensure col has mask attribute if table.masked
2205         self._set_col_parent_table_and_mask(col)
2206 
2207         # Add new column as last column
2208         self.columns[name] = col
2209 
2210         if index is not None:
2211             # Move the other cols to the right of the new one
2212             move_names = self.colnames[index:-1]
2213             for move_name in move_names:
2214                 self.columns.move_to_end(move_name, last=True)
2215 
2216     def add_columns(self, cols, indexes=None, names=None, copy=True, rename_duplicate=False):
2217         """
2218         Add a list of new columns the table using ``cols`` data objects.  If a
2219         corresponding list of ``indexes`` is supplied then insert column
2220         before each ``index`` position in the *original* list of columns,
2221         otherwise append columns to the end of the list.
2222 
2223         The ``cols`` input can include any data objects which are acceptable as
2224         `~astropy.table.Table` column objects or can be converted.  This includes
2225         mixin columns and scalar or length=1 objects which get broadcast to match
2226         the table length.
2227 
2228         From a performance perspective there is little difference between calling
2229         this method once or looping over the new columns and calling ``add_column()``
2230         for each column.
2231 
2232         Parameters
2233         ----------
2234         cols : list of object
2235             List of data objects for the new columns
2236         indexes : list of int or None
2237             Insert column before this position or at end (default).
2238         names : list of str
2239             Column names
2240         copy : bool
2241             Make a copy of the new columns. Default is True.
2242         rename_duplicate : bool
2243             Uniquify new column names if they duplicate the existing ones.
2244             Default is False.
2245 
2246         See Also
2247         --------
2248         astropy.table.hstack, update, replace_column
2249 
2250         Examples
2251         --------
2252         Create a table with two columns 'a' and 'b', then create columns 'c' and 'd'
2253         and append them to the end of the table::
2254 
2255             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2256             >>> col_c = Column(name='c', data=['x', 'y'])
2257             >>> col_d = Column(name='d', data=['u', 'v'])
2258             >>> t.add_columns([col_c, col_d])
2259             >>> print(t)
2260              a   b   c   d
2261             --- --- --- ---
2262               1 0.1   x   u
2263               2 0.2   y   v
2264 
2265         Add column 'c' at position 0 and column 'd' at position 1. Note that
2266         the columns are inserted before the given position::
2267 
2268             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2269             >>> t.add_columns([['x', 'y'], ['u', 'v']], names=['c', 'd'],
2270             ...               indexes=[0, 1])
2271             >>> print(t)
2272              c   a   d   b
2273             --- --- --- ---
2274               x   1   u 0.1
2275               y   2   v 0.2
2276 
2277         Add second column 'b' and column 'c' with ``rename_duplicate``::
2278 
2279             >>> t = Table([[1, 2], [0.1, 0.2]], names=('a', 'b'))
2280             >>> t.add_columns([[1.1, 1.2], ['x', 'y']], names=('b', 'c'),
2281             ...               rename_duplicate=True)
2282             >>> print(t)
2283              a   b  b_1  c
2284             --- --- --- ---
2285               1 0.1 1.1  x
2286               2 0.2 1.2  y
2287 
2288         Add unnamed columns or mixin objects in the table using default names
2289         or by specifying explicit names with ``names``. Names can also be overridden::
2290 
2291             >>> t = Table()
2292             >>> col_b = Column(name='b', data=['u', 'v'])
2293             >>> t.add_columns([[1, 2], col_b])
2294             >>> t.add_columns([[3, 4], col_b], names=['c', 'd'])
2295             >>> print(t)
2296             col0  b   c   d
2297             ---- --- --- ---
2298                1   u   3   u
2299                2   v   4   v
2300         """
2301         if indexes is None:
2302             indexes = [len(self.columns)] * len(cols)
2303         elif len(indexes) != len(cols):
2304             raise ValueError('Number of indexes must match number of cols')
2305 
2306         if names is None:
2307             names = (None,) * len(cols)
2308         elif len(names) != len(cols):
2309             raise ValueError('Number of names must match number of cols')
2310 
2311         default_names = [f'col{ii + len(self.columns)}'
2312                          for ii in range(len(cols))]
2313 
2314         for ii in reversed(np.argsort(indexes)):
2315             self.add_column(cols[ii], index=indexes[ii], name=names[ii],
2316                             default_name=default_names[ii],
2317                             rename_duplicate=rename_duplicate, copy=copy)
2318 
2319     def _replace_column_warnings(self, name, col):
2320         """
2321         Same as replace_column but issues warnings under various circumstances.
2322         """
2323         warns = conf.replace_warnings
2324         refcount = None
2325         old_col = None
2326 
2327         if 'refcount' in warns and name in self.colnames:
2328             refcount = sys.getrefcount(self[name])
2329 
2330         if name in self.colnames:
2331             old_col = self[name]
2332 
2333         # This may raise an exception (e.g. t['a'] = 1) in which case none of
2334         # the downstream code runs.
2335         self.replace_column(name, col)
2336 
2337         if 'always' in warns:
2338             warnings.warn(f"replaced column '{name}'",
2339                           TableReplaceWarning, stacklevel=3)
2340 
2341         if 'slice' in warns:
2342             try:
2343                 # Check for ndarray-subclass slice.  An unsliced instance
2344                 # has an ndarray for the base while sliced has the same class
2345                 # as parent.
2346                 if isinstance(old_col.base, old_col.__class__):
2347                     msg = ("replaced column '{}' which looks like an array slice. "
2348                            "The new column no longer shares memory with the "
2349                            "original array.".format(name))
2350                     warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2351             except AttributeError:
2352                 pass
2353 
2354         if 'refcount' in warns:
2355             # Did reference count change?
2356             new_refcount = sys.getrefcount(self[name])
2357             if refcount != new_refcount:
2358                 msg = ("replaced column '{}' and the number of references "
2359                        "to the column changed.".format(name))
2360                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2361 
2362         if 'attributes' in warns:
2363             # Any of the standard column attributes changed?
2364             changed_attrs = []
2365             new_col = self[name]
2366             # Check base DataInfo attributes that any column will have
2367             for attr in DataInfo.attr_names:
2368                 if getattr(old_col.info, attr) != getattr(new_col.info, attr):
2369                     changed_attrs.append(attr)
2370 
2371             if changed_attrs:
2372                 msg = ("replaced column '{}' and column attributes {} changed."
2373                        .format(name, changed_attrs))
2374                 warnings.warn(msg, TableReplaceWarning, stacklevel=3)
2375 
2376     def replace_column(self, name, col, copy=True):
2377         """
2378         Replace column ``name`` with the new ``col`` object.
2379 
2380         The behavior of ``copy`` for Column objects is:
2381         - copy=True: new class instance with a copy of data and deep copy of meta
2382         - copy=False: new class instance with same data and a key-only copy of meta
2383 
2384         For mixin columns:
2385         - copy=True: new class instance with copy of data and deep copy of meta
2386         - copy=False: original instance (no copy at all)
2387 
2388         Parameters
2389         ----------
2390         name : str
2391             Name of column to replace
2392         col : `~astropy.table.Column` or `~numpy.ndarray` or sequence
2393             New column object to replace the existing column.
2394         copy : bool
2395             Make copy of the input ``col``, default=True
2396 
2397         See Also
2398         --------
2399         add_columns, astropy.table.hstack, update
2400 
2401         Examples
2402         --------
2403         Replace column 'a' with a float version of itself::
2404 
2405             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3]], names=('a', 'b'))
2406             >>> float_a = t['a'].astype(float)
2407             >>> t.replace_column('a', float_a)
2408         """
2409         if name not in self.colnames:
2410             raise ValueError(f'column name {name} is not in the table')
2411 
2412         if self[name].info.indices:
2413             raise ValueError('cannot replace a table index column')
2414 
2415         col = self._convert_data_to_col(col, name=name, copy=copy)
2416         self._set_col_parent_table_and_mask(col)
2417 
2418         # Ensure that new column is the right length, unless it is the only column
2419         # in which case re-sizing is allowed.
2420         if len(self.columns) > 1 and len(col) != len(self[name]):
2421             raise ValueError('length of new column must match table length')
2422 
2423         self.columns.__setitem__(name, col, validated=True)
2424 
2425     def remove_row(self, index):
2426         """
2427         Remove a row from the table.
2428 
2429         Parameters
2430         ----------
2431         index : int
2432             Index of row to remove
2433 
2434         Examples
2435         --------
2436         Create a table with three columns 'a', 'b' and 'c'::
2437 
2438             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2439             ...           names=('a', 'b', 'c'))
2440             >>> print(t)
2441              a   b   c
2442             --- --- ---
2443               1 0.1   x
2444               2 0.2   y
2445               3 0.3   z
2446 
2447         Remove row 1 from the table::
2448 
2449             >>> t.remove_row(1)
2450             >>> print(t)
2451              a   b   c
2452             --- --- ---
2453               1 0.1   x
2454               3 0.3   z
2455 
2456         To remove several rows at the same time use remove_rows.
2457         """
2458         # check the index against the types that work with np.delete
2459         if not isinstance(index, (int, np.integer)):
2460             raise TypeError("Row index must be an integer")
2461         self.remove_rows(index)
2462 
2463     def remove_rows(self, row_specifier):
2464         """
2465         Remove rows from the table.
2466 
2467         Parameters
2468         ----------
2469         row_specifier : slice or int or array of int
2470             Specification for rows to remove
2471 
2472         Examples
2473         --------
2474         Create a table with three columns 'a', 'b' and 'c'::
2475 
2476             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2477             ...           names=('a', 'b', 'c'))
2478             >>> print(t)
2479              a   b   c
2480             --- --- ---
2481               1 0.1   x
2482               2 0.2   y
2483               3 0.3   z
2484 
2485         Remove rows 0 and 2 from the table::
2486 
2487             >>> t.remove_rows([0, 2])
2488             >>> print(t)
2489              a   b   c
2490             --- --- ---
2491               2 0.2   y
2492 
2493 
2494         Note that there are no warnings if the slice operator extends
2495         outside the data::
2496 
2497             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2498             ...           names=('a', 'b', 'c'))
2499             >>> t.remove_rows(slice(10, 20, 1))
2500             >>> print(t)
2501              a   b   c
2502             --- --- ---
2503               1 0.1   x
2504               2 0.2   y
2505               3 0.3   z
2506         """
2507         # Update indices
2508         for index in self.indices:
2509             index.remove_rows(row_specifier)
2510 
2511         keep_mask = np.ones(len(self), dtype=bool)
2512         keep_mask[row_specifier] = False
2513 
2514         columns = self.TableColumns()
2515         for name, col in self.columns.items():
2516             newcol = col[keep_mask]
2517             newcol.info.parent_table = self
2518             columns[name] = newcol
2519 
2520         self._replace_cols(columns)
2521 
2522         # Revert groups to default (ungrouped) state
2523         if hasattr(self, '_groups'):
2524             del self._groups
2525 
2526     def iterrows(self, *names):
2527         """
2528         Iterate over rows of table returning a tuple of values for each row.
2529 
2530         This method is especially useful when only a subset of columns are needed.
2531 
2532         The ``iterrows`` method can be substantially faster than using the standard
2533         Table row iteration (e.g. ``for row in tbl:``), since that returns a new
2534         ``~astropy.table.Row`` object for each row and accessing a column in that
2535         row (e.g. ``row['col0']``) is slower than tuple access.
2536 
2537         Parameters
2538         ----------
2539         names : list
2540             List of column names (default to all columns if no names provided)
2541 
2542         Returns
2543         -------
2544         rows : iterable
2545             Iterator returns tuples of row values
2546 
2547         Examples
2548         --------
2549         Create a table with three columns 'a', 'b' and 'c'::
2550 
2551             >>> t = Table({'a': [1, 2, 3],
2552             ...            'b': [1.0, 2.5, 3.0],
2553             ...            'c': ['x', 'y', 'z']})
2554 
2555         To iterate row-wise using column names::
2556 
2557             >>> for a, c in t.iterrows('a', 'c'):
2558             ...     print(a, c)
2559             1 x
2560             2 y
2561             3 z
2562 
2563         """
2564         if len(names) == 0:
2565             names = self.colnames
2566         else:
2567             for name in names:
2568                 if name not in self.colnames:
2569                     raise ValueError(f'{name} is not a valid column name')
2570 
2571         cols = (self[name] for name in names)
2572         out = zip(*cols)
2573         return out
2574 
2575     def _set_of_names_in_colnames(self, names):
2576         """Return ``names`` as a set if valid, or raise a `KeyError`.
2577 
2578         ``names`` is valid if all elements in it are in ``self.colnames``.
2579         If ``names`` is a string then it is interpreted as a single column
2580         name.
2581         """
2582         names = {names} if isinstance(names, str) else set(names)
2583         invalid_names = names.difference(self.colnames)
2584         if len(invalid_names) == 1:
2585             raise KeyError(f'column "{invalid_names.pop()}" does not exist')
2586         elif len(invalid_names) > 1:
2587             raise KeyError(f'columns {invalid_names} do not exist')
2588         return names
2589 
2590     def remove_column(self, name):
2591         """
2592         Remove a column from the table.
2593 
2594         This can also be done with::
2595 
2596           del table[name]
2597 
2598         Parameters
2599         ----------
2600         name : str
2601             Name of column to remove
2602 
2603         Examples
2604         --------
2605         Create a table with three columns 'a', 'b' and 'c'::
2606 
2607             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2608             ...           names=('a', 'b', 'c'))
2609             >>> print(t)
2610              a   b   c
2611             --- --- ---
2612               1 0.1   x
2613               2 0.2   y
2614               3 0.3   z
2615 
2616         Remove column 'b' from the table::
2617 
2618             >>> t.remove_column('b')
2619             >>> print(t)
2620              a   c
2621             --- ---
2622               1   x
2623               2   y
2624               3   z
2625 
2626         To remove several columns at the same time use remove_columns.
2627         """
2628 
2629         self.remove_columns([name])
2630 
2631     def remove_columns(self, names):
2632         '''
2633         Remove several columns from the table.
2634 
2635         Parameters
2636         ----------
2637         names : str or iterable of str
2638             Names of the columns to remove
2639 
2640         Examples
2641         --------
2642         Create a table with three columns 'a', 'b' and 'c'::
2643 
2644             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2645             ...     names=('a', 'b', 'c'))
2646             >>> print(t)
2647              a   b   c
2648             --- --- ---
2649               1 0.1   x
2650               2 0.2   y
2651               3 0.3   z
2652 
2653         Remove columns 'b' and 'c' from the table::
2654 
2655             >>> t.remove_columns(['b', 'c'])
2656             >>> print(t)
2657              a
2658             ---
2659               1
2660               2
2661               3
2662 
2663         Specifying only a single column also works. Remove column 'b' from the table::
2664 
2665             >>> t = Table([[1, 2, 3], [0.1, 0.2, 0.3], ['x', 'y', 'z']],
2666             ...     names=('a', 'b', 'c'))
2667             >>> t.remove_columns('b')
2668             >>> print(t)
2669              a   c
2670             --- ---
2671               1   x
2672               2   y
2673               3   z
2674 
2675         This gives the same as using remove_column.
2676         '''
2677         for name in self._set_of_names_in_colnames(names):
2678             self.columns.pop(name)
2679 
2680     def _convert_string_dtype(self, in_kind, out_kind, encode_decode_func):
2681         """
2682         Convert string-like columns to/from bytestring and unicode (internal only).
2683 
2684         Parameters
2685         ----------
2686         in_kind : str
2687             Input dtype.kind
2688         out_kind : str
2689             Output dtype.kind
2690         """
2691 
2692         for col in self.itercols():
2693             if col.dtype.kind == in_kind:
2694                 try:
2695                     # This requires ASCII and is faster by a factor of up to ~8, so
2696                     # try that first.
2697                     newcol = col.__class__(col, dtype=out_kind)
2698                 except (UnicodeEncodeError, UnicodeDecodeError):
2699                     newcol = col.__class__(encode_decode_func(col, 'utf-8'))
2700 
2701                     # Quasi-manually copy info attributes.  Unfortunately
2702                     # DataInfo.__set__ does not do the right thing in this case
2703                     # so newcol.info = col.info does not get the old info attributes.
2704                     for attr in col.info.attr_names - col.info._attrs_no_copy - {'dtype'}:
2705                         value = deepcopy(getattr(col.info, attr))
2706                         setattr(newcol.info, attr, value)
2707 
2708                 self[col.name] = newcol
2709 
2710     def convert_bytestring_to_unicode(self):
2711         """
2712         Convert bytestring columns (dtype.kind='S') to unicode (dtype.kind='U')
2713         using UTF-8 encoding.
2714 
2715         Internally this changes string columns to represent each character
2716         in the string with a 4-byte UCS-4 equivalent, so it is inefficient
2717         for memory but allows scripts to manipulate string arrays with
2718         natural syntax.
2719         """
2720         self._convert_string_dtype('S', 'U', np.char.decode)
2721 
2722     def convert_unicode_to_bytestring(self):
2723         """
2724         Convert unicode columns (dtype.kind='U') to bytestring (dtype.kind='S')
2725         using UTF-8 encoding.
2726 
2727         When exporting a unicode string array to a file, it may be desirable
2728         to encode unicode columns as bytestrings.
2729         """
2730         self._convert_string_dtype('U', 'S', np.char.encode)
2731 
2732     def keep_columns(self, names):
2733         '''
2734         Keep only the columns specified (remove the others).
2735 
2736         Parameters
2737         ----------
2738         names : str or iterable of str
2739             The columns to keep. All other columns will be removed.
2740 
2741         Examples
2742         --------
2743         Create a table with three columns 'a', 'b' and 'c'::
2744 
2745             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
2746             ...           names=('a', 'b', 'c'))
2747             >>> print(t)
2748              a   b   c
2749             --- --- ---
2750               1 0.1   x
2751               2 0.2   y
2752               3 0.3   z
2753 
2754         Keep only column 'a' of the table::
2755 
2756             >>> t.keep_columns('a')
2757             >>> print(t)
2758              a
2759             ---
2760               1
2761               2
2762               3
2763 
2764         Keep columns 'a' and 'c' of the table::
2765 
2766             >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],
2767             ...           names=('a', 'b', 'c'))
2768             >>> t.keep_columns(['a', 'c'])
2769             >>> print(t)
2770              a   c
2771             --- ---
2772               1   x
2773               2   y
2774               3   z
2775         '''
2776         names = self._set_of_names_in_colnames(names)
2777         for colname in self.colnames:
2778             if colname not in names:
2779                 self.columns.pop(colname)
2780 
2781     def rename_column(self, name, new_name):
2782         '''
2783         Rename a column.
2784 
2785         This can also be done directly with by setting the ``name`` attribute
2786         for a column::
2787 
2788           table[name].name = new_name
2789 
2790         TODO: this won't work for mixins
2791 
2792         Parameters
2793         ----------
2794         name : str
2795             The current name of the column.
2796         new_name : str
2797             The new name for the column
2798 
2799         Examples
2800         --------
2801         Create a table with three columns 'a', 'b' and 'c'::
2802 
2803             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
2804             >>> print(t)
2805              a   b   c
2806             --- --- ---
2807               1   3   5
2808               2   4   6
2809 
2810         Renaming column 'a' to 'aa'::
2811 
2812             >>> t.rename_column('a' , 'aa')
2813             >>> print(t)
2814              aa  b   c
2815             --- --- ---
2816               1   3   5
2817               2   4   6
2818         '''
2819 
2820         if name not in self.keys():
2821             raise KeyError(f"Column {name} does not exist")
2822 
2823         self.columns[name].info.name = new_name
2824 
2825     def rename_columns(self, names, new_names):
2826         '''
2827         Rename multiple columns.
2828 
2829         Parameters
2830         ----------
2831         names : list, tuple
2832             A list or tuple of existing column names.
2833         new_names : list, tuple
2834             A list or tuple of new column names.
2835 
2836         Examples
2837         --------
2838         Create a table with three columns 'a', 'b', 'c'::
2839 
2840             >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))
2841             >>> print(t)
2842               a   b   c
2843              --- --- ---
2844               1   3   5
2845               2   4   6
2846 
2847         Renaming columns 'a' to 'aa' and 'b' to 'bb'::
2848 
2849             >>> names = ('a','b')
2850             >>> new_names = ('aa','bb')
2851             >>> t.rename_columns(names, new_names)
2852             >>> print(t)
2853              aa  bb   c
2854             --- --- ---
2855               1   3   5
2856               2   4   6
2857         '''
2858 
2859         if not self._is_list_or_tuple_of_str(names):
2860             raise TypeError("input 'names' must be a tuple or a list of column names")
2861 
2862         if not self._is_list_or_tuple_of_str(new_names):
2863             raise TypeError("input 'new_names' must be a tuple or a list of column names")
2864 
2865         if len(names) != len(new_names):
2866             raise ValueError("input 'names' and 'new_names' list arguments must be the same length")
2867 
2868         for name, new_name in zip(names, new_names):
2869             self.rename_column(name, new_name)
2870 
2871     def _set_row(self, idx, colnames, vals):
2872         try:
2873             assert len(vals) == len(colnames)
2874         except Exception:
2875             raise ValueError('right hand side must be a sequence of values with '
2876                              'the same length as the number of selected columns')
2877 
2878         # Keep track of original values before setting each column so that
2879         # setting row can be transactional.
2880         orig_vals = []
2881         cols = self.columns
2882         try:
2883             for name, val in zip(colnames, vals):
2884                 orig_vals.append(cols[name][idx])
2885                 cols[name][idx] = val
2886         except Exception:
2887             # If anything went wrong first revert the row update then raise
2888             for name, val in zip(colnames, orig_vals[:-1]):
2889                 cols[name][idx] = val
2890             raise
2891 
2892     def add_row(self, vals=None, mask=None):
2893         """Add a new row to the end of the table.
2894 
2895         The ``vals`` argument can be:
2896 
2897         sequence (e.g. tuple or list)
2898             Column values in the same order as table columns.
2899         mapping (e.g. dict)
2900             Keys corresponding to column names.  Missing values will be
2901             filled with np.zeros for the column dtype.
2902         `None`
2903             All values filled with np.zeros for the column dtype.
2904 
2905         This method requires that the Table object "owns" the underlying array
2906         data.  In particular one cannot add a row to a Table that was
2907         initialized with copy=False from an existing array.
2908 
2909         The ``mask`` attribute should give (if desired) the mask for the
2910         values. The type of the mask should match that of the values, i.e. if
2911         ``vals`` is an iterable, then ``mask`` should also be an iterable
2912         with the same length, and if ``vals`` is a mapping, then ``mask``
2913         should be a dictionary.
2914 
2915         Parameters
2916         ----------
2917         vals : tuple, list, dict or None
2918             Use the specified values in the new row
2919         mask : tuple, list, dict or None
2920             Use the specified mask values in the new row
2921 
2922         Examples
2923         --------
2924         Create a table with three columns 'a', 'b' and 'c'::
2925 
2926            >>> t = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
2927            >>> print(t)
2928             a   b   c
2929            --- --- ---
2930              1   4   7
2931              2   5   8
2932 
2933         Adding a new row with entries '3' in 'a', '6' in 'b' and '9' in 'c'::
2934 
2935            >>> t.add_row([3,6,9])
2936            >>> print(t)
2937              a   b   c
2938              --- --- ---
2939              1   4   7
2940              2   5   8
2941              3   6   9
2942         """
2943         self.insert_row(len(self), vals, mask)
2944 
2945     def insert_row(self, index, vals=None, mask=None):
2946         """Add a new row before the given ``index`` position in the table.
2947 
2948         The ``vals`` argument can be:
2949 
2950         sequence (e.g. tuple or list)
2951             Column values in the same order as table columns.
2952         mapping (e.g. dict)
2953             Keys corresponding to column names.  Missing values will be
2954             filled with np.zeros for the column dtype.
2955         `None`
2956             All values filled with np.zeros for the column dtype.
2957 
2958         The ``mask`` attribute should give (if desired) the mask for the
2959         values. The type of the mask should match that of the values, i.e. if
2960         ``vals`` is an iterable, then ``mask`` should also be an iterable
2961         with the same length, and if ``vals`` is a mapping, then ``mask``
2962         should be a dictionary.
2963 
2964         Parameters
2965         ----------
2966         vals : tuple, list, dict or None
2967             Use the specified values in the new row
2968         mask : tuple, list, dict or None
2969             Use the specified mask values in the new row
2970         """
2971         colnames = self.colnames
2972 
2973         N = len(self)
2974         if index < -N or index > N:
2975             raise IndexError("Index {} is out of bounds for table with length {}"
2976                              .format(index, N))
2977         if index < 0:
2978             index += N
2979 
2980         if isinstance(vals, Mapping) or vals is None:
2981             # From the vals and/or mask mappings create the corresponding lists
2982             # that have entries for each table column.
2983             if mask is not None and not isinstance(mask, Mapping):
2984                 raise TypeError("Mismatch between type of vals and mask")
2985 
2986             # Now check that the mask is specified for the same keys as the
2987             # values, otherwise things get really confusing.
2988             if mask is not None and set(vals.keys()) != set(mask.keys()):
2989                 raise ValueError('keys in mask should match keys in vals')
2990 
2991             if vals and any(name not in colnames for name in vals):
2992                 raise ValueError('Keys in vals must all be valid column names')
2993 
2994             vals_list = []
2995             mask_list = []
2996 
2997             for name in colnames:
2998                 if vals and name in vals:
2999                     vals_list.append(vals[name])
3000                     mask_list.append(False if mask is None else mask[name])
3001                 else:
3002                     col = self[name]
3003                     if hasattr(col, 'dtype'):
3004                         # Make a placeholder zero element of the right type which is masked.
3005                         # This assumes the appropriate insert() method will broadcast a
3006                         # numpy scalar to the right shape.
3007                         vals_list.append(np.zeros(shape=(), dtype=col.dtype))
3008 
3009                         # For masked table any unsupplied values are masked by default.
3010                         mask_list.append(self.masked and vals is not None)
3011                     else:
3012                         raise ValueError(f"Value must be supplied for column '{name}'")
3013 
3014             vals = vals_list
3015             mask = mask_list
3016 
3017         if isiterable(vals):
3018             if mask is not None and (not isiterable(mask) or isinstance(mask, Mapping)):
3019                 raise TypeError("Mismatch between type of vals and mask")
3020 
3021             if len(self.columns) != len(vals):
3022                 raise ValueError('Mismatch between number of vals and columns')
3023 
3024             if mask is not None:
3025                 if len(self.columns) != len(mask):
3026                     raise ValueError('Mismatch between number of masks and columns')
3027             else:
3028                 mask = [False] * len(self.columns)
3029 
3030         else:
3031             raise TypeError('Vals must be an iterable or mapping or None')
3032 
3033         # Insert val at index for each column
3034         columns = self.TableColumns()
3035         for name, col, val, mask_ in zip(colnames, self.columns.values(), vals, mask):
3036             try:
3037                 # If new val is masked and the existing column does not support masking
3038                 # then upgrade the column to a mask-enabled type: either the table-level
3039                 # default ColumnClass or else MaskedColumn.
3040                 if mask_ and isinstance(col, Column) and not isinstance(col, MaskedColumn):
3041                     col_cls = (self.ColumnClass
3042                                if issubclass(self.ColumnClass, self.MaskedColumn)
3043                                else self.MaskedColumn)
3044                     col = col_cls(col, copy=False)
3045 
3046                 newcol = col.insert(index, val, axis=0)
3047 
3048                 if len(newcol) != N + 1:
3049                     raise ValueError('Incorrect length for column {} after inserting {}'
3050                                      ' (expected {}, got {})'
3051                                      .format(name, val, len(newcol), N + 1))
3052                 newcol.info.parent_table = self
3053 
3054                 # Set mask if needed and possible
3055                 if mask_:
3056                     if hasattr(newcol, 'mask'):
3057                         newcol[index] = np.ma.masked
3058                     else:
3059                         raise TypeError("mask was supplied for column '{}' but it does not "
3060                                         "support masked values".format(col.info.name))
3061 
3062                 columns[name] = newcol
3063 
3064             except Exception as err:
3065                 raise ValueError("Unable to insert row because of exception in column '{}':\n{}"
3066                                  .format(name, err)) from err
3067 
3068         for table_index in self.indices:
3069             table_index.insert_row(index, vals, self.columns.values())
3070 
3071         self._replace_cols(columns)
3072 
3073         # Revert groups to default (ungrouped) state
3074         if hasattr(self, '_groups'):
3075             del self._groups
3076 
3077     def _replace_cols(self, columns):
3078         for col, new_col in zip(self.columns.values(), columns.values()):
3079             new_col.info.indices = []
3080             for index in col.info.indices:
3081                 index.columns[index.col_position(col.info.name)] = new_col
3082                 new_col.info.indices.append(index)
3083 
3084         self.columns = columns
3085 
3086     def update(self, other, copy=True):
3087         """
3088         Perform a dictionary-style update and merge metadata.
3089 
3090         The argument ``other`` must be a |Table|, or something that can be used
3091         to initialize a table. Columns from (possibly converted) ``other`` are
3092         added to this table. In case of matching column names the column from
3093         this table is replaced with the one from ``other``.
3094 
3095         Parameters
3096         ----------
3097         other : table-like
3098             Data to update this table with.
3099         copy : bool
3100             Whether the updated columns should be copies of or references to
3101             the originals.
3102 
3103         See Also
3104         --------
3105         add_columns, astropy.table.hstack, replace_column
3106 
3107         Examples
3108         --------
3109         Update a table with another table::
3110 
3111             >>> t1 = Table({'a': ['foo', 'bar'], 'b': [0., 0.]}, meta={'i': 0})
3112             >>> t2 = Table({'b': [1., 2.], 'c': [7., 11.]}, meta={'n': 2})
3113             >>> t1.update(t2)
3114             >>> t1
3115             <Table length=2>
3116              a      b       c
3117             str3 float64 float64
3118             ---- ------- -------
3119              foo     1.0     7.0
3120              bar     2.0    11.0
3121             >>> t1.meta
3122             {'i': 0, 'n': 2}
3123 
3124         Update a table with a dictionary::
3125 
3126             >>> t = Table({'a': ['foo', 'bar'], 'b': [0., 0.]})
3127             >>> t.update({'b': [1., 2.]})
3128             >>> t
3129             <Table length=2>
3130              a      b
3131             str3 float64
3132             ---- -------
3133              foo     1.0
3134              bar     2.0
3135         """
3136         from .operations import _merge_table_meta
3137         if not isinstance(other, Table):
3138             other = self.__class__(other, copy=copy)
3139         common_cols = set(self.colnames).intersection(other.colnames)
3140         for name, col in other.items():
3141             if name in common_cols:
3142                 self.replace_column(name, col, copy=copy)
3143             else:
3144                 self.add_column(col, name=name, copy=copy)
3145         _merge_table_meta(self, [self, other], metadata_conflicts='silent')
3146 
3147     def argsort(self, keys=None, kind=None, reverse=False):
3148         """
3149         Return the indices which would sort the table according to one or
3150         more key columns.  This simply calls the `numpy.argsort` function on
3151         the table with the ``order`` parameter set to ``keys``.
3152 
3153         Parameters
3154         ----------
3155         keys : str or list of str
3156             The column name(s) to order the table by
3157         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3158             Sorting algorithm used by ``numpy.argsort``.
3159         reverse : bool
3160             Sort in reverse order (default=False)
3161 
3162         Returns
3163         -------
3164         index_array : ndarray, int
3165             Array of indices that sorts the table by the specified key
3166             column(s).
3167         """
3168         if isinstance(keys, str):
3169             keys = [keys]
3170 
3171         # use index sorted order if possible
3172         if keys is not None:
3173             index = get_index(self, names=keys)
3174             if index is not None:
3175                 idx = np.asarray(index.sorted_data())
3176                 return idx[::-1] if reverse else idx
3177 
3178         kwargs = {}
3179         if keys:
3180             # For multiple keys return a structured array which gets sorted,
3181             # while for a single key return a single ndarray.  Sorting a
3182             # one-column structured array is slower than ndarray (e.g. a
3183             # factor of ~6 for a 10 million long random array), and much slower
3184             # for in principle sortable columns like Time, which get stored as
3185             # object arrays.
3186             if len(keys) > 1:
3187                 kwargs['order'] = keys
3188                 data = self.as_array(names=keys)
3189             else:
3190                 data = self[keys[0]]
3191         else:
3192             # No keys provided so sort on all columns.
3193             data = self.as_array()
3194 
3195         if kind:
3196             kwargs['kind'] = kind
3197 
3198         # np.argsort will look for a possible .argsort method (e.g., for Time),
3199         # and if that fails cast to an array and try sorting that way.
3200         idx = np.argsort(data, **kwargs)
3201 
3202         return idx[::-1] if reverse else idx
3203 
3204     def sort(self, keys=None, *, kind=None, reverse=False):
3205         '''
3206         Sort the table according to one or more keys. This operates
3207         on the existing table and does not return a new table.
3208 
3209         Parameters
3210         ----------
3211         keys : str or list of str
3212             The key(s) to order the table by. If None, use the
3213             primary index of the Table.
3214         kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
3215             Sorting algorithm used by ``numpy.argsort``.
3216         reverse : bool
3217             Sort in reverse order (default=False)
3218 
3219         Examples
3220         --------
3221         Create a table with 3 columns::
3222 
3223             >>> t = Table([['Max', 'Jo', 'John'], ['Miller', 'Miller', 'Jackson'],
3224             ...            [12, 15, 18]], names=('firstname', 'name', 'tel'))
3225             >>> print(t)
3226             firstname   name  tel
3227             --------- ------- ---
3228                   Max  Miller  12
3229                    Jo  Miller  15
3230                  John Jackson  18
3231 
3232         Sorting according to standard sorting rules, first 'name' then 'firstname'::
3233 
3234             >>> t.sort(['name', 'firstname'])
3235             >>> print(t)
3236             firstname   name  tel
3237             --------- ------- ---
3238                  John Jackson  18
3239                    Jo  Miller  15
3240                   Max  Miller  12
3241 
3242         Sorting according to standard sorting rules, first 'firstname' then 'tel',
3243         in reverse order::
3244 
3245             >>> t.sort(['firstname', 'tel'], reverse=True)
3246             >>> print(t)
3247             firstname   name  tel
3248             --------- ------- ---
3249                   Max  Miller  12
3250                  John Jackson  18
3251                    Jo  Miller  15
3252         '''
3253         if keys is None:
3254             if not self.indices:
3255                 raise ValueError("Table sort requires input keys or a table index")
3256             keys = [x.info.name for x in self.indices[0].columns]
3257 
3258         if isinstance(keys, str):
3259             keys = [keys]
3260 
3261         indexes = self.argsort(keys, kind=kind, reverse=reverse)
3262 
3263         with self.index_mode('freeze'):
3264             for name, col in self.columns.items():
3265                 # Make a new sorted column.  This requires that take() also copies
3266                 # relevant info attributes for mixin columns.
3267                 new_col = col.take(indexes, axis=0)
3268 
3269                 # First statement in try: will succeed if the column supports an in-place
3270                 # update, and matches the legacy behavior of astropy Table.  However,
3271                 # some mixin classes may not support this, so in that case just drop
3272                 # in the entire new column. See #9553 and #9536 for discussion.
3273                 try:
3274                     col[:] = new_col
3275                 except Exception:
3276                     # In-place update failed for some reason, exception class not
3277                     # predictable for arbitrary mixin.
3278                     self[col.info.name] = new_col
3279 
3280     def reverse(self):
3281         '''
3282         Reverse the row order of table rows.  The table is reversed
3283         in place and there are no function arguments.
3284 
3285         Examples
3286         --------
3287         Create a table with three columns::
3288 
3289             >>> t = Table([['Max', 'Jo', 'John'], ['Miller','Miller','Jackson'],
3290             ...         [12,15,18]], names=('firstname','name','tel'))
3291             >>> print(t)
3292             firstname   name  tel
3293             --------- ------- ---
3294                   Max  Miller  12
3295                    Jo  Miller  15
3296                  John Jackson  18
3297 
3298         Reversing order::
3299 
3300             >>> t.reverse()
3301             >>> print(t)
3302             firstname   name  tel
3303             --------- ------- ---
3304                  John Jackson  18
3305                    Jo  Miller  15
3306                   Max  Miller  12
3307         '''
3308         for col in self.columns.values():
3309             # First statement in try: will succeed if the column supports an in-place
3310             # update, and matches the legacy behavior of astropy Table.  However,
3311             # some mixin classes may not support this, so in that case just drop
3312             # in the entire new column. See #9836, #9553, and #9536 for discussion.
3313             new_col = col[::-1]
3314             try:
3315                 col[:] = new_col
3316             except Exception:
3317                 # In-place update failed for some reason, exception class not
3318                 # predictable for arbitrary mixin.
3319                 self[col.info.name] = new_col
3320 
3321         for index in self.indices:
3322             index.reverse()
3323 
3324     def round(self, decimals=0):
3325         '''
3326         Round numeric columns in-place to the specified number of decimals.
3327         Non-numeric columns will be ignored.
3328 
3329         Examples
3330         --------
3331         Create three columns with different types:
3332 
3333             >>> t = Table([[1, 4, 5], [-25.55, 12.123, 85],
3334             ...     ['a', 'b', 'c']], names=('a', 'b', 'c'))
3335             >>> print(t)
3336              a    b     c
3337             --- ------ ---
3338               1 -25.55   a
3339               4 12.123   b
3340               5   85.0   c
3341 
3342         Round them all to 0:
3343 
3344             >>> t.round(0)
3345             >>> print(t)
3346              a    b    c
3347             --- ----- ---
3348               1 -26.0   a
3349               4  12.0   b
3350               5  85.0   c
3351 
3352         Round column 'a' to -1 decimal:
3353 
3354             >>> t.round({'a':-1})
3355             >>> print(t)
3356              a    b    c
3357             --- ----- ---
3358               0 -26.0   a
3359               0  12.0   b
3360               0  85.0   c
3361 
3362         Parameters
3363         ----------
3364         decimals: int, dict
3365             Number of decimals to round the columns to. If a dict is given,
3366             the columns will be rounded to the number specified as the value.
3367             If a certain column is not in the dict given, it will remain the
3368             same.
3369         '''
3370         if isinstance(decimals, Mapping):
3371             decimal_values = decimals.values()
3372             column_names = decimals.keys()
3373         elif isinstance(decimals, int):
3374             decimal_values = itertools.repeat(decimals)
3375             column_names = self.colnames
3376         else:
3377             raise ValueError("'decimals' argument must be an int or a dict")
3378 
3379         for colname, decimal in zip(column_names, decimal_values):
3380             col = self.columns[colname]
3381             if np.issubdtype(col.info.dtype, np.number):
3382                 try:
3383                     np.around(col, decimals=decimal, out=col)
3384                 except TypeError:
3385                     # Bug in numpy see https://github.com/numpy/numpy/issues/15438
3386                     col[()] = np.around(col, decimals=decimal)
3387 
3388     def copy(self, copy_data=True):
3389         '''
3390         Return a copy of the table.
3391 
3392         Parameters
3393         ----------
3394         copy_data : bool
3395             If `True` (the default), copy the underlying data array.
3396             Otherwise, use the same data array. The ``meta`` is always
3397             deepcopied regardless of the value for ``copy_data``.
3398         '''
3399         out = self.__class__(self, copy=copy_data)
3400 
3401         # If the current table is grouped then do the same in the copy
3402         if hasattr(self, '_groups'):
3403             out._groups = groups.TableGroups(out, indices=self._groups._indices,
3404                                              keys=self._groups._keys)
3405         return out
3406 
3407     def __deepcopy__(self, memo=None):
3408         return self.copy(True)
3409 
3410     def __copy__(self):
3411         return self.copy(False)
3412 
3413     def __lt__(self, other):
3414         return super().__lt__(other)
3415 
3416     def __gt__(self, other):
3417         return super().__gt__(other)
3418 
3419     def __le__(self, other):
3420         return super().__le__(other)
3421 
3422     def __ge__(self, other):
3423         return super().__ge__(other)
3424 
3425     def __eq__(self, other):
3426         return self._rows_equal(other)
3427 
3428     def __ne__(self, other):
3429         return ~self.__eq__(other)
3430 
3431     def _rows_equal(self, other):
3432         """
3433         Row-wise comparison of table with any other object.
3434 
3435         This is actual implementation for __eq__.
3436 
3437         Returns a 1-D boolean numpy array showing result of row-wise comparison.
3438         This is the same as the ``==`` comparison for tables.
3439 
3440         Parameters
3441         ----------
3442         other : Table or DataFrame or ndarray
3443              An object to compare with table
3444 
3445         Examples
3446         --------
3447         Comparing one Table with other::
3448 
3449             >>> t1 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3450             >>> t2 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))
3451             >>> t1._rows_equal(t2)
3452             array([ True,  True])
3453 
3454         """
3455 
3456         if isinstance(other, Table):
3457             other = other.as_array()
3458 
3459         if self.has_masked_columns:
3460             if isinstance(other, np.ma.MaskedArray):
3461                 result = self.as_array() == other
3462             else:
3463                 # If mask is True, then by definition the row doesn't match
3464                 # because the other array is not masked.
3465                 false_mask = np.zeros(1, dtype=[(n, bool) for n in self.dtype.names])
3466                 result = (self.as_array().data == other) & (self.mask == false_mask)
3467         else:
3468             if isinstance(other, np.ma.MaskedArray):
3469                 # If mask is True, then by definition the row doesn't match
3470                 # because the other array is not masked.
3471                 false_mask = np.zeros(1, dtype=[(n, bool) for n in other.dtype.names])
3472                 result = (self.as_array() == other.data) & (other.mask == false_mask)
3473             else:
3474                 result = self.as_array() == other
3475 
3476         return result
3477 
3478     def values_equal(self, other):
3479         """
3480         Element-wise comparison of table with another table, list, or scalar.
3481 
3482         Returns a ``Table`` with the same columns containing boolean values
3483         showing result of comparison.
3484 
3485         Parameters
3486         ----------
3487         other : table-like object or list or scalar
3488              Object to compare with table
3489 
3490         Examples
3491         --------
3492         Compare one Table with other::
3493 
3494           >>> t1 = Table([[1, 2], [4, 5], [-7, 8]], names=('a', 'b', 'c'))
3495           >>> t2 = Table([[1, 2], [-4, 5], [7, 8]], names=('a', 'b', 'c'))
3496           >>> t1.values_equal(t2)
3497           <Table length=2>
3498            a     b     c
3499           bool  bool  bool
3500           ---- ----- -----
3501           True False False
3502           True  True  True
3503 
3504         """
3505         if isinstance(other, Table):
3506             names = other.colnames
3507         else:
3508             try:
3509                 other = Table(other, copy=False)
3510                 names = other.colnames
3511             except Exception:
3512                 # Broadcast other into a dict, so e.g. other = 2 will turn into
3513                 # other = {'a': 2, 'b': 2} and then equality does a
3514                 # column-by-column broadcasting.
3515                 names = self.colnames
3516                 other = {name: other for name in names}
3517 
3518         # Require column names match but do not require same column order
3519         if set(self.colnames) != set(names):
3520             raise ValueError('cannot compare tables with different column names')
3521 
3522         eqs = []
3523         for name in names:
3524             try:
3525                 np.broadcast(self[name], other[name])  # Check if broadcast-able
3526                 # Catch the numpy FutureWarning related to equality checking,
3527                 # "elementwise comparison failed; returning scalar instead, but
3528                 #  in the future will perform elementwise comparison".  Turn this
3529                 # into an exception since the scalar answer is not what we want.
3530                 with warnings.catch_warnings(record=True) as warns:
3531                     warnings.simplefilter('always')
3532                     eq = self[name] == other[name]
3533                     if (warns and issubclass(warns[-1].category, FutureWarning)
3534                             and 'elementwise comparison failed' in str(warns[-1].message)):
3535                         raise FutureWarning(warns[-1].message)
3536             except Exception as err:
3537                 raise ValueError(f'unable to compare column {name}') from err
3538 
3539             # Be strict about the result from the comparison. E.g. SkyCoord __eq__ is just
3540             # broken and completely ignores that it should return an array.
3541             if not (isinstance(eq, np.ndarray)
3542                     and eq.dtype is np.dtype('bool')
3543                     and len(eq) == len(self)):
3544                 raise TypeError(f'comparison for column {name} returned {eq} '
3545                                 f'instead of the expected boolean ndarray')
3546 
3547             eqs.append(eq)
3548 
3549         out = Table(eqs, names=names)
3550 
3551         return out
3552 
3553     @property
3554     def groups(self):
3555         if not hasattr(self, '_groups'):
3556             self._groups = groups.TableGroups(self)
3557         return self._groups
3558 
3559     def group_by(self, keys):
3560         """
3561         Group this table by the specified ``keys``
3562 
3563         This effectively splits the table into groups which correspond to unique
3564         values of the ``keys`` grouping object.  The output is a new
3565         `~astropy.table.TableGroups` which contains a copy of this table but
3566         sorted by row according to ``keys``.
3567 
3568         The ``keys`` input to `group_by` can be specified in different ways:
3569 
3570           - String or list of strings corresponding to table column name(s)
3571           - Numpy array (homogeneous or structured) with same length as this table
3572           - `~astropy.table.Table` with same length as this table
3573 
3574         Parameters
3575         ----------
3576         keys : str, list of str, numpy array, or `~astropy.table.Table`
3577             Key grouping object
3578 
3579         Returns
3580         -------
3581         out : `~astropy.table.Table`
3582             New table with groups set
3583         """
3584         return groups.table_group_by(self, keys)
3585 
3586     def to_pandas(self, index=None, use_nullable_int=True):
3587         """
3588         Return a :class:`pandas.DataFrame` instance
3589 
3590         The index of the created DataFrame is controlled by the ``index``
3591         argument.  For ``index=True`` or the default ``None``, an index will be
3592         specified for the DataFrame if there is a primary key index on the
3593         Table *and* if it corresponds to a single column.  If ``index=False``
3594         then no DataFrame index will be specified.  If ``index`` is the name of
3595         a column in the table then that will be the DataFrame index.
3596 
3597         In addition to vanilla columns or masked columns, this supports Table
3598         mixin columns like Quantity, Time, or SkyCoord.  In many cases these
3599         objects have no analog in pandas and will be converted to a "encoded"
3600         representation using only Column or MaskedColumn.  The exception is
3601         Time or TimeDelta columns, which will be converted to the corresponding
3602         representation in pandas using ``np.datetime64`` or ``np.timedelta64``.
3603         See the example below.
3604 
3605         Parameters
3606         ----------
3607         index : None, bool, str
3608             Specify DataFrame index mode
3609         use_nullable_int : bool, default=True
3610             Convert integer MaskedColumn to pandas nullable integer type.
3611             If ``use_nullable_int=False`` or the pandas version does not support
3612             nullable integer types (version < 0.24), then the column is converted
3613             to float with NaN for missing elements and a warning is issued.
3614 
3615         Returns
3616         -------
3617         dataframe : :class:`pandas.DataFrame`
3618             A pandas :class:`pandas.DataFrame` instance
3619 
3620         Raises
3621         ------
3622         ImportError
3623             If pandas is not installed
3624         ValueError
3625             If the Table has multi-dimensional columns
3626 
3627         Examples
3628         --------
3629         Here we convert a table with a few mixins to a
3630         :class:`pandas.DataFrame` instance.
3631 
3632           >>> import pandas as pd
3633           >>> from astropy.table import QTable
3634           >>> import astropy.units as u
3635           >>> from astropy.time import Time, TimeDelta
3636           >>> from astropy.coordinates import SkyCoord
3637 
3638           >>> q = [1, 2] * u.m
3639           >>> tm = Time([1998, 2002], format='jyear')
3640           >>> sc = SkyCoord([5, 6], [7, 8], unit='deg')
3641           >>> dt = TimeDelta([3, 200] * u.s)
3642 
3643           >>> t = QTable([q, tm, sc, dt], names=['q', 'tm', 'sc', 'dt'])
3644 
3645           >>> df = t.to_pandas(index='tm')
3646           >>> with pd.option_context('display.max_columns', 20):
3647           ...     print(df)
3648                         q  sc.ra  sc.dec              dt
3649           tm
3650           1998-01-01  1.0    5.0     7.0 0 days 00:00:03
3651           2002-01-01  2.0    6.0     8.0 0 days 00:03:20
3652 
3653         """
3654         from pandas import DataFrame, Series
3655 
3656         if index is not False:
3657             if index in (None, True):
3658                 # Default is to use the table primary key if available and a single column
3659                 if self.primary_key and len(self.primary_key) == 1:
3660                     index = self.primary_key[0]
3661                 else:
3662                     index = False
3663             else:
3664                 if index not in self.colnames:
3665                     raise ValueError('index must be None, False, True or a table '
3666                                      'column name')
3667 
3668         def _encode_mixins(tbl):
3669             """Encode a Table ``tbl`` that may have mixin columns to a Table with only
3670             astropy Columns + appropriate meta-data to allow subsequent decoding.
3671             """
3672             from . import serialize
3673             from astropy.time import TimeBase, TimeDelta
3674 
3675             # Convert any Time or TimeDelta columns and pay attention to masking
3676             time_cols = [col for col in tbl.itercols() if isinstance(col, TimeBase)]
3677             if time_cols:
3678 
3679                 # Make a light copy of table and clear any indices
3680                 new_cols = []
3681                 for col in tbl.itercols():
3682                     new_col = col_copy(col, copy_indices=False) if col.info.indices else col
3683                     new_cols.append(new_col)
3684                 tbl = tbl.__class__(new_cols, copy=False)
3685 
3686                 # Certain subclasses (e.g. TimeSeries) may generate new indices on
3687                 # table creation, so make sure there are no indices on the table.
3688                 for col in tbl.itercols():
3689                     col.info.indices.clear()
3690 
3691                 for col in time_cols:
3692                     if isinstance(col, TimeDelta):
3693                         # Convert to nanoseconds (matches astropy datetime64 support)
3694                         new_col = (col.sec * 1e9).astype('timedelta64[ns]')
3695                         nat = np.timedelta64('NaT')
3696                     else:
3697                         new_col = col.datetime64.copy()
3698                         nat = np.datetime64('NaT')
3699                     if col.masked:
3700                         new_col[col.mask] = nat
3701                     tbl[col.info.name] = new_col
3702 
3703             # Convert the table to one with no mixins, only Column objects.
3704             encode_tbl = serialize.represent_mixins_as_columns(tbl)
3705             return encode_tbl
3706 
3707         tbl = _encode_mixins(self)
3708 
3709         badcols = [name for name, col in self.columns.items() if len(col.shape) > 1]
3710         if badcols:
3711             raise ValueError(
3712                 f'Cannot convert a table with multidimensional columns to a '
3713                 f'pandas DataFrame. Offending columns are: {badcols}\n'
3714                 f'One can filter out such columns using:\n'
3715                 f'names = [name for name in tbl.colnames if len(tbl[name].shape) <= 1]\n'
3716                 f'tbl[names].to_pandas(...)')
3717 
3718         out = OrderedDict()
3719 
3720         for name, column in tbl.columns.items():
3721             if getattr(column.dtype, 'isnative', True):
3722                 out[name] = column
3723             else:
3724                 out[name] = column.data.byteswap().newbyteorder('=')
3725 
3726             if isinstance(column, MaskedColumn) and np.any(column.mask):
3727                 if column.dtype.kind in ['i', 'u']:
3728                     pd_dtype = column.dtype.name
3729                     if use_nullable_int:
3730                         # Convert int64 to Int64, uint32 to UInt32, etc for nullable types
3731                         pd_dtype = pd_dtype.replace('i', 'I').replace('u', 'U')
3732                     out[name] = Series(out[name], dtype=pd_dtype)
3733 
3734                     # If pandas is older than 0.24 the type may have turned to float
3735                     if column.dtype.kind != out[name].dtype.kind:
3736                         warnings.warn(
3737                             f"converted column '{name}' from {column.dtype} to {out[name].dtype}",
3738                             TableReplaceWarning, stacklevel=3)
3739                 elif column.dtype.kind not in ['f', 'c']:
3740                     out[name] = column.astype(object).filled(np.nan)
3741 
3742         kwargs = {}
3743 
3744         if index:
3745             idx = out.pop(index)
3746 
3747             kwargs['index'] = idx
3748 
3749             # We add the table index to Series inputs (MaskedColumn with int values) to override
3750             # its default RangeIndex, see #11432
3751             for v in out.values():
3752                 if isinstance(v, Series):
3753                     v.index = idx
3754 
3755         df = DataFrame(out, **kwargs)
3756         if index:
3757             # Explicitly set the pandas DataFrame index to the original table
3758             # index name.
3759             df.index.name = idx.info.name
3760 
3761         return df
3762 
3763     @classmethod
3764     def from_pandas(cls, dataframe, index=False, units=None):
3765         """
3766         Create a `~astropy.table.Table` from a :class:`pandas.DataFrame` instance
3767 
3768         In addition to converting generic numeric or string columns, this supports
3769         conversion of pandas Date and Time delta columns to `~astropy.time.Time`
3770         and `~astropy.time.TimeDelta` columns, respectively.
3771 
3772         Parameters
3773         ----------
3774         dataframe : :class:`pandas.DataFrame`
3775             A pandas :class:`pandas.DataFrame` instance
3776         index : bool
3777             Include the index column in the returned table (default=False)
3778         units: dict
3779             A dict mapping column names to to a `~astropy.units.Unit`.
3780             The columns will have the specified unit in the Table.
3781 
3782         Returns
3783         -------
3784         table : `~astropy.table.Table`
3785             A `~astropy.table.Table` (or subclass) instance
3786 
3787         Raises
3788         ------
3789         ImportError
3790             If pandas is not installed
3791 
3792         Examples
3793         --------
3794         Here we convert a :class:`pandas.DataFrame` instance
3795         to a `~astropy.table.QTable`.
3796 
3797           >>> import numpy as np
3798           >>> import pandas as pd
3799           >>> from astropy.table import QTable
3800 
3801           >>> time = pd.Series(['1998-01-01', '2002-01-01'], dtype='datetime64[ns]')
3802           >>> dt = pd.Series(np.array([1, 300], dtype='timedelta64[s]'))
3803           >>> df = pd.DataFrame({'time': time})
3804           >>> df['dt'] = dt
3805           >>> df['x'] = [3., 4.]
3806           >>> with pd.option_context('display.max_columns', 20):
3807           ...     print(df)
3808                   time              dt    x
3809           0 1998-01-01 0 days 00:00:01  3.0
3810           1 2002-01-01 0 days 00:05:00  4.0
3811 
3812           >>> QTable.from_pandas(df)
3813           <QTable length=2>
3814                     time              dt       x
3815                     Time          TimeDelta float64
3816           ----------------------- --------- -------
3817           1998-01-01T00:00:00.000       1.0     3.0
3818           2002-01-01T00:00:00.000     300.0     4.0
3819 
3820         """
3821 
3822         out = OrderedDict()
3823 
3824         names = list(dataframe.columns)
3825         columns = [dataframe[name] for name in names]
3826         datas = [np.array(column) for column in columns]
3827         masks = [np.array(column.isnull()) for column in columns]
3828 
3829         if index:
3830             index_name = dataframe.index.name or 'index'
3831             while index_name in names:
3832                 index_name = '_' + index_name + '_'
3833             names.insert(0, index_name)
3834             columns.insert(0, dataframe.index)
3835             datas.insert(0, np.array(dataframe.index))
3836             masks.insert(0, np.zeros(len(dataframe), dtype=bool))
3837 
3838         if units is None:
3839             units = [None] * len(names)
3840         else:
3841             if not isinstance(units, Mapping):
3842                 raise TypeError('Expected a Mapping "column-name" -> "unit"')
3843 
3844             not_found = set(units.keys()) - set(names)
3845             if not_found:
3846                 warnings.warn(f'`units` contains additional columns: {not_found}')
3847 
3848             units = [units.get(name) for name in names]
3849 
3850         for name, column, data, mask, unit in zip(names, columns, datas, masks, units):
3851 
3852             if column.dtype.kind in ['u', 'i'] and np.any(mask):
3853                 # Special-case support for pandas nullable int
3854                 np_dtype = str(column.dtype).lower()
3855                 data = np.zeros(shape=column.shape, dtype=np_dtype)
3856                 data[~mask] = column[~mask]
3857                 out[name] = MaskedColumn(data=data, name=name, mask=mask, unit=unit, copy=False)
3858                 continue
3859 
3860             if data.dtype.kind == 'O':
3861                 # If all elements of an object array are string-like or np.nan
3862                 # then coerce back to a native numpy str/unicode array.
3863                 string_types = (str, bytes)
3864                 nan = np.nan
3865                 if all(isinstance(x, string_types) or x is nan for x in data):
3866                     # Force any missing (null) values to b''.  Numpy will
3867                     # upcast to str/unicode as needed.
3868                     data[mask] = b''
3869 
3870                     # When the numpy object array is represented as a list then
3871                     # numpy initializes to the correct string or unicode type.
3872                     data = np.array([x for x in data])
3873 
3874             # Numpy datetime64
3875             if data.dtype.kind == 'M':
3876                 from astropy.time import Time
3877                 out[name] = Time(data, format='datetime64')
3878                 if np.any(mask):
3879                     out[name][mask] = np.ma.masked
3880                 out[name].format = 'isot'
3881 
3882             # Numpy timedelta64
3883             elif data.dtype.kind == 'm':
3884                 from astropy.time import TimeDelta
3885                 data_sec = data.astype('timedelta64[ns]').astype(np.float64) / 1e9
3886                 out[name] = TimeDelta(data_sec, format='sec')
3887                 if np.any(mask):
3888                     out[name][mask] = np.ma.masked
3889 
3890             else:
3891                 if np.any(mask):
3892                     out[name] = MaskedColumn(data=data, name=name, mask=mask, unit=unit)
3893                 else:
3894                     out[name] = Column(data=data, name=name, unit=unit)
3895 
3896         return cls(out)
3897 
3898     info = TableInfo()

</code><intended_behavior>Ensure that any method within the `Table` class that leads to HTML output generation (either directly or indirectly through utility methods or class instantiation) properly propagates the `formats` argument to the HTML writing logic. The precise adjustment needed may vary based on the method's current responsibilities and its role in HTML output generation. The goal is to provide a seamless and consistent interface for users, where specifying formats for table output produces the expected results regardless of the output format chosen.</intended_behavior>]
2025-10-17 09:43:25.786 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 09:43:25.786 | INFO     | Search-only: skipping patch selection
2025-10-17 09:43:25.923 | INFO     | Task astropy__astropy-13453 completed successfully.
2025-10-17 09:43:25.924 | INFO     | No patch generated. You can try running ACR again.
