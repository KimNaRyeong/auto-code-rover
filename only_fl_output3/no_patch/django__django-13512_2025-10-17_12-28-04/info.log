2025-10-17 12:28:05.157 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 12:28:09.877 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=196, output_tokens=12, cost=0.002320
2025-10-17 12:28:09.877 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 12:28:09.881 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:28:19.244 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=501, output_tokens=373, cost=0.016200
2025-10-17 12:28:19.248 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:28:22.170 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=727, output_tokens=34, cost=0.008290
2025-10-17 12:28:22.171 | DEBUG    | Extracted a valid json.
2025-10-17 12:28:22.171 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"JSONField\")",
        "search_code(\"json.dumps\")"
    ],
    "bug_locations": []
}
2025-10-17 12:28:22.288 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 12:28:22.289 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 12:28:38.226 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1771, output_tokens=630, cost=0.036610
2025-10-17 12:28:38.232 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:28:43.575 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2617, output_tokens=219, cost=0.032740
2025-10-17 12:28:43.582 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:28:51.192 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=573, output_tokens=252, cost=0.013290
2025-10-17 12:28:51.193 | DEBUG    | Extracted a valid json.
2025-10-17 12:28:51.193 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/json.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify the serialization logic to ensure `json.dumps` is called with the `ensure_ascii=False` option when serializing JSON data for `JSONField`. This will allow Unicode characters to be displayed properly in the Django admin by default, instead of being escaped as ASCII sequences. This change should preserve the field's existing functionality in all contexts, including form submissions, database storage, and admin display."
        },
        {
            "file": "django/contrib/admin/options.py",
            "class": "",
            "method": "",
            "intended_behavior": "Review and adjust how `JSONField` data is prepared and displayed in the admin interface, specifically in methods that handle or display field values in the admin forms or list displays. If `json.dumps` is used to serialize `JSONField` data for display, ensure it uses `ensure_ascii=False`. This adjustment is to ensure that the admin interface properly displays Unicode characters contained in `JSONField`, enhancing user experience without affecting the admin's performance or security."
        }
    ]
}
2025-10-17 12:28:51.203 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/json.py</file>
<class>None</class>
<method>None</method>
<code>
1 import json
2 
3 from django import forms
4 from django.core import checks, exceptions
5 from django.db import NotSupportedError, connections, router
6 from django.db.models import lookups
7 from django.db.models.lookups import PostgresOperatorLookup, Transform
8 from django.utils.translation import gettext_lazy as _
9 
10 from . import Field
11 from .mixins import CheckFieldDefaultMixin
12 
13 __all__ = ['JSONField']
14 
15 
16 class JSONField(CheckFieldDefaultMixin, Field):
17     empty_strings_allowed = False
18     description = _('A JSON object')
19     default_error_messages = {
20         'invalid': _('Value must be valid JSON.'),
21     }
22     _default_hint = ('dict', '{}')
23 
24     def __init__(
25         self, verbose_name=None, name=None, encoder=None, decoder=None,
26         **kwargs,
27     ):
28         if encoder and not callable(encoder):
29             raise ValueError('The encoder parameter must be a callable object.')
30         if decoder and not callable(decoder):
31             raise ValueError('The decoder parameter must be a callable object.')
32         self.encoder = encoder
33         self.decoder = decoder
34         super().__init__(verbose_name, name, **kwargs)
35 
36     def check(self, **kwargs):
37         errors = super().check(**kwargs)
38         databases = kwargs.get('databases') or []
39         errors.extend(self._check_supported(databases))
40         return errors
41 
42     def _check_supported(self, databases):
43         errors = []
44         for db in databases:
45             if not router.allow_migrate_model(db, self.model):
46                 continue
47             connection = connections[db]
48             if not (
49                 'supports_json_field' in self.model._meta.required_db_features or
50                 connection.features.supports_json_field
51             ):
52                 errors.append(
53                     checks.Error(
54                         '%s does not support JSONFields.'
55                         % connection.display_name,
56                         obj=self.model,
57                         id='fields.E180',
58                     )
59                 )
60         return errors
61 
62     def deconstruct(self):
63         name, path, args, kwargs = super().deconstruct()
64         if self.encoder is not None:
65             kwargs['encoder'] = self.encoder
66         if self.decoder is not None:
67             kwargs['decoder'] = self.decoder
68         return name, path, args, kwargs
69 
70     def from_db_value(self, value, expression, connection):
71         if value is None:
72             return value
73         try:
74             return json.loads(value, cls=self.decoder)
75         except json.JSONDecodeError:
76             return value
77 
78     def get_internal_type(self):
79         return 'JSONField'
80 
81     def get_prep_value(self, value):
82         if value is None:
83             return value
84         return json.dumps(value, cls=self.encoder)
85 
86     def get_transform(self, name):
87         transform = super().get_transform(name)
88         if transform:
89             return transform
90         return KeyTransformFactory(name)
91 
92     def validate(self, value, model_instance):
93         super().validate(value, model_instance)
94         try:
95             json.dumps(value, cls=self.encoder)
96         except TypeError:
97             raise exceptions.ValidationError(
98                 self.error_messages['invalid'],
99                 code='invalid',
100                 params={'value': value},
101             )
102 
103     def value_to_string(self, obj):
104         return self.value_from_object(obj)
105 
106     def formfield(self, **kwargs):
107         return super().formfield(**{
108             'form_class': forms.JSONField,
109             'encoder': self.encoder,
110             'decoder': self.decoder,
111             **kwargs,
112         })
113 
114 
115 def compile_json_path(key_transforms, include_root=True):
116     path = ['$'] if include_root else []
117     for key_transform in key_transforms:
118         try:
119             num = int(key_transform)
120         except ValueError:  # non-integer
121             path.append('.')
122             path.append(json.dumps(key_transform))
123         else:
124             path.append('[%s]' % num)
125     return ''.join(path)
126 
127 
128 class DataContains(PostgresOperatorLookup):
129     lookup_name = 'contains'
130     postgres_operator = '@>'
131 
132     def as_sql(self, compiler, connection):
133         if not connection.features.supports_json_field_contains:
134             raise NotSupportedError(
135                 'contains lookup is not supported on this database backend.'
136             )
137         lhs, lhs_params = self.process_lhs(compiler, connection)
138         rhs, rhs_params = self.process_rhs(compiler, connection)
139         params = tuple(lhs_params) + tuple(rhs_params)
140         return 'JSON_CONTAINS(%s, %s)' % (lhs, rhs), params
141 
142 
143 class ContainedBy(PostgresOperatorLookup):
144     lookup_name = 'contained_by'
145     postgres_operator = '<@'
146 
147     def as_sql(self, compiler, connection):
148         if not connection.features.supports_json_field_contains:
149             raise NotSupportedError(
150                 'contained_by lookup is not supported on this database backend.'
151             )
152         lhs, lhs_params = self.process_lhs(compiler, connection)
153         rhs, rhs_params = self.process_rhs(compiler, connection)
154         params = tuple(rhs_params) + tuple(lhs_params)
155         return 'JSON_CONTAINS(%s, %s)' % (rhs, lhs), params
156 
157 
158 class HasKeyLookup(PostgresOperatorLookup):
159     logical_operator = None
160 
161     def as_sql(self, compiler, connection, template=None):
162         # Process JSON path from the left-hand side.
163         if isinstance(self.lhs, KeyTransform):
164             lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)
165             lhs_json_path = compile_json_path(lhs_key_transforms)
166         else:
167             lhs, lhs_params = self.process_lhs(compiler, connection)
168             lhs_json_path = '$'
169         sql = template % lhs
170         # Process JSON path from the right-hand side.
171         rhs = self.rhs
172         rhs_params = []
173         if not isinstance(rhs, (list, tuple)):
174             rhs = [rhs]
175         for key in rhs:
176             if isinstance(key, KeyTransform):
177                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)
178             else:
179                 rhs_key_transforms = [key]
180             rhs_params.append('%s%s' % (
181                 lhs_json_path,
182                 compile_json_path(rhs_key_transforms, include_root=False),
183             ))
184         # Add condition for each key.
185         if self.logical_operator:
186             sql = '(%s)' % self.logical_operator.join([sql] * len(rhs_params))
187         return sql, tuple(lhs_params) + tuple(rhs_params)
188 
189     def as_mysql(self, compiler, connection):
190         return self.as_sql(compiler, connection, template="JSON_CONTAINS_PATH(%s, 'one', %%s)")
191 
192     def as_oracle(self, compiler, connection):
193         sql, params = self.as_sql(compiler, connection, template="JSON_EXISTS(%s, '%%s')")
194         # Add paths directly into SQL because path expressions cannot be passed
195         # as bind variables on Oracle.
196         return sql % tuple(params), []
197 
198     def as_postgresql(self, compiler, connection):
199         if isinstance(self.rhs, KeyTransform):
200             *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)
201             for key in rhs_key_transforms[:-1]:
202                 self.lhs = KeyTransform(key, self.lhs)
203             self.rhs = rhs_key_transforms[-1]
204         return super().as_postgresql(compiler, connection)
205 
206     def as_sqlite(self, compiler, connection):
207         return self.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NOT NULL')
208 
209 
210 class HasKey(HasKeyLookup):
211     lookup_name = 'has_key'
212     postgres_operator = '?'
213     prepare_rhs = False
214 
215 
216 class HasKeys(HasKeyLookup):
217     lookup_name = 'has_keys'
218     postgres_operator = '?&'
219     logical_operator = ' AND '
220 
221     def get_prep_lookup(self):
222         return [str(item) for item in self.rhs]
223 
224 
225 class HasAnyKeys(HasKeys):
226     lookup_name = 'has_any_keys'
227     postgres_operator = '?|'
228     logical_operator = ' OR '
229 
230 
231 class JSONExact(lookups.Exact):
232     can_use_none_as_rhs = True
233 
234     def process_lhs(self, compiler, connection):
235         lhs, lhs_params = super().process_lhs(compiler, connection)
236         if connection.vendor == 'sqlite':
237             rhs, rhs_params = super().process_rhs(compiler, connection)
238             if rhs == '%s' and rhs_params == [None]:
239                 # Use JSON_TYPE instead of JSON_EXTRACT for NULLs.
240                 lhs = "JSON_TYPE(%s, '$')" % lhs
241         return lhs, lhs_params
242 
243     def process_rhs(self, compiler, connection):
244         rhs, rhs_params = super().process_rhs(compiler, connection)
245         # Treat None lookup values as null.
246         if rhs == '%s' and rhs_params == [None]:
247             rhs_params = ['null']
248         if connection.vendor == 'mysql':
249             func = ["JSON_EXTRACT(%s, '$')"] * len(rhs_params)
250             rhs = rhs % tuple(func)
251         return rhs, rhs_params
252 
253 
254 JSONField.register_lookup(DataContains)
255 JSONField.register_lookup(ContainedBy)
256 JSONField.register_lookup(HasKey)
257 JSONField.register_lookup(HasKeys)
258 JSONField.register_lookup(HasAnyKeys)
259 JSONField.register_lookup(JSONExact)
260 
261 
262 class KeyTransform(Transform):
263     postgres_operator = '->'
264     postgres_nested_operator = '#>'
265 
266     def __init__(self, key_name, *args, **kwargs):
267         super().__init__(*args, **kwargs)
268         self.key_name = str(key_name)
269 
270     def preprocess_lhs(self, compiler, connection, lhs_only=False):
271         if not lhs_only:
272             key_transforms = [self.key_name]
273         previous = self.lhs
274         while isinstance(previous, KeyTransform):
275             if not lhs_only:
276                 key_transforms.insert(0, previous.key_name)
277             previous = previous.lhs
278         lhs, params = compiler.compile(previous)
279         if connection.vendor == 'oracle':
280             # Escape string-formatting.
281             key_transforms = [key.replace('%', '%%') for key in key_transforms]
282         return (lhs, params, key_transforms) if not lhs_only else (lhs, params)
283 
284     def as_mysql(self, compiler, connection):
285         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
286         json_path = compile_json_path(key_transforms)
287         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
288 
289     def as_oracle(self, compiler, connection):
290         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
291         json_path = compile_json_path(key_transforms)
292         return (
293             "COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))" %
294             ((lhs, json_path) * 2)
295         ), tuple(params) * 2
296 
297     def as_postgresql(self, compiler, connection):
298         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
299         if len(key_transforms) > 1:
300             return '(%s %s %%s)' % (lhs, self.postgres_nested_operator), params + [key_transforms]
301         try:
302             lookup = int(self.key_name)
303         except ValueError:
304             lookup = self.key_name
305         return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)
306 
307     def as_sqlite(self, compiler, connection):
308         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
309         json_path = compile_json_path(key_transforms)
310         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
311 
312 
313 class KeyTextTransform(KeyTransform):
314     postgres_operator = '->>'
315     postgres_nested_operator = '#>>'
316 
317 
318 class KeyTransformTextLookupMixin:
319     """
320     Mixin for combining with a lookup expecting a text lhs from a JSONField
321     key lookup. On PostgreSQL, make use of the ->> operator instead of casting
322     key values to text and performing the lookup on the resulting
323     representation.
324     """
325     def __init__(self, key_transform, *args, **kwargs):
326         if not isinstance(key_transform, KeyTransform):
327             raise TypeError(
328                 'Transform should be an instance of KeyTransform in order to '
329                 'use this lookup.'
330             )
331         key_text_transform = KeyTextTransform(
332             key_transform.key_name, *key_transform.source_expressions,
333             **key_transform.extra,
334         )
335         super().__init__(key_text_transform, *args, **kwargs)
336 
337 
338 class CaseInsensitiveMixin:
339     """
340     Mixin to allow case-insensitive comparison of JSON values on MySQL.
341     MySQL handles strings used in JSON context using the utf8mb4_bin collation.
342     Because utf8mb4_bin is a binary collation, comparison of JSON values is
343     case-sensitive.
344     """
345     def process_lhs(self, compiler, connection):
346         lhs, lhs_params = super().process_lhs(compiler, connection)
347         if connection.vendor == 'mysql':
348             return 'LOWER(%s)' % lhs, lhs_params
349         return lhs, lhs_params
350 
351     def process_rhs(self, compiler, connection):
352         rhs, rhs_params = super().process_rhs(compiler, connection)
353         if connection.vendor == 'mysql':
354             return 'LOWER(%s)' % rhs, rhs_params
355         return rhs, rhs_params
356 
357 
358 class KeyTransformIsNull(lookups.IsNull):
359     # key__isnull=False is the same as has_key='key'
360     def as_oracle(self, compiler, connection):
361         if not self.rhs:
362             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)
363         return super().as_sql(compiler, connection)
364 
365     def as_sqlite(self, compiler, connection):
366         if not self.rhs:
367             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)
368         return super().as_sql(compiler, connection)
369 
370 
371 class KeyTransformIn(lookups.In):
372     def process_rhs(self, compiler, connection):
373         rhs, rhs_params = super().process_rhs(compiler, connection)
374         if not connection.features.has_native_json_field:
375             func = ()
376             if connection.vendor == 'oracle':
377                 func = []
378                 for value in rhs_params:
379                     value = json.loads(value)
380                     function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
381                     func.append("%s('%s', '$.value')" % (
382                         function,
383                         json.dumps({'value': value}),
384                     ))
385                 func = tuple(func)
386                 rhs_params = ()
387             elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:
388                 func = ("JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))",) * len(rhs_params)
389             elif connection.vendor in {'sqlite', 'mysql'}:
390                 func = ("JSON_EXTRACT(%s, '$')",) * len(rhs_params)
391             rhs = rhs % func
392         return rhs, rhs_params
393 
394 
395 class KeyTransformExact(JSONExact):
396     def process_lhs(self, compiler, connection):
397         lhs, lhs_params = super().process_lhs(compiler, connection)
398         if connection.vendor == 'sqlite':
399             rhs, rhs_params = super().process_rhs(compiler, connection)
400             if rhs == '%s' and rhs_params == ['null']:
401                 lhs, _ = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)
402                 lhs = 'JSON_TYPE(%s, %%s)' % lhs
403         return lhs, lhs_params
404 
405     def process_rhs(self, compiler, connection):
406         if isinstance(self.rhs, KeyTransform):
407             return super(lookups.Exact, self).process_rhs(compiler, connection)
408         rhs, rhs_params = super().process_rhs(compiler, connection)
409         if connection.vendor == 'oracle':
410             func = []
411             for value in rhs_params:
412                 value = json.loads(value)
413                 function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
414                 func.append("%s('%s', '$.value')" % (
415                     function,
416                     json.dumps({'value': value}),
417                 ))
418             rhs = rhs % tuple(func)
419             rhs_params = []
420         elif connection.vendor == 'sqlite':
421             func = ["JSON_EXTRACT(%s, '$')" if value != 'null' else '%s' for value in rhs_params]
422             rhs = rhs % tuple(func)
423         return rhs, rhs_params
424 
425     def as_oracle(self, compiler, connection):
426         rhs, rhs_params = super().process_rhs(compiler, connection)
427         if rhs_params == ['null']:
428             # Field has key and it's NULL.
429             has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)
430             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)
431             is_null_expr = self.lhs.get_lookup('isnull')(self.lhs, True)
432             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)
433             return (
434                 '%s AND %s' % (has_key_sql, is_null_sql),
435                 tuple(has_key_params) + tuple(is_null_params),
436             )
437         return super().as_sql(compiler, connection)
438 
439 
440 class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):
441     pass
442 
443 
444 class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):
445     pass
446 
447 
448 class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):
449     pass
450 
451 
452 class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):
453     pass
454 
455 
456 class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):
457     pass
458 
459 
460 class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):
461     pass
462 
463 
464 class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):
465     pass
466 
467 
468 class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):
469     pass
470 
471 
472 class KeyTransformNumericLookupMixin:
473     def process_rhs(self, compiler, connection):
474         rhs, rhs_params = super().process_rhs(compiler, connection)
475         if not connection.features.has_native_json_field:
476             rhs_params = [json.loads(value) for value in rhs_params]
477         return rhs, rhs_params
478 
479 
480 class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):
481     pass
482 
483 
484 class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):
485     pass
486 
487 
488 class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):
489     pass
490 
491 
492 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):
493     pass
494 
495 
496 KeyTransform.register_lookup(KeyTransformIn)
497 KeyTransform.register_lookup(KeyTransformExact)
498 KeyTransform.register_lookup(KeyTransformIExact)
499 KeyTransform.register_lookup(KeyTransformIsNull)
500 KeyTransform.register_lookup(KeyTransformIContains)
501 KeyTransform.register_lookup(KeyTransformStartsWith)
502 KeyTransform.register_lookup(KeyTransformIStartsWith)
503 KeyTransform.register_lookup(KeyTransformEndsWith)
504 KeyTransform.register_lookup(KeyTransformIEndsWith)
505 KeyTransform.register_lookup(KeyTransformRegex)
506 KeyTransform.register_lookup(KeyTransformIRegex)
507 
508 KeyTransform.register_lookup(KeyTransformLt)
509 KeyTransform.register_lookup(KeyTransformLte)
510 KeyTransform.register_lookup(KeyTransformGt)
511 KeyTransform.register_lookup(KeyTransformGte)
512 
513 
514 class KeyTransformFactory:
515 
516     def __init__(self, key_name):
517         self.key_name = key_name
518 
519     def __call__(self, *args, **kwargs):
520         return KeyTransform(self.key_name, *args, **kwargs)

</code><intended_behavior>Modify the serialization logic to ensure `json.dumps` is called with the `ensure_ascii=False` option when serializing JSON data for `JSONField`. This will allow Unicode characters to be displayed properly in the Django admin by default, instead of being escaped as ASCII sequences. This change should preserve the field's existing functionality in all contexts, including form submissions, database storage, and admin display.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import json
3 import operator
4 import re
5 from functools import partial, reduce, update_wrapper
6 from urllib.parse import quote as urlquote
7 
8 from django import forms
9 from django.conf import settings
10 from django.contrib import messages
11 from django.contrib.admin import helpers, widgets
12 from django.contrib.admin.checks import (
13     BaseModelAdminChecks, InlineModelAdminChecks, ModelAdminChecks,
14 )
15 from django.contrib.admin.exceptions import DisallowedModelAdminToField
16 from django.contrib.admin.templatetags.admin_urls import add_preserved_filters
17 from django.contrib.admin.utils import (
18     NestedObjects, construct_change_message, flatten_fieldsets,
19     get_deleted_objects, lookup_needs_distinct, model_format_dict,
20     model_ngettext, quote, unquote,
21 )
22 from django.contrib.admin.views.autocomplete import AutocompleteJsonView
23 from django.contrib.admin.widgets import (
24     AutocompleteSelect, AutocompleteSelectMultiple,
25 )
26 from django.contrib.auth import get_permission_codename
27 from django.core.exceptions import (
28     FieldDoesNotExist, FieldError, PermissionDenied, ValidationError,
29 )
30 from django.core.paginator import Paginator
31 from django.db import models, router, transaction
32 from django.db.models.constants import LOOKUP_SEP
33 from django.forms.formsets import DELETION_FIELD_NAME, all_valid
34 from django.forms.models import (
35     BaseInlineFormSet, inlineformset_factory, modelform_defines_fields,
36     modelform_factory, modelformset_factory,
37 )
38 from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple
39 from django.http import HttpResponseRedirect
40 from django.http.response import HttpResponseBase
41 from django.template.response import SimpleTemplateResponse, TemplateResponse
42 from django.urls import reverse
43 from django.utils.decorators import method_decorator
44 from django.utils.html import format_html
45 from django.utils.http import urlencode
46 from django.utils.safestring import mark_safe
47 from django.utils.text import (
48     capfirst, format_lazy, get_text_list, smart_split, unescape_string_literal,
49 )
50 from django.utils.translation import gettext as _, ngettext
51 from django.views.decorators.csrf import csrf_protect
52 from django.views.generic import RedirectView
53 
54 IS_POPUP_VAR = '_popup'
55 TO_FIELD_VAR = '_to_field'
56 
57 
58 HORIZONTAL, VERTICAL = 1, 2
59 
60 
61 def get_content_type_for_model(obj):
62     # Since this module gets imported in the application's root package,
63     # it cannot import models from other applications at the module level.
64     from django.contrib.contenttypes.models import ContentType
65     return ContentType.objects.get_for_model(obj, for_concrete_model=False)
66 
67 
68 def get_ul_class(radio_style):
69     return 'radiolist' if radio_style == VERTICAL else 'radiolist inline'
70 
71 
72 class IncorrectLookupParameters(Exception):
73     pass
74 
75 
76 # Defaults for formfield_overrides. ModelAdmin subclasses can change this
77 # by adding to ModelAdmin.formfield_overrides.
78 
79 FORMFIELD_FOR_DBFIELD_DEFAULTS = {
80     models.DateTimeField: {
81         'form_class': forms.SplitDateTimeField,
82         'widget': widgets.AdminSplitDateTime
83     },
84     models.DateField: {'widget': widgets.AdminDateWidget},
85     models.TimeField: {'widget': widgets.AdminTimeWidget},
86     models.TextField: {'widget': widgets.AdminTextareaWidget},
87     models.URLField: {'widget': widgets.AdminURLFieldWidget},
88     models.IntegerField: {'widget': widgets.AdminIntegerFieldWidget},
89     models.BigIntegerField: {'widget': widgets.AdminBigIntegerFieldWidget},
90     models.CharField: {'widget': widgets.AdminTextInputWidget},
91     models.ImageField: {'widget': widgets.AdminFileWidget},
92     models.FileField: {'widget': widgets.AdminFileWidget},
93     models.EmailField: {'widget': widgets.AdminEmailInputWidget},
94     models.UUIDField: {'widget': widgets.AdminUUIDInputWidget},
95 }
96 
97 csrf_protect_m = method_decorator(csrf_protect)
98 
99 
100 class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
101     """Functionality common to both ModelAdmin and InlineAdmin."""
102 
103     autocomplete_fields = ()
104     raw_id_fields = ()
105     fields = None
106     exclude = None
107     fieldsets = None
108     form = forms.ModelForm
109     filter_vertical = ()
110     filter_horizontal = ()
111     radio_fields = {}
112     prepopulated_fields = {}
113     formfield_overrides = {}
114     readonly_fields = ()
115     ordering = None
116     sortable_by = None
117     view_on_site = True
118     show_full_result_count = True
119     checks_class = BaseModelAdminChecks
120 
121     def check(self, **kwargs):
122         return self.checks_class().check(self, **kwargs)
123 
124     def __init__(self):
125         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides
126         # rather than simply overwriting.
127         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)
128         for k, v in self.formfield_overrides.items():
129             overrides.setdefault(k, {}).update(v)
130         self.formfield_overrides = overrides
131 
132     def formfield_for_dbfield(self, db_field, request, **kwargs):
133         """
134         Hook for specifying the form Field instance for a given database Field
135         instance.
136 
137         If kwargs are given, they're passed to the form Field's constructor.
138         """
139         # If the field specifies choices, we don't need to look for special
140         # admin widgets - we just need to use a select widget of some kind.
141         if db_field.choices:
142             return self.formfield_for_choice_field(db_field, request, **kwargs)
143 
144         # ForeignKey or ManyToManyFields
145         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):
146             # Combine the field kwargs with any options for formfield_overrides.
147             # Make sure the passed in **kwargs override anything in
148             # formfield_overrides because **kwargs is more specific, and should
149             # always win.
150             if db_field.__class__ in self.formfield_overrides:
151                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}
152 
153             # Get the correct formfield.
154             if isinstance(db_field, models.ForeignKey):
155                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)
156             elif isinstance(db_field, models.ManyToManyField):
157                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)
158 
159             # For non-raw_id fields, wrap the widget with a wrapper that adds
160             # extra HTML -- the "add other" interface -- to the end of the
161             # rendered output. formfield can be None if it came from a
162             # OneToOneField with parent_link=True or a M2M intermediary.
163             if formfield and db_field.name not in self.raw_id_fields:
164                 related_modeladmin = self.admin_site._registry.get(db_field.remote_field.model)
165                 wrapper_kwargs = {}
166                 if related_modeladmin:
167                     wrapper_kwargs.update(
168                         can_add_related=related_modeladmin.has_add_permission(request),
169                         can_change_related=related_modeladmin.has_change_permission(request),
170                         can_delete_related=related_modeladmin.has_delete_permission(request),
171                         can_view_related=related_modeladmin.has_view_permission(request),
172                     )
173                 formfield.widget = widgets.RelatedFieldWidgetWrapper(
174                     formfield.widget, db_field.remote_field, self.admin_site, **wrapper_kwargs
175                 )
176 
177             return formfield
178 
179         # If we've got overrides for the formfield defined, use 'em. **kwargs
180         # passed to formfield_for_dbfield override the defaults.
181         for klass in db_field.__class__.mro():
182             if klass in self.formfield_overrides:
183                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}
184                 return db_field.formfield(**kwargs)
185 
186         # For any other type of field, just call its formfield() method.
187         return db_field.formfield(**kwargs)
188 
189     def formfield_for_choice_field(self, db_field, request, **kwargs):
190         """
191         Get a form Field for a database Field that has declared choices.
192         """
193         # If the field is named as a radio_field, use a RadioSelect
194         if db_field.name in self.radio_fields:
195             # Avoid stomping on custom widget/choices arguments.
196             if 'widget' not in kwargs:
197                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={
198                     'class': get_ul_class(self.radio_fields[db_field.name]),
199                 })
200             if 'choices' not in kwargs:
201                 kwargs['choices'] = db_field.get_choices(
202                     include_blank=db_field.blank,
203                     blank_choice=[('', _('None'))]
204                 )
205         return db_field.formfield(**kwargs)
206 
207     def get_field_queryset(self, db, db_field, request):
208         """
209         If the ModelAdmin specifies ordering, the queryset should respect that
210         ordering.  Otherwise don't specify the queryset, let the field decide
211         (return None in that case).
212         """
213         related_admin = self.admin_site._registry.get(db_field.remote_field.model)
214         if related_admin is not None:
215             ordering = related_admin.get_ordering(request)
216             if ordering is not None and ordering != ():
217                 return db_field.remote_field.model._default_manager.using(db).order_by(*ordering)
218         return None
219 
220     def formfield_for_foreignkey(self, db_field, request, **kwargs):
221         """
222         Get a form Field for a ForeignKey.
223         """
224         db = kwargs.get('using')
225 
226         if 'widget' not in kwargs:
227             if db_field.name in self.get_autocomplete_fields(request):
228                 kwargs['widget'] = AutocompleteSelect(db_field.remote_field, self.admin_site, using=db)
229             elif db_field.name in self.raw_id_fields:
230                 kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)
231             elif db_field.name in self.radio_fields:
232                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={
233                     'class': get_ul_class(self.radio_fields[db_field.name]),
234                 })
235                 kwargs['empty_label'] = _('None') if db_field.blank else None
236 
237         if 'queryset' not in kwargs:
238             queryset = self.get_field_queryset(db, db_field, request)
239             if queryset is not None:
240                 kwargs['queryset'] = queryset
241 
242         return db_field.formfield(**kwargs)
243 
244     def formfield_for_manytomany(self, db_field, request, **kwargs):
245         """
246         Get a form Field for a ManyToManyField.
247         """
248         # If it uses an intermediary model that isn't auto created, don't show
249         # a field in admin.
250         if not db_field.remote_field.through._meta.auto_created:
251             return None
252         db = kwargs.get('using')
253 
254         if 'widget' not in kwargs:
255             autocomplete_fields = self.get_autocomplete_fields(request)
256             if db_field.name in autocomplete_fields:
257                 kwargs['widget'] = AutocompleteSelectMultiple(
258                     db_field.remote_field,
259                     self.admin_site,
260                     using=db,
261                 )
262             elif db_field.name in self.raw_id_fields:
263                 kwargs['widget'] = widgets.ManyToManyRawIdWidget(
264                     db_field.remote_field,
265                     self.admin_site,
266                     using=db,
267                 )
268             elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:
269                 kwargs['widget'] = widgets.FilteredSelectMultiple(
270                     db_field.verbose_name,
271                     db_field.name in self.filter_vertical
272                 )
273         if 'queryset' not in kwargs:
274             queryset = self.get_field_queryset(db, db_field, request)
275             if queryset is not None:
276                 kwargs['queryset'] = queryset
277 
278         form_field = db_field.formfield(**kwargs)
279         if (isinstance(form_field.widget, SelectMultiple) and
280                 not isinstance(form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple))):
281             msg = _('Hold down “Control”, or “Command” on a Mac, to select more than one.')
282             help_text = form_field.help_text
283             form_field.help_text = format_lazy('{} {}', help_text, msg) if help_text else msg
284         return form_field
285 
286     def get_autocomplete_fields(self, request):
287         """
288         Return a list of ForeignKey and/or ManyToMany fields which should use
289         an autocomplete widget.
290         """
291         return self.autocomplete_fields
292 
293     def get_view_on_site_url(self, obj=None):
294         if obj is None or not self.view_on_site:
295             return None
296 
297         if callable(self.view_on_site):
298             return self.view_on_site(obj)
299         elif self.view_on_site and hasattr(obj, 'get_absolute_url'):
300             # use the ContentType lookup if view_on_site is True
301             return reverse('admin:view_on_site', kwargs={
302                 'content_type_id': get_content_type_for_model(obj).pk,
303                 'object_id': obj.pk
304             })
305 
306     def get_empty_value_display(self):
307         """
308         Return the empty_value_display set on ModelAdmin or AdminSite.
309         """
310         try:
311             return mark_safe(self.empty_value_display)
312         except AttributeError:
313             return mark_safe(self.admin_site.empty_value_display)
314 
315     def get_exclude(self, request, obj=None):
316         """
317         Hook for specifying exclude.
318         """
319         return self.exclude
320 
321     def get_fields(self, request, obj=None):
322         """
323         Hook for specifying fields.
324         """
325         if self.fields:
326             return self.fields
327         # _get_form_for_get_fields() is implemented in subclasses.
328         form = self._get_form_for_get_fields(request, obj)
329         return [*form.base_fields, *self.get_readonly_fields(request, obj)]
330 
331     def get_fieldsets(self, request, obj=None):
332         """
333         Hook for specifying fieldsets.
334         """
335         if self.fieldsets:
336             return self.fieldsets
337         return [(None, {'fields': self.get_fields(request, obj)})]
338 
339     def get_inlines(self, request, obj):
340         """Hook for specifying custom inlines."""
341         return self.inlines
342 
343     def get_ordering(self, request):
344         """
345         Hook for specifying field ordering.
346         """
347         return self.ordering or ()  # otherwise we might try to *None, which is bad ;)
348 
349     def get_readonly_fields(self, request, obj=None):
350         """
351         Hook for specifying custom readonly fields.
352         """
353         return self.readonly_fields
354 
355     def get_prepopulated_fields(self, request, obj=None):
356         """
357         Hook for specifying custom prepopulated fields.
358         """
359         return self.prepopulated_fields
360 
361     def get_queryset(self, request):
362         """
363         Return a QuerySet of all model instances that can be edited by the
364         admin site. This is used by changelist_view.
365         """
366         qs = self.model._default_manager.get_queryset()
367         # TODO: this should be handled by some parameter to the ChangeList.
368         ordering = self.get_ordering(request)
369         if ordering:
370             qs = qs.order_by(*ordering)
371         return qs
372 
373     def get_sortable_by(self, request):
374         """Hook for specifying which fields can be sorted in the changelist."""
375         return self.sortable_by if self.sortable_by is not None else self.get_list_display(request)
376 
377     def lookup_allowed(self, lookup, value):
378         from django.contrib.admin.filters import SimpleListFilter
379 
380         model = self.model
381         # Check FKey lookups that are allowed, so that popups produced by
382         # ForeignKeyRawIdWidget, on the basis of ForeignKey.limit_choices_to,
383         # are allowed to work.
384         for fk_lookup in model._meta.related_fkey_lookups:
385             # As ``limit_choices_to`` can be a callable, invoke it here.
386             if callable(fk_lookup):
387                 fk_lookup = fk_lookup()
388             if (lookup, value) in widgets.url_params_from_lookup_dict(fk_lookup).items():
389                 return True
390 
391         relation_parts = []
392         prev_field = None
393         for part in lookup.split(LOOKUP_SEP):
394             try:
395                 field = model._meta.get_field(part)
396             except FieldDoesNotExist:
397                 # Lookups on nonexistent fields are ok, since they're ignored
398                 # later.
399                 break
400             # It is allowed to filter on values that would be found from local
401             # model anyways. For example, if you filter on employee__department__id,
402             # then the id value would be found already from employee__department_id.
403             if not prev_field or (prev_field.is_relation and
404                                   field not in prev_field.get_path_info()[-1].target_fields):
405                 relation_parts.append(part)
406             if not getattr(field, 'get_path_info', None):
407                 # This is not a relational field, so further parts
408                 # must be transforms.
409                 break
410             prev_field = field
411             model = field.get_path_info()[-1].to_opts.model
412 
413         if len(relation_parts) <= 1:
414             # Either a local field filter, or no fields at all.
415             return True
416         valid_lookups = {self.date_hierarchy}
417         for filter_item in self.list_filter:
418             if isinstance(filter_item, type) and issubclass(filter_item, SimpleListFilter):
419                 valid_lookups.add(filter_item.parameter_name)
420             elif isinstance(filter_item, (list, tuple)):
421                 valid_lookups.add(filter_item[0])
422             else:
423                 valid_lookups.add(filter_item)
424 
425         # Is it a valid relational lookup?
426         return not {
427             LOOKUP_SEP.join(relation_parts),
428             LOOKUP_SEP.join(relation_parts + [part])
429         }.isdisjoint(valid_lookups)
430 
431     def to_field_allowed(self, request, to_field):
432         """
433         Return True if the model associated with this admin should be
434         allowed to be referenced by the specified field.
435         """
436         opts = self.model._meta
437 
438         try:
439             field = opts.get_field(to_field)
440         except FieldDoesNotExist:
441             return False
442 
443         # Always allow referencing the primary key since it's already possible
444         # to get this information from the change view URL.
445         if field.primary_key:
446             return True
447 
448         # Allow reverse relationships to models defining m2m fields if they
449         # target the specified field.
450         for many_to_many in opts.many_to_many:
451             if many_to_many.m2m_target_field_name() == to_field:
452                 return True
453 
454         # Make sure at least one of the models registered for this site
455         # references this field through a FK or a M2M relationship.
456         registered_models = set()
457         for model, admin in self.admin_site._registry.items():
458             registered_models.add(model)
459             for inline in admin.inlines:
460                 registered_models.add(inline.model)
461 
462         related_objects = (
463             f for f in opts.get_fields(include_hidden=True)
464             if (f.auto_created and not f.concrete)
465         )
466         for related_object in related_objects:
467             related_model = related_object.related_model
468             remote_field = related_object.field.remote_field
469             if (any(issubclass(model, related_model) for model in registered_models) and
470                     hasattr(remote_field, 'get_related_field') and
471                     remote_field.get_related_field() == field):
472                 return True
473 
474         return False
475 
476     def has_add_permission(self, request):
477         """
478         Return True if the given request has permission to add an object.
479         Can be overridden by the user in subclasses.
480         """
481         opts = self.opts
482         codename = get_permission_codename('add', opts)
483         return request.user.has_perm("%s.%s" % (opts.app_label, codename))
484 
485     def has_change_permission(self, request, obj=None):
486         """
487         Return True if the given request has permission to change the given
488         Django model instance, the default implementation doesn't examine the
489         `obj` parameter.
490 
491         Can be overridden by the user in subclasses. In such case it should
492         return True if the given request has permission to change the `obj`
493         model instance. If `obj` is None, this should return True if the given
494         request has permission to change *any* object of the given type.
495         """
496         opts = self.opts
497         codename = get_permission_codename('change', opts)
498         return request.user.has_perm("%s.%s" % (opts.app_label, codename))
499 
500     def has_delete_permission(self, request, obj=None):
501         """
502         Return True if the given request has permission to change the given
503         Django model instance, the default implementation doesn't examine the
504         `obj` parameter.
505 
506         Can be overridden by the user in subclasses. In such case it should
507         return True if the given request has permission to delete the `obj`
508         model instance. If `obj` is None, this should return True if the given
509         request has permission to delete *any* object of the given type.
510         """
511         opts = self.opts
512         codename = get_permission_codename('delete', opts)
513         return request.user.has_perm("%s.%s" % (opts.app_label, codename))
514 
515     def has_view_permission(self, request, obj=None):
516         """
517         Return True if the given request has permission to view the given
518         Django model instance. The default implementation doesn't examine the
519         `obj` parameter.
520 
521         If overridden by the user in subclasses, it should return True if the
522         given request has permission to view the `obj` model instance. If `obj`
523         is None, it should return True if the request has permission to view
524         any object of the given type.
525         """
526         opts = self.opts
527         codename_view = get_permission_codename('view', opts)
528         codename_change = get_permission_codename('change', opts)
529         return (
530             request.user.has_perm('%s.%s' % (opts.app_label, codename_view)) or
531             request.user.has_perm('%s.%s' % (opts.app_label, codename_change))
532         )
533 
534     def has_view_or_change_permission(self, request, obj=None):
535         return self.has_view_permission(request, obj) or self.has_change_permission(request, obj)
536 
537     def has_module_permission(self, request):
538         """
539         Return True if the given request has any permission in the given
540         app label.
541 
542         Can be overridden by the user in subclasses. In such case it should
543         return True if the given request has permission to view the module on
544         the admin index page and access the module's index page. Overriding it
545         does not restrict access to the add, change or delete views. Use
546         `ModelAdmin.has_(add|change|delete)_permission` for that.
547         """
548         return request.user.has_module_perms(self.opts.app_label)
549 
550 
551 class ModelAdmin(BaseModelAdmin):
552     """Encapsulate all admin options and functionality for a given model."""
553 
554     list_display = ('__str__',)
555     list_display_links = ()
556     list_filter = ()
557     list_select_related = False
558     list_per_page = 100
559     list_max_show_all = 200
560     list_editable = ()
561     search_fields = ()
562     date_hierarchy = None
563     save_as = False
564     save_as_continue = True
565     save_on_top = False
566     paginator = Paginator
567     preserve_filters = True
568     inlines = []
569 
570     # Custom templates (designed to be over-ridden in subclasses)
571     add_form_template = None
572     change_form_template = None
573     change_list_template = None
574     delete_confirmation_template = None
575     delete_selected_confirmation_template = None
576     object_history_template = None
577     popup_response_template = None
578 
579     # Actions
580     actions = []
581     action_form = helpers.ActionForm
582     actions_on_top = True
583     actions_on_bottom = False
584     actions_selection_counter = True
585     checks_class = ModelAdminChecks
586 
587     def __init__(self, model, admin_site):
588         self.model = model
589         self.opts = model._meta
590         self.admin_site = admin_site
591         super().__init__()
592 
593     def __str__(self):
594         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
595 
596     def get_inline_instances(self, request, obj=None):
597         inline_instances = []
598         for inline_class in self.get_inlines(request, obj):
599             inline = inline_class(self.model, self.admin_site)
600             if request:
601                 if not (inline.has_view_or_change_permission(request, obj) or
602                         inline.has_add_permission(request, obj) or
603                         inline.has_delete_permission(request, obj)):
604                     continue
605                 if not inline.has_add_permission(request, obj):
606                     inline.max_num = 0
607             inline_instances.append(inline)
608 
609         return inline_instances
610 
611     def get_urls(self):
612         from django.urls import path
613 
614         def wrap(view):
615             def wrapper(*args, **kwargs):
616                 return self.admin_site.admin_view(view)(*args, **kwargs)
617             wrapper.model_admin = self
618             return update_wrapper(wrapper, view)
619 
620         info = self.model._meta.app_label, self.model._meta.model_name
621 
622         return [
623             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
624             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
625             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),
626             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
627             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
628             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
629             # For backwards compatibility (was the change url before 1.9)
630             path('<path:object_id>/', wrap(RedirectView.as_view(
631                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
632             ))),
633         ]
634 
635     @property
636     def urls(self):
637         return self.get_urls()
638 
639     @property
640     def media(self):
641         extra = '' if settings.DEBUG else '.min'
642         js = [
643             'vendor/jquery/jquery%s.js' % extra,
644             'jquery.init.js',
645             'core.js',
646             'admin/RelatedObjectLookups.js',
647             'actions.js',
648             'urlify.js',
649             'prepopulate.js',
650             'vendor/xregexp/xregexp%s.js' % extra,
651         ]
652         return forms.Media(js=['admin/js/%s' % url for url in js])
653 
654     def get_model_perms(self, request):
655         """
656         Return a dict of all perms for this model. This dict has the keys
657         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
658         for each of those actions.
659         """
660         return {
661             'add': self.has_add_permission(request),
662             'change': self.has_change_permission(request),
663             'delete': self.has_delete_permission(request),
664             'view': self.has_view_permission(request),
665         }
666 
667     def _get_form_for_get_fields(self, request, obj):
668         return self.get_form(request, obj, fields=None)
669 
670     def get_form(self, request, obj=None, change=False, **kwargs):
671         """
672         Return a Form class for use in the admin add view. This is used by
673         add_view and change_view.
674         """
675         if 'fields' in kwargs:
676             fields = kwargs.pop('fields')
677         else:
678             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
679         excluded = self.get_exclude(request, obj)
680         exclude = [] if excluded is None else list(excluded)
681         readonly_fields = self.get_readonly_fields(request, obj)
682         exclude.extend(readonly_fields)
683         # Exclude all fields if it's a change form and the user doesn't have
684         # the change permission.
685         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
686             exclude.extend(fields)
687         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
688             # Take the custom ModelForm's Meta.exclude into account only if the
689             # ModelAdmin doesn't define its own.
690             exclude.extend(self.form._meta.exclude)
691         # if exclude is an empty list we pass None to be consistent with the
692         # default on modelform_factory
693         exclude = exclude or None
694 
695         # Remove declared form fields which are in readonly_fields.
696         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
697         form = type(self.form.__name__, (self.form,), new_attrs)
698 
699         defaults = {
700             'form': form,
701             'fields': fields,
702             'exclude': exclude,
703             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
704             **kwargs,
705         }
706 
707         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
708             defaults['fields'] = forms.ALL_FIELDS
709 
710         try:
711             return modelform_factory(self.model, **defaults)
712         except FieldError as e:
713             raise FieldError(
714                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
715                 % (e, self.__class__.__name__)
716             )
717 
718     def get_changelist(self, request, **kwargs):
719         """
720         Return the ChangeList class for use on the changelist page.
721         """
722         from django.contrib.admin.views.main import ChangeList
723         return ChangeList
724 
725     def get_changelist_instance(self, request):
726         """
727         Return a `ChangeList` instance based on `request`. May raise
728         `IncorrectLookupParameters`.
729         """
730         list_display = self.get_list_display(request)
731         list_display_links = self.get_list_display_links(request, list_display)
732         # Add the action checkboxes if any actions are available.
733         if self.get_actions(request):
734             list_display = ['action_checkbox', *list_display]
735         sortable_by = self.get_sortable_by(request)
736         ChangeList = self.get_changelist(request)
737         return ChangeList(
738             request,
739             self.model,
740             list_display,
741             list_display_links,
742             self.get_list_filter(request),
743             self.date_hierarchy,
744             self.get_search_fields(request),
745             self.get_list_select_related(request),
746             self.list_per_page,
747             self.list_max_show_all,
748             self.list_editable,
749             self,
750             sortable_by,
751         )
752 
753     def get_object(self, request, object_id, from_field=None):
754         """
755         Return an instance matching the field and value provided, the primary
756         key is used if no field is provided. Return ``None`` if no match is
757         found or the object_id fails validation.
758         """
759         queryset = self.get_queryset(request)
760         model = queryset.model
761         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
762         try:
763             object_id = field.to_python(object_id)
764             return queryset.get(**{field.name: object_id})
765         except (model.DoesNotExist, ValidationError, ValueError):
766             return None
767 
768     def get_changelist_form(self, request, **kwargs):
769         """
770         Return a Form class for use in the Formset on the changelist page.
771         """
772         defaults = {
773             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
774             **kwargs,
775         }
776         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
777             defaults['fields'] = forms.ALL_FIELDS
778 
779         return modelform_factory(self.model, **defaults)
780 
781     def get_changelist_formset(self, request, **kwargs):
782         """
783         Return a FormSet class for use on the changelist page if list_editable
784         is used.
785         """
786         defaults = {
787             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
788             **kwargs,
789         }
790         return modelformset_factory(
791             self.model, self.get_changelist_form(request), extra=0,
792             fields=self.list_editable, **defaults
793         )
794 
795     def get_formsets_with_inlines(self, request, obj=None):
796         """
797         Yield formsets and the corresponding inlines.
798         """
799         for inline in self.get_inline_instances(request, obj):
800             yield inline.get_formset(request, obj), inline
801 
802     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
803         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
804 
805     def log_addition(self, request, object, message):
806         """
807         Log that an object has been successfully added.
808 
809         The default implementation creates an admin LogEntry object.
810         """
811         from django.contrib.admin.models import ADDITION, LogEntry
812         return LogEntry.objects.log_action(
813             user_id=request.user.pk,
814             content_type_id=get_content_type_for_model(object).pk,
815             object_id=object.pk,
816             object_repr=str(object),
817             action_flag=ADDITION,
818             change_message=message,
819         )
820 
821     def log_change(self, request, object, message):
822         """
823         Log that an object has been successfully changed.
824 
825         The default implementation creates an admin LogEntry object.
826         """
827         from django.contrib.admin.models import CHANGE, LogEntry
828         return LogEntry.objects.log_action(
829             user_id=request.user.pk,
830             content_type_id=get_content_type_for_model(object).pk,
831             object_id=object.pk,
832             object_repr=str(object),
833             action_flag=CHANGE,
834             change_message=message,
835         )
836 
837     def log_deletion(self, request, object, object_repr):
838         """
839         Log that an object will be deleted. Note that this method must be
840         called before the deletion.
841 
842         The default implementation creates an admin LogEntry object.
843         """
844         from django.contrib.admin.models import DELETION, LogEntry
845         return LogEntry.objects.log_action(
846             user_id=request.user.pk,
847             content_type_id=get_content_type_for_model(object).pk,
848             object_id=object.pk,
849             object_repr=object_repr,
850             action_flag=DELETION,
851         )
852 
853     def action_checkbox(self, obj):
854         """
855         A list_display column containing a checkbox widget.
856         """
857         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
858     action_checkbox.short_description = mark_safe('<input type="checkbox" id="action-toggle">')
859 
860     def _get_base_actions(self):
861         """Return the list of actions, prior to any request-based filtering."""
862         actions = []
863         base_actions = (self.get_action(action) for action in self.actions or [])
864         # get_action might have returned None, so filter any of those out.
865         base_actions = [action for action in base_actions if action]
866         base_action_names = {name for _, name, _ in base_actions}
867 
868         # Gather actions from the admin site first
869         for (name, func) in self.admin_site.actions:
870             if name in base_action_names:
871                 continue
872             description = getattr(func, 'short_description', name.replace('_', ' '))
873             actions.append((func, name, description))
874         # Add actions from this ModelAdmin.
875         actions.extend(base_actions)
876         return actions
877 
878     def _filter_actions_by_permissions(self, request, actions):
879         """Filter out any actions that the user doesn't have access to."""
880         filtered_actions = []
881         for action in actions:
882             callable = action[0]
883             if not hasattr(callable, 'allowed_permissions'):
884                 filtered_actions.append(action)
885                 continue
886             permission_checks = (
887                 getattr(self, 'has_%s_permission' % permission)
888                 for permission in callable.allowed_permissions
889             )
890             if any(has_permission(request) for has_permission in permission_checks):
891                 filtered_actions.append(action)
892         return filtered_actions
893 
894     def get_actions(self, request):
895         """
896         Return a dictionary mapping the names of all actions for this
897         ModelAdmin to a tuple of (callable, name, description) for each action.
898         """
899         # If self.actions is set to None that means actions are disabled on
900         # this page.
901         if self.actions is None or IS_POPUP_VAR in request.GET:
902             return {}
903         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
904         return {name: (func, name, desc) for func, name, desc in actions}
905 
906     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
907         """
908         Return a list of choices for use in a form object.  Each choice is a
909         tuple (name, description).
910         """
911         choices = [] + default_choices
912         for func, name, description in self.get_actions(request).values():
913             choice = (name, description % model_format_dict(self.opts))
914             choices.append(choice)
915         return choices
916 
917     def get_action(self, action):
918         """
919         Return a given action from a parameter, which can either be a callable,
920         or the name of a method on the ModelAdmin.  Return is a tuple of
921         (callable, name, description).
922         """
923         # If the action is a callable, just use it.
924         if callable(action):
925             func = action
926             action = action.__name__
927 
928         # Next, look for a method. Grab it off self.__class__ to get an unbound
929         # method instead of a bound one; this ensures that the calling
930         # conventions are the same for functions and methods.
931         elif hasattr(self.__class__, action):
932             func = getattr(self.__class__, action)
933 
934         # Finally, look for a named method on the admin site
935         else:
936             try:
937                 func = self.admin_site.get_action(action)
938             except KeyError:
939                 return None
940 
941         if hasattr(func, 'short_description'):
942             description = func.short_description
943         else:
944             description = capfirst(action.replace('_', ' '))
945         return func, action, description
946 
947     def get_list_display(self, request):
948         """
949         Return a sequence containing the fields to be displayed on the
950         changelist.
951         """
952         return self.list_display
953 
954     def get_list_display_links(self, request, list_display):
955         """
956         Return a sequence containing the fields to be displayed as links
957         on the changelist. The list_display parameter is the list of fields
958         returned by get_list_display().
959         """
960         if self.list_display_links or self.list_display_links is None or not list_display:
961             return self.list_display_links
962         else:
963             # Use only the first item in list_display as link
964             return list(list_display)[:1]
965 
966     def get_list_filter(self, request):
967         """
968         Return a sequence containing the fields to be displayed as filters in
969         the right sidebar of the changelist page.
970         """
971         return self.list_filter
972 
973     def get_list_select_related(self, request):
974         """
975         Return a list of fields to add to the select_related() part of the
976         changelist items query.
977         """
978         return self.list_select_related
979 
980     def get_search_fields(self, request):
981         """
982         Return a sequence containing the fields to be searched whenever
983         somebody submits a search query.
984         """
985         return self.search_fields
986 
987     def get_search_results(self, request, queryset, search_term):
988         """
989         Return a tuple containing a queryset to implement the search
990         and a boolean indicating if the results may contain duplicates.
991         """
992         # Apply keyword searches.
993         def construct_search(field_name):
994             if field_name.startswith('^'):
995                 return "%s__istartswith" % field_name[1:]
996             elif field_name.startswith('='):
997                 return "%s__iexact" % field_name[1:]
998             elif field_name.startswith('@'):
999                 return "%s__search" % field_name[1:]
1000             # Use field_name if it includes a lookup.
1001             opts = queryset.model._meta
1002             lookup_fields = field_name.split(LOOKUP_SEP)
1003             # Go through the fields, following all relations.
1004             prev_field = None
1005             for path_part in lookup_fields:
1006                 if path_part == 'pk':
1007                     path_part = opts.pk.name
1008                 try:
1009                     field = opts.get_field(path_part)
1010                 except FieldDoesNotExist:
1011                     # Use valid query lookups.
1012                     if prev_field and prev_field.get_lookup(path_part):
1013                         return field_name
1014                 else:
1015                     prev_field = field
1016                     if hasattr(field, 'get_path_info'):
1017                         # Update opts to follow the relation.
1018                         opts = field.get_path_info()[-1].to_opts
1019             # Otherwise, use the field with icontains.
1020             return "%s__icontains" % field_name
1021 
1022         use_distinct = False
1023         search_fields = self.get_search_fields(request)
1024         if search_fields and search_term:
1025             orm_lookups = [construct_search(str(search_field))
1026                            for search_field in search_fields]
1027             for bit in smart_split(search_term):
1028                 if bit.startswith(('"', "'")):
1029                     bit = unescape_string_literal(bit)
1030                 or_queries = [models.Q(**{orm_lookup: bit})
1031                               for orm_lookup in orm_lookups]
1032                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1033             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1034 
1035         return queryset, use_distinct
1036 
1037     def get_preserved_filters(self, request):
1038         """
1039         Return the preserved filters querystring.
1040         """
1041         match = request.resolver_match
1042         if self.preserve_filters and match:
1043             opts = self.model._meta
1044             current_url = '%s:%s' % (match.app_name, match.url_name)
1045             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1046             if current_url == changelist_url:
1047                 preserved_filters = request.GET.urlencode()
1048             else:
1049                 preserved_filters = request.GET.get('_changelist_filters')
1050 
1051             if preserved_filters:
1052                 return urlencode({'_changelist_filters': preserved_filters})
1053         return ''
1054 
1055     def construct_change_message(self, request, form, formsets, add=False):
1056         """
1057         Construct a JSON structure describing changes from a changed object.
1058         """
1059         return construct_change_message(form, formsets, add)
1060 
1061     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1062                      fail_silently=False):
1063         """
1064         Send a message to the user. The default implementation
1065         posts a message using the django.contrib.messages backend.
1066 
1067         Exposes almost the same API as messages.add_message(), but accepts the
1068         positional arguments in a different order to maintain backwards
1069         compatibility. For convenience, it accepts the `level` argument as
1070         a string rather than the usual level number.
1071         """
1072         if not isinstance(level, int):
1073             # attempt to get the level if passed a string
1074             try:
1075                 level = getattr(messages.constants, level.upper())
1076             except AttributeError:
1077                 levels = messages.constants.DEFAULT_TAGS.values()
1078                 levels_repr = ', '.join('`%s`' % level for level in levels)
1079                 raise ValueError(
1080                     'Bad message level string: `%s`. Possible values are: %s'
1081                     % (level, levels_repr)
1082                 )
1083 
1084         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1085 
1086     def save_form(self, request, form, change):
1087         """
1088         Given a ModelForm return an unsaved instance. ``change`` is True if
1089         the object is being changed, and False if it's being added.
1090         """
1091         return form.save(commit=False)
1092 
1093     def save_model(self, request, obj, form, change):
1094         """
1095         Given a model instance save it to the database.
1096         """
1097         obj.save()
1098 
1099     def delete_model(self, request, obj):
1100         """
1101         Given a model instance delete it from the database.
1102         """
1103         obj.delete()
1104 
1105     def delete_queryset(self, request, queryset):
1106         """Given a queryset, delete it from the database."""
1107         queryset.delete()
1108 
1109     def save_formset(self, request, form, formset, change):
1110         """
1111         Given an inline formset save it to the database.
1112         """
1113         formset.save()
1114 
1115     def save_related(self, request, form, formsets, change):
1116         """
1117         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1118         list of inline formsets and a boolean value based on whether the
1119         parent is being added or changed, save the related objects to the
1120         database. Note that at this point save_form() and save_model() have
1121         already been called.
1122         """
1123         form.save_m2m()
1124         for formset in formsets:
1125             self.save_formset(request, form, formset, change=change)
1126 
1127     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1128         opts = self.model._meta
1129         app_label = opts.app_label
1130         preserved_filters = self.get_preserved_filters(request)
1131         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1132         view_on_site_url = self.get_view_on_site_url(obj)
1133         has_editable_inline_admin_formsets = False
1134         for inline in context['inline_admin_formsets']:
1135             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1136                 has_editable_inline_admin_formsets = True
1137                 break
1138         context.update({
1139             'add': add,
1140             'change': change,
1141             'has_view_permission': self.has_view_permission(request, obj),
1142             'has_add_permission': self.has_add_permission(request),
1143             'has_change_permission': self.has_change_permission(request, obj),
1144             'has_delete_permission': self.has_delete_permission(request, obj),
1145             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1146             'has_file_field': context['adminform'].form.is_multipart() or any(
1147                 admin_formset.formset.is_multipart()
1148                 for admin_formset in context['inline_admin_formsets']
1149             ),
1150             'has_absolute_url': view_on_site_url is not None,
1151             'absolute_url': view_on_site_url,
1152             'form_url': form_url,
1153             'opts': opts,
1154             'content_type_id': get_content_type_for_model(self.model).pk,
1155             'save_as': self.save_as,
1156             'save_on_top': self.save_on_top,
1157             'to_field_var': TO_FIELD_VAR,
1158             'is_popup_var': IS_POPUP_VAR,
1159             'app_label': app_label,
1160         })
1161         if add and self.add_form_template is not None:
1162             form_template = self.add_form_template
1163         else:
1164             form_template = self.change_form_template
1165 
1166         request.current_app = self.admin_site.name
1167 
1168         return TemplateResponse(request, form_template or [
1169             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1170             "admin/%s/change_form.html" % app_label,
1171             "admin/change_form.html"
1172         ], context)
1173 
1174     def response_add(self, request, obj, post_url_continue=None):
1175         """
1176         Determine the HttpResponse for the add_view stage.
1177         """
1178         opts = obj._meta
1179         preserved_filters = self.get_preserved_filters(request)
1180         obj_url = reverse(
1181             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1182             args=(quote(obj.pk),),
1183             current_app=self.admin_site.name,
1184         )
1185         # Add a link to the object's change form if the user can edit the obj.
1186         if self.has_change_permission(request, obj):
1187             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1188         else:
1189             obj_repr = str(obj)
1190         msg_dict = {
1191             'name': opts.verbose_name,
1192             'obj': obj_repr,
1193         }
1194         # Here, we distinguish between different save types by checking for
1195         # the presence of keys in request.POST.
1196 
1197         if IS_POPUP_VAR in request.POST:
1198             to_field = request.POST.get(TO_FIELD_VAR)
1199             if to_field:
1200                 attr = str(to_field)
1201             else:
1202                 attr = obj._meta.pk.attname
1203             value = obj.serializable_value(attr)
1204             popup_response_data = json.dumps({
1205                 'value': str(value),
1206                 'obj': str(obj),
1207             })
1208             return TemplateResponse(request, self.popup_response_template or [
1209                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1210                 'admin/%s/popup_response.html' % opts.app_label,
1211                 'admin/popup_response.html',
1212             ], {
1213                 'popup_response_data': popup_response_data,
1214             })
1215 
1216         elif "_continue" in request.POST or (
1217                 # Redirecting after "Save as new".
1218                 "_saveasnew" in request.POST and self.save_as_continue and
1219                 self.has_change_permission(request, obj)
1220         ):
1221             msg = _('The {name} “{obj}” was added successfully.')
1222             if self.has_change_permission(request, obj):
1223                 msg += ' ' + _('You may edit it again below.')
1224             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1225             if post_url_continue is None:
1226                 post_url_continue = obj_url
1227             post_url_continue = add_preserved_filters(
1228                 {'preserved_filters': preserved_filters, 'opts': opts},
1229                 post_url_continue
1230             )
1231             return HttpResponseRedirect(post_url_continue)
1232 
1233         elif "_addanother" in request.POST:
1234             msg = format_html(
1235                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1236                 **msg_dict
1237             )
1238             self.message_user(request, msg, messages.SUCCESS)
1239             redirect_url = request.path
1240             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1241             return HttpResponseRedirect(redirect_url)
1242 
1243         else:
1244             msg = format_html(
1245                 _('The {name} “{obj}” was added successfully.'),
1246                 **msg_dict
1247             )
1248             self.message_user(request, msg, messages.SUCCESS)
1249             return self.response_post_save_add(request, obj)
1250 
1251     def response_change(self, request, obj):
1252         """
1253         Determine the HttpResponse for the change_view stage.
1254         """
1255 
1256         if IS_POPUP_VAR in request.POST:
1257             opts = obj._meta
1258             to_field = request.POST.get(TO_FIELD_VAR)
1259             attr = str(to_field) if to_field else opts.pk.attname
1260             value = request.resolver_match.kwargs['object_id']
1261             new_value = obj.serializable_value(attr)
1262             popup_response_data = json.dumps({
1263                 'action': 'change',
1264                 'value': str(value),
1265                 'obj': str(obj),
1266                 'new_value': str(new_value),
1267             })
1268             return TemplateResponse(request, self.popup_response_template or [
1269                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1270                 'admin/%s/popup_response.html' % opts.app_label,
1271                 'admin/popup_response.html',
1272             ], {
1273                 'popup_response_data': popup_response_data,
1274             })
1275 
1276         opts = self.model._meta
1277         preserved_filters = self.get_preserved_filters(request)
1278 
1279         msg_dict = {
1280             'name': opts.verbose_name,
1281             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1282         }
1283         if "_continue" in request.POST:
1284             msg = format_html(
1285                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1286                 **msg_dict
1287             )
1288             self.message_user(request, msg, messages.SUCCESS)
1289             redirect_url = request.path
1290             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1291             return HttpResponseRedirect(redirect_url)
1292 
1293         elif "_saveasnew" in request.POST:
1294             msg = format_html(
1295                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1296                 **msg_dict
1297             )
1298             self.message_user(request, msg, messages.SUCCESS)
1299             redirect_url = reverse('admin:%s_%s_change' %
1300                                    (opts.app_label, opts.model_name),
1301                                    args=(obj.pk,),
1302                                    current_app=self.admin_site.name)
1303             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1304             return HttpResponseRedirect(redirect_url)
1305 
1306         elif "_addanother" in request.POST:
1307             msg = format_html(
1308                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1309                 **msg_dict
1310             )
1311             self.message_user(request, msg, messages.SUCCESS)
1312             redirect_url = reverse('admin:%s_%s_add' %
1313                                    (opts.app_label, opts.model_name),
1314                                    current_app=self.admin_site.name)
1315             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1316             return HttpResponseRedirect(redirect_url)
1317 
1318         else:
1319             msg = format_html(
1320                 _('The {name} “{obj}” was changed successfully.'),
1321                 **msg_dict
1322             )
1323             self.message_user(request, msg, messages.SUCCESS)
1324             return self.response_post_save_change(request, obj)
1325 
1326     def _response_post_save(self, request, obj):
1327         opts = self.model._meta
1328         if self.has_view_or_change_permission(request):
1329             post_url = reverse('admin:%s_%s_changelist' %
1330                                (opts.app_label, opts.model_name),
1331                                current_app=self.admin_site.name)
1332             preserved_filters = self.get_preserved_filters(request)
1333             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1334         else:
1335             post_url = reverse('admin:index',
1336                                current_app=self.admin_site.name)
1337         return HttpResponseRedirect(post_url)
1338 
1339     def response_post_save_add(self, request, obj):
1340         """
1341         Figure out where to redirect after the 'Save' button has been pressed
1342         when adding a new object.
1343         """
1344         return self._response_post_save(request, obj)
1345 
1346     def response_post_save_change(self, request, obj):
1347         """
1348         Figure out where to redirect after the 'Save' button has been pressed
1349         when editing an existing object.
1350         """
1351         return self._response_post_save(request, obj)
1352 
1353     def response_action(self, request, queryset):
1354         """
1355         Handle an admin action. This is called if a request is POSTed to the
1356         changelist; it returns an HttpResponse if the action was handled, and
1357         None otherwise.
1358         """
1359 
1360         # There can be multiple action forms on the page (at the top
1361         # and bottom of the change list, for example). Get the action
1362         # whose button was pushed.
1363         try:
1364             action_index = int(request.POST.get('index', 0))
1365         except ValueError:
1366             action_index = 0
1367 
1368         # Construct the action form.
1369         data = request.POST.copy()
1370         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1371         data.pop("index", None)
1372 
1373         # Use the action whose button was pushed
1374         try:
1375             data.update({'action': data.getlist('action')[action_index]})
1376         except IndexError:
1377             # If we didn't get an action from the chosen form that's invalid
1378             # POST data, so by deleting action it'll fail the validation check
1379             # below. So no need to do anything here
1380             pass
1381 
1382         action_form = self.action_form(data, auto_id=None)
1383         action_form.fields['action'].choices = self.get_action_choices(request)
1384 
1385         # If the form's valid we can handle the action.
1386         if action_form.is_valid():
1387             action = action_form.cleaned_data['action']
1388             select_across = action_form.cleaned_data['select_across']
1389             func = self.get_actions(request)[action][0]
1390 
1391             # Get the list of selected PKs. If nothing's selected, we can't
1392             # perform an action on it, so bail. Except we want to perform
1393             # the action explicitly on all objects.
1394             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1395             if not selected and not select_across:
1396                 # Reminder that something needs to be selected or nothing will happen
1397                 msg = _("Items must be selected in order to perform "
1398                         "actions on them. No items have been changed.")
1399                 self.message_user(request, msg, messages.WARNING)
1400                 return None
1401 
1402             if not select_across:
1403                 # Perform the action only on the selected objects
1404                 queryset = queryset.filter(pk__in=selected)
1405 
1406             response = func(self, request, queryset)
1407 
1408             # Actions may return an HttpResponse-like object, which will be
1409             # used as the response from the POST. If not, we'll be a good
1410             # little HTTP citizen and redirect back to the changelist page.
1411             if isinstance(response, HttpResponseBase):
1412                 return response
1413             else:
1414                 return HttpResponseRedirect(request.get_full_path())
1415         else:
1416             msg = _("No action selected.")
1417             self.message_user(request, msg, messages.WARNING)
1418             return None
1419 
1420     def response_delete(self, request, obj_display, obj_id):
1421         """
1422         Determine the HttpResponse for the delete_view stage.
1423         """
1424         opts = self.model._meta
1425 
1426         if IS_POPUP_VAR in request.POST:
1427             popup_response_data = json.dumps({
1428                 'action': 'delete',
1429                 'value': str(obj_id),
1430             })
1431             return TemplateResponse(request, self.popup_response_template or [
1432                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1433                 'admin/%s/popup_response.html' % opts.app_label,
1434                 'admin/popup_response.html',
1435             ], {
1436                 'popup_response_data': popup_response_data,
1437             })
1438 
1439         self.message_user(
1440             request,
1441             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1442                 'name': opts.verbose_name,
1443                 'obj': obj_display,
1444             },
1445             messages.SUCCESS,
1446         )
1447 
1448         if self.has_change_permission(request, None):
1449             post_url = reverse(
1450                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1451                 current_app=self.admin_site.name,
1452             )
1453             preserved_filters = self.get_preserved_filters(request)
1454             post_url = add_preserved_filters(
1455                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1456             )
1457         else:
1458             post_url = reverse('admin:index', current_app=self.admin_site.name)
1459         return HttpResponseRedirect(post_url)
1460 
1461     def render_delete_form(self, request, context):
1462         opts = self.model._meta
1463         app_label = opts.app_label
1464 
1465         request.current_app = self.admin_site.name
1466         context.update(
1467             to_field_var=TO_FIELD_VAR,
1468             is_popup_var=IS_POPUP_VAR,
1469             media=self.media,
1470         )
1471 
1472         return TemplateResponse(
1473             request,
1474             self.delete_confirmation_template or [
1475                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1476                 "admin/{}/delete_confirmation.html".format(app_label),
1477                 "admin/delete_confirmation.html",
1478             ],
1479             context,
1480         )
1481 
1482     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1483         # Edit permissions on parent model are required for editable inlines.
1484         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1485         inline_admin_formsets = []
1486         for inline, formset in zip(inline_instances, formsets):
1487             fieldsets = list(inline.get_fieldsets(request, obj))
1488             readonly = list(inline.get_readonly_fields(request, obj))
1489             if can_edit_parent:
1490                 has_add_permission = inline.has_add_permission(request, obj)
1491                 has_change_permission = inline.has_change_permission(request, obj)
1492                 has_delete_permission = inline.has_delete_permission(request, obj)
1493             else:
1494                 # Disable all edit-permissions, and overide formset settings.
1495                 has_add_permission = has_change_permission = has_delete_permission = False
1496                 formset.extra = formset.max_num = 0
1497             has_view_permission = inline.has_view_permission(request, obj)
1498             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1499             inline_admin_formset = helpers.InlineAdminFormSet(
1500                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1501                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1502                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1503             )
1504             inline_admin_formsets.append(inline_admin_formset)
1505         return inline_admin_formsets
1506 
1507     def get_changeform_initial_data(self, request):
1508         """
1509         Get the initial form data from the request's GET params.
1510         """
1511         initial = dict(request.GET.items())
1512         for k in initial:
1513             try:
1514                 f = self.model._meta.get_field(k)
1515             except FieldDoesNotExist:
1516                 continue
1517             # We have to special-case M2Ms as a list of comma-separated PKs.
1518             if isinstance(f, models.ManyToManyField):
1519                 initial[k] = initial[k].split(",")
1520         return initial
1521 
1522     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1523         """
1524         Create a message informing the user that the object doesn't exist
1525         and return a redirect to the admin index page.
1526         """
1527         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1528             'name': opts.verbose_name,
1529             'key': unquote(object_id),
1530         }
1531         self.message_user(request, msg, messages.WARNING)
1532         url = reverse('admin:index', current_app=self.admin_site.name)
1533         return HttpResponseRedirect(url)
1534 
1535     @csrf_protect_m
1536     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1537         with transaction.atomic(using=router.db_for_write(self.model)):
1538             return self._changeform_view(request, object_id, form_url, extra_context)
1539 
1540     def _changeform_view(self, request, object_id, form_url, extra_context):
1541         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1542         if to_field and not self.to_field_allowed(request, to_field):
1543             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1544 
1545         model = self.model
1546         opts = model._meta
1547 
1548         if request.method == 'POST' and '_saveasnew' in request.POST:
1549             object_id = None
1550 
1551         add = object_id is None
1552 
1553         if add:
1554             if not self.has_add_permission(request):
1555                 raise PermissionDenied
1556             obj = None
1557 
1558         else:
1559             obj = self.get_object(request, unquote(object_id), to_field)
1560 
1561             if request.method == 'POST':
1562                 if not self.has_change_permission(request, obj):
1563                     raise PermissionDenied
1564             else:
1565                 if not self.has_view_or_change_permission(request, obj):
1566                     raise PermissionDenied
1567 
1568             if obj is None:
1569                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1570 
1571         fieldsets = self.get_fieldsets(request, obj)
1572         ModelForm = self.get_form(
1573             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1574         )
1575         if request.method == 'POST':
1576             form = ModelForm(request.POST, request.FILES, instance=obj)
1577             form_validated = form.is_valid()
1578             if form_validated:
1579                 new_object = self.save_form(request, form, change=not add)
1580             else:
1581                 new_object = form.instance
1582             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1583             if all_valid(formsets) and form_validated:
1584                 self.save_model(request, new_object, form, not add)
1585                 self.save_related(request, form, formsets, not add)
1586                 change_message = self.construct_change_message(request, form, formsets, add)
1587                 if add:
1588                     self.log_addition(request, new_object, change_message)
1589                     return self.response_add(request, new_object)
1590                 else:
1591                     self.log_change(request, new_object, change_message)
1592                     return self.response_change(request, new_object)
1593             else:
1594                 form_validated = False
1595         else:
1596             if add:
1597                 initial = self.get_changeform_initial_data(request)
1598                 form = ModelForm(initial=initial)
1599                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1600             else:
1601                 form = ModelForm(instance=obj)
1602                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1603 
1604         if not add and not self.has_change_permission(request, obj):
1605             readonly_fields = flatten_fieldsets(fieldsets)
1606         else:
1607             readonly_fields = self.get_readonly_fields(request, obj)
1608         adminForm = helpers.AdminForm(
1609             form,
1610             list(fieldsets),
1611             # Clear prepopulated fields on a view-only form to avoid a crash.
1612             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1613             readonly_fields,
1614             model_admin=self)
1615         media = self.media + adminForm.media
1616 
1617         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1618         for inline_formset in inline_formsets:
1619             media = media + inline_formset.media
1620 
1621         if add:
1622             title = _('Add %s')
1623         elif self.has_change_permission(request, obj):
1624             title = _('Change %s')
1625         else:
1626             title = _('View %s')
1627         context = {
1628             **self.admin_site.each_context(request),
1629             'title': title % opts.verbose_name,
1630             'subtitle': str(obj) if obj else None,
1631             'adminform': adminForm,
1632             'object_id': object_id,
1633             'original': obj,
1634             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1635             'to_field': to_field,
1636             'media': media,
1637             'inline_admin_formsets': inline_formsets,
1638             'errors': helpers.AdminErrorList(form, formsets),
1639             'preserved_filters': self.get_preserved_filters(request),
1640         }
1641 
1642         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1643         # previously chosen to prevent the interface from getting confusing.
1644         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1645             context['show_save'] = False
1646             context['show_save_and_continue'] = False
1647             # Use the change template instead of the add template.
1648             add = False
1649 
1650         context.update(extra_context or {})
1651 
1652         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1653 
1654     def autocomplete_view(self, request):
1655         return AutocompleteJsonView.as_view(model_admin=self)(request)
1656 
1657     def add_view(self, request, form_url='', extra_context=None):
1658         return self.changeform_view(request, None, form_url, extra_context)
1659 
1660     def change_view(self, request, object_id, form_url='', extra_context=None):
1661         return self.changeform_view(request, object_id, form_url, extra_context)
1662 
1663     def _get_edited_object_pks(self, request, prefix):
1664         """Return POST data values of list_editable primary keys."""
1665         pk_pattern = re.compile(
1666             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1667         )
1668         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1669 
1670     def _get_list_editable_queryset(self, request, prefix):
1671         """
1672         Based on POST data, return a queryset of the objects that were edited
1673         via list_editable.
1674         """
1675         object_pks = self._get_edited_object_pks(request, prefix)
1676         queryset = self.get_queryset(request)
1677         validate = queryset.model._meta.pk.to_python
1678         try:
1679             for pk in object_pks:
1680                 validate(pk)
1681         except ValidationError:
1682             # Disable the optimization if the POST data was tampered with.
1683             return queryset
1684         return queryset.filter(pk__in=object_pks)
1685 
1686     @csrf_protect_m
1687     def changelist_view(self, request, extra_context=None):
1688         """
1689         The 'change list' admin view for this model.
1690         """
1691         from django.contrib.admin.views.main import ERROR_FLAG
1692         opts = self.model._meta
1693         app_label = opts.app_label
1694         if not self.has_view_or_change_permission(request):
1695             raise PermissionDenied
1696 
1697         try:
1698             cl = self.get_changelist_instance(request)
1699         except IncorrectLookupParameters:
1700             # Wacky lookup parameters were given, so redirect to the main
1701             # changelist page, without parameters, and pass an 'invalid=1'
1702             # parameter via the query string. If wacky parameters were given
1703             # and the 'invalid=1' parameter was already in the query string,
1704             # something is screwed up with the database, so display an error
1705             # page.
1706             if ERROR_FLAG in request.GET:
1707                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1708                     'title': _('Database error'),
1709                 })
1710             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1711 
1712         # If the request was POSTed, this might be a bulk action or a bulk
1713         # edit. Try to look up an action or confirmation first, but if this
1714         # isn't an action the POST will fall through to the bulk edit check,
1715         # below.
1716         action_failed = False
1717         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1718 
1719         actions = self.get_actions(request)
1720         # Actions with no confirmation
1721         if (actions and request.method == 'POST' and
1722                 'index' in request.POST and '_save' not in request.POST):
1723             if selected:
1724                 response = self.response_action(request, queryset=cl.get_queryset(request))
1725                 if response:
1726                     return response
1727                 else:
1728                     action_failed = True
1729             else:
1730                 msg = _("Items must be selected in order to perform "
1731                         "actions on them. No items have been changed.")
1732                 self.message_user(request, msg, messages.WARNING)
1733                 action_failed = True
1734 
1735         # Actions with confirmation
1736         if (actions and request.method == 'POST' and
1737                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1738                 'index' not in request.POST and '_save' not in request.POST):
1739             if selected:
1740                 response = self.response_action(request, queryset=cl.get_queryset(request))
1741                 if response:
1742                     return response
1743                 else:
1744                     action_failed = True
1745 
1746         if action_failed:
1747             # Redirect back to the changelist page to avoid resubmitting the
1748             # form if the user refreshes the browser or uses the "No, take
1749             # me back" button on the action confirmation page.
1750             return HttpResponseRedirect(request.get_full_path())
1751 
1752         # If we're allowing changelist editing, we need to construct a formset
1753         # for the changelist given all the fields to be edited. Then we'll
1754         # use the formset to validate/process POSTed data.
1755         formset = cl.formset = None
1756 
1757         # Handle POSTed bulk-edit data.
1758         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1759             if not self.has_change_permission(request):
1760                 raise PermissionDenied
1761             FormSet = self.get_changelist_formset(request)
1762             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1763             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1764             if formset.is_valid():
1765                 changecount = 0
1766                 for form in formset.forms:
1767                     if form.has_changed():
1768                         obj = self.save_form(request, form, change=True)
1769                         self.save_model(request, obj, form, change=True)
1770                         self.save_related(request, form, formsets=[], change=True)
1771                         change_msg = self.construct_change_message(request, form, None)
1772                         self.log_change(request, obj, change_msg)
1773                         changecount += 1
1774 
1775                 if changecount:
1776                     msg = ngettext(
1777                         "%(count)s %(name)s was changed successfully.",
1778                         "%(count)s %(name)s were changed successfully.",
1779                         changecount
1780                     ) % {
1781                         'count': changecount,
1782                         'name': model_ngettext(opts, changecount),
1783                     }
1784                     self.message_user(request, msg, messages.SUCCESS)
1785 
1786                 return HttpResponseRedirect(request.get_full_path())
1787 
1788         # Handle GET -- construct a formset for display.
1789         elif cl.list_editable and self.has_change_permission(request):
1790             FormSet = self.get_changelist_formset(request)
1791             formset = cl.formset = FormSet(queryset=cl.result_list)
1792 
1793         # Build the list of media to be used by the formset.
1794         if formset:
1795             media = self.media + formset.media
1796         else:
1797             media = self.media
1798 
1799         # Build the action form and populate it with available actions.
1800         if actions:
1801             action_form = self.action_form(auto_id=None)
1802             action_form.fields['action'].choices = self.get_action_choices(request)
1803             media += action_form.media
1804         else:
1805             action_form = None
1806 
1807         selection_note_all = ngettext(
1808             '%(total_count)s selected',
1809             'All %(total_count)s selected',
1810             cl.result_count
1811         )
1812 
1813         context = {
1814             **self.admin_site.each_context(request),
1815             'module_name': str(opts.verbose_name_plural),
1816             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1817             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1818             'title': cl.title,
1819             'subtitle': None,
1820             'is_popup': cl.is_popup,
1821             'to_field': cl.to_field,
1822             'cl': cl,
1823             'media': media,
1824             'has_add_permission': self.has_add_permission(request),
1825             'opts': cl.opts,
1826             'action_form': action_form,
1827             'actions_on_top': self.actions_on_top,
1828             'actions_on_bottom': self.actions_on_bottom,
1829             'actions_selection_counter': self.actions_selection_counter,
1830             'preserved_filters': self.get_preserved_filters(request),
1831             **(extra_context or {}),
1832         }
1833 
1834         request.current_app = self.admin_site.name
1835 
1836         return TemplateResponse(request, self.change_list_template or [
1837             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1838             'admin/%s/change_list.html' % app_label,
1839             'admin/change_list.html'
1840         ], context)
1841 
1842     def get_deleted_objects(self, objs, request):
1843         """
1844         Hook for customizing the delete process for the delete view and the
1845         "delete selected" action.
1846         """
1847         return get_deleted_objects(objs, request, self.admin_site)
1848 
1849     @csrf_protect_m
1850     def delete_view(self, request, object_id, extra_context=None):
1851         with transaction.atomic(using=router.db_for_write(self.model)):
1852             return self._delete_view(request, object_id, extra_context)
1853 
1854     def _delete_view(self, request, object_id, extra_context):
1855         "The 'delete' admin view for this model."
1856         opts = self.model._meta
1857         app_label = opts.app_label
1858 
1859         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1860         if to_field and not self.to_field_allowed(request, to_field):
1861             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1862 
1863         obj = self.get_object(request, unquote(object_id), to_field)
1864 
1865         if not self.has_delete_permission(request, obj):
1866             raise PermissionDenied
1867 
1868         if obj is None:
1869             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1870 
1871         # Populate deleted_objects, a data structure of all related objects that
1872         # will also be deleted.
1873         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1874 
1875         if request.POST and not protected:  # The user has confirmed the deletion.
1876             if perms_needed:
1877                 raise PermissionDenied
1878             obj_display = str(obj)
1879             attr = str(to_field) if to_field else opts.pk.attname
1880             obj_id = obj.serializable_value(attr)
1881             self.log_deletion(request, obj, obj_display)
1882             self.delete_model(request, obj)
1883 
1884             return self.response_delete(request, obj_display, obj_id)
1885 
1886         object_name = str(opts.verbose_name)
1887 
1888         if perms_needed or protected:
1889             title = _("Cannot delete %(name)s") % {"name": object_name}
1890         else:
1891             title = _("Are you sure?")
1892 
1893         context = {
1894             **self.admin_site.each_context(request),
1895             'title': title,
1896             'object_name': object_name,
1897             'object': obj,
1898             'deleted_objects': deleted_objects,
1899             'model_count': dict(model_count).items(),
1900             'perms_lacking': perms_needed,
1901             'protected': protected,
1902             'opts': opts,
1903             'app_label': app_label,
1904             'preserved_filters': self.get_preserved_filters(request),
1905             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1906             'to_field': to_field,
1907             **(extra_context or {}),
1908         }
1909 
1910         return self.render_delete_form(request, context)
1911 
1912     def history_view(self, request, object_id, extra_context=None):
1913         "The 'history' admin view for this model."
1914         from django.contrib.admin.models import LogEntry
1915 
1916         # First check if the user can see this history.
1917         model = self.model
1918         obj = self.get_object(request, unquote(object_id))
1919         if obj is None:
1920             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1921 
1922         if not self.has_view_or_change_permission(request, obj):
1923             raise PermissionDenied
1924 
1925         # Then get the history for this object.
1926         opts = model._meta
1927         app_label = opts.app_label
1928         action_list = LogEntry.objects.filter(
1929             object_id=unquote(object_id),
1930             content_type=get_content_type_for_model(model)
1931         ).select_related().order_by('action_time')
1932 
1933         context = {
1934             **self.admin_site.each_context(request),
1935             'title': _('Change history: %s') % obj,
1936             'action_list': action_list,
1937             'module_name': str(capfirst(opts.verbose_name_plural)),
1938             'object': obj,
1939             'opts': opts,
1940             'preserved_filters': self.get_preserved_filters(request),
1941             **(extra_context or {}),
1942         }
1943 
1944         request.current_app = self.admin_site.name
1945 
1946         return TemplateResponse(request, self.object_history_template or [
1947             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1948             "admin/%s/object_history.html" % app_label,
1949             "admin/object_history.html"
1950         ], context)
1951 
1952     def _create_formsets(self, request, obj, change):
1953         "Helper function to generate formsets for add/change_view."
1954         formsets = []
1955         inline_instances = []
1956         prefixes = {}
1957         get_formsets_args = [request]
1958         if change:
1959             get_formsets_args.append(obj)
1960         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1961             prefix = FormSet.get_default_prefix()
1962             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1963             if prefixes[prefix] != 1 or not prefix:
1964                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1965             formset_params = {
1966                 'instance': obj,
1967                 'prefix': prefix,
1968                 'queryset': inline.get_queryset(request),
1969             }
1970             if request.method == 'POST':
1971                 formset_params.update({
1972                     'data': request.POST.copy(),
1973                     'files': request.FILES,
1974                     'save_as_new': '_saveasnew' in request.POST
1975                 })
1976             formset = FormSet(**formset_params)
1977 
1978             def user_deleted_form(request, obj, formset, index):
1979                 """Return whether or not the user deleted the form."""
1980                 return (
1981                     inline.has_delete_permission(request, obj) and
1982                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1983                 )
1984 
1985             # Bypass validation of each view-only inline form (since the form's
1986             # data won't be in request.POST), unless the form was deleted.
1987             if not inline.has_change_permission(request, obj if change else None):
1988                 for index, form in enumerate(formset.initial_forms):
1989                     if user_deleted_form(request, obj, formset, index):
1990                         continue
1991                     form._errors = {}
1992                     form.cleaned_data = form.initial
1993             formsets.append(formset)
1994             inline_instances.append(inline)
1995         return formsets, inline_instances
1996 
1997 
1998 class InlineModelAdmin(BaseModelAdmin):
1999     """
2000     Options for inline editing of ``model`` instances.
2001 
2002     Provide ``fk_name`` to specify the attribute name of the ``ForeignKey``
2003     from ``model`` to its parent. This is required if ``model`` has more than
2004     one ``ForeignKey`` to its parent.
2005     """
2006     model = None
2007     fk_name = None
2008     formset = BaseInlineFormSet
2009     extra = 3
2010     min_num = None
2011     max_num = None
2012     template = None
2013     verbose_name = None
2014     verbose_name_plural = None
2015     can_delete = True
2016     show_change_link = False
2017     checks_class = InlineModelAdminChecks
2018     classes = None
2019 
2020     def __init__(self, parent_model, admin_site):
2021         self.admin_site = admin_site
2022         self.parent_model = parent_model
2023         self.opts = self.model._meta
2024         self.has_registered_model = admin_site.is_registered(self.model)
2025         super().__init__()
2026         if self.verbose_name is None:
2027             self.verbose_name = self.model._meta.verbose_name
2028         if self.verbose_name_plural is None:
2029             self.verbose_name_plural = self.model._meta.verbose_name_plural
2030 
2031     @property
2032     def media(self):
2033         extra = '' if settings.DEBUG else '.min'
2034         js = ['vendor/jquery/jquery%s.js' % extra, 'jquery.init.js', 'inlines.js']
2035         if self.filter_vertical or self.filter_horizontal:
2036             js.extend(['SelectBox.js', 'SelectFilter2.js'])
2037         if self.classes and 'collapse' in self.classes:
2038             js.append('collapse.js')
2039         return forms.Media(js=['admin/js/%s' % url for url in js])
2040 
2041     def get_extra(self, request, obj=None, **kwargs):
2042         """Hook for customizing the number of extra inline forms."""
2043         return self.extra
2044 
2045     def get_min_num(self, request, obj=None, **kwargs):
2046         """Hook for customizing the min number of inline forms."""
2047         return self.min_num
2048 
2049     def get_max_num(self, request, obj=None, **kwargs):
2050         """Hook for customizing the max number of extra inline forms."""
2051         return self.max_num
2052 
2053     def get_formset(self, request, obj=None, **kwargs):
2054         """Return a BaseInlineFormSet class for use in admin add/change views."""
2055         if 'fields' in kwargs:
2056             fields = kwargs.pop('fields')
2057         else:
2058             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
2059         excluded = self.get_exclude(request, obj)
2060         exclude = [] if excluded is None else list(excluded)
2061         exclude.extend(self.get_readonly_fields(request, obj))
2062         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
2063             # Take the custom ModelForm's Meta.exclude into account only if the
2064             # InlineModelAdmin doesn't define its own.
2065             exclude.extend(self.form._meta.exclude)
2066         # If exclude is an empty list we use None, since that's the actual
2067         # default.
2068         exclude = exclude or None
2069         can_delete = self.can_delete and self.has_delete_permission(request, obj)
2070         defaults = {
2071             'form': self.form,
2072             'formset': self.formset,
2073             'fk_name': self.fk_name,
2074             'fields': fields,
2075             'exclude': exclude,
2076             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
2077             'extra': self.get_extra(request, obj, **kwargs),
2078             'min_num': self.get_min_num(request, obj, **kwargs),
2079             'max_num': self.get_max_num(request, obj, **kwargs),
2080             'can_delete': can_delete,
2081             **kwargs,
2082         }
2083 
2084         base_model_form = defaults['form']
2085         can_change = self.has_change_permission(request, obj) if request else True
2086         can_add = self.has_add_permission(request, obj) if request else True
2087 
2088         class DeleteProtectedModelForm(base_model_form):
2089 
2090             def hand_clean_DELETE(self):
2091                 """
2092                 We don't validate the 'DELETE' field itself because on
2093                 templates it's not rendered using the field information, but
2094                 just using a generic "deletion_field" of the InlineModelAdmin.
2095                 """
2096                 if self.cleaned_data.get(DELETION_FIELD_NAME, False):
2097                     using = router.db_for_write(self._meta.model)
2098                     collector = NestedObjects(using=using)
2099                     if self.instance._state.adding:
2100                         return
2101                     collector.collect([self.instance])
2102                     if collector.protected:
2103                         objs = []
2104                         for p in collector.protected:
2105                             objs.append(
2106                                 # Translators: Model verbose name and instance representation,
2107                                 # suitable to be an item in a list.
2108                                 _('%(class_name)s %(instance)s') % {
2109                                     'class_name': p._meta.verbose_name,
2110                                     'instance': p}
2111                             )
2112                         params = {
2113                             'class_name': self._meta.model._meta.verbose_name,
2114                             'instance': self.instance,
2115                             'related_objects': get_text_list(objs, _('and')),
2116                         }
2117                         msg = _("Deleting %(class_name)s %(instance)s would require "
2118                                 "deleting the following protected related objects: "
2119                                 "%(related_objects)s")
2120                         raise ValidationError(msg, code='deleting_protected', params=params)
2121 
2122             def is_valid(self):
2123                 result = super().is_valid()
2124                 self.hand_clean_DELETE()
2125                 return result
2126 
2127             def has_changed(self):
2128                 # Protect against unauthorized edits.
2129                 if not can_change and not self.instance._state.adding:
2130                     return False
2131                 if not can_add and self.instance._state.adding:
2132                     return False
2133                 return super().has_changed()
2134 
2135         defaults['form'] = DeleteProtectedModelForm
2136 
2137         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
2138             defaults['fields'] = forms.ALL_FIELDS
2139 
2140         return inlineformset_factory(self.parent_model, self.model, **defaults)
2141 
2142     def _get_form_for_get_fields(self, request, obj=None):
2143         return self.get_formset(request, obj, fields=None).form
2144 
2145     def get_queryset(self, request):
2146         queryset = super().get_queryset(request)
2147         if not self.has_view_or_change_permission(request):
2148             queryset = queryset.none()
2149         return queryset
2150 
2151     def _has_any_perms_for_target_model(self, request, perms):
2152         """
2153         This method is called only when the ModelAdmin's model is for an
2154         ManyToManyField's implicit through model (if self.opts.auto_created).
2155         Return True if the user has any of the given permissions ('add',
2156         'change', etc.) for the model that points to the through model.
2157         """
2158         opts = self.opts
2159         # Find the target model of an auto-created many-to-many relationship.
2160         for field in opts.fields:
2161             if field.remote_field and field.remote_field.model != self.parent_model:
2162                 opts = field.remote_field.model._meta
2163                 break
2164         return any(
2165             request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename(perm, opts)))
2166             for perm in perms
2167         )
2168 
2169     def has_add_permission(self, request, obj):
2170         if self.opts.auto_created:
2171             # Auto-created intermediate models don't have their own
2172             # permissions. The user needs to have the change permission for the
2173             # related model in order to be able to do anything with the
2174             # intermediate model.
2175             return self._has_any_perms_for_target_model(request, ['change'])
2176         return super().has_add_permission(request)
2177 
2178     def has_change_permission(self, request, obj=None):
2179         if self.opts.auto_created:
2180             # Same comment as has_add_permission().
2181             return self._has_any_perms_for_target_model(request, ['change'])
2182         return super().has_change_permission(request)
2183 
2184     def has_delete_permission(self, request, obj=None):
2185         if self.opts.auto_created:
2186             # Same comment as has_add_permission().
2187             return self._has_any_perms_for_target_model(request, ['change'])
2188         return super().has_delete_permission(request, obj)
2189 
2190     def has_view_permission(self, request, obj=None):
2191         if self.opts.auto_created:
2192             # Same comment as has_add_permission(). The 'change' permission
2193             # also implies the 'view' permission.
2194             return self._has_any_perms_for_target_model(request, ['view', 'change'])
2195         return super().has_view_permission(request)
2196 
2197 
2198 class StackedInline(InlineModelAdmin):
2199     template = 'admin/edit_inline/stacked.html'
2200 
2201 
2202 class TabularInline(InlineModelAdmin):
2203     template = 'admin/edit_inline/tabular.html'

</code><intended_behavior>Review and adjust how `JSONField` data is prepared and displayed in the admin interface, specifically in methods that handle or display field values in the admin forms or list displays. If `json.dumps` is used to serialize `JSONField` data for display, ensure it uses `ensure_ascii=False`. This adjustment is to ensure that the admin interface properly displays Unicode characters contained in `JSONField`, enhancing user experience without affecting the admin's performance or security.</intended_behavior>]
2025-10-17 12:28:51.204 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/json.py</file>
<class>None</class>
<method>None</method>
<code>
1 import json
2 
3 from django import forms
4 from django.core import checks, exceptions
5 from django.db import NotSupportedError, connections, router
6 from django.db.models import lookups
7 from django.db.models.lookups import PostgresOperatorLookup, Transform
8 from django.utils.translation import gettext_lazy as _
9 
10 from . import Field
11 from .mixins import CheckFieldDefaultMixin
12 
13 __all__ = ['JSONField']
14 
15 
16 class JSONField(CheckFieldDefaultMixin, Field):
17     empty_strings_allowed = False
18     description = _('A JSON object')
19     default_error_messages = {
20         'invalid': _('Value must be valid JSON.'),
21     }
22     _default_hint = ('dict', '{}')
23 
24     def __init__(
25         self, verbose_name=None, name=None, encoder=None, decoder=None,
26         **kwargs,
27     ):
28         if encoder and not callable(encoder):
29             raise ValueError('The encoder parameter must be a callable object.')
30         if decoder and not callable(decoder):
31             raise ValueError('The decoder parameter must be a callable object.')
32         self.encoder = encoder
33         self.decoder = decoder
34         super().__init__(verbose_name, name, **kwargs)
35 
36     def check(self, **kwargs):
37         errors = super().check(**kwargs)
38         databases = kwargs.get('databases') or []
39         errors.extend(self._check_supported(databases))
40         return errors
41 
42     def _check_supported(self, databases):
43         errors = []
44         for db in databases:
45             if not router.allow_migrate_model(db, self.model):
46                 continue
47             connection = connections[db]
48             if not (
49                 'supports_json_field' in self.model._meta.required_db_features or
50                 connection.features.supports_json_field
51             ):
52                 errors.append(
53                     checks.Error(
54                         '%s does not support JSONFields.'
55                         % connection.display_name,
56                         obj=self.model,
57                         id='fields.E180',
58                     )
59                 )
60         return errors
61 
62     def deconstruct(self):
63         name, path, args, kwargs = super().deconstruct()
64         if self.encoder is not None:
65             kwargs['encoder'] = self.encoder
66         if self.decoder is not None:
67             kwargs['decoder'] = self.decoder
68         return name, path, args, kwargs
69 
70     def from_db_value(self, value, expression, connection):
71         if value is None:
72             return value
73         try:
74             return json.loads(value, cls=self.decoder)
75         except json.JSONDecodeError:
76             return value
77 
78     def get_internal_type(self):
79         return 'JSONField'
80 
81     def get_prep_value(self, value):
82         if value is None:
83             return value
84         return json.dumps(value, cls=self.encoder)
85 
86     def get_transform(self, name):
87         transform = super().get_transform(name)
88         if transform:
89             return transform
90         return KeyTransformFactory(name)
91 
92     def validate(self, value, model_instance):
93         super().validate(value, model_instance)
94         try:
95             json.dumps(value, cls=self.encoder)
96         except TypeError:
97             raise exceptions.ValidationError(
98                 self.error_messages['invalid'],
99                 code='invalid',
100                 params={'value': value},
101             )
102 
103     def value_to_string(self, obj):
104         return self.value_from_object(obj)
105 
106     def formfield(self, **kwargs):
107         return super().formfield(**{
108             'form_class': forms.JSONField,
109             'encoder': self.encoder,
110             'decoder': self.decoder,
111             **kwargs,
112         })
113 
114 
115 def compile_json_path(key_transforms, include_root=True):
116     path = ['$'] if include_root else []
117     for key_transform in key_transforms:
118         try:
119             num = int(key_transform)
120         except ValueError:  # non-integer
121             path.append('.')
122             path.append(json.dumps(key_transform))
123         else:
124             path.append('[%s]' % num)
125     return ''.join(path)
126 
127 
128 class DataContains(PostgresOperatorLookup):
129     lookup_name = 'contains'
130     postgres_operator = '@>'
131 
132     def as_sql(self, compiler, connection):
133         if not connection.features.supports_json_field_contains:
134             raise NotSupportedError(
135                 'contains lookup is not supported on this database backend.'
136             )
137         lhs, lhs_params = self.process_lhs(compiler, connection)
138         rhs, rhs_params = self.process_rhs(compiler, connection)
139         params = tuple(lhs_params) + tuple(rhs_params)
140         return 'JSON_CONTAINS(%s, %s)' % (lhs, rhs), params
141 
142 
143 class ContainedBy(PostgresOperatorLookup):
144     lookup_name = 'contained_by'
145     postgres_operator = '<@'
146 
147     def as_sql(self, compiler, connection):
148         if not connection.features.supports_json_field_contains:
149             raise NotSupportedError(
150                 'contained_by lookup is not supported on this database backend.'
151             )
152         lhs, lhs_params = self.process_lhs(compiler, connection)
153         rhs, rhs_params = self.process_rhs(compiler, connection)
154         params = tuple(rhs_params) + tuple(lhs_params)
155         return 'JSON_CONTAINS(%s, %s)' % (rhs, lhs), params
156 
157 
158 class HasKeyLookup(PostgresOperatorLookup):
159     logical_operator = None
160 
161     def as_sql(self, compiler, connection, template=None):
162         # Process JSON path from the left-hand side.
163         if isinstance(self.lhs, KeyTransform):
164             lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)
165             lhs_json_path = compile_json_path(lhs_key_transforms)
166         else:
167             lhs, lhs_params = self.process_lhs(compiler, connection)
168             lhs_json_path = '$'
169         sql = template % lhs
170         # Process JSON path from the right-hand side.
171         rhs = self.rhs
172         rhs_params = []
173         if not isinstance(rhs, (list, tuple)):
174             rhs = [rhs]
175         for key in rhs:
176             if isinstance(key, KeyTransform):
177                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)
178             else:
179                 rhs_key_transforms = [key]
180             rhs_params.append('%s%s' % (
181                 lhs_json_path,
182                 compile_json_path(rhs_key_transforms, include_root=False),
183             ))
184         # Add condition for each key.
185         if self.logical_operator:
186             sql = '(%s)' % self.logical_operator.join([sql] * len(rhs_params))
187         return sql, tuple(lhs_params) + tuple(rhs_params)
188 
189     def as_mysql(self, compiler, connection):
190         return self.as_sql(compiler, connection, template="JSON_CONTAINS_PATH(%s, 'one', %%s)")
191 
192     def as_oracle(self, compiler, connection):
193         sql, params = self.as_sql(compiler, connection, template="JSON_EXISTS(%s, '%%s')")
194         # Add paths directly into SQL because path expressions cannot be passed
195         # as bind variables on Oracle.
196         return sql % tuple(params), []
197 
198     def as_postgresql(self, compiler, connection):
199         if isinstance(self.rhs, KeyTransform):
200             *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)
201             for key in rhs_key_transforms[:-1]:
202                 self.lhs = KeyTransform(key, self.lhs)
203             self.rhs = rhs_key_transforms[-1]
204         return super().as_postgresql(compiler, connection)
205 
206     def as_sqlite(self, compiler, connection):
207         return self.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NOT NULL')
208 
209 
210 class HasKey(HasKeyLookup):
211     lookup_name = 'has_key'
212     postgres_operator = '?'
213     prepare_rhs = False
214 
215 
216 class HasKeys(HasKeyLookup):
217     lookup_name = 'has_keys'
218     postgres_operator = '?&'
219     logical_operator = ' AND '
220 
221     def get_prep_lookup(self):
222         return [str(item) for item in self.rhs]
223 
224 
225 class HasAnyKeys(HasKeys):
226     lookup_name = 'has_any_keys'
227     postgres_operator = '?|'
228     logical_operator = ' OR '
229 
230 
231 class JSONExact(lookups.Exact):
232     can_use_none_as_rhs = True
233 
234     def process_lhs(self, compiler, connection):
235         lhs, lhs_params = super().process_lhs(compiler, connection)
236         if connection.vendor == 'sqlite':
237             rhs, rhs_params = super().process_rhs(compiler, connection)
238             if rhs == '%s' and rhs_params == [None]:
239                 # Use JSON_TYPE instead of JSON_EXTRACT for NULLs.
240                 lhs = "JSON_TYPE(%s, '$')" % lhs
241         return lhs, lhs_params
242 
243     def process_rhs(self, compiler, connection):
244         rhs, rhs_params = super().process_rhs(compiler, connection)
245         # Treat None lookup values as null.
246         if rhs == '%s' and rhs_params == [None]:
247             rhs_params = ['null']
248         if connection.vendor == 'mysql':
249             func = ["JSON_EXTRACT(%s, '$')"] * len(rhs_params)
250             rhs = rhs % tuple(func)
251         return rhs, rhs_params
252 
253 
254 JSONField.register_lookup(DataContains)
255 JSONField.register_lookup(ContainedBy)
256 JSONField.register_lookup(HasKey)
257 JSONField.register_lookup(HasKeys)
258 JSONField.register_lookup(HasAnyKeys)
259 JSONField.register_lookup(JSONExact)
260 
261 
262 class KeyTransform(Transform):
263     postgres_operator = '->'
264     postgres_nested_operator = '#>'
265 
266     def __init__(self, key_name, *args, **kwargs):
267         super().__init__(*args, **kwargs)
268         self.key_name = str(key_name)
269 
270     def preprocess_lhs(self, compiler, connection, lhs_only=False):
271         if not lhs_only:
272             key_transforms = [self.key_name]
273         previous = self.lhs
274         while isinstance(previous, KeyTransform):
275             if not lhs_only:
276                 key_transforms.insert(0, previous.key_name)
277             previous = previous.lhs
278         lhs, params = compiler.compile(previous)
279         if connection.vendor == 'oracle':
280             # Escape string-formatting.
281             key_transforms = [key.replace('%', '%%') for key in key_transforms]
282         return (lhs, params, key_transforms) if not lhs_only else (lhs, params)
283 
284     def as_mysql(self, compiler, connection):
285         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
286         json_path = compile_json_path(key_transforms)
287         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
288 
289     def as_oracle(self, compiler, connection):
290         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
291         json_path = compile_json_path(key_transforms)
292         return (
293             "COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))" %
294             ((lhs, json_path) * 2)
295         ), tuple(params) * 2
296 
297     def as_postgresql(self, compiler, connection):
298         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
299         if len(key_transforms) > 1:
300             return '(%s %s %%s)' % (lhs, self.postgres_nested_operator), params + [key_transforms]
301         try:
302             lookup = int(self.key_name)
303         except ValueError:
304             lookup = self.key_name
305         return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)
306 
307     def as_sqlite(self, compiler, connection):
308         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)
309         json_path = compile_json_path(key_transforms)
310         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)
311 
312 
313 class KeyTextTransform(KeyTransform):
314     postgres_operator = '->>'
315     postgres_nested_operator = '#>>'
316 
317 
318 class KeyTransformTextLookupMixin:
319     """
320     Mixin for combining with a lookup expecting a text lhs from a JSONField
321     key lookup. On PostgreSQL, make use of the ->> operator instead of casting
322     key values to text and performing the lookup on the resulting
323     representation.
324     """
325     def __init__(self, key_transform, *args, **kwargs):
326         if not isinstance(key_transform, KeyTransform):
327             raise TypeError(
328                 'Transform should be an instance of KeyTransform in order to '
329                 'use this lookup.'
330             )
331         key_text_transform = KeyTextTransform(
332             key_transform.key_name, *key_transform.source_expressions,
333             **key_transform.extra,
334         )
335         super().__init__(key_text_transform, *args, **kwargs)
336 
337 
338 class CaseInsensitiveMixin:
339     """
340     Mixin to allow case-insensitive comparison of JSON values on MySQL.
341     MySQL handles strings used in JSON context using the utf8mb4_bin collation.
342     Because utf8mb4_bin is a binary collation, comparison of JSON values is
343     case-sensitive.
344     """
345     def process_lhs(self, compiler, connection):
346         lhs, lhs_params = super().process_lhs(compiler, connection)
347         if connection.vendor == 'mysql':
348             return 'LOWER(%s)' % lhs, lhs_params
349         return lhs, lhs_params
350 
351     def process_rhs(self, compiler, connection):
352         rhs, rhs_params = super().process_rhs(compiler, connection)
353         if connection.vendor == 'mysql':
354             return 'LOWER(%s)' % rhs, rhs_params
355         return rhs, rhs_params
356 
357 
358 class KeyTransformIsNull(lookups.IsNull):
359     # key__isnull=False is the same as has_key='key'
360     def as_oracle(self, compiler, connection):
361         if not self.rhs:
362             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)
363         return super().as_sql(compiler, connection)
364 
365     def as_sqlite(self, compiler, connection):
366         if not self.rhs:
367             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)
368         return super().as_sql(compiler, connection)
369 
370 
371 class KeyTransformIn(lookups.In):
372     def process_rhs(self, compiler, connection):
373         rhs, rhs_params = super().process_rhs(compiler, connection)
374         if not connection.features.has_native_json_field:
375             func = ()
376             if connection.vendor == 'oracle':
377                 func = []
378                 for value in rhs_params:
379                     value = json.loads(value)
380                     function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
381                     func.append("%s('%s', '$.value')" % (
382                         function,
383                         json.dumps({'value': value}),
384                     ))
385                 func = tuple(func)
386                 rhs_params = ()
387             elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:
388                 func = ("JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))",) * len(rhs_params)
389             elif connection.vendor in {'sqlite', 'mysql'}:
390                 func = ("JSON_EXTRACT(%s, '$')",) * len(rhs_params)
391             rhs = rhs % func
392         return rhs, rhs_params
393 
394 
395 class KeyTransformExact(JSONExact):
396     def process_lhs(self, compiler, connection):
397         lhs, lhs_params = super().process_lhs(compiler, connection)
398         if connection.vendor == 'sqlite':
399             rhs, rhs_params = super().process_rhs(compiler, connection)
400             if rhs == '%s' and rhs_params == ['null']:
401                 lhs, _ = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)
402                 lhs = 'JSON_TYPE(%s, %%s)' % lhs
403         return lhs, lhs_params
404 
405     def process_rhs(self, compiler, connection):
406         if isinstance(self.rhs, KeyTransform):
407             return super(lookups.Exact, self).process_rhs(compiler, connection)
408         rhs, rhs_params = super().process_rhs(compiler, connection)
409         if connection.vendor == 'oracle':
410             func = []
411             for value in rhs_params:
412                 value = json.loads(value)
413                 function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'
414                 func.append("%s('%s', '$.value')" % (
415                     function,
416                     json.dumps({'value': value}),
417                 ))
418             rhs = rhs % tuple(func)
419             rhs_params = []
420         elif connection.vendor == 'sqlite':
421             func = ["JSON_EXTRACT(%s, '$')" if value != 'null' else '%s' for value in rhs_params]
422             rhs = rhs % tuple(func)
423         return rhs, rhs_params
424 
425     def as_oracle(self, compiler, connection):
426         rhs, rhs_params = super().process_rhs(compiler, connection)
427         if rhs_params == ['null']:
428             # Field has key and it's NULL.
429             has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)
430             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)
431             is_null_expr = self.lhs.get_lookup('isnull')(self.lhs, True)
432             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)
433             return (
434                 '%s AND %s' % (has_key_sql, is_null_sql),
435                 tuple(has_key_params) + tuple(is_null_params),
436             )
437         return super().as_sql(compiler, connection)
438 
439 
440 class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):
441     pass
442 
443 
444 class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):
445     pass
446 
447 
448 class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):
449     pass
450 
451 
452 class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):
453     pass
454 
455 
456 class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):
457     pass
458 
459 
460 class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):
461     pass
462 
463 
464 class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):
465     pass
466 
467 
468 class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):
469     pass
470 
471 
472 class KeyTransformNumericLookupMixin:
473     def process_rhs(self, compiler, connection):
474         rhs, rhs_params = super().process_rhs(compiler, connection)
475         if not connection.features.has_native_json_field:
476             rhs_params = [json.loads(value) for value in rhs_params]
477         return rhs, rhs_params
478 
479 
480 class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):
481     pass
482 
483 
484 class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):
485     pass
486 
487 
488 class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):
489     pass
490 
491 
492 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):
493     pass
494 
495 
496 KeyTransform.register_lookup(KeyTransformIn)
497 KeyTransform.register_lookup(KeyTransformExact)
498 KeyTransform.register_lookup(KeyTransformIExact)
499 KeyTransform.register_lookup(KeyTransformIsNull)
500 KeyTransform.register_lookup(KeyTransformIContains)
501 KeyTransform.register_lookup(KeyTransformStartsWith)
502 KeyTransform.register_lookup(KeyTransformIStartsWith)
503 KeyTransform.register_lookup(KeyTransformEndsWith)
504 KeyTransform.register_lookup(KeyTransformIEndsWith)
505 KeyTransform.register_lookup(KeyTransformRegex)
506 KeyTransform.register_lookup(KeyTransformIRegex)
507 
508 KeyTransform.register_lookup(KeyTransformLt)
509 KeyTransform.register_lookup(KeyTransformLte)
510 KeyTransform.register_lookup(KeyTransformGt)
511 KeyTransform.register_lookup(KeyTransformGte)
512 
513 
514 class KeyTransformFactory:
515 
516     def __init__(self, key_name):
517         self.key_name = key_name
518 
519     def __call__(self, *args, **kwargs):
520         return KeyTransform(self.key_name, *args, **kwargs)

</code><intended_behavior>Modify the serialization logic to ensure `json.dumps` is called with the `ensure_ascii=False` option when serializing JSON data for `JSONField`. This will allow Unicode characters to be displayed properly in the Django admin by default, instead of being escaped as ASCII sequences. This change should preserve the field's existing functionality in all contexts, including form submissions, database storage, and admin display.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import json
3 import operator
4 import re
5 from functools import partial, reduce, update_wrapper
6 from urllib.parse import quote as urlquote
7 
8 from django import forms
9 from django.conf import settings
10 from django.contrib import messages
11 from django.contrib.admin import helpers, widgets
12 from django.contrib.admin.checks import (
13     BaseModelAdminChecks, InlineModelAdminChecks, ModelAdminChecks,
14 )
15 from django.contrib.admin.exceptions import DisallowedModelAdminToField
16 from django.contrib.admin.templatetags.admin_urls import add_preserved_filters
17 from django.contrib.admin.utils import (
18     NestedObjects, construct_change_message, flatten_fieldsets,
19     get_deleted_objects, lookup_needs_distinct, model_format_dict,
20     model_ngettext, quote, unquote,
21 )
22 from django.contrib.admin.views.autocomplete import AutocompleteJsonView
23 from django.contrib.admin.widgets import (
24     AutocompleteSelect, AutocompleteSelectMultiple,
25 )
26 from django.contrib.auth import get_permission_codename
27 from django.core.exceptions import (
28     FieldDoesNotExist, FieldError, PermissionDenied, ValidationError,
29 )
30 from django.core.paginator import Paginator
31 from django.db import models, router, transaction
32 from django.db.models.constants import LOOKUP_SEP
33 from django.forms.formsets import DELETION_FIELD_NAME, all_valid
34 from django.forms.models import (
35     BaseInlineFormSet, inlineformset_factory, modelform_defines_fields,
36     modelform_factory, modelformset_factory,
37 )
38 from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple
39 from django.http import HttpResponseRedirect
40 from django.http.response import HttpResponseBase
41 from django.template.response import SimpleTemplateResponse, TemplateResponse
42 from django.urls import reverse
43 from django.utils.decorators import method_decorator
44 from django.utils.html import format_html
45 from django.utils.http import urlencode
46 from django.utils.safestring import mark_safe
47 from django.utils.text import (
48     capfirst, format_lazy, get_text_list, smart_split, unescape_string_literal,
49 )
50 from django.utils.translation import gettext as _, ngettext
51 from django.views.decorators.csrf import csrf_protect
52 from django.views.generic import RedirectView
53 
54 IS_POPUP_VAR = '_popup'
55 TO_FIELD_VAR = '_to_field'
56 
57 
58 HORIZONTAL, VERTICAL = 1, 2
59 
60 
61 def get_content_type_for_model(obj):
62     # Since this module gets imported in the application's root package,
63     # it cannot import models from other applications at the module level.
64     from django.contrib.contenttypes.models import ContentType
65     return ContentType.objects.get_for_model(obj, for_concrete_model=False)
66 
67 
68 def get_ul_class(radio_style):
69     return 'radiolist' if radio_style == VERTICAL else 'radiolist inline'
70 
71 
72 class IncorrectLookupParameters(Exception):
73     pass
74 
75 
76 # Defaults for formfield_overrides. ModelAdmin subclasses can change this
77 # by adding to ModelAdmin.formfield_overrides.
78 
79 FORMFIELD_FOR_DBFIELD_DEFAULTS = {
80     models.DateTimeField: {
81         'form_class': forms.SplitDateTimeField,
82         'widget': widgets.AdminSplitDateTime
83     },
84     models.DateField: {'widget': widgets.AdminDateWidget},
85     models.TimeField: {'widget': widgets.AdminTimeWidget},
86     models.TextField: {'widget': widgets.AdminTextareaWidget},
87     models.URLField: {'widget': widgets.AdminURLFieldWidget},
88     models.IntegerField: {'widget': widgets.AdminIntegerFieldWidget},
89     models.BigIntegerField: {'widget': widgets.AdminBigIntegerFieldWidget},
90     models.CharField: {'widget': widgets.AdminTextInputWidget},
91     models.ImageField: {'widget': widgets.AdminFileWidget},
92     models.FileField: {'widget': widgets.AdminFileWidget},
93     models.EmailField: {'widget': widgets.AdminEmailInputWidget},
94     models.UUIDField: {'widget': widgets.AdminUUIDInputWidget},
95 }
96 
97 csrf_protect_m = method_decorator(csrf_protect)
98 
99 
100 class BaseModelAdmin(metaclass=forms.MediaDefiningClass):
101     """Functionality common to both ModelAdmin and InlineAdmin."""
102 
103     autocomplete_fields = ()
104     raw_id_fields = ()
105     fields = None
106     exclude = None
107     fieldsets = None
108     form = forms.ModelForm
109     filter_vertical = ()
110     filter_horizontal = ()
111     radio_fields = {}
112     prepopulated_fields = {}
113     formfield_overrides = {}
114     readonly_fields = ()
115     ordering = None
116     sortable_by = None
117     view_on_site = True
118     show_full_result_count = True
119     checks_class = BaseModelAdminChecks
120 
121     def check(self, **kwargs):
122         return self.checks_class().check(self, **kwargs)
123 
124     def __init__(self):
125         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides
126         # rather than simply overwriting.
127         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)
128         for k, v in self.formfield_overrides.items():
129             overrides.setdefault(k, {}).update(v)
130         self.formfield_overrides = overrides
131 
132     def formfield_for_dbfield(self, db_field, request, **kwargs):
133         """
134         Hook for specifying the form Field instance for a given database Field
135         instance.
136 
137         If kwargs are given, they're passed to the form Field's constructor.
138         """
139         # If the field specifies choices, we don't need to look for special
140         # admin widgets - we just need to use a select widget of some kind.
141         if db_field.choices:
142             return self.formfield_for_choice_field(db_field, request, **kwargs)
143 
144         # ForeignKey or ManyToManyFields
145         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):
146             # Combine the field kwargs with any options for formfield_overrides.
147             # Make sure the passed in **kwargs override anything in
148             # formfield_overrides because **kwargs is more specific, and should
149             # always win.
150             if db_field.__class__ in self.formfield_overrides:
151                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}
152 
153             # Get the correct formfield.
154             if isinstance(db_field, models.ForeignKey):
155                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)
156             elif isinstance(db_field, models.ManyToManyField):
157                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)
158 
159             # For non-raw_id fields, wrap the widget with a wrapper that adds
160             # extra HTML -- the "add other" interface -- to the end of the
161             # rendered output. formfield can be None if it came from a
162             # OneToOneField with parent_link=True or a M2M intermediary.
163             if formfield and db_field.name not in self.raw_id_fields:
164                 related_modeladmin = self.admin_site._registry.get(db_field.remote_field.model)
165                 wrapper_kwargs = {}
166                 if related_modeladmin:
167                     wrapper_kwargs.update(
168                         can_add_related=related_modeladmin.has_add_permission(request),
169                         can_change_related=related_modeladmin.has_change_permission(request),
170                         can_delete_related=related_modeladmin.has_delete_permission(request),
171                         can_view_related=related_modeladmin.has_view_permission(request),
172                     )
173                 formfield.widget = widgets.RelatedFieldWidgetWrapper(
174                     formfield.widget, db_field.remote_field, self.admin_site, **wrapper_kwargs
175                 )
176 
177             return formfield
178 
179         # If we've got overrides for the formfield defined, use 'em. **kwargs
180         # passed to formfield_for_dbfield override the defaults.
181         for klass in db_field.__class__.mro():
182             if klass in self.formfield_overrides:
183                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}
184                 return db_field.formfield(**kwargs)
185 
186         # For any other type of field, just call its formfield() method.
187         return db_field.formfield(**kwargs)
188 
189     def formfield_for_choice_field(self, db_field, request, **kwargs):
190         """
191         Get a form Field for a database Field that has declared choices.
192         """
193         # If the field is named as a radio_field, use a RadioSelect
194         if db_field.name in self.radio_fields:
195             # Avoid stomping on custom widget/choices arguments.
196             if 'widget' not in kwargs:
197                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={
198                     'class': get_ul_class(self.radio_fields[db_field.name]),
199                 })
200             if 'choices' not in kwargs:
201                 kwargs['choices'] = db_field.get_choices(
202                     include_blank=db_field.blank,
203                     blank_choice=[('', _('None'))]
204                 )
205         return db_field.formfield(**kwargs)
206 
207     def get_field_queryset(self, db, db_field, request):
208         """
209         If the ModelAdmin specifies ordering, the queryset should respect that
210         ordering.  Otherwise don't specify the queryset, let the field decide
211         (return None in that case).
212         """
213         related_admin = self.admin_site._registry.get(db_field.remote_field.model)
214         if related_admin is not None:
215             ordering = related_admin.get_ordering(request)
216             if ordering is not None and ordering != ():
217                 return db_field.remote_field.model._default_manager.using(db).order_by(*ordering)
218         return None
219 
220     def formfield_for_foreignkey(self, db_field, request, **kwargs):
221         """
222         Get a form Field for a ForeignKey.
223         """
224         db = kwargs.get('using')
225 
226         if 'widget' not in kwargs:
227             if db_field.name in self.get_autocomplete_fields(request):
228                 kwargs['widget'] = AutocompleteSelect(db_field.remote_field, self.admin_site, using=db)
229             elif db_field.name in self.raw_id_fields:
230                 kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)
231             elif db_field.name in self.radio_fields:
232                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={
233                     'class': get_ul_class(self.radio_fields[db_field.name]),
234                 })
235                 kwargs['empty_label'] = _('None') if db_field.blank else None
236 
237         if 'queryset' not in kwargs:
238             queryset = self.get_field_queryset(db, db_field, request)
239             if queryset is not None:
240                 kwargs['queryset'] = queryset
241 
242         return db_field.formfield(**kwargs)
243 
244     def formfield_for_manytomany(self, db_field, request, **kwargs):
245         """
246         Get a form Field for a ManyToManyField.
247         """
248         # If it uses an intermediary model that isn't auto created, don't show
249         # a field in admin.
250         if not db_field.remote_field.through._meta.auto_created:
251             return None
252         db = kwargs.get('using')
253 
254         if 'widget' not in kwargs:
255             autocomplete_fields = self.get_autocomplete_fields(request)
256             if db_field.name in autocomplete_fields:
257                 kwargs['widget'] = AutocompleteSelectMultiple(
258                     db_field.remote_field,
259                     self.admin_site,
260                     using=db,
261                 )
262             elif db_field.name in self.raw_id_fields:
263                 kwargs['widget'] = widgets.ManyToManyRawIdWidget(
264                     db_field.remote_field,
265                     self.admin_site,
266                     using=db,
267                 )
268             elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:
269                 kwargs['widget'] = widgets.FilteredSelectMultiple(
270                     db_field.verbose_name,
271                     db_field.name in self.filter_vertical
272                 )
273         if 'queryset' not in kwargs:
274             queryset = self.get_field_queryset(db, db_field, request)
275             if queryset is not None:
276                 kwargs['queryset'] = queryset
277 
278         form_field = db_field.formfield(**kwargs)
279         if (isinstance(form_field.widget, SelectMultiple) and
280                 not isinstance(form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple))):
281             msg = _('Hold down “Control”, or “Command” on a Mac, to select more than one.')
282             help_text = form_field.help_text
283             form_field.help_text = format_lazy('{} {}', help_text, msg) if help_text else msg
284         return form_field
285 
286     def get_autocomplete_fields(self, request):
287         """
288         Return a list of ForeignKey and/or ManyToMany fields which should use
289         an autocomplete widget.
290         """
291         return self.autocomplete_fields
292 
293     def get_view_on_site_url(self, obj=None):
294         if obj is None or not self.view_on_site:
295             return None
296 
297         if callable(self.view_on_site):
298             return self.view_on_site(obj)
299         elif self.view_on_site and hasattr(obj, 'get_absolute_url'):
300             # use the ContentType lookup if view_on_site is True
301             return reverse('admin:view_on_site', kwargs={
302                 'content_type_id': get_content_type_for_model(obj).pk,
303                 'object_id': obj.pk
304             })
305 
306     def get_empty_value_display(self):
307         """
308         Return the empty_value_display set on ModelAdmin or AdminSite.
309         """
310         try:
311             return mark_safe(self.empty_value_display)
312         except AttributeError:
313             return mark_safe(self.admin_site.empty_value_display)
314 
315     def get_exclude(self, request, obj=None):
316         """
317         Hook for specifying exclude.
318         """
319         return self.exclude
320 
321     def get_fields(self, request, obj=None):
322         """
323         Hook for specifying fields.
324         """
325         if self.fields:
326             return self.fields
327         # _get_form_for_get_fields() is implemented in subclasses.
328         form = self._get_form_for_get_fields(request, obj)
329         return [*form.base_fields, *self.get_readonly_fields(request, obj)]
330 
331     def get_fieldsets(self, request, obj=None):
332         """
333         Hook for specifying fieldsets.
334         """
335         if self.fieldsets:
336             return self.fieldsets
337         return [(None, {'fields': self.get_fields(request, obj)})]
338 
339     def get_inlines(self, request, obj):
340         """Hook for specifying custom inlines."""
341         return self.inlines
342 
343     def get_ordering(self, request):
344         """
345         Hook for specifying field ordering.
346         """
347         return self.ordering or ()  # otherwise we might try to *None, which is bad ;)
348 
349     def get_readonly_fields(self, request, obj=None):
350         """
351         Hook for specifying custom readonly fields.
352         """
353         return self.readonly_fields
354 
355     def get_prepopulated_fields(self, request, obj=None):
356         """
357         Hook for specifying custom prepopulated fields.
358         """
359         return self.prepopulated_fields
360 
361     def get_queryset(self, request):
362         """
363         Return a QuerySet of all model instances that can be edited by the
364         admin site. This is used by changelist_view.
365         """
366         qs = self.model._default_manager.get_queryset()
367         # TODO: this should be handled by some parameter to the ChangeList.
368         ordering = self.get_ordering(request)
369         if ordering:
370             qs = qs.order_by(*ordering)
371         return qs
372 
373     def get_sortable_by(self, request):
374         """Hook for specifying which fields can be sorted in the changelist."""
375         return self.sortable_by if self.sortable_by is not None else self.get_list_display(request)
376 
377     def lookup_allowed(self, lookup, value):
378         from django.contrib.admin.filters import SimpleListFilter
379 
380         model = self.model
381         # Check FKey lookups that are allowed, so that popups produced by
382         # ForeignKeyRawIdWidget, on the basis of ForeignKey.limit_choices_to,
383         # are allowed to work.
384         for fk_lookup in model._meta.related_fkey_lookups:
385             # As ``limit_choices_to`` can be a callable, invoke it here.
386             if callable(fk_lookup):
387                 fk_lookup = fk_lookup()
388             if (lookup, value) in widgets.url_params_from_lookup_dict(fk_lookup).items():
389                 return True
390 
391         relation_parts = []
392         prev_field = None
393         for part in lookup.split(LOOKUP_SEP):
394             try:
395                 field = model._meta.get_field(part)
396             except FieldDoesNotExist:
397                 # Lookups on nonexistent fields are ok, since they're ignored
398                 # later.
399                 break
400             # It is allowed to filter on values that would be found from local
401             # model anyways. For example, if you filter on employee__department__id,
402             # then the id value would be found already from employee__department_id.
403             if not prev_field or (prev_field.is_relation and
404                                   field not in prev_field.get_path_info()[-1].target_fields):
405                 relation_parts.append(part)
406             if not getattr(field, 'get_path_info', None):
407                 # This is not a relational field, so further parts
408                 # must be transforms.
409                 break
410             prev_field = field
411             model = field.get_path_info()[-1].to_opts.model
412 
413         if len(relation_parts) <= 1:
414             # Either a local field filter, or no fields at all.
415             return True
416         valid_lookups = {self.date_hierarchy}
417         for filter_item in self.list_filter:
418             if isinstance(filter_item, type) and issubclass(filter_item, SimpleListFilter):
419                 valid_lookups.add(filter_item.parameter_name)
420             elif isinstance(filter_item, (list, tuple)):
421                 valid_lookups.add(filter_item[0])
422             else:
423                 valid_lookups.add(filter_item)
424 
425         # Is it a valid relational lookup?
426         return not {
427             LOOKUP_SEP.join(relation_parts),
428             LOOKUP_SEP.join(relation_parts + [part])
429         }.isdisjoint(valid_lookups)
430 
431     def to_field_allowed(self, request, to_field):
432         """
433         Return True if the model associated with this admin should be
434         allowed to be referenced by the specified field.
435         """
436         opts = self.model._meta
437 
438         try:
439             field = opts.get_field(to_field)
440         except FieldDoesNotExist:
441             return False
442 
443         # Always allow referencing the primary key since it's already possible
444         # to get this information from the change view URL.
445         if field.primary_key:
446             return True
447 
448         # Allow reverse relationships to models defining m2m fields if they
449         # target the specified field.
450         for many_to_many in opts.many_to_many:
451             if many_to_many.m2m_target_field_name() == to_field:
452                 return True
453 
454         # Make sure at least one of the models registered for this site
455         # references this field through a FK or a M2M relationship.
456         registered_models = set()
457         for model, admin in self.admin_site._registry.items():
458             registered_models.add(model)
459             for inline in admin.inlines:
460                 registered_models.add(inline.model)
461 
462         related_objects = (
463             f for f in opts.get_fields(include_hidden=True)
464             if (f.auto_created and not f.concrete)
465         )
466         for related_object in related_objects:
467             related_model = related_object.related_model
468             remote_field = related_object.field.remote_field
469             if (any(issubclass(model, related_model) for model in registered_models) and
470                     hasattr(remote_field, 'get_related_field') and
471                     remote_field.get_related_field() == field):
472                 return True
473 
474         return False
475 
476     def has_add_permission(self, request):
477         """
478         Return True if the given request has permission to add an object.
479         Can be overridden by the user in subclasses.
480         """
481         opts = self.opts
482         codename = get_permission_codename('add', opts)
483         return request.user.has_perm("%s.%s" % (opts.app_label, codename))
484 
485     def has_change_permission(self, request, obj=None):
486         """
487         Return True if the given request has permission to change the given
488         Django model instance, the default implementation doesn't examine the
489         `obj` parameter.
490 
491         Can be overridden by the user in subclasses. In such case it should
492         return True if the given request has permission to change the `obj`
493         model instance. If `obj` is None, this should return True if the given
494         request has permission to change *any* object of the given type.
495         """
496         opts = self.opts
497         codename = get_permission_codename('change', opts)
498         return request.user.has_perm("%s.%s" % (opts.app_label, codename))
499 
500     def has_delete_permission(self, request, obj=None):
501         """
502         Return True if the given request has permission to change the given
503         Django model instance, the default implementation doesn't examine the
504         `obj` parameter.
505 
506         Can be overridden by the user in subclasses. In such case it should
507         return True if the given request has permission to delete the `obj`
508         model instance. If `obj` is None, this should return True if the given
509         request has permission to delete *any* object of the given type.
510         """
511         opts = self.opts
512         codename = get_permission_codename('delete', opts)
513         return request.user.has_perm("%s.%s" % (opts.app_label, codename))
514 
515     def has_view_permission(self, request, obj=None):
516         """
517         Return True if the given request has permission to view the given
518         Django model instance. The default implementation doesn't examine the
519         `obj` parameter.
520 
521         If overridden by the user in subclasses, it should return True if the
522         given request has permission to view the `obj` model instance. If `obj`
523         is None, it should return True if the request has permission to view
524         any object of the given type.
525         """
526         opts = self.opts
527         codename_view = get_permission_codename('view', opts)
528         codename_change = get_permission_codename('change', opts)
529         return (
530             request.user.has_perm('%s.%s' % (opts.app_label, codename_view)) or
531             request.user.has_perm('%s.%s' % (opts.app_label, codename_change))
532         )
533 
534     def has_view_or_change_permission(self, request, obj=None):
535         return self.has_view_permission(request, obj) or self.has_change_permission(request, obj)
536 
537     def has_module_permission(self, request):
538         """
539         Return True if the given request has any permission in the given
540         app label.
541 
542         Can be overridden by the user in subclasses. In such case it should
543         return True if the given request has permission to view the module on
544         the admin index page and access the module's index page. Overriding it
545         does not restrict access to the add, change or delete views. Use
546         `ModelAdmin.has_(add|change|delete)_permission` for that.
547         """
548         return request.user.has_module_perms(self.opts.app_label)
549 
550 
551 class ModelAdmin(BaseModelAdmin):
552     """Encapsulate all admin options and functionality for a given model."""
553 
554     list_display = ('__str__',)
555     list_display_links = ()
556     list_filter = ()
557     list_select_related = False
558     list_per_page = 100
559     list_max_show_all = 200
560     list_editable = ()
561     search_fields = ()
562     date_hierarchy = None
563     save_as = False
564     save_as_continue = True
565     save_on_top = False
566     paginator = Paginator
567     preserve_filters = True
568     inlines = []
569 
570     # Custom templates (designed to be over-ridden in subclasses)
571     add_form_template = None
572     change_form_template = None
573     change_list_template = None
574     delete_confirmation_template = None
575     delete_selected_confirmation_template = None
576     object_history_template = None
577     popup_response_template = None
578 
579     # Actions
580     actions = []
581     action_form = helpers.ActionForm
582     actions_on_top = True
583     actions_on_bottom = False
584     actions_selection_counter = True
585     checks_class = ModelAdminChecks
586 
587     def __init__(self, model, admin_site):
588         self.model = model
589         self.opts = model._meta
590         self.admin_site = admin_site
591         super().__init__()
592 
593     def __str__(self):
594         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
595 
596     def get_inline_instances(self, request, obj=None):
597         inline_instances = []
598         for inline_class in self.get_inlines(request, obj):
599             inline = inline_class(self.model, self.admin_site)
600             if request:
601                 if not (inline.has_view_or_change_permission(request, obj) or
602                         inline.has_add_permission(request, obj) or
603                         inline.has_delete_permission(request, obj)):
604                     continue
605                 if not inline.has_add_permission(request, obj):
606                     inline.max_num = 0
607             inline_instances.append(inline)
608 
609         return inline_instances
610 
611     def get_urls(self):
612         from django.urls import path
613 
614         def wrap(view):
615             def wrapper(*args, **kwargs):
616                 return self.admin_site.admin_view(view)(*args, **kwargs)
617             wrapper.model_admin = self
618             return update_wrapper(wrapper, view)
619 
620         info = self.model._meta.app_label, self.model._meta.model_name
621 
622         return [
623             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
624             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
625             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),
626             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
627             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
628             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
629             # For backwards compatibility (was the change url before 1.9)
630             path('<path:object_id>/', wrap(RedirectView.as_view(
631                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
632             ))),
633         ]
634 
635     @property
636     def urls(self):
637         return self.get_urls()
638 
639     @property
640     def media(self):
641         extra = '' if settings.DEBUG else '.min'
642         js = [
643             'vendor/jquery/jquery%s.js' % extra,
644             'jquery.init.js',
645             'core.js',
646             'admin/RelatedObjectLookups.js',
647             'actions.js',
648             'urlify.js',
649             'prepopulate.js',
650             'vendor/xregexp/xregexp%s.js' % extra,
651         ]
652         return forms.Media(js=['admin/js/%s' % url for url in js])
653 
654     def get_model_perms(self, request):
655         """
656         Return a dict of all perms for this model. This dict has the keys
657         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
658         for each of those actions.
659         """
660         return {
661             'add': self.has_add_permission(request),
662             'change': self.has_change_permission(request),
663             'delete': self.has_delete_permission(request),
664             'view': self.has_view_permission(request),
665         }
666 
667     def _get_form_for_get_fields(self, request, obj):
668         return self.get_form(request, obj, fields=None)
669 
670     def get_form(self, request, obj=None, change=False, **kwargs):
671         """
672         Return a Form class for use in the admin add view. This is used by
673         add_view and change_view.
674         """
675         if 'fields' in kwargs:
676             fields = kwargs.pop('fields')
677         else:
678             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
679         excluded = self.get_exclude(request, obj)
680         exclude = [] if excluded is None else list(excluded)
681         readonly_fields = self.get_readonly_fields(request, obj)
682         exclude.extend(readonly_fields)
683         # Exclude all fields if it's a change form and the user doesn't have
684         # the change permission.
685         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
686             exclude.extend(fields)
687         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
688             # Take the custom ModelForm's Meta.exclude into account only if the
689             # ModelAdmin doesn't define its own.
690             exclude.extend(self.form._meta.exclude)
691         # if exclude is an empty list we pass None to be consistent with the
692         # default on modelform_factory
693         exclude = exclude or None
694 
695         # Remove declared form fields which are in readonly_fields.
696         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
697         form = type(self.form.__name__, (self.form,), new_attrs)
698 
699         defaults = {
700             'form': form,
701             'fields': fields,
702             'exclude': exclude,
703             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
704             **kwargs,
705         }
706 
707         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
708             defaults['fields'] = forms.ALL_FIELDS
709 
710         try:
711             return modelform_factory(self.model, **defaults)
712         except FieldError as e:
713             raise FieldError(
714                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
715                 % (e, self.__class__.__name__)
716             )
717 
718     def get_changelist(self, request, **kwargs):
719         """
720         Return the ChangeList class for use on the changelist page.
721         """
722         from django.contrib.admin.views.main import ChangeList
723         return ChangeList
724 
725     def get_changelist_instance(self, request):
726         """
727         Return a `ChangeList` instance based on `request`. May raise
728         `IncorrectLookupParameters`.
729         """
730         list_display = self.get_list_display(request)
731         list_display_links = self.get_list_display_links(request, list_display)
732         # Add the action checkboxes if any actions are available.
733         if self.get_actions(request):
734             list_display = ['action_checkbox', *list_display]
735         sortable_by = self.get_sortable_by(request)
736         ChangeList = self.get_changelist(request)
737         return ChangeList(
738             request,
739             self.model,
740             list_display,
741             list_display_links,
742             self.get_list_filter(request),
743             self.date_hierarchy,
744             self.get_search_fields(request),
745             self.get_list_select_related(request),
746             self.list_per_page,
747             self.list_max_show_all,
748             self.list_editable,
749             self,
750             sortable_by,
751         )
752 
753     def get_object(self, request, object_id, from_field=None):
754         """
755         Return an instance matching the field and value provided, the primary
756         key is used if no field is provided. Return ``None`` if no match is
757         found or the object_id fails validation.
758         """
759         queryset = self.get_queryset(request)
760         model = queryset.model
761         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
762         try:
763             object_id = field.to_python(object_id)
764             return queryset.get(**{field.name: object_id})
765         except (model.DoesNotExist, ValidationError, ValueError):
766             return None
767 
768     def get_changelist_form(self, request, **kwargs):
769         """
770         Return a Form class for use in the Formset on the changelist page.
771         """
772         defaults = {
773             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
774             **kwargs,
775         }
776         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
777             defaults['fields'] = forms.ALL_FIELDS
778 
779         return modelform_factory(self.model, **defaults)
780 
781     def get_changelist_formset(self, request, **kwargs):
782         """
783         Return a FormSet class for use on the changelist page if list_editable
784         is used.
785         """
786         defaults = {
787             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
788             **kwargs,
789         }
790         return modelformset_factory(
791             self.model, self.get_changelist_form(request), extra=0,
792             fields=self.list_editable, **defaults
793         )
794 
795     def get_formsets_with_inlines(self, request, obj=None):
796         """
797         Yield formsets and the corresponding inlines.
798         """
799         for inline in self.get_inline_instances(request, obj):
800             yield inline.get_formset(request, obj), inline
801 
802     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
803         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
804 
805     def log_addition(self, request, object, message):
806         """
807         Log that an object has been successfully added.
808 
809         The default implementation creates an admin LogEntry object.
810         """
811         from django.contrib.admin.models import ADDITION, LogEntry
812         return LogEntry.objects.log_action(
813             user_id=request.user.pk,
814             content_type_id=get_content_type_for_model(object).pk,
815             object_id=object.pk,
816             object_repr=str(object),
817             action_flag=ADDITION,
818             change_message=message,
819         )
820 
821     def log_change(self, request, object, message):
822         """
823         Log that an object has been successfully changed.
824 
825         The default implementation creates an admin LogEntry object.
826         """
827         from django.contrib.admin.models import CHANGE, LogEntry
828         return LogEntry.objects.log_action(
829             user_id=request.user.pk,
830             content_type_id=get_content_type_for_model(object).pk,
831             object_id=object.pk,
832             object_repr=str(object),
833             action_flag=CHANGE,
834             change_message=message,
835         )
836 
837     def log_deletion(self, request, object, object_repr):
838         """
839         Log that an object will be deleted. Note that this method must be
840         called before the deletion.
841 
842         The default implementation creates an admin LogEntry object.
843         """
844         from django.contrib.admin.models import DELETION, LogEntry
845         return LogEntry.objects.log_action(
846             user_id=request.user.pk,
847             content_type_id=get_content_type_for_model(object).pk,
848             object_id=object.pk,
849             object_repr=object_repr,
850             action_flag=DELETION,
851         )
852 
853     def action_checkbox(self, obj):
854         """
855         A list_display column containing a checkbox widget.
856         """
857         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
858     action_checkbox.short_description = mark_safe('<input type="checkbox" id="action-toggle">')
859 
860     def _get_base_actions(self):
861         """Return the list of actions, prior to any request-based filtering."""
862         actions = []
863         base_actions = (self.get_action(action) for action in self.actions or [])
864         # get_action might have returned None, so filter any of those out.
865         base_actions = [action for action in base_actions if action]
866         base_action_names = {name for _, name, _ in base_actions}
867 
868         # Gather actions from the admin site first
869         for (name, func) in self.admin_site.actions:
870             if name in base_action_names:
871                 continue
872             description = getattr(func, 'short_description', name.replace('_', ' '))
873             actions.append((func, name, description))
874         # Add actions from this ModelAdmin.
875         actions.extend(base_actions)
876         return actions
877 
878     def _filter_actions_by_permissions(self, request, actions):
879         """Filter out any actions that the user doesn't have access to."""
880         filtered_actions = []
881         for action in actions:
882             callable = action[0]
883             if not hasattr(callable, 'allowed_permissions'):
884                 filtered_actions.append(action)
885                 continue
886             permission_checks = (
887                 getattr(self, 'has_%s_permission' % permission)
888                 for permission in callable.allowed_permissions
889             )
890             if any(has_permission(request) for has_permission in permission_checks):
891                 filtered_actions.append(action)
892         return filtered_actions
893 
894     def get_actions(self, request):
895         """
896         Return a dictionary mapping the names of all actions for this
897         ModelAdmin to a tuple of (callable, name, description) for each action.
898         """
899         # If self.actions is set to None that means actions are disabled on
900         # this page.
901         if self.actions is None or IS_POPUP_VAR in request.GET:
902             return {}
903         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
904         return {name: (func, name, desc) for func, name, desc in actions}
905 
906     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
907         """
908         Return a list of choices for use in a form object.  Each choice is a
909         tuple (name, description).
910         """
911         choices = [] + default_choices
912         for func, name, description in self.get_actions(request).values():
913             choice = (name, description % model_format_dict(self.opts))
914             choices.append(choice)
915         return choices
916 
917     def get_action(self, action):
918         """
919         Return a given action from a parameter, which can either be a callable,
920         or the name of a method on the ModelAdmin.  Return is a tuple of
921         (callable, name, description).
922         """
923         # If the action is a callable, just use it.
924         if callable(action):
925             func = action
926             action = action.__name__
927 
928         # Next, look for a method. Grab it off self.__class__ to get an unbound
929         # method instead of a bound one; this ensures that the calling
930         # conventions are the same for functions and methods.
931         elif hasattr(self.__class__, action):
932             func = getattr(self.__class__, action)
933 
934         # Finally, look for a named method on the admin site
935         else:
936             try:
937                 func = self.admin_site.get_action(action)
938             except KeyError:
939                 return None
940 
941         if hasattr(func, 'short_description'):
942             description = func.short_description
943         else:
944             description = capfirst(action.replace('_', ' '))
945         return func, action, description
946 
947     def get_list_display(self, request):
948         """
949         Return a sequence containing the fields to be displayed on the
950         changelist.
951         """
952         return self.list_display
953 
954     def get_list_display_links(self, request, list_display):
955         """
956         Return a sequence containing the fields to be displayed as links
957         on the changelist. The list_display parameter is the list of fields
958         returned by get_list_display().
959         """
960         if self.list_display_links or self.list_display_links is None or not list_display:
961             return self.list_display_links
962         else:
963             # Use only the first item in list_display as link
964             return list(list_display)[:1]
965 
966     def get_list_filter(self, request):
967         """
968         Return a sequence containing the fields to be displayed as filters in
969         the right sidebar of the changelist page.
970         """
971         return self.list_filter
972 
973     def get_list_select_related(self, request):
974         """
975         Return a list of fields to add to the select_related() part of the
976         changelist items query.
977         """
978         return self.list_select_related
979 
980     def get_search_fields(self, request):
981         """
982         Return a sequence containing the fields to be searched whenever
983         somebody submits a search query.
984         """
985         return self.search_fields
986 
987     def get_search_results(self, request, queryset, search_term):
988         """
989         Return a tuple containing a queryset to implement the search
990         and a boolean indicating if the results may contain duplicates.
991         """
992         # Apply keyword searches.
993         def construct_search(field_name):
994             if field_name.startswith('^'):
995                 return "%s__istartswith" % field_name[1:]
996             elif field_name.startswith('='):
997                 return "%s__iexact" % field_name[1:]
998             elif field_name.startswith('@'):
999                 return "%s__search" % field_name[1:]
1000             # Use field_name if it includes a lookup.
1001             opts = queryset.model._meta
1002             lookup_fields = field_name.split(LOOKUP_SEP)
1003             # Go through the fields, following all relations.
1004             prev_field = None
1005             for path_part in lookup_fields:
1006                 if path_part == 'pk':
1007                     path_part = opts.pk.name
1008                 try:
1009                     field = opts.get_field(path_part)
1010                 except FieldDoesNotExist:
1011                     # Use valid query lookups.
1012                     if prev_field and prev_field.get_lookup(path_part):
1013                         return field_name
1014                 else:
1015                     prev_field = field
1016                     if hasattr(field, 'get_path_info'):
1017                         # Update opts to follow the relation.
1018                         opts = field.get_path_info()[-1].to_opts
1019             # Otherwise, use the field with icontains.
1020             return "%s__icontains" % field_name
1021 
1022         use_distinct = False
1023         search_fields = self.get_search_fields(request)
1024         if search_fields and search_term:
1025             orm_lookups = [construct_search(str(search_field))
1026                            for search_field in search_fields]
1027             for bit in smart_split(search_term):
1028                 if bit.startswith(('"', "'")):
1029                     bit = unescape_string_literal(bit)
1030                 or_queries = [models.Q(**{orm_lookup: bit})
1031                               for orm_lookup in orm_lookups]
1032                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1033             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1034 
1035         return queryset, use_distinct
1036 
1037     def get_preserved_filters(self, request):
1038         """
1039         Return the preserved filters querystring.
1040         """
1041         match = request.resolver_match
1042         if self.preserve_filters and match:
1043             opts = self.model._meta
1044             current_url = '%s:%s' % (match.app_name, match.url_name)
1045             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1046             if current_url == changelist_url:
1047                 preserved_filters = request.GET.urlencode()
1048             else:
1049                 preserved_filters = request.GET.get('_changelist_filters')
1050 
1051             if preserved_filters:
1052                 return urlencode({'_changelist_filters': preserved_filters})
1053         return ''
1054 
1055     def construct_change_message(self, request, form, formsets, add=False):
1056         """
1057         Construct a JSON structure describing changes from a changed object.
1058         """
1059         return construct_change_message(form, formsets, add)
1060 
1061     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1062                      fail_silently=False):
1063         """
1064         Send a message to the user. The default implementation
1065         posts a message using the django.contrib.messages backend.
1066 
1067         Exposes almost the same API as messages.add_message(), but accepts the
1068         positional arguments in a different order to maintain backwards
1069         compatibility. For convenience, it accepts the `level` argument as
1070         a string rather than the usual level number.
1071         """
1072         if not isinstance(level, int):
1073             # attempt to get the level if passed a string
1074             try:
1075                 level = getattr(messages.constants, level.upper())
1076             except AttributeError:
1077                 levels = messages.constants.DEFAULT_TAGS.values()
1078                 levels_repr = ', '.join('`%s`' % level for level in levels)
1079                 raise ValueError(
1080                     'Bad message level string: `%s`. Possible values are: %s'
1081                     % (level, levels_repr)
1082                 )
1083 
1084         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1085 
1086     def save_form(self, request, form, change):
1087         """
1088         Given a ModelForm return an unsaved instance. ``change`` is True if
1089         the object is being changed, and False if it's being added.
1090         """
1091         return form.save(commit=False)
1092 
1093     def save_model(self, request, obj, form, change):
1094         """
1095         Given a model instance save it to the database.
1096         """
1097         obj.save()
1098 
1099     def delete_model(self, request, obj):
1100         """
1101         Given a model instance delete it from the database.
1102         """
1103         obj.delete()
1104 
1105     def delete_queryset(self, request, queryset):
1106         """Given a queryset, delete it from the database."""
1107         queryset.delete()
1108 
1109     def save_formset(self, request, form, formset, change):
1110         """
1111         Given an inline formset save it to the database.
1112         """
1113         formset.save()
1114 
1115     def save_related(self, request, form, formsets, change):
1116         """
1117         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1118         list of inline formsets and a boolean value based on whether the
1119         parent is being added or changed, save the related objects to the
1120         database. Note that at this point save_form() and save_model() have
1121         already been called.
1122         """
1123         form.save_m2m()
1124         for formset in formsets:
1125             self.save_formset(request, form, formset, change=change)
1126 
1127     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1128         opts = self.model._meta
1129         app_label = opts.app_label
1130         preserved_filters = self.get_preserved_filters(request)
1131         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1132         view_on_site_url = self.get_view_on_site_url(obj)
1133         has_editable_inline_admin_formsets = False
1134         for inline in context['inline_admin_formsets']:
1135             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1136                 has_editable_inline_admin_formsets = True
1137                 break
1138         context.update({
1139             'add': add,
1140             'change': change,
1141             'has_view_permission': self.has_view_permission(request, obj),
1142             'has_add_permission': self.has_add_permission(request),
1143             'has_change_permission': self.has_change_permission(request, obj),
1144             'has_delete_permission': self.has_delete_permission(request, obj),
1145             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1146             'has_file_field': context['adminform'].form.is_multipart() or any(
1147                 admin_formset.formset.is_multipart()
1148                 for admin_formset in context['inline_admin_formsets']
1149             ),
1150             'has_absolute_url': view_on_site_url is not None,
1151             'absolute_url': view_on_site_url,
1152             'form_url': form_url,
1153             'opts': opts,
1154             'content_type_id': get_content_type_for_model(self.model).pk,
1155             'save_as': self.save_as,
1156             'save_on_top': self.save_on_top,
1157             'to_field_var': TO_FIELD_VAR,
1158             'is_popup_var': IS_POPUP_VAR,
1159             'app_label': app_label,
1160         })
1161         if add and self.add_form_template is not None:
1162             form_template = self.add_form_template
1163         else:
1164             form_template = self.change_form_template
1165 
1166         request.current_app = self.admin_site.name
1167 
1168         return TemplateResponse(request, form_template or [
1169             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1170             "admin/%s/change_form.html" % app_label,
1171             "admin/change_form.html"
1172         ], context)
1173 
1174     def response_add(self, request, obj, post_url_continue=None):
1175         """
1176         Determine the HttpResponse for the add_view stage.
1177         """
1178         opts = obj._meta
1179         preserved_filters = self.get_preserved_filters(request)
1180         obj_url = reverse(
1181             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1182             args=(quote(obj.pk),),
1183             current_app=self.admin_site.name,
1184         )
1185         # Add a link to the object's change form if the user can edit the obj.
1186         if self.has_change_permission(request, obj):
1187             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1188         else:
1189             obj_repr = str(obj)
1190         msg_dict = {
1191             'name': opts.verbose_name,
1192             'obj': obj_repr,
1193         }
1194         # Here, we distinguish between different save types by checking for
1195         # the presence of keys in request.POST.
1196 
1197         if IS_POPUP_VAR in request.POST:
1198             to_field = request.POST.get(TO_FIELD_VAR)
1199             if to_field:
1200                 attr = str(to_field)
1201             else:
1202                 attr = obj._meta.pk.attname
1203             value = obj.serializable_value(attr)
1204             popup_response_data = json.dumps({
1205                 'value': str(value),
1206                 'obj': str(obj),
1207             })
1208             return TemplateResponse(request, self.popup_response_template or [
1209                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1210                 'admin/%s/popup_response.html' % opts.app_label,
1211                 'admin/popup_response.html',
1212             ], {
1213                 'popup_response_data': popup_response_data,
1214             })
1215 
1216         elif "_continue" in request.POST or (
1217                 # Redirecting after "Save as new".
1218                 "_saveasnew" in request.POST and self.save_as_continue and
1219                 self.has_change_permission(request, obj)
1220         ):
1221             msg = _('The {name} “{obj}” was added successfully.')
1222             if self.has_change_permission(request, obj):
1223                 msg += ' ' + _('You may edit it again below.')
1224             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1225             if post_url_continue is None:
1226                 post_url_continue = obj_url
1227             post_url_continue = add_preserved_filters(
1228                 {'preserved_filters': preserved_filters, 'opts': opts},
1229                 post_url_continue
1230             )
1231             return HttpResponseRedirect(post_url_continue)
1232 
1233         elif "_addanother" in request.POST:
1234             msg = format_html(
1235                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1236                 **msg_dict
1237             )
1238             self.message_user(request, msg, messages.SUCCESS)
1239             redirect_url = request.path
1240             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1241             return HttpResponseRedirect(redirect_url)
1242 
1243         else:
1244             msg = format_html(
1245                 _('The {name} “{obj}” was added successfully.'),
1246                 **msg_dict
1247             )
1248             self.message_user(request, msg, messages.SUCCESS)
1249             return self.response_post_save_add(request, obj)
1250 
1251     def response_change(self, request, obj):
1252         """
1253         Determine the HttpResponse for the change_view stage.
1254         """
1255 
1256         if IS_POPUP_VAR in request.POST:
1257             opts = obj._meta
1258             to_field = request.POST.get(TO_FIELD_VAR)
1259             attr = str(to_field) if to_field else opts.pk.attname
1260             value = request.resolver_match.kwargs['object_id']
1261             new_value = obj.serializable_value(attr)
1262             popup_response_data = json.dumps({
1263                 'action': 'change',
1264                 'value': str(value),
1265                 'obj': str(obj),
1266                 'new_value': str(new_value),
1267             })
1268             return TemplateResponse(request, self.popup_response_template or [
1269                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1270                 'admin/%s/popup_response.html' % opts.app_label,
1271                 'admin/popup_response.html',
1272             ], {
1273                 'popup_response_data': popup_response_data,
1274             })
1275 
1276         opts = self.model._meta
1277         preserved_filters = self.get_preserved_filters(request)
1278 
1279         msg_dict = {
1280             'name': opts.verbose_name,
1281             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1282         }
1283         if "_continue" in request.POST:
1284             msg = format_html(
1285                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1286                 **msg_dict
1287             )
1288             self.message_user(request, msg, messages.SUCCESS)
1289             redirect_url = request.path
1290             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1291             return HttpResponseRedirect(redirect_url)
1292 
1293         elif "_saveasnew" in request.POST:
1294             msg = format_html(
1295                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1296                 **msg_dict
1297             )
1298             self.message_user(request, msg, messages.SUCCESS)
1299             redirect_url = reverse('admin:%s_%s_change' %
1300                                    (opts.app_label, opts.model_name),
1301                                    args=(obj.pk,),
1302                                    current_app=self.admin_site.name)
1303             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1304             return HttpResponseRedirect(redirect_url)
1305 
1306         elif "_addanother" in request.POST:
1307             msg = format_html(
1308                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1309                 **msg_dict
1310             )
1311             self.message_user(request, msg, messages.SUCCESS)
1312             redirect_url = reverse('admin:%s_%s_add' %
1313                                    (opts.app_label, opts.model_name),
1314                                    current_app=self.admin_site.name)
1315             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1316             return HttpResponseRedirect(redirect_url)
1317 
1318         else:
1319             msg = format_html(
1320                 _('The {name} “{obj}” was changed successfully.'),
1321                 **msg_dict
1322             )
1323             self.message_user(request, msg, messages.SUCCESS)
1324             return self.response_post_save_change(request, obj)
1325 
1326     def _response_post_save(self, request, obj):
1327         opts = self.model._meta
1328         if self.has_view_or_change_permission(request):
1329             post_url = reverse('admin:%s_%s_changelist' %
1330                                (opts.app_label, opts.model_name),
1331                                current_app=self.admin_site.name)
1332             preserved_filters = self.get_preserved_filters(request)
1333             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1334         else:
1335             post_url = reverse('admin:index',
1336                                current_app=self.admin_site.name)
1337         return HttpResponseRedirect(post_url)
1338 
1339     def response_post_save_add(self, request, obj):
1340         """
1341         Figure out where to redirect after the 'Save' button has been pressed
1342         when adding a new object.
1343         """
1344         return self._response_post_save(request, obj)
1345 
1346     def response_post_save_change(self, request, obj):
1347         """
1348         Figure out where to redirect after the 'Save' button has been pressed
1349         when editing an existing object.
1350         """
1351         return self._response_post_save(request, obj)
1352 
1353     def response_action(self, request, queryset):
1354         """
1355         Handle an admin action. This is called if a request is POSTed to the
1356         changelist; it returns an HttpResponse if the action was handled, and
1357         None otherwise.
1358         """
1359 
1360         # There can be multiple action forms on the page (at the top
1361         # and bottom of the change list, for example). Get the action
1362         # whose button was pushed.
1363         try:
1364             action_index = int(request.POST.get('index', 0))
1365         except ValueError:
1366             action_index = 0
1367 
1368         # Construct the action form.
1369         data = request.POST.copy()
1370         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1371         data.pop("index", None)
1372 
1373         # Use the action whose button was pushed
1374         try:
1375             data.update({'action': data.getlist('action')[action_index]})
1376         except IndexError:
1377             # If we didn't get an action from the chosen form that's invalid
1378             # POST data, so by deleting action it'll fail the validation check
1379             # below. So no need to do anything here
1380             pass
1381 
1382         action_form = self.action_form(data, auto_id=None)
1383         action_form.fields['action'].choices = self.get_action_choices(request)
1384 
1385         # If the form's valid we can handle the action.
1386         if action_form.is_valid():
1387             action = action_form.cleaned_data['action']
1388             select_across = action_form.cleaned_data['select_across']
1389             func = self.get_actions(request)[action][0]
1390 
1391             # Get the list of selected PKs. If nothing's selected, we can't
1392             # perform an action on it, so bail. Except we want to perform
1393             # the action explicitly on all objects.
1394             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1395             if not selected and not select_across:
1396                 # Reminder that something needs to be selected or nothing will happen
1397                 msg = _("Items must be selected in order to perform "
1398                         "actions on them. No items have been changed.")
1399                 self.message_user(request, msg, messages.WARNING)
1400                 return None
1401 
1402             if not select_across:
1403                 # Perform the action only on the selected objects
1404                 queryset = queryset.filter(pk__in=selected)
1405 
1406             response = func(self, request, queryset)
1407 
1408             # Actions may return an HttpResponse-like object, which will be
1409             # used as the response from the POST. If not, we'll be a good
1410             # little HTTP citizen and redirect back to the changelist page.
1411             if isinstance(response, HttpResponseBase):
1412                 return response
1413             else:
1414                 return HttpResponseRedirect(request.get_full_path())
1415         else:
1416             msg = _("No action selected.")
1417             self.message_user(request, msg, messages.WARNING)
1418             return None
1419 
1420     def response_delete(self, request, obj_display, obj_id):
1421         """
1422         Determine the HttpResponse for the delete_view stage.
1423         """
1424         opts = self.model._meta
1425 
1426         if IS_POPUP_VAR in request.POST:
1427             popup_response_data = json.dumps({
1428                 'action': 'delete',
1429                 'value': str(obj_id),
1430             })
1431             return TemplateResponse(request, self.popup_response_template or [
1432                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1433                 'admin/%s/popup_response.html' % opts.app_label,
1434                 'admin/popup_response.html',
1435             ], {
1436                 'popup_response_data': popup_response_data,
1437             })
1438 
1439         self.message_user(
1440             request,
1441             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1442                 'name': opts.verbose_name,
1443                 'obj': obj_display,
1444             },
1445             messages.SUCCESS,
1446         )
1447 
1448         if self.has_change_permission(request, None):
1449             post_url = reverse(
1450                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1451                 current_app=self.admin_site.name,
1452             )
1453             preserved_filters = self.get_preserved_filters(request)
1454             post_url = add_preserved_filters(
1455                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1456             )
1457         else:
1458             post_url = reverse('admin:index', current_app=self.admin_site.name)
1459         return HttpResponseRedirect(post_url)
1460 
1461     def render_delete_form(self, request, context):
1462         opts = self.model._meta
1463         app_label = opts.app_label
1464 
1465         request.current_app = self.admin_site.name
1466         context.update(
1467             to_field_var=TO_FIELD_VAR,
1468             is_popup_var=IS_POPUP_VAR,
1469             media=self.media,
1470         )
1471 
1472         return TemplateResponse(
1473             request,
1474             self.delete_confirmation_template or [
1475                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1476                 "admin/{}/delete_confirmation.html".format(app_label),
1477                 "admin/delete_confirmation.html",
1478             ],
1479             context,
1480         )
1481 
1482     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1483         # Edit permissions on parent model are required for editable inlines.
1484         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1485         inline_admin_formsets = []
1486         for inline, formset in zip(inline_instances, formsets):
1487             fieldsets = list(inline.get_fieldsets(request, obj))
1488             readonly = list(inline.get_readonly_fields(request, obj))
1489             if can_edit_parent:
1490                 has_add_permission = inline.has_add_permission(request, obj)
1491                 has_change_permission = inline.has_change_permission(request, obj)
1492                 has_delete_permission = inline.has_delete_permission(request, obj)
1493             else:
1494                 # Disable all edit-permissions, and overide formset settings.
1495                 has_add_permission = has_change_permission = has_delete_permission = False
1496                 formset.extra = formset.max_num = 0
1497             has_view_permission = inline.has_view_permission(request, obj)
1498             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1499             inline_admin_formset = helpers.InlineAdminFormSet(
1500                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1501                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1502                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1503             )
1504             inline_admin_formsets.append(inline_admin_formset)
1505         return inline_admin_formsets
1506 
1507     def get_changeform_initial_data(self, request):
1508         """
1509         Get the initial form data from the request's GET params.
1510         """
1511         initial = dict(request.GET.items())
1512         for k in initial:
1513             try:
1514                 f = self.model._meta.get_field(k)
1515             except FieldDoesNotExist:
1516                 continue
1517             # We have to special-case M2Ms as a list of comma-separated PKs.
1518             if isinstance(f, models.ManyToManyField):
1519                 initial[k] = initial[k].split(",")
1520         return initial
1521 
1522     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1523         """
1524         Create a message informing the user that the object doesn't exist
1525         and return a redirect to the admin index page.
1526         """
1527         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1528             'name': opts.verbose_name,
1529             'key': unquote(object_id),
1530         }
1531         self.message_user(request, msg, messages.WARNING)
1532         url = reverse('admin:index', current_app=self.admin_site.name)
1533         return HttpResponseRedirect(url)
1534 
1535     @csrf_protect_m
1536     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1537         with transaction.atomic(using=router.db_for_write(self.model)):
1538             return self._changeform_view(request, object_id, form_url, extra_context)
1539 
1540     def _changeform_view(self, request, object_id, form_url, extra_context):
1541         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1542         if to_field and not self.to_field_allowed(request, to_field):
1543             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1544 
1545         model = self.model
1546         opts = model._meta
1547 
1548         if request.method == 'POST' and '_saveasnew' in request.POST:
1549             object_id = None
1550 
1551         add = object_id is None
1552 
1553         if add:
1554             if not self.has_add_permission(request):
1555                 raise PermissionDenied
1556             obj = None
1557 
1558         else:
1559             obj = self.get_object(request, unquote(object_id), to_field)
1560 
1561             if request.method == 'POST':
1562                 if not self.has_change_permission(request, obj):
1563                     raise PermissionDenied
1564             else:
1565                 if not self.has_view_or_change_permission(request, obj):
1566                     raise PermissionDenied
1567 
1568             if obj is None:
1569                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1570 
1571         fieldsets = self.get_fieldsets(request, obj)
1572         ModelForm = self.get_form(
1573             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1574         )
1575         if request.method == 'POST':
1576             form = ModelForm(request.POST, request.FILES, instance=obj)
1577             form_validated = form.is_valid()
1578             if form_validated:
1579                 new_object = self.save_form(request, form, change=not add)
1580             else:
1581                 new_object = form.instance
1582             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1583             if all_valid(formsets) and form_validated:
1584                 self.save_model(request, new_object, form, not add)
1585                 self.save_related(request, form, formsets, not add)
1586                 change_message = self.construct_change_message(request, form, formsets, add)
1587                 if add:
1588                     self.log_addition(request, new_object, change_message)
1589                     return self.response_add(request, new_object)
1590                 else:
1591                     self.log_change(request, new_object, change_message)
1592                     return self.response_change(request, new_object)
1593             else:
1594                 form_validated = False
1595         else:
1596             if add:
1597                 initial = self.get_changeform_initial_data(request)
1598                 form = ModelForm(initial=initial)
1599                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1600             else:
1601                 form = ModelForm(instance=obj)
1602                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1603 
1604         if not add and not self.has_change_permission(request, obj):
1605             readonly_fields = flatten_fieldsets(fieldsets)
1606         else:
1607             readonly_fields = self.get_readonly_fields(request, obj)
1608         adminForm = helpers.AdminForm(
1609             form,
1610             list(fieldsets),
1611             # Clear prepopulated fields on a view-only form to avoid a crash.
1612             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1613             readonly_fields,
1614             model_admin=self)
1615         media = self.media + adminForm.media
1616 
1617         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1618         for inline_formset in inline_formsets:
1619             media = media + inline_formset.media
1620 
1621         if add:
1622             title = _('Add %s')
1623         elif self.has_change_permission(request, obj):
1624             title = _('Change %s')
1625         else:
1626             title = _('View %s')
1627         context = {
1628             **self.admin_site.each_context(request),
1629             'title': title % opts.verbose_name,
1630             'subtitle': str(obj) if obj else None,
1631             'adminform': adminForm,
1632             'object_id': object_id,
1633             'original': obj,
1634             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1635             'to_field': to_field,
1636             'media': media,
1637             'inline_admin_formsets': inline_formsets,
1638             'errors': helpers.AdminErrorList(form, formsets),
1639             'preserved_filters': self.get_preserved_filters(request),
1640         }
1641 
1642         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1643         # previously chosen to prevent the interface from getting confusing.
1644         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1645             context['show_save'] = False
1646             context['show_save_and_continue'] = False
1647             # Use the change template instead of the add template.
1648             add = False
1649 
1650         context.update(extra_context or {})
1651 
1652         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1653 
1654     def autocomplete_view(self, request):
1655         return AutocompleteJsonView.as_view(model_admin=self)(request)
1656 
1657     def add_view(self, request, form_url='', extra_context=None):
1658         return self.changeform_view(request, None, form_url, extra_context)
1659 
1660     def change_view(self, request, object_id, form_url='', extra_context=None):
1661         return self.changeform_view(request, object_id, form_url, extra_context)
1662 
1663     def _get_edited_object_pks(self, request, prefix):
1664         """Return POST data values of list_editable primary keys."""
1665         pk_pattern = re.compile(
1666             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1667         )
1668         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1669 
1670     def _get_list_editable_queryset(self, request, prefix):
1671         """
1672         Based on POST data, return a queryset of the objects that were edited
1673         via list_editable.
1674         """
1675         object_pks = self._get_edited_object_pks(request, prefix)
1676         queryset = self.get_queryset(request)
1677         validate = queryset.model._meta.pk.to_python
1678         try:
1679             for pk in object_pks:
1680                 validate(pk)
1681         except ValidationError:
1682             # Disable the optimization if the POST data was tampered with.
1683             return queryset
1684         return queryset.filter(pk__in=object_pks)
1685 
1686     @csrf_protect_m
1687     def changelist_view(self, request, extra_context=None):
1688         """
1689         The 'change list' admin view for this model.
1690         """
1691         from django.contrib.admin.views.main import ERROR_FLAG
1692         opts = self.model._meta
1693         app_label = opts.app_label
1694         if not self.has_view_or_change_permission(request):
1695             raise PermissionDenied
1696 
1697         try:
1698             cl = self.get_changelist_instance(request)
1699         except IncorrectLookupParameters:
1700             # Wacky lookup parameters were given, so redirect to the main
1701             # changelist page, without parameters, and pass an 'invalid=1'
1702             # parameter via the query string. If wacky parameters were given
1703             # and the 'invalid=1' parameter was already in the query string,
1704             # something is screwed up with the database, so display an error
1705             # page.
1706             if ERROR_FLAG in request.GET:
1707                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1708                     'title': _('Database error'),
1709                 })
1710             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1711 
1712         # If the request was POSTed, this might be a bulk action or a bulk
1713         # edit. Try to look up an action or confirmation first, but if this
1714         # isn't an action the POST will fall through to the bulk edit check,
1715         # below.
1716         action_failed = False
1717         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1718 
1719         actions = self.get_actions(request)
1720         # Actions with no confirmation
1721         if (actions and request.method == 'POST' and
1722                 'index' in request.POST and '_save' not in request.POST):
1723             if selected:
1724                 response = self.response_action(request, queryset=cl.get_queryset(request))
1725                 if response:
1726                     return response
1727                 else:
1728                     action_failed = True
1729             else:
1730                 msg = _("Items must be selected in order to perform "
1731                         "actions on them. No items have been changed.")
1732                 self.message_user(request, msg, messages.WARNING)
1733                 action_failed = True
1734 
1735         # Actions with confirmation
1736         if (actions and request.method == 'POST' and
1737                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1738                 'index' not in request.POST and '_save' not in request.POST):
1739             if selected:
1740                 response = self.response_action(request, queryset=cl.get_queryset(request))
1741                 if response:
1742                     return response
1743                 else:
1744                     action_failed = True
1745 
1746         if action_failed:
1747             # Redirect back to the changelist page to avoid resubmitting the
1748             # form if the user refreshes the browser or uses the "No, take
1749             # me back" button on the action confirmation page.
1750             return HttpResponseRedirect(request.get_full_path())
1751 
1752         # If we're allowing changelist editing, we need to construct a formset
1753         # for the changelist given all the fields to be edited. Then we'll
1754         # use the formset to validate/process POSTed data.
1755         formset = cl.formset = None
1756 
1757         # Handle POSTed bulk-edit data.
1758         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1759             if not self.has_change_permission(request):
1760                 raise PermissionDenied
1761             FormSet = self.get_changelist_formset(request)
1762             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1763             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1764             if formset.is_valid():
1765                 changecount = 0
1766                 for form in formset.forms:
1767                     if form.has_changed():
1768                         obj = self.save_form(request, form, change=True)
1769                         self.save_model(request, obj, form, change=True)
1770                         self.save_related(request, form, formsets=[], change=True)
1771                         change_msg = self.construct_change_message(request, form, None)
1772                         self.log_change(request, obj, change_msg)
1773                         changecount += 1
1774 
1775                 if changecount:
1776                     msg = ngettext(
1777                         "%(count)s %(name)s was changed successfully.",
1778                         "%(count)s %(name)s were changed successfully.",
1779                         changecount
1780                     ) % {
1781                         'count': changecount,
1782                         'name': model_ngettext(opts, changecount),
1783                     }
1784                     self.message_user(request, msg, messages.SUCCESS)
1785 
1786                 return HttpResponseRedirect(request.get_full_path())
1787 
1788         # Handle GET -- construct a formset for display.
1789         elif cl.list_editable and self.has_change_permission(request):
1790             FormSet = self.get_changelist_formset(request)
1791             formset = cl.formset = FormSet(queryset=cl.result_list)
1792 
1793         # Build the list of media to be used by the formset.
1794         if formset:
1795             media = self.media + formset.media
1796         else:
1797             media = self.media
1798 
1799         # Build the action form and populate it with available actions.
1800         if actions:
1801             action_form = self.action_form(auto_id=None)
1802             action_form.fields['action'].choices = self.get_action_choices(request)
1803             media += action_form.media
1804         else:
1805             action_form = None
1806 
1807         selection_note_all = ngettext(
1808             '%(total_count)s selected',
1809             'All %(total_count)s selected',
1810             cl.result_count
1811         )
1812 
1813         context = {
1814             **self.admin_site.each_context(request),
1815             'module_name': str(opts.verbose_name_plural),
1816             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1817             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1818             'title': cl.title,
1819             'subtitle': None,
1820             'is_popup': cl.is_popup,
1821             'to_field': cl.to_field,
1822             'cl': cl,
1823             'media': media,
1824             'has_add_permission': self.has_add_permission(request),
1825             'opts': cl.opts,
1826             'action_form': action_form,
1827             'actions_on_top': self.actions_on_top,
1828             'actions_on_bottom': self.actions_on_bottom,
1829             'actions_selection_counter': self.actions_selection_counter,
1830             'preserved_filters': self.get_preserved_filters(request),
1831             **(extra_context or {}),
1832         }
1833 
1834         request.current_app = self.admin_site.name
1835 
1836         return TemplateResponse(request, self.change_list_template or [
1837             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1838             'admin/%s/change_list.html' % app_label,
1839             'admin/change_list.html'
1840         ], context)
1841 
1842     def get_deleted_objects(self, objs, request):
1843         """
1844         Hook for customizing the delete process for the delete view and the
1845         "delete selected" action.
1846         """
1847         return get_deleted_objects(objs, request, self.admin_site)
1848 
1849     @csrf_protect_m
1850     def delete_view(self, request, object_id, extra_context=None):
1851         with transaction.atomic(using=router.db_for_write(self.model)):
1852             return self._delete_view(request, object_id, extra_context)
1853 
1854     def _delete_view(self, request, object_id, extra_context):
1855         "The 'delete' admin view for this model."
1856         opts = self.model._meta
1857         app_label = opts.app_label
1858 
1859         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1860         if to_field and not self.to_field_allowed(request, to_field):
1861             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1862 
1863         obj = self.get_object(request, unquote(object_id), to_field)
1864 
1865         if not self.has_delete_permission(request, obj):
1866             raise PermissionDenied
1867 
1868         if obj is None:
1869             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1870 
1871         # Populate deleted_objects, a data structure of all related objects that
1872         # will also be deleted.
1873         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1874 
1875         if request.POST and not protected:  # The user has confirmed the deletion.
1876             if perms_needed:
1877                 raise PermissionDenied
1878             obj_display = str(obj)
1879             attr = str(to_field) if to_field else opts.pk.attname
1880             obj_id = obj.serializable_value(attr)
1881             self.log_deletion(request, obj, obj_display)
1882             self.delete_model(request, obj)
1883 
1884             return self.response_delete(request, obj_display, obj_id)
1885 
1886         object_name = str(opts.verbose_name)
1887 
1888         if perms_needed or protected:
1889             title = _("Cannot delete %(name)s") % {"name": object_name}
1890         else:
1891             title = _("Are you sure?")
1892 
1893         context = {
1894             **self.admin_site.each_context(request),
1895             'title': title,
1896             'object_name': object_name,
1897             'object': obj,
1898             'deleted_objects': deleted_objects,
1899             'model_count': dict(model_count).items(),
1900             'perms_lacking': perms_needed,
1901             'protected': protected,
1902             'opts': opts,
1903             'app_label': app_label,
1904             'preserved_filters': self.get_preserved_filters(request),
1905             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1906             'to_field': to_field,
1907             **(extra_context or {}),
1908         }
1909 
1910         return self.render_delete_form(request, context)
1911 
1912     def history_view(self, request, object_id, extra_context=None):
1913         "The 'history' admin view for this model."
1914         from django.contrib.admin.models import LogEntry
1915 
1916         # First check if the user can see this history.
1917         model = self.model
1918         obj = self.get_object(request, unquote(object_id))
1919         if obj is None:
1920             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1921 
1922         if not self.has_view_or_change_permission(request, obj):
1923             raise PermissionDenied
1924 
1925         # Then get the history for this object.
1926         opts = model._meta
1927         app_label = opts.app_label
1928         action_list = LogEntry.objects.filter(
1929             object_id=unquote(object_id),
1930             content_type=get_content_type_for_model(model)
1931         ).select_related().order_by('action_time')
1932 
1933         context = {
1934             **self.admin_site.each_context(request),
1935             'title': _('Change history: %s') % obj,
1936             'action_list': action_list,
1937             'module_name': str(capfirst(opts.verbose_name_plural)),
1938             'object': obj,
1939             'opts': opts,
1940             'preserved_filters': self.get_preserved_filters(request),
1941             **(extra_context or {}),
1942         }
1943 
1944         request.current_app = self.admin_site.name
1945 
1946         return TemplateResponse(request, self.object_history_template or [
1947             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1948             "admin/%s/object_history.html" % app_label,
1949             "admin/object_history.html"
1950         ], context)
1951 
1952     def _create_formsets(self, request, obj, change):
1953         "Helper function to generate formsets for add/change_view."
1954         formsets = []
1955         inline_instances = []
1956         prefixes = {}
1957         get_formsets_args = [request]
1958         if change:
1959             get_formsets_args.append(obj)
1960         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1961             prefix = FormSet.get_default_prefix()
1962             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1963             if prefixes[prefix] != 1 or not prefix:
1964                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1965             formset_params = {
1966                 'instance': obj,
1967                 'prefix': prefix,
1968                 'queryset': inline.get_queryset(request),
1969             }
1970             if request.method == 'POST':
1971                 formset_params.update({
1972                     'data': request.POST.copy(),
1973                     'files': request.FILES,
1974                     'save_as_new': '_saveasnew' in request.POST
1975                 })
1976             formset = FormSet(**formset_params)
1977 
1978             def user_deleted_form(request, obj, formset, index):
1979                 """Return whether or not the user deleted the form."""
1980                 return (
1981                     inline.has_delete_permission(request, obj) and
1982                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1983                 )
1984 
1985             # Bypass validation of each view-only inline form (since the form's
1986             # data won't be in request.POST), unless the form was deleted.
1987             if not inline.has_change_permission(request, obj if change else None):
1988                 for index, form in enumerate(formset.initial_forms):
1989                     if user_deleted_form(request, obj, formset, index):
1990                         continue
1991                     form._errors = {}
1992                     form.cleaned_data = form.initial
1993             formsets.append(formset)
1994             inline_instances.append(inline)
1995         return formsets, inline_instances
1996 
1997 
1998 class InlineModelAdmin(BaseModelAdmin):
1999     """
2000     Options for inline editing of ``model`` instances.
2001 
2002     Provide ``fk_name`` to specify the attribute name of the ``ForeignKey``
2003     from ``model`` to its parent. This is required if ``model`` has more than
2004     one ``ForeignKey`` to its parent.
2005     """
2006     model = None
2007     fk_name = None
2008     formset = BaseInlineFormSet
2009     extra = 3
2010     min_num = None
2011     max_num = None
2012     template = None
2013     verbose_name = None
2014     verbose_name_plural = None
2015     can_delete = True
2016     show_change_link = False
2017     checks_class = InlineModelAdminChecks
2018     classes = None
2019 
2020     def __init__(self, parent_model, admin_site):
2021         self.admin_site = admin_site
2022         self.parent_model = parent_model
2023         self.opts = self.model._meta
2024         self.has_registered_model = admin_site.is_registered(self.model)
2025         super().__init__()
2026         if self.verbose_name is None:
2027             self.verbose_name = self.model._meta.verbose_name
2028         if self.verbose_name_plural is None:
2029             self.verbose_name_plural = self.model._meta.verbose_name_plural
2030 
2031     @property
2032     def media(self):
2033         extra = '' if settings.DEBUG else '.min'
2034         js = ['vendor/jquery/jquery%s.js' % extra, 'jquery.init.js', 'inlines.js']
2035         if self.filter_vertical or self.filter_horizontal:
2036             js.extend(['SelectBox.js', 'SelectFilter2.js'])
2037         if self.classes and 'collapse' in self.classes:
2038             js.append('collapse.js')
2039         return forms.Media(js=['admin/js/%s' % url for url in js])
2040 
2041     def get_extra(self, request, obj=None, **kwargs):
2042         """Hook for customizing the number of extra inline forms."""
2043         return self.extra
2044 
2045     def get_min_num(self, request, obj=None, **kwargs):
2046         """Hook for customizing the min number of inline forms."""
2047         return self.min_num
2048 
2049     def get_max_num(self, request, obj=None, **kwargs):
2050         """Hook for customizing the max number of extra inline forms."""
2051         return self.max_num
2052 
2053     def get_formset(self, request, obj=None, **kwargs):
2054         """Return a BaseInlineFormSet class for use in admin add/change views."""
2055         if 'fields' in kwargs:
2056             fields = kwargs.pop('fields')
2057         else:
2058             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
2059         excluded = self.get_exclude(request, obj)
2060         exclude = [] if excluded is None else list(excluded)
2061         exclude.extend(self.get_readonly_fields(request, obj))
2062         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
2063             # Take the custom ModelForm's Meta.exclude into account only if the
2064             # InlineModelAdmin doesn't define its own.
2065             exclude.extend(self.form._meta.exclude)
2066         # If exclude is an empty list we use None, since that's the actual
2067         # default.
2068         exclude = exclude or None
2069         can_delete = self.can_delete and self.has_delete_permission(request, obj)
2070         defaults = {
2071             'form': self.form,
2072             'formset': self.formset,
2073             'fk_name': self.fk_name,
2074             'fields': fields,
2075             'exclude': exclude,
2076             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
2077             'extra': self.get_extra(request, obj, **kwargs),
2078             'min_num': self.get_min_num(request, obj, **kwargs),
2079             'max_num': self.get_max_num(request, obj, **kwargs),
2080             'can_delete': can_delete,
2081             **kwargs,
2082         }
2083 
2084         base_model_form = defaults['form']
2085         can_change = self.has_change_permission(request, obj) if request else True
2086         can_add = self.has_add_permission(request, obj) if request else True
2087 
2088         class DeleteProtectedModelForm(base_model_form):
2089 
2090             def hand_clean_DELETE(self):
2091                 """
2092                 We don't validate the 'DELETE' field itself because on
2093                 templates it's not rendered using the field information, but
2094                 just using a generic "deletion_field" of the InlineModelAdmin.
2095                 """
2096                 if self.cleaned_data.get(DELETION_FIELD_NAME, False):
2097                     using = router.db_for_write(self._meta.model)
2098                     collector = NestedObjects(using=using)
2099                     if self.instance._state.adding:
2100                         return
2101                     collector.collect([self.instance])
2102                     if collector.protected:
2103                         objs = []
2104                         for p in collector.protected:
2105                             objs.append(
2106                                 # Translators: Model verbose name and instance representation,
2107                                 # suitable to be an item in a list.
2108                                 _('%(class_name)s %(instance)s') % {
2109                                     'class_name': p._meta.verbose_name,
2110                                     'instance': p}
2111                             )
2112                         params = {
2113                             'class_name': self._meta.model._meta.verbose_name,
2114                             'instance': self.instance,
2115                             'related_objects': get_text_list(objs, _('and')),
2116                         }
2117                         msg = _("Deleting %(class_name)s %(instance)s would require "
2118                                 "deleting the following protected related objects: "
2119                                 "%(related_objects)s")
2120                         raise ValidationError(msg, code='deleting_protected', params=params)
2121 
2122             def is_valid(self):
2123                 result = super().is_valid()
2124                 self.hand_clean_DELETE()
2125                 return result
2126 
2127             def has_changed(self):
2128                 # Protect against unauthorized edits.
2129                 if not can_change and not self.instance._state.adding:
2130                     return False
2131                 if not can_add and self.instance._state.adding:
2132                     return False
2133                 return super().has_changed()
2134 
2135         defaults['form'] = DeleteProtectedModelForm
2136 
2137         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
2138             defaults['fields'] = forms.ALL_FIELDS
2139 
2140         return inlineformset_factory(self.parent_model, self.model, **defaults)
2141 
2142     def _get_form_for_get_fields(self, request, obj=None):
2143         return self.get_formset(request, obj, fields=None).form
2144 
2145     def get_queryset(self, request):
2146         queryset = super().get_queryset(request)
2147         if not self.has_view_or_change_permission(request):
2148             queryset = queryset.none()
2149         return queryset
2150 
2151     def _has_any_perms_for_target_model(self, request, perms):
2152         """
2153         This method is called only when the ModelAdmin's model is for an
2154         ManyToManyField's implicit through model (if self.opts.auto_created).
2155         Return True if the user has any of the given permissions ('add',
2156         'change', etc.) for the model that points to the through model.
2157         """
2158         opts = self.opts
2159         # Find the target model of an auto-created many-to-many relationship.
2160         for field in opts.fields:
2161             if field.remote_field and field.remote_field.model != self.parent_model:
2162                 opts = field.remote_field.model._meta
2163                 break
2164         return any(
2165             request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename(perm, opts)))
2166             for perm in perms
2167         )
2168 
2169     def has_add_permission(self, request, obj):
2170         if self.opts.auto_created:
2171             # Auto-created intermediate models don't have their own
2172             # permissions. The user needs to have the change permission for the
2173             # related model in order to be able to do anything with the
2174             # intermediate model.
2175             return self._has_any_perms_for_target_model(request, ['change'])
2176         return super().has_add_permission(request)
2177 
2178     def has_change_permission(self, request, obj=None):
2179         if self.opts.auto_created:
2180             # Same comment as has_add_permission().
2181             return self._has_any_perms_for_target_model(request, ['change'])
2182         return super().has_change_permission(request)
2183 
2184     def has_delete_permission(self, request, obj=None):
2185         if self.opts.auto_created:
2186             # Same comment as has_add_permission().
2187             return self._has_any_perms_for_target_model(request, ['change'])
2188         return super().has_delete_permission(request, obj)
2189 
2190     def has_view_permission(self, request, obj=None):
2191         if self.opts.auto_created:
2192             # Same comment as has_add_permission(). The 'change' permission
2193             # also implies the 'view' permission.
2194             return self._has_any_perms_for_target_model(request, ['view', 'change'])
2195         return super().has_view_permission(request)
2196 
2197 
2198 class StackedInline(InlineModelAdmin):
2199     template = 'admin/edit_inline/stacked.html'
2200 
2201 
2202 class TabularInline(InlineModelAdmin):
2203     template = 'admin/edit_inline/tabular.html'

</code><intended_behavior>Review and adjust how `JSONField` data is prepared and displayed in the admin interface, specifically in methods that handle or display field values in the admin forms or list displays. If `json.dumps` is used to serialize `JSONField` data for display, ensure it uses `ensure_ascii=False`. This adjustment is to ensure that the admin interface properly displays Unicode characters contained in `JSONField`, enhancing user experience without affecting the admin's performance or security.</intended_behavior>]
2025-10-17 12:28:51.204 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 12:28:51.204 | INFO     | Search-only: skipping patch selection
2025-10-17 12:28:51.338 | INFO     | Task django__django-13512 completed successfully.
2025-10-17 12:28:51.339 | INFO     | No patch generated. You can try running ACR again.
