[
    {
        "rel_file_path": "django/db/models/fields/json.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/fields/json.py",
        "start": 1,
        "end": 520,
        "class_name": null,
        "method_name": null,
        "code": "1 import json\n2 \n3 from django import forms\n4 from django.core import checks, exceptions\n5 from django.db import NotSupportedError, connections, router\n6 from django.db.models import lookups\n7 from django.db.models.lookups import PostgresOperatorLookup, Transform\n8 from django.utils.translation import gettext_lazy as _\n9 \n10 from . import Field\n11 from .mixins import CheckFieldDefaultMixin\n12 \n13 __all__ = ['JSONField']\n14 \n15 \n16 class JSONField(CheckFieldDefaultMixin, Field):\n17     empty_strings_allowed = False\n18     description = _('A JSON object')\n19     default_error_messages = {\n20         'invalid': _('Value must be valid JSON.'),\n21     }\n22     _default_hint = ('dict', '{}')\n23 \n24     def __init__(\n25         self, verbose_name=None, name=None, encoder=None, decoder=None,\n26         **kwargs,\n27     ):\n28         if encoder and not callable(encoder):\n29             raise ValueError('The encoder parameter must be a callable object.')\n30         if decoder and not callable(decoder):\n31             raise ValueError('The decoder parameter must be a callable object.')\n32         self.encoder = encoder\n33         self.decoder = decoder\n34         super().__init__(verbose_name, name, **kwargs)\n35 \n36     def check(self, **kwargs):\n37         errors = super().check(**kwargs)\n38         databases = kwargs.get('databases') or []\n39         errors.extend(self._check_supported(databases))\n40         return errors\n41 \n42     def _check_supported(self, databases):\n43         errors = []\n44         for db in databases:\n45             if not router.allow_migrate_model(db, self.model):\n46                 continue\n47             connection = connections[db]\n48             if not (\n49                 'supports_json_field' in self.model._meta.required_db_features or\n50                 connection.features.supports_json_field\n51             ):\n52                 errors.append(\n53                     checks.Error(\n54                         '%s does not support JSONFields.'\n55                         % connection.display_name,\n56                         obj=self.model,\n57                         id='fields.E180',\n58                     )\n59                 )\n60         return errors\n61 \n62     def deconstruct(self):\n63         name, path, args, kwargs = super().deconstruct()\n64         if self.encoder is not None:\n65             kwargs['encoder'] = self.encoder\n66         if self.decoder is not None:\n67             kwargs['decoder'] = self.decoder\n68         return name, path, args, kwargs\n69 \n70     def from_db_value(self, value, expression, connection):\n71         if value is None:\n72             return value\n73         try:\n74             return json.loads(value, cls=self.decoder)\n75         except json.JSONDecodeError:\n76             return value\n77 \n78     def get_internal_type(self):\n79         return 'JSONField'\n80 \n81     def get_prep_value(self, value):\n82         if value is None:\n83             return value\n84         return json.dumps(value, cls=self.encoder)\n85 \n86     def get_transform(self, name):\n87         transform = super().get_transform(name)\n88         if transform:\n89             return transform\n90         return KeyTransformFactory(name)\n91 \n92     def validate(self, value, model_instance):\n93         super().validate(value, model_instance)\n94         try:\n95             json.dumps(value, cls=self.encoder)\n96         except TypeError:\n97             raise exceptions.ValidationError(\n98                 self.error_messages['invalid'],\n99                 code='invalid',\n100                 params={'value': value},\n101             )\n102 \n103     def value_to_string(self, obj):\n104         return self.value_from_object(obj)\n105 \n106     def formfield(self, **kwargs):\n107         return super().formfield(**{\n108             'form_class': forms.JSONField,\n109             'encoder': self.encoder,\n110             'decoder': self.decoder,\n111             **kwargs,\n112         })\n113 \n114 \n115 def compile_json_path(key_transforms, include_root=True):\n116     path = ['$'] if include_root else []\n117     for key_transform in key_transforms:\n118         try:\n119             num = int(key_transform)\n120         except ValueError:  # non-integer\n121             path.append('.')\n122             path.append(json.dumps(key_transform))\n123         else:\n124             path.append('[%s]' % num)\n125     return ''.join(path)\n126 \n127 \n128 class DataContains(PostgresOperatorLookup):\n129     lookup_name = 'contains'\n130     postgres_operator = '@>'\n131 \n132     def as_sql(self, compiler, connection):\n133         if not connection.features.supports_json_field_contains:\n134             raise NotSupportedError(\n135                 'contains lookup is not supported on this database backend.'\n136             )\n137         lhs, lhs_params = self.process_lhs(compiler, connection)\n138         rhs, rhs_params = self.process_rhs(compiler, connection)\n139         params = tuple(lhs_params) + tuple(rhs_params)\n140         return 'JSON_CONTAINS(%s, %s)' % (lhs, rhs), params\n141 \n142 \n143 class ContainedBy(PostgresOperatorLookup):\n144     lookup_name = 'contained_by'\n145     postgres_operator = '<@'\n146 \n147     def as_sql(self, compiler, connection):\n148         if not connection.features.supports_json_field_contains:\n149             raise NotSupportedError(\n150                 'contained_by lookup is not supported on this database backend.'\n151             )\n152         lhs, lhs_params = self.process_lhs(compiler, connection)\n153         rhs, rhs_params = self.process_rhs(compiler, connection)\n154         params = tuple(rhs_params) + tuple(lhs_params)\n155         return 'JSON_CONTAINS(%s, %s)' % (rhs, lhs), params\n156 \n157 \n158 class HasKeyLookup(PostgresOperatorLookup):\n159     logical_operator = None\n160 \n161     def as_sql(self, compiler, connection, template=None):\n162         # Process JSON path from the left-hand side.\n163         if isinstance(self.lhs, KeyTransform):\n164             lhs, lhs_params, lhs_key_transforms = self.lhs.preprocess_lhs(compiler, connection)\n165             lhs_json_path = compile_json_path(lhs_key_transforms)\n166         else:\n167             lhs, lhs_params = self.process_lhs(compiler, connection)\n168             lhs_json_path = '$'\n169         sql = template % lhs\n170         # Process JSON path from the right-hand side.\n171         rhs = self.rhs\n172         rhs_params = []\n173         if not isinstance(rhs, (list, tuple)):\n174             rhs = [rhs]\n175         for key in rhs:\n176             if isinstance(key, KeyTransform):\n177                 *_, rhs_key_transforms = key.preprocess_lhs(compiler, connection)\n178             else:\n179                 rhs_key_transforms = [key]\n180             rhs_params.append('%s%s' % (\n181                 lhs_json_path,\n182                 compile_json_path(rhs_key_transforms, include_root=False),\n183             ))\n184         # Add condition for each key.\n185         if self.logical_operator:\n186             sql = '(%s)' % self.logical_operator.join([sql] * len(rhs_params))\n187         return sql, tuple(lhs_params) + tuple(rhs_params)\n188 \n189     def as_mysql(self, compiler, connection):\n190         return self.as_sql(compiler, connection, template=\"JSON_CONTAINS_PATH(%s, 'one', %%s)\")\n191 \n192     def as_oracle(self, compiler, connection):\n193         sql, params = self.as_sql(compiler, connection, template=\"JSON_EXISTS(%s, '%%s')\")\n194         # Add paths directly into SQL because path expressions cannot be passed\n195         # as bind variables on Oracle.\n196         return sql % tuple(params), []\n197 \n198     def as_postgresql(self, compiler, connection):\n199         if isinstance(self.rhs, KeyTransform):\n200             *_, rhs_key_transforms = self.rhs.preprocess_lhs(compiler, connection)\n201             for key in rhs_key_transforms[:-1]:\n202                 self.lhs = KeyTransform(key, self.lhs)\n203             self.rhs = rhs_key_transforms[-1]\n204         return super().as_postgresql(compiler, connection)\n205 \n206     def as_sqlite(self, compiler, connection):\n207         return self.as_sql(compiler, connection, template='JSON_TYPE(%s, %%s) IS NOT NULL')\n208 \n209 \n210 class HasKey(HasKeyLookup):\n211     lookup_name = 'has_key'\n212     postgres_operator = '?'\n213     prepare_rhs = False\n214 \n215 \n216 class HasKeys(HasKeyLookup):\n217     lookup_name = 'has_keys'\n218     postgres_operator = '?&'\n219     logical_operator = ' AND '\n220 \n221     def get_prep_lookup(self):\n222         return [str(item) for item in self.rhs]\n223 \n224 \n225 class HasAnyKeys(HasKeys):\n226     lookup_name = 'has_any_keys'\n227     postgres_operator = '?|'\n228     logical_operator = ' OR '\n229 \n230 \n231 class JSONExact(lookups.Exact):\n232     can_use_none_as_rhs = True\n233 \n234     def process_lhs(self, compiler, connection):\n235         lhs, lhs_params = super().process_lhs(compiler, connection)\n236         if connection.vendor == 'sqlite':\n237             rhs, rhs_params = super().process_rhs(compiler, connection)\n238             if rhs == '%s' and rhs_params == [None]:\n239                 # Use JSON_TYPE instead of JSON_EXTRACT for NULLs.\n240                 lhs = \"JSON_TYPE(%s, '$')\" % lhs\n241         return lhs, lhs_params\n242 \n243     def process_rhs(self, compiler, connection):\n244         rhs, rhs_params = super().process_rhs(compiler, connection)\n245         # Treat None lookup values as null.\n246         if rhs == '%s' and rhs_params == [None]:\n247             rhs_params = ['null']\n248         if connection.vendor == 'mysql':\n249             func = [\"JSON_EXTRACT(%s, '$')\"] * len(rhs_params)\n250             rhs = rhs % tuple(func)\n251         return rhs, rhs_params\n252 \n253 \n254 JSONField.register_lookup(DataContains)\n255 JSONField.register_lookup(ContainedBy)\n256 JSONField.register_lookup(HasKey)\n257 JSONField.register_lookup(HasKeys)\n258 JSONField.register_lookup(HasAnyKeys)\n259 JSONField.register_lookup(JSONExact)\n260 \n261 \n262 class KeyTransform(Transform):\n263     postgres_operator = '->'\n264     postgres_nested_operator = '#>'\n265 \n266     def __init__(self, key_name, *args, **kwargs):\n267         super().__init__(*args, **kwargs)\n268         self.key_name = str(key_name)\n269 \n270     def preprocess_lhs(self, compiler, connection, lhs_only=False):\n271         if not lhs_only:\n272             key_transforms = [self.key_name]\n273         previous = self.lhs\n274         while isinstance(previous, KeyTransform):\n275             if not lhs_only:\n276                 key_transforms.insert(0, previous.key_name)\n277             previous = previous.lhs\n278         lhs, params = compiler.compile(previous)\n279         if connection.vendor == 'oracle':\n280             # Escape string-formatting.\n281             key_transforms = [key.replace('%', '%%') for key in key_transforms]\n282         return (lhs, params, key_transforms) if not lhs_only else (lhs, params)\n283 \n284     def as_mysql(self, compiler, connection):\n285         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n286         json_path = compile_json_path(key_transforms)\n287         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n288 \n289     def as_oracle(self, compiler, connection):\n290         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n291         json_path = compile_json_path(key_transforms)\n292         return (\n293             \"COALESCE(JSON_QUERY(%s, '%s'), JSON_VALUE(%s, '%s'))\" %\n294             ((lhs, json_path) * 2)\n295         ), tuple(params) * 2\n296 \n297     def as_postgresql(self, compiler, connection):\n298         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n299         if len(key_transforms) > 1:\n300             return '(%s %s %%s)' % (lhs, self.postgres_nested_operator), params + [key_transforms]\n301         try:\n302             lookup = int(self.key_name)\n303         except ValueError:\n304             lookup = self.key_name\n305         return '(%s %s %%s)' % (lhs, self.postgres_operator), tuple(params) + (lookup,)\n306 \n307     def as_sqlite(self, compiler, connection):\n308         lhs, params, key_transforms = self.preprocess_lhs(compiler, connection)\n309         json_path = compile_json_path(key_transforms)\n310         return 'JSON_EXTRACT(%s, %%s)' % lhs, tuple(params) + (json_path,)\n311 \n312 \n313 class KeyTextTransform(KeyTransform):\n314     postgres_operator = '->>'\n315     postgres_nested_operator = '#>>'\n316 \n317 \n318 class KeyTransformTextLookupMixin:\n319     \"\"\"\n320     Mixin for combining with a lookup expecting a text lhs from a JSONField\n321     key lookup. On PostgreSQL, make use of the ->> operator instead of casting\n322     key values to text and performing the lookup on the resulting\n323     representation.\n324     \"\"\"\n325     def __init__(self, key_transform, *args, **kwargs):\n326         if not isinstance(key_transform, KeyTransform):\n327             raise TypeError(\n328                 'Transform should be an instance of KeyTransform in order to '\n329                 'use this lookup.'\n330             )\n331         key_text_transform = KeyTextTransform(\n332             key_transform.key_name, *key_transform.source_expressions,\n333             **key_transform.extra,\n334         )\n335         super().__init__(key_text_transform, *args, **kwargs)\n336 \n337 \n338 class CaseInsensitiveMixin:\n339     \"\"\"\n340     Mixin to allow case-insensitive comparison of JSON values on MySQL.\n341     MySQL handles strings used in JSON context using the utf8mb4_bin collation.\n342     Because utf8mb4_bin is a binary collation, comparison of JSON values is\n343     case-sensitive.\n344     \"\"\"\n345     def process_lhs(self, compiler, connection):\n346         lhs, lhs_params = super().process_lhs(compiler, connection)\n347         if connection.vendor == 'mysql':\n348             return 'LOWER(%s)' % lhs, lhs_params\n349         return lhs, lhs_params\n350 \n351     def process_rhs(self, compiler, connection):\n352         rhs, rhs_params = super().process_rhs(compiler, connection)\n353         if connection.vendor == 'mysql':\n354             return 'LOWER(%s)' % rhs, rhs_params\n355         return rhs, rhs_params\n356 \n357 \n358 class KeyTransformIsNull(lookups.IsNull):\n359     # key__isnull=False is the same as has_key='key'\n360     def as_oracle(self, compiler, connection):\n361         if not self.rhs:\n362             return HasKey(self.lhs.lhs, self.lhs.key_name).as_oracle(compiler, connection)\n363         return super().as_sql(compiler, connection)\n364 \n365     def as_sqlite(self, compiler, connection):\n366         if not self.rhs:\n367             return HasKey(self.lhs.lhs, self.lhs.key_name).as_sqlite(compiler, connection)\n368         return super().as_sql(compiler, connection)\n369 \n370 \n371 class KeyTransformIn(lookups.In):\n372     def process_rhs(self, compiler, connection):\n373         rhs, rhs_params = super().process_rhs(compiler, connection)\n374         if not connection.features.has_native_json_field:\n375             func = ()\n376             if connection.vendor == 'oracle':\n377                 func = []\n378                 for value in rhs_params:\n379                     value = json.loads(value)\n380                     function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'\n381                     func.append(\"%s('%s', '$.value')\" % (\n382                         function,\n383                         json.dumps({'value': value}),\n384                     ))\n385                 func = tuple(func)\n386                 rhs_params = ()\n387             elif connection.vendor == 'mysql' and connection.mysql_is_mariadb:\n388                 func = (\"JSON_UNQUOTE(JSON_EXTRACT(%s, '$'))\",) * len(rhs_params)\n389             elif connection.vendor in {'sqlite', 'mysql'}:\n390                 func = (\"JSON_EXTRACT(%s, '$')\",) * len(rhs_params)\n391             rhs = rhs % func\n392         return rhs, rhs_params\n393 \n394 \n395 class KeyTransformExact(JSONExact):\n396     def process_lhs(self, compiler, connection):\n397         lhs, lhs_params = super().process_lhs(compiler, connection)\n398         if connection.vendor == 'sqlite':\n399             rhs, rhs_params = super().process_rhs(compiler, connection)\n400             if rhs == '%s' and rhs_params == ['null']:\n401                 lhs, _ = self.lhs.preprocess_lhs(compiler, connection, lhs_only=True)\n402                 lhs = 'JSON_TYPE(%s, %%s)' % lhs\n403         return lhs, lhs_params\n404 \n405     def process_rhs(self, compiler, connection):\n406         if isinstance(self.rhs, KeyTransform):\n407             return super(lookups.Exact, self).process_rhs(compiler, connection)\n408         rhs, rhs_params = super().process_rhs(compiler, connection)\n409         if connection.vendor == 'oracle':\n410             func = []\n411             for value in rhs_params:\n412                 value = json.loads(value)\n413                 function = 'JSON_QUERY' if isinstance(value, (list, dict)) else 'JSON_VALUE'\n414                 func.append(\"%s('%s', '$.value')\" % (\n415                     function,\n416                     json.dumps({'value': value}),\n417                 ))\n418             rhs = rhs % tuple(func)\n419             rhs_params = []\n420         elif connection.vendor == 'sqlite':\n421             func = [\"JSON_EXTRACT(%s, '$')\" if value != 'null' else '%s' for value in rhs_params]\n422             rhs = rhs % tuple(func)\n423         return rhs, rhs_params\n424 \n425     def as_oracle(self, compiler, connection):\n426         rhs, rhs_params = super().process_rhs(compiler, connection)\n427         if rhs_params == ['null']:\n428             # Field has key and it's NULL.\n429             has_key_expr = HasKey(self.lhs.lhs, self.lhs.key_name)\n430             has_key_sql, has_key_params = has_key_expr.as_oracle(compiler, connection)\n431             is_null_expr = self.lhs.get_lookup('isnull')(self.lhs, True)\n432             is_null_sql, is_null_params = is_null_expr.as_sql(compiler, connection)\n433             return (\n434                 '%s AND %s' % (has_key_sql, is_null_sql),\n435                 tuple(has_key_params) + tuple(is_null_params),\n436             )\n437         return super().as_sql(compiler, connection)\n438 \n439 \n440 class KeyTransformIExact(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact):\n441     pass\n442 \n443 \n444 class KeyTransformIContains(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IContains):\n445     pass\n446 \n447 \n448 class KeyTransformStartsWith(KeyTransformTextLookupMixin, lookups.StartsWith):\n449     pass\n450 \n451 \n452 class KeyTransformIStartsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IStartsWith):\n453     pass\n454 \n455 \n456 class KeyTransformEndsWith(KeyTransformTextLookupMixin, lookups.EndsWith):\n457     pass\n458 \n459 \n460 class KeyTransformIEndsWith(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IEndsWith):\n461     pass\n462 \n463 \n464 class KeyTransformRegex(KeyTransformTextLookupMixin, lookups.Regex):\n465     pass\n466 \n467 \n468 class KeyTransformIRegex(CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IRegex):\n469     pass\n470 \n471 \n472 class KeyTransformNumericLookupMixin:\n473     def process_rhs(self, compiler, connection):\n474         rhs, rhs_params = super().process_rhs(compiler, connection)\n475         if not connection.features.has_native_json_field:\n476             rhs_params = [json.loads(value) for value in rhs_params]\n477         return rhs, rhs_params\n478 \n479 \n480 class KeyTransformLt(KeyTransformNumericLookupMixin, lookups.LessThan):\n481     pass\n482 \n483 \n484 class KeyTransformLte(KeyTransformNumericLookupMixin, lookups.LessThanOrEqual):\n485     pass\n486 \n487 \n488 class KeyTransformGt(KeyTransformNumericLookupMixin, lookups.GreaterThan):\n489     pass\n490 \n491 \n492 class KeyTransformGte(KeyTransformNumericLookupMixin, lookups.GreaterThanOrEqual):\n493     pass\n494 \n495 \n496 KeyTransform.register_lookup(KeyTransformIn)\n497 KeyTransform.register_lookup(KeyTransformExact)\n498 KeyTransform.register_lookup(KeyTransformIExact)\n499 KeyTransform.register_lookup(KeyTransformIsNull)\n500 KeyTransform.register_lookup(KeyTransformIContains)\n501 KeyTransform.register_lookup(KeyTransformStartsWith)\n502 KeyTransform.register_lookup(KeyTransformIStartsWith)\n503 KeyTransform.register_lookup(KeyTransformEndsWith)\n504 KeyTransform.register_lookup(KeyTransformIEndsWith)\n505 KeyTransform.register_lookup(KeyTransformRegex)\n506 KeyTransform.register_lookup(KeyTransformIRegex)\n507 \n508 KeyTransform.register_lookup(KeyTransformLt)\n509 KeyTransform.register_lookup(KeyTransformLte)\n510 KeyTransform.register_lookup(KeyTransformGt)\n511 KeyTransform.register_lookup(KeyTransformGte)\n512 \n513 \n514 class KeyTransformFactory:\n515 \n516     def __init__(self, key_name):\n517         self.key_name = key_name\n518 \n519     def __call__(self, *args, **kwargs):\n520         return KeyTransform(self.key_name, *args, **kwargs)\n",
        "intended_behavior": "Modify the serialization logic to ensure `json.dumps` is called with the `ensure_ascii=False` option when serializing JSON data for `JSONField`. This will allow Unicode characters to be displayed properly in the Django admin by default, instead of being escaped as ASCII sequences. This change should preserve the field's existing functionality in all contexts, including form submissions, database storage, and admin display."
    },
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/contrib/admin/options.py",
        "start": 1,
        "end": 2203,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 import json\n3 import operator\n4 import re\n5 from functools import partial, reduce, update_wrapper\n6 from urllib.parse import quote as urlquote\n7 \n8 from django import forms\n9 from django.conf import settings\n10 from django.contrib import messages\n11 from django.contrib.admin import helpers, widgets\n12 from django.contrib.admin.checks import (\n13     BaseModelAdminChecks, InlineModelAdminChecks, ModelAdminChecks,\n14 )\n15 from django.contrib.admin.exceptions import DisallowedModelAdminToField\n16 from django.contrib.admin.templatetags.admin_urls import add_preserved_filters\n17 from django.contrib.admin.utils import (\n18     NestedObjects, construct_change_message, flatten_fieldsets,\n19     get_deleted_objects, lookup_needs_distinct, model_format_dict,\n20     model_ngettext, quote, unquote,\n21 )\n22 from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n23 from django.contrib.admin.widgets import (\n24     AutocompleteSelect, AutocompleteSelectMultiple,\n25 )\n26 from django.contrib.auth import get_permission_codename\n27 from django.core.exceptions import (\n28     FieldDoesNotExist, FieldError, PermissionDenied, ValidationError,\n29 )\n30 from django.core.paginator import Paginator\n31 from django.db import models, router, transaction\n32 from django.db.models.constants import LOOKUP_SEP\n33 from django.forms.formsets import DELETION_FIELD_NAME, all_valid\n34 from django.forms.models import (\n35     BaseInlineFormSet, inlineformset_factory, modelform_defines_fields,\n36     modelform_factory, modelformset_factory,\n37 )\n38 from django.forms.widgets import CheckboxSelectMultiple, SelectMultiple\n39 from django.http import HttpResponseRedirect\n40 from django.http.response import HttpResponseBase\n41 from django.template.response import SimpleTemplateResponse, TemplateResponse\n42 from django.urls import reverse\n43 from django.utils.decorators import method_decorator\n44 from django.utils.html import format_html\n45 from django.utils.http import urlencode\n46 from django.utils.safestring import mark_safe\n47 from django.utils.text import (\n48     capfirst, format_lazy, get_text_list, smart_split, unescape_string_literal,\n49 )\n50 from django.utils.translation import gettext as _, ngettext\n51 from django.views.decorators.csrf import csrf_protect\n52 from django.views.generic import RedirectView\n53 \n54 IS_POPUP_VAR = '_popup'\n55 TO_FIELD_VAR = '_to_field'\n56 \n57 \n58 HORIZONTAL, VERTICAL = 1, 2\n59 \n60 \n61 def get_content_type_for_model(obj):\n62     # Since this module gets imported in the application's root package,\n63     # it cannot import models from other applications at the module level.\n64     from django.contrib.contenttypes.models import ContentType\n65     return ContentType.objects.get_for_model(obj, for_concrete_model=False)\n66 \n67 \n68 def get_ul_class(radio_style):\n69     return 'radiolist' if radio_style == VERTICAL else 'radiolist inline'\n70 \n71 \n72 class IncorrectLookupParameters(Exception):\n73     pass\n74 \n75 \n76 # Defaults for formfield_overrides. ModelAdmin subclasses can change this\n77 # by adding to ModelAdmin.formfield_overrides.\n78 \n79 FORMFIELD_FOR_DBFIELD_DEFAULTS = {\n80     models.DateTimeField: {\n81         'form_class': forms.SplitDateTimeField,\n82         'widget': widgets.AdminSplitDateTime\n83     },\n84     models.DateField: {'widget': widgets.AdminDateWidget},\n85     models.TimeField: {'widget': widgets.AdminTimeWidget},\n86     models.TextField: {'widget': widgets.AdminTextareaWidget},\n87     models.URLField: {'widget': widgets.AdminURLFieldWidget},\n88     models.IntegerField: {'widget': widgets.AdminIntegerFieldWidget},\n89     models.BigIntegerField: {'widget': widgets.AdminBigIntegerFieldWidget},\n90     models.CharField: {'widget': widgets.AdminTextInputWidget},\n91     models.ImageField: {'widget': widgets.AdminFileWidget},\n92     models.FileField: {'widget': widgets.AdminFileWidget},\n93     models.EmailField: {'widget': widgets.AdminEmailInputWidget},\n94     models.UUIDField: {'widget': widgets.AdminUUIDInputWidget},\n95 }\n96 \n97 csrf_protect_m = method_decorator(csrf_protect)\n98 \n99 \n100 class BaseModelAdmin(metaclass=forms.MediaDefiningClass):\n101     \"\"\"Functionality common to both ModelAdmin and InlineAdmin.\"\"\"\n102 \n103     autocomplete_fields = ()\n104     raw_id_fields = ()\n105     fields = None\n106     exclude = None\n107     fieldsets = None\n108     form = forms.ModelForm\n109     filter_vertical = ()\n110     filter_horizontal = ()\n111     radio_fields = {}\n112     prepopulated_fields = {}\n113     formfield_overrides = {}\n114     readonly_fields = ()\n115     ordering = None\n116     sortable_by = None\n117     view_on_site = True\n118     show_full_result_count = True\n119     checks_class = BaseModelAdminChecks\n120 \n121     def check(self, **kwargs):\n122         return self.checks_class().check(self, **kwargs)\n123 \n124     def __init__(self):\n125         # Merge FORMFIELD_FOR_DBFIELD_DEFAULTS with the formfield_overrides\n126         # rather than simply overwriting.\n127         overrides = copy.deepcopy(FORMFIELD_FOR_DBFIELD_DEFAULTS)\n128         for k, v in self.formfield_overrides.items():\n129             overrides.setdefault(k, {}).update(v)\n130         self.formfield_overrides = overrides\n131 \n132     def formfield_for_dbfield(self, db_field, request, **kwargs):\n133         \"\"\"\n134         Hook for specifying the form Field instance for a given database Field\n135         instance.\n136 \n137         If kwargs are given, they're passed to the form Field's constructor.\n138         \"\"\"\n139         # If the field specifies choices, we don't need to look for special\n140         # admin widgets - we just need to use a select widget of some kind.\n141         if db_field.choices:\n142             return self.formfield_for_choice_field(db_field, request, **kwargs)\n143 \n144         # ForeignKey or ManyToManyFields\n145         if isinstance(db_field, (models.ForeignKey, models.ManyToManyField)):\n146             # Combine the field kwargs with any options for formfield_overrides.\n147             # Make sure the passed in **kwargs override anything in\n148             # formfield_overrides because **kwargs is more specific, and should\n149             # always win.\n150             if db_field.__class__ in self.formfield_overrides:\n151                 kwargs = {**self.formfield_overrides[db_field.__class__], **kwargs}\n152 \n153             # Get the correct formfield.\n154             if isinstance(db_field, models.ForeignKey):\n155                 formfield = self.formfield_for_foreignkey(db_field, request, **kwargs)\n156             elif isinstance(db_field, models.ManyToManyField):\n157                 formfield = self.formfield_for_manytomany(db_field, request, **kwargs)\n158 \n159             # For non-raw_id fields, wrap the widget with a wrapper that adds\n160             # extra HTML -- the \"add other\" interface -- to the end of the\n161             # rendered output. formfield can be None if it came from a\n162             # OneToOneField with parent_link=True or a M2M intermediary.\n163             if formfield and db_field.name not in self.raw_id_fields:\n164                 related_modeladmin = self.admin_site._registry.get(db_field.remote_field.model)\n165                 wrapper_kwargs = {}\n166                 if related_modeladmin:\n167                     wrapper_kwargs.update(\n168                         can_add_related=related_modeladmin.has_add_permission(request),\n169                         can_change_related=related_modeladmin.has_change_permission(request),\n170                         can_delete_related=related_modeladmin.has_delete_permission(request),\n171                         can_view_related=related_modeladmin.has_view_permission(request),\n172                     )\n173                 formfield.widget = widgets.RelatedFieldWidgetWrapper(\n174                     formfield.widget, db_field.remote_field, self.admin_site, **wrapper_kwargs\n175                 )\n176 \n177             return formfield\n178 \n179         # If we've got overrides for the formfield defined, use 'em. **kwargs\n180         # passed to formfield_for_dbfield override the defaults.\n181         for klass in db_field.__class__.mro():\n182             if klass in self.formfield_overrides:\n183                 kwargs = {**copy.deepcopy(self.formfield_overrides[klass]), **kwargs}\n184                 return db_field.formfield(**kwargs)\n185 \n186         # For any other type of field, just call its formfield() method.\n187         return db_field.formfield(**kwargs)\n188 \n189     def formfield_for_choice_field(self, db_field, request, **kwargs):\n190         \"\"\"\n191         Get a form Field for a database Field that has declared choices.\n192         \"\"\"\n193         # If the field is named as a radio_field, use a RadioSelect\n194         if db_field.name in self.radio_fields:\n195             # Avoid stomping on custom widget/choices arguments.\n196             if 'widget' not in kwargs:\n197                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n198                     'class': get_ul_class(self.radio_fields[db_field.name]),\n199                 })\n200             if 'choices' not in kwargs:\n201                 kwargs['choices'] = db_field.get_choices(\n202                     include_blank=db_field.blank,\n203                     blank_choice=[('', _('None'))]\n204                 )\n205         return db_field.formfield(**kwargs)\n206 \n207     def get_field_queryset(self, db, db_field, request):\n208         \"\"\"\n209         If the ModelAdmin specifies ordering, the queryset should respect that\n210         ordering.  Otherwise don't specify the queryset, let the field decide\n211         (return None in that case).\n212         \"\"\"\n213         related_admin = self.admin_site._registry.get(db_field.remote_field.model)\n214         if related_admin is not None:\n215             ordering = related_admin.get_ordering(request)\n216             if ordering is not None and ordering != ():\n217                 return db_field.remote_field.model._default_manager.using(db).order_by(*ordering)\n218         return None\n219 \n220     def formfield_for_foreignkey(self, db_field, request, **kwargs):\n221         \"\"\"\n222         Get a form Field for a ForeignKey.\n223         \"\"\"\n224         db = kwargs.get('using')\n225 \n226         if 'widget' not in kwargs:\n227             if db_field.name in self.get_autocomplete_fields(request):\n228                 kwargs['widget'] = AutocompleteSelect(db_field.remote_field, self.admin_site, using=db)\n229             elif db_field.name in self.raw_id_fields:\n230                 kwargs['widget'] = widgets.ForeignKeyRawIdWidget(db_field.remote_field, self.admin_site, using=db)\n231             elif db_field.name in self.radio_fields:\n232                 kwargs['widget'] = widgets.AdminRadioSelect(attrs={\n233                     'class': get_ul_class(self.radio_fields[db_field.name]),\n234                 })\n235                 kwargs['empty_label'] = _('None') if db_field.blank else None\n236 \n237         if 'queryset' not in kwargs:\n238             queryset = self.get_field_queryset(db, db_field, request)\n239             if queryset is not None:\n240                 kwargs['queryset'] = queryset\n241 \n242         return db_field.formfield(**kwargs)\n243 \n244     def formfield_for_manytomany(self, db_field, request, **kwargs):\n245         \"\"\"\n246         Get a form Field for a ManyToManyField.\n247         \"\"\"\n248         # If it uses an intermediary model that isn't auto created, don't show\n249         # a field in admin.\n250         if not db_field.remote_field.through._meta.auto_created:\n251             return None\n252         db = kwargs.get('using')\n253 \n254         if 'widget' not in kwargs:\n255             autocomplete_fields = self.get_autocomplete_fields(request)\n256             if db_field.name in autocomplete_fields:\n257                 kwargs['widget'] = AutocompleteSelectMultiple(\n258                     db_field.remote_field,\n259                     self.admin_site,\n260                     using=db,\n261                 )\n262             elif db_field.name in self.raw_id_fields:\n263                 kwargs['widget'] = widgets.ManyToManyRawIdWidget(\n264                     db_field.remote_field,\n265                     self.admin_site,\n266                     using=db,\n267                 )\n268             elif db_field.name in [*self.filter_vertical, *self.filter_horizontal]:\n269                 kwargs['widget'] = widgets.FilteredSelectMultiple(\n270                     db_field.verbose_name,\n271                     db_field.name in self.filter_vertical\n272                 )\n273         if 'queryset' not in kwargs:\n274             queryset = self.get_field_queryset(db, db_field, request)\n275             if queryset is not None:\n276                 kwargs['queryset'] = queryset\n277 \n278         form_field = db_field.formfield(**kwargs)\n279         if (isinstance(form_field.widget, SelectMultiple) and\n280                 not isinstance(form_field.widget, (CheckboxSelectMultiple, AutocompleteSelectMultiple))):\n281             msg = _('Hold down \u201cControl\u201d, or \u201cCommand\u201d on a Mac, to select more than one.')\n282             help_text = form_field.help_text\n283             form_field.help_text = format_lazy('{} {}', help_text, msg) if help_text else msg\n284         return form_field\n285 \n286     def get_autocomplete_fields(self, request):\n287         \"\"\"\n288         Return a list of ForeignKey and/or ManyToMany fields which should use\n289         an autocomplete widget.\n290         \"\"\"\n291         return self.autocomplete_fields\n292 \n293     def get_view_on_site_url(self, obj=None):\n294         if obj is None or not self.view_on_site:\n295             return None\n296 \n297         if callable(self.view_on_site):\n298             return self.view_on_site(obj)\n299         elif self.view_on_site and hasattr(obj, 'get_absolute_url'):\n300             # use the ContentType lookup if view_on_site is True\n301             return reverse('admin:view_on_site', kwargs={\n302                 'content_type_id': get_content_type_for_model(obj).pk,\n303                 'object_id': obj.pk\n304             })\n305 \n306     def get_empty_value_display(self):\n307         \"\"\"\n308         Return the empty_value_display set on ModelAdmin or AdminSite.\n309         \"\"\"\n310         try:\n311             return mark_safe(self.empty_value_display)\n312         except AttributeError:\n313             return mark_safe(self.admin_site.empty_value_display)\n314 \n315     def get_exclude(self, request, obj=None):\n316         \"\"\"\n317         Hook for specifying exclude.\n318         \"\"\"\n319         return self.exclude\n320 \n321     def get_fields(self, request, obj=None):\n322         \"\"\"\n323         Hook for specifying fields.\n324         \"\"\"\n325         if self.fields:\n326             return self.fields\n327         # _get_form_for_get_fields() is implemented in subclasses.\n328         form = self._get_form_for_get_fields(request, obj)\n329         return [*form.base_fields, *self.get_readonly_fields(request, obj)]\n330 \n331     def get_fieldsets(self, request, obj=None):\n332         \"\"\"\n333         Hook for specifying fieldsets.\n334         \"\"\"\n335         if self.fieldsets:\n336             return self.fieldsets\n337         return [(None, {'fields': self.get_fields(request, obj)})]\n338 \n339     def get_inlines(self, request, obj):\n340         \"\"\"Hook for specifying custom inlines.\"\"\"\n341         return self.inlines\n342 \n343     def get_ordering(self, request):\n344         \"\"\"\n345         Hook for specifying field ordering.\n346         \"\"\"\n347         return self.ordering or ()  # otherwise we might try to *None, which is bad ;)\n348 \n349     def get_readonly_fields(self, request, obj=None):\n350         \"\"\"\n351         Hook for specifying custom readonly fields.\n352         \"\"\"\n353         return self.readonly_fields\n354 \n355     def get_prepopulated_fields(self, request, obj=None):\n356         \"\"\"\n357         Hook for specifying custom prepopulated fields.\n358         \"\"\"\n359         return self.prepopulated_fields\n360 \n361     def get_queryset(self, request):\n362         \"\"\"\n363         Return a QuerySet of all model instances that can be edited by the\n364         admin site. This is used by changelist_view.\n365         \"\"\"\n366         qs = self.model._default_manager.get_queryset()\n367         # TODO: this should be handled by some parameter to the ChangeList.\n368         ordering = self.get_ordering(request)\n369         if ordering:\n370             qs = qs.order_by(*ordering)\n371         return qs\n372 \n373     def get_sortable_by(self, request):\n374         \"\"\"Hook for specifying which fields can be sorted in the changelist.\"\"\"\n375         return self.sortable_by if self.sortable_by is not None else self.get_list_display(request)\n376 \n377     def lookup_allowed(self, lookup, value):\n378         from django.contrib.admin.filters import SimpleListFilter\n379 \n380         model = self.model\n381         # Check FKey lookups that are allowed, so that popups produced by\n382         # ForeignKeyRawIdWidget, on the basis of ForeignKey.limit_choices_to,\n383         # are allowed to work.\n384         for fk_lookup in model._meta.related_fkey_lookups:\n385             # As ``limit_choices_to`` can be a callable, invoke it here.\n386             if callable(fk_lookup):\n387                 fk_lookup = fk_lookup()\n388             if (lookup, value) in widgets.url_params_from_lookup_dict(fk_lookup).items():\n389                 return True\n390 \n391         relation_parts = []\n392         prev_field = None\n393         for part in lookup.split(LOOKUP_SEP):\n394             try:\n395                 field = model._meta.get_field(part)\n396             except FieldDoesNotExist:\n397                 # Lookups on nonexistent fields are ok, since they're ignored\n398                 # later.\n399                 break\n400             # It is allowed to filter on values that would be found from local\n401             # model anyways. For example, if you filter on employee__department__id,\n402             # then the id value would be found already from employee__department_id.\n403             if not prev_field or (prev_field.is_relation and\n404                                   field not in prev_field.get_path_info()[-1].target_fields):\n405                 relation_parts.append(part)\n406             if not getattr(field, 'get_path_info', None):\n407                 # This is not a relational field, so further parts\n408                 # must be transforms.\n409                 break\n410             prev_field = field\n411             model = field.get_path_info()[-1].to_opts.model\n412 \n413         if len(relation_parts) <= 1:\n414             # Either a local field filter, or no fields at all.\n415             return True\n416         valid_lookups = {self.date_hierarchy}\n417         for filter_item in self.list_filter:\n418             if isinstance(filter_item, type) and issubclass(filter_item, SimpleListFilter):\n419                 valid_lookups.add(filter_item.parameter_name)\n420             elif isinstance(filter_item, (list, tuple)):\n421                 valid_lookups.add(filter_item[0])\n422             else:\n423                 valid_lookups.add(filter_item)\n424 \n425         # Is it a valid relational lookup?\n426         return not {\n427             LOOKUP_SEP.join(relation_parts),\n428             LOOKUP_SEP.join(relation_parts + [part])\n429         }.isdisjoint(valid_lookups)\n430 \n431     def to_field_allowed(self, request, to_field):\n432         \"\"\"\n433         Return True if the model associated with this admin should be\n434         allowed to be referenced by the specified field.\n435         \"\"\"\n436         opts = self.model._meta\n437 \n438         try:\n439             field = opts.get_field(to_field)\n440         except FieldDoesNotExist:\n441             return False\n442 \n443         # Always allow referencing the primary key since it's already possible\n444         # to get this information from the change view URL.\n445         if field.primary_key:\n446             return True\n447 \n448         # Allow reverse relationships to models defining m2m fields if they\n449         # target the specified field.\n450         for many_to_many in opts.many_to_many:\n451             if many_to_many.m2m_target_field_name() == to_field:\n452                 return True\n453 \n454         # Make sure at least one of the models registered for this site\n455         # references this field through a FK or a M2M relationship.\n456         registered_models = set()\n457         for model, admin in self.admin_site._registry.items():\n458             registered_models.add(model)\n459             for inline in admin.inlines:\n460                 registered_models.add(inline.model)\n461 \n462         related_objects = (\n463             f for f in opts.get_fields(include_hidden=True)\n464             if (f.auto_created and not f.concrete)\n465         )\n466         for related_object in related_objects:\n467             related_model = related_object.related_model\n468             remote_field = related_object.field.remote_field\n469             if (any(issubclass(model, related_model) for model in registered_models) and\n470                     hasattr(remote_field, 'get_related_field') and\n471                     remote_field.get_related_field() == field):\n472                 return True\n473 \n474         return False\n475 \n476     def has_add_permission(self, request):\n477         \"\"\"\n478         Return True if the given request has permission to add an object.\n479         Can be overridden by the user in subclasses.\n480         \"\"\"\n481         opts = self.opts\n482         codename = get_permission_codename('add', opts)\n483         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n484 \n485     def has_change_permission(self, request, obj=None):\n486         \"\"\"\n487         Return True if the given request has permission to change the given\n488         Django model instance, the default implementation doesn't examine the\n489         `obj` parameter.\n490 \n491         Can be overridden by the user in subclasses. In such case it should\n492         return True if the given request has permission to change the `obj`\n493         model instance. If `obj` is None, this should return True if the given\n494         request has permission to change *any* object of the given type.\n495         \"\"\"\n496         opts = self.opts\n497         codename = get_permission_codename('change', opts)\n498         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n499 \n500     def has_delete_permission(self, request, obj=None):\n501         \"\"\"\n502         Return True if the given request has permission to change the given\n503         Django model instance, the default implementation doesn't examine the\n504         `obj` parameter.\n505 \n506         Can be overridden by the user in subclasses. In such case it should\n507         return True if the given request has permission to delete the `obj`\n508         model instance. If `obj` is None, this should return True if the given\n509         request has permission to delete *any* object of the given type.\n510         \"\"\"\n511         opts = self.opts\n512         codename = get_permission_codename('delete', opts)\n513         return request.user.has_perm(\"%s.%s\" % (opts.app_label, codename))\n514 \n515     def has_view_permission(self, request, obj=None):\n516         \"\"\"\n517         Return True if the given request has permission to view the given\n518         Django model instance. The default implementation doesn't examine the\n519         `obj` parameter.\n520 \n521         If overridden by the user in subclasses, it should return True if the\n522         given request has permission to view the `obj` model instance. If `obj`\n523         is None, it should return True if the request has permission to view\n524         any object of the given type.\n525         \"\"\"\n526         opts = self.opts\n527         codename_view = get_permission_codename('view', opts)\n528         codename_change = get_permission_codename('change', opts)\n529         return (\n530             request.user.has_perm('%s.%s' % (opts.app_label, codename_view)) or\n531             request.user.has_perm('%s.%s' % (opts.app_label, codename_change))\n532         )\n533 \n534     def has_view_or_change_permission(self, request, obj=None):\n535         return self.has_view_permission(request, obj) or self.has_change_permission(request, obj)\n536 \n537     def has_module_permission(self, request):\n538         \"\"\"\n539         Return True if the given request has any permission in the given\n540         app label.\n541 \n542         Can be overridden by the user in subclasses. In such case it should\n543         return True if the given request has permission to view the module on\n544         the admin index page and access the module's index page. Overriding it\n545         does not restrict access to the add, change or delete views. Use\n546         `ModelAdmin.has_(add|change|delete)_permission` for that.\n547         \"\"\"\n548         return request.user.has_module_perms(self.opts.app_label)\n549 \n550 \n551 class ModelAdmin(BaseModelAdmin):\n552     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n553 \n554     list_display = ('__str__',)\n555     list_display_links = ()\n556     list_filter = ()\n557     list_select_related = False\n558     list_per_page = 100\n559     list_max_show_all = 200\n560     list_editable = ()\n561     search_fields = ()\n562     date_hierarchy = None\n563     save_as = False\n564     save_as_continue = True\n565     save_on_top = False\n566     paginator = Paginator\n567     preserve_filters = True\n568     inlines = []\n569 \n570     # Custom templates (designed to be over-ridden in subclasses)\n571     add_form_template = None\n572     change_form_template = None\n573     change_list_template = None\n574     delete_confirmation_template = None\n575     delete_selected_confirmation_template = None\n576     object_history_template = None\n577     popup_response_template = None\n578 \n579     # Actions\n580     actions = []\n581     action_form = helpers.ActionForm\n582     actions_on_top = True\n583     actions_on_bottom = False\n584     actions_selection_counter = True\n585     checks_class = ModelAdminChecks\n586 \n587     def __init__(self, model, admin_site):\n588         self.model = model\n589         self.opts = model._meta\n590         self.admin_site = admin_site\n591         super().__init__()\n592 \n593     def __str__(self):\n594         return \"%s.%s\" % (self.model._meta.app_label, self.__class__.__name__)\n595 \n596     def get_inline_instances(self, request, obj=None):\n597         inline_instances = []\n598         for inline_class in self.get_inlines(request, obj):\n599             inline = inline_class(self.model, self.admin_site)\n600             if request:\n601                 if not (inline.has_view_or_change_permission(request, obj) or\n602                         inline.has_add_permission(request, obj) or\n603                         inline.has_delete_permission(request, obj)):\n604                     continue\n605                 if not inline.has_add_permission(request, obj):\n606                     inline.max_num = 0\n607             inline_instances.append(inline)\n608 \n609         return inline_instances\n610 \n611     def get_urls(self):\n612         from django.urls import path\n613 \n614         def wrap(view):\n615             def wrapper(*args, **kwargs):\n616                 return self.admin_site.admin_view(view)(*args, **kwargs)\n617             wrapper.model_admin = self\n618             return update_wrapper(wrapper, view)\n619 \n620         info = self.model._meta.app_label, self.model._meta.model_name\n621 \n622         return [\n623             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),\n624             path('add/', wrap(self.add_view), name='%s_%s_add' % info),\n625             path('autocomplete/', wrap(self.autocomplete_view), name='%s_%s_autocomplete' % info),\n626             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),\n627             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),\n628             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),\n629             # For backwards compatibility (was the change url before 1.9)\n630             path('<path:object_id>/', wrap(RedirectView.as_view(\n631                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)\n632             ))),\n633         ]\n634 \n635     @property\n636     def urls(self):\n637         return self.get_urls()\n638 \n639     @property\n640     def media(self):\n641         extra = '' if settings.DEBUG else '.min'\n642         js = [\n643             'vendor/jquery/jquery%s.js' % extra,\n644             'jquery.init.js',\n645             'core.js',\n646             'admin/RelatedObjectLookups.js',\n647             'actions.js',\n648             'urlify.js',\n649             'prepopulate.js',\n650             'vendor/xregexp/xregexp%s.js' % extra,\n651         ]\n652         return forms.Media(js=['admin/js/%s' % url for url in js])\n653 \n654     def get_model_perms(self, request):\n655         \"\"\"\n656         Return a dict of all perms for this model. This dict has the keys\n657         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n658         for each of those actions.\n659         \"\"\"\n660         return {\n661             'add': self.has_add_permission(request),\n662             'change': self.has_change_permission(request),\n663             'delete': self.has_delete_permission(request),\n664             'view': self.has_view_permission(request),\n665         }\n666 \n667     def _get_form_for_get_fields(self, request, obj):\n668         return self.get_form(request, obj, fields=None)\n669 \n670     def get_form(self, request, obj=None, change=False, **kwargs):\n671         \"\"\"\n672         Return a Form class for use in the admin add view. This is used by\n673         add_view and change_view.\n674         \"\"\"\n675         if 'fields' in kwargs:\n676             fields = kwargs.pop('fields')\n677         else:\n678             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n679         excluded = self.get_exclude(request, obj)\n680         exclude = [] if excluded is None else list(excluded)\n681         readonly_fields = self.get_readonly_fields(request, obj)\n682         exclude.extend(readonly_fields)\n683         # Exclude all fields if it's a change form and the user doesn't have\n684         # the change permission.\n685         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):\n686             exclude.extend(fields)\n687         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n688             # Take the custom ModelForm's Meta.exclude into account only if the\n689             # ModelAdmin doesn't define its own.\n690             exclude.extend(self.form._meta.exclude)\n691         # if exclude is an empty list we pass None to be consistent with the\n692         # default on modelform_factory\n693         exclude = exclude or None\n694 \n695         # Remove declared form fields which are in readonly_fields.\n696         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)\n697         form = type(self.form.__name__, (self.form,), new_attrs)\n698 \n699         defaults = {\n700             'form': form,\n701             'fields': fields,\n702             'exclude': exclude,\n703             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n704             **kwargs,\n705         }\n706 \n707         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n708             defaults['fields'] = forms.ALL_FIELDS\n709 \n710         try:\n711             return modelform_factory(self.model, **defaults)\n712         except FieldError as e:\n713             raise FieldError(\n714                 '%s. Check fields/fieldsets/exclude attributes of class %s.'\n715                 % (e, self.__class__.__name__)\n716             )\n717 \n718     def get_changelist(self, request, **kwargs):\n719         \"\"\"\n720         Return the ChangeList class for use on the changelist page.\n721         \"\"\"\n722         from django.contrib.admin.views.main import ChangeList\n723         return ChangeList\n724 \n725     def get_changelist_instance(self, request):\n726         \"\"\"\n727         Return a `ChangeList` instance based on `request`. May raise\n728         `IncorrectLookupParameters`.\n729         \"\"\"\n730         list_display = self.get_list_display(request)\n731         list_display_links = self.get_list_display_links(request, list_display)\n732         # Add the action checkboxes if any actions are available.\n733         if self.get_actions(request):\n734             list_display = ['action_checkbox', *list_display]\n735         sortable_by = self.get_sortable_by(request)\n736         ChangeList = self.get_changelist(request)\n737         return ChangeList(\n738             request,\n739             self.model,\n740             list_display,\n741             list_display_links,\n742             self.get_list_filter(request),\n743             self.date_hierarchy,\n744             self.get_search_fields(request),\n745             self.get_list_select_related(request),\n746             self.list_per_page,\n747             self.list_max_show_all,\n748             self.list_editable,\n749             self,\n750             sortable_by,\n751         )\n752 \n753     def get_object(self, request, object_id, from_field=None):\n754         \"\"\"\n755         Return an instance matching the field and value provided, the primary\n756         key is used if no field is provided. Return ``None`` if no match is\n757         found or the object_id fails validation.\n758         \"\"\"\n759         queryset = self.get_queryset(request)\n760         model = queryset.model\n761         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)\n762         try:\n763             object_id = field.to_python(object_id)\n764             return queryset.get(**{field.name: object_id})\n765         except (model.DoesNotExist, ValidationError, ValueError):\n766             return None\n767 \n768     def get_changelist_form(self, request, **kwargs):\n769         \"\"\"\n770         Return a Form class for use in the Formset on the changelist page.\n771         \"\"\"\n772         defaults = {\n773             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n774             **kwargs,\n775         }\n776         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):\n777             defaults['fields'] = forms.ALL_FIELDS\n778 \n779         return modelform_factory(self.model, **defaults)\n780 \n781     def get_changelist_formset(self, request, **kwargs):\n782         \"\"\"\n783         Return a FormSet class for use on the changelist page if list_editable\n784         is used.\n785         \"\"\"\n786         defaults = {\n787             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n788             **kwargs,\n789         }\n790         return modelformset_factory(\n791             self.model, self.get_changelist_form(request), extra=0,\n792             fields=self.list_editable, **defaults\n793         )\n794 \n795     def get_formsets_with_inlines(self, request, obj=None):\n796         \"\"\"\n797         Yield formsets and the corresponding inlines.\n798         \"\"\"\n799         for inline in self.get_inline_instances(request, obj):\n800             yield inline.get_formset(request, obj), inline\n801 \n802     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):\n803         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n804 \n805     def log_addition(self, request, object, message):\n806         \"\"\"\n807         Log that an object has been successfully added.\n808 \n809         The default implementation creates an admin LogEntry object.\n810         \"\"\"\n811         from django.contrib.admin.models import ADDITION, LogEntry\n812         return LogEntry.objects.log_action(\n813             user_id=request.user.pk,\n814             content_type_id=get_content_type_for_model(object).pk,\n815             object_id=object.pk,\n816             object_repr=str(object),\n817             action_flag=ADDITION,\n818             change_message=message,\n819         )\n820 \n821     def log_change(self, request, object, message):\n822         \"\"\"\n823         Log that an object has been successfully changed.\n824 \n825         The default implementation creates an admin LogEntry object.\n826         \"\"\"\n827         from django.contrib.admin.models import CHANGE, LogEntry\n828         return LogEntry.objects.log_action(\n829             user_id=request.user.pk,\n830             content_type_id=get_content_type_for_model(object).pk,\n831             object_id=object.pk,\n832             object_repr=str(object),\n833             action_flag=CHANGE,\n834             change_message=message,\n835         )\n836 \n837     def log_deletion(self, request, object, object_repr):\n838         \"\"\"\n839         Log that an object will be deleted. Note that this method must be\n840         called before the deletion.\n841 \n842         The default implementation creates an admin LogEntry object.\n843         \"\"\"\n844         from django.contrib.admin.models import DELETION, LogEntry\n845         return LogEntry.objects.log_action(\n846             user_id=request.user.pk,\n847             content_type_id=get_content_type_for_model(object).pk,\n848             object_id=object.pk,\n849             object_repr=object_repr,\n850             action_flag=DELETION,\n851         )\n852 \n853     def action_checkbox(self, obj):\n854         \"\"\"\n855         A list_display column containing a checkbox widget.\n856         \"\"\"\n857         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n858     action_checkbox.short_description = mark_safe('<input type=\"checkbox\" id=\"action-toggle\">')\n859 \n860     def _get_base_actions(self):\n861         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n862         actions = []\n863         base_actions = (self.get_action(action) for action in self.actions or [])\n864         # get_action might have returned None, so filter any of those out.\n865         base_actions = [action for action in base_actions if action]\n866         base_action_names = {name for _, name, _ in base_actions}\n867 \n868         # Gather actions from the admin site first\n869         for (name, func) in self.admin_site.actions:\n870             if name in base_action_names:\n871                 continue\n872             description = getattr(func, 'short_description', name.replace('_', ' '))\n873             actions.append((func, name, description))\n874         # Add actions from this ModelAdmin.\n875         actions.extend(base_actions)\n876         return actions\n877 \n878     def _filter_actions_by_permissions(self, request, actions):\n879         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n880         filtered_actions = []\n881         for action in actions:\n882             callable = action[0]\n883             if not hasattr(callable, 'allowed_permissions'):\n884                 filtered_actions.append(action)\n885                 continue\n886             permission_checks = (\n887                 getattr(self, 'has_%s_permission' % permission)\n888                 for permission in callable.allowed_permissions\n889             )\n890             if any(has_permission(request) for has_permission in permission_checks):\n891                 filtered_actions.append(action)\n892         return filtered_actions\n893 \n894     def get_actions(self, request):\n895         \"\"\"\n896         Return a dictionary mapping the names of all actions for this\n897         ModelAdmin to a tuple of (callable, name, description) for each action.\n898         \"\"\"\n899         # If self.actions is set to None that means actions are disabled on\n900         # this page.\n901         if self.actions is None or IS_POPUP_VAR in request.GET:\n902             return {}\n903         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n904         return {name: (func, name, desc) for func, name, desc in actions}\n905 \n906     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):\n907         \"\"\"\n908         Return a list of choices for use in a form object.  Each choice is a\n909         tuple (name, description).\n910         \"\"\"\n911         choices = [] + default_choices\n912         for func, name, description in self.get_actions(request).values():\n913             choice = (name, description % model_format_dict(self.opts))\n914             choices.append(choice)\n915         return choices\n916 \n917     def get_action(self, action):\n918         \"\"\"\n919         Return a given action from a parameter, which can either be a callable,\n920         or the name of a method on the ModelAdmin.  Return is a tuple of\n921         (callable, name, description).\n922         \"\"\"\n923         # If the action is a callable, just use it.\n924         if callable(action):\n925             func = action\n926             action = action.__name__\n927 \n928         # Next, look for a method. Grab it off self.__class__ to get an unbound\n929         # method instead of a bound one; this ensures that the calling\n930         # conventions are the same for functions and methods.\n931         elif hasattr(self.__class__, action):\n932             func = getattr(self.__class__, action)\n933 \n934         # Finally, look for a named method on the admin site\n935         else:\n936             try:\n937                 func = self.admin_site.get_action(action)\n938             except KeyError:\n939                 return None\n940 \n941         if hasattr(func, 'short_description'):\n942             description = func.short_description\n943         else:\n944             description = capfirst(action.replace('_', ' '))\n945         return func, action, description\n946 \n947     def get_list_display(self, request):\n948         \"\"\"\n949         Return a sequence containing the fields to be displayed on the\n950         changelist.\n951         \"\"\"\n952         return self.list_display\n953 \n954     def get_list_display_links(self, request, list_display):\n955         \"\"\"\n956         Return a sequence containing the fields to be displayed as links\n957         on the changelist. The list_display parameter is the list of fields\n958         returned by get_list_display().\n959         \"\"\"\n960         if self.list_display_links or self.list_display_links is None or not list_display:\n961             return self.list_display_links\n962         else:\n963             # Use only the first item in list_display as link\n964             return list(list_display)[:1]\n965 \n966     def get_list_filter(self, request):\n967         \"\"\"\n968         Return a sequence containing the fields to be displayed as filters in\n969         the right sidebar of the changelist page.\n970         \"\"\"\n971         return self.list_filter\n972 \n973     def get_list_select_related(self, request):\n974         \"\"\"\n975         Return a list of fields to add to the select_related() part of the\n976         changelist items query.\n977         \"\"\"\n978         return self.list_select_related\n979 \n980     def get_search_fields(self, request):\n981         \"\"\"\n982         Return a sequence containing the fields to be searched whenever\n983         somebody submits a search query.\n984         \"\"\"\n985         return self.search_fields\n986 \n987     def get_search_results(self, request, queryset, search_term):\n988         \"\"\"\n989         Return a tuple containing a queryset to implement the search\n990         and a boolean indicating if the results may contain duplicates.\n991         \"\"\"\n992         # Apply keyword searches.\n993         def construct_search(field_name):\n994             if field_name.startswith('^'):\n995                 return \"%s__istartswith\" % field_name[1:]\n996             elif field_name.startswith('='):\n997                 return \"%s__iexact\" % field_name[1:]\n998             elif field_name.startswith('@'):\n999                 return \"%s__search\" % field_name[1:]\n1000             # Use field_name if it includes a lookup.\n1001             opts = queryset.model._meta\n1002             lookup_fields = field_name.split(LOOKUP_SEP)\n1003             # Go through the fields, following all relations.\n1004             prev_field = None\n1005             for path_part in lookup_fields:\n1006                 if path_part == 'pk':\n1007                     path_part = opts.pk.name\n1008                 try:\n1009                     field = opts.get_field(path_part)\n1010                 except FieldDoesNotExist:\n1011                     # Use valid query lookups.\n1012                     if prev_field and prev_field.get_lookup(path_part):\n1013                         return field_name\n1014                 else:\n1015                     prev_field = field\n1016                     if hasattr(field, 'get_path_info'):\n1017                         # Update opts to follow the relation.\n1018                         opts = field.get_path_info()[-1].to_opts\n1019             # Otherwise, use the field with icontains.\n1020             return \"%s__icontains\" % field_name\n1021 \n1022         use_distinct = False\n1023         search_fields = self.get_search_fields(request)\n1024         if search_fields and search_term:\n1025             orm_lookups = [construct_search(str(search_field))\n1026                            for search_field in search_fields]\n1027             for bit in smart_split(search_term):\n1028                 if bit.startswith(('\"', \"'\")):\n1029                     bit = unescape_string_literal(bit)\n1030                 or_queries = [models.Q(**{orm_lookup: bit})\n1031                               for orm_lookup in orm_lookups]\n1032                 queryset = queryset.filter(reduce(operator.or_, or_queries))\n1033             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)\n1034 \n1035         return queryset, use_distinct\n1036 \n1037     def get_preserved_filters(self, request):\n1038         \"\"\"\n1039         Return the preserved filters querystring.\n1040         \"\"\"\n1041         match = request.resolver_match\n1042         if self.preserve_filters and match:\n1043             opts = self.model._meta\n1044             current_url = '%s:%s' % (match.app_name, match.url_name)\n1045             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)\n1046             if current_url == changelist_url:\n1047                 preserved_filters = request.GET.urlencode()\n1048             else:\n1049                 preserved_filters = request.GET.get('_changelist_filters')\n1050 \n1051             if preserved_filters:\n1052                 return urlencode({'_changelist_filters': preserved_filters})\n1053         return ''\n1054 \n1055     def construct_change_message(self, request, form, formsets, add=False):\n1056         \"\"\"\n1057         Construct a JSON structure describing changes from a changed object.\n1058         \"\"\"\n1059         return construct_change_message(form, formsets, add)\n1060 \n1061     def message_user(self, request, message, level=messages.INFO, extra_tags='',\n1062                      fail_silently=False):\n1063         \"\"\"\n1064         Send a message to the user. The default implementation\n1065         posts a message using the django.contrib.messages backend.\n1066 \n1067         Exposes almost the same API as messages.add_message(), but accepts the\n1068         positional arguments in a different order to maintain backwards\n1069         compatibility. For convenience, it accepts the `level` argument as\n1070         a string rather than the usual level number.\n1071         \"\"\"\n1072         if not isinstance(level, int):\n1073             # attempt to get the level if passed a string\n1074             try:\n1075                 level = getattr(messages.constants, level.upper())\n1076             except AttributeError:\n1077                 levels = messages.constants.DEFAULT_TAGS.values()\n1078                 levels_repr = ', '.join('`%s`' % level for level in levels)\n1079                 raise ValueError(\n1080                     'Bad message level string: `%s`. Possible values are: %s'\n1081                     % (level, levels_repr)\n1082                 )\n1083 \n1084         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)\n1085 \n1086     def save_form(self, request, form, change):\n1087         \"\"\"\n1088         Given a ModelForm return an unsaved instance. ``change`` is True if\n1089         the object is being changed, and False if it's being added.\n1090         \"\"\"\n1091         return form.save(commit=False)\n1092 \n1093     def save_model(self, request, obj, form, change):\n1094         \"\"\"\n1095         Given a model instance save it to the database.\n1096         \"\"\"\n1097         obj.save()\n1098 \n1099     def delete_model(self, request, obj):\n1100         \"\"\"\n1101         Given a model instance delete it from the database.\n1102         \"\"\"\n1103         obj.delete()\n1104 \n1105     def delete_queryset(self, request, queryset):\n1106         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1107         queryset.delete()\n1108 \n1109     def save_formset(self, request, form, formset, change):\n1110         \"\"\"\n1111         Given an inline formset save it to the database.\n1112         \"\"\"\n1113         formset.save()\n1114 \n1115     def save_related(self, request, form, formsets, change):\n1116         \"\"\"\n1117         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the\n1118         list of inline formsets and a boolean value based on whether the\n1119         parent is being added or changed, save the related objects to the\n1120         database. Note that at this point save_form() and save_model() have\n1121         already been called.\n1122         \"\"\"\n1123         form.save_m2m()\n1124         for formset in formsets:\n1125             self.save_formset(request, form, formset, change=change)\n1126 \n1127     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):\n1128         opts = self.model._meta\n1129         app_label = opts.app_label\n1130         preserved_filters = self.get_preserved_filters(request)\n1131         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)\n1132         view_on_site_url = self.get_view_on_site_url(obj)\n1133         has_editable_inline_admin_formsets = False\n1134         for inline in context['inline_admin_formsets']:\n1135             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:\n1136                 has_editable_inline_admin_formsets = True\n1137                 break\n1138         context.update({\n1139             'add': add,\n1140             'change': change,\n1141             'has_view_permission': self.has_view_permission(request, obj),\n1142             'has_add_permission': self.has_add_permission(request),\n1143             'has_change_permission': self.has_change_permission(request, obj),\n1144             'has_delete_permission': self.has_delete_permission(request, obj),\n1145             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,\n1146             'has_file_field': context['adminform'].form.is_multipart() or any(\n1147                 admin_formset.formset.is_multipart()\n1148                 for admin_formset in context['inline_admin_formsets']\n1149             ),\n1150             'has_absolute_url': view_on_site_url is not None,\n1151             'absolute_url': view_on_site_url,\n1152             'form_url': form_url,\n1153             'opts': opts,\n1154             'content_type_id': get_content_type_for_model(self.model).pk,\n1155             'save_as': self.save_as,\n1156             'save_on_top': self.save_on_top,\n1157             'to_field_var': TO_FIELD_VAR,\n1158             'is_popup_var': IS_POPUP_VAR,\n1159             'app_label': app_label,\n1160         })\n1161         if add and self.add_form_template is not None:\n1162             form_template = self.add_form_template\n1163         else:\n1164             form_template = self.change_form_template\n1165 \n1166         request.current_app = self.admin_site.name\n1167 \n1168         return TemplateResponse(request, form_template or [\n1169             \"admin/%s/%s/change_form.html\" % (app_label, opts.model_name),\n1170             \"admin/%s/change_form.html\" % app_label,\n1171             \"admin/change_form.html\"\n1172         ], context)\n1173 \n1174     def response_add(self, request, obj, post_url_continue=None):\n1175         \"\"\"\n1176         Determine the HttpResponse for the add_view stage.\n1177         \"\"\"\n1178         opts = obj._meta\n1179         preserved_filters = self.get_preserved_filters(request)\n1180         obj_url = reverse(\n1181             'admin:%s_%s_change' % (opts.app_label, opts.model_name),\n1182             args=(quote(obj.pk),),\n1183             current_app=self.admin_site.name,\n1184         )\n1185         # Add a link to the object's change form if the user can edit the obj.\n1186         if self.has_change_permission(request, obj):\n1187             obj_repr = format_html('<a href=\"{}\">{}</a>', urlquote(obj_url), obj)\n1188         else:\n1189             obj_repr = str(obj)\n1190         msg_dict = {\n1191             'name': opts.verbose_name,\n1192             'obj': obj_repr,\n1193         }\n1194         # Here, we distinguish between different save types by checking for\n1195         # the presence of keys in request.POST.\n1196 \n1197         if IS_POPUP_VAR in request.POST:\n1198             to_field = request.POST.get(TO_FIELD_VAR)\n1199             if to_field:\n1200                 attr = str(to_field)\n1201             else:\n1202                 attr = obj._meta.pk.attname\n1203             value = obj.serializable_value(attr)\n1204             popup_response_data = json.dumps({\n1205                 'value': str(value),\n1206                 'obj': str(obj),\n1207             })\n1208             return TemplateResponse(request, self.popup_response_template or [\n1209                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1210                 'admin/%s/popup_response.html' % opts.app_label,\n1211                 'admin/popup_response.html',\n1212             ], {\n1213                 'popup_response_data': popup_response_data,\n1214             })\n1215 \n1216         elif \"_continue\" in request.POST or (\n1217                 # Redirecting after \"Save as new\".\n1218                 \"_saveasnew\" in request.POST and self.save_as_continue and\n1219                 self.has_change_permission(request, obj)\n1220         ):\n1221             msg = _('The {name} \u201c{obj}\u201d was added successfully.')\n1222             if self.has_change_permission(request, obj):\n1223                 msg += ' ' + _('You may edit it again below.')\n1224             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)\n1225             if post_url_continue is None:\n1226                 post_url_continue = obj_url\n1227             post_url_continue = add_preserved_filters(\n1228                 {'preserved_filters': preserved_filters, 'opts': opts},\n1229                 post_url_continue\n1230             )\n1231             return HttpResponseRedirect(post_url_continue)\n1232 \n1233         elif \"_addanother\" in request.POST:\n1234             msg = format_html(\n1235                 _('The {name} \u201c{obj}\u201d was added successfully. You may add another {name} below.'),\n1236                 **msg_dict\n1237             )\n1238             self.message_user(request, msg, messages.SUCCESS)\n1239             redirect_url = request.path\n1240             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1241             return HttpResponseRedirect(redirect_url)\n1242 \n1243         else:\n1244             msg = format_html(\n1245                 _('The {name} \u201c{obj}\u201d was added successfully.'),\n1246                 **msg_dict\n1247             )\n1248             self.message_user(request, msg, messages.SUCCESS)\n1249             return self.response_post_save_add(request, obj)\n1250 \n1251     def response_change(self, request, obj):\n1252         \"\"\"\n1253         Determine the HttpResponse for the change_view stage.\n1254         \"\"\"\n1255 \n1256         if IS_POPUP_VAR in request.POST:\n1257             opts = obj._meta\n1258             to_field = request.POST.get(TO_FIELD_VAR)\n1259             attr = str(to_field) if to_field else opts.pk.attname\n1260             value = request.resolver_match.kwargs['object_id']\n1261             new_value = obj.serializable_value(attr)\n1262             popup_response_data = json.dumps({\n1263                 'action': 'change',\n1264                 'value': str(value),\n1265                 'obj': str(obj),\n1266                 'new_value': str(new_value),\n1267             })\n1268             return TemplateResponse(request, self.popup_response_template or [\n1269                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1270                 'admin/%s/popup_response.html' % opts.app_label,\n1271                 'admin/popup_response.html',\n1272             ], {\n1273                 'popup_response_data': popup_response_data,\n1274             })\n1275 \n1276         opts = self.model._meta\n1277         preserved_filters = self.get_preserved_filters(request)\n1278 \n1279         msg_dict = {\n1280             'name': opts.verbose_name,\n1281             'obj': format_html('<a href=\"{}\">{}</a>', urlquote(request.path), obj),\n1282         }\n1283         if \"_continue\" in request.POST:\n1284             msg = format_html(\n1285                 _('The {name} \u201c{obj}\u201d was changed successfully. You may edit it again below.'),\n1286                 **msg_dict\n1287             )\n1288             self.message_user(request, msg, messages.SUCCESS)\n1289             redirect_url = request.path\n1290             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1291             return HttpResponseRedirect(redirect_url)\n1292 \n1293         elif \"_saveasnew\" in request.POST:\n1294             msg = format_html(\n1295                 _('The {name} \u201c{obj}\u201d was added successfully. You may edit it again below.'),\n1296                 **msg_dict\n1297             )\n1298             self.message_user(request, msg, messages.SUCCESS)\n1299             redirect_url = reverse('admin:%s_%s_change' %\n1300                                    (opts.app_label, opts.model_name),\n1301                                    args=(obj.pk,),\n1302                                    current_app=self.admin_site.name)\n1303             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1304             return HttpResponseRedirect(redirect_url)\n1305 \n1306         elif \"_addanother\" in request.POST:\n1307             msg = format_html(\n1308                 _('The {name} \u201c{obj}\u201d was changed successfully. You may add another {name} below.'),\n1309                 **msg_dict\n1310             )\n1311             self.message_user(request, msg, messages.SUCCESS)\n1312             redirect_url = reverse('admin:%s_%s_add' %\n1313                                    (opts.app_label, opts.model_name),\n1314                                    current_app=self.admin_site.name)\n1315             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)\n1316             return HttpResponseRedirect(redirect_url)\n1317 \n1318         else:\n1319             msg = format_html(\n1320                 _('The {name} \u201c{obj}\u201d was changed successfully.'),\n1321                 **msg_dict\n1322             )\n1323             self.message_user(request, msg, messages.SUCCESS)\n1324             return self.response_post_save_change(request, obj)\n1325 \n1326     def _response_post_save(self, request, obj):\n1327         opts = self.model._meta\n1328         if self.has_view_or_change_permission(request):\n1329             post_url = reverse('admin:%s_%s_changelist' %\n1330                                (opts.app_label, opts.model_name),\n1331                                current_app=self.admin_site.name)\n1332             preserved_filters = self.get_preserved_filters(request)\n1333             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)\n1334         else:\n1335             post_url = reverse('admin:index',\n1336                                current_app=self.admin_site.name)\n1337         return HttpResponseRedirect(post_url)\n1338 \n1339     def response_post_save_add(self, request, obj):\n1340         \"\"\"\n1341         Figure out where to redirect after the 'Save' button has been pressed\n1342         when adding a new object.\n1343         \"\"\"\n1344         return self._response_post_save(request, obj)\n1345 \n1346     def response_post_save_change(self, request, obj):\n1347         \"\"\"\n1348         Figure out where to redirect after the 'Save' button has been pressed\n1349         when editing an existing object.\n1350         \"\"\"\n1351         return self._response_post_save(request, obj)\n1352 \n1353     def response_action(self, request, queryset):\n1354         \"\"\"\n1355         Handle an admin action. This is called if a request is POSTed to the\n1356         changelist; it returns an HttpResponse if the action was handled, and\n1357         None otherwise.\n1358         \"\"\"\n1359 \n1360         # There can be multiple action forms on the page (at the top\n1361         # and bottom of the change list, for example). Get the action\n1362         # whose button was pushed.\n1363         try:\n1364             action_index = int(request.POST.get('index', 0))\n1365         except ValueError:\n1366             action_index = 0\n1367 \n1368         # Construct the action form.\n1369         data = request.POST.copy()\n1370         data.pop(helpers.ACTION_CHECKBOX_NAME, None)\n1371         data.pop(\"index\", None)\n1372 \n1373         # Use the action whose button was pushed\n1374         try:\n1375             data.update({'action': data.getlist('action')[action_index]})\n1376         except IndexError:\n1377             # If we didn't get an action from the chosen form that's invalid\n1378             # POST data, so by deleting action it'll fail the validation check\n1379             # below. So no need to do anything here\n1380             pass\n1381 \n1382         action_form = self.action_form(data, auto_id=None)\n1383         action_form.fields['action'].choices = self.get_action_choices(request)\n1384 \n1385         # If the form's valid we can handle the action.\n1386         if action_form.is_valid():\n1387             action = action_form.cleaned_data['action']\n1388             select_across = action_form.cleaned_data['select_across']\n1389             func = self.get_actions(request)[action][0]\n1390 \n1391             # Get the list of selected PKs. If nothing's selected, we can't\n1392             # perform an action on it, so bail. Except we want to perform\n1393             # the action explicitly on all objects.\n1394             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1395             if not selected and not select_across:\n1396                 # Reminder that something needs to be selected or nothing will happen\n1397                 msg = _(\"Items must be selected in order to perform \"\n1398                         \"actions on them. No items have been changed.\")\n1399                 self.message_user(request, msg, messages.WARNING)\n1400                 return None\n1401 \n1402             if not select_across:\n1403                 # Perform the action only on the selected objects\n1404                 queryset = queryset.filter(pk__in=selected)\n1405 \n1406             response = func(self, request, queryset)\n1407 \n1408             # Actions may return an HttpResponse-like object, which will be\n1409             # used as the response from the POST. If not, we'll be a good\n1410             # little HTTP citizen and redirect back to the changelist page.\n1411             if isinstance(response, HttpResponseBase):\n1412                 return response\n1413             else:\n1414                 return HttpResponseRedirect(request.get_full_path())\n1415         else:\n1416             msg = _(\"No action selected.\")\n1417             self.message_user(request, msg, messages.WARNING)\n1418             return None\n1419 \n1420     def response_delete(self, request, obj_display, obj_id):\n1421         \"\"\"\n1422         Determine the HttpResponse for the delete_view stage.\n1423         \"\"\"\n1424         opts = self.model._meta\n1425 \n1426         if IS_POPUP_VAR in request.POST:\n1427             popup_response_data = json.dumps({\n1428                 'action': 'delete',\n1429                 'value': str(obj_id),\n1430             })\n1431             return TemplateResponse(request, self.popup_response_template or [\n1432                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),\n1433                 'admin/%s/popup_response.html' % opts.app_label,\n1434                 'admin/popup_response.html',\n1435             ], {\n1436                 'popup_response_data': popup_response_data,\n1437             })\n1438 \n1439         self.message_user(\n1440             request,\n1441             _('The %(name)s \u201c%(obj)s\u201d was deleted successfully.') % {\n1442                 'name': opts.verbose_name,\n1443                 'obj': obj_display,\n1444             },\n1445             messages.SUCCESS,\n1446         )\n1447 \n1448         if self.has_change_permission(request, None):\n1449             post_url = reverse(\n1450                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),\n1451                 current_app=self.admin_site.name,\n1452             )\n1453             preserved_filters = self.get_preserved_filters(request)\n1454             post_url = add_preserved_filters(\n1455                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url\n1456             )\n1457         else:\n1458             post_url = reverse('admin:index', current_app=self.admin_site.name)\n1459         return HttpResponseRedirect(post_url)\n1460 \n1461     def render_delete_form(self, request, context):\n1462         opts = self.model._meta\n1463         app_label = opts.app_label\n1464 \n1465         request.current_app = self.admin_site.name\n1466         context.update(\n1467             to_field_var=TO_FIELD_VAR,\n1468             is_popup_var=IS_POPUP_VAR,\n1469             media=self.media,\n1470         )\n1471 \n1472         return TemplateResponse(\n1473             request,\n1474             self.delete_confirmation_template or [\n1475                 \"admin/{}/{}/delete_confirmation.html\".format(app_label, opts.model_name),\n1476                 \"admin/{}/delete_confirmation.html\".format(app_label),\n1477                 \"admin/delete_confirmation.html\",\n1478             ],\n1479             context,\n1480         )\n1481 \n1482     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):\n1483         # Edit permissions on parent model are required for editable inlines.\n1484         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)\n1485         inline_admin_formsets = []\n1486         for inline, formset in zip(inline_instances, formsets):\n1487             fieldsets = list(inline.get_fieldsets(request, obj))\n1488             readonly = list(inline.get_readonly_fields(request, obj))\n1489             if can_edit_parent:\n1490                 has_add_permission = inline.has_add_permission(request, obj)\n1491                 has_change_permission = inline.has_change_permission(request, obj)\n1492                 has_delete_permission = inline.has_delete_permission(request, obj)\n1493             else:\n1494                 # Disable all edit-permissions, and overide formset settings.\n1495                 has_add_permission = has_change_permission = has_delete_permission = False\n1496                 formset.extra = formset.max_num = 0\n1497             has_view_permission = inline.has_view_permission(request, obj)\n1498             prepopulated = dict(inline.get_prepopulated_fields(request, obj))\n1499             inline_admin_formset = helpers.InlineAdminFormSet(\n1500                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,\n1501                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,\n1502                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,\n1503             )\n1504             inline_admin_formsets.append(inline_admin_formset)\n1505         return inline_admin_formsets\n1506 \n1507     def get_changeform_initial_data(self, request):\n1508         \"\"\"\n1509         Get the initial form data from the request's GET params.\n1510         \"\"\"\n1511         initial = dict(request.GET.items())\n1512         for k in initial:\n1513             try:\n1514                 f = self.model._meta.get_field(k)\n1515             except FieldDoesNotExist:\n1516                 continue\n1517             # We have to special-case M2Ms as a list of comma-separated PKs.\n1518             if isinstance(f, models.ManyToManyField):\n1519                 initial[k] = initial[k].split(\",\")\n1520         return initial\n1521 \n1522     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):\n1523         \"\"\"\n1524         Create a message informing the user that the object doesn't exist\n1525         and return a redirect to the admin index page.\n1526         \"\"\"\n1527         msg = _('%(name)s with ID \u201c%(key)s\u201d doesn\u2019t exist. Perhaps it was deleted?') % {\n1528             'name': opts.verbose_name,\n1529             'key': unquote(object_id),\n1530         }\n1531         self.message_user(request, msg, messages.WARNING)\n1532         url = reverse('admin:index', current_app=self.admin_site.name)\n1533         return HttpResponseRedirect(url)\n1534 \n1535     @csrf_protect_m\n1536     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):\n1537         with transaction.atomic(using=router.db_for_write(self.model)):\n1538             return self._changeform_view(request, object_id, form_url, extra_context)\n1539 \n1540     def _changeform_view(self, request, object_id, form_url, extra_context):\n1541         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1542         if to_field and not self.to_field_allowed(request, to_field):\n1543             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1544 \n1545         model = self.model\n1546         opts = model._meta\n1547 \n1548         if request.method == 'POST' and '_saveasnew' in request.POST:\n1549             object_id = None\n1550 \n1551         add = object_id is None\n1552 \n1553         if add:\n1554             if not self.has_add_permission(request):\n1555                 raise PermissionDenied\n1556             obj = None\n1557 \n1558         else:\n1559             obj = self.get_object(request, unquote(object_id), to_field)\n1560 \n1561             if request.method == 'POST':\n1562                 if not self.has_change_permission(request, obj):\n1563                     raise PermissionDenied\n1564             else:\n1565                 if not self.has_view_or_change_permission(request, obj):\n1566                     raise PermissionDenied\n1567 \n1568             if obj is None:\n1569                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1570 \n1571         fieldsets = self.get_fieldsets(request, obj)\n1572         ModelForm = self.get_form(\n1573             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)\n1574         )\n1575         if request.method == 'POST':\n1576             form = ModelForm(request.POST, request.FILES, instance=obj)\n1577             form_validated = form.is_valid()\n1578             if form_validated:\n1579                 new_object = self.save_form(request, form, change=not add)\n1580             else:\n1581                 new_object = form.instance\n1582             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)\n1583             if all_valid(formsets) and form_validated:\n1584                 self.save_model(request, new_object, form, not add)\n1585                 self.save_related(request, form, formsets, not add)\n1586                 change_message = self.construct_change_message(request, form, formsets, add)\n1587                 if add:\n1588                     self.log_addition(request, new_object, change_message)\n1589                     return self.response_add(request, new_object)\n1590                 else:\n1591                     self.log_change(request, new_object, change_message)\n1592                     return self.response_change(request, new_object)\n1593             else:\n1594                 form_validated = False\n1595         else:\n1596             if add:\n1597                 initial = self.get_changeform_initial_data(request)\n1598                 form = ModelForm(initial=initial)\n1599                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)\n1600             else:\n1601                 form = ModelForm(instance=obj)\n1602                 formsets, inline_instances = self._create_formsets(request, obj, change=True)\n1603 \n1604         if not add and not self.has_change_permission(request, obj):\n1605             readonly_fields = flatten_fieldsets(fieldsets)\n1606         else:\n1607             readonly_fields = self.get_readonly_fields(request, obj)\n1608         adminForm = helpers.AdminForm(\n1609             form,\n1610             list(fieldsets),\n1611             # Clear prepopulated fields on a view-only form to avoid a crash.\n1612             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},\n1613             readonly_fields,\n1614             model_admin=self)\n1615         media = self.media + adminForm.media\n1616 \n1617         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)\n1618         for inline_formset in inline_formsets:\n1619             media = media + inline_formset.media\n1620 \n1621         if add:\n1622             title = _('Add %s')\n1623         elif self.has_change_permission(request, obj):\n1624             title = _('Change %s')\n1625         else:\n1626             title = _('View %s')\n1627         context = {\n1628             **self.admin_site.each_context(request),\n1629             'title': title % opts.verbose_name,\n1630             'subtitle': str(obj) if obj else None,\n1631             'adminform': adminForm,\n1632             'object_id': object_id,\n1633             'original': obj,\n1634             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1635             'to_field': to_field,\n1636             'media': media,\n1637             'inline_admin_formsets': inline_formsets,\n1638             'errors': helpers.AdminErrorList(form, formsets),\n1639             'preserved_filters': self.get_preserved_filters(request),\n1640         }\n1641 \n1642         # Hide the \"Save\" and \"Save and continue\" buttons if \"Save as New\" was\n1643         # previously chosen to prevent the interface from getting confusing.\n1644         if request.method == 'POST' and not form_validated and \"_saveasnew\" in request.POST:\n1645             context['show_save'] = False\n1646             context['show_save_and_continue'] = False\n1647             # Use the change template instead of the add template.\n1648             add = False\n1649 \n1650         context.update(extra_context or {})\n1651 \n1652         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)\n1653 \n1654     def autocomplete_view(self, request):\n1655         return AutocompleteJsonView.as_view(model_admin=self)(request)\n1656 \n1657     def add_view(self, request, form_url='', extra_context=None):\n1658         return self.changeform_view(request, None, form_url, extra_context)\n1659 \n1660     def change_view(self, request, object_id, form_url='', extra_context=None):\n1661         return self.changeform_view(request, object_id, form_url, extra_context)\n1662 \n1663     def _get_edited_object_pks(self, request, prefix):\n1664         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n1665         pk_pattern = re.compile(\n1666             r'{}-\\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)\n1667         )\n1668         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n1669 \n1670     def _get_list_editable_queryset(self, request, prefix):\n1671         \"\"\"\n1672         Based on POST data, return a queryset of the objects that were edited\n1673         via list_editable.\n1674         \"\"\"\n1675         object_pks = self._get_edited_object_pks(request, prefix)\n1676         queryset = self.get_queryset(request)\n1677         validate = queryset.model._meta.pk.to_python\n1678         try:\n1679             for pk in object_pks:\n1680                 validate(pk)\n1681         except ValidationError:\n1682             # Disable the optimization if the POST data was tampered with.\n1683             return queryset\n1684         return queryset.filter(pk__in=object_pks)\n1685 \n1686     @csrf_protect_m\n1687     def changelist_view(self, request, extra_context=None):\n1688         \"\"\"\n1689         The 'change list' admin view for this model.\n1690         \"\"\"\n1691         from django.contrib.admin.views.main import ERROR_FLAG\n1692         opts = self.model._meta\n1693         app_label = opts.app_label\n1694         if not self.has_view_or_change_permission(request):\n1695             raise PermissionDenied\n1696 \n1697         try:\n1698             cl = self.get_changelist_instance(request)\n1699         except IncorrectLookupParameters:\n1700             # Wacky lookup parameters were given, so redirect to the main\n1701             # changelist page, without parameters, and pass an 'invalid=1'\n1702             # parameter via the query string. If wacky parameters were given\n1703             # and the 'invalid=1' parameter was already in the query string,\n1704             # something is screwed up with the database, so display an error\n1705             # page.\n1706             if ERROR_FLAG in request.GET:\n1707                 return SimpleTemplateResponse('admin/invalid_setup.html', {\n1708                     'title': _('Database error'),\n1709                 })\n1710             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')\n1711 \n1712         # If the request was POSTed, this might be a bulk action or a bulk\n1713         # edit. Try to look up an action or confirmation first, but if this\n1714         # isn't an action the POST will fall through to the bulk edit check,\n1715         # below.\n1716         action_failed = False\n1717         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1718 \n1719         actions = self.get_actions(request)\n1720         # Actions with no confirmation\n1721         if (actions and request.method == 'POST' and\n1722                 'index' in request.POST and '_save' not in request.POST):\n1723             if selected:\n1724                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1725                 if response:\n1726                     return response\n1727                 else:\n1728                     action_failed = True\n1729             else:\n1730                 msg = _(\"Items must be selected in order to perform \"\n1731                         \"actions on them. No items have been changed.\")\n1732                 self.message_user(request, msg, messages.WARNING)\n1733                 action_failed = True\n1734 \n1735         # Actions with confirmation\n1736         if (actions and request.method == 'POST' and\n1737                 helpers.ACTION_CHECKBOX_NAME in request.POST and\n1738                 'index' not in request.POST and '_save' not in request.POST):\n1739             if selected:\n1740                 response = self.response_action(request, queryset=cl.get_queryset(request))\n1741                 if response:\n1742                     return response\n1743                 else:\n1744                     action_failed = True\n1745 \n1746         if action_failed:\n1747             # Redirect back to the changelist page to avoid resubmitting the\n1748             # form if the user refreshes the browser or uses the \"No, take\n1749             # me back\" button on the action confirmation page.\n1750             return HttpResponseRedirect(request.get_full_path())\n1751 \n1752         # If we're allowing changelist editing, we need to construct a formset\n1753         # for the changelist given all the fields to be edited. Then we'll\n1754         # use the formset to validate/process POSTed data.\n1755         formset = cl.formset = None\n1756 \n1757         # Handle POSTed bulk-edit data.\n1758         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:\n1759             if not self.has_change_permission(request):\n1760                 raise PermissionDenied\n1761             FormSet = self.get_changelist_formset(request)\n1762             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())\n1763             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)\n1764             if formset.is_valid():\n1765                 changecount = 0\n1766                 for form in formset.forms:\n1767                     if form.has_changed():\n1768                         obj = self.save_form(request, form, change=True)\n1769                         self.save_model(request, obj, form, change=True)\n1770                         self.save_related(request, form, formsets=[], change=True)\n1771                         change_msg = self.construct_change_message(request, form, None)\n1772                         self.log_change(request, obj, change_msg)\n1773                         changecount += 1\n1774 \n1775                 if changecount:\n1776                     msg = ngettext(\n1777                         \"%(count)s %(name)s was changed successfully.\",\n1778                         \"%(count)s %(name)s were changed successfully.\",\n1779                         changecount\n1780                     ) % {\n1781                         'count': changecount,\n1782                         'name': model_ngettext(opts, changecount),\n1783                     }\n1784                     self.message_user(request, msg, messages.SUCCESS)\n1785 \n1786                 return HttpResponseRedirect(request.get_full_path())\n1787 \n1788         # Handle GET -- construct a formset for display.\n1789         elif cl.list_editable and self.has_change_permission(request):\n1790             FormSet = self.get_changelist_formset(request)\n1791             formset = cl.formset = FormSet(queryset=cl.result_list)\n1792 \n1793         # Build the list of media to be used by the formset.\n1794         if formset:\n1795             media = self.media + formset.media\n1796         else:\n1797             media = self.media\n1798 \n1799         # Build the action form and populate it with available actions.\n1800         if actions:\n1801             action_form = self.action_form(auto_id=None)\n1802             action_form.fields['action'].choices = self.get_action_choices(request)\n1803             media += action_form.media\n1804         else:\n1805             action_form = None\n1806 \n1807         selection_note_all = ngettext(\n1808             '%(total_count)s selected',\n1809             'All %(total_count)s selected',\n1810             cl.result_count\n1811         )\n1812 \n1813         context = {\n1814             **self.admin_site.each_context(request),\n1815             'module_name': str(opts.verbose_name_plural),\n1816             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},\n1817             'selection_note_all': selection_note_all % {'total_count': cl.result_count},\n1818             'title': cl.title,\n1819             'subtitle': None,\n1820             'is_popup': cl.is_popup,\n1821             'to_field': cl.to_field,\n1822             'cl': cl,\n1823             'media': media,\n1824             'has_add_permission': self.has_add_permission(request),\n1825             'opts': cl.opts,\n1826             'action_form': action_form,\n1827             'actions_on_top': self.actions_on_top,\n1828             'actions_on_bottom': self.actions_on_bottom,\n1829             'actions_selection_counter': self.actions_selection_counter,\n1830             'preserved_filters': self.get_preserved_filters(request),\n1831             **(extra_context or {}),\n1832         }\n1833 \n1834         request.current_app = self.admin_site.name\n1835 \n1836         return TemplateResponse(request, self.change_list_template or [\n1837             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),\n1838             'admin/%s/change_list.html' % app_label,\n1839             'admin/change_list.html'\n1840         ], context)\n1841 \n1842     def get_deleted_objects(self, objs, request):\n1843         \"\"\"\n1844         Hook for customizing the delete process for the delete view and the\n1845         \"delete selected\" action.\n1846         \"\"\"\n1847         return get_deleted_objects(objs, request, self.admin_site)\n1848 \n1849     @csrf_protect_m\n1850     def delete_view(self, request, object_id, extra_context=None):\n1851         with transaction.atomic(using=router.db_for_write(self.model)):\n1852             return self._delete_view(request, object_id, extra_context)\n1853 \n1854     def _delete_view(self, request, object_id, extra_context):\n1855         \"The 'delete' admin view for this model.\"\n1856         opts = self.model._meta\n1857         app_label = opts.app_label\n1858 \n1859         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1860         if to_field and not self.to_field_allowed(request, to_field):\n1861             raise DisallowedModelAdminToField(\"The field %s cannot be referenced.\" % to_field)\n1862 \n1863         obj = self.get_object(request, unquote(object_id), to_field)\n1864 \n1865         if not self.has_delete_permission(request, obj):\n1866             raise PermissionDenied\n1867 \n1868         if obj is None:\n1869             return self._get_obj_does_not_exist_redirect(request, opts, object_id)\n1870 \n1871         # Populate deleted_objects, a data structure of all related objects that\n1872         # will also be deleted.\n1873         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)\n1874 \n1875         if request.POST and not protected:  # The user has confirmed the deletion.\n1876             if perms_needed:\n1877                 raise PermissionDenied\n1878             obj_display = str(obj)\n1879             attr = str(to_field) if to_field else opts.pk.attname\n1880             obj_id = obj.serializable_value(attr)\n1881             self.log_deletion(request, obj, obj_display)\n1882             self.delete_model(request, obj)\n1883 \n1884             return self.response_delete(request, obj_display, obj_id)\n1885 \n1886         object_name = str(opts.verbose_name)\n1887 \n1888         if perms_needed or protected:\n1889             title = _(\"Cannot delete %(name)s\") % {\"name\": object_name}\n1890         else:\n1891             title = _(\"Are you sure?\")\n1892 \n1893         context = {\n1894             **self.admin_site.each_context(request),\n1895             'title': title,\n1896             'object_name': object_name,\n1897             'object': obj,\n1898             'deleted_objects': deleted_objects,\n1899             'model_count': dict(model_count).items(),\n1900             'perms_lacking': perms_needed,\n1901             'protected': protected,\n1902             'opts': opts,\n1903             'app_label': app_label,\n1904             'preserved_filters': self.get_preserved_filters(request),\n1905             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1906             'to_field': to_field,\n1907             **(extra_context or {}),\n1908         }\n1909 \n1910         return self.render_delete_form(request, context)\n1911 \n1912     def history_view(self, request, object_id, extra_context=None):\n1913         \"The 'history' admin view for this model.\"\n1914         from django.contrib.admin.models import LogEntry\n1915 \n1916         # First check if the user can see this history.\n1917         model = self.model\n1918         obj = self.get_object(request, unquote(object_id))\n1919         if obj is None:\n1920             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)\n1921 \n1922         if not self.has_view_or_change_permission(request, obj):\n1923             raise PermissionDenied\n1924 \n1925         # Then get the history for this object.\n1926         opts = model._meta\n1927         app_label = opts.app_label\n1928         action_list = LogEntry.objects.filter(\n1929             object_id=unquote(object_id),\n1930             content_type=get_content_type_for_model(model)\n1931         ).select_related().order_by('action_time')\n1932 \n1933         context = {\n1934             **self.admin_site.each_context(request),\n1935             'title': _('Change history: %s') % obj,\n1936             'action_list': action_list,\n1937             'module_name': str(capfirst(opts.verbose_name_plural)),\n1938             'object': obj,\n1939             'opts': opts,\n1940             'preserved_filters': self.get_preserved_filters(request),\n1941             **(extra_context or {}),\n1942         }\n1943 \n1944         request.current_app = self.admin_site.name\n1945 \n1946         return TemplateResponse(request, self.object_history_template or [\n1947             \"admin/%s/%s/object_history.html\" % (app_label, opts.model_name),\n1948             \"admin/%s/object_history.html\" % app_label,\n1949             \"admin/object_history.html\"\n1950         ], context)\n1951 \n1952     def _create_formsets(self, request, obj, change):\n1953         \"Helper function to generate formsets for add/change_view.\"\n1954         formsets = []\n1955         inline_instances = []\n1956         prefixes = {}\n1957         get_formsets_args = [request]\n1958         if change:\n1959             get_formsets_args.append(obj)\n1960         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n1961             prefix = FormSet.get_default_prefix()\n1962             prefixes[prefix] = prefixes.get(prefix, 0) + 1\n1963             if prefixes[prefix] != 1 or not prefix:\n1964                 prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n1965             formset_params = {\n1966                 'instance': obj,\n1967                 'prefix': prefix,\n1968                 'queryset': inline.get_queryset(request),\n1969             }\n1970             if request.method == 'POST':\n1971                 formset_params.update({\n1972                     'data': request.POST.copy(),\n1973                     'files': request.FILES,\n1974                     'save_as_new': '_saveasnew' in request.POST\n1975                 })\n1976             formset = FormSet(**formset_params)\n1977 \n1978             def user_deleted_form(request, obj, formset, index):\n1979                 \"\"\"Return whether or not the user deleted the form.\"\"\"\n1980                 return (\n1981                     inline.has_delete_permission(request, obj) and\n1982                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST\n1983                 )\n1984 \n1985             # Bypass validation of each view-only inline form (since the form's\n1986             # data won't be in request.POST), unless the form was deleted.\n1987             if not inline.has_change_permission(request, obj if change else None):\n1988                 for index, form in enumerate(formset.initial_forms):\n1989                     if user_deleted_form(request, obj, formset, index):\n1990                         continue\n1991                     form._errors = {}\n1992                     form.cleaned_data = form.initial\n1993             formsets.append(formset)\n1994             inline_instances.append(inline)\n1995         return formsets, inline_instances\n1996 \n1997 \n1998 class InlineModelAdmin(BaseModelAdmin):\n1999     \"\"\"\n2000     Options for inline editing of ``model`` instances.\n2001 \n2002     Provide ``fk_name`` to specify the attribute name of the ``ForeignKey``\n2003     from ``model`` to its parent. This is required if ``model`` has more than\n2004     one ``ForeignKey`` to its parent.\n2005     \"\"\"\n2006     model = None\n2007     fk_name = None\n2008     formset = BaseInlineFormSet\n2009     extra = 3\n2010     min_num = None\n2011     max_num = None\n2012     template = None\n2013     verbose_name = None\n2014     verbose_name_plural = None\n2015     can_delete = True\n2016     show_change_link = False\n2017     checks_class = InlineModelAdminChecks\n2018     classes = None\n2019 \n2020     def __init__(self, parent_model, admin_site):\n2021         self.admin_site = admin_site\n2022         self.parent_model = parent_model\n2023         self.opts = self.model._meta\n2024         self.has_registered_model = admin_site.is_registered(self.model)\n2025         super().__init__()\n2026         if self.verbose_name is None:\n2027             self.verbose_name = self.model._meta.verbose_name\n2028         if self.verbose_name_plural is None:\n2029             self.verbose_name_plural = self.model._meta.verbose_name_plural\n2030 \n2031     @property\n2032     def media(self):\n2033         extra = '' if settings.DEBUG else '.min'\n2034         js = ['vendor/jquery/jquery%s.js' % extra, 'jquery.init.js', 'inlines.js']\n2035         if self.filter_vertical or self.filter_horizontal:\n2036             js.extend(['SelectBox.js', 'SelectFilter2.js'])\n2037         if self.classes and 'collapse' in self.classes:\n2038             js.append('collapse.js')\n2039         return forms.Media(js=['admin/js/%s' % url for url in js])\n2040 \n2041     def get_extra(self, request, obj=None, **kwargs):\n2042         \"\"\"Hook for customizing the number of extra inline forms.\"\"\"\n2043         return self.extra\n2044 \n2045     def get_min_num(self, request, obj=None, **kwargs):\n2046         \"\"\"Hook for customizing the min number of inline forms.\"\"\"\n2047         return self.min_num\n2048 \n2049     def get_max_num(self, request, obj=None, **kwargs):\n2050         \"\"\"Hook for customizing the max number of extra inline forms.\"\"\"\n2051         return self.max_num\n2052 \n2053     def get_formset(self, request, obj=None, **kwargs):\n2054         \"\"\"Return a BaseInlineFormSet class for use in admin add/change views.\"\"\"\n2055         if 'fields' in kwargs:\n2056             fields = kwargs.pop('fields')\n2057         else:\n2058             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n2059         excluded = self.get_exclude(request, obj)\n2060         exclude = [] if excluded is None else list(excluded)\n2061         exclude.extend(self.get_readonly_fields(request, obj))\n2062         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:\n2063             # Take the custom ModelForm's Meta.exclude into account only if the\n2064             # InlineModelAdmin doesn't define its own.\n2065             exclude.extend(self.form._meta.exclude)\n2066         # If exclude is an empty list we use None, since that's the actual\n2067         # default.\n2068         exclude = exclude or None\n2069         can_delete = self.can_delete and self.has_delete_permission(request, obj)\n2070         defaults = {\n2071             'form': self.form,\n2072             'formset': self.formset,\n2073             'fk_name': self.fk_name,\n2074             'fields': fields,\n2075             'exclude': exclude,\n2076             'formfield_callback': partial(self.formfield_for_dbfield, request=request),\n2077             'extra': self.get_extra(request, obj, **kwargs),\n2078             'min_num': self.get_min_num(request, obj, **kwargs),\n2079             'max_num': self.get_max_num(request, obj, **kwargs),\n2080             'can_delete': can_delete,\n2081             **kwargs,\n2082         }\n2083 \n2084         base_model_form = defaults['form']\n2085         can_change = self.has_change_permission(request, obj) if request else True\n2086         can_add = self.has_add_permission(request, obj) if request else True\n2087 \n2088         class DeleteProtectedModelForm(base_model_form):\n2089 \n2090             def hand_clean_DELETE(self):\n2091                 \"\"\"\n2092                 We don't validate the 'DELETE' field itself because on\n2093                 templates it's not rendered using the field information, but\n2094                 just using a generic \"deletion_field\" of the InlineModelAdmin.\n2095                 \"\"\"\n2096                 if self.cleaned_data.get(DELETION_FIELD_NAME, False):\n2097                     using = router.db_for_write(self._meta.model)\n2098                     collector = NestedObjects(using=using)\n2099                     if self.instance._state.adding:\n2100                         return\n2101                     collector.collect([self.instance])\n2102                     if collector.protected:\n2103                         objs = []\n2104                         for p in collector.protected:\n2105                             objs.append(\n2106                                 # Translators: Model verbose name and instance representation,\n2107                                 # suitable to be an item in a list.\n2108                                 _('%(class_name)s %(instance)s') % {\n2109                                     'class_name': p._meta.verbose_name,\n2110                                     'instance': p}\n2111                             )\n2112                         params = {\n2113                             'class_name': self._meta.model._meta.verbose_name,\n2114                             'instance': self.instance,\n2115                             'related_objects': get_text_list(objs, _('and')),\n2116                         }\n2117                         msg = _(\"Deleting %(class_name)s %(instance)s would require \"\n2118                                 \"deleting the following protected related objects: \"\n2119                                 \"%(related_objects)s\")\n2120                         raise ValidationError(msg, code='deleting_protected', params=params)\n2121 \n2122             def is_valid(self):\n2123                 result = super().is_valid()\n2124                 self.hand_clean_DELETE()\n2125                 return result\n2126 \n2127             def has_changed(self):\n2128                 # Protect against unauthorized edits.\n2129                 if not can_change and not self.instance._state.adding:\n2130                     return False\n2131                 if not can_add and self.instance._state.adding:\n2132                     return False\n2133                 return super().has_changed()\n2134 \n2135         defaults['form'] = DeleteProtectedModelForm\n2136 \n2137         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):\n2138             defaults['fields'] = forms.ALL_FIELDS\n2139 \n2140         return inlineformset_factory(self.parent_model, self.model, **defaults)\n2141 \n2142     def _get_form_for_get_fields(self, request, obj=None):\n2143         return self.get_formset(request, obj, fields=None).form\n2144 \n2145     def get_queryset(self, request):\n2146         queryset = super().get_queryset(request)\n2147         if not self.has_view_or_change_permission(request):\n2148             queryset = queryset.none()\n2149         return queryset\n2150 \n2151     def _has_any_perms_for_target_model(self, request, perms):\n2152         \"\"\"\n2153         This method is called only when the ModelAdmin's model is for an\n2154         ManyToManyField's implicit through model (if self.opts.auto_created).\n2155         Return True if the user has any of the given permissions ('add',\n2156         'change', etc.) for the model that points to the through model.\n2157         \"\"\"\n2158         opts = self.opts\n2159         # Find the target model of an auto-created many-to-many relationship.\n2160         for field in opts.fields:\n2161             if field.remote_field and field.remote_field.model != self.parent_model:\n2162                 opts = field.remote_field.model._meta\n2163                 break\n2164         return any(\n2165             request.user.has_perm('%s.%s' % (opts.app_label, get_permission_codename(perm, opts)))\n2166             for perm in perms\n2167         )\n2168 \n2169     def has_add_permission(self, request, obj):\n2170         if self.opts.auto_created:\n2171             # Auto-created intermediate models don't have their own\n2172             # permissions. The user needs to have the change permission for the\n2173             # related model in order to be able to do anything with the\n2174             # intermediate model.\n2175             return self._has_any_perms_for_target_model(request, ['change'])\n2176         return super().has_add_permission(request)\n2177 \n2178     def has_change_permission(self, request, obj=None):\n2179         if self.opts.auto_created:\n2180             # Same comment as has_add_permission().\n2181             return self._has_any_perms_for_target_model(request, ['change'])\n2182         return super().has_change_permission(request)\n2183 \n2184     def has_delete_permission(self, request, obj=None):\n2185         if self.opts.auto_created:\n2186             # Same comment as has_add_permission().\n2187             return self._has_any_perms_for_target_model(request, ['change'])\n2188         return super().has_delete_permission(request, obj)\n2189 \n2190     def has_view_permission(self, request, obj=None):\n2191         if self.opts.auto_created:\n2192             # Same comment as has_add_permission(). The 'change' permission\n2193             # also implies the 'view' permission.\n2194             return self._has_any_perms_for_target_model(request, ['view', 'change'])\n2195         return super().has_view_permission(request)\n2196 \n2197 \n2198 class StackedInline(InlineModelAdmin):\n2199     template = 'admin/edit_inline/stacked.html'\n2200 \n2201 \n2202 class TabularInline(InlineModelAdmin):\n2203     template = 'admin/edit_inline/tabular.html'\n",
        "intended_behavior": "Review and adjust how `JSONField` data is prepared and displayed in the admin interface, specifically in methods that handle or display field values in the admin forms or list displays. If `json.dumps` is used to serialize `JSONField` data for display, ensure it uses `ensure_ascii=False`. This adjustment is to ensure that the admin interface properly displays Unicode characters contained in `JSONField`, enhancing user experience without affecting the admin's performance or security."
    }
]