2025-10-17 17:20:58.094 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 17:21:00.837 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=201, output_tokens=13, cost=0.002400
2025-10-17 17:21:00.838 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 17:21:00.842 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 17:21:04.444 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=509, output_tokens=119, cost=0.008660
2025-10-17 17:21:04.467 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 17:21:06.850 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=473, output_tokens=56, cost=0.006410
2025-10-17 17:21:06.852 | DEBUG    | Extracted a valid json.
2025-10-17 17:21:06.852 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"QuantileTransformer\")",
        "search_method_in_class(\"fit\", \"QuantileTransformer\")",
        "search_method_in_class(\"transform\", \"QuantileTransformer\")"
    ],
    "bug_locations": []
}
2025-10-17 17:21:06.890 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 17:21:06.891 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 17:21:20.445 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1717, output_tokens=564, cost=0.034090
2025-10-17 17:21:20.459 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 17:21:22.200 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2497, output_tokens=49, cost=0.026440
2025-10-17 17:21:22.408 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 17:21:26.887 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=403, output_tokens=60, cost=0.005830
2025-10-17 17:21:26.888 | DEBUG    | Extracted a valid json.
2025-10-17 17:21:26.888 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method_in_class(\"_dense_fit\", \"QuantileTransformer\")", "search_method_in_class(\"_sparse_fit\", \"QuantileTransformer\")", "search_method_in_class(\"_transform\", \"QuantileTransformer\")"],
    "bug_locations": []
}
2025-10-17 17:21:26.904 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 17:21:26.904 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 17:21:42.360 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3865, output_tokens=697, cost=0.059560
2025-10-17 17:21:42.371 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 17:21:56.195 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4778, output_tokens=510, cost=0.063080
2025-10-17 17:21:56.205 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 17:22:04.844 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=864, output_tokens=354, cost=0.019260
2025-10-17 17:22:04.845 | DEBUG    | Extracted a valid json.
2025-10-17 17:22:04.845 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sklearn/preprocessing/data.py",
            "class": "QuantileTransformer",
            "method": "",
            "intended_behavior": "The main class documentation and the `__init__` documentation should include details on how `QuantileTransformer` implements quantile transformation. It should explain that for both dense and sparse matrices, `QuantileTransformer` computes empirical quantiles based on the input data. For dense matrices, this might involve subsampling for efficiency. For sparse matrices, the implementation carefully considers non-zero elements to compute quantiles efficiently while handling implicit zeros based on the `ignore_implicit_zeros` parameter. The documentation should also clarify how these quantiles are then used to map the data to the desired distribution (uniform or normal) by applying a transformation that closely aligns with calculating the empirical CDF or its inverse."
        },
        {
            "file": "sklearn/preprocessing/data.py",
            "class": "QuantileTransformer",
            "method": "",
            "intended_behavior": "Detailed documentation within these methods should explain: The role of `fit` in computing the necessary quantiles for transformation, including how quantiles are derived from the data. How `_dense_fit` operates on dense matrices and the importance of subsampling and computing nanpercentiles. The adaptation of `_sparse_fit` for sparse matrices, highlighting how it deals with non-zero elements and efficiency considerations. The functionality of `_transform` in applying the computed quantiles to transform data to the desired distribution, detailing both forward and inverse transformations. This should tie back to the theoretical grounding of the transformation process, emphasizing its practical application in data preprocessing."
        }
    ]
}
2025-10-17 17:22:04.853 | DEBUG    | Bug location extracted successfully: [<file>sklearn/preprocessing/data.py</file>
<class>QuantileTransformer</class>
<method>None</method>
<code>
1990 class QuantileTransformer(BaseEstimator, TransformerMixin):
1991     """Transform features using quantiles information.
1992 
1993     This method transforms the features to follow a uniform or a normal
1994     distribution. Therefore, for a given feature, this transformation tends
1995     to spread out the most frequent values. It also reduces the impact of
1996     (marginal) outliers: this is therefore a robust preprocessing scheme.
1997 
1998     The transformation is applied on each feature independently.
1999     The cumulative distribution function of a feature is used to project the
2000     original values. Features values of new/unseen data that fall below
2001     or above the fitted range will be mapped to the bounds of the output
2002     distribution. Note that this transform is non-linear. It may distort linear
2003     correlations between variables measured at the same scale but renders
2004     variables measured at different scales more directly comparable.
2005 
2006     Read more in the :ref:`User Guide <preprocessing_transformer>`.
2007 
2008     Parameters
2009     ----------
2010     n_quantiles : int, optional (default=1000)
2011         Number of quantiles to be computed. It corresponds to the number
2012         of landmarks used to discretize the cumulative distribution function.
2013 
2014     output_distribution : str, optional (default='uniform')
2015         Marginal distribution for the transformed data. The choices are
2016         'uniform' (default) or 'normal'.
2017 
2018     ignore_implicit_zeros : bool, optional (default=False)
2019         Only applies to sparse matrices. If True, the sparse entries of the
2020         matrix are discarded to compute the quantile statistics. If False,
2021         these entries are treated as zeros.
2022 
2023     subsample : int, optional (default=1e5)
2024         Maximum number of samples used to estimate the quantiles for
2025         computational efficiency. Note that the subsampling procedure may
2026         differ for value-identical sparse and dense matrices.
2027 
2028     random_state : int, RandomState instance or None, optional (default=None)
2029         If int, random_state is the seed used by the random number generator;
2030         If RandomState instance, random_state is the random number generator;
2031         If None, the random number generator is the RandomState instance used
2032         by np.random. Note that this is used by subsampling and smoothing
2033         noise.
2034 
2035     copy : boolean, optional, (default=True)
2036         Set to False to perform inplace transformation and avoid a copy (if the
2037         input is already a numpy array).
2038 
2039     Attributes
2040     ----------
2041     quantiles_ : ndarray, shape (n_quantiles, n_features)
2042         The values corresponding the quantiles of reference.
2043 
2044     references_ : ndarray, shape(n_quantiles, )
2045         Quantiles of references.
2046 
2047     Examples
2048     --------
2049     >>> import numpy as np
2050     >>> from sklearn.preprocessing import QuantileTransformer
2051     >>> rng = np.random.RandomState(0)
2052     >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)
2053     >>> qt = QuantileTransformer(n_quantiles=10, random_state=0)
2054     >>> qt.fit_transform(X) # doctest: +ELLIPSIS
2055     array([...])
2056 
2057     See also
2058     --------
2059     quantile_transform : Equivalent function without the estimator API.
2060     PowerTransformer : Perform mapping to a normal distribution using a power
2061         transform.
2062     StandardScaler : Perform standardization that is faster, but less robust
2063         to outliers.
2064     RobustScaler : Perform robust standardization that removes the influence
2065         of outliers but does not put outliers and inliers on the same scale.
2066 
2067     Notes
2068     -----
2069     NaNs are treated as missing values: disregarded in fit, and maintained in
2070     transform.
2071 
2072     For a comparison of the different scalers, transformers, and normalizers,
2073     see :ref:`examples/preprocessing/plot_all_scaling.py
2074     <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.
2075     """
2076 
2077     def __init__(self, n_quantiles=1000, output_distribution='uniform',
2078                  ignore_implicit_zeros=False, subsample=int(1e5),
2079                  random_state=None, copy=True):
2080         self.n_quantiles = n_quantiles
2081         self.output_distribution = output_distribution
2082         self.ignore_implicit_zeros = ignore_implicit_zeros
2083         self.subsample = subsample
2084         self.random_state = random_state
2085         self.copy = copy
2086 
2087     def _dense_fit(self, X, random_state):
2088         """Compute percentiles for dense matrices.
2089 
2090         Parameters
2091         ----------
2092         X : ndarray, shape (n_samples, n_features)
2093             The data used to scale along the features axis.
2094         """
2095         if self.ignore_implicit_zeros:
2096             warnings.warn("'ignore_implicit_zeros' takes effect only with"
2097                           " sparse matrix. This parameter has no effect.")
2098 
2099         n_samples, n_features = X.shape
2100         references = self.references_ * 100
2101 
2102         self.quantiles_ = []
2103         for col in X.T:
2104             if self.subsample < n_samples:
2105                 subsample_idx = random_state.choice(n_samples,
2106                                                     size=self.subsample,
2107                                                     replace=False)
2108                 col = col.take(subsample_idx, mode='clip')
2109             self.quantiles_.append(nanpercentile(col, references))
2110         self.quantiles_ = np.transpose(self.quantiles_)
2111 
2112     def _sparse_fit(self, X, random_state):
2113         """Compute percentiles for sparse matrices.
2114 
2115         Parameters
2116         ----------
2117         X : sparse matrix CSC, shape (n_samples, n_features)
2118             The data used to scale along the features axis. The sparse matrix
2119             needs to be nonnegative.
2120         """
2121         n_samples, n_features = X.shape
2122         references = self.references_ * 100
2123 
2124         self.quantiles_ = []
2125         for feature_idx in range(n_features):
2126             column_nnz_data = X.data[X.indptr[feature_idx]:
2127                                      X.indptr[feature_idx + 1]]
2128             if len(column_nnz_data) > self.subsample:
2129                 column_subsample = (self.subsample * len(column_nnz_data) //
2130                                     n_samples)
2131                 if self.ignore_implicit_zeros:
2132                     column_data = np.zeros(shape=column_subsample,
2133                                            dtype=X.dtype)
2134                 else:
2135                     column_data = np.zeros(shape=self.subsample, dtype=X.dtype)
2136                 column_data[:column_subsample] = random_state.choice(
2137                     column_nnz_data, size=column_subsample, replace=False)
2138             else:
2139                 if self.ignore_implicit_zeros:
2140                     column_data = np.zeros(shape=len(column_nnz_data),
2141                                            dtype=X.dtype)
2142                 else:
2143                     column_data = np.zeros(shape=n_samples, dtype=X.dtype)
2144                 column_data[:len(column_nnz_data)] = column_nnz_data
2145 
2146             if not column_data.size:
2147                 # if no nnz, an error will be raised for computing the
2148                 # quantiles. Force the quantiles to be zeros.
2149                 self.quantiles_.append([0] * len(references))
2150             else:
2151                 self.quantiles_.append(nanpercentile(column_data, references))
2152         self.quantiles_ = np.transpose(self.quantiles_)
2153 
2154     def fit(self, X, y=None):
2155         """Compute the quantiles used for transforming.
2156 
2157         Parameters
2158         ----------
2159         X : ndarray or sparse matrix, shape (n_samples, n_features)
2160             The data used to scale along the features axis. If a sparse
2161             matrix is provided, it will be converted into a sparse
2162             ``csc_matrix``. Additionally, the sparse matrix needs to be
2163             nonnegative if `ignore_implicit_zeros` is False.
2164 
2165         Returns
2166         -------
2167         self : object
2168         """
2169         if self.n_quantiles <= 0:
2170             raise ValueError("Invalid value for 'n_quantiles': %d. "
2171                              "The number of quantiles must be at least one."
2172                              % self.n_quantiles)
2173 
2174         if self.subsample <= 0:
2175             raise ValueError("Invalid value for 'subsample': %d. "
2176                              "The number of subsamples must be at least one."
2177                              % self.subsample)
2178 
2179         if self.n_quantiles > self.subsample:
2180             raise ValueError("The number of quantiles cannot be greater than"
2181                              " the number of samples used. Got {} quantiles"
2182                              " and {} samples.".format(self.n_quantiles,
2183                                                        self.subsample))
2184 
2185         X = self._check_inputs(X)
2186         rng = check_random_state(self.random_state)
2187 
2188         # Create the quantiles of reference
2189         self.references_ = np.linspace(0, 1, self.n_quantiles,
2190                                        endpoint=True)
2191         if sparse.issparse(X):
2192             self._sparse_fit(X, rng)
2193         else:
2194             self._dense_fit(X, rng)
2195 
2196         return self
2197 
2198     def _transform_col(self, X_col, quantiles, inverse):
2199         """Private function to transform a single feature"""
2200 
2201         if self.output_distribution == 'normal':
2202             output_distribution = 'norm'
2203         else:
2204             output_distribution = self.output_distribution
2205         output_distribution = getattr(stats, output_distribution)
2206 
2207         if not inverse:
2208             lower_bound_x = quantiles[0]
2209             upper_bound_x = quantiles[-1]
2210             lower_bound_y = 0
2211             upper_bound_y = 1
2212         else:
2213             lower_bound_x = 0
2214             upper_bound_x = 1
2215             lower_bound_y = quantiles[0]
2216             upper_bound_y = quantiles[-1]
2217             #  for inverse transform, match a uniform PDF
2218             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2219                 X_col = output_distribution.cdf(X_col)
2220         # find index for lower and higher bounds
2221         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2222             lower_bounds_idx = (X_col - BOUNDS_THRESHOLD <
2223                                 lower_bound_x)
2224             upper_bounds_idx = (X_col + BOUNDS_THRESHOLD >
2225                                 upper_bound_x)
2226 
2227         isfinite_mask = ~np.isnan(X_col)
2228         X_col_finite = X_col[isfinite_mask]
2229         if not inverse:
2230             # Interpolate in one direction and in the other and take the
2231             # mean. This is in case of repeated values in the features
2232             # and hence repeated quantiles
2233             #
2234             # If we don't do this, only one extreme of the duplicated is
2235             # used (the upper when we do ascending, and the
2236             # lower for descending). We take the mean of these two
2237             X_col[isfinite_mask] = .5 * (
2238                 np.interp(X_col_finite, quantiles, self.references_)
2239                 - np.interp(-X_col_finite, -quantiles[::-1],
2240                             -self.references_[::-1]))
2241         else:
2242             X_col[isfinite_mask] = np.interp(X_col_finite,
2243                                              self.references_, quantiles)
2244 
2245         X_col[upper_bounds_idx] = upper_bound_y
2246         X_col[lower_bounds_idx] = lower_bound_y
2247         # for forward transform, match the output PDF
2248         if not inverse:
2249             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2250                 X_col = output_distribution.ppf(X_col)
2251             # find the value to clip the data to avoid mapping to
2252             # infinity. Clip such that the inverse transform will be
2253             # consistent
2254             clip_min = output_distribution.ppf(BOUNDS_THRESHOLD -
2255                                                np.spacing(1))
2256             clip_max = output_distribution.ppf(1 - (BOUNDS_THRESHOLD -
2257                                                     np.spacing(1)))
2258             X_col = np.clip(X_col, clip_min, clip_max)
2259 
2260         return X_col
2261 
2262     def _check_inputs(self, X, accept_sparse_negative=False):
2263         """Check inputs before fit and transform"""
2264         X = check_array(X, accept_sparse='csc', copy=self.copy,
2265                         dtype=FLOAT_DTYPES,
2266                         force_all_finite='allow-nan')
2267         # we only accept positive sparse matrix when ignore_implicit_zeros is
2268         # false and that we call fit or transform.
2269         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2270             if (not accept_sparse_negative and not self.ignore_implicit_zeros
2271                     and (sparse.issparse(X) and np.any(X.data < 0))):
2272                 raise ValueError('QuantileTransformer only accepts'
2273                                  ' non-negative sparse matrices.')
2274 
2275         # check the output PDF
2276         if self.output_distribution not in ('normal', 'uniform'):
2277             raise ValueError("'output_distribution' has to be either 'normal'"
2278                              " or 'uniform'. Got '{}' instead.".format(
2279                                  self.output_distribution))
2280 
2281         return X
2282 
2283     def _check_is_fitted(self, X):
2284         """Check the inputs before transforming"""
2285         check_is_fitted(self, 'quantiles_')
2286         # check that the dimension of X are adequate with the fitted data
2287         if X.shape[1] != self.quantiles_.shape[1]:
2288             raise ValueError('X does not have the same number of features as'
2289                              ' the previously fitted data. Got {} instead of'
2290                              ' {}.'.format(X.shape[1],
2291                                            self.quantiles_.shape[1]))
2292 
2293     def _transform(self, X, inverse=False):
2294         """Forward and inverse transform.
2295 
2296         Parameters
2297         ----------
2298         X : ndarray, shape (n_samples, n_features)
2299             The data used to scale along the features axis.
2300 
2301         inverse : bool, optional (default=False)
2302             If False, apply forward transform. If True, apply
2303             inverse transform.
2304 
2305         Returns
2306         -------
2307         X : ndarray, shape (n_samples, n_features)
2308             Projected data
2309         """
2310 
2311         if sparse.issparse(X):
2312             for feature_idx in range(X.shape[1]):
2313                 column_slice = slice(X.indptr[feature_idx],
2314                                      X.indptr[feature_idx + 1])
2315                 X.data[column_slice] = self._transform_col(
2316                     X.data[column_slice], self.quantiles_[:, feature_idx],
2317                     inverse)
2318         else:
2319             for feature_idx in range(X.shape[1]):
2320                 X[:, feature_idx] = self._transform_col(
2321                     X[:, feature_idx], self.quantiles_[:, feature_idx],
2322                     inverse)
2323 
2324         return X
2325 
2326     def transform(self, X):
2327         """Feature-wise transformation of the data.
2328 
2329         Parameters
2330         ----------
2331         X : ndarray or sparse matrix, shape (n_samples, n_features)
2332             The data used to scale along the features axis. If a sparse
2333             matrix is provided, it will be converted into a sparse
2334             ``csc_matrix``. Additionally, the sparse matrix needs to be
2335             nonnegative if `ignore_implicit_zeros` is False.
2336 
2337         Returns
2338         -------
2339         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2340             The projected data.
2341         """
2342         X = self._check_inputs(X)
2343         self._check_is_fitted(X)
2344 
2345         return self._transform(X, inverse=False)
2346 
2347     def inverse_transform(self, X):
2348         """Back-projection to the original space.
2349 
2350         Parameters
2351         ----------
2352         X : ndarray or sparse matrix, shape (n_samples, n_features)
2353             The data used to scale along the features axis. If a sparse
2354             matrix is provided, it will be converted into a sparse
2355             ``csc_matrix``. Additionally, the sparse matrix needs to be
2356             nonnegative if `ignore_implicit_zeros` is False.
2357 
2358         Returns
2359         -------
2360         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2361             The projected data.
2362         """
2363         X = self._check_inputs(X, accept_sparse_negative=True)
2364         self._check_is_fitted(X)
2365 
2366         return self._transform(X, inverse=True)

</code><intended_behavior>The main class documentation and the `__init__` documentation should include details on how `QuantileTransformer` implements quantile transformation. It should explain that for both dense and sparse matrices, `QuantileTransformer` computes empirical quantiles based on the input data. For dense matrices, this might involve subsampling for efficiency. For sparse matrices, the implementation carefully considers non-zero elements to compute quantiles efficiently while handling implicit zeros based on the `ignore_implicit_zeros` parameter. The documentation should also clarify how these quantiles are then used to map the data to the desired distribution (uniform or normal) by applying a transformation that closely aligns with calculating the empirical CDF or its inverse.</intended_behavior>, <file>sklearn/preprocessing/data.py</file>
<class>QuantileTransformer</class>
<method>None</method>
<code>
1990 class QuantileTransformer(BaseEstimator, TransformerMixin):
1991     """Transform features using quantiles information.
1992 
1993     This method transforms the features to follow a uniform or a normal
1994     distribution. Therefore, for a given feature, this transformation tends
1995     to spread out the most frequent values. It also reduces the impact of
1996     (marginal) outliers: this is therefore a robust preprocessing scheme.
1997 
1998     The transformation is applied on each feature independently.
1999     The cumulative distribution function of a feature is used to project the
2000     original values. Features values of new/unseen data that fall below
2001     or above the fitted range will be mapped to the bounds of the output
2002     distribution. Note that this transform is non-linear. It may distort linear
2003     correlations between variables measured at the same scale but renders
2004     variables measured at different scales more directly comparable.
2005 
2006     Read more in the :ref:`User Guide <preprocessing_transformer>`.
2007 
2008     Parameters
2009     ----------
2010     n_quantiles : int, optional (default=1000)
2011         Number of quantiles to be computed. It corresponds to the number
2012         of landmarks used to discretize the cumulative distribution function.
2013 
2014     output_distribution : str, optional (default='uniform')
2015         Marginal distribution for the transformed data. The choices are
2016         'uniform' (default) or 'normal'.
2017 
2018     ignore_implicit_zeros : bool, optional (default=False)
2019         Only applies to sparse matrices. If True, the sparse entries of the
2020         matrix are discarded to compute the quantile statistics. If False,
2021         these entries are treated as zeros.
2022 
2023     subsample : int, optional (default=1e5)
2024         Maximum number of samples used to estimate the quantiles for
2025         computational efficiency. Note that the subsampling procedure may
2026         differ for value-identical sparse and dense matrices.
2027 
2028     random_state : int, RandomState instance or None, optional (default=None)
2029         If int, random_state is the seed used by the random number generator;
2030         If RandomState instance, random_state is the random number generator;
2031         If None, the random number generator is the RandomState instance used
2032         by np.random. Note that this is used by subsampling and smoothing
2033         noise.
2034 
2035     copy : boolean, optional, (default=True)
2036         Set to False to perform inplace transformation and avoid a copy (if the
2037         input is already a numpy array).
2038 
2039     Attributes
2040     ----------
2041     quantiles_ : ndarray, shape (n_quantiles, n_features)
2042         The values corresponding the quantiles of reference.
2043 
2044     references_ : ndarray, shape(n_quantiles, )
2045         Quantiles of references.
2046 
2047     Examples
2048     --------
2049     >>> import numpy as np
2050     >>> from sklearn.preprocessing import QuantileTransformer
2051     >>> rng = np.random.RandomState(0)
2052     >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)
2053     >>> qt = QuantileTransformer(n_quantiles=10, random_state=0)
2054     >>> qt.fit_transform(X) # doctest: +ELLIPSIS
2055     array([...])
2056 
2057     See also
2058     --------
2059     quantile_transform : Equivalent function without the estimator API.
2060     PowerTransformer : Perform mapping to a normal distribution using a power
2061         transform.
2062     StandardScaler : Perform standardization that is faster, but less robust
2063         to outliers.
2064     RobustScaler : Perform robust standardization that removes the influence
2065         of outliers but does not put outliers and inliers on the same scale.
2066 
2067     Notes
2068     -----
2069     NaNs are treated as missing values: disregarded in fit, and maintained in
2070     transform.
2071 
2072     For a comparison of the different scalers, transformers, and normalizers,
2073     see :ref:`examples/preprocessing/plot_all_scaling.py
2074     <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.
2075     """
2076 
2077     def __init__(self, n_quantiles=1000, output_distribution='uniform',
2078                  ignore_implicit_zeros=False, subsample=int(1e5),
2079                  random_state=None, copy=True):
2080         self.n_quantiles = n_quantiles
2081         self.output_distribution = output_distribution
2082         self.ignore_implicit_zeros = ignore_implicit_zeros
2083         self.subsample = subsample
2084         self.random_state = random_state
2085         self.copy = copy
2086 
2087     def _dense_fit(self, X, random_state):
2088         """Compute percentiles for dense matrices.
2089 
2090         Parameters
2091         ----------
2092         X : ndarray, shape (n_samples, n_features)
2093             The data used to scale along the features axis.
2094         """
2095         if self.ignore_implicit_zeros:
2096             warnings.warn("'ignore_implicit_zeros' takes effect only with"
2097                           " sparse matrix. This parameter has no effect.")
2098 
2099         n_samples, n_features = X.shape
2100         references = self.references_ * 100
2101 
2102         self.quantiles_ = []
2103         for col in X.T:
2104             if self.subsample < n_samples:
2105                 subsample_idx = random_state.choice(n_samples,
2106                                                     size=self.subsample,
2107                                                     replace=False)
2108                 col = col.take(subsample_idx, mode='clip')
2109             self.quantiles_.append(nanpercentile(col, references))
2110         self.quantiles_ = np.transpose(self.quantiles_)
2111 
2112     def _sparse_fit(self, X, random_state):
2113         """Compute percentiles for sparse matrices.
2114 
2115         Parameters
2116         ----------
2117         X : sparse matrix CSC, shape (n_samples, n_features)
2118             The data used to scale along the features axis. The sparse matrix
2119             needs to be nonnegative.
2120         """
2121         n_samples, n_features = X.shape
2122         references = self.references_ * 100
2123 
2124         self.quantiles_ = []
2125         for feature_idx in range(n_features):
2126             column_nnz_data = X.data[X.indptr[feature_idx]:
2127                                      X.indptr[feature_idx + 1]]
2128             if len(column_nnz_data) > self.subsample:
2129                 column_subsample = (self.subsample * len(column_nnz_data) //
2130                                     n_samples)
2131                 if self.ignore_implicit_zeros:
2132                     column_data = np.zeros(shape=column_subsample,
2133                                            dtype=X.dtype)
2134                 else:
2135                     column_data = np.zeros(shape=self.subsample, dtype=X.dtype)
2136                 column_data[:column_subsample] = random_state.choice(
2137                     column_nnz_data, size=column_subsample, replace=False)
2138             else:
2139                 if self.ignore_implicit_zeros:
2140                     column_data = np.zeros(shape=len(column_nnz_data),
2141                                            dtype=X.dtype)
2142                 else:
2143                     column_data = np.zeros(shape=n_samples, dtype=X.dtype)
2144                 column_data[:len(column_nnz_data)] = column_nnz_data
2145 
2146             if not column_data.size:
2147                 # if no nnz, an error will be raised for computing the
2148                 # quantiles. Force the quantiles to be zeros.
2149                 self.quantiles_.append([0] * len(references))
2150             else:
2151                 self.quantiles_.append(nanpercentile(column_data, references))
2152         self.quantiles_ = np.transpose(self.quantiles_)
2153 
2154     def fit(self, X, y=None):
2155         """Compute the quantiles used for transforming.
2156 
2157         Parameters
2158         ----------
2159         X : ndarray or sparse matrix, shape (n_samples, n_features)
2160             The data used to scale along the features axis. If a sparse
2161             matrix is provided, it will be converted into a sparse
2162             ``csc_matrix``. Additionally, the sparse matrix needs to be
2163             nonnegative if `ignore_implicit_zeros` is False.
2164 
2165         Returns
2166         -------
2167         self : object
2168         """
2169         if self.n_quantiles <= 0:
2170             raise ValueError("Invalid value for 'n_quantiles': %d. "
2171                              "The number of quantiles must be at least one."
2172                              % self.n_quantiles)
2173 
2174         if self.subsample <= 0:
2175             raise ValueError("Invalid value for 'subsample': %d. "
2176                              "The number of subsamples must be at least one."
2177                              % self.subsample)
2178 
2179         if self.n_quantiles > self.subsample:
2180             raise ValueError("The number of quantiles cannot be greater than"
2181                              " the number of samples used. Got {} quantiles"
2182                              " and {} samples.".format(self.n_quantiles,
2183                                                        self.subsample))
2184 
2185         X = self._check_inputs(X)
2186         rng = check_random_state(self.random_state)
2187 
2188         # Create the quantiles of reference
2189         self.references_ = np.linspace(0, 1, self.n_quantiles,
2190                                        endpoint=True)
2191         if sparse.issparse(X):
2192             self._sparse_fit(X, rng)
2193         else:
2194             self._dense_fit(X, rng)
2195 
2196         return self
2197 
2198     def _transform_col(self, X_col, quantiles, inverse):
2199         """Private function to transform a single feature"""
2200 
2201         if self.output_distribution == 'normal':
2202             output_distribution = 'norm'
2203         else:
2204             output_distribution = self.output_distribution
2205         output_distribution = getattr(stats, output_distribution)
2206 
2207         if not inverse:
2208             lower_bound_x = quantiles[0]
2209             upper_bound_x = quantiles[-1]
2210             lower_bound_y = 0
2211             upper_bound_y = 1
2212         else:
2213             lower_bound_x = 0
2214             upper_bound_x = 1
2215             lower_bound_y = quantiles[0]
2216             upper_bound_y = quantiles[-1]
2217             #  for inverse transform, match a uniform PDF
2218             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2219                 X_col = output_distribution.cdf(X_col)
2220         # find index for lower and higher bounds
2221         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2222             lower_bounds_idx = (X_col - BOUNDS_THRESHOLD <
2223                                 lower_bound_x)
2224             upper_bounds_idx = (X_col + BOUNDS_THRESHOLD >
2225                                 upper_bound_x)
2226 
2227         isfinite_mask = ~np.isnan(X_col)
2228         X_col_finite = X_col[isfinite_mask]
2229         if not inverse:
2230             # Interpolate in one direction and in the other and take the
2231             # mean. This is in case of repeated values in the features
2232             # and hence repeated quantiles
2233             #
2234             # If we don't do this, only one extreme of the duplicated is
2235             # used (the upper when we do ascending, and the
2236             # lower for descending). We take the mean of these two
2237             X_col[isfinite_mask] = .5 * (
2238                 np.interp(X_col_finite, quantiles, self.references_)
2239                 - np.interp(-X_col_finite, -quantiles[::-1],
2240                             -self.references_[::-1]))
2241         else:
2242             X_col[isfinite_mask] = np.interp(X_col_finite,
2243                                              self.references_, quantiles)
2244 
2245         X_col[upper_bounds_idx] = upper_bound_y
2246         X_col[lower_bounds_idx] = lower_bound_y
2247         # for forward transform, match the output PDF
2248         if not inverse:
2249             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2250                 X_col = output_distribution.ppf(X_col)
2251             # find the value to clip the data to avoid mapping to
2252             # infinity. Clip such that the inverse transform will be
2253             # consistent
2254             clip_min = output_distribution.ppf(BOUNDS_THRESHOLD -
2255                                                np.spacing(1))
2256             clip_max = output_distribution.ppf(1 - (BOUNDS_THRESHOLD -
2257                                                     np.spacing(1)))
2258             X_col = np.clip(X_col, clip_min, clip_max)
2259 
2260         return X_col
2261 
2262     def _check_inputs(self, X, accept_sparse_negative=False):
2263         """Check inputs before fit and transform"""
2264         X = check_array(X, accept_sparse='csc', copy=self.copy,
2265                         dtype=FLOAT_DTYPES,
2266                         force_all_finite='allow-nan')
2267         # we only accept positive sparse matrix when ignore_implicit_zeros is
2268         # false and that we call fit or transform.
2269         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2270             if (not accept_sparse_negative and not self.ignore_implicit_zeros
2271                     and (sparse.issparse(X) and np.any(X.data < 0))):
2272                 raise ValueError('QuantileTransformer only accepts'
2273                                  ' non-negative sparse matrices.')
2274 
2275         # check the output PDF
2276         if self.output_distribution not in ('normal', 'uniform'):
2277             raise ValueError("'output_distribution' has to be either 'normal'"
2278                              " or 'uniform'. Got '{}' instead.".format(
2279                                  self.output_distribution))
2280 
2281         return X
2282 
2283     def _check_is_fitted(self, X):
2284         """Check the inputs before transforming"""
2285         check_is_fitted(self, 'quantiles_')
2286         # check that the dimension of X are adequate with the fitted data
2287         if X.shape[1] != self.quantiles_.shape[1]:
2288             raise ValueError('X does not have the same number of features as'
2289                              ' the previously fitted data. Got {} instead of'
2290                              ' {}.'.format(X.shape[1],
2291                                            self.quantiles_.shape[1]))
2292 
2293     def _transform(self, X, inverse=False):
2294         """Forward and inverse transform.
2295 
2296         Parameters
2297         ----------
2298         X : ndarray, shape (n_samples, n_features)
2299             The data used to scale along the features axis.
2300 
2301         inverse : bool, optional (default=False)
2302             If False, apply forward transform. If True, apply
2303             inverse transform.
2304 
2305         Returns
2306         -------
2307         X : ndarray, shape (n_samples, n_features)
2308             Projected data
2309         """
2310 
2311         if sparse.issparse(X):
2312             for feature_idx in range(X.shape[1]):
2313                 column_slice = slice(X.indptr[feature_idx],
2314                                      X.indptr[feature_idx + 1])
2315                 X.data[column_slice] = self._transform_col(
2316                     X.data[column_slice], self.quantiles_[:, feature_idx],
2317                     inverse)
2318         else:
2319             for feature_idx in range(X.shape[1]):
2320                 X[:, feature_idx] = self._transform_col(
2321                     X[:, feature_idx], self.quantiles_[:, feature_idx],
2322                     inverse)
2323 
2324         return X
2325 
2326     def transform(self, X):
2327         """Feature-wise transformation of the data.
2328 
2329         Parameters
2330         ----------
2331         X : ndarray or sparse matrix, shape (n_samples, n_features)
2332             The data used to scale along the features axis. If a sparse
2333             matrix is provided, it will be converted into a sparse
2334             ``csc_matrix``. Additionally, the sparse matrix needs to be
2335             nonnegative if `ignore_implicit_zeros` is False.
2336 
2337         Returns
2338         -------
2339         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2340             The projected data.
2341         """
2342         X = self._check_inputs(X)
2343         self._check_is_fitted(X)
2344 
2345         return self._transform(X, inverse=False)
2346 
2347     def inverse_transform(self, X):
2348         """Back-projection to the original space.
2349 
2350         Parameters
2351         ----------
2352         X : ndarray or sparse matrix, shape (n_samples, n_features)
2353             The data used to scale along the features axis. If a sparse
2354             matrix is provided, it will be converted into a sparse
2355             ``csc_matrix``. Additionally, the sparse matrix needs to be
2356             nonnegative if `ignore_implicit_zeros` is False.
2357 
2358         Returns
2359         -------
2360         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2361             The projected data.
2362         """
2363         X = self._check_inputs(X, accept_sparse_negative=True)
2364         self._check_is_fitted(X)
2365 
2366         return self._transform(X, inverse=True)

</code><intended_behavior>Detailed documentation within these methods should explain: The role of `fit` in computing the necessary quantiles for transformation, including how quantiles are derived from the data. How `_dense_fit` operates on dense matrices and the importance of subsampling and computing nanpercentiles. The adaptation of `_sparse_fit` for sparse matrices, highlighting how it deals with non-zero elements and efficiency considerations. The functionality of `_transform` in applying the computed quantiles to transform data to the desired distribution, detailing both forward and inverse transformations. This should tie back to the theoretical grounding of the transformation process, emphasizing its practical application in data preprocessing.</intended_behavior>]
2025-10-17 17:22:04.854 | INFO     | Search completed. Bug locations: [<file>sklearn/preprocessing/data.py</file>
<class>QuantileTransformer</class>
<method>None</method>
<code>
1990 class QuantileTransformer(BaseEstimator, TransformerMixin):
1991     """Transform features using quantiles information.
1992 
1993     This method transforms the features to follow a uniform or a normal
1994     distribution. Therefore, for a given feature, this transformation tends
1995     to spread out the most frequent values. It also reduces the impact of
1996     (marginal) outliers: this is therefore a robust preprocessing scheme.
1997 
1998     The transformation is applied on each feature independently.
1999     The cumulative distribution function of a feature is used to project the
2000     original values. Features values of new/unseen data that fall below
2001     or above the fitted range will be mapped to the bounds of the output
2002     distribution. Note that this transform is non-linear. It may distort linear
2003     correlations between variables measured at the same scale but renders
2004     variables measured at different scales more directly comparable.
2005 
2006     Read more in the :ref:`User Guide <preprocessing_transformer>`.
2007 
2008     Parameters
2009     ----------
2010     n_quantiles : int, optional (default=1000)
2011         Number of quantiles to be computed. It corresponds to the number
2012         of landmarks used to discretize the cumulative distribution function.
2013 
2014     output_distribution : str, optional (default='uniform')
2015         Marginal distribution for the transformed data. The choices are
2016         'uniform' (default) or 'normal'.
2017 
2018     ignore_implicit_zeros : bool, optional (default=False)
2019         Only applies to sparse matrices. If True, the sparse entries of the
2020         matrix are discarded to compute the quantile statistics. If False,
2021         these entries are treated as zeros.
2022 
2023     subsample : int, optional (default=1e5)
2024         Maximum number of samples used to estimate the quantiles for
2025         computational efficiency. Note that the subsampling procedure may
2026         differ for value-identical sparse and dense matrices.
2027 
2028     random_state : int, RandomState instance or None, optional (default=None)
2029         If int, random_state is the seed used by the random number generator;
2030         If RandomState instance, random_state is the random number generator;
2031         If None, the random number generator is the RandomState instance used
2032         by np.random. Note that this is used by subsampling and smoothing
2033         noise.
2034 
2035     copy : boolean, optional, (default=True)
2036         Set to False to perform inplace transformation and avoid a copy (if the
2037         input is already a numpy array).
2038 
2039     Attributes
2040     ----------
2041     quantiles_ : ndarray, shape (n_quantiles, n_features)
2042         The values corresponding the quantiles of reference.
2043 
2044     references_ : ndarray, shape(n_quantiles, )
2045         Quantiles of references.
2046 
2047     Examples
2048     --------
2049     >>> import numpy as np
2050     >>> from sklearn.preprocessing import QuantileTransformer
2051     >>> rng = np.random.RandomState(0)
2052     >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)
2053     >>> qt = QuantileTransformer(n_quantiles=10, random_state=0)
2054     >>> qt.fit_transform(X) # doctest: +ELLIPSIS
2055     array([...])
2056 
2057     See also
2058     --------
2059     quantile_transform : Equivalent function without the estimator API.
2060     PowerTransformer : Perform mapping to a normal distribution using a power
2061         transform.
2062     StandardScaler : Perform standardization that is faster, but less robust
2063         to outliers.
2064     RobustScaler : Perform robust standardization that removes the influence
2065         of outliers but does not put outliers and inliers on the same scale.
2066 
2067     Notes
2068     -----
2069     NaNs are treated as missing values: disregarded in fit, and maintained in
2070     transform.
2071 
2072     For a comparison of the different scalers, transformers, and normalizers,
2073     see :ref:`examples/preprocessing/plot_all_scaling.py
2074     <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.
2075     """
2076 
2077     def __init__(self, n_quantiles=1000, output_distribution='uniform',
2078                  ignore_implicit_zeros=False, subsample=int(1e5),
2079                  random_state=None, copy=True):
2080         self.n_quantiles = n_quantiles
2081         self.output_distribution = output_distribution
2082         self.ignore_implicit_zeros = ignore_implicit_zeros
2083         self.subsample = subsample
2084         self.random_state = random_state
2085         self.copy = copy
2086 
2087     def _dense_fit(self, X, random_state):
2088         """Compute percentiles for dense matrices.
2089 
2090         Parameters
2091         ----------
2092         X : ndarray, shape (n_samples, n_features)
2093             The data used to scale along the features axis.
2094         """
2095         if self.ignore_implicit_zeros:
2096             warnings.warn("'ignore_implicit_zeros' takes effect only with"
2097                           " sparse matrix. This parameter has no effect.")
2098 
2099         n_samples, n_features = X.shape
2100         references = self.references_ * 100
2101 
2102         self.quantiles_ = []
2103         for col in X.T:
2104             if self.subsample < n_samples:
2105                 subsample_idx = random_state.choice(n_samples,
2106                                                     size=self.subsample,
2107                                                     replace=False)
2108                 col = col.take(subsample_idx, mode='clip')
2109             self.quantiles_.append(nanpercentile(col, references))
2110         self.quantiles_ = np.transpose(self.quantiles_)
2111 
2112     def _sparse_fit(self, X, random_state):
2113         """Compute percentiles for sparse matrices.
2114 
2115         Parameters
2116         ----------
2117         X : sparse matrix CSC, shape (n_samples, n_features)
2118             The data used to scale along the features axis. The sparse matrix
2119             needs to be nonnegative.
2120         """
2121         n_samples, n_features = X.shape
2122         references = self.references_ * 100
2123 
2124         self.quantiles_ = []
2125         for feature_idx in range(n_features):
2126             column_nnz_data = X.data[X.indptr[feature_idx]:
2127                                      X.indptr[feature_idx + 1]]
2128             if len(column_nnz_data) > self.subsample:
2129                 column_subsample = (self.subsample * len(column_nnz_data) //
2130                                     n_samples)
2131                 if self.ignore_implicit_zeros:
2132                     column_data = np.zeros(shape=column_subsample,
2133                                            dtype=X.dtype)
2134                 else:
2135                     column_data = np.zeros(shape=self.subsample, dtype=X.dtype)
2136                 column_data[:column_subsample] = random_state.choice(
2137                     column_nnz_data, size=column_subsample, replace=False)
2138             else:
2139                 if self.ignore_implicit_zeros:
2140                     column_data = np.zeros(shape=len(column_nnz_data),
2141                                            dtype=X.dtype)
2142                 else:
2143                     column_data = np.zeros(shape=n_samples, dtype=X.dtype)
2144                 column_data[:len(column_nnz_data)] = column_nnz_data
2145 
2146             if not column_data.size:
2147                 # if no nnz, an error will be raised for computing the
2148                 # quantiles. Force the quantiles to be zeros.
2149                 self.quantiles_.append([0] * len(references))
2150             else:
2151                 self.quantiles_.append(nanpercentile(column_data, references))
2152         self.quantiles_ = np.transpose(self.quantiles_)
2153 
2154     def fit(self, X, y=None):
2155         """Compute the quantiles used for transforming.
2156 
2157         Parameters
2158         ----------
2159         X : ndarray or sparse matrix, shape (n_samples, n_features)
2160             The data used to scale along the features axis. If a sparse
2161             matrix is provided, it will be converted into a sparse
2162             ``csc_matrix``. Additionally, the sparse matrix needs to be
2163             nonnegative if `ignore_implicit_zeros` is False.
2164 
2165         Returns
2166         -------
2167         self : object
2168         """
2169         if self.n_quantiles <= 0:
2170             raise ValueError("Invalid value for 'n_quantiles': %d. "
2171                              "The number of quantiles must be at least one."
2172                              % self.n_quantiles)
2173 
2174         if self.subsample <= 0:
2175             raise ValueError("Invalid value for 'subsample': %d. "
2176                              "The number of subsamples must be at least one."
2177                              % self.subsample)
2178 
2179         if self.n_quantiles > self.subsample:
2180             raise ValueError("The number of quantiles cannot be greater than"
2181                              " the number of samples used. Got {} quantiles"
2182                              " and {} samples.".format(self.n_quantiles,
2183                                                        self.subsample))
2184 
2185         X = self._check_inputs(X)
2186         rng = check_random_state(self.random_state)
2187 
2188         # Create the quantiles of reference
2189         self.references_ = np.linspace(0, 1, self.n_quantiles,
2190                                        endpoint=True)
2191         if sparse.issparse(X):
2192             self._sparse_fit(X, rng)
2193         else:
2194             self._dense_fit(X, rng)
2195 
2196         return self
2197 
2198     def _transform_col(self, X_col, quantiles, inverse):
2199         """Private function to transform a single feature"""
2200 
2201         if self.output_distribution == 'normal':
2202             output_distribution = 'norm'
2203         else:
2204             output_distribution = self.output_distribution
2205         output_distribution = getattr(stats, output_distribution)
2206 
2207         if not inverse:
2208             lower_bound_x = quantiles[0]
2209             upper_bound_x = quantiles[-1]
2210             lower_bound_y = 0
2211             upper_bound_y = 1
2212         else:
2213             lower_bound_x = 0
2214             upper_bound_x = 1
2215             lower_bound_y = quantiles[0]
2216             upper_bound_y = quantiles[-1]
2217             #  for inverse transform, match a uniform PDF
2218             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2219                 X_col = output_distribution.cdf(X_col)
2220         # find index for lower and higher bounds
2221         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2222             lower_bounds_idx = (X_col - BOUNDS_THRESHOLD <
2223                                 lower_bound_x)
2224             upper_bounds_idx = (X_col + BOUNDS_THRESHOLD >
2225                                 upper_bound_x)
2226 
2227         isfinite_mask = ~np.isnan(X_col)
2228         X_col_finite = X_col[isfinite_mask]
2229         if not inverse:
2230             # Interpolate in one direction and in the other and take the
2231             # mean. This is in case of repeated values in the features
2232             # and hence repeated quantiles
2233             #
2234             # If we don't do this, only one extreme of the duplicated is
2235             # used (the upper when we do ascending, and the
2236             # lower for descending). We take the mean of these two
2237             X_col[isfinite_mask] = .5 * (
2238                 np.interp(X_col_finite, quantiles, self.references_)
2239                 - np.interp(-X_col_finite, -quantiles[::-1],
2240                             -self.references_[::-1]))
2241         else:
2242             X_col[isfinite_mask] = np.interp(X_col_finite,
2243                                              self.references_, quantiles)
2244 
2245         X_col[upper_bounds_idx] = upper_bound_y
2246         X_col[lower_bounds_idx] = lower_bound_y
2247         # for forward transform, match the output PDF
2248         if not inverse:
2249             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2250                 X_col = output_distribution.ppf(X_col)
2251             # find the value to clip the data to avoid mapping to
2252             # infinity. Clip such that the inverse transform will be
2253             # consistent
2254             clip_min = output_distribution.ppf(BOUNDS_THRESHOLD -
2255                                                np.spacing(1))
2256             clip_max = output_distribution.ppf(1 - (BOUNDS_THRESHOLD -
2257                                                     np.spacing(1)))
2258             X_col = np.clip(X_col, clip_min, clip_max)
2259 
2260         return X_col
2261 
2262     def _check_inputs(self, X, accept_sparse_negative=False):
2263         """Check inputs before fit and transform"""
2264         X = check_array(X, accept_sparse='csc', copy=self.copy,
2265                         dtype=FLOAT_DTYPES,
2266                         force_all_finite='allow-nan')
2267         # we only accept positive sparse matrix when ignore_implicit_zeros is
2268         # false and that we call fit or transform.
2269         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2270             if (not accept_sparse_negative and not self.ignore_implicit_zeros
2271                     and (sparse.issparse(X) and np.any(X.data < 0))):
2272                 raise ValueError('QuantileTransformer only accepts'
2273                                  ' non-negative sparse matrices.')
2274 
2275         # check the output PDF
2276         if self.output_distribution not in ('normal', 'uniform'):
2277             raise ValueError("'output_distribution' has to be either 'normal'"
2278                              " or 'uniform'. Got '{}' instead.".format(
2279                                  self.output_distribution))
2280 
2281         return X
2282 
2283     def _check_is_fitted(self, X):
2284         """Check the inputs before transforming"""
2285         check_is_fitted(self, 'quantiles_')
2286         # check that the dimension of X are adequate with the fitted data
2287         if X.shape[1] != self.quantiles_.shape[1]:
2288             raise ValueError('X does not have the same number of features as'
2289                              ' the previously fitted data. Got {} instead of'
2290                              ' {}.'.format(X.shape[1],
2291                                            self.quantiles_.shape[1]))
2292 
2293     def _transform(self, X, inverse=False):
2294         """Forward and inverse transform.
2295 
2296         Parameters
2297         ----------
2298         X : ndarray, shape (n_samples, n_features)
2299             The data used to scale along the features axis.
2300 
2301         inverse : bool, optional (default=False)
2302             If False, apply forward transform. If True, apply
2303             inverse transform.
2304 
2305         Returns
2306         -------
2307         X : ndarray, shape (n_samples, n_features)
2308             Projected data
2309         """
2310 
2311         if sparse.issparse(X):
2312             for feature_idx in range(X.shape[1]):
2313                 column_slice = slice(X.indptr[feature_idx],
2314                                      X.indptr[feature_idx + 1])
2315                 X.data[column_slice] = self._transform_col(
2316                     X.data[column_slice], self.quantiles_[:, feature_idx],
2317                     inverse)
2318         else:
2319             for feature_idx in range(X.shape[1]):
2320                 X[:, feature_idx] = self._transform_col(
2321                     X[:, feature_idx], self.quantiles_[:, feature_idx],
2322                     inverse)
2323 
2324         return X
2325 
2326     def transform(self, X):
2327         """Feature-wise transformation of the data.
2328 
2329         Parameters
2330         ----------
2331         X : ndarray or sparse matrix, shape (n_samples, n_features)
2332             The data used to scale along the features axis. If a sparse
2333             matrix is provided, it will be converted into a sparse
2334             ``csc_matrix``. Additionally, the sparse matrix needs to be
2335             nonnegative if `ignore_implicit_zeros` is False.
2336 
2337         Returns
2338         -------
2339         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2340             The projected data.
2341         """
2342         X = self._check_inputs(X)
2343         self._check_is_fitted(X)
2344 
2345         return self._transform(X, inverse=False)
2346 
2347     def inverse_transform(self, X):
2348         """Back-projection to the original space.
2349 
2350         Parameters
2351         ----------
2352         X : ndarray or sparse matrix, shape (n_samples, n_features)
2353             The data used to scale along the features axis. If a sparse
2354             matrix is provided, it will be converted into a sparse
2355             ``csc_matrix``. Additionally, the sparse matrix needs to be
2356             nonnegative if `ignore_implicit_zeros` is False.
2357 
2358         Returns
2359         -------
2360         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2361             The projected data.
2362         """
2363         X = self._check_inputs(X, accept_sparse_negative=True)
2364         self._check_is_fitted(X)
2365 
2366         return self._transform(X, inverse=True)

</code><intended_behavior>The main class documentation and the `__init__` documentation should include details on how `QuantileTransformer` implements quantile transformation. It should explain that for both dense and sparse matrices, `QuantileTransformer` computes empirical quantiles based on the input data. For dense matrices, this might involve subsampling for efficiency. For sparse matrices, the implementation carefully considers non-zero elements to compute quantiles efficiently while handling implicit zeros based on the `ignore_implicit_zeros` parameter. The documentation should also clarify how these quantiles are then used to map the data to the desired distribution (uniform or normal) by applying a transformation that closely aligns with calculating the empirical CDF or its inverse.</intended_behavior>, <file>sklearn/preprocessing/data.py</file>
<class>QuantileTransformer</class>
<method>None</method>
<code>
1990 class QuantileTransformer(BaseEstimator, TransformerMixin):
1991     """Transform features using quantiles information.
1992 
1993     This method transforms the features to follow a uniform or a normal
1994     distribution. Therefore, for a given feature, this transformation tends
1995     to spread out the most frequent values. It also reduces the impact of
1996     (marginal) outliers: this is therefore a robust preprocessing scheme.
1997 
1998     The transformation is applied on each feature independently.
1999     The cumulative distribution function of a feature is used to project the
2000     original values. Features values of new/unseen data that fall below
2001     or above the fitted range will be mapped to the bounds of the output
2002     distribution. Note that this transform is non-linear. It may distort linear
2003     correlations between variables measured at the same scale but renders
2004     variables measured at different scales more directly comparable.
2005 
2006     Read more in the :ref:`User Guide <preprocessing_transformer>`.
2007 
2008     Parameters
2009     ----------
2010     n_quantiles : int, optional (default=1000)
2011         Number of quantiles to be computed. It corresponds to the number
2012         of landmarks used to discretize the cumulative distribution function.
2013 
2014     output_distribution : str, optional (default='uniform')
2015         Marginal distribution for the transformed data. The choices are
2016         'uniform' (default) or 'normal'.
2017 
2018     ignore_implicit_zeros : bool, optional (default=False)
2019         Only applies to sparse matrices. If True, the sparse entries of the
2020         matrix are discarded to compute the quantile statistics. If False,
2021         these entries are treated as zeros.
2022 
2023     subsample : int, optional (default=1e5)
2024         Maximum number of samples used to estimate the quantiles for
2025         computational efficiency. Note that the subsampling procedure may
2026         differ for value-identical sparse and dense matrices.
2027 
2028     random_state : int, RandomState instance or None, optional (default=None)
2029         If int, random_state is the seed used by the random number generator;
2030         If RandomState instance, random_state is the random number generator;
2031         If None, the random number generator is the RandomState instance used
2032         by np.random. Note that this is used by subsampling and smoothing
2033         noise.
2034 
2035     copy : boolean, optional, (default=True)
2036         Set to False to perform inplace transformation and avoid a copy (if the
2037         input is already a numpy array).
2038 
2039     Attributes
2040     ----------
2041     quantiles_ : ndarray, shape (n_quantiles, n_features)
2042         The values corresponding the quantiles of reference.
2043 
2044     references_ : ndarray, shape(n_quantiles, )
2045         Quantiles of references.
2046 
2047     Examples
2048     --------
2049     >>> import numpy as np
2050     >>> from sklearn.preprocessing import QuantileTransformer
2051     >>> rng = np.random.RandomState(0)
2052     >>> X = np.sort(rng.normal(loc=0.5, scale=0.25, size=(25, 1)), axis=0)
2053     >>> qt = QuantileTransformer(n_quantiles=10, random_state=0)
2054     >>> qt.fit_transform(X) # doctest: +ELLIPSIS
2055     array([...])
2056 
2057     See also
2058     --------
2059     quantile_transform : Equivalent function without the estimator API.
2060     PowerTransformer : Perform mapping to a normal distribution using a power
2061         transform.
2062     StandardScaler : Perform standardization that is faster, but less robust
2063         to outliers.
2064     RobustScaler : Perform robust standardization that removes the influence
2065         of outliers but does not put outliers and inliers on the same scale.
2066 
2067     Notes
2068     -----
2069     NaNs are treated as missing values: disregarded in fit, and maintained in
2070     transform.
2071 
2072     For a comparison of the different scalers, transformers, and normalizers,
2073     see :ref:`examples/preprocessing/plot_all_scaling.py
2074     <sphx_glr_auto_examples_preprocessing_plot_all_scaling.py>`.
2075     """
2076 
2077     def __init__(self, n_quantiles=1000, output_distribution='uniform',
2078                  ignore_implicit_zeros=False, subsample=int(1e5),
2079                  random_state=None, copy=True):
2080         self.n_quantiles = n_quantiles
2081         self.output_distribution = output_distribution
2082         self.ignore_implicit_zeros = ignore_implicit_zeros
2083         self.subsample = subsample
2084         self.random_state = random_state
2085         self.copy = copy
2086 
2087     def _dense_fit(self, X, random_state):
2088         """Compute percentiles for dense matrices.
2089 
2090         Parameters
2091         ----------
2092         X : ndarray, shape (n_samples, n_features)
2093             The data used to scale along the features axis.
2094         """
2095         if self.ignore_implicit_zeros:
2096             warnings.warn("'ignore_implicit_zeros' takes effect only with"
2097                           " sparse matrix. This parameter has no effect.")
2098 
2099         n_samples, n_features = X.shape
2100         references = self.references_ * 100
2101 
2102         self.quantiles_ = []
2103         for col in X.T:
2104             if self.subsample < n_samples:
2105                 subsample_idx = random_state.choice(n_samples,
2106                                                     size=self.subsample,
2107                                                     replace=False)
2108                 col = col.take(subsample_idx, mode='clip')
2109             self.quantiles_.append(nanpercentile(col, references))
2110         self.quantiles_ = np.transpose(self.quantiles_)
2111 
2112     def _sparse_fit(self, X, random_state):
2113         """Compute percentiles for sparse matrices.
2114 
2115         Parameters
2116         ----------
2117         X : sparse matrix CSC, shape (n_samples, n_features)
2118             The data used to scale along the features axis. The sparse matrix
2119             needs to be nonnegative.
2120         """
2121         n_samples, n_features = X.shape
2122         references = self.references_ * 100
2123 
2124         self.quantiles_ = []
2125         for feature_idx in range(n_features):
2126             column_nnz_data = X.data[X.indptr[feature_idx]:
2127                                      X.indptr[feature_idx + 1]]
2128             if len(column_nnz_data) > self.subsample:
2129                 column_subsample = (self.subsample * len(column_nnz_data) //
2130                                     n_samples)
2131                 if self.ignore_implicit_zeros:
2132                     column_data = np.zeros(shape=column_subsample,
2133                                            dtype=X.dtype)
2134                 else:
2135                     column_data = np.zeros(shape=self.subsample, dtype=X.dtype)
2136                 column_data[:column_subsample] = random_state.choice(
2137                     column_nnz_data, size=column_subsample, replace=False)
2138             else:
2139                 if self.ignore_implicit_zeros:
2140                     column_data = np.zeros(shape=len(column_nnz_data),
2141                                            dtype=X.dtype)
2142                 else:
2143                     column_data = np.zeros(shape=n_samples, dtype=X.dtype)
2144                 column_data[:len(column_nnz_data)] = column_nnz_data
2145 
2146             if not column_data.size:
2147                 # if no nnz, an error will be raised for computing the
2148                 # quantiles. Force the quantiles to be zeros.
2149                 self.quantiles_.append([0] * len(references))
2150             else:
2151                 self.quantiles_.append(nanpercentile(column_data, references))
2152         self.quantiles_ = np.transpose(self.quantiles_)
2153 
2154     def fit(self, X, y=None):
2155         """Compute the quantiles used for transforming.
2156 
2157         Parameters
2158         ----------
2159         X : ndarray or sparse matrix, shape (n_samples, n_features)
2160             The data used to scale along the features axis. If a sparse
2161             matrix is provided, it will be converted into a sparse
2162             ``csc_matrix``. Additionally, the sparse matrix needs to be
2163             nonnegative if `ignore_implicit_zeros` is False.
2164 
2165         Returns
2166         -------
2167         self : object
2168         """
2169         if self.n_quantiles <= 0:
2170             raise ValueError("Invalid value for 'n_quantiles': %d. "
2171                              "The number of quantiles must be at least one."
2172                              % self.n_quantiles)
2173 
2174         if self.subsample <= 0:
2175             raise ValueError("Invalid value for 'subsample': %d. "
2176                              "The number of subsamples must be at least one."
2177                              % self.subsample)
2178 
2179         if self.n_quantiles > self.subsample:
2180             raise ValueError("The number of quantiles cannot be greater than"
2181                              " the number of samples used. Got {} quantiles"
2182                              " and {} samples.".format(self.n_quantiles,
2183                                                        self.subsample))
2184 
2185         X = self._check_inputs(X)
2186         rng = check_random_state(self.random_state)
2187 
2188         # Create the quantiles of reference
2189         self.references_ = np.linspace(0, 1, self.n_quantiles,
2190                                        endpoint=True)
2191         if sparse.issparse(X):
2192             self._sparse_fit(X, rng)
2193         else:
2194             self._dense_fit(X, rng)
2195 
2196         return self
2197 
2198     def _transform_col(self, X_col, quantiles, inverse):
2199         """Private function to transform a single feature"""
2200 
2201         if self.output_distribution == 'normal':
2202             output_distribution = 'norm'
2203         else:
2204             output_distribution = self.output_distribution
2205         output_distribution = getattr(stats, output_distribution)
2206 
2207         if not inverse:
2208             lower_bound_x = quantiles[0]
2209             upper_bound_x = quantiles[-1]
2210             lower_bound_y = 0
2211             upper_bound_y = 1
2212         else:
2213             lower_bound_x = 0
2214             upper_bound_x = 1
2215             lower_bound_y = quantiles[0]
2216             upper_bound_y = quantiles[-1]
2217             #  for inverse transform, match a uniform PDF
2218             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2219                 X_col = output_distribution.cdf(X_col)
2220         # find index for lower and higher bounds
2221         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2222             lower_bounds_idx = (X_col - BOUNDS_THRESHOLD <
2223                                 lower_bound_x)
2224             upper_bounds_idx = (X_col + BOUNDS_THRESHOLD >
2225                                 upper_bound_x)
2226 
2227         isfinite_mask = ~np.isnan(X_col)
2228         X_col_finite = X_col[isfinite_mask]
2229         if not inverse:
2230             # Interpolate in one direction and in the other and take the
2231             # mean. This is in case of repeated values in the features
2232             # and hence repeated quantiles
2233             #
2234             # If we don't do this, only one extreme of the duplicated is
2235             # used (the upper when we do ascending, and the
2236             # lower for descending). We take the mean of these two
2237             X_col[isfinite_mask] = .5 * (
2238                 np.interp(X_col_finite, quantiles, self.references_)
2239                 - np.interp(-X_col_finite, -quantiles[::-1],
2240                             -self.references_[::-1]))
2241         else:
2242             X_col[isfinite_mask] = np.interp(X_col_finite,
2243                                              self.references_, quantiles)
2244 
2245         X_col[upper_bounds_idx] = upper_bound_y
2246         X_col[lower_bounds_idx] = lower_bound_y
2247         # for forward transform, match the output PDF
2248         if not inverse:
2249             with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2250                 X_col = output_distribution.ppf(X_col)
2251             # find the value to clip the data to avoid mapping to
2252             # infinity. Clip such that the inverse transform will be
2253             # consistent
2254             clip_min = output_distribution.ppf(BOUNDS_THRESHOLD -
2255                                                np.spacing(1))
2256             clip_max = output_distribution.ppf(1 - (BOUNDS_THRESHOLD -
2257                                                     np.spacing(1)))
2258             X_col = np.clip(X_col, clip_min, clip_max)
2259 
2260         return X_col
2261 
2262     def _check_inputs(self, X, accept_sparse_negative=False):
2263         """Check inputs before fit and transform"""
2264         X = check_array(X, accept_sparse='csc', copy=self.copy,
2265                         dtype=FLOAT_DTYPES,
2266                         force_all_finite='allow-nan')
2267         # we only accept positive sparse matrix when ignore_implicit_zeros is
2268         # false and that we call fit or transform.
2269         with np.errstate(invalid='ignore'):  # hide NaN comparison warnings
2270             if (not accept_sparse_negative and not self.ignore_implicit_zeros
2271                     and (sparse.issparse(X) and np.any(X.data < 0))):
2272                 raise ValueError('QuantileTransformer only accepts'
2273                                  ' non-negative sparse matrices.')
2274 
2275         # check the output PDF
2276         if self.output_distribution not in ('normal', 'uniform'):
2277             raise ValueError("'output_distribution' has to be either 'normal'"
2278                              " or 'uniform'. Got '{}' instead.".format(
2279                                  self.output_distribution))
2280 
2281         return X
2282 
2283     def _check_is_fitted(self, X):
2284         """Check the inputs before transforming"""
2285         check_is_fitted(self, 'quantiles_')
2286         # check that the dimension of X are adequate with the fitted data
2287         if X.shape[1] != self.quantiles_.shape[1]:
2288             raise ValueError('X does not have the same number of features as'
2289                              ' the previously fitted data. Got {} instead of'
2290                              ' {}.'.format(X.shape[1],
2291                                            self.quantiles_.shape[1]))
2292 
2293     def _transform(self, X, inverse=False):
2294         """Forward and inverse transform.
2295 
2296         Parameters
2297         ----------
2298         X : ndarray, shape (n_samples, n_features)
2299             The data used to scale along the features axis.
2300 
2301         inverse : bool, optional (default=False)
2302             If False, apply forward transform. If True, apply
2303             inverse transform.
2304 
2305         Returns
2306         -------
2307         X : ndarray, shape (n_samples, n_features)
2308             Projected data
2309         """
2310 
2311         if sparse.issparse(X):
2312             for feature_idx in range(X.shape[1]):
2313                 column_slice = slice(X.indptr[feature_idx],
2314                                      X.indptr[feature_idx + 1])
2315                 X.data[column_slice] = self._transform_col(
2316                     X.data[column_slice], self.quantiles_[:, feature_idx],
2317                     inverse)
2318         else:
2319             for feature_idx in range(X.shape[1]):
2320                 X[:, feature_idx] = self._transform_col(
2321                     X[:, feature_idx], self.quantiles_[:, feature_idx],
2322                     inverse)
2323 
2324         return X
2325 
2326     def transform(self, X):
2327         """Feature-wise transformation of the data.
2328 
2329         Parameters
2330         ----------
2331         X : ndarray or sparse matrix, shape (n_samples, n_features)
2332             The data used to scale along the features axis. If a sparse
2333             matrix is provided, it will be converted into a sparse
2334             ``csc_matrix``. Additionally, the sparse matrix needs to be
2335             nonnegative if `ignore_implicit_zeros` is False.
2336 
2337         Returns
2338         -------
2339         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2340             The projected data.
2341         """
2342         X = self._check_inputs(X)
2343         self._check_is_fitted(X)
2344 
2345         return self._transform(X, inverse=False)
2346 
2347     def inverse_transform(self, X):
2348         """Back-projection to the original space.
2349 
2350         Parameters
2351         ----------
2352         X : ndarray or sparse matrix, shape (n_samples, n_features)
2353             The data used to scale along the features axis. If a sparse
2354             matrix is provided, it will be converted into a sparse
2355             ``csc_matrix``. Additionally, the sparse matrix needs to be
2356             nonnegative if `ignore_implicit_zeros` is False.
2357 
2358         Returns
2359         -------
2360         Xt : ndarray or sparse matrix, shape (n_samples, n_features)
2361             The projected data.
2362         """
2363         X = self._check_inputs(X, accept_sparse_negative=True)
2364         self._check_is_fitted(X)
2365 
2366         return self._transform(X, inverse=True)

</code><intended_behavior>Detailed documentation within these methods should explain: The role of `fit` in computing the necessary quantiles for transformation, including how quantiles are derived from the data. How `_dense_fit` operates on dense matrices and the importance of subsampling and computing nanpercentiles. The adaptation of `_sparse_fit` for sparse matrices, highlighting how it deals with non-zero elements and efficiency considerations. The functionality of `_transform` in applying the computed quantiles to transform data to the desired distribution, detailing both forward and inverse transformations. This should tie back to the theoretical grounding of the transformation process, emphasizing its practical application in data preprocessing.</intended_behavior>]
2025-10-17 17:22:04.854 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 17:22:04.854 | INFO     | Search-only: skipping patch selection
2025-10-17 17:22:04.924 | INFO     | Task scikit-learn__scikit-learn-12827 completed successfully.
2025-10-17 17:22:04.925 | INFO     | No patch generated. You can try running ACR again.
