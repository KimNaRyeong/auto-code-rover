[
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__6.0/src/_pytest/python_api.py",
        "start": 1,
        "end": 755,
        "class_name": null,
        "method_name": null,
        "code": "1 import inspect\n2 import math\n3 import pprint\n4 from collections.abc import Iterable\n5 from collections.abc import Mapping\n6 from collections.abc import Sized\n7 from decimal import Decimal\n8 from itertools import filterfalse\n9 from numbers import Number\n10 from types import TracebackType\n11 from typing import Any\n12 from typing import Callable\n13 from typing import cast\n14 from typing import Generic\n15 from typing import Optional\n16 from typing import Pattern\n17 from typing import Tuple\n18 from typing import TypeVar\n19 from typing import Union\n20 \n21 from more_itertools.more import always_iterable\n22 \n23 import _pytest._code\n24 from _pytest.compat import overload\n25 from _pytest.compat import STRING_TYPES\n26 from _pytest.compat import TYPE_CHECKING\n27 from _pytest.outcomes import fail\n28 \n29 if TYPE_CHECKING:\n30     from typing import Type\n31 \n32 \n33 BASE_TYPE = (type, STRING_TYPES)\n34 \n35 \n36 def _non_numeric_type_error(value, at: Optional[str]) -> TypeError:\n37     at_str = \" at {}\".format(at) if at else \"\"\n38     return TypeError(\n39         \"cannot make approximate comparisons to non-numeric values: {!r} {}\".format(\n40             value, at_str\n41         )\n42     )\n43 \n44 \n45 # builtin pytest.approx helper\n46 \n47 \n48 class ApproxBase:\n49     \"\"\"\n50     Provide shared utilities for making approximate comparisons between numbers\n51     or sequences of numbers.\n52     \"\"\"\n53 \n54     # Tell numpy to use our `__eq__` operator instead of its.\n55     __array_ufunc__ = None\n56     __array_priority__ = 100\n57 \n58     def __init__(self, expected, rel=None, abs=None, nan_ok: bool = False) -> None:\n59         __tracebackhide__ = True\n60         self.expected = expected\n61         self.abs = abs\n62         self.rel = rel\n63         self.nan_ok = nan_ok\n64         self._check_type()\n65 \n66     def __repr__(self) -> str:\n67         raise NotImplementedError\n68 \n69     def __eq__(self, actual) -> bool:\n70         return all(\n71             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)\n72         )\n73 \n74     # Ignore type because of https://github.com/python/mypy/issues/4266.\n75     __hash__ = None  # type: ignore\n76 \n77     def __ne__(self, actual) -> bool:\n78         return not (actual == self)\n79 \n80     def _approx_scalar(self, x) -> \"ApproxScalar\":\n81         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n82 \n83     def _yield_comparisons(self, actual):\n84         \"\"\"\n85         Yield all the pairs of numbers to be compared.  This is used to\n86         implement the `__eq__` method.\n87         \"\"\"\n88         raise NotImplementedError\n89 \n90     def _check_type(self) -> None:\n91         \"\"\"\n92         Raise a TypeError if the expected value is not a valid type.\n93         \"\"\"\n94         # This is only a concern if the expected value is a sequence.  In every\n95         # other case, the approx() function ensures that the expected value has\n96         # a numeric type.  For this reason, the default is to do nothing.  The\n97         # classes that deal with sequences should reimplement this method to\n98         # raise if there are any non-numeric elements in the sequence.\n99         pass\n100 \n101 \n102 def _recursive_list_map(f, x):\n103     if isinstance(x, list):\n104         return list(_recursive_list_map(f, xi) for xi in x)\n105     else:\n106         return f(x)\n107 \n108 \n109 class ApproxNumpy(ApproxBase):\n110     \"\"\"\n111     Perform approximate comparisons where the expected value is numpy array.\n112     \"\"\"\n113 \n114     def __repr__(self) -> str:\n115         list_scalars = _recursive_list_map(self._approx_scalar, self.expected.tolist())\n116         return \"approx({!r})\".format(list_scalars)\n117 \n118     def __eq__(self, actual) -> bool:\n119         import numpy as np\n120 \n121         # self.expected is supposed to always be an array here\n122 \n123         if not np.isscalar(actual):\n124             try:\n125                 actual = np.asarray(actual)\n126             except Exception as e:\n127                 raise TypeError(\n128                     \"cannot compare '{}' to numpy.ndarray\".format(actual)\n129                 ) from e\n130 \n131         if not np.isscalar(actual) and actual.shape != self.expected.shape:\n132             return False\n133 \n134         return ApproxBase.__eq__(self, actual)\n135 \n136     def _yield_comparisons(self, actual):\n137         import numpy as np\n138 \n139         # `actual` can either be a numpy array or a scalar, it is treated in\n140         # `__eq__` before being passed to `ApproxBase.__eq__`, which is the\n141         # only method that calls this one.\n142 \n143         if np.isscalar(actual):\n144             for i in np.ndindex(self.expected.shape):\n145                 yield actual, self.expected[i].item()\n146         else:\n147             for i in np.ndindex(self.expected.shape):\n148                 yield actual[i].item(), self.expected[i].item()\n149 \n150 \n151 class ApproxMapping(ApproxBase):\n152     \"\"\"\n153     Perform approximate comparisons where the expected value is a mapping with\n154     numeric values (the keys can be anything).\n155     \"\"\"\n156 \n157     def __repr__(self) -> str:\n158         return \"approx({!r})\".format(\n159             {k: self._approx_scalar(v) for k, v in self.expected.items()}\n160         )\n161 \n162     def __eq__(self, actual) -> bool:\n163         if set(actual.keys()) != set(self.expected.keys()):\n164             return False\n165 \n166         return ApproxBase.__eq__(self, actual)\n167 \n168     def _yield_comparisons(self, actual):\n169         for k in self.expected.keys():\n170             yield actual[k], self.expected[k]\n171 \n172     def _check_type(self) -> None:\n173         __tracebackhide__ = True\n174         for key, value in self.expected.items():\n175             if isinstance(value, type(self.expected)):\n176                 msg = \"pytest.approx() does not support nested dictionaries: key={!r} value={!r}\\n  full mapping={}\"\n177                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))\n178             elif not isinstance(value, Number):\n179                 raise _non_numeric_type_error(self.expected, at=\"key={!r}\".format(key))\n180 \n181 \n182 class ApproxSequencelike(ApproxBase):\n183     \"\"\"\n184     Perform approximate comparisons where the expected value is a sequence of\n185     numbers.\n186     \"\"\"\n187 \n188     def __repr__(self) -> str:\n189         seq_type = type(self.expected)\n190         if seq_type not in (tuple, list, set):\n191             seq_type = list\n192         return \"approx({!r})\".format(\n193             seq_type(self._approx_scalar(x) for x in self.expected)\n194         )\n195 \n196     def __eq__(self, actual) -> bool:\n197         if len(actual) != len(self.expected):\n198             return False\n199         return ApproxBase.__eq__(self, actual)\n200 \n201     def _yield_comparisons(self, actual):\n202         return zip(actual, self.expected)\n203 \n204     def _check_type(self) -> None:\n205         __tracebackhide__ = True\n206         for index, x in enumerate(self.expected):\n207             if isinstance(x, type(self.expected)):\n208                 msg = \"pytest.approx() does not support nested data structures: {!r} at index {}\\n  full sequence: {}\"\n209                 raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))\n210             elif not isinstance(x, Number):\n211                 raise _non_numeric_type_error(\n212                     self.expected, at=\"index {}\".format(index)\n213                 )\n214 \n215 \n216 class ApproxScalar(ApproxBase):\n217     \"\"\"\n218     Perform approximate comparisons where the expected value is a single number.\n219     \"\"\"\n220 \n221     # Using Real should be better than this Union, but not possible yet:\n222     # https://github.com/python/typeshed/pull/3108\n223     DEFAULT_ABSOLUTE_TOLERANCE = 1e-12  # type: Union[float, Decimal]\n224     DEFAULT_RELATIVE_TOLERANCE = 1e-6  # type: Union[float, Decimal]\n225 \n226     def __repr__(self) -> str:\n227         \"\"\"\n228         Return a string communicating both the expected value and the tolerance\n229         for the comparison being made, e.g. '1.0 \u00b1 1e-6', '(3+4j) \u00b1 5e-6 \u2220 \u00b1180\u00b0'.\n230         \"\"\"\n231 \n232         # Infinities aren't compared using tolerances, so don't show a\n233         # tolerance. Need to call abs to handle complex numbers, e.g. (inf + 1j)\n234         if math.isinf(abs(self.expected)):\n235             return str(self.expected)\n236 \n237         # If a sensible tolerance can't be calculated, self.tolerance will\n238         # raise a ValueError.  In this case, display '???'.\n239         try:\n240             vetted_tolerance = \"{:.1e}\".format(self.tolerance)\n241             if isinstance(self.expected, complex) and not math.isinf(self.tolerance):\n242                 vetted_tolerance += \" \u2220 \u00b1180\u00b0\"\n243         except ValueError:\n244             vetted_tolerance = \"???\"\n245 \n246         return \"{} \u00b1 {}\".format(self.expected, vetted_tolerance)\n247 \n248     def __eq__(self, actual) -> bool:\n249         \"\"\"\n250         Return true if the given value is equal to the expected value within\n251         the pre-specified tolerance.\n252         \"\"\"\n253         if _is_numpy_array(actual):\n254             # Call ``__eq__()`` manually to prevent infinite-recursion with\n255             # numpy<1.13.  See #3748.\n256             return all(self.__eq__(a) for a in actual.flat)\n257 \n258         # Short-circuit exact equality.\n259         if actual == self.expected:\n260             return True\n261 \n262         # Allow the user to control whether NaNs are considered equal to each\n263         # other or not.  The abs() calls are for compatibility with complex\n264         # numbers.\n265         if math.isnan(abs(self.expected)):\n266             return self.nan_ok and math.isnan(abs(actual))\n267 \n268         # Infinity shouldn't be approximately equal to anything but itself, but\n269         # if there's a relative tolerance, it will be infinite and infinity\n270         # will seem approximately equal to everything.  The equal-to-itself\n271         # case would have been short circuited above, so here we can just\n272         # return false if the expected value is infinite.  The abs() call is\n273         # for compatibility with complex numbers.\n274         if math.isinf(abs(self.expected)):\n275             return False\n276 \n277         # Return true if the two numbers are within the tolerance.\n278         result = abs(self.expected - actual) <= self.tolerance  # type: bool\n279         return result\n280 \n281     # Ignore type because of https://github.com/python/mypy/issues/4266.\n282     __hash__ = None  # type: ignore\n283 \n284     @property\n285     def tolerance(self):\n286         \"\"\"\n287         Return the tolerance for the comparison.  This could be either an\n288         absolute tolerance or a relative tolerance, depending on what the user\n289         specified or which would be larger.\n290         \"\"\"\n291 \n292         def set_default(x, default):\n293             return x if x is not None else default\n294 \n295         # Figure out what the absolute tolerance should be.  ``self.abs`` is\n296         # either None or a value specified by the user.\n297         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)\n298 \n299         if absolute_tolerance < 0:\n300             raise ValueError(\n301                 \"absolute tolerance can't be negative: {}\".format(absolute_tolerance)\n302             )\n303         if math.isnan(absolute_tolerance):\n304             raise ValueError(\"absolute tolerance can't be NaN.\")\n305 \n306         # If the user specified an absolute tolerance but not a relative one,\n307         # just return the absolute tolerance.\n308         if self.rel is None:\n309             if self.abs is not None:\n310                 return absolute_tolerance\n311 \n312         # Figure out what the relative tolerance should be.  ``self.rel`` is\n313         # either None or a value specified by the user.  This is done after\n314         # we've made sure the user didn't ask for an absolute tolerance only,\n315         # because we don't want to raise errors about the relative tolerance if\n316         # we aren't even going to use it.\n317         relative_tolerance = set_default(\n318             self.rel, self.DEFAULT_RELATIVE_TOLERANCE\n319         ) * abs(self.expected)\n320 \n321         if relative_tolerance < 0:\n322             raise ValueError(\n323                 \"relative tolerance can't be negative: {}\".format(absolute_tolerance)\n324             )\n325         if math.isnan(relative_tolerance):\n326             raise ValueError(\"relative tolerance can't be NaN.\")\n327 \n328         # Return the larger of the relative and absolute tolerances.\n329         return max(relative_tolerance, absolute_tolerance)\n330 \n331 \n332 class ApproxDecimal(ApproxScalar):\n333     \"\"\"\n334     Perform approximate comparisons where the expected value is a decimal.\n335     \"\"\"\n336 \n337     DEFAULT_ABSOLUTE_TOLERANCE = Decimal(\"1e-12\")\n338     DEFAULT_RELATIVE_TOLERANCE = Decimal(\"1e-6\")\n339 \n340 \n341 def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:\n342     \"\"\"\n343     Assert that two numbers (or two sets of numbers) are equal to each other\n344     within some tolerance.\n345 \n346     Due to the `intricacies of floating-point arithmetic`__, numbers that we\n347     would intuitively expect to be equal are not always so::\n348 \n349         >>> 0.1 + 0.2 == 0.3\n350         False\n351 \n352     __ https://docs.python.org/3/tutorial/floatingpoint.html\n353 \n354     This problem is commonly encountered when writing tests, e.g. when making\n355     sure that floating-point values are what you expect them to be.  One way to\n356     deal with this problem is to assert that two floating-point numbers are\n357     equal to within some appropriate tolerance::\n358 \n359         >>> abs((0.1 + 0.2) - 0.3) < 1e-6\n360         True\n361 \n362     However, comparisons like this are tedious to write and difficult to\n363     understand.  Furthermore, absolute comparisons like the one above are\n364     usually discouraged because there's no tolerance that works well for all\n365     situations.  ``1e-6`` is good for numbers around ``1``, but too small for\n366     very big numbers and too big for very small ones.  It's better to express\n367     the tolerance as a fraction of the expected value, but relative comparisons\n368     like that are even more difficult to write correctly and concisely.\n369 \n370     The ``approx`` class performs floating-point comparisons using a syntax\n371     that's as intuitive as possible::\n372 \n373         >>> from pytest import approx\n374         >>> 0.1 + 0.2 == approx(0.3)\n375         True\n376 \n377     The same syntax also works for sequences of numbers::\n378 \n379         >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))\n380         True\n381 \n382     Dictionary *values*::\n383 \n384         >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})\n385         True\n386 \n387     ``numpy`` arrays::\n388 \n389         >>> import numpy as np                                                          # doctest: +SKIP\n390         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP\n391         True\n392 \n393     And for a ``numpy`` array against a scalar::\n394 \n395         >>> import numpy as np                                         # doctest: +SKIP\n396         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP\n397         True\n398 \n399     By default, ``approx`` considers numbers within a relative tolerance of\n400     ``1e-6`` (i.e. one part in a million) of its expected value to be equal.\n401     This treatment would lead to surprising results if the expected value was\n402     ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.\n403     To handle this case less surprisingly, ``approx`` also considers numbers\n404     within an absolute tolerance of ``1e-12`` of its expected value to be\n405     equal.  Infinity and NaN are special cases.  Infinity is only considered\n406     equal to itself, regardless of the relative tolerance.  NaN is not\n407     considered equal to anything by default, but you can make it be equal to\n408     itself by setting the ``nan_ok`` argument to True.  (This is meant to\n409     facilitate comparing arrays that use NaN to mean \"no data\".)\n410 \n411     Both the relative and absolute tolerances can be changed by passing\n412     arguments to the ``approx`` constructor::\n413 \n414         >>> 1.0001 == approx(1)\n415         False\n416         >>> 1.0001 == approx(1, rel=1e-3)\n417         True\n418         >>> 1.0001 == approx(1, abs=1e-3)\n419         True\n420 \n421     If you specify ``abs`` but not ``rel``, the comparison will not consider\n422     the relative tolerance at all.  In other words, two numbers that are within\n423     the default relative tolerance of ``1e-6`` will still be considered unequal\n424     if they exceed the specified absolute tolerance.  If you specify both\n425     ``abs`` and ``rel``, the numbers will be considered equal if either\n426     tolerance is met::\n427 \n428         >>> 1 + 1e-8 == approx(1)\n429         True\n430         >>> 1 + 1e-8 == approx(1, abs=1e-12)\n431         False\n432         >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n433         True\n434 \n435     If you're thinking about using ``approx``, then you might want to know how\n436     it compares to other good ways of comparing floating-point numbers.  All of\n437     these algorithms are based on relative and absolute tolerances and should\n438     agree for the most part, but they do have meaningful differences:\n439 \n440     - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative\n441       tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute\n442       tolerance is met.  Because the relative tolerance is calculated w.r.t.\n443       both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor\n444       ``b`` is a \"reference value\").  You have to specify an absolute tolerance\n445       if you want to compare to ``0.0`` because there is no tolerance by\n446       default.  Only available in python>=3.5.  `More information...`__\n447 \n448       __ https://docs.python.org/3/library/math.html#math.isclose\n449 \n450     - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference\n451       between ``a`` and ``b`` is less that the sum of the relative tolerance\n452       w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance\n453       is only calculated w.r.t. ``b``, this test is asymmetric and you can\n454       think of ``b`` as the reference value.  Support for comparing sequences\n455       is provided by ``numpy.allclose``.  `More information...`__\n456 \n457       __ http://docs.scipy.org/doc/numpy-1.10.0/reference/generated/numpy.isclose.html\n458 \n459     - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``\n460       are within an absolute tolerance of ``1e-7``.  No relative tolerance is\n461       considered and the absolute tolerance cannot be changed, so this function\n462       is not appropriate for very large or very small numbers.  Also, it's only\n463       available in subclasses of ``unittest.TestCase`` and it's ugly because it\n464       doesn't follow PEP8.  `More information...`__\n465 \n466       __ https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertAlmostEqual\n467 \n468     - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative\n469       tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.\n470       Because the relative tolerance is only calculated w.r.t. ``b``, this test\n471       is asymmetric and you can think of ``b`` as the reference value.  In the\n472       special case that you explicitly specify an absolute tolerance but not a\n473       relative tolerance, only the absolute tolerance is considered.\n474 \n475     .. warning::\n476 \n477        .. versionchanged:: 3.2\n478 \n479        In order to avoid inconsistent behavior, ``TypeError`` is\n480        raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.\n481        The example below illustrates the problem::\n482 \n483            assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)\n484            assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)\n485 \n486        In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``\n487        to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to\n488        comparison. This is because the call hierarchy of rich comparisons\n489        follows a fixed behavior. `More information...`__\n490 \n491        __ https://docs.python.org/3/reference/datamodel.html#object.__ge__\n492     \"\"\"\n493 \n494     # Delegate the comparison to a class that knows how to deal with the type\n495     # of the expected value (e.g. int, float, list, dict, numpy.array, etc).\n496     #\n497     # The primary responsibility of these classes is to implement ``__eq__()``\n498     # and ``__repr__()``.  The former is used to actually check if some\n499     # \"actual\" value is equivalent to the given expected value within the\n500     # allowed tolerance.  The latter is used to show the user the expected\n501     # value and tolerance, in the case that a test failed.\n502     #\n503     # The actual logic for making approximate comparisons can be found in\n504     # ApproxScalar, which is used to compare individual numbers.  All of the\n505     # other Approx classes eventually delegate to this class.  The ApproxBase\n506     # class provides some convenient methods and overloads, but isn't really\n507     # essential.\n508 \n509     __tracebackhide__ = True\n510 \n511     if isinstance(expected, Decimal):\n512         cls = ApproxDecimal  # type: Type[ApproxBase]\n513     elif isinstance(expected, Number):\n514         cls = ApproxScalar\n515     elif isinstance(expected, Mapping):\n516         cls = ApproxMapping\n517     elif _is_numpy_array(expected):\n518         cls = ApproxNumpy\n519     elif (\n520         isinstance(expected, Iterable)\n521         and isinstance(expected, Sized)\n522         and not isinstance(expected, STRING_TYPES)\n523     ):\n524         cls = ApproxSequencelike\n525     else:\n526         raise _non_numeric_type_error(expected, at=None)\n527 \n528     return cls(expected, rel, abs, nan_ok)\n529 \n530 \n531 def _is_numpy_array(obj: object) -> bool:\n532     \"\"\"\n533     Return true if the given object is a numpy array.  Make a special effort to\n534     avoid importing numpy unless it's really necessary.\n535     \"\"\"\n536     import sys\n537 \n538     np = sys.modules.get(\"numpy\")  # type: Any\n539     if np is not None:\n540         return isinstance(obj, np.ndarray)\n541     return False\n542 \n543 \n544 # builtin pytest.raises helper\n545 \n546 _E = TypeVar(\"_E\", bound=BaseException)\n547 \n548 \n549 @overload\n550 def raises(\n551     expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n552     *,\n553     match: \"Optional[Union[str, Pattern]]\" = ...\n554 ) -> \"RaisesContext[_E]\":\n555     ...  # pragma: no cover\n556 \n557 \n558 @overload  # noqa: F811\n559 def raises(  # noqa: F811\n560     expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n561     func: Callable,\n562     *args: Any,\n563     **kwargs: Any\n564 ) -> _pytest._code.ExceptionInfo[_E]:\n565     ...  # pragma: no cover\n566 \n567 \n568 def raises(  # noqa: F811\n569     expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n570     *args: Any,\n571     **kwargs: Any\n572 ) -> Union[\"RaisesContext[_E]\", _pytest._code.ExceptionInfo[_E]]:\n573     r\"\"\"\n574     Assert that a code block/function call raises ``expected_exception``\n575     or raise a failure exception otherwise.\n576 \n577     :kwparam match: if specified, a string containing a regular expression,\n578         or a regular expression object, that is tested against the string\n579         representation of the exception using ``re.search``. To match a literal\n580         string that may contain `special characters`__, the pattern can\n581         first be escaped with ``re.escape``.\n582 \n583         (This is only used when ``pytest.raises`` is used as a context manager,\n584         and passed through to the function otherwise.\n585         When using ``pytest.raises`` as a function, you can use:\n586         ``pytest.raises(Exc, func, match=\"passed on\").match(\"my pattern\")``.)\n587 \n588         __ https://docs.python.org/3/library/re.html#regular-expression-syntax\n589 \n590     .. currentmodule:: _pytest._code\n591 \n592     Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n593     type::\n594 \n595         >>> with raises(ZeroDivisionError):\n596         ...    1/0\n597 \n598     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n599     above), or no exception at all, the check will fail instead.\n600 \n601     You can also use the keyword argument ``match`` to assert that the\n602     exception matches a text or regex::\n603 \n604         >>> with raises(ValueError, match='must be 0 or None'):\n605         ...     raise ValueError(\"value must be 0 or None\")\n606 \n607         >>> with raises(ValueError, match=r'must be \\d+$'):\n608         ...     raise ValueError(\"value must be 42\")\n609 \n610     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n611     details of the captured exception::\n612 \n613         >>> with raises(ValueError) as exc_info:\n614         ...     raise ValueError(\"value must be 42\")\n615         >>> assert exc_info.type is ValueError\n616         >>> assert exc_info.value.args[0] == \"value must be 42\"\n617 \n618     .. note::\n619 \n620        When using ``pytest.raises`` as a context manager, it's worthwhile to\n621        note that normal context manager rules apply and that the exception\n622        raised *must* be the final line in the scope of the context manager.\n623        Lines of code after that, within the scope of the context manager will\n624        not be executed. For example::\n625 \n626            >>> value = 15\n627            >>> with raises(ValueError) as exc_info:\n628            ...     if value > 10:\n629            ...         raise ValueError(\"value must be <= 10\")\n630            ...     assert exc_info.type is ValueError  # this will not execute\n631 \n632        Instead, the following approach must be taken (note the difference in\n633        scope)::\n634 \n635            >>> with raises(ValueError) as exc_info:\n636            ...     if value > 10:\n637            ...         raise ValueError(\"value must be <= 10\")\n638            ...\n639            >>> assert exc_info.type is ValueError\n640 \n641     **Using with** ``pytest.mark.parametrize``\n642 \n643     When using :ref:`pytest.mark.parametrize ref`\n644     it is possible to parametrize tests such that\n645     some runs raise an exception and others do not.\n646 \n647     See :ref:`parametrizing_conditional_raising` for an example.\n648 \n649     **Legacy form**\n650 \n651     It is possible to specify a callable by passing a to-be-called lambda::\n652 \n653         >>> raises(ZeroDivisionError, lambda: 1/0)\n654         <ExceptionInfo ...>\n655 \n656     or you can specify an arbitrary callable with arguments::\n657 \n658         >>> def f(x): return 1/x\n659         ...\n660         >>> raises(ZeroDivisionError, f, 0)\n661         <ExceptionInfo ...>\n662         >>> raises(ZeroDivisionError, f, x=0)\n663         <ExceptionInfo ...>\n664 \n665     The form above is fully supported but discouraged for new code because the\n666     context manager form is regarded as more readable and less error-prone.\n667 \n668     .. note::\n669         Similar to caught exception objects in Python, explicitly clearing\n670         local references to returned ``ExceptionInfo`` objects can\n671         help the Python interpreter speed up its garbage collection.\n672 \n673         Clearing those references breaks a reference cycle\n674         (``ExceptionInfo`` --> caught exception --> frame stack raising\n675         the exception --> current frame stack --> local variables -->\n676         ``ExceptionInfo``) which makes Python keep all objects referenced\n677         from that cycle (including all local variables in the current\n678         frame) alive until the next cyclic garbage collection run.\n679         More detailed information can be found in the official Python\n680         documentation for :ref:`the try statement <python:try>`.\n681     \"\"\"\n682     __tracebackhide__ = True\n683     for exc in filterfalse(\n684         inspect.isclass, always_iterable(expected_exception, BASE_TYPE)\n685     ):\n686         msg = \"exceptions must be derived from BaseException, not %s\"\n687         raise TypeError(msg % type(exc))\n688 \n689     message = \"DID NOT RAISE {}\".format(expected_exception)\n690 \n691     if not args:\n692         match = kwargs.pop(\"match\", None)\n693         if kwargs:\n694             msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n695             msg += \", \".join(sorted(kwargs))\n696             msg += \"\\nUse context-manager form instead?\"\n697             raise TypeError(msg)\n698         return RaisesContext(expected_exception, message, match)\n699     else:\n700         func = args[0]\n701         if not callable(func):\n702             raise TypeError(\n703                 \"{!r} object (type: {}) must be callable\".format(func, type(func))\n704             )\n705         try:\n706             func(*args[1:], **kwargs)\n707         except expected_exception as e:\n708             # We just caught the exception - there is a traceback.\n709             assert e.__traceback__ is not None\n710             return _pytest._code.ExceptionInfo.from_exc_info(\n711                 (type(e), e, e.__traceback__)\n712             )\n713     fail(message)\n714 \n715 \n716 # This doesn't work with mypy for now. Use fail.Exception instead.\n717 raises.Exception = fail.Exception  # type: ignore\n718 \n719 \n720 class RaisesContext(Generic[_E]):\n721     def __init__(\n722         self,\n723         expected_exception: Union[\"Type[_E]\", Tuple[\"Type[_E]\", ...]],\n724         message: str,\n725         match_expr: Optional[Union[str, \"Pattern\"]] = None,\n726     ) -> None:\n727         self.expected_exception = expected_exception\n728         self.message = message\n729         self.match_expr = match_expr\n730         self.excinfo = None  # type: Optional[_pytest._code.ExceptionInfo[_E]]\n731 \n732     def __enter__(self) -> _pytest._code.ExceptionInfo[_E]:\n733         self.excinfo = _pytest._code.ExceptionInfo.for_later()\n734         return self.excinfo\n735 \n736     def __exit__(\n737         self,\n738         exc_type: Optional[\"Type[BaseException]\"],\n739         exc_val: Optional[BaseException],\n740         exc_tb: Optional[TracebackType],\n741     ) -> bool:\n742         __tracebackhide__ = True\n743         if exc_type is None:\n744             fail(self.message)\n745         assert self.excinfo is not None\n746         if not issubclass(exc_type, self.expected_exception):\n747             return False\n748         # Cast to narrow the exception type now that it's verified.\n749         exc_info = cast(\n750             Tuple[\"Type[_E]\", _E, TracebackType], (exc_type, exc_val, exc_tb)\n751         )\n752         self.excinfo.fill_unfilled(exc_info)\n753         if self.match_expr is not None:\n754             self.excinfo.match(self.match_expr)\n755         return True\n",
        "intended_behavior": "The code at this location should be enhanced to provide clearer feedback when a match fails due to the presence of special characters in the strings being compared. Specifically, when match is not None and contains characters that have special meaning in regular expressions, such as parentheses, the error message should: 1. Inform the user that the string being matched is treated as a regular expression. 2. Suggest that if the matching fails due to literal characters that have special meanings in regex (such as parentheses), the user should consider escaping those characters or using a raw string literal if they did not intend for a regex match. 3. This improvement should be made without altering the existing functionality for regular users who are correctly using the match parameter as intended (with properly escaped characters or regex patterns). This enhancement aims to make the debugging process more intuitive, particularly for cases where users may unintentionally include regex-special characters in their strings. Additionally, this should preserve the utility of using regular expressions in the match parameter for more advanced use cases."
    }
]