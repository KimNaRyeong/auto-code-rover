2025-10-17 16:41:08.358 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 16:41:11.180 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=505, output_tokens=12, cost=0.005410
2025-10-17 16:41:23.796 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=685, output_tokens=488, cost=0.021490
2025-10-17 16:41:24.783 | INFO     | registered non reproducing test 0
2025-10-17 16:41:41.073 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1522, output_tokens=551, cost=0.031750
2025-10-17 16:41:53.520 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1522, output_tokens=546, cost=0.031600
2025-10-17 16:41:54.492 | INFO     | registered non reproducing test 2
2025-10-17 16:41:54.492 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 16:41:54.498 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:41:59.731 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=803, output_tokens=187, cost=0.013640
2025-10-17 16:41:59.737 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:42:01.142 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=541, output_tokens=20, cost=0.006010
2025-10-17 16:42:01.144 | DEBUG    | Extracted a valid json.
2025-10-17 16:42:01.144 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"approx\")"],
    "bug_locations": []
}
2025-10-17 16:42:01.197 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 16:42:01.198 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 16:42:19.688 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4056, output_tokens=664, cost=0.060480
2025-10-17 16:42:19.700 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 16:42:26.564 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4936, output_tokens=244, cost=0.056680
2025-10-17 16:42:26.570 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 16:42:33.608 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=598, output_tokens=195, cost=0.011830
2025-10-17 16:42:33.609 | DEBUG    | Extracted a valid json.
2025-10-17 16:42:33.609 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "src/_pytest/python_api.py",
            "class": "approx",
            "method": "",
            "intended_behavior": "When `approx` encounters a dictionary value or a sequence element that is `None`, it should not raise a `TypeError`. Instead, it should gracefully compare the value to `None` directly, effectively treating it as a strict equality comparison. This update would not alter the existing functionality for numeric and other types that `approx` currently supports. For numeric comparisons, `approx` should continue to work as it does now, using specified tolerances to determine equality. The change would specifically cater to the case where `None` is part of a complex structure like a dictionary or a list that is being compared, making `approx` more versatile and user-friendly for testing scenarios where optional values represented by `None` are expected."
        }
    ]
}
2025-10-17 16:42:33.618 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/python_api.py</file>
<class>None</class>
<method>None</method>
<code>
1 import math
2 import pprint
3 from collections.abc import Collection
4 from collections.abc import Sized
5 from decimal import Decimal
6 from numbers import Complex
7 from types import TracebackType
8 from typing import Any
9 from typing import Callable
10 from typing import cast
11 from typing import ContextManager
12 from typing import final
13 from typing import List
14 from typing import Mapping
15 from typing import Optional
16 from typing import overload
17 from typing import Pattern
18 from typing import Sequence
19 from typing import Tuple
20 from typing import Type
21 from typing import TYPE_CHECKING
22 from typing import TypeVar
23 from typing import Union
24 
25 import _pytest._code
26 from _pytest.compat import STRING_TYPES
27 from _pytest.outcomes import fail
28 
29 if TYPE_CHECKING:
30     from numpy import ndarray
31 
32 
33 def _non_numeric_type_error(value, at: Optional[str]) -> TypeError:
34     at_str = f" at {at}" if at else ""
35     return TypeError(
36         "cannot make approximate comparisons to non-numeric values: {!r} {}".format(
37             value, at_str
38         )
39     )
40 
41 
42 def _compare_approx(
43     full_object: object,
44     message_data: Sequence[Tuple[str, str, str]],
45     number_of_elements: int,
46     different_ids: Sequence[object],
47     max_abs_diff: float,
48     max_rel_diff: float,
49 ) -> List[str]:
50     message_list = list(message_data)
51     message_list.insert(0, ("Index", "Obtained", "Expected"))
52     max_sizes = [0, 0, 0]
53     for index, obtained, expected in message_list:
54         max_sizes[0] = max(max_sizes[0], len(index))
55         max_sizes[1] = max(max_sizes[1], len(obtained))
56         max_sizes[2] = max(max_sizes[2], len(expected))
57     explanation = [
58         f"comparison failed. Mismatched elements: {len(different_ids)} / {number_of_elements}:",
59         f"Max absolute difference: {max_abs_diff}",
60         f"Max relative difference: {max_rel_diff}",
61     ] + [
62         f"{indexes:<{max_sizes[0]}} | {obtained:<{max_sizes[1]}} | {expected:<{max_sizes[2]}}"
63         for indexes, obtained, expected in message_list
64     ]
65     return explanation
66 
67 
68 # builtin pytest.approx helper
69 
70 
71 class ApproxBase:
72     """Provide shared utilities for making approximate comparisons between
73     numbers or sequences of numbers."""
74 
75     # Tell numpy to use our `__eq__` operator instead of its.
76     __array_ufunc__ = None
77     __array_priority__ = 100
78 
79     def __init__(self, expected, rel=None, abs=None, nan_ok: bool = False) -> None:
80         __tracebackhide__ = True
81         self.expected = expected
82         self.abs = abs
83         self.rel = rel
84         self.nan_ok = nan_ok
85         self._check_type()
86 
87     def __repr__(self) -> str:
88         raise NotImplementedError
89 
90     def _repr_compare(self, other_side: Any) -> List[str]:
91         return [
92             "comparison failed",
93             f"Obtained: {other_side}",
94             f"Expected: {self}",
95         ]
96 
97     def __eq__(self, actual) -> bool:
98         return all(
99             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)
100         )
101 
102     def __bool__(self):
103         __tracebackhide__ = True
104         raise AssertionError(
105             "approx() is not supported in a boolean context.\nDid you mean: `assert a == approx(b)`?"
106         )
107 
108     # Ignore type because of https://github.com/python/mypy/issues/4266.
109     __hash__ = None  # type: ignore
110 
111     def __ne__(self, actual) -> bool:
112         return not (actual == self)
113 
114     def _approx_scalar(self, x) -> "ApproxScalar":
115         if isinstance(x, Decimal):
116             return ApproxDecimal(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)
117         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)
118 
119     def _yield_comparisons(self, actual):
120         """Yield all the pairs of numbers to be compared.
121 
122         This is used to implement the `__eq__` method.
123         """
124         raise NotImplementedError
125 
126     def _check_type(self) -> None:
127         """Raise a TypeError if the expected value is not a valid type."""
128         # This is only a concern if the expected value is a sequence.  In every
129         # other case, the approx() function ensures that the expected value has
130         # a numeric type.  For this reason, the default is to do nothing.  The
131         # classes that deal with sequences should reimplement this method to
132         # raise if there are any non-numeric elements in the sequence.
133 
134 
135 def _recursive_sequence_map(f, x):
136     """Recursively map a function over a sequence of arbitrary depth"""
137     if isinstance(x, (list, tuple)):
138         seq_type = type(x)
139         return seq_type(_recursive_sequence_map(f, xi) for xi in x)
140     else:
141         return f(x)
142 
143 
144 class ApproxNumpy(ApproxBase):
145     """Perform approximate comparisons where the expected value is numpy array."""
146 
147     def __repr__(self) -> str:
148         list_scalars = _recursive_sequence_map(
149             self._approx_scalar, self.expected.tolist()
150         )
151         return f"approx({list_scalars!r})"
152 
153     def _repr_compare(self, other_side: "ndarray") -> List[str]:
154         import itertools
155         import math
156 
157         def get_value_from_nested_list(
158             nested_list: List[Any], nd_index: Tuple[Any, ...]
159         ) -> Any:
160             """
161             Helper function to get the value out of a nested list, given an n-dimensional index.
162             This mimics numpy's indexing, but for raw nested python lists.
163             """
164             value: Any = nested_list
165             for i in nd_index:
166                 value = value[i]
167             return value
168 
169         np_array_shape = self.expected.shape
170         approx_side_as_seq = _recursive_sequence_map(
171             self._approx_scalar, self.expected.tolist()
172         )
173 
174         if np_array_shape != other_side.shape:
175             return [
176                 "Impossible to compare arrays with different shapes.",
177                 f"Shapes: {np_array_shape} and {other_side.shape}",
178             ]
179 
180         number_of_elements = self.expected.size
181         max_abs_diff = -math.inf
182         max_rel_diff = -math.inf
183         different_ids = []
184         for index in itertools.product(*(range(i) for i in np_array_shape)):
185             approx_value = get_value_from_nested_list(approx_side_as_seq, index)
186             other_value = get_value_from_nested_list(other_side, index)
187             if approx_value != other_value:
188                 abs_diff = abs(approx_value.expected - other_value)
189                 max_abs_diff = max(max_abs_diff, abs_diff)
190                 if other_value == 0.0:
191                     max_rel_diff = math.inf
192                 else:
193                     max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))
194                 different_ids.append(index)
195 
196         message_data = [
197             (
198                 str(index),
199                 str(get_value_from_nested_list(other_side, index)),
200                 str(get_value_from_nested_list(approx_side_as_seq, index)),
201             )
202             for index in different_ids
203         ]
204         return _compare_approx(
205             self.expected,
206             message_data,
207             number_of_elements,
208             different_ids,
209             max_abs_diff,
210             max_rel_diff,
211         )
212 
213     def __eq__(self, actual) -> bool:
214         import numpy as np
215 
216         # self.expected is supposed to always be an array here.
217 
218         if not np.isscalar(actual):
219             try:
220                 actual = np.asarray(actual)
221             except Exception as e:
222                 raise TypeError(f"cannot compare '{actual}' to numpy.ndarray") from e
223 
224         if not np.isscalar(actual) and actual.shape != self.expected.shape:
225             return False
226 
227         return super().__eq__(actual)
228 
229     def _yield_comparisons(self, actual):
230         import numpy as np
231 
232         # `actual` can either be a numpy array or a scalar, it is treated in
233         # `__eq__` before being passed to `ApproxBase.__eq__`, which is the
234         # only method that calls this one.
235 
236         if np.isscalar(actual):
237             for i in np.ndindex(self.expected.shape):
238                 yield actual, self.expected[i].item()
239         else:
240             for i in np.ndindex(self.expected.shape):
241                 yield actual[i].item(), self.expected[i].item()
242 
243 
244 class ApproxMapping(ApproxBase):
245     """Perform approximate comparisons where the expected value is a mapping
246     with numeric values (the keys can be anything)."""
247 
248     def __repr__(self) -> str:
249         return "approx({!r})".format(
250             {k: self._approx_scalar(v) for k, v in self.expected.items()}
251         )
252 
253     def _repr_compare(self, other_side: Mapping[object, float]) -> List[str]:
254         import math
255 
256         approx_side_as_map = {
257             k: self._approx_scalar(v) for k, v in self.expected.items()
258         }
259 
260         number_of_elements = len(approx_side_as_map)
261         max_abs_diff = -math.inf
262         max_rel_diff = -math.inf
263         different_ids = []
264         for (approx_key, approx_value), other_value in zip(
265             approx_side_as_map.items(), other_side.values()
266         ):
267             if approx_value != other_value:
268                 max_abs_diff = max(
269                     max_abs_diff, abs(approx_value.expected - other_value)
270                 )
271                 if approx_value.expected == 0.0:
272                     max_rel_diff = math.inf
273                 else:
274                     max_rel_diff = max(
275                         max_rel_diff,
276                         abs(
277                             (approx_value.expected - other_value)
278                             / approx_value.expected
279                         ),
280                     )
281                 different_ids.append(approx_key)
282 
283         message_data = [
284             (str(key), str(other_side[key]), str(approx_side_as_map[key]))
285             for key in different_ids
286         ]
287 
288         return _compare_approx(
289             self.expected,
290             message_data,
291             number_of_elements,
292             different_ids,
293             max_abs_diff,
294             max_rel_diff,
295         )
296 
297     def __eq__(self, actual) -> bool:
298         try:
299             if set(actual.keys()) != set(self.expected.keys()):
300                 return False
301         except AttributeError:
302             return False
303 
304         return super().__eq__(actual)
305 
306     def _yield_comparisons(self, actual):
307         for k in self.expected.keys():
308             yield actual[k], self.expected[k]
309 
310     def _check_type(self) -> None:
311         __tracebackhide__ = True
312         for key, value in self.expected.items():
313             if isinstance(value, type(self.expected)):
314                 msg = "pytest.approx() does not support nested dictionaries: key={!r} value={!r}\n  full mapping={}"
315                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))
316 
317 
318 class ApproxSequenceLike(ApproxBase):
319     """Perform approximate comparisons where the expected value is a sequence of numbers."""
320 
321     def __repr__(self) -> str:
322         seq_type = type(self.expected)
323         if seq_type not in (tuple, list):
324             seq_type = list
325         return "approx({!r})".format(
326             seq_type(self._approx_scalar(x) for x in self.expected)
327         )
328 
329     def _repr_compare(self, other_side: Sequence[float]) -> List[str]:
330         import math
331 
332         if len(self.expected) != len(other_side):
333             return [
334                 "Impossible to compare lists with different sizes.",
335                 f"Lengths: {len(self.expected)} and {len(other_side)}",
336             ]
337 
338         approx_side_as_map = _recursive_sequence_map(self._approx_scalar, self.expected)
339 
340         number_of_elements = len(approx_side_as_map)
341         max_abs_diff = -math.inf
342         max_rel_diff = -math.inf
343         different_ids = []
344         for i, (approx_value, other_value) in enumerate(
345             zip(approx_side_as_map, other_side)
346         ):
347             if approx_value != other_value:
348                 abs_diff = abs(approx_value.expected - other_value)
349                 max_abs_diff = max(max_abs_diff, abs_diff)
350                 if other_value == 0.0:
351                     max_rel_diff = math.inf
352                 else:
353                     max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))
354                 different_ids.append(i)
355 
356         message_data = [
357             (str(i), str(other_side[i]), str(approx_side_as_map[i]))
358             for i in different_ids
359         ]
360 
361         return _compare_approx(
362             self.expected,
363             message_data,
364             number_of_elements,
365             different_ids,
366             max_abs_diff,
367             max_rel_diff,
368         )
369 
370     def __eq__(self, actual) -> bool:
371         try:
372             if len(actual) != len(self.expected):
373                 return False
374         except TypeError:
375             return False
376         return super().__eq__(actual)
377 
378     def _yield_comparisons(self, actual):
379         return zip(actual, self.expected)
380 
381     def _check_type(self) -> None:
382         __tracebackhide__ = True
383         for index, x in enumerate(self.expected):
384             if isinstance(x, type(self.expected)):
385                 msg = "pytest.approx() does not support nested data structures: {!r} at index {}\n  full sequence: {}"
386                 raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))
387 
388 
389 class ApproxScalar(ApproxBase):
390     """Perform approximate comparisons where the expected value is a single number."""
391 
392     # Using Real should be better than this Union, but not possible yet:
393     # https://github.com/python/typeshed/pull/3108
394     DEFAULT_ABSOLUTE_TOLERANCE: Union[float, Decimal] = 1e-12
395     DEFAULT_RELATIVE_TOLERANCE: Union[float, Decimal] = 1e-6
396 
397     def __repr__(self) -> str:
398         """Return a string communicating both the expected value and the
399         tolerance for the comparison being made.
400 
401         For example, ``1.0 ± 1e-6``, ``(3+4j) ± 5e-6 ∠ ±180°``.
402         """
403         # Don't show a tolerance for values that aren't compared using
404         # tolerances, i.e. non-numerics and infinities. Need to call abs to
405         # handle complex numbers, e.g. (inf + 1j).
406         if (not isinstance(self.expected, (Complex, Decimal))) or math.isinf(
407             abs(self.expected)  # type: ignore[arg-type]
408         ):
409             return str(self.expected)
410 
411         # If a sensible tolerance can't be calculated, self.tolerance will
412         # raise a ValueError.  In this case, display '???'.
413         try:
414             vetted_tolerance = f"{self.tolerance:.1e}"
415             if (
416                 isinstance(self.expected, Complex)
417                 and self.expected.imag
418                 and not math.isinf(self.tolerance)
419             ):
420                 vetted_tolerance += " ∠ ±180°"
421         except ValueError:
422             vetted_tolerance = "???"
423 
424         return f"{self.expected} ± {vetted_tolerance}"
425 
426     def __eq__(self, actual) -> bool:
427         """Return whether the given value is equal to the expected value
428         within the pre-specified tolerance."""
429         asarray = _as_numpy_array(actual)
430         if asarray is not None:
431             # Call ``__eq__()`` manually to prevent infinite-recursion with
432             # numpy<1.13.  See #3748.
433             return all(self.__eq__(a) for a in asarray.flat)
434 
435         # Short-circuit exact equality.
436         if actual == self.expected:
437             return True
438 
439         # If either type is non-numeric, fall back to strict equality.
440         # NB: we need Complex, rather than just Number, to ensure that __abs__,
441         # __sub__, and __float__ are defined.
442         if not (
443             isinstance(self.expected, (Complex, Decimal))
444             and isinstance(actual, (Complex, Decimal))
445         ):
446             return False
447 
448         # Allow the user to control whether NaNs are considered equal to each
449         # other or not.  The abs() calls are for compatibility with complex
450         # numbers.
451         if math.isnan(abs(self.expected)):  # type: ignore[arg-type]
452             return self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]
453 
454         # Infinity shouldn't be approximately equal to anything but itself, but
455         # if there's a relative tolerance, it will be infinite and infinity
456         # will seem approximately equal to everything.  The equal-to-itself
457         # case would have been short circuited above, so here we can just
458         # return false if the expected value is infinite.  The abs() call is
459         # for compatibility with complex numbers.
460         if math.isinf(abs(self.expected)):  # type: ignore[arg-type]
461             return False
462 
463         # Return true if the two numbers are within the tolerance.
464         result: bool = abs(self.expected - actual) <= self.tolerance
465         return result
466 
467     # Ignore type because of https://github.com/python/mypy/issues/4266.
468     __hash__ = None  # type: ignore
469 
470     @property
471     def tolerance(self):
472         """Return the tolerance for the comparison.
473 
474         This could be either an absolute tolerance or a relative tolerance,
475         depending on what the user specified or which would be larger.
476         """
477 
478         def set_default(x, default):
479             return x if x is not None else default
480 
481         # Figure out what the absolute tolerance should be.  ``self.abs`` is
482         # either None or a value specified by the user.
483         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)
484 
485         if absolute_tolerance < 0:
486             raise ValueError(
487                 f"absolute tolerance can't be negative: {absolute_tolerance}"
488             )
489         if math.isnan(absolute_tolerance):
490             raise ValueError("absolute tolerance can't be NaN.")
491 
492         # If the user specified an absolute tolerance but not a relative one,
493         # just return the absolute tolerance.
494         if self.rel is None:
495             if self.abs is not None:
496                 return absolute_tolerance
497 
498         # Figure out what the relative tolerance should be.  ``self.rel`` is
499         # either None or a value specified by the user.  This is done after
500         # we've made sure the user didn't ask for an absolute tolerance only,
501         # because we don't want to raise errors about the relative tolerance if
502         # we aren't even going to use it.
503         relative_tolerance = set_default(
504             self.rel, self.DEFAULT_RELATIVE_TOLERANCE
505         ) * abs(self.expected)
506 
507         if relative_tolerance < 0:
508             raise ValueError(
509                 f"relative tolerance can't be negative: {relative_tolerance}"
510             )
511         if math.isnan(relative_tolerance):
512             raise ValueError("relative tolerance can't be NaN.")
513 
514         # Return the larger of the relative and absolute tolerances.
515         return max(relative_tolerance, absolute_tolerance)
516 
517 
518 class ApproxDecimal(ApproxScalar):
519     """Perform approximate comparisons where the expected value is a Decimal."""
520 
521     DEFAULT_ABSOLUTE_TOLERANCE = Decimal("1e-12")
522     DEFAULT_RELATIVE_TOLERANCE = Decimal("1e-6")
523 
524 
525 def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:
526     """Assert that two numbers (or two ordered sequences of numbers) are equal to each other
527     within some tolerance.
528 
529     Due to the :doc:`python:tutorial/floatingpoint`, numbers that we
530     would intuitively expect to be equal are not always so::
531 
532         >>> 0.1 + 0.2 == 0.3
533         False
534 
535     This problem is commonly encountered when writing tests, e.g. when making
536     sure that floating-point values are what you expect them to be.  One way to
537     deal with this problem is to assert that two floating-point numbers are
538     equal to within some appropriate tolerance::
539 
540         >>> abs((0.1 + 0.2) - 0.3) < 1e-6
541         True
542 
543     However, comparisons like this are tedious to write and difficult to
544     understand.  Furthermore, absolute comparisons like the one above are
545     usually discouraged because there's no tolerance that works well for all
546     situations.  ``1e-6`` is good for numbers around ``1``, but too small for
547     very big numbers and too big for very small ones.  It's better to express
548     the tolerance as a fraction of the expected value, but relative comparisons
549     like that are even more difficult to write correctly and concisely.
550 
551     The ``approx`` class performs floating-point comparisons using a syntax
552     that's as intuitive as possible::
553 
554         >>> from pytest import approx
555         >>> 0.1 + 0.2 == approx(0.3)
556         True
557 
558     The same syntax also works for ordered sequences of numbers::
559 
560         >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
561         True
562 
563     ``numpy`` arrays::
564 
565         >>> import numpy as np                                                          # doctest: +SKIP
566         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP
567         True
568 
569     And for a ``numpy`` array against a scalar::
570 
571         >>> import numpy as np                                         # doctest: +SKIP
572         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP
573         True
574 
575     Only ordered sequences are supported, because ``approx`` needs
576     to infer the relative position of the sequences without ambiguity. This means
577     ``sets`` and other unordered sequences are not supported.
578 
579     Finally, dictionary *values* can also be compared::
580 
581         >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
582         True
583 
584     The comparison will be true if both mappings have the same keys and their
585     respective values match the expected tolerances.
586 
587     **Tolerances**
588 
589     By default, ``approx`` considers numbers within a relative tolerance of
590     ``1e-6`` (i.e. one part in a million) of its expected value to be equal.
591     This treatment would lead to surprising results if the expected value was
592     ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.
593     To handle this case less surprisingly, ``approx`` also considers numbers
594     within an absolute tolerance of ``1e-12`` of its expected value to be
595     equal.  Infinity and NaN are special cases.  Infinity is only considered
596     equal to itself, regardless of the relative tolerance.  NaN is not
597     considered equal to anything by default, but you can make it be equal to
598     itself by setting the ``nan_ok`` argument to True.  (This is meant to
599     facilitate comparing arrays that use NaN to mean "no data".)
600 
601     Both the relative and absolute tolerances can be changed by passing
602     arguments to the ``approx`` constructor::
603 
604         >>> 1.0001 == approx(1)
605         False
606         >>> 1.0001 == approx(1, rel=1e-3)
607         True
608         >>> 1.0001 == approx(1, abs=1e-3)
609         True
610 
611     If you specify ``abs`` but not ``rel``, the comparison will not consider
612     the relative tolerance at all.  In other words, two numbers that are within
613     the default relative tolerance of ``1e-6`` will still be considered unequal
614     if they exceed the specified absolute tolerance.  If you specify both
615     ``abs`` and ``rel``, the numbers will be considered equal if either
616     tolerance is met::
617 
618         >>> 1 + 1e-8 == approx(1)
619         True
620         >>> 1 + 1e-8 == approx(1, abs=1e-12)
621         False
622         >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
623         True
624 
625     You can also use ``approx`` to compare nonnumeric types, or dicts and
626     sequences containing nonnumeric types, in which case it falls back to
627     strict equality. This can be useful for comparing dicts and sequences that
628     can contain optional values::
629 
630         >>> {"required": 1.0000005, "optional": None} == approx({"required": 1, "optional": None})
631         True
632         >>> [None, 1.0000005] == approx([None,1])
633         True
634         >>> ["foo", 1.0000005] == approx([None,1])
635         False
636 
637     If you're thinking about using ``approx``, then you might want to know how
638     it compares to other good ways of comparing floating-point numbers.  All of
639     these algorithms are based on relative and absolute tolerances and should
640     agree for the most part, but they do have meaningful differences:
641 
642     - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative
643       tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute
644       tolerance is met.  Because the relative tolerance is calculated w.r.t.
645       both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor
646       ``b`` is a "reference value").  You have to specify an absolute tolerance
647       if you want to compare to ``0.0`` because there is no tolerance by
648       default.  More information: :py:func:`math.isclose`.
649 
650     - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference
651       between ``a`` and ``b`` is less that the sum of the relative tolerance
652       w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance
653       is only calculated w.r.t. ``b``, this test is asymmetric and you can
654       think of ``b`` as the reference value.  Support for comparing sequences
655       is provided by :py:func:`numpy.allclose`.  More information:
656       :std:doc:`numpy:reference/generated/numpy.isclose`.
657 
658     - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``
659       are within an absolute tolerance of ``1e-7``.  No relative tolerance is
660       considered , so this function is not appropriate for very large or very
661       small numbers.  Also, it's only available in subclasses of ``unittest.TestCase``
662       and it's ugly because it doesn't follow PEP8.  More information:
663       :py:meth:`unittest.TestCase.assertAlmostEqual`.
664 
665     - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative
666       tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.
667       Because the relative tolerance is only calculated w.r.t. ``b``, this test
668       is asymmetric and you can think of ``b`` as the reference value.  In the
669       special case that you explicitly specify an absolute tolerance but not a
670       relative tolerance, only the absolute tolerance is considered.
671 
672     .. note::
673 
674         ``approx`` can handle numpy arrays, but we recommend the
675         specialised test helpers in :std:doc:`numpy:reference/routines.testing`
676         if you need support for comparisons, NaNs, or ULP-based tolerances.
677 
678         To match strings using regex, you can use
679         `Matches <https://github.com/asottile/re-assert#re_assertmatchespattern-str-args-kwargs>`_
680         from the
681         `re_assert package <https://github.com/asottile/re-assert>`_.
682 
683     .. warning::
684 
685        .. versionchanged:: 3.2
686 
687        In order to avoid inconsistent behavior, :py:exc:`TypeError` is
688        raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.
689        The example below illustrates the problem::
690 
691            assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)
692            assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)
693 
694        In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``
695        to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to
696        comparison. This is because the call hierarchy of rich comparisons
697        follows a fixed behavior. More information: :py:meth:`object.__ge__`
698 
699     .. versionchanged:: 3.7.1
700        ``approx`` raises ``TypeError`` when it encounters a dict value or
701        sequence element of nonnumeric type.
702 
703     .. versionchanged:: 6.1.0
704        ``approx`` falls back to strict equality for nonnumeric types instead
705        of raising ``TypeError``.
706     """
707 
708     # Delegate the comparison to a class that knows how to deal with the type
709     # of the expected value (e.g. int, float, list, dict, numpy.array, etc).
710     #
711     # The primary responsibility of these classes is to implement ``__eq__()``
712     # and ``__repr__()``.  The former is used to actually check if some
713     # "actual" value is equivalent to the given expected value within the
714     # allowed tolerance.  The latter is used to show the user the expected
715     # value and tolerance, in the case that a test failed.
716     #
717     # The actual logic for making approximate comparisons can be found in
718     # ApproxScalar, which is used to compare individual numbers.  All of the
719     # other Approx classes eventually delegate to this class.  The ApproxBase
720     # class provides some convenient methods and overloads, but isn't really
721     # essential.
722 
723     __tracebackhide__ = True
724 
725     if isinstance(expected, Decimal):
726         cls: Type[ApproxBase] = ApproxDecimal
727     elif isinstance(expected, Mapping):
728         cls = ApproxMapping
729     elif _is_numpy_array(expected):
730         expected = _as_numpy_array(expected)
731         cls = ApproxNumpy
732     elif (
733         hasattr(expected, "__getitem__")
734         and isinstance(expected, Sized)
735         # Type ignored because the error is wrong -- not unreachable.
736         and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]
737     ):
738         cls = ApproxSequenceLike
739     elif (
740         isinstance(expected, Collection)
741         # Type ignored because the error is wrong -- not unreachable.
742         and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]
743     ):
744         msg = f"pytest.approx() only supports ordered sequences, but got: {repr(expected)}"
745         raise TypeError(msg)
746     else:
747         cls = ApproxScalar
748 
749     return cls(expected, rel, abs, nan_ok)
750 
751 
752 def _is_numpy_array(obj: object) -> bool:
753     """
754     Return true if the given object is implicitly convertible to ndarray,
755     and numpy is already imported.
756     """
757     return _as_numpy_array(obj) is not None
758 
759 
760 def _as_numpy_array(obj: object) -> Optional["ndarray"]:
761     """
762     Return an ndarray if the given object is implicitly convertible to ndarray,
763     and numpy is already imported, otherwise None.
764     """
765     import sys
766 
767     np: Any = sys.modules.get("numpy")
768     if np is not None:
769         # avoid infinite recursion on numpy scalars, which have __array__
770         if np.isscalar(obj):
771             return None
772         elif isinstance(obj, np.ndarray):
773             return obj
774         elif hasattr(obj, "__array__") or hasattr("obj", "__array_interface__"):
775             return np.asarray(obj)
776     return None
777 
778 
779 # builtin pytest.raises helper
780 
781 E = TypeVar("E", bound=BaseException)
782 
783 
784 @overload
785 def raises(
786     expected_exception: Union[Type[E], Tuple[Type[E], ...]],
787     *,
788     match: Optional[Union[str, Pattern[str]]] = ...,
789 ) -> "RaisesContext[E]":
790     ...
791 
792 
793 @overload
794 def raises(  # noqa: F811
795     expected_exception: Union[Type[E], Tuple[Type[E], ...]],
796     func: Callable[..., Any],
797     *args: Any,
798     **kwargs: Any,
799 ) -> _pytest._code.ExceptionInfo[E]:
800     ...
801 
802 
803 def raises(  # noqa: F811
804     expected_exception: Union[Type[E], Tuple[Type[E], ...]], *args: Any, **kwargs: Any
805 ) -> Union["RaisesContext[E]", _pytest._code.ExceptionInfo[E]]:
806     r"""Assert that a code block/function call raises an exception.
807 
808     :param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:
809         The expected exception type, or a tuple if one of multiple possible
810         exception types are expected.
811     :kwparam str | typing.Pattern[str] | None match:
812         If specified, a string containing a regular expression,
813         or a regular expression object, that is tested against the string
814         representation of the exception using :func:`re.search`.
815 
816         To match a literal string that may contain :ref:`special characters
817         <re-syntax>`, the pattern can first be escaped with :func:`re.escape`.
818 
819         (This is only used when :py:func:`pytest.raises` is used as a context manager,
820         and passed through to the function otherwise.
821         When using :py:func:`pytest.raises` as a function, you can use:
822         ``pytest.raises(Exc, func, match="passed on").match("my pattern")``.)
823 
824     .. currentmodule:: _pytest._code
825 
826     Use ``pytest.raises`` as a context manager, which will capture the exception of the given
827     type::
828 
829         >>> import pytest
830         >>> with pytest.raises(ZeroDivisionError):
831         ...    1/0
832 
833     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example
834     above), or no exception at all, the check will fail instead.
835 
836     You can also use the keyword argument ``match`` to assert that the
837     exception matches a text or regex::
838 
839         >>> with pytest.raises(ValueError, match='must be 0 or None'):
840         ...     raise ValueError("value must be 0 or None")
841 
842         >>> with pytest.raises(ValueError, match=r'must be \d+$'):
843         ...     raise ValueError("value must be 42")
844 
845     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the
846     details of the captured exception::
847 
848         >>> with pytest.raises(ValueError) as exc_info:
849         ...     raise ValueError("value must be 42")
850         >>> assert exc_info.type is ValueError
851         >>> assert exc_info.value.args[0] == "value must be 42"
852 
853     .. note::
854 
855        When using ``pytest.raises`` as a context manager, it's worthwhile to
856        note that normal context manager rules apply and that the exception
857        raised *must* be the final line in the scope of the context manager.
858        Lines of code after that, within the scope of the context manager will
859        not be executed. For example::
860 
861            >>> value = 15
862            >>> with pytest.raises(ValueError) as exc_info:
863            ...     if value > 10:
864            ...         raise ValueError("value must be <= 10")
865            ...     assert exc_info.type is ValueError  # this will not execute
866 
867        Instead, the following approach must be taken (note the difference in
868        scope)::
869 
870            >>> with pytest.raises(ValueError) as exc_info:
871            ...     if value > 10:
872            ...         raise ValueError("value must be <= 10")
873            ...
874            >>> assert exc_info.type is ValueError
875 
876     **Using with** ``pytest.mark.parametrize``
877 
878     When using :ref:`pytest.mark.parametrize ref`
879     it is possible to parametrize tests such that
880     some runs raise an exception and others do not.
881 
882     See :ref:`parametrizing_conditional_raising` for an example.
883 
884     **Legacy form**
885 
886     It is possible to specify a callable by passing a to-be-called lambda::
887 
888         >>> raises(ZeroDivisionError, lambda: 1/0)
889         <ExceptionInfo ...>
890 
891     or you can specify an arbitrary callable with arguments::
892 
893         >>> def f(x): return 1/x
894         ...
895         >>> raises(ZeroDivisionError, f, 0)
896         <ExceptionInfo ...>
897         >>> raises(ZeroDivisionError, f, x=0)
898         <ExceptionInfo ...>
899 
900     The form above is fully supported but discouraged for new code because the
901     context manager form is regarded as more readable and less error-prone.
902 
903     .. note::
904         Similar to caught exception objects in Python, explicitly clearing
905         local references to returned ``ExceptionInfo`` objects can
906         help the Python interpreter speed up its garbage collection.
907 
908         Clearing those references breaks a reference cycle
909         (``ExceptionInfo`` --> caught exception --> frame stack raising
910         the exception --> current frame stack --> local variables -->
911         ``ExceptionInfo``) which makes Python keep all objects referenced
912         from that cycle (including all local variables in the current
913         frame) alive until the next cyclic garbage collection run.
914         More detailed information can be found in the official Python
915         documentation for :ref:`the try statement <python:try>`.
916     """
917     __tracebackhide__ = True
918 
919     if not expected_exception:
920         raise ValueError(
921             f"Expected an exception type or a tuple of exception types, but got `{expected_exception!r}`. "
922             f"Raising exceptions is already understood as failing the test, so you don't need "
923             f"any special code to say 'this should never raise an exception'."
924         )
925     if isinstance(expected_exception, type):
926         expected_exceptions: Tuple[Type[E], ...] = (expected_exception,)
927     else:
928         expected_exceptions = expected_exception
929     for exc in expected_exceptions:
930         if not isinstance(exc, type) or not issubclass(exc, BaseException):
931             msg = "expected exception must be a BaseException type, not {}"  # type: ignore[unreachable]
932             not_a = exc.__name__ if isinstance(exc, type) else type(exc).__name__
933             raise TypeError(msg.format(not_a))
934 
935     message = f"DID NOT RAISE {expected_exception}"
936 
937     if not args:
938         match: Optional[Union[str, Pattern[str]]] = kwargs.pop("match", None)
939         if kwargs:
940             msg = "Unexpected keyword arguments passed to pytest.raises: "
941             msg += ", ".join(sorted(kwargs))
942             msg += "\nUse context-manager form instead?"
943             raise TypeError(msg)
944         return RaisesContext(expected_exception, message, match)
945     else:
946         func = args[0]
947         if not callable(func):
948             raise TypeError(f"{func!r} object (type: {type(func)}) must be callable")
949         try:
950             func(*args[1:], **kwargs)
951         except expected_exception as e:
952             return _pytest._code.ExceptionInfo.from_exception(e)
953     fail(message)
954 
955 
956 # This doesn't work with mypy for now. Use fail.Exception instead.
957 raises.Exception = fail.Exception  # type: ignore
958 
959 
960 @final
961 class RaisesContext(ContextManager[_pytest._code.ExceptionInfo[E]]):
962     def __init__(
963         self,
964         expected_exception: Union[Type[E], Tuple[Type[E], ...]],
965         message: str,
966         match_expr: Optional[Union[str, Pattern[str]]] = None,
967     ) -> None:
968         self.expected_exception = expected_exception
969         self.message = message
970         self.match_expr = match_expr
971         self.excinfo: Optional[_pytest._code.ExceptionInfo[E]] = None
972 
973     def __enter__(self) -> _pytest._code.ExceptionInfo[E]:
974         self.excinfo = _pytest._code.ExceptionInfo.for_later()
975         return self.excinfo
976 
977     def __exit__(
978         self,
979         exc_type: Optional[Type[BaseException]],
980         exc_val: Optional[BaseException],
981         exc_tb: Optional[TracebackType],
982     ) -> bool:
983         __tracebackhide__ = True
984         if exc_type is None:
985             fail(self.message)
986         assert self.excinfo is not None
987         if not issubclass(exc_type, self.expected_exception):
988             return False
989         # Cast to narrow the exception type now that it's verified.
990         exc_info = cast(Tuple[Type[E], E, TracebackType], (exc_type, exc_val, exc_tb))
991         self.excinfo.fill_unfilled(exc_info)
992         if self.match_expr is not None:
993             self.excinfo.match(self.match_expr)
994         return True

</code><intended_behavior>When `approx` encounters a dictionary value or a sequence element that is `None`, it should not raise a `TypeError`. Instead, it should gracefully compare the value to `None` directly, effectively treating it as a strict equality comparison. This update would not alter the existing functionality for numeric and other types that `approx` currently supports. For numeric comparisons, `approx` should continue to work as it does now, using specified tolerances to determine equality. The change would specifically cater to the case where `None` is part of a complex structure like a dictionary or a list that is being compared, making `approx` more versatile and user-friendly for testing scenarios where optional values represented by `None` are expected.</intended_behavior>]
2025-10-17 16:42:33.618 | INFO     | Search completed. Bug locations: [<file>src/_pytest/python_api.py</file>
<class>None</class>
<method>None</method>
<code>
1 import math
2 import pprint
3 from collections.abc import Collection
4 from collections.abc import Sized
5 from decimal import Decimal
6 from numbers import Complex
7 from types import TracebackType
8 from typing import Any
9 from typing import Callable
10 from typing import cast
11 from typing import ContextManager
12 from typing import final
13 from typing import List
14 from typing import Mapping
15 from typing import Optional
16 from typing import overload
17 from typing import Pattern
18 from typing import Sequence
19 from typing import Tuple
20 from typing import Type
21 from typing import TYPE_CHECKING
22 from typing import TypeVar
23 from typing import Union
24 
25 import _pytest._code
26 from _pytest.compat import STRING_TYPES
27 from _pytest.outcomes import fail
28 
29 if TYPE_CHECKING:
30     from numpy import ndarray
31 
32 
33 def _non_numeric_type_error(value, at: Optional[str]) -> TypeError:
34     at_str = f" at {at}" if at else ""
35     return TypeError(
36         "cannot make approximate comparisons to non-numeric values: {!r} {}".format(
37             value, at_str
38         )
39     )
40 
41 
42 def _compare_approx(
43     full_object: object,
44     message_data: Sequence[Tuple[str, str, str]],
45     number_of_elements: int,
46     different_ids: Sequence[object],
47     max_abs_diff: float,
48     max_rel_diff: float,
49 ) -> List[str]:
50     message_list = list(message_data)
51     message_list.insert(0, ("Index", "Obtained", "Expected"))
52     max_sizes = [0, 0, 0]
53     for index, obtained, expected in message_list:
54         max_sizes[0] = max(max_sizes[0], len(index))
55         max_sizes[1] = max(max_sizes[1], len(obtained))
56         max_sizes[2] = max(max_sizes[2], len(expected))
57     explanation = [
58         f"comparison failed. Mismatched elements: {len(different_ids)} / {number_of_elements}:",
59         f"Max absolute difference: {max_abs_diff}",
60         f"Max relative difference: {max_rel_diff}",
61     ] + [
62         f"{indexes:<{max_sizes[0]}} | {obtained:<{max_sizes[1]}} | {expected:<{max_sizes[2]}}"
63         for indexes, obtained, expected in message_list
64     ]
65     return explanation
66 
67 
68 # builtin pytest.approx helper
69 
70 
71 class ApproxBase:
72     """Provide shared utilities for making approximate comparisons between
73     numbers or sequences of numbers."""
74 
75     # Tell numpy to use our `__eq__` operator instead of its.
76     __array_ufunc__ = None
77     __array_priority__ = 100
78 
79     def __init__(self, expected, rel=None, abs=None, nan_ok: bool = False) -> None:
80         __tracebackhide__ = True
81         self.expected = expected
82         self.abs = abs
83         self.rel = rel
84         self.nan_ok = nan_ok
85         self._check_type()
86 
87     def __repr__(self) -> str:
88         raise NotImplementedError
89 
90     def _repr_compare(self, other_side: Any) -> List[str]:
91         return [
92             "comparison failed",
93             f"Obtained: {other_side}",
94             f"Expected: {self}",
95         ]
96 
97     def __eq__(self, actual) -> bool:
98         return all(
99             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)
100         )
101 
102     def __bool__(self):
103         __tracebackhide__ = True
104         raise AssertionError(
105             "approx() is not supported in a boolean context.\nDid you mean: `assert a == approx(b)`?"
106         )
107 
108     # Ignore type because of https://github.com/python/mypy/issues/4266.
109     __hash__ = None  # type: ignore
110 
111     def __ne__(self, actual) -> bool:
112         return not (actual == self)
113 
114     def _approx_scalar(self, x) -> "ApproxScalar":
115         if isinstance(x, Decimal):
116             return ApproxDecimal(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)
117         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)
118 
119     def _yield_comparisons(self, actual):
120         """Yield all the pairs of numbers to be compared.
121 
122         This is used to implement the `__eq__` method.
123         """
124         raise NotImplementedError
125 
126     def _check_type(self) -> None:
127         """Raise a TypeError if the expected value is not a valid type."""
128         # This is only a concern if the expected value is a sequence.  In every
129         # other case, the approx() function ensures that the expected value has
130         # a numeric type.  For this reason, the default is to do nothing.  The
131         # classes that deal with sequences should reimplement this method to
132         # raise if there are any non-numeric elements in the sequence.
133 
134 
135 def _recursive_sequence_map(f, x):
136     """Recursively map a function over a sequence of arbitrary depth"""
137     if isinstance(x, (list, tuple)):
138         seq_type = type(x)
139         return seq_type(_recursive_sequence_map(f, xi) for xi in x)
140     else:
141         return f(x)
142 
143 
144 class ApproxNumpy(ApproxBase):
145     """Perform approximate comparisons where the expected value is numpy array."""
146 
147     def __repr__(self) -> str:
148         list_scalars = _recursive_sequence_map(
149             self._approx_scalar, self.expected.tolist()
150         )
151         return f"approx({list_scalars!r})"
152 
153     def _repr_compare(self, other_side: "ndarray") -> List[str]:
154         import itertools
155         import math
156 
157         def get_value_from_nested_list(
158             nested_list: List[Any], nd_index: Tuple[Any, ...]
159         ) -> Any:
160             """
161             Helper function to get the value out of a nested list, given an n-dimensional index.
162             This mimics numpy's indexing, but for raw nested python lists.
163             """
164             value: Any = nested_list
165             for i in nd_index:
166                 value = value[i]
167             return value
168 
169         np_array_shape = self.expected.shape
170         approx_side_as_seq = _recursive_sequence_map(
171             self._approx_scalar, self.expected.tolist()
172         )
173 
174         if np_array_shape != other_side.shape:
175             return [
176                 "Impossible to compare arrays with different shapes.",
177                 f"Shapes: {np_array_shape} and {other_side.shape}",
178             ]
179 
180         number_of_elements = self.expected.size
181         max_abs_diff = -math.inf
182         max_rel_diff = -math.inf
183         different_ids = []
184         for index in itertools.product(*(range(i) for i in np_array_shape)):
185             approx_value = get_value_from_nested_list(approx_side_as_seq, index)
186             other_value = get_value_from_nested_list(other_side, index)
187             if approx_value != other_value:
188                 abs_diff = abs(approx_value.expected - other_value)
189                 max_abs_diff = max(max_abs_diff, abs_diff)
190                 if other_value == 0.0:
191                     max_rel_diff = math.inf
192                 else:
193                     max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))
194                 different_ids.append(index)
195 
196         message_data = [
197             (
198                 str(index),
199                 str(get_value_from_nested_list(other_side, index)),
200                 str(get_value_from_nested_list(approx_side_as_seq, index)),
201             )
202             for index in different_ids
203         ]
204         return _compare_approx(
205             self.expected,
206             message_data,
207             number_of_elements,
208             different_ids,
209             max_abs_diff,
210             max_rel_diff,
211         )
212 
213     def __eq__(self, actual) -> bool:
214         import numpy as np
215 
216         # self.expected is supposed to always be an array here.
217 
218         if not np.isscalar(actual):
219             try:
220                 actual = np.asarray(actual)
221             except Exception as e:
222                 raise TypeError(f"cannot compare '{actual}' to numpy.ndarray") from e
223 
224         if not np.isscalar(actual) and actual.shape != self.expected.shape:
225             return False
226 
227         return super().__eq__(actual)
228 
229     def _yield_comparisons(self, actual):
230         import numpy as np
231 
232         # `actual` can either be a numpy array or a scalar, it is treated in
233         # `__eq__` before being passed to `ApproxBase.__eq__`, which is the
234         # only method that calls this one.
235 
236         if np.isscalar(actual):
237             for i in np.ndindex(self.expected.shape):
238                 yield actual, self.expected[i].item()
239         else:
240             for i in np.ndindex(self.expected.shape):
241                 yield actual[i].item(), self.expected[i].item()
242 
243 
244 class ApproxMapping(ApproxBase):
245     """Perform approximate comparisons where the expected value is a mapping
246     with numeric values (the keys can be anything)."""
247 
248     def __repr__(self) -> str:
249         return "approx({!r})".format(
250             {k: self._approx_scalar(v) for k, v in self.expected.items()}
251         )
252 
253     def _repr_compare(self, other_side: Mapping[object, float]) -> List[str]:
254         import math
255 
256         approx_side_as_map = {
257             k: self._approx_scalar(v) for k, v in self.expected.items()
258         }
259 
260         number_of_elements = len(approx_side_as_map)
261         max_abs_diff = -math.inf
262         max_rel_diff = -math.inf
263         different_ids = []
264         for (approx_key, approx_value), other_value in zip(
265             approx_side_as_map.items(), other_side.values()
266         ):
267             if approx_value != other_value:
268                 max_abs_diff = max(
269                     max_abs_diff, abs(approx_value.expected - other_value)
270                 )
271                 if approx_value.expected == 0.0:
272                     max_rel_diff = math.inf
273                 else:
274                     max_rel_diff = max(
275                         max_rel_diff,
276                         abs(
277                             (approx_value.expected - other_value)
278                             / approx_value.expected
279                         ),
280                     )
281                 different_ids.append(approx_key)
282 
283         message_data = [
284             (str(key), str(other_side[key]), str(approx_side_as_map[key]))
285             for key in different_ids
286         ]
287 
288         return _compare_approx(
289             self.expected,
290             message_data,
291             number_of_elements,
292             different_ids,
293             max_abs_diff,
294             max_rel_diff,
295         )
296 
297     def __eq__(self, actual) -> bool:
298         try:
299             if set(actual.keys()) != set(self.expected.keys()):
300                 return False
301         except AttributeError:
302             return False
303 
304         return super().__eq__(actual)
305 
306     def _yield_comparisons(self, actual):
307         for k in self.expected.keys():
308             yield actual[k], self.expected[k]
309 
310     def _check_type(self) -> None:
311         __tracebackhide__ = True
312         for key, value in self.expected.items():
313             if isinstance(value, type(self.expected)):
314                 msg = "pytest.approx() does not support nested dictionaries: key={!r} value={!r}\n  full mapping={}"
315                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))
316 
317 
318 class ApproxSequenceLike(ApproxBase):
319     """Perform approximate comparisons where the expected value is a sequence of numbers."""
320 
321     def __repr__(self) -> str:
322         seq_type = type(self.expected)
323         if seq_type not in (tuple, list):
324             seq_type = list
325         return "approx({!r})".format(
326             seq_type(self._approx_scalar(x) for x in self.expected)
327         )
328 
329     def _repr_compare(self, other_side: Sequence[float]) -> List[str]:
330         import math
331 
332         if len(self.expected) != len(other_side):
333             return [
334                 "Impossible to compare lists with different sizes.",
335                 f"Lengths: {len(self.expected)} and {len(other_side)}",
336             ]
337 
338         approx_side_as_map = _recursive_sequence_map(self._approx_scalar, self.expected)
339 
340         number_of_elements = len(approx_side_as_map)
341         max_abs_diff = -math.inf
342         max_rel_diff = -math.inf
343         different_ids = []
344         for i, (approx_value, other_value) in enumerate(
345             zip(approx_side_as_map, other_side)
346         ):
347             if approx_value != other_value:
348                 abs_diff = abs(approx_value.expected - other_value)
349                 max_abs_diff = max(max_abs_diff, abs_diff)
350                 if other_value == 0.0:
351                     max_rel_diff = math.inf
352                 else:
353                     max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))
354                 different_ids.append(i)
355 
356         message_data = [
357             (str(i), str(other_side[i]), str(approx_side_as_map[i]))
358             for i in different_ids
359         ]
360 
361         return _compare_approx(
362             self.expected,
363             message_data,
364             number_of_elements,
365             different_ids,
366             max_abs_diff,
367             max_rel_diff,
368         )
369 
370     def __eq__(self, actual) -> bool:
371         try:
372             if len(actual) != len(self.expected):
373                 return False
374         except TypeError:
375             return False
376         return super().__eq__(actual)
377 
378     def _yield_comparisons(self, actual):
379         return zip(actual, self.expected)
380 
381     def _check_type(self) -> None:
382         __tracebackhide__ = True
383         for index, x in enumerate(self.expected):
384             if isinstance(x, type(self.expected)):
385                 msg = "pytest.approx() does not support nested data structures: {!r} at index {}\n  full sequence: {}"
386                 raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))
387 
388 
389 class ApproxScalar(ApproxBase):
390     """Perform approximate comparisons where the expected value is a single number."""
391 
392     # Using Real should be better than this Union, but not possible yet:
393     # https://github.com/python/typeshed/pull/3108
394     DEFAULT_ABSOLUTE_TOLERANCE: Union[float, Decimal] = 1e-12
395     DEFAULT_RELATIVE_TOLERANCE: Union[float, Decimal] = 1e-6
396 
397     def __repr__(self) -> str:
398         """Return a string communicating both the expected value and the
399         tolerance for the comparison being made.
400 
401         For example, ``1.0 ± 1e-6``, ``(3+4j) ± 5e-6 ∠ ±180°``.
402         """
403         # Don't show a tolerance for values that aren't compared using
404         # tolerances, i.e. non-numerics and infinities. Need to call abs to
405         # handle complex numbers, e.g. (inf + 1j).
406         if (not isinstance(self.expected, (Complex, Decimal))) or math.isinf(
407             abs(self.expected)  # type: ignore[arg-type]
408         ):
409             return str(self.expected)
410 
411         # If a sensible tolerance can't be calculated, self.tolerance will
412         # raise a ValueError.  In this case, display '???'.
413         try:
414             vetted_tolerance = f"{self.tolerance:.1e}"
415             if (
416                 isinstance(self.expected, Complex)
417                 and self.expected.imag
418                 and not math.isinf(self.tolerance)
419             ):
420                 vetted_tolerance += " ∠ ±180°"
421         except ValueError:
422             vetted_tolerance = "???"
423 
424         return f"{self.expected} ± {vetted_tolerance}"
425 
426     def __eq__(self, actual) -> bool:
427         """Return whether the given value is equal to the expected value
428         within the pre-specified tolerance."""
429         asarray = _as_numpy_array(actual)
430         if asarray is not None:
431             # Call ``__eq__()`` manually to prevent infinite-recursion with
432             # numpy<1.13.  See #3748.
433             return all(self.__eq__(a) for a in asarray.flat)
434 
435         # Short-circuit exact equality.
436         if actual == self.expected:
437             return True
438 
439         # If either type is non-numeric, fall back to strict equality.
440         # NB: we need Complex, rather than just Number, to ensure that __abs__,
441         # __sub__, and __float__ are defined.
442         if not (
443             isinstance(self.expected, (Complex, Decimal))
444             and isinstance(actual, (Complex, Decimal))
445         ):
446             return False
447 
448         # Allow the user to control whether NaNs are considered equal to each
449         # other or not.  The abs() calls are for compatibility with complex
450         # numbers.
451         if math.isnan(abs(self.expected)):  # type: ignore[arg-type]
452             return self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]
453 
454         # Infinity shouldn't be approximately equal to anything but itself, but
455         # if there's a relative tolerance, it will be infinite and infinity
456         # will seem approximately equal to everything.  The equal-to-itself
457         # case would have been short circuited above, so here we can just
458         # return false if the expected value is infinite.  The abs() call is
459         # for compatibility with complex numbers.
460         if math.isinf(abs(self.expected)):  # type: ignore[arg-type]
461             return False
462 
463         # Return true if the two numbers are within the tolerance.
464         result: bool = abs(self.expected - actual) <= self.tolerance
465         return result
466 
467     # Ignore type because of https://github.com/python/mypy/issues/4266.
468     __hash__ = None  # type: ignore
469 
470     @property
471     def tolerance(self):
472         """Return the tolerance for the comparison.
473 
474         This could be either an absolute tolerance or a relative tolerance,
475         depending on what the user specified or which would be larger.
476         """
477 
478         def set_default(x, default):
479             return x if x is not None else default
480 
481         # Figure out what the absolute tolerance should be.  ``self.abs`` is
482         # either None or a value specified by the user.
483         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)
484 
485         if absolute_tolerance < 0:
486             raise ValueError(
487                 f"absolute tolerance can't be negative: {absolute_tolerance}"
488             )
489         if math.isnan(absolute_tolerance):
490             raise ValueError("absolute tolerance can't be NaN.")
491 
492         # If the user specified an absolute tolerance but not a relative one,
493         # just return the absolute tolerance.
494         if self.rel is None:
495             if self.abs is not None:
496                 return absolute_tolerance
497 
498         # Figure out what the relative tolerance should be.  ``self.rel`` is
499         # either None or a value specified by the user.  This is done after
500         # we've made sure the user didn't ask for an absolute tolerance only,
501         # because we don't want to raise errors about the relative tolerance if
502         # we aren't even going to use it.
503         relative_tolerance = set_default(
504             self.rel, self.DEFAULT_RELATIVE_TOLERANCE
505         ) * abs(self.expected)
506 
507         if relative_tolerance < 0:
508             raise ValueError(
509                 f"relative tolerance can't be negative: {relative_tolerance}"
510             )
511         if math.isnan(relative_tolerance):
512             raise ValueError("relative tolerance can't be NaN.")
513 
514         # Return the larger of the relative and absolute tolerances.
515         return max(relative_tolerance, absolute_tolerance)
516 
517 
518 class ApproxDecimal(ApproxScalar):
519     """Perform approximate comparisons where the expected value is a Decimal."""
520 
521     DEFAULT_ABSOLUTE_TOLERANCE = Decimal("1e-12")
522     DEFAULT_RELATIVE_TOLERANCE = Decimal("1e-6")
523 
524 
525 def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:
526     """Assert that two numbers (or two ordered sequences of numbers) are equal to each other
527     within some tolerance.
528 
529     Due to the :doc:`python:tutorial/floatingpoint`, numbers that we
530     would intuitively expect to be equal are not always so::
531 
532         >>> 0.1 + 0.2 == 0.3
533         False
534 
535     This problem is commonly encountered when writing tests, e.g. when making
536     sure that floating-point values are what you expect them to be.  One way to
537     deal with this problem is to assert that two floating-point numbers are
538     equal to within some appropriate tolerance::
539 
540         >>> abs((0.1 + 0.2) - 0.3) < 1e-6
541         True
542 
543     However, comparisons like this are tedious to write and difficult to
544     understand.  Furthermore, absolute comparisons like the one above are
545     usually discouraged because there's no tolerance that works well for all
546     situations.  ``1e-6`` is good for numbers around ``1``, but too small for
547     very big numbers and too big for very small ones.  It's better to express
548     the tolerance as a fraction of the expected value, but relative comparisons
549     like that are even more difficult to write correctly and concisely.
550 
551     The ``approx`` class performs floating-point comparisons using a syntax
552     that's as intuitive as possible::
553 
554         >>> from pytest import approx
555         >>> 0.1 + 0.2 == approx(0.3)
556         True
557 
558     The same syntax also works for ordered sequences of numbers::
559 
560         >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))
561         True
562 
563     ``numpy`` arrays::
564 
565         >>> import numpy as np                                                          # doctest: +SKIP
566         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP
567         True
568 
569     And for a ``numpy`` array against a scalar::
570 
571         >>> import numpy as np                                         # doctest: +SKIP
572         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP
573         True
574 
575     Only ordered sequences are supported, because ``approx`` needs
576     to infer the relative position of the sequences without ambiguity. This means
577     ``sets`` and other unordered sequences are not supported.
578 
579     Finally, dictionary *values* can also be compared::
580 
581         >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})
582         True
583 
584     The comparison will be true if both mappings have the same keys and their
585     respective values match the expected tolerances.
586 
587     **Tolerances**
588 
589     By default, ``approx`` considers numbers within a relative tolerance of
590     ``1e-6`` (i.e. one part in a million) of its expected value to be equal.
591     This treatment would lead to surprising results if the expected value was
592     ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.
593     To handle this case less surprisingly, ``approx`` also considers numbers
594     within an absolute tolerance of ``1e-12`` of its expected value to be
595     equal.  Infinity and NaN are special cases.  Infinity is only considered
596     equal to itself, regardless of the relative tolerance.  NaN is not
597     considered equal to anything by default, but you can make it be equal to
598     itself by setting the ``nan_ok`` argument to True.  (This is meant to
599     facilitate comparing arrays that use NaN to mean "no data".)
600 
601     Both the relative and absolute tolerances can be changed by passing
602     arguments to the ``approx`` constructor::
603 
604         >>> 1.0001 == approx(1)
605         False
606         >>> 1.0001 == approx(1, rel=1e-3)
607         True
608         >>> 1.0001 == approx(1, abs=1e-3)
609         True
610 
611     If you specify ``abs`` but not ``rel``, the comparison will not consider
612     the relative tolerance at all.  In other words, two numbers that are within
613     the default relative tolerance of ``1e-6`` will still be considered unequal
614     if they exceed the specified absolute tolerance.  If you specify both
615     ``abs`` and ``rel``, the numbers will be considered equal if either
616     tolerance is met::
617 
618         >>> 1 + 1e-8 == approx(1)
619         True
620         >>> 1 + 1e-8 == approx(1, abs=1e-12)
621         False
622         >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)
623         True
624 
625     You can also use ``approx`` to compare nonnumeric types, or dicts and
626     sequences containing nonnumeric types, in which case it falls back to
627     strict equality. This can be useful for comparing dicts and sequences that
628     can contain optional values::
629 
630         >>> {"required": 1.0000005, "optional": None} == approx({"required": 1, "optional": None})
631         True
632         >>> [None, 1.0000005] == approx([None,1])
633         True
634         >>> ["foo", 1.0000005] == approx([None,1])
635         False
636 
637     If you're thinking about using ``approx``, then you might want to know how
638     it compares to other good ways of comparing floating-point numbers.  All of
639     these algorithms are based on relative and absolute tolerances and should
640     agree for the most part, but they do have meaningful differences:
641 
642     - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative
643       tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute
644       tolerance is met.  Because the relative tolerance is calculated w.r.t.
645       both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor
646       ``b`` is a "reference value").  You have to specify an absolute tolerance
647       if you want to compare to ``0.0`` because there is no tolerance by
648       default.  More information: :py:func:`math.isclose`.
649 
650     - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference
651       between ``a`` and ``b`` is less that the sum of the relative tolerance
652       w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance
653       is only calculated w.r.t. ``b``, this test is asymmetric and you can
654       think of ``b`` as the reference value.  Support for comparing sequences
655       is provided by :py:func:`numpy.allclose`.  More information:
656       :std:doc:`numpy:reference/generated/numpy.isclose`.
657 
658     - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``
659       are within an absolute tolerance of ``1e-7``.  No relative tolerance is
660       considered , so this function is not appropriate for very large or very
661       small numbers.  Also, it's only available in subclasses of ``unittest.TestCase``
662       and it's ugly because it doesn't follow PEP8.  More information:
663       :py:meth:`unittest.TestCase.assertAlmostEqual`.
664 
665     - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative
666       tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.
667       Because the relative tolerance is only calculated w.r.t. ``b``, this test
668       is asymmetric and you can think of ``b`` as the reference value.  In the
669       special case that you explicitly specify an absolute tolerance but not a
670       relative tolerance, only the absolute tolerance is considered.
671 
672     .. note::
673 
674         ``approx`` can handle numpy arrays, but we recommend the
675         specialised test helpers in :std:doc:`numpy:reference/routines.testing`
676         if you need support for comparisons, NaNs, or ULP-based tolerances.
677 
678         To match strings using regex, you can use
679         `Matches <https://github.com/asottile/re-assert#re_assertmatchespattern-str-args-kwargs>`_
680         from the
681         `re_assert package <https://github.com/asottile/re-assert>`_.
682 
683     .. warning::
684 
685        .. versionchanged:: 3.2
686 
687        In order to avoid inconsistent behavior, :py:exc:`TypeError` is
688        raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.
689        The example below illustrates the problem::
690 
691            assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)
692            assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)
693 
694        In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``
695        to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to
696        comparison. This is because the call hierarchy of rich comparisons
697        follows a fixed behavior. More information: :py:meth:`object.__ge__`
698 
699     .. versionchanged:: 3.7.1
700        ``approx`` raises ``TypeError`` when it encounters a dict value or
701        sequence element of nonnumeric type.
702 
703     .. versionchanged:: 6.1.0
704        ``approx`` falls back to strict equality for nonnumeric types instead
705        of raising ``TypeError``.
706     """
707 
708     # Delegate the comparison to a class that knows how to deal with the type
709     # of the expected value (e.g. int, float, list, dict, numpy.array, etc).
710     #
711     # The primary responsibility of these classes is to implement ``__eq__()``
712     # and ``__repr__()``.  The former is used to actually check if some
713     # "actual" value is equivalent to the given expected value within the
714     # allowed tolerance.  The latter is used to show the user the expected
715     # value and tolerance, in the case that a test failed.
716     #
717     # The actual logic for making approximate comparisons can be found in
718     # ApproxScalar, which is used to compare individual numbers.  All of the
719     # other Approx classes eventually delegate to this class.  The ApproxBase
720     # class provides some convenient methods and overloads, but isn't really
721     # essential.
722 
723     __tracebackhide__ = True
724 
725     if isinstance(expected, Decimal):
726         cls: Type[ApproxBase] = ApproxDecimal
727     elif isinstance(expected, Mapping):
728         cls = ApproxMapping
729     elif _is_numpy_array(expected):
730         expected = _as_numpy_array(expected)
731         cls = ApproxNumpy
732     elif (
733         hasattr(expected, "__getitem__")
734         and isinstance(expected, Sized)
735         # Type ignored because the error is wrong -- not unreachable.
736         and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]
737     ):
738         cls = ApproxSequenceLike
739     elif (
740         isinstance(expected, Collection)
741         # Type ignored because the error is wrong -- not unreachable.
742         and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]
743     ):
744         msg = f"pytest.approx() only supports ordered sequences, but got: {repr(expected)}"
745         raise TypeError(msg)
746     else:
747         cls = ApproxScalar
748 
749     return cls(expected, rel, abs, nan_ok)
750 
751 
752 def _is_numpy_array(obj: object) -> bool:
753     """
754     Return true if the given object is implicitly convertible to ndarray,
755     and numpy is already imported.
756     """
757     return _as_numpy_array(obj) is not None
758 
759 
760 def _as_numpy_array(obj: object) -> Optional["ndarray"]:
761     """
762     Return an ndarray if the given object is implicitly convertible to ndarray,
763     and numpy is already imported, otherwise None.
764     """
765     import sys
766 
767     np: Any = sys.modules.get("numpy")
768     if np is not None:
769         # avoid infinite recursion on numpy scalars, which have __array__
770         if np.isscalar(obj):
771             return None
772         elif isinstance(obj, np.ndarray):
773             return obj
774         elif hasattr(obj, "__array__") or hasattr("obj", "__array_interface__"):
775             return np.asarray(obj)
776     return None
777 
778 
779 # builtin pytest.raises helper
780 
781 E = TypeVar("E", bound=BaseException)
782 
783 
784 @overload
785 def raises(
786     expected_exception: Union[Type[E], Tuple[Type[E], ...]],
787     *,
788     match: Optional[Union[str, Pattern[str]]] = ...,
789 ) -> "RaisesContext[E]":
790     ...
791 
792 
793 @overload
794 def raises(  # noqa: F811
795     expected_exception: Union[Type[E], Tuple[Type[E], ...]],
796     func: Callable[..., Any],
797     *args: Any,
798     **kwargs: Any,
799 ) -> _pytest._code.ExceptionInfo[E]:
800     ...
801 
802 
803 def raises(  # noqa: F811
804     expected_exception: Union[Type[E], Tuple[Type[E], ...]], *args: Any, **kwargs: Any
805 ) -> Union["RaisesContext[E]", _pytest._code.ExceptionInfo[E]]:
806     r"""Assert that a code block/function call raises an exception.
807 
808     :param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:
809         The expected exception type, or a tuple if one of multiple possible
810         exception types are expected.
811     :kwparam str | typing.Pattern[str] | None match:
812         If specified, a string containing a regular expression,
813         or a regular expression object, that is tested against the string
814         representation of the exception using :func:`re.search`.
815 
816         To match a literal string that may contain :ref:`special characters
817         <re-syntax>`, the pattern can first be escaped with :func:`re.escape`.
818 
819         (This is only used when :py:func:`pytest.raises` is used as a context manager,
820         and passed through to the function otherwise.
821         When using :py:func:`pytest.raises` as a function, you can use:
822         ``pytest.raises(Exc, func, match="passed on").match("my pattern")``.)
823 
824     .. currentmodule:: _pytest._code
825 
826     Use ``pytest.raises`` as a context manager, which will capture the exception of the given
827     type::
828 
829         >>> import pytest
830         >>> with pytest.raises(ZeroDivisionError):
831         ...    1/0
832 
833     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example
834     above), or no exception at all, the check will fail instead.
835 
836     You can also use the keyword argument ``match`` to assert that the
837     exception matches a text or regex::
838 
839         >>> with pytest.raises(ValueError, match='must be 0 or None'):
840         ...     raise ValueError("value must be 0 or None")
841 
842         >>> with pytest.raises(ValueError, match=r'must be \d+$'):
843         ...     raise ValueError("value must be 42")
844 
845     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the
846     details of the captured exception::
847 
848         >>> with pytest.raises(ValueError) as exc_info:
849         ...     raise ValueError("value must be 42")
850         >>> assert exc_info.type is ValueError
851         >>> assert exc_info.value.args[0] == "value must be 42"
852 
853     .. note::
854 
855        When using ``pytest.raises`` as a context manager, it's worthwhile to
856        note that normal context manager rules apply and that the exception
857        raised *must* be the final line in the scope of the context manager.
858        Lines of code after that, within the scope of the context manager will
859        not be executed. For example::
860 
861            >>> value = 15
862            >>> with pytest.raises(ValueError) as exc_info:
863            ...     if value > 10:
864            ...         raise ValueError("value must be <= 10")
865            ...     assert exc_info.type is ValueError  # this will not execute
866 
867        Instead, the following approach must be taken (note the difference in
868        scope)::
869 
870            >>> with pytest.raises(ValueError) as exc_info:
871            ...     if value > 10:
872            ...         raise ValueError("value must be <= 10")
873            ...
874            >>> assert exc_info.type is ValueError
875 
876     **Using with** ``pytest.mark.parametrize``
877 
878     When using :ref:`pytest.mark.parametrize ref`
879     it is possible to parametrize tests such that
880     some runs raise an exception and others do not.
881 
882     See :ref:`parametrizing_conditional_raising` for an example.
883 
884     **Legacy form**
885 
886     It is possible to specify a callable by passing a to-be-called lambda::
887 
888         >>> raises(ZeroDivisionError, lambda: 1/0)
889         <ExceptionInfo ...>
890 
891     or you can specify an arbitrary callable with arguments::
892 
893         >>> def f(x): return 1/x
894         ...
895         >>> raises(ZeroDivisionError, f, 0)
896         <ExceptionInfo ...>
897         >>> raises(ZeroDivisionError, f, x=0)
898         <ExceptionInfo ...>
899 
900     The form above is fully supported but discouraged for new code because the
901     context manager form is regarded as more readable and less error-prone.
902 
903     .. note::
904         Similar to caught exception objects in Python, explicitly clearing
905         local references to returned ``ExceptionInfo`` objects can
906         help the Python interpreter speed up its garbage collection.
907 
908         Clearing those references breaks a reference cycle
909         (``ExceptionInfo`` --> caught exception --> frame stack raising
910         the exception --> current frame stack --> local variables -->
911         ``ExceptionInfo``) which makes Python keep all objects referenced
912         from that cycle (including all local variables in the current
913         frame) alive until the next cyclic garbage collection run.
914         More detailed information can be found in the official Python
915         documentation for :ref:`the try statement <python:try>`.
916     """
917     __tracebackhide__ = True
918 
919     if not expected_exception:
920         raise ValueError(
921             f"Expected an exception type or a tuple of exception types, but got `{expected_exception!r}`. "
922             f"Raising exceptions is already understood as failing the test, so you don't need "
923             f"any special code to say 'this should never raise an exception'."
924         )
925     if isinstance(expected_exception, type):
926         expected_exceptions: Tuple[Type[E], ...] = (expected_exception,)
927     else:
928         expected_exceptions = expected_exception
929     for exc in expected_exceptions:
930         if not isinstance(exc, type) or not issubclass(exc, BaseException):
931             msg = "expected exception must be a BaseException type, not {}"  # type: ignore[unreachable]
932             not_a = exc.__name__ if isinstance(exc, type) else type(exc).__name__
933             raise TypeError(msg.format(not_a))
934 
935     message = f"DID NOT RAISE {expected_exception}"
936 
937     if not args:
938         match: Optional[Union[str, Pattern[str]]] = kwargs.pop("match", None)
939         if kwargs:
940             msg = "Unexpected keyword arguments passed to pytest.raises: "
941             msg += ", ".join(sorted(kwargs))
942             msg += "\nUse context-manager form instead?"
943             raise TypeError(msg)
944         return RaisesContext(expected_exception, message, match)
945     else:
946         func = args[0]
947         if not callable(func):
948             raise TypeError(f"{func!r} object (type: {type(func)}) must be callable")
949         try:
950             func(*args[1:], **kwargs)
951         except expected_exception as e:
952             return _pytest._code.ExceptionInfo.from_exception(e)
953     fail(message)
954 
955 
956 # This doesn't work with mypy for now. Use fail.Exception instead.
957 raises.Exception = fail.Exception  # type: ignore
958 
959 
960 @final
961 class RaisesContext(ContextManager[_pytest._code.ExceptionInfo[E]]):
962     def __init__(
963         self,
964         expected_exception: Union[Type[E], Tuple[Type[E], ...]],
965         message: str,
966         match_expr: Optional[Union[str, Pattern[str]]] = None,
967     ) -> None:
968         self.expected_exception = expected_exception
969         self.message = message
970         self.match_expr = match_expr
971         self.excinfo: Optional[_pytest._code.ExceptionInfo[E]] = None
972 
973     def __enter__(self) -> _pytest._code.ExceptionInfo[E]:
974         self.excinfo = _pytest._code.ExceptionInfo.for_later()
975         return self.excinfo
976 
977     def __exit__(
978         self,
979         exc_type: Optional[Type[BaseException]],
980         exc_val: Optional[BaseException],
981         exc_tb: Optional[TracebackType],
982     ) -> bool:
983         __tracebackhide__ = True
984         if exc_type is None:
985             fail(self.message)
986         assert self.excinfo is not None
987         if not issubclass(exc_type, self.expected_exception):
988             return False
989         # Cast to narrow the exception type now that it's verified.
990         exc_info = cast(Tuple[Type[E], E, TracebackType], (exc_type, exc_val, exc_tb))
991         self.excinfo.fill_unfilled(exc_info)
992         if self.match_expr is not None:
993             self.excinfo.match(self.match_expr)
994         return True

</code><intended_behavior>When `approx` encounters a dictionary value or a sequence element that is `None`, it should not raise a `TypeError`. Instead, it should gracefully compare the value to `None` directly, effectively treating it as a strict equality comparison. This update would not alter the existing functionality for numeric and other types that `approx` currently supports. For numeric comparisons, `approx` should continue to work as it does now, using specified tolerances to determine equality. The change would specifically cater to the case where `None` is part of a complex structure like a dictionary or a list that is being compared, making `approx` more versatile and user-friendly for testing scenarios where optional values represented by `None` are expected.</intended_behavior>]
2025-10-17 16:42:33.619 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 16:42:33.619 | INFO     | Search-only: skipping patch selection
2025-10-17 16:42:33.690 | INFO     | Task pytest-dev__pytest-11178 completed successfully.
2025-10-17 16:42:33.691 | INFO     | No patch generated. You can try running ACR again.
