[
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 1,
        "end": 994,
        "class_name": null,
        "method_name": null,
        "code": "1 import math\n2 import pprint\n3 from collections.abc import Collection\n4 from collections.abc import Sized\n5 from decimal import Decimal\n6 from numbers import Complex\n7 from types import TracebackType\n8 from typing import Any\n9 from typing import Callable\n10 from typing import cast\n11 from typing import ContextManager\n12 from typing import final\n13 from typing import List\n14 from typing import Mapping\n15 from typing import Optional\n16 from typing import overload\n17 from typing import Pattern\n18 from typing import Sequence\n19 from typing import Tuple\n20 from typing import Type\n21 from typing import TYPE_CHECKING\n22 from typing import TypeVar\n23 from typing import Union\n24 \n25 import _pytest._code\n26 from _pytest.compat import STRING_TYPES\n27 from _pytest.outcomes import fail\n28 \n29 if TYPE_CHECKING:\n30     from numpy import ndarray\n31 \n32 \n33 def _non_numeric_type_error(value, at: Optional[str]) -> TypeError:\n34     at_str = f\" at {at}\" if at else \"\"\n35     return TypeError(\n36         \"cannot make approximate comparisons to non-numeric values: {!r} {}\".format(\n37             value, at_str\n38         )\n39     )\n40 \n41 \n42 def _compare_approx(\n43     full_object: object,\n44     message_data: Sequence[Tuple[str, str, str]],\n45     number_of_elements: int,\n46     different_ids: Sequence[object],\n47     max_abs_diff: float,\n48     max_rel_diff: float,\n49 ) -> List[str]:\n50     message_list = list(message_data)\n51     message_list.insert(0, (\"Index\", \"Obtained\", \"Expected\"))\n52     max_sizes = [0, 0, 0]\n53     for index, obtained, expected in message_list:\n54         max_sizes[0] = max(max_sizes[0], len(index))\n55         max_sizes[1] = max(max_sizes[1], len(obtained))\n56         max_sizes[2] = max(max_sizes[2], len(expected))\n57     explanation = [\n58         f\"comparison failed. Mismatched elements: {len(different_ids)} / {number_of_elements}:\",\n59         f\"Max absolute difference: {max_abs_diff}\",\n60         f\"Max relative difference: {max_rel_diff}\",\n61     ] + [\n62         f\"{indexes:<{max_sizes[0]}} | {obtained:<{max_sizes[1]}} | {expected:<{max_sizes[2]}}\"\n63         for indexes, obtained, expected in message_list\n64     ]\n65     return explanation\n66 \n67 \n68 # builtin pytest.approx helper\n69 \n70 \n71 class ApproxBase:\n72     \"\"\"Provide shared utilities for making approximate comparisons between\n73     numbers or sequences of numbers.\"\"\"\n74 \n75     # Tell numpy to use our `__eq__` operator instead of its.\n76     __array_ufunc__ = None\n77     __array_priority__ = 100\n78 \n79     def __init__(self, expected, rel=None, abs=None, nan_ok: bool = False) -> None:\n80         __tracebackhide__ = True\n81         self.expected = expected\n82         self.abs = abs\n83         self.rel = rel\n84         self.nan_ok = nan_ok\n85         self._check_type()\n86 \n87     def __repr__(self) -> str:\n88         raise NotImplementedError\n89 \n90     def _repr_compare(self, other_side: Any) -> List[str]:\n91         return [\n92             \"comparison failed\",\n93             f\"Obtained: {other_side}\",\n94             f\"Expected: {self}\",\n95         ]\n96 \n97     def __eq__(self, actual) -> bool:\n98         return all(\n99             a == self._approx_scalar(x) for a, x in self._yield_comparisons(actual)\n100         )\n101 \n102     def __bool__(self):\n103         __tracebackhide__ = True\n104         raise AssertionError(\n105             \"approx() is not supported in a boolean context.\\nDid you mean: `assert a == approx(b)`?\"\n106         )\n107 \n108     # Ignore type because of https://github.com/python/mypy/issues/4266.\n109     __hash__ = None  # type: ignore\n110 \n111     def __ne__(self, actual) -> bool:\n112         return not (actual == self)\n113 \n114     def _approx_scalar(self, x) -> \"ApproxScalar\":\n115         if isinstance(x, Decimal):\n116             return ApproxDecimal(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n117         return ApproxScalar(x, rel=self.rel, abs=self.abs, nan_ok=self.nan_ok)\n118 \n119     def _yield_comparisons(self, actual):\n120         \"\"\"Yield all the pairs of numbers to be compared.\n121 \n122         This is used to implement the `__eq__` method.\n123         \"\"\"\n124         raise NotImplementedError\n125 \n126     def _check_type(self) -> None:\n127         \"\"\"Raise a TypeError if the expected value is not a valid type.\"\"\"\n128         # This is only a concern if the expected value is a sequence.  In every\n129         # other case, the approx() function ensures that the expected value has\n130         # a numeric type.  For this reason, the default is to do nothing.  The\n131         # classes that deal with sequences should reimplement this method to\n132         # raise if there are any non-numeric elements in the sequence.\n133 \n134 \n135 def _recursive_sequence_map(f, x):\n136     \"\"\"Recursively map a function over a sequence of arbitrary depth\"\"\"\n137     if isinstance(x, (list, tuple)):\n138         seq_type = type(x)\n139         return seq_type(_recursive_sequence_map(f, xi) for xi in x)\n140     else:\n141         return f(x)\n142 \n143 \n144 class ApproxNumpy(ApproxBase):\n145     \"\"\"Perform approximate comparisons where the expected value is numpy array.\"\"\"\n146 \n147     def __repr__(self) -> str:\n148         list_scalars = _recursive_sequence_map(\n149             self._approx_scalar, self.expected.tolist()\n150         )\n151         return f\"approx({list_scalars!r})\"\n152 \n153     def _repr_compare(self, other_side: \"ndarray\") -> List[str]:\n154         import itertools\n155         import math\n156 \n157         def get_value_from_nested_list(\n158             nested_list: List[Any], nd_index: Tuple[Any, ...]\n159         ) -> Any:\n160             \"\"\"\n161             Helper function to get the value out of a nested list, given an n-dimensional index.\n162             This mimics numpy's indexing, but for raw nested python lists.\n163             \"\"\"\n164             value: Any = nested_list\n165             for i in nd_index:\n166                 value = value[i]\n167             return value\n168 \n169         np_array_shape = self.expected.shape\n170         approx_side_as_seq = _recursive_sequence_map(\n171             self._approx_scalar, self.expected.tolist()\n172         )\n173 \n174         if np_array_shape != other_side.shape:\n175             return [\n176                 \"Impossible to compare arrays with different shapes.\",\n177                 f\"Shapes: {np_array_shape} and {other_side.shape}\",\n178             ]\n179 \n180         number_of_elements = self.expected.size\n181         max_abs_diff = -math.inf\n182         max_rel_diff = -math.inf\n183         different_ids = []\n184         for index in itertools.product(*(range(i) for i in np_array_shape)):\n185             approx_value = get_value_from_nested_list(approx_side_as_seq, index)\n186             other_value = get_value_from_nested_list(other_side, index)\n187             if approx_value != other_value:\n188                 abs_diff = abs(approx_value.expected - other_value)\n189                 max_abs_diff = max(max_abs_diff, abs_diff)\n190                 if other_value == 0.0:\n191                     max_rel_diff = math.inf\n192                 else:\n193                     max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))\n194                 different_ids.append(index)\n195 \n196         message_data = [\n197             (\n198                 str(index),\n199                 str(get_value_from_nested_list(other_side, index)),\n200                 str(get_value_from_nested_list(approx_side_as_seq, index)),\n201             )\n202             for index in different_ids\n203         ]\n204         return _compare_approx(\n205             self.expected,\n206             message_data,\n207             number_of_elements,\n208             different_ids,\n209             max_abs_diff,\n210             max_rel_diff,\n211         )\n212 \n213     def __eq__(self, actual) -> bool:\n214         import numpy as np\n215 \n216         # self.expected is supposed to always be an array here.\n217 \n218         if not np.isscalar(actual):\n219             try:\n220                 actual = np.asarray(actual)\n221             except Exception as e:\n222                 raise TypeError(f\"cannot compare '{actual}' to numpy.ndarray\") from e\n223 \n224         if not np.isscalar(actual) and actual.shape != self.expected.shape:\n225             return False\n226 \n227         return super().__eq__(actual)\n228 \n229     def _yield_comparisons(self, actual):\n230         import numpy as np\n231 \n232         # `actual` can either be a numpy array or a scalar, it is treated in\n233         # `__eq__` before being passed to `ApproxBase.__eq__`, which is the\n234         # only method that calls this one.\n235 \n236         if np.isscalar(actual):\n237             for i in np.ndindex(self.expected.shape):\n238                 yield actual, self.expected[i].item()\n239         else:\n240             for i in np.ndindex(self.expected.shape):\n241                 yield actual[i].item(), self.expected[i].item()\n242 \n243 \n244 class ApproxMapping(ApproxBase):\n245     \"\"\"Perform approximate comparisons where the expected value is a mapping\n246     with numeric values (the keys can be anything).\"\"\"\n247 \n248     def __repr__(self) -> str:\n249         return \"approx({!r})\".format(\n250             {k: self._approx_scalar(v) for k, v in self.expected.items()}\n251         )\n252 \n253     def _repr_compare(self, other_side: Mapping[object, float]) -> List[str]:\n254         import math\n255 \n256         approx_side_as_map = {\n257             k: self._approx_scalar(v) for k, v in self.expected.items()\n258         }\n259 \n260         number_of_elements = len(approx_side_as_map)\n261         max_abs_diff = -math.inf\n262         max_rel_diff = -math.inf\n263         different_ids = []\n264         for (approx_key, approx_value), other_value in zip(\n265             approx_side_as_map.items(), other_side.values()\n266         ):\n267             if approx_value != other_value:\n268                 max_abs_diff = max(\n269                     max_abs_diff, abs(approx_value.expected - other_value)\n270                 )\n271                 if approx_value.expected == 0.0:\n272                     max_rel_diff = math.inf\n273                 else:\n274                     max_rel_diff = max(\n275                         max_rel_diff,\n276                         abs(\n277                             (approx_value.expected - other_value)\n278                             / approx_value.expected\n279                         ),\n280                     )\n281                 different_ids.append(approx_key)\n282 \n283         message_data = [\n284             (str(key), str(other_side[key]), str(approx_side_as_map[key]))\n285             for key in different_ids\n286         ]\n287 \n288         return _compare_approx(\n289             self.expected,\n290             message_data,\n291             number_of_elements,\n292             different_ids,\n293             max_abs_diff,\n294             max_rel_diff,\n295         )\n296 \n297     def __eq__(self, actual) -> bool:\n298         try:\n299             if set(actual.keys()) != set(self.expected.keys()):\n300                 return False\n301         except AttributeError:\n302             return False\n303 \n304         return super().__eq__(actual)\n305 \n306     def _yield_comparisons(self, actual):\n307         for k in self.expected.keys():\n308             yield actual[k], self.expected[k]\n309 \n310     def _check_type(self) -> None:\n311         __tracebackhide__ = True\n312         for key, value in self.expected.items():\n313             if isinstance(value, type(self.expected)):\n314                 msg = \"pytest.approx() does not support nested dictionaries: key={!r} value={!r}\\n  full mapping={}\"\n315                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))\n316 \n317 \n318 class ApproxSequenceLike(ApproxBase):\n319     \"\"\"Perform approximate comparisons where the expected value is a sequence of numbers.\"\"\"\n320 \n321     def __repr__(self) -> str:\n322         seq_type = type(self.expected)\n323         if seq_type not in (tuple, list):\n324             seq_type = list\n325         return \"approx({!r})\".format(\n326             seq_type(self._approx_scalar(x) for x in self.expected)\n327         )\n328 \n329     def _repr_compare(self, other_side: Sequence[float]) -> List[str]:\n330         import math\n331 \n332         if len(self.expected) != len(other_side):\n333             return [\n334                 \"Impossible to compare lists with different sizes.\",\n335                 f\"Lengths: {len(self.expected)} and {len(other_side)}\",\n336             ]\n337 \n338         approx_side_as_map = _recursive_sequence_map(self._approx_scalar, self.expected)\n339 \n340         number_of_elements = len(approx_side_as_map)\n341         max_abs_diff = -math.inf\n342         max_rel_diff = -math.inf\n343         different_ids = []\n344         for i, (approx_value, other_value) in enumerate(\n345             zip(approx_side_as_map, other_side)\n346         ):\n347             if approx_value != other_value:\n348                 abs_diff = abs(approx_value.expected - other_value)\n349                 max_abs_diff = max(max_abs_diff, abs_diff)\n350                 if other_value == 0.0:\n351                     max_rel_diff = math.inf\n352                 else:\n353                     max_rel_diff = max(max_rel_diff, abs_diff / abs(other_value))\n354                 different_ids.append(i)\n355 \n356         message_data = [\n357             (str(i), str(other_side[i]), str(approx_side_as_map[i]))\n358             for i in different_ids\n359         ]\n360 \n361         return _compare_approx(\n362             self.expected,\n363             message_data,\n364             number_of_elements,\n365             different_ids,\n366             max_abs_diff,\n367             max_rel_diff,\n368         )\n369 \n370     def __eq__(self, actual) -> bool:\n371         try:\n372             if len(actual) != len(self.expected):\n373                 return False\n374         except TypeError:\n375             return False\n376         return super().__eq__(actual)\n377 \n378     def _yield_comparisons(self, actual):\n379         return zip(actual, self.expected)\n380 \n381     def _check_type(self) -> None:\n382         __tracebackhide__ = True\n383         for index, x in enumerate(self.expected):\n384             if isinstance(x, type(self.expected)):\n385                 msg = \"pytest.approx() does not support nested data structures: {!r} at index {}\\n  full sequence: {}\"\n386                 raise TypeError(msg.format(x, index, pprint.pformat(self.expected)))\n387 \n388 \n389 class ApproxScalar(ApproxBase):\n390     \"\"\"Perform approximate comparisons where the expected value is a single number.\"\"\"\n391 \n392     # Using Real should be better than this Union, but not possible yet:\n393     # https://github.com/python/typeshed/pull/3108\n394     DEFAULT_ABSOLUTE_TOLERANCE: Union[float, Decimal] = 1e-12\n395     DEFAULT_RELATIVE_TOLERANCE: Union[float, Decimal] = 1e-6\n396 \n397     def __repr__(self) -> str:\n398         \"\"\"Return a string communicating both the expected value and the\n399         tolerance for the comparison being made.\n400 \n401         For example, ``1.0 \u00b1 1e-6``, ``(3+4j) \u00b1 5e-6 \u2220 \u00b1180\u00b0``.\n402         \"\"\"\n403         # Don't show a tolerance for values that aren't compared using\n404         # tolerances, i.e. non-numerics and infinities. Need to call abs to\n405         # handle complex numbers, e.g. (inf + 1j).\n406         if (not isinstance(self.expected, (Complex, Decimal))) or math.isinf(\n407             abs(self.expected)  # type: ignore[arg-type]\n408         ):\n409             return str(self.expected)\n410 \n411         # If a sensible tolerance can't be calculated, self.tolerance will\n412         # raise a ValueError.  In this case, display '???'.\n413         try:\n414             vetted_tolerance = f\"{self.tolerance:.1e}\"\n415             if (\n416                 isinstance(self.expected, Complex)\n417                 and self.expected.imag\n418                 and not math.isinf(self.tolerance)\n419             ):\n420                 vetted_tolerance += \" \u2220 \u00b1180\u00b0\"\n421         except ValueError:\n422             vetted_tolerance = \"???\"\n423 \n424         return f\"{self.expected} \u00b1 {vetted_tolerance}\"\n425 \n426     def __eq__(self, actual) -> bool:\n427         \"\"\"Return whether the given value is equal to the expected value\n428         within the pre-specified tolerance.\"\"\"\n429         asarray = _as_numpy_array(actual)\n430         if asarray is not None:\n431             # Call ``__eq__()`` manually to prevent infinite-recursion with\n432             # numpy<1.13.  See #3748.\n433             return all(self.__eq__(a) for a in asarray.flat)\n434 \n435         # Short-circuit exact equality.\n436         if actual == self.expected:\n437             return True\n438 \n439         # If either type is non-numeric, fall back to strict equality.\n440         # NB: we need Complex, rather than just Number, to ensure that __abs__,\n441         # __sub__, and __float__ are defined.\n442         if not (\n443             isinstance(self.expected, (Complex, Decimal))\n444             and isinstance(actual, (Complex, Decimal))\n445         ):\n446             return False\n447 \n448         # Allow the user to control whether NaNs are considered equal to each\n449         # other or not.  The abs() calls are for compatibility with complex\n450         # numbers.\n451         if math.isnan(abs(self.expected)):  # type: ignore[arg-type]\n452             return self.nan_ok and math.isnan(abs(actual))  # type: ignore[arg-type]\n453 \n454         # Infinity shouldn't be approximately equal to anything but itself, but\n455         # if there's a relative tolerance, it will be infinite and infinity\n456         # will seem approximately equal to everything.  The equal-to-itself\n457         # case would have been short circuited above, so here we can just\n458         # return false if the expected value is infinite.  The abs() call is\n459         # for compatibility with complex numbers.\n460         if math.isinf(abs(self.expected)):  # type: ignore[arg-type]\n461             return False\n462 \n463         # Return true if the two numbers are within the tolerance.\n464         result: bool = abs(self.expected - actual) <= self.tolerance\n465         return result\n466 \n467     # Ignore type because of https://github.com/python/mypy/issues/4266.\n468     __hash__ = None  # type: ignore\n469 \n470     @property\n471     def tolerance(self):\n472         \"\"\"Return the tolerance for the comparison.\n473 \n474         This could be either an absolute tolerance or a relative tolerance,\n475         depending on what the user specified or which would be larger.\n476         \"\"\"\n477 \n478         def set_default(x, default):\n479             return x if x is not None else default\n480 \n481         # Figure out what the absolute tolerance should be.  ``self.abs`` is\n482         # either None or a value specified by the user.\n483         absolute_tolerance = set_default(self.abs, self.DEFAULT_ABSOLUTE_TOLERANCE)\n484 \n485         if absolute_tolerance < 0:\n486             raise ValueError(\n487                 f\"absolute tolerance can't be negative: {absolute_tolerance}\"\n488             )\n489         if math.isnan(absolute_tolerance):\n490             raise ValueError(\"absolute tolerance can't be NaN.\")\n491 \n492         # If the user specified an absolute tolerance but not a relative one,\n493         # just return the absolute tolerance.\n494         if self.rel is None:\n495             if self.abs is not None:\n496                 return absolute_tolerance\n497 \n498         # Figure out what the relative tolerance should be.  ``self.rel`` is\n499         # either None or a value specified by the user.  This is done after\n500         # we've made sure the user didn't ask for an absolute tolerance only,\n501         # because we don't want to raise errors about the relative tolerance if\n502         # we aren't even going to use it.\n503         relative_tolerance = set_default(\n504             self.rel, self.DEFAULT_RELATIVE_TOLERANCE\n505         ) * abs(self.expected)\n506 \n507         if relative_tolerance < 0:\n508             raise ValueError(\n509                 f\"relative tolerance can't be negative: {relative_tolerance}\"\n510             )\n511         if math.isnan(relative_tolerance):\n512             raise ValueError(\"relative tolerance can't be NaN.\")\n513 \n514         # Return the larger of the relative and absolute tolerances.\n515         return max(relative_tolerance, absolute_tolerance)\n516 \n517 \n518 class ApproxDecimal(ApproxScalar):\n519     \"\"\"Perform approximate comparisons where the expected value is a Decimal.\"\"\"\n520 \n521     DEFAULT_ABSOLUTE_TOLERANCE = Decimal(\"1e-12\")\n522     DEFAULT_RELATIVE_TOLERANCE = Decimal(\"1e-6\")\n523 \n524 \n525 def approx(expected, rel=None, abs=None, nan_ok: bool = False) -> ApproxBase:\n526     \"\"\"Assert that two numbers (or two ordered sequences of numbers) are equal to each other\n527     within some tolerance.\n528 \n529     Due to the :doc:`python:tutorial/floatingpoint`, numbers that we\n530     would intuitively expect to be equal are not always so::\n531 \n532         >>> 0.1 + 0.2 == 0.3\n533         False\n534 \n535     This problem is commonly encountered when writing tests, e.g. when making\n536     sure that floating-point values are what you expect them to be.  One way to\n537     deal with this problem is to assert that two floating-point numbers are\n538     equal to within some appropriate tolerance::\n539 \n540         >>> abs((0.1 + 0.2) - 0.3) < 1e-6\n541         True\n542 \n543     However, comparisons like this are tedious to write and difficult to\n544     understand.  Furthermore, absolute comparisons like the one above are\n545     usually discouraged because there's no tolerance that works well for all\n546     situations.  ``1e-6`` is good for numbers around ``1``, but too small for\n547     very big numbers and too big for very small ones.  It's better to express\n548     the tolerance as a fraction of the expected value, but relative comparisons\n549     like that are even more difficult to write correctly and concisely.\n550 \n551     The ``approx`` class performs floating-point comparisons using a syntax\n552     that's as intuitive as possible::\n553 \n554         >>> from pytest import approx\n555         >>> 0.1 + 0.2 == approx(0.3)\n556         True\n557 \n558     The same syntax also works for ordered sequences of numbers::\n559 \n560         >>> (0.1 + 0.2, 0.2 + 0.4) == approx((0.3, 0.6))\n561         True\n562 \n563     ``numpy`` arrays::\n564 \n565         >>> import numpy as np                                                          # doctest: +SKIP\n566         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == approx(np.array([0.3, 0.6])) # doctest: +SKIP\n567         True\n568 \n569     And for a ``numpy`` array against a scalar::\n570 \n571         >>> import numpy as np                                         # doctest: +SKIP\n572         >>> np.array([0.1, 0.2]) + np.array([0.2, 0.1]) == approx(0.3) # doctest: +SKIP\n573         True\n574 \n575     Only ordered sequences are supported, because ``approx`` needs\n576     to infer the relative position of the sequences without ambiguity. This means\n577     ``sets`` and other unordered sequences are not supported.\n578 \n579     Finally, dictionary *values* can also be compared::\n580 \n581         >>> {'a': 0.1 + 0.2, 'b': 0.2 + 0.4} == approx({'a': 0.3, 'b': 0.6})\n582         True\n583 \n584     The comparison will be true if both mappings have the same keys and their\n585     respective values match the expected tolerances.\n586 \n587     **Tolerances**\n588 \n589     By default, ``approx`` considers numbers within a relative tolerance of\n590     ``1e-6`` (i.e. one part in a million) of its expected value to be equal.\n591     This treatment would lead to surprising results if the expected value was\n592     ``0.0``, because nothing but ``0.0`` itself is relatively close to ``0.0``.\n593     To handle this case less surprisingly, ``approx`` also considers numbers\n594     within an absolute tolerance of ``1e-12`` of its expected value to be\n595     equal.  Infinity and NaN are special cases.  Infinity is only considered\n596     equal to itself, regardless of the relative tolerance.  NaN is not\n597     considered equal to anything by default, but you can make it be equal to\n598     itself by setting the ``nan_ok`` argument to True.  (This is meant to\n599     facilitate comparing arrays that use NaN to mean \"no data\".)\n600 \n601     Both the relative and absolute tolerances can be changed by passing\n602     arguments to the ``approx`` constructor::\n603 \n604         >>> 1.0001 == approx(1)\n605         False\n606         >>> 1.0001 == approx(1, rel=1e-3)\n607         True\n608         >>> 1.0001 == approx(1, abs=1e-3)\n609         True\n610 \n611     If you specify ``abs`` but not ``rel``, the comparison will not consider\n612     the relative tolerance at all.  In other words, two numbers that are within\n613     the default relative tolerance of ``1e-6`` will still be considered unequal\n614     if they exceed the specified absolute tolerance.  If you specify both\n615     ``abs`` and ``rel``, the numbers will be considered equal if either\n616     tolerance is met::\n617 \n618         >>> 1 + 1e-8 == approx(1)\n619         True\n620         >>> 1 + 1e-8 == approx(1, abs=1e-12)\n621         False\n622         >>> 1 + 1e-8 == approx(1, rel=1e-6, abs=1e-12)\n623         True\n624 \n625     You can also use ``approx`` to compare nonnumeric types, or dicts and\n626     sequences containing nonnumeric types, in which case it falls back to\n627     strict equality. This can be useful for comparing dicts and sequences that\n628     can contain optional values::\n629 \n630         >>> {\"required\": 1.0000005, \"optional\": None} == approx({\"required\": 1, \"optional\": None})\n631         True\n632         >>> [None, 1.0000005] == approx([None,1])\n633         True\n634         >>> [\"foo\", 1.0000005] == approx([None,1])\n635         False\n636 \n637     If you're thinking about using ``approx``, then you might want to know how\n638     it compares to other good ways of comparing floating-point numbers.  All of\n639     these algorithms are based on relative and absolute tolerances and should\n640     agree for the most part, but they do have meaningful differences:\n641 \n642     - ``math.isclose(a, b, rel_tol=1e-9, abs_tol=0.0)``:  True if the relative\n643       tolerance is met w.r.t. either ``a`` or ``b`` or if the absolute\n644       tolerance is met.  Because the relative tolerance is calculated w.r.t.\n645       both ``a`` and ``b``, this test is symmetric (i.e.  neither ``a`` nor\n646       ``b`` is a \"reference value\").  You have to specify an absolute tolerance\n647       if you want to compare to ``0.0`` because there is no tolerance by\n648       default.  More information: :py:func:`math.isclose`.\n649 \n650     - ``numpy.isclose(a, b, rtol=1e-5, atol=1e-8)``: True if the difference\n651       between ``a`` and ``b`` is less that the sum of the relative tolerance\n652       w.r.t. ``b`` and the absolute tolerance.  Because the relative tolerance\n653       is only calculated w.r.t. ``b``, this test is asymmetric and you can\n654       think of ``b`` as the reference value.  Support for comparing sequences\n655       is provided by :py:func:`numpy.allclose`.  More information:\n656       :std:doc:`numpy:reference/generated/numpy.isclose`.\n657 \n658     - ``unittest.TestCase.assertAlmostEqual(a, b)``: True if ``a`` and ``b``\n659       are within an absolute tolerance of ``1e-7``.  No relative tolerance is\n660       considered , so this function is not appropriate for very large or very\n661       small numbers.  Also, it's only available in subclasses of ``unittest.TestCase``\n662       and it's ugly because it doesn't follow PEP8.  More information:\n663       :py:meth:`unittest.TestCase.assertAlmostEqual`.\n664 \n665     - ``a == pytest.approx(b, rel=1e-6, abs=1e-12)``: True if the relative\n666       tolerance is met w.r.t. ``b`` or if the absolute tolerance is met.\n667       Because the relative tolerance is only calculated w.r.t. ``b``, this test\n668       is asymmetric and you can think of ``b`` as the reference value.  In the\n669       special case that you explicitly specify an absolute tolerance but not a\n670       relative tolerance, only the absolute tolerance is considered.\n671 \n672     .. note::\n673 \n674         ``approx`` can handle numpy arrays, but we recommend the\n675         specialised test helpers in :std:doc:`numpy:reference/routines.testing`\n676         if you need support for comparisons, NaNs, or ULP-based tolerances.\n677 \n678         To match strings using regex, you can use\n679         `Matches <https://github.com/asottile/re-assert#re_assertmatchespattern-str-args-kwargs>`_\n680         from the\n681         `re_assert package <https://github.com/asottile/re-assert>`_.\n682 \n683     .. warning::\n684 \n685        .. versionchanged:: 3.2\n686 \n687        In order to avoid inconsistent behavior, :py:exc:`TypeError` is\n688        raised for ``>``, ``>=``, ``<`` and ``<=`` comparisons.\n689        The example below illustrates the problem::\n690 \n691            assert approx(0.1) > 0.1 + 1e-10  # calls approx(0.1).__gt__(0.1 + 1e-10)\n692            assert 0.1 + 1e-10 > approx(0.1)  # calls approx(0.1).__lt__(0.1 + 1e-10)\n693 \n694        In the second example one expects ``approx(0.1).__le__(0.1 + 1e-10)``\n695        to be called. But instead, ``approx(0.1).__lt__(0.1 + 1e-10)`` is used to\n696        comparison. This is because the call hierarchy of rich comparisons\n697        follows a fixed behavior. More information: :py:meth:`object.__ge__`\n698 \n699     .. versionchanged:: 3.7.1\n700        ``approx`` raises ``TypeError`` when it encounters a dict value or\n701        sequence element of nonnumeric type.\n702 \n703     .. versionchanged:: 6.1.0\n704        ``approx`` falls back to strict equality for nonnumeric types instead\n705        of raising ``TypeError``.\n706     \"\"\"\n707 \n708     # Delegate the comparison to a class that knows how to deal with the type\n709     # of the expected value (e.g. int, float, list, dict, numpy.array, etc).\n710     #\n711     # The primary responsibility of these classes is to implement ``__eq__()``\n712     # and ``__repr__()``.  The former is used to actually check if some\n713     # \"actual\" value is equivalent to the given expected value within the\n714     # allowed tolerance.  The latter is used to show the user the expected\n715     # value and tolerance, in the case that a test failed.\n716     #\n717     # The actual logic for making approximate comparisons can be found in\n718     # ApproxScalar, which is used to compare individual numbers.  All of the\n719     # other Approx classes eventually delegate to this class.  The ApproxBase\n720     # class provides some convenient methods and overloads, but isn't really\n721     # essential.\n722 \n723     __tracebackhide__ = True\n724 \n725     if isinstance(expected, Decimal):\n726         cls: Type[ApproxBase] = ApproxDecimal\n727     elif isinstance(expected, Mapping):\n728         cls = ApproxMapping\n729     elif _is_numpy_array(expected):\n730         expected = _as_numpy_array(expected)\n731         cls = ApproxNumpy\n732     elif (\n733         hasattr(expected, \"__getitem__\")\n734         and isinstance(expected, Sized)\n735         # Type ignored because the error is wrong -- not unreachable.\n736         and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]\n737     ):\n738         cls = ApproxSequenceLike\n739     elif (\n740         isinstance(expected, Collection)\n741         # Type ignored because the error is wrong -- not unreachable.\n742         and not isinstance(expected, STRING_TYPES)  # type: ignore[unreachable]\n743     ):\n744         msg = f\"pytest.approx() only supports ordered sequences, but got: {repr(expected)}\"\n745         raise TypeError(msg)\n746     else:\n747         cls = ApproxScalar\n748 \n749     return cls(expected, rel, abs, nan_ok)\n750 \n751 \n752 def _is_numpy_array(obj: object) -> bool:\n753     \"\"\"\n754     Return true if the given object is implicitly convertible to ndarray,\n755     and numpy is already imported.\n756     \"\"\"\n757     return _as_numpy_array(obj) is not None\n758 \n759 \n760 def _as_numpy_array(obj: object) -> Optional[\"ndarray\"]:\n761     \"\"\"\n762     Return an ndarray if the given object is implicitly convertible to ndarray,\n763     and numpy is already imported, otherwise None.\n764     \"\"\"\n765     import sys\n766 \n767     np: Any = sys.modules.get(\"numpy\")\n768     if np is not None:\n769         # avoid infinite recursion on numpy scalars, which have __array__\n770         if np.isscalar(obj):\n771             return None\n772         elif isinstance(obj, np.ndarray):\n773             return obj\n774         elif hasattr(obj, \"__array__\") or hasattr(\"obj\", \"__array_interface__\"):\n775             return np.asarray(obj)\n776     return None\n777 \n778 \n779 # builtin pytest.raises helper\n780 \n781 E = TypeVar(\"E\", bound=BaseException)\n782 \n783 \n784 @overload\n785 def raises(\n786     expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n787     *,\n788     match: Optional[Union[str, Pattern[str]]] = ...,\n789 ) -> \"RaisesContext[E]\":\n790     ...\n791 \n792 \n793 @overload\n794 def raises(  # noqa: F811\n795     expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n796     func: Callable[..., Any],\n797     *args: Any,\n798     **kwargs: Any,\n799 ) -> _pytest._code.ExceptionInfo[E]:\n800     ...\n801 \n802 \n803 def raises(  # noqa: F811\n804     expected_exception: Union[Type[E], Tuple[Type[E], ...]], *args: Any, **kwargs: Any\n805 ) -> Union[\"RaisesContext[E]\", _pytest._code.ExceptionInfo[E]]:\n806     r\"\"\"Assert that a code block/function call raises an exception.\n807 \n808     :param typing.Type[E] | typing.Tuple[typing.Type[E], ...] expected_exception:\n809         The expected exception type, or a tuple if one of multiple possible\n810         exception types are expected.\n811     :kwparam str | typing.Pattern[str] | None match:\n812         If specified, a string containing a regular expression,\n813         or a regular expression object, that is tested against the string\n814         representation of the exception using :func:`re.search`.\n815 \n816         To match a literal string that may contain :ref:`special characters\n817         <re-syntax>`, the pattern can first be escaped with :func:`re.escape`.\n818 \n819         (This is only used when :py:func:`pytest.raises` is used as a context manager,\n820         and passed through to the function otherwise.\n821         When using :py:func:`pytest.raises` as a function, you can use:\n822         ``pytest.raises(Exc, func, match=\"passed on\").match(\"my pattern\")``.)\n823 \n824     .. currentmodule:: _pytest._code\n825 \n826     Use ``pytest.raises`` as a context manager, which will capture the exception of the given\n827     type::\n828 \n829         >>> import pytest\n830         >>> with pytest.raises(ZeroDivisionError):\n831         ...    1/0\n832 \n833     If the code block does not raise the expected exception (``ZeroDivisionError`` in the example\n834     above), or no exception at all, the check will fail instead.\n835 \n836     You can also use the keyword argument ``match`` to assert that the\n837     exception matches a text or regex::\n838 \n839         >>> with pytest.raises(ValueError, match='must be 0 or None'):\n840         ...     raise ValueError(\"value must be 0 or None\")\n841 \n842         >>> with pytest.raises(ValueError, match=r'must be \\d+$'):\n843         ...     raise ValueError(\"value must be 42\")\n844 \n845     The context manager produces an :class:`ExceptionInfo` object which can be used to inspect the\n846     details of the captured exception::\n847 \n848         >>> with pytest.raises(ValueError) as exc_info:\n849         ...     raise ValueError(\"value must be 42\")\n850         >>> assert exc_info.type is ValueError\n851         >>> assert exc_info.value.args[0] == \"value must be 42\"\n852 \n853     .. note::\n854 \n855        When using ``pytest.raises`` as a context manager, it's worthwhile to\n856        note that normal context manager rules apply and that the exception\n857        raised *must* be the final line in the scope of the context manager.\n858        Lines of code after that, within the scope of the context manager will\n859        not be executed. For example::\n860 \n861            >>> value = 15\n862            >>> with pytest.raises(ValueError) as exc_info:\n863            ...     if value > 10:\n864            ...         raise ValueError(\"value must be <= 10\")\n865            ...     assert exc_info.type is ValueError  # this will not execute\n866 \n867        Instead, the following approach must be taken (note the difference in\n868        scope)::\n869 \n870            >>> with pytest.raises(ValueError) as exc_info:\n871            ...     if value > 10:\n872            ...         raise ValueError(\"value must be <= 10\")\n873            ...\n874            >>> assert exc_info.type is ValueError\n875 \n876     **Using with** ``pytest.mark.parametrize``\n877 \n878     When using :ref:`pytest.mark.parametrize ref`\n879     it is possible to parametrize tests such that\n880     some runs raise an exception and others do not.\n881 \n882     See :ref:`parametrizing_conditional_raising` for an example.\n883 \n884     **Legacy form**\n885 \n886     It is possible to specify a callable by passing a to-be-called lambda::\n887 \n888         >>> raises(ZeroDivisionError, lambda: 1/0)\n889         <ExceptionInfo ...>\n890 \n891     or you can specify an arbitrary callable with arguments::\n892 \n893         >>> def f(x): return 1/x\n894         ...\n895         >>> raises(ZeroDivisionError, f, 0)\n896         <ExceptionInfo ...>\n897         >>> raises(ZeroDivisionError, f, x=0)\n898         <ExceptionInfo ...>\n899 \n900     The form above is fully supported but discouraged for new code because the\n901     context manager form is regarded as more readable and less error-prone.\n902 \n903     .. note::\n904         Similar to caught exception objects in Python, explicitly clearing\n905         local references to returned ``ExceptionInfo`` objects can\n906         help the Python interpreter speed up its garbage collection.\n907 \n908         Clearing those references breaks a reference cycle\n909         (``ExceptionInfo`` --> caught exception --> frame stack raising\n910         the exception --> current frame stack --> local variables -->\n911         ``ExceptionInfo``) which makes Python keep all objects referenced\n912         from that cycle (including all local variables in the current\n913         frame) alive until the next cyclic garbage collection run.\n914         More detailed information can be found in the official Python\n915         documentation for :ref:`the try statement <python:try>`.\n916     \"\"\"\n917     __tracebackhide__ = True\n918 \n919     if not expected_exception:\n920         raise ValueError(\n921             f\"Expected an exception type or a tuple of exception types, but got `{expected_exception!r}`. \"\n922             f\"Raising exceptions is already understood as failing the test, so you don't need \"\n923             f\"any special code to say 'this should never raise an exception'.\"\n924         )\n925     if isinstance(expected_exception, type):\n926         expected_exceptions: Tuple[Type[E], ...] = (expected_exception,)\n927     else:\n928         expected_exceptions = expected_exception\n929     for exc in expected_exceptions:\n930         if not isinstance(exc, type) or not issubclass(exc, BaseException):\n931             msg = \"expected exception must be a BaseException type, not {}\"  # type: ignore[unreachable]\n932             not_a = exc.__name__ if isinstance(exc, type) else type(exc).__name__\n933             raise TypeError(msg.format(not_a))\n934 \n935     message = f\"DID NOT RAISE {expected_exception}\"\n936 \n937     if not args:\n938         match: Optional[Union[str, Pattern[str]]] = kwargs.pop(\"match\", None)\n939         if kwargs:\n940             msg = \"Unexpected keyword arguments passed to pytest.raises: \"\n941             msg += \", \".join(sorted(kwargs))\n942             msg += \"\\nUse context-manager form instead?\"\n943             raise TypeError(msg)\n944         return RaisesContext(expected_exception, message, match)\n945     else:\n946         func = args[0]\n947         if not callable(func):\n948             raise TypeError(f\"{func!r} object (type: {type(func)}) must be callable\")\n949         try:\n950             func(*args[1:], **kwargs)\n951         except expected_exception as e:\n952             return _pytest._code.ExceptionInfo.from_exception(e)\n953     fail(message)\n954 \n955 \n956 # This doesn't work with mypy for now. Use fail.Exception instead.\n957 raises.Exception = fail.Exception  # type: ignore\n958 \n959 \n960 @final\n961 class RaisesContext(ContextManager[_pytest._code.ExceptionInfo[E]]):\n962     def __init__(\n963         self,\n964         expected_exception: Union[Type[E], Tuple[Type[E], ...]],\n965         message: str,\n966         match_expr: Optional[Union[str, Pattern[str]]] = None,\n967     ) -> None:\n968         self.expected_exception = expected_exception\n969         self.message = message\n970         self.match_expr = match_expr\n971         self.excinfo: Optional[_pytest._code.ExceptionInfo[E]] = None\n972 \n973     def __enter__(self) -> _pytest._code.ExceptionInfo[E]:\n974         self.excinfo = _pytest._code.ExceptionInfo.for_later()\n975         return self.excinfo\n976 \n977     def __exit__(\n978         self,\n979         exc_type: Optional[Type[BaseException]],\n980         exc_val: Optional[BaseException],\n981         exc_tb: Optional[TracebackType],\n982     ) -> bool:\n983         __tracebackhide__ = True\n984         if exc_type is None:\n985             fail(self.message)\n986         assert self.excinfo is not None\n987         if not issubclass(exc_type, self.expected_exception):\n988             return False\n989         # Cast to narrow the exception type now that it's verified.\n990         exc_info = cast(Tuple[Type[E], E, TracebackType], (exc_type, exc_val, exc_tb))\n991         self.excinfo.fill_unfilled(exc_info)\n992         if self.match_expr is not None:\n993             self.excinfo.match(self.match_expr)\n994         return True\n",
        "intended_behavior": "When `approx` encounters a dictionary value or a sequence element that is `None`, it should not raise a `TypeError`. Instead, it should gracefully compare the value to `None` directly, effectively treating it as a strict equality comparison. This update would not alter the existing functionality for numeric and other types that `approx` currently supports. For numeric comparisons, `approx` should continue to work as it does now, using specified tolerances to determine equality. The change would specifically cater to the case where `None` is part of a complex structure like a dictionary or a list that is being compared, making `approx` more versatile and user-friendly for testing scenarios where optional values represented by `None` are expected."
    }
]