[
    {
        "rel_file_path": "lib/matplotlib/widgets.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.4/lib/matplotlib/widgets.py",
        "start": 1,
        "end": 3568,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 GUI neutral widgets\n3 ===================\n4 \n5 Widgets that are designed to work for any of the GUI backends.\n6 All of these widgets require you to predefine a `matplotlib.axes.Axes`\n7 instance and pass that as the first parameter.  Matplotlib doesn't try to\n8 be too smart with respect to layout -- you will have to figure out how\n9 wide and tall you want your Axes to be to accommodate your widget.\n10 \"\"\"\n11 \n12 from contextlib import ExitStack\n13 import copy\n14 from numbers import Integral, Number\n15 \n16 import numpy as np\n17 \n18 import matplotlib as mpl\n19 from matplotlib import docstring\n20 from . import _api, backend_tools, cbook, colors, ticker\n21 from .lines import Line2D\n22 from .patches import Circle, Rectangle, Ellipse\n23 \n24 \n25 class LockDraw:\n26     \"\"\"\n27     Some widgets, like the cursor, draw onto the canvas, and this is not\n28     desirable under all circumstances, like when the toolbar is in zoom-to-rect\n29     mode and drawing a rectangle.  To avoid this, a widget can acquire a\n30     canvas' lock with ``canvas.widgetlock(widget)`` before drawing on the\n31     canvas; this will prevent other widgets from doing so at the same time (if\n32     they also try to acquire the lock first).\n33     \"\"\"\n34 \n35     def __init__(self):\n36         self._owner = None\n37 \n38     def __call__(self, o):\n39         \"\"\"Reserve the lock for *o*.\"\"\"\n40         if not self.available(o):\n41             raise ValueError('already locked')\n42         self._owner = o\n43 \n44     def release(self, o):\n45         \"\"\"Release the lock from *o*.\"\"\"\n46         if not self.available(o):\n47             raise ValueError('you do not own this lock')\n48         self._owner = None\n49 \n50     def available(self, o):\n51         \"\"\"Return whether drawing is available to *o*.\"\"\"\n52         return not self.locked() or self.isowner(o)\n53 \n54     def isowner(self, o):\n55         \"\"\"Return whether *o* owns this lock.\"\"\"\n56         return self._owner is o\n57 \n58     def locked(self):\n59         \"\"\"Return whether the lock is currently held by an owner.\"\"\"\n60         return self._owner is not None\n61 \n62 \n63 class Widget:\n64     \"\"\"\n65     Abstract base class for GUI neutral widgets.\n66     \"\"\"\n67     drawon = True\n68     eventson = True\n69     _active = True\n70 \n71     def set_active(self, active):\n72         \"\"\"Set whether the widget is active.\"\"\"\n73         self._active = active\n74 \n75     def get_active(self):\n76         \"\"\"Get whether the widget is active.\"\"\"\n77         return self._active\n78 \n79     # set_active is overridden by SelectorWidgets.\n80     active = property(get_active, set_active, doc=\"Is the widget active?\")\n81 \n82     def ignore(self, event):\n83         \"\"\"\n84         Return whether *event* should be ignored.\n85 \n86         This method should be called at the beginning of any event callback.\n87         \"\"\"\n88         return not self.active\n89 \n90 \n91 class AxesWidget(Widget):\n92     \"\"\"\n93     Widget connected to a single `~matplotlib.axes.Axes`.\n94 \n95     To guarantee that the widget remains responsive and not garbage-collected,\n96     a reference to the object should be maintained by the user.\n97 \n98     This is necessary because the callback registry\n99     maintains only weak-refs to the functions, which are member\n100     functions of the widget.  If there are no references to the widget\n101     object it may be garbage collected which will disconnect the callbacks.\n102 \n103     Attributes\n104     ----------\n105     ax : `~matplotlib.axes.Axes`\n106         The parent axes for the widget.\n107     canvas : `~matplotlib.backend_bases.FigureCanvasBase`\n108         The parent figure canvas for the widget.\n109     active : bool\n110         If False, the widget does not respond to events.\n111     \"\"\"\n112 \n113     cids = _api.deprecated(\"3.4\")(property(lambda self: self._cids))\n114 \n115     def __init__(self, ax):\n116         self.ax = ax\n117         self.canvas = ax.figure.canvas\n118         self._cids = []\n119 \n120     def connect_event(self, event, callback):\n121         \"\"\"\n122         Connect a callback function with an event.\n123 \n124         This should be used in lieu of ``figure.canvas.mpl_connect`` since this\n125         function stores callback ids for later clean up.\n126         \"\"\"\n127         cid = self.canvas.mpl_connect(event, callback)\n128         self._cids.append(cid)\n129 \n130     def disconnect_events(self):\n131         \"\"\"Disconnect all events created by this widget.\"\"\"\n132         for c in self._cids:\n133             self.canvas.mpl_disconnect(c)\n134 \n135 \n136 class Button(AxesWidget):\n137     \"\"\"\n138     A GUI neutral button.\n139 \n140     For the button to remain responsive you must keep a reference to it.\n141     Call `.on_clicked` to connect to the button.\n142 \n143     Attributes\n144     ----------\n145     ax\n146         The `matplotlib.axes.Axes` the button renders into.\n147     label\n148         A `matplotlib.text.Text` instance.\n149     color\n150         The color of the button when not hovering.\n151     hovercolor\n152         The color of the button when hovering.\n153     \"\"\"\n154 \n155     cnt = _api.deprecated(\"3.4\")(property(  # Not real, but close enough.\n156         lambda self: len(self._observers.callbacks['clicked'])))\n157     observers = _api.deprecated(\"3.4\")(property(\n158         lambda self: self._observers.callbacks['clicked']))\n159 \n160     def __init__(self, ax, label, image=None,\n161                  color='0.85', hovercolor='0.95'):\n162         \"\"\"\n163         Parameters\n164         ----------\n165         ax : `~matplotlib.axes.Axes`\n166             The `~.axes.Axes` instance the button will be placed into.\n167         label : str\n168             The button text.\n169         image : array-like or PIL Image\n170             The image to place in the button, if not *None*.  The parameter is\n171             directly forwarded to `~matplotlib.axes.Axes.imshow`.\n172         color : color\n173             The color of the button when not activated.\n174         hovercolor : color\n175             The color of the button when the mouse is over it.\n176         \"\"\"\n177         super().__init__(ax)\n178 \n179         if image is not None:\n180             ax.imshow(image)\n181         self.label = ax.text(0.5, 0.5, label,\n182                              verticalalignment='center',\n183                              horizontalalignment='center',\n184                              transform=ax.transAxes)\n185 \n186         self._observers = cbook.CallbackRegistry()\n187 \n188         self.connect_event('button_press_event', self._click)\n189         self.connect_event('button_release_event', self._release)\n190         self.connect_event('motion_notify_event', self._motion)\n191         ax.set_navigate(False)\n192         ax.set_facecolor(color)\n193         ax.set_xticks([])\n194         ax.set_yticks([])\n195         self.color = color\n196         self.hovercolor = hovercolor\n197 \n198     def _click(self, event):\n199         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:\n200             return\n201         if event.canvas.mouse_grabber != self.ax:\n202             event.canvas.grab_mouse(self.ax)\n203 \n204     def _release(self, event):\n205         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:\n206             return\n207         event.canvas.release_mouse(self.ax)\n208         if self.eventson and event.inaxes == self.ax:\n209             self._observers.process('clicked', event)\n210 \n211     def _motion(self, event):\n212         if self.ignore(event):\n213             return\n214         c = self.hovercolor if event.inaxes == self.ax else self.color\n215         if not colors.same_color(c, self.ax.get_facecolor()):\n216             self.ax.set_facecolor(c)\n217             if self.drawon:\n218                 self.ax.figure.canvas.draw()\n219 \n220     def on_clicked(self, func):\n221         \"\"\"\n222         Connect the callback function *func* to button click events.\n223 \n224         Returns a connection id, which can be used to disconnect the callback.\n225         \"\"\"\n226         return self._observers.connect('clicked', lambda event: func(event))\n227 \n228     def disconnect(self, cid):\n229         \"\"\"Remove the callback function with connection id *cid*.\"\"\"\n230         self._observers.disconnect(cid)\n231 \n232 \n233 class SliderBase(AxesWidget):\n234     \"\"\"\n235     The base class for constructing Slider widgets. Not intended for direct\n236     usage.\n237 \n238     For the slider to remain responsive you must maintain a reference to it.\n239     \"\"\"\n240     def __init__(self, ax, orientation, closedmin, closedmax,\n241                  valmin, valmax, valfmt, dragging, valstep):\n242         if ax.name == '3d':\n243             raise ValueError('Sliders cannot be added to 3D Axes')\n244 \n245         super().__init__(ax)\n246         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)\n247 \n248         self.orientation = orientation\n249         self.closedmin = closedmin\n250         self.closedmax = closedmax\n251         self.valmin = valmin\n252         self.valmax = valmax\n253         self.valstep = valstep\n254         self.drag_active = False\n255         self.valfmt = valfmt\n256 \n257         if orientation == \"vertical\":\n258             ax.set_ylim((valmin, valmax))\n259             axis = ax.yaxis\n260         else:\n261             ax.set_xlim((valmin, valmax))\n262             axis = ax.xaxis\n263 \n264         self._fmt = axis.get_major_formatter()\n265         if not isinstance(self._fmt, ticker.ScalarFormatter):\n266             self._fmt = ticker.ScalarFormatter()\n267             self._fmt.set_axis(axis)\n268         self._fmt.set_useOffset(False)  # No additive offset.\n269         self._fmt.set_useMathText(True)  # x sign before multiplicative offset.\n270 \n271         ax.set_axis_off()\n272         ax.set_navigate(False)\n273 \n274         self.connect_event(\"button_press_event\", self._update)\n275         self.connect_event(\"button_release_event\", self._update)\n276         if dragging:\n277             self.connect_event(\"motion_notify_event\", self._update)\n278         self._observers = cbook.CallbackRegistry()\n279 \n280     def _stepped_value(self, val):\n281         \"\"\"Return *val* coerced to closest number in the ``valstep`` grid.\"\"\"\n282         if isinstance(self.valstep, Number):\n283             val = (self.valmin\n284                    + round((val - self.valmin) / self.valstep) * self.valstep)\n285         elif self.valstep is not None:\n286             valstep = np.asanyarray(self.valstep)\n287             if valstep.ndim != 1:\n288                 raise ValueError(\n289                     f\"valstep must have 1 dimension but has {valstep.ndim}\"\n290                 )\n291             val = valstep[np.argmin(np.abs(valstep - val))]\n292         return val\n293 \n294     def disconnect(self, cid):\n295         \"\"\"\n296         Remove the observer with connection id *cid*.\n297 \n298         Parameters\n299         ----------\n300         cid : int\n301             Connection id of the observer to be removed.\n302         \"\"\"\n303         self._observers.disconnect(cid)\n304 \n305     def reset(self):\n306         \"\"\"Reset the slider to the initial value.\"\"\"\n307         if self.val != self.valinit:\n308             self.set_val(self.valinit)\n309 \n310 \n311 class Slider(SliderBase):\n312     \"\"\"\n313     A slider representing a floating point range.\n314 \n315     Create a slider from *valmin* to *valmax* in axes *ax*. For the slider to\n316     remain responsive you must maintain a reference to it. Call\n317     :meth:`on_changed` to connect to the slider event.\n318 \n319     Attributes\n320     ----------\n321     val : float\n322         Slider value.\n323     \"\"\"\n324 \n325     cnt = _api.deprecated(\"3.4\")(property(  # Not real, but close enough.\n326         lambda self: len(self._observers.callbacks['changed'])))\n327     observers = _api.deprecated(\"3.4\")(property(\n328         lambda self: self._observers.callbacks['changed']))\n329 \n330     def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt=None,\n331                  closedmin=True, closedmax=True, slidermin=None,\n332                  slidermax=None, dragging=True, valstep=None,\n333                  orientation='horizontal', *, initcolor='r',\n334                  track_color='lightgrey', handle_style=None, **kwargs):\n335         \"\"\"\n336         Parameters\n337         ----------\n338         ax : Axes\n339             The Axes to put the slider in.\n340 \n341         label : str\n342             Slider label.\n343 \n344         valmin : float\n345             The minimum value of the slider.\n346 \n347         valmax : float\n348             The maximum value of the slider.\n349 \n350         valinit : float, default: 0.5\n351             The slider initial position.\n352 \n353         valfmt : str, default: None\n354             %-format string used to format the slider value.  If None, a\n355             `.ScalarFormatter` is used instead.\n356 \n357         closedmin : bool, default: True\n358             Whether the slider interval is closed on the bottom.\n359 \n360         closedmax : bool, default: True\n361             Whether the slider interval is closed on the top.\n362 \n363         slidermin : Slider, default: None\n364             Do not allow the current slider to have a value less than\n365             the value of the Slider *slidermin*.\n366 \n367         slidermax : Slider, default: None\n368             Do not allow the current slider to have a value greater than\n369             the value of the Slider *slidermax*.\n370 \n371         dragging : bool, default: True\n372             If True the slider can be dragged by the mouse.\n373 \n374         valstep : float or array-like, default: None\n375             If a float, the slider will snap to multiples of *valstep*.\n376             If an array the slider will snap to the values in the array.\n377 \n378         orientation : {'horizontal', 'vertical'}, default: 'horizontal'\n379             The orientation of the slider.\n380 \n381         initcolor : color, default: 'r'\n382             The color of the line at the *valinit* position. Set to ``'none'``\n383             for no line.\n384 \n385         track_color : color, default: 'lightgrey'\n386             The color of the background track. The track is accessible for\n387             further styling via the *track* attribute.\n388 \n389         handle_style : dict\n390             Properties of the slider handle. Default values are\n391 \n392             ========= ===== ======= ========================================\n393             Key       Value Default Description\n394             ========= ===== ======= ========================================\n395             facecolor color 'white' The facecolor of the slider handle.\n396             edgecolor color '.75'   The edgecolor of the slider handle.\n397             size      int   10      The size of the slider handle in points.\n398             ========= ===== ======= ========================================\n399 \n400             Other values will be transformed as marker{foo} and passed to the\n401             `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will\n402             result in ``markerstyle = 'x'``.\n403 \n404         Notes\n405         -----\n406         Additional kwargs are passed on to ``self.poly`` which is the\n407         `~matplotlib.patches.Polygon` that draws the slider knob.  See the\n408         `.Polygon` documentation for valid property names (``facecolor``,\n409         ``edgecolor``, ``alpha``, etc.).\n410         \"\"\"\n411         super().__init__(ax, orientation, closedmin, closedmax,\n412                          valmin, valmax, valfmt, dragging, valstep)\n413 \n414         if slidermin is not None and not hasattr(slidermin, 'val'):\n415             raise ValueError(\n416                 f\"Argument slidermin ({type(slidermin)}) has no 'val'\")\n417         if slidermax is not None and not hasattr(slidermax, 'val'):\n418             raise ValueError(\n419                 f\"Argument slidermax ({type(slidermax)}) has no 'val'\")\n420         self.slidermin = slidermin\n421         self.slidermax = slidermax\n422         valinit = self._value_in_bounds(valinit)\n423         if valinit is None:\n424             valinit = valmin\n425         self.val = valinit\n426         self.valinit = valinit\n427 \n428         defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}\n429         handle_style = {} if handle_style is None else handle_style\n430         marker_props = {\n431             f'marker{k}': v for k, v in {**defaults, **handle_style}.items()\n432         }\n433 \n434         if orientation == 'vertical':\n435             self.track = Rectangle(\n436                 (.25, 0), .5, 1,\n437                 transform=ax.transAxes,\n438                 facecolor=track_color\n439             )\n440             ax.add_patch(self.track)\n441             self.poly = ax.axhspan(valmin, valinit, .25, .75, **kwargs)\n442             self.hline = ax.axhline(valinit, .15, .85, color=initcolor, lw=1)\n443             handleXY = [[0.5], [valinit]]\n444         else:\n445             self.track = Rectangle(\n446                 (0, .25), 1, .5,\n447                 transform=ax.transAxes,\n448                 facecolor=track_color\n449             )\n450             ax.add_patch(self.track)\n451             self.poly = ax.axvspan(valmin, valinit, .25, .75, **kwargs)\n452             # These asymmetric limits (.2, .9) minimize the asymmetry\n453             # above and below the *poly* when rendered to pixels.\n454             # This seems to be different for Horizontal and Vertical lines.\n455             # For discussion see:\n456             # https://github.com/matplotlib/matplotlib/pull/19265\n457             self.vline = ax.axvline(valinit, .2, .9, color=initcolor, lw=1)\n458             handleXY = [[valinit], [0.5]]\n459         self._handle, = ax.plot(\n460             *handleXY,\n461             \"o\",\n462             **marker_props,\n463             clip_on=False\n464         )\n465 \n466         if orientation == 'vertical':\n467             self.label = ax.text(0.5, 1.02, label, transform=ax.transAxes,\n468                                  verticalalignment='bottom',\n469                                  horizontalalignment='center')\n470 \n471             self.valtext = ax.text(0.5, -0.02, self._format(valinit),\n472                                    transform=ax.transAxes,\n473                                    verticalalignment='top',\n474                                    horizontalalignment='center')\n475         else:\n476             self.label = ax.text(-0.02, 0.5, label, transform=ax.transAxes,\n477                                  verticalalignment='center',\n478                                  horizontalalignment='right')\n479 \n480             self.valtext = ax.text(1.02, 0.5, self._format(valinit),\n481                                    transform=ax.transAxes,\n482                                    verticalalignment='center',\n483                                    horizontalalignment='left')\n484 \n485         self.set_val(valinit)\n486 \n487     def _value_in_bounds(self, val):\n488         \"\"\"Makes sure *val* is with given bounds.\"\"\"\n489         val = self._stepped_value(val)\n490 \n491         if val <= self.valmin:\n492             if not self.closedmin:\n493                 return\n494             val = self.valmin\n495         elif val >= self.valmax:\n496             if not self.closedmax:\n497                 return\n498             val = self.valmax\n499 \n500         if self.slidermin is not None and val <= self.slidermin.val:\n501             if not self.closedmin:\n502                 return\n503             val = self.slidermin.val\n504 \n505         if self.slidermax is not None and val >= self.slidermax.val:\n506             if not self.closedmax:\n507                 return\n508             val = self.slidermax.val\n509         return val\n510 \n511     def _update(self, event):\n512         \"\"\"Update the slider position.\"\"\"\n513         if self.ignore(event) or event.button != 1:\n514             return\n515 \n516         if event.name == 'button_press_event' and event.inaxes == self.ax:\n517             self.drag_active = True\n518             event.canvas.grab_mouse(self.ax)\n519 \n520         if not self.drag_active:\n521             return\n522 \n523         elif ((event.name == 'button_release_event') or\n524               (event.name == 'button_press_event' and\n525                event.inaxes != self.ax)):\n526             self.drag_active = False\n527             event.canvas.release_mouse(self.ax)\n528             return\n529         if self.orientation == 'vertical':\n530             val = self._value_in_bounds(event.ydata)\n531         else:\n532             val = self._value_in_bounds(event.xdata)\n533         if val not in [None, self.val]:\n534             self.set_val(val)\n535 \n536     def _format(self, val):\n537         \"\"\"Pretty-print *val*.\"\"\"\n538         if self.valfmt is not None:\n539             return self.valfmt % val\n540         else:\n541             _, s, _ = self._fmt.format_ticks([self.valmin, val, self.valmax])\n542             # fmt.get_offset is actually the multiplicative factor, if any.\n543             return s + self._fmt.get_offset()\n544 \n545     def set_val(self, val):\n546         \"\"\"\n547         Set slider value to *val*.\n548 \n549         Parameters\n550         ----------\n551         val : float\n552         \"\"\"\n553         xy = self.poly.xy\n554         if self.orientation == 'vertical':\n555             xy[1] = .25, val\n556             xy[2] = .75, val\n557             self._handle.set_ydata([val])\n558         else:\n559             xy[2] = val, .75\n560             xy[3] = val, .25\n561             self._handle.set_xdata([val])\n562         self.poly.xy = xy\n563         self.valtext.set_text(self._format(val))\n564         if self.drawon:\n565             self.ax.figure.canvas.draw_idle()\n566         self.val = val\n567         if self.eventson:\n568             self._observers.process('changed', val)\n569 \n570     def on_changed(self, func):\n571         \"\"\"\n572         Connect *func* as callback function to changes of the slider value.\n573 \n574         Parameters\n575         ----------\n576         func : callable\n577             Function to call when slider is changed.\n578             The function must accept a single float as its arguments.\n579 \n580         Returns\n581         -------\n582         int\n583             Connection id (which can be used to disconnect *func*).\n584         \"\"\"\n585         return self._observers.connect('changed', lambda val: func(val))\n586 \n587 \n588 class RangeSlider(SliderBase):\n589     \"\"\"\n590     A slider representing a range of floating point values. Defines the min and\n591     max of the range via the *val* attribute as a tuple of (min, max).\n592 \n593     Create a slider that defines a range contained within [*valmin*, *valmax*]\n594     in axes *ax*. For the slider to remain responsive you must maintain a\n595     reference to it. Call :meth:`on_changed` to connect to the slider event.\n596 \n597     Attributes\n598     ----------\n599     val : tuple of float\n600         Slider value.\n601     \"\"\"\n602 \n603     def __init__(\n604         self,\n605         ax,\n606         label,\n607         valmin,\n608         valmax,\n609         valinit=None,\n610         valfmt=None,\n611         closedmin=True,\n612         closedmax=True,\n613         dragging=True,\n614         valstep=None,\n615         orientation=\"horizontal\",\n616         track_color='lightgrey',\n617         handle_style=None,\n618         **kwargs,\n619     ):\n620         \"\"\"\n621         Parameters\n622         ----------\n623         ax : Axes\n624             The Axes to put the slider in.\n625 \n626         label : str\n627             Slider label.\n628 \n629         valmin : float\n630             The minimum value of the slider.\n631 \n632         valmax : float\n633             The maximum value of the slider.\n634 \n635         valinit : tuple of float or None, default: None\n636             The initial positions of the slider. If None the initial positions\n637             will be at the 25th and 75th percentiles of the range.\n638 \n639         valfmt : str, default: None\n640             %-format string used to format the slider values.  If None, a\n641             `.ScalarFormatter` is used instead.\n642 \n643         closedmin : bool, default: True\n644             Whether the slider interval is closed on the bottom.\n645 \n646         closedmax : bool, default: True\n647             Whether the slider interval is closed on the top.\n648 \n649         dragging : bool, default: True\n650             If True the slider can be dragged by the mouse.\n651 \n652         valstep : float, default: None\n653             If given, the slider will snap to multiples of *valstep*.\n654 \n655         orientation : {'horizontal', 'vertical'}, default: 'horizontal'\n656             The orientation of the slider.\n657 \n658         track_color : color, default: 'lightgrey'\n659             The color of the background track. The track is accessible for\n660             further styling via the *track* attribute.\n661 \n662         handle_style : dict\n663             Properties of the slider handles. Default values are\n664 \n665             ========= ===== ======= =========================================\n666             Key       Value Default Description\n667             ========= ===== ======= =========================================\n668             facecolor color 'white' The facecolor of the slider handles.\n669             edgecolor color '.75'   The edgecolor of the slider handles.\n670             size      int   10      The size of the slider handles in points.\n671             ========= ===== ======= =========================================\n672 \n673             Other values will be transformed as marker{foo} and passed to the\n674             `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will\n675             result in ``markerstyle = 'x'``.\n676 \n677         Notes\n678         -----\n679         Additional kwargs are passed on to ``self.poly`` which is the\n680         `~matplotlib.patches.Polygon` that draws the slider knob.  See the\n681         `.Polygon` documentation for valid property names (``facecolor``,\n682         ``edgecolor``, ``alpha``, etc.).\n683         \"\"\"\n684         super().__init__(ax, orientation, closedmin, closedmax,\n685                          valmin, valmax, valfmt, dragging, valstep)\n686 \n687         # Set a value to allow _value_in_bounds() to work.\n688         self.val = [valmin, valmax]\n689         if valinit is None:\n690             # Place at the 25th and 75th percentiles\n691             extent = valmax - valmin\n692             valinit = np.array([valmin + extent * 0.25,\n693                                 valmin + extent * 0.75])\n694         else:\n695             valinit = self._value_in_bounds(valinit)\n696         self.val = valinit\n697         self.valinit = valinit\n698 \n699         defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}\n700         handle_style = {} if handle_style is None else handle_style\n701         marker_props = {\n702             f'marker{k}': v for k, v in {**defaults, **handle_style}.items()\n703         }\n704 \n705         if orientation == \"vertical\":\n706             self.track = Rectangle(\n707                 (.25, 0), .5, 2,\n708                 transform=ax.transAxes,\n709                 facecolor=track_color\n710             )\n711             ax.add_patch(self.track)\n712             self.poly = ax.axhspan(valinit[0], valinit[1], 0, 1, **kwargs)\n713             handleXY_1 = [.5, valinit[0]]\n714             handleXY_2 = [.5, valinit[1]]\n715         else:\n716             self.track = Rectangle(\n717                 (0, .25), 1, .5,\n718                 transform=ax.transAxes,\n719                 facecolor=track_color\n720             )\n721             ax.add_patch(self.track)\n722             self.poly = ax.axvspan(valinit[0], valinit[1], 0, 1, **kwargs)\n723             handleXY_1 = [valinit[0], .5]\n724             handleXY_2 = [valinit[1], .5]\n725         self._handles = [\n726             ax.plot(\n727                 *handleXY_1,\n728                 \"o\",\n729                 **marker_props,\n730                 clip_on=False\n731             )[0],\n732             ax.plot(\n733                 *handleXY_2,\n734                 \"o\",\n735                 **marker_props,\n736                 clip_on=False\n737             )[0]\n738         ]\n739 \n740         if orientation == \"vertical\":\n741             self.label = ax.text(\n742                 0.5,\n743                 1.02,\n744                 label,\n745                 transform=ax.transAxes,\n746                 verticalalignment=\"bottom\",\n747                 horizontalalignment=\"center\",\n748             )\n749 \n750             self.valtext = ax.text(\n751                 0.5,\n752                 -0.02,\n753                 self._format(valinit),\n754                 transform=ax.transAxes,\n755                 verticalalignment=\"top\",\n756                 horizontalalignment=\"center\",\n757             )\n758         else:\n759             self.label = ax.text(\n760                 -0.02,\n761                 0.5,\n762                 label,\n763                 transform=ax.transAxes,\n764                 verticalalignment=\"center\",\n765                 horizontalalignment=\"right\",\n766             )\n767 \n768             self.valtext = ax.text(\n769                 1.02,\n770                 0.5,\n771                 self._format(valinit),\n772                 transform=ax.transAxes,\n773                 verticalalignment=\"center\",\n774                 horizontalalignment=\"left\",\n775             )\n776 \n777         self._active_handle = None\n778         self.set_val(valinit)\n779 \n780     def _min_in_bounds(self, min):\n781         \"\"\"Ensure the new min value is between valmin and self.val[1].\"\"\"\n782         if min <= self.valmin:\n783             if not self.closedmin:\n784                 return self.val[0]\n785             min = self.valmin\n786 \n787         if min > self.val[1]:\n788             min = self.val[1]\n789         return self._stepped_value(min)\n790 \n791     def _max_in_bounds(self, max):\n792         \"\"\"Ensure the new max value is between valmax and self.val[0].\"\"\"\n793         if max >= self.valmax:\n794             if not self.closedmax:\n795                 return self.val[1]\n796             max = self.valmax\n797 \n798         if max <= self.val[0]:\n799             max = self.val[0]\n800         return self._stepped_value(max)\n801 \n802     def _value_in_bounds(self, vals):\n803         \"\"\"Clip min, max values to the bounds.\"\"\"\n804         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))\n805 \n806     def _update_val_from_pos(self, pos):\n807         \"\"\"Update the slider value based on a given position.\"\"\"\n808         idx = np.argmin(np.abs(self.val - pos))\n809         if idx == 0:\n810             val = self._min_in_bounds(pos)\n811             self.set_min(val)\n812         else:\n813             val = self._max_in_bounds(pos)\n814             self.set_max(val)\n815         if self._active_handle:\n816             self._active_handle.set_xdata([val])\n817 \n818     def _update(self, event):\n819         \"\"\"Update the slider position.\"\"\"\n820         if self.ignore(event) or event.button != 1:\n821             return\n822 \n823         if event.name == \"button_press_event\" and event.inaxes == self.ax:\n824             self.drag_active = True\n825             event.canvas.grab_mouse(self.ax)\n826 \n827         if not self.drag_active:\n828             return\n829 \n830         elif (event.name == \"button_release_event\") or (\n831             event.name == \"button_press_event\" and event.inaxes != self.ax\n832         ):\n833             self.drag_active = False\n834             event.canvas.release_mouse(self.ax)\n835             self._active_handle = None\n836             return\n837 \n838         # determine which handle was grabbed\n839         handle = self._handles[\n840             np.argmin(\n841                 np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n842             )\n843         ]\n844         # these checks ensure smooth behavior if the handles swap which one\n845         # has a higher value. i.e. if one is dragged over and past the other.\n846         if handle is not self._active_handle:\n847             self._active_handle = handle\n848 \n849         if self.orientation == \"vertical\":\n850             self._update_val_from_pos(event.ydata)\n851         else:\n852             self._update_val_from_pos(event.xdata)\n853 \n854     def _format(self, val):\n855         \"\"\"Pretty-print *val*.\"\"\"\n856         if self.valfmt is not None:\n857             return f\"({self.valfmt % val[0]}, {self.valfmt % val[1]})\"\n858         else:\n859             _, s1, s2, _ = self._fmt.format_ticks(\n860                 [self.valmin, *val, self.valmax]\n861             )\n862             # fmt.get_offset is actually the multiplicative factor, if any.\n863             s1 += self._fmt.get_offset()\n864             s2 += self._fmt.get_offset()\n865             # Use f string to avoid issues with backslashes when cast to a str\n866             return f\"({s1}, {s2})\"\n867 \n868     def set_min(self, min):\n869         \"\"\"\n870         Set the lower value of the slider to *min*.\n871 \n872         Parameters\n873         ----------\n874         min : float\n875         \"\"\"\n876         self.set_val((min, self.val[1]))\n877 \n878     def set_max(self, max):\n879         \"\"\"\n880         Set the lower value of the slider to *max*.\n881 \n882         Parameters\n883         ----------\n884         max : float\n885         \"\"\"\n886         self.set_val((self.val[0], max))\n887 \n888     def set_val(self, val):\n889         \"\"\"\n890         Set slider value to *val*.\n891 \n892         Parameters\n893         ----------\n894         val : tuple or array-like of float\n895         \"\"\"\n896         val = np.sort(np.asanyarray(val))\n897         if val.shape != (2,):\n898             raise ValueError(\n899                 f\"val must have shape (2,) but has shape {val.shape}\"\n900             )\n901         val[0] = self._min_in_bounds(val[0])\n902         val[1] = self._max_in_bounds(val[1])\n903         xy = self.poly.xy\n904         if self.orientation == \"vertical\":\n905             xy[0] = .25, val[0]\n906             xy[1] = .25, val[1]\n907             xy[2] = .75, val[1]\n908             xy[3] = .75, val[0]\n909             xy[4] = .25, val[0]\n910         else:\n911             xy[0] = val[0], .25\n912             xy[1] = val[0], .75\n913             xy[2] = val[1], .75\n914             xy[3] = val[1], .25\n915             xy[4] = val[0], .25\n916         self.poly.xy = xy\n917         self.valtext.set_text(self._format(val))\n918         if self.drawon:\n919             self.ax.figure.canvas.draw_idle()\n920         self.val = val\n921         if self.eventson:\n922             self._observers.process(\"changed\", val)\n923 \n924     def on_changed(self, func):\n925         \"\"\"\n926         Connect *func* as callback function to changes of the slider value.\n927 \n928         Parameters\n929         ----------\n930         func : callable\n931             Function to call when slider is changed. The function\n932             must accept a numpy array with shape (2,) as its argument.\n933 \n934         Returns\n935         -------\n936         int\n937             Connection id (which can be used to disconnect *func*).\n938         \"\"\"\n939         return self._observers.connect('changed', lambda val: func(val))\n940 \n941 \n942 class CheckButtons(AxesWidget):\n943     r\"\"\"\n944     A GUI neutral set of check buttons.\n945 \n946     For the check buttons to remain responsive you must keep a\n947     reference to this object.\n948 \n949     Connect to the CheckButtons with the `.on_clicked` method.\n950 \n951     Attributes\n952     ----------\n953     ax : `~matplotlib.axes.Axes`\n954         The parent axes for the widget.\n955     labels : list of `.Text`\n956 \n957     rectangles : list of `.Rectangle`\n958 \n959     lines : list of (`.Line2D`, `.Line2D`) pairs\n960         List of lines for the x's in the check boxes.  These lines exist for\n961         each box, but have ``set_visible(False)`` when its box is not checked.\n962     \"\"\"\n963 \n964     cnt = _api.deprecated(\"3.4\")(property(  # Not real, but close enough.\n965         lambda self: len(self._observers.callbacks['clicked'])))\n966     observers = _api.deprecated(\"3.4\")(property(\n967         lambda self: self._observers.callbacks['clicked']))\n968 \n969     def __init__(self, ax, labels, actives=None):\n970         \"\"\"\n971         Add check buttons to `matplotlib.axes.Axes` instance *ax*.\n972 \n973         Parameters\n974         ----------\n975         ax : `~matplotlib.axes.Axes`\n976             The parent axes for the widget.\n977 \n978         labels : list of str\n979             The labels of the check buttons.\n980 \n981         actives : list of bool, optional\n982             The initial check states of the buttons. The list must have the\n983             same length as *labels*. If not given, all buttons are unchecked.\n984         \"\"\"\n985         super().__init__(ax)\n986 \n987         ax.set_xticks([])\n988         ax.set_yticks([])\n989         ax.set_navigate(False)\n990 \n991         if actives is None:\n992             actives = [False] * len(labels)\n993 \n994         if len(labels) > 1:\n995             dy = 1. / (len(labels) + 1)\n996             ys = np.linspace(1 - dy, dy, len(labels))\n997         else:\n998             dy = 0.25\n999             ys = [0.5]\n1000 \n1001         axcolor = ax.get_facecolor()\n1002 \n1003         self.labels = []\n1004         self.lines = []\n1005         self.rectangles = []\n1006 \n1007         lineparams = {'color': 'k', 'linewidth': 1.25,\n1008                       'transform': ax.transAxes, 'solid_capstyle': 'butt'}\n1009         for y, label, active in zip(ys, labels, actives):\n1010             t = ax.text(0.25, y, label, transform=ax.transAxes,\n1011                         horizontalalignment='left',\n1012                         verticalalignment='center')\n1013 \n1014             w, h = dy / 2, dy / 2\n1015             x, y = 0.05, y - h / 2\n1016 \n1017             p = Rectangle(xy=(x, y), width=w, height=h, edgecolor='black',\n1018                           facecolor=axcolor, transform=ax.transAxes)\n1019 \n1020             l1 = Line2D([x, x + w], [y + h, y], **lineparams)\n1021             l2 = Line2D([x, x + w], [y, y + h], **lineparams)\n1022 \n1023             l1.set_visible(active)\n1024             l2.set_visible(active)\n1025             self.labels.append(t)\n1026             self.rectangles.append(p)\n1027             self.lines.append((l1, l2))\n1028             ax.add_patch(p)\n1029             ax.add_line(l1)\n1030             ax.add_line(l2)\n1031 \n1032         self.connect_event('button_press_event', self._clicked)\n1033 \n1034         self._observers = cbook.CallbackRegistry()\n1035 \n1036     def _clicked(self, event):\n1037         if self.ignore(event) or event.button != 1 or event.inaxes != self.ax:\n1038             return\n1039         for i, (p, t) in enumerate(zip(self.rectangles, self.labels)):\n1040             if (t.get_window_extent().contains(event.x, event.y) or\n1041                     p.get_window_extent().contains(event.x, event.y)):\n1042                 self.set_active(i)\n1043                 break\n1044 \n1045     def set_active(self, index):\n1046         \"\"\"\n1047         Toggle (activate or deactivate) a check button by index.\n1048 \n1049         Callbacks will be triggered if :attr:`eventson` is True.\n1050 \n1051         Parameters\n1052         ----------\n1053         index : int\n1054             Index of the check button to toggle.\n1055 \n1056         Raises\n1057         ------\n1058         ValueError\n1059             If *index* is invalid.\n1060         \"\"\"\n1061         if index not in range(len(self.labels)):\n1062             raise ValueError(f'Invalid CheckButton index: {index}')\n1063 \n1064         l1, l2 = self.lines[index]\n1065         l1.set_visible(not l1.get_visible())\n1066         l2.set_visible(not l2.get_visible())\n1067 \n1068         if self.drawon:\n1069             self.ax.figure.canvas.draw()\n1070 \n1071         if self.eventson:\n1072             self._observers.process('clicked', self.labels[index].get_text())\n1073 \n1074     def get_status(self):\n1075         \"\"\"\n1076         Return a tuple of the status (True/False) of all of the check buttons.\n1077         \"\"\"\n1078         return [l1.get_visible() for (l1, l2) in self.lines]\n1079 \n1080     def on_clicked(self, func):\n1081         \"\"\"\n1082         Connect the callback function *func* to button click events.\n1083 \n1084         Returns a connection id, which can be used to disconnect the callback.\n1085         \"\"\"\n1086         return self._observers.connect('clicked', lambda text: func(text))\n1087 \n1088     def disconnect(self, cid):\n1089         \"\"\"Remove the observer with connection id *cid*.\"\"\"\n1090         self._observers.disconnect(cid)\n1091 \n1092 \n1093 class TextBox(AxesWidget):\n1094     \"\"\"\n1095     A GUI neutral text input box.\n1096 \n1097     For the text box to remain responsive you must keep a reference to it.\n1098 \n1099     Call `.on_text_change` to be updated whenever the text changes.\n1100 \n1101     Call `.on_submit` to be updated whenever the user hits enter or\n1102     leaves the text entry field.\n1103 \n1104     Attributes\n1105     ----------\n1106     ax : `~matplotlib.axes.Axes`\n1107         The parent axes for the widget.\n1108     label : `.Text`\n1109 \n1110     color : color\n1111         The color of the text box when not hovering.\n1112     hovercolor : color\n1113         The color of the text box when hovering.\n1114     \"\"\"\n1115 \n1116     cnt = _api.deprecated(\"3.4\")(property(  # Not real, but close enough.\n1117         lambda self: sum(len(d) for d in self._observers.callbacks.values())))\n1118     change_observers = _api.deprecated(\"3.4\")(property(\n1119         lambda self: self._observers.callbacks['change']))\n1120     submit_observers = _api.deprecated(\"3.4\")(property(\n1121         lambda self: self._observers.callbacks['submit']))\n1122     DIST_FROM_LEFT = _api.deprecate_privatize_attribute(\"3.5\")\n1123 \n1124     def __init__(self, ax, label, initial='',\n1125                  color='.95', hovercolor='1', label_pad=.01,\n1126                  textalignment=\"left\"):\n1127         \"\"\"\n1128         Parameters\n1129         ----------\n1130         ax : `~matplotlib.axes.Axes`\n1131             The `~.axes.Axes` instance the button will be placed into.\n1132         label : str\n1133             Label for this text box.\n1134         initial : str\n1135             Initial value in the text box.\n1136         color : color\n1137             The color of the box.\n1138         hovercolor : color\n1139             The color of the box when the mouse is over it.\n1140         label_pad : float\n1141             The distance between the label and the right side of the textbox.\n1142         textalignment : {'left', 'center', 'right'}\n1143             The horizontal location of the text.\n1144         \"\"\"\n1145         super().__init__(ax)\n1146 \n1147         self._DIST_FROM_LEFT = .05\n1148 \n1149         self._text_position = _api.check_getitem(\n1150             {\"left\": 0.05, \"center\": 0.5, \"right\": 0.95},\n1151             textalignment=textalignment)\n1152 \n1153         self.label = ax.text(\n1154             -label_pad, 0.5, label, transform=ax.transAxes,\n1155             verticalalignment='center', horizontalalignment='right')\n1156 \n1157         # TextBox's text object should not parse mathtext at all.\n1158         self.text_disp = self.ax.text(\n1159             self._text_position, 0.5, initial, transform=self.ax.transAxes,\n1160             verticalalignment='center', horizontalalignment=textalignment,\n1161             parse_math=False)\n1162 \n1163         self._observers = cbook.CallbackRegistry()\n1164 \n1165         ax.set(\n1166             xlim=(0, 1), ylim=(0, 1),  # s.t. cursor appears from first click.\n1167             navigate=False, facecolor=color,\n1168             xticks=[], yticks=[])\n1169 \n1170         self.cursor_index = 0\n1171 \n1172         self.cursor = ax.vlines(0, 0, 0, visible=False, color=\"k\", lw=1,\n1173                                 transform=mpl.transforms.IdentityTransform())\n1174 \n1175         self.connect_event('button_press_event', self._click)\n1176         self.connect_event('button_release_event', self._release)\n1177         self.connect_event('motion_notify_event', self._motion)\n1178         self.connect_event('key_press_event', self._keypress)\n1179         self.connect_event('resize_event', self._resize)\n1180 \n1181         self.color = color\n1182         self.hovercolor = hovercolor\n1183 \n1184         self.capturekeystrokes = False\n1185 \n1186     @property\n1187     def text(self):\n1188         return self.text_disp.get_text()\n1189 \n1190     def _rendercursor(self):\n1191         # this is a hack to figure out where the cursor should go.\n1192         # we draw the text up to where the cursor should go, measure\n1193         # and save its dimensions, draw the real text, then put the cursor\n1194         # at the saved dimensions\n1195 \n1196         # This causes a single extra draw if the figure has never been rendered\n1197         # yet, which should be fine as we're going to repeatedly re-render the\n1198         # figure later anyways.\n1199         if self.ax.figure._cachedRenderer is None:\n1200             self.ax.figure.canvas.draw()\n1201 \n1202         text = self.text_disp.get_text()  # Save value before overwriting it.\n1203         widthtext = text[:self.cursor_index]\n1204 \n1205         bb_text = self.text_disp.get_window_extent()\n1206         self.text_disp.set_text(widthtext or \",\")\n1207         bb_widthtext = self.text_disp.get_window_extent()\n1208 \n1209         if bb_text.y0 == bb_text.y1:  # Restoring the height if no text.\n1210             bb_text.y0 -= (bb_widthtext.y1-bb_widthtext.y0)/2\n1211             bb_text.y1 += (bb_widthtext.y1-bb_widthtext.y0)/2\n1212         elif not widthtext:  # Keep width to 0.\n1213             bb_text.x1 = bb_text.x0\n1214         else:  # Move the cursor using width of bb_widthtext.\n1215             bb_text.x1 = bb_text.x0 + (bb_widthtext.x1 - bb_widthtext.x0)\n1216 \n1217         self.cursor.set(\n1218             segments=[[(bb_text.x1, bb_text.y0), (bb_text.x1, bb_text.y1)]],\n1219             visible=True)\n1220         self.text_disp.set_text(text)\n1221 \n1222         self.ax.figure.canvas.draw()\n1223 \n1224     def _release(self, event):\n1225         if self.ignore(event):\n1226             return\n1227         if event.canvas.mouse_grabber != self.ax:\n1228             return\n1229         event.canvas.release_mouse(self.ax)\n1230 \n1231     def _keypress(self, event):\n1232         if self.ignore(event):\n1233             return\n1234         if self.capturekeystrokes:\n1235             key = event.key\n1236             text = self.text\n1237             if len(key) == 1:\n1238                 text = (text[:self.cursor_index] + key +\n1239                         text[self.cursor_index:])\n1240                 self.cursor_index += 1\n1241             elif key == \"right\":\n1242                 if self.cursor_index != len(text):\n1243                     self.cursor_index += 1\n1244             elif key == \"left\":\n1245                 if self.cursor_index != 0:\n1246                     self.cursor_index -= 1\n1247             elif key == \"home\":\n1248                 self.cursor_index = 0\n1249             elif key == \"end\":\n1250                 self.cursor_index = len(text)\n1251             elif key == \"backspace\":\n1252                 if self.cursor_index != 0:\n1253                     text = (text[:self.cursor_index - 1] +\n1254                             text[self.cursor_index:])\n1255                     self.cursor_index -= 1\n1256             elif key == \"delete\":\n1257                 if self.cursor_index != len(self.text):\n1258                     text = (text[:self.cursor_index] +\n1259                             text[self.cursor_index + 1:])\n1260             self.text_disp.set_text(text)\n1261             self._rendercursor()\n1262             if self.eventson:\n1263                 self._observers.process('change', self.text)\n1264                 if key in [\"enter\", \"return\"]:\n1265                     self._observers.process('submit', self.text)\n1266 \n1267     def set_val(self, val):\n1268         newval = str(val)\n1269         if self.text == newval:\n1270             return\n1271         self.text_disp.set_text(newval)\n1272         self._rendercursor()\n1273         if self.eventson:\n1274             self._observers.process('change', self.text)\n1275             self._observers.process('submit', self.text)\n1276 \n1277     def begin_typing(self, x):\n1278         self.capturekeystrokes = True\n1279         # Disable keypress shortcuts, which may otherwise cause the figure to\n1280         # be saved, closed, etc., until the user stops typing.  The way to\n1281         # achieve this depends on whether toolmanager is in use.\n1282         stack = ExitStack()  # Register cleanup actions when user stops typing.\n1283         self._on_stop_typing = stack.close\n1284         toolmanager = getattr(\n1285             self.ax.figure.canvas.manager, \"toolmanager\", None)\n1286         if toolmanager is not None:\n1287             # If using toolmanager, lock keypresses, and plan to release the\n1288             # lock when typing stops.\n1289             toolmanager.keypresslock(self)\n1290             stack.push(toolmanager.keypresslock.release, self)\n1291         else:\n1292             # If not using toolmanager, disable all keypress-related rcParams.\n1293             # Avoid spurious warnings if keymaps are getting deprecated.\n1294             with _api.suppress_matplotlib_deprecation_warning():\n1295                 stack.enter_context(mpl.rc_context(\n1296                     {k: [] for k in mpl.rcParams if k.startswith(\"keymap.\")}))\n1297 \n1298     def stop_typing(self):\n1299         if self.capturekeystrokes:\n1300             self._on_stop_typing()\n1301             self._on_stop_typing = None\n1302             notifysubmit = True\n1303         else:\n1304             notifysubmit = False\n1305         self.capturekeystrokes = False\n1306         self.cursor.set_visible(False)\n1307         self.ax.figure.canvas.draw()\n1308         if notifysubmit and self.eventson:\n1309             # Because process() might throw an error in the user's code, only\n1310             # call it once we've already done our cleanup.\n1311             self._observers.process('submit', self.text)\n1312 \n1313     def position_cursor(self, x):\n1314         # now, we have to figure out where the cursor goes.\n1315         # approximate it based on assuming all characters the same length\n1316         if len(self.text) == 0:\n1317             self.cursor_index = 0\n1318         else:\n1319             bb = self.text_disp.get_window_extent()\n1320             ratio = np.clip((x - bb.x0) / bb.width, 0, 1)\n1321             self.cursor_index = int(len(self.text) * ratio)\n1322         self._rendercursor()\n1323 \n1324     def _click(self, event):\n1325         if self.ignore(event):\n1326             return\n1327         if event.inaxes != self.ax:\n1328             self.stop_typing()\n1329             return\n1330         if not self.eventson:\n1331             return\n1332         if event.canvas.mouse_grabber != self.ax:\n1333             event.canvas.grab_mouse(self.ax)\n1334         if not self.capturekeystrokes:\n1335             self.begin_typing(event.x)\n1336         self.position_cursor(event.x)\n1337 \n1338     def _resize(self, event):\n1339         self.stop_typing()\n1340 \n1341     def _motion(self, event):\n1342         if self.ignore(event):\n1343             return\n1344         c = self.hovercolor if event.inaxes == self.ax else self.color\n1345         if not colors.same_color(c, self.ax.get_facecolor()):\n1346             self.ax.set_facecolor(c)\n1347             if self.drawon:\n1348                 self.ax.figure.canvas.draw()\n1349 \n1350     def on_text_change(self, func):\n1351         \"\"\"\n1352         When the text changes, call this *func* with event.\n1353 \n1354         A connection id is returned which can be used to disconnect.\n1355         \"\"\"\n1356         return self._observers.connect('change', lambda text: func(text))\n1357 \n1358     def on_submit(self, func):\n1359         \"\"\"\n1360         When the user hits enter or leaves the submission box, call this\n1361         *func* with event.\n1362 \n1363         A connection id is returned which can be used to disconnect.\n1364         \"\"\"\n1365         return self._observers.connect('submit', lambda text: func(text))\n1366 \n1367     def disconnect(self, cid):\n1368         \"\"\"Remove the observer with connection id *cid*.\"\"\"\n1369         self._observers.disconnect(cid)\n1370 \n1371 \n1372 class RadioButtons(AxesWidget):\n1373     \"\"\"\n1374     A GUI neutral radio button.\n1375 \n1376     For the buttons to remain responsive you must keep a reference to this\n1377     object.\n1378 \n1379     Connect to the RadioButtons with the `.on_clicked` method.\n1380 \n1381     Attributes\n1382     ----------\n1383     ax : `~matplotlib.axes.Axes`\n1384         The parent axes for the widget.\n1385     activecolor : color\n1386         The color of the selected button.\n1387     labels : list of `.Text`\n1388         The button labels.\n1389     circles : list of `~.patches.Circle`\n1390         The buttons.\n1391     value_selected : str\n1392         The label text of the currently selected button.\n1393     \"\"\"\n1394 \n1395     def __init__(self, ax, labels, active=0, activecolor='blue'):\n1396         \"\"\"\n1397         Add radio buttons to an `~.axes.Axes`.\n1398 \n1399         Parameters\n1400         ----------\n1401         ax : `~matplotlib.axes.Axes`\n1402             The axes to add the buttons to.\n1403         labels : list of str\n1404             The button labels.\n1405         active : int\n1406             The index of the initially selected button.\n1407         activecolor : color\n1408             The color of the selected button.\n1409         \"\"\"\n1410         super().__init__(ax)\n1411         self.activecolor = activecolor\n1412         self.value_selected = None\n1413 \n1414         ax.set_xticks([])\n1415         ax.set_yticks([])\n1416         ax.set_navigate(False)\n1417         dy = 1. / (len(labels) + 1)\n1418         ys = np.linspace(1 - dy, dy, len(labels))\n1419         cnt = 0\n1420         axcolor = ax.get_facecolor()\n1421 \n1422         # scale the radius of the circle with the spacing between each one\n1423         circle_radius = dy / 2 - 0.01\n1424         # default to hard-coded value if the radius becomes too large\n1425         circle_radius = min(circle_radius, 0.05)\n1426 \n1427         self.labels = []\n1428         self.circles = []\n1429         for y, label in zip(ys, labels):\n1430             t = ax.text(0.25, y, label, transform=ax.transAxes,\n1431                         horizontalalignment='left',\n1432                         verticalalignment='center')\n1433 \n1434             if cnt == active:\n1435                 self.value_selected = label\n1436                 facecolor = activecolor\n1437             else:\n1438                 facecolor = axcolor\n1439 \n1440             p = Circle(xy=(0.15, y), radius=circle_radius, edgecolor='black',\n1441                        facecolor=facecolor, transform=ax.transAxes)\n1442 \n1443             self.labels.append(t)\n1444             self.circles.append(p)\n1445             ax.add_patch(p)\n1446             cnt += 1\n1447 \n1448         self.connect_event('button_press_event', self._clicked)\n1449 \n1450         self._observers = cbook.CallbackRegistry()\n1451 \n1452     cnt = _api.deprecated(\"3.4\")(property(  # Not real, but close enough.\n1453         lambda self: len(self._observers.callbacks['clicked'])))\n1454     observers = _api.deprecated(\"3.4\")(property(\n1455         lambda self: self._observers.callbacks['clicked']))\n1456 \n1457     def _clicked(self, event):\n1458         if self.ignore(event) or event.button != 1 or event.inaxes != self.ax:\n1459             return\n1460         pclicked = self.ax.transAxes.inverted().transform((event.x, event.y))\n1461         distances = {}\n1462         for i, (p, t) in enumerate(zip(self.circles, self.labels)):\n1463             if (t.get_window_extent().contains(event.x, event.y)\n1464                     or np.linalg.norm(pclicked - p.center) < p.radius):\n1465                 distances[i] = np.linalg.norm(pclicked - p.center)\n1466         if len(distances) > 0:\n1467             closest = min(distances, key=distances.get)\n1468             self.set_active(closest)\n1469 \n1470     def set_active(self, index):\n1471         \"\"\"\n1472         Select button with number *index*.\n1473 \n1474         Callbacks will be triggered if :attr:`eventson` is True.\n1475         \"\"\"\n1476         if index not in range(len(self.labels)):\n1477             raise ValueError(f'Invalid RadioButton index: {index}')\n1478 \n1479         self.value_selected = self.labels[index].get_text()\n1480 \n1481         for i, p in enumerate(self.circles):\n1482             if i == index:\n1483                 color = self.activecolor\n1484             else:\n1485                 color = self.ax.get_facecolor()\n1486             p.set_facecolor(color)\n1487 \n1488         if self.drawon:\n1489             self.ax.figure.canvas.draw()\n1490 \n1491         if self.eventson:\n1492             self._observers.process('clicked', self.labels[index].get_text())\n1493 \n1494     def on_clicked(self, func):\n1495         \"\"\"\n1496         Connect the callback function *func* to button click events.\n1497 \n1498         Returns a connection id, which can be used to disconnect the callback.\n1499         \"\"\"\n1500         return self._observers.connect('clicked', func)\n1501 \n1502     def disconnect(self, cid):\n1503         \"\"\"Remove the observer with connection id *cid*.\"\"\"\n1504         self._observers.disconnect(cid)\n1505 \n1506 \n1507 class SubplotTool(Widget):\n1508     \"\"\"\n1509     A tool to adjust the subplot params of a `matplotlib.figure.Figure`.\n1510     \"\"\"\n1511 \n1512     def __init__(self, targetfig, toolfig):\n1513         \"\"\"\n1514         Parameters\n1515         ----------\n1516         targetfig : `.Figure`\n1517             The figure instance to adjust.\n1518         toolfig : `.Figure`\n1519             The figure instance to embed the subplot tool into.\n1520         \"\"\"\n1521 \n1522         self.figure = toolfig\n1523         self.targetfig = targetfig\n1524         toolfig.subplots_adjust(left=0.2, right=0.9)\n1525         toolfig.suptitle(\"Click on slider to adjust subplot param\")\n1526 \n1527         self._sliders = []\n1528         names = [\"left\", \"bottom\", \"right\", \"top\", \"wspace\", \"hspace\"]\n1529         # The last subplot, removed below, keeps space for the \"Reset\" button.\n1530         for name, ax in zip(names, toolfig.subplots(len(names) + 1)):\n1531             ax.set_navigate(False)\n1532             slider = Slider(ax, name,\n1533                             0, 1, getattr(targetfig.subplotpars, name))\n1534             slider.on_changed(self._on_slider_changed)\n1535             self._sliders.append(slider)\n1536         toolfig.axes[-1].remove()\n1537         (self.sliderleft, self.sliderbottom, self.sliderright, self.slidertop,\n1538          self.sliderwspace, self.sliderhspace) = self._sliders\n1539         for slider in [self.sliderleft, self.sliderbottom,\n1540                        self.sliderwspace, self.sliderhspace]:\n1541             slider.closedmax = False\n1542         for slider in [self.sliderright, self.slidertop]:\n1543             slider.closedmin = False\n1544 \n1545         # constraints\n1546         self.sliderleft.slidermax = self.sliderright\n1547         self.sliderright.slidermin = self.sliderleft\n1548         self.sliderbottom.slidermax = self.slidertop\n1549         self.slidertop.slidermin = self.sliderbottom\n1550 \n1551         bax = toolfig.add_axes([0.8, 0.05, 0.15, 0.075])\n1552         self.buttonreset = Button(bax, 'Reset')\n1553         self.buttonreset.on_clicked(self._on_reset)\n1554 \n1555     def _on_slider_changed(self, _):\n1556         self.targetfig.subplots_adjust(\n1557             **{slider.label.get_text(): slider.val\n1558                for slider in self._sliders})\n1559         if self.drawon:\n1560             self.targetfig.canvas.draw()\n1561 \n1562     def _on_reset(self, event):\n1563         with ExitStack() as stack:\n1564             # Temporarily disable drawing on self and self's sliders, and\n1565             # disconnect slider events (as the subplotparams can be temporarily\n1566             # invalid, depending on the order in which they are restored).\n1567             stack.enter_context(cbook._setattr_cm(self, drawon=False))\n1568             for slider in self._sliders:\n1569                 stack.enter_context(\n1570                     cbook._setattr_cm(slider, drawon=False, eventson=False))\n1571             # Reset the slider to the initial position.\n1572             for slider in self._sliders:\n1573                 slider.reset()\n1574         if self.drawon:\n1575             event.canvas.draw()  # Redraw the subplottool canvas.\n1576         self._on_slider_changed(None)  # Apply changes to the target window.\n1577 \n1578 \n1579 class Cursor(AxesWidget):\n1580     \"\"\"\n1581     A crosshair cursor that spans the axes and moves with mouse cursor.\n1582 \n1583     For the cursor to remain responsive you must keep a reference to it.\n1584 \n1585     Parameters\n1586     ----------\n1587     ax : `matplotlib.axes.Axes`\n1588         The `~.axes.Axes` to attach the cursor to.\n1589     horizOn : bool, default: True\n1590         Whether to draw the horizontal line.\n1591     vertOn : bool, default: True\n1592         Whether to draw the vertical line.\n1593     useblit : bool, default: False\n1594         Use blitting for faster drawing if supported by the backend.\n1595 \n1596     Other Parameters\n1597     ----------------\n1598     **lineprops\n1599         `.Line2D` properties that control the appearance of the lines.\n1600         See also `~.Axes.axhline`.\n1601 \n1602     Examples\n1603     --------\n1604     See :doc:`/gallery/widgets/cursor`.\n1605     \"\"\"\n1606 \n1607     def __init__(self, ax, horizOn=True, vertOn=True, useblit=False,\n1608                  **lineprops):\n1609         super().__init__(ax)\n1610 \n1611         self.connect_event('motion_notify_event', self.onmove)\n1612         self.connect_event('draw_event', self.clear)\n1613 \n1614         self.visible = True\n1615         self.horizOn = horizOn\n1616         self.vertOn = vertOn\n1617         self.useblit = useblit and self.canvas.supports_blit\n1618 \n1619         if self.useblit:\n1620             lineprops['animated'] = True\n1621         self.lineh = ax.axhline(ax.get_ybound()[0], visible=False, **lineprops)\n1622         self.linev = ax.axvline(ax.get_xbound()[0], visible=False, **lineprops)\n1623 \n1624         self.background = None\n1625         self.needclear = False\n1626 \n1627     def clear(self, event):\n1628         \"\"\"Internal event handler to clear the cursor.\"\"\"\n1629         if self.ignore(event):\n1630             return\n1631         if self.useblit:\n1632             self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n1633         self.linev.set_visible(False)\n1634         self.lineh.set_visible(False)\n1635 \n1636     def onmove(self, event):\n1637         \"\"\"Internal event handler to draw the cursor when the mouse moves.\"\"\"\n1638         if self.ignore(event):\n1639             return\n1640         if not self.canvas.widgetlock.available(self):\n1641             return\n1642         if event.inaxes != self.ax:\n1643             self.linev.set_visible(False)\n1644             self.lineh.set_visible(False)\n1645 \n1646             if self.needclear:\n1647                 self.canvas.draw()\n1648                 self.needclear = False\n1649             return\n1650         self.needclear = True\n1651         if not self.visible:\n1652             return\n1653         self.linev.set_xdata((event.xdata, event.xdata))\n1654 \n1655         self.lineh.set_ydata((event.ydata, event.ydata))\n1656         self.linev.set_visible(self.visible and self.vertOn)\n1657         self.lineh.set_visible(self.visible and self.horizOn)\n1658 \n1659         self._update()\n1660 \n1661     def _update(self):\n1662         if self.useblit:\n1663             if self.background is not None:\n1664                 self.canvas.restore_region(self.background)\n1665             self.ax.draw_artist(self.linev)\n1666             self.ax.draw_artist(self.lineh)\n1667             self.canvas.blit(self.ax.bbox)\n1668         else:\n1669             self.canvas.draw_idle()\n1670         return False\n1671 \n1672 \n1673 class MultiCursor(Widget):\n1674     \"\"\"\n1675     Provide a vertical (default) and/or horizontal line cursor shared between\n1676     multiple axes.\n1677 \n1678     For the cursor to remain responsive you must keep a reference to it.\n1679 \n1680     Example usage::\n1681 \n1682         from matplotlib.widgets import MultiCursor\n1683         import matplotlib.pyplot as plt\n1684         import numpy as np\n1685 \n1686         fig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)\n1687         t = np.arange(0.0, 2.0, 0.01)\n1688         ax1.plot(t, np.sin(2*np.pi*t))\n1689         ax2.plot(t, np.sin(4*np.pi*t))\n1690 \n1691         multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1,\n1692                             horizOn=False, vertOn=True)\n1693         plt.show()\n1694 \n1695     \"\"\"\n1696     def __init__(self, canvas, axes, useblit=True, horizOn=False, vertOn=True,\n1697                  **lineprops):\n1698 \n1699         self.canvas = canvas\n1700         self.axes = axes\n1701         self.horizOn = horizOn\n1702         self.vertOn = vertOn\n1703 \n1704         xmin, xmax = axes[-1].get_xlim()\n1705         ymin, ymax = axes[-1].get_ylim()\n1706         xmid = 0.5 * (xmin + xmax)\n1707         ymid = 0.5 * (ymin + ymax)\n1708 \n1709         self.visible = True\n1710         self.useblit = useblit and self.canvas.supports_blit\n1711         self.background = None\n1712         self.needclear = False\n1713 \n1714         if self.useblit:\n1715             lineprops['animated'] = True\n1716 \n1717         if vertOn:\n1718             self.vlines = [ax.axvline(xmid, visible=False, **lineprops)\n1719                            for ax in axes]\n1720         else:\n1721             self.vlines = []\n1722 \n1723         if horizOn:\n1724             self.hlines = [ax.axhline(ymid, visible=False, **lineprops)\n1725                            for ax in axes]\n1726         else:\n1727             self.hlines = []\n1728 \n1729         self.connect()\n1730 \n1731     def connect(self):\n1732         \"\"\"Connect events.\"\"\"\n1733         self._cidmotion = self.canvas.mpl_connect('motion_notify_event',\n1734                                                   self.onmove)\n1735         self._ciddraw = self.canvas.mpl_connect('draw_event', self.clear)\n1736 \n1737     def disconnect(self):\n1738         \"\"\"Disconnect events.\"\"\"\n1739         self.canvas.mpl_disconnect(self._cidmotion)\n1740         self.canvas.mpl_disconnect(self._ciddraw)\n1741 \n1742     def clear(self, event):\n1743         \"\"\"Clear the cursor.\"\"\"\n1744         if self.ignore(event):\n1745             return\n1746         if self.useblit:\n1747             self.background = (\n1748                 self.canvas.copy_from_bbox(self.canvas.figure.bbox))\n1749         for line in self.vlines + self.hlines:\n1750             line.set_visible(False)\n1751 \n1752     def onmove(self, event):\n1753         if self.ignore(event):\n1754             return\n1755         if event.inaxes not in self.axes:\n1756             return\n1757         if not self.canvas.widgetlock.available(self):\n1758             return\n1759         self.needclear = True\n1760         if not self.visible:\n1761             return\n1762         if self.vertOn:\n1763             for line in self.vlines:\n1764                 line.set_xdata((event.xdata, event.xdata))\n1765                 line.set_visible(self.visible)\n1766         if self.horizOn:\n1767             for line in self.hlines:\n1768                 line.set_ydata((event.ydata, event.ydata))\n1769                 line.set_visible(self.visible)\n1770         self._update()\n1771 \n1772     def _update(self):\n1773         if self.useblit:\n1774             if self.background is not None:\n1775                 self.canvas.restore_region(self.background)\n1776             if self.vertOn:\n1777                 for ax, line in zip(self.axes, self.vlines):\n1778                     ax.draw_artist(line)\n1779             if self.horizOn:\n1780                 for ax, line in zip(self.axes, self.hlines):\n1781                     ax.draw_artist(line)\n1782             self.canvas.blit()\n1783         else:\n1784             self.canvas.draw_idle()\n1785 \n1786 \n1787 class _SelectorWidget(AxesWidget):\n1788 \n1789     def __init__(self, ax, onselect, useblit=False, button=None,\n1790                  state_modifier_keys=None):\n1791         super().__init__(ax)\n1792 \n1793         self.visible = True\n1794         self.onselect = onselect\n1795         self.useblit = useblit and self.canvas.supports_blit\n1796         self.connect_default_events()\n1797 \n1798         self.state_modifier_keys = dict(move=' ', clear='escape',\n1799                                         square='shift', center='control')\n1800         self.state_modifier_keys.update(state_modifier_keys or {})\n1801 \n1802         self.background = None\n1803         self.artists = []\n1804 \n1805         if isinstance(button, Integral):\n1806             self.validButtons = [button]\n1807         else:\n1808             self.validButtons = button\n1809 \n1810         # Set to True when a selection is completed, otherwise is False\n1811         self._selection_completed = False\n1812 \n1813         # will save the data (position at mouseclick)\n1814         self._eventpress = None\n1815         # will save the data (pos. at mouserelease)\n1816         self._eventrelease = None\n1817         self._prev_event = None\n1818         self._state = set()\n1819 \n1820     eventpress = _api.deprecate_privatize_attribute(\"3.5\")\n1821     eventrelease = _api.deprecate_privatize_attribute(\"3.5\")\n1822     state = _api.deprecate_privatize_attribute(\"3.5\")\n1823 \n1824     def set_active(self, active):\n1825         super().set_active(active)\n1826         if active:\n1827             self.update_background(None)\n1828 \n1829     def update_background(self, event):\n1830         \"\"\"Force an update of the background.\"\"\"\n1831         # If you add a call to `ignore` here, you'll want to check edge case:\n1832         # `release` can call a draw event even when `ignore` is True.\n1833         if not self.useblit:\n1834             return\n1835         # Make sure that widget artists don't get accidentally included in the\n1836         # background, by re-rendering the background if needed (and then\n1837         # re-re-rendering the canvas with the visible widget artists).\n1838         needs_redraw = any(artist.get_visible() for artist in self.artists)\n1839         with ExitStack() as stack:\n1840             if needs_redraw:\n1841                 for artist in self.artists:\n1842                     stack.enter_context(artist._cm_set(visible=False))\n1843                 self.canvas.draw()\n1844             self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n1845         if needs_redraw:\n1846             for artist in self.artists:\n1847                 self.ax.draw_artist(artist)\n1848 \n1849     def connect_default_events(self):\n1850         \"\"\"Connect the major canvas events to methods.\"\"\"\n1851         self.connect_event('motion_notify_event', self.onmove)\n1852         self.connect_event('button_press_event', self.press)\n1853         self.connect_event('button_release_event', self.release)\n1854         self.connect_event('draw_event', self.update_background)\n1855         self.connect_event('key_press_event', self.on_key_press)\n1856         self.connect_event('key_release_event', self.on_key_release)\n1857         self.connect_event('scroll_event', self.on_scroll)\n1858 \n1859     def ignore(self, event):\n1860         # docstring inherited\n1861         if not self.active or not self.ax.get_visible():\n1862             return True\n1863         # If canvas was locked\n1864         if not self.canvas.widgetlock.available(self):\n1865             return True\n1866         if not hasattr(event, 'button'):\n1867             event.button = None\n1868         # Only do rectangle selection if event was triggered\n1869         # with a desired button\n1870         if (self.validButtons is not None\n1871                 and event.button not in self.validButtons):\n1872             return True\n1873         # If no button was pressed yet ignore the event if it was out\n1874         # of the axes\n1875         if self._eventpress is None:\n1876             return event.inaxes != self.ax\n1877         # If a button was pressed, check if the release-button is the same.\n1878         if event.button == self._eventpress.button:\n1879             return False\n1880         # If a button was pressed, check if the release-button is the same.\n1881         return (event.inaxes != self.ax or\n1882                 event.button != self._eventpress.button)\n1883 \n1884     def update(self):\n1885         \"\"\"Draw using blit() or draw_idle(), depending on ``self.useblit``.\"\"\"\n1886         if not self.ax.get_visible() or self.ax.figure._cachedRenderer is None:\n1887             return False\n1888         if self.useblit:\n1889             if self.background is not None:\n1890                 self.canvas.restore_region(self.background)\n1891             else:\n1892                 self.update_background(None)\n1893             for artist in self.artists:\n1894                 self.ax.draw_artist(artist)\n1895             self.canvas.blit(self.ax.bbox)\n1896         else:\n1897             self.canvas.draw_idle()\n1898         return False\n1899 \n1900     def _get_data(self, event):\n1901         \"\"\"Get the xdata and ydata for event, with limits.\"\"\"\n1902         if event.xdata is None:\n1903             return None, None\n1904         xdata = np.clip(event.xdata, *self.ax.get_xbound())\n1905         ydata = np.clip(event.ydata, *self.ax.get_ybound())\n1906         return xdata, ydata\n1907 \n1908     def _clean_event(self, event):\n1909         \"\"\"\n1910         Preprocess an event:\n1911 \n1912         - Replace *event* by the previous event if *event* has no ``xdata``.\n1913         - Clip ``xdata`` and ``ydata`` to the axes limits.\n1914         - Update the previous event.\n1915         \"\"\"\n1916         if event.xdata is None:\n1917             event = self._prev_event\n1918         else:\n1919             event = copy.copy(event)\n1920         event.xdata, event.ydata = self._get_data(event)\n1921         self._prev_event = event\n1922         return event\n1923 \n1924     def press(self, event):\n1925         \"\"\"Button press handler and validator.\"\"\"\n1926         if not self.ignore(event):\n1927             event = self._clean_event(event)\n1928             self._eventpress = event\n1929             self._prev_event = event\n1930             key = event.key or ''\n1931             key = key.replace('ctrl', 'control')\n1932             # move state is locked in on a button press\n1933             if key == self.state_modifier_keys['move']:\n1934                 self._state.add('move')\n1935             self._press(event)\n1936             return True\n1937         return False\n1938 \n1939     def _press(self, event):\n1940         \"\"\"Button press event handler.\"\"\"\n1941 \n1942     def release(self, event):\n1943         \"\"\"Button release event handler and validator.\"\"\"\n1944         if not self.ignore(event) and self._eventpress:\n1945             event = self._clean_event(event)\n1946             self._eventrelease = event\n1947             self._release(event)\n1948             self._eventpress = None\n1949             self._eventrelease = None\n1950             self._state.discard('move')\n1951             return True\n1952         return False\n1953 \n1954     def _release(self, event):\n1955         \"\"\"Button release event handler.\"\"\"\n1956 \n1957     def onmove(self, event):\n1958         \"\"\"Cursor move event handler and validator.\"\"\"\n1959         if not self.ignore(event) and self._eventpress:\n1960             event = self._clean_event(event)\n1961             self._onmove(event)\n1962             return True\n1963         return False\n1964 \n1965     def _onmove(self, event):\n1966         \"\"\"Cursor move event handler.\"\"\"\n1967 \n1968     def on_scroll(self, event):\n1969         \"\"\"Mouse scroll event handler and validator.\"\"\"\n1970         if not self.ignore(event):\n1971             self._on_scroll(event)\n1972 \n1973     def _on_scroll(self, event):\n1974         \"\"\"Mouse scroll event handler.\"\"\"\n1975 \n1976     def on_key_press(self, event):\n1977         \"\"\"Key press event handler and validator for all selection widgets.\"\"\"\n1978         if self.active:\n1979             key = event.key or ''\n1980             key = key.replace('ctrl', 'control')\n1981             if key == self.state_modifier_keys['clear']:\n1982                 for artist in self.artists:\n1983                     artist.set_visible(False)\n1984                 self.update()\n1985                 return\n1986             for (state, modifier) in self.state_modifier_keys.items():\n1987                 if modifier in key:\n1988                     self._state.add(state)\n1989             self._on_key_press(event)\n1990 \n1991     def _on_key_press(self, event):\n1992         \"\"\"Key press event handler - for widget-specific key press actions.\"\"\"\n1993 \n1994     def on_key_release(self, event):\n1995         \"\"\"Key release event handler and validator.\"\"\"\n1996         if self.active:\n1997             key = event.key or ''\n1998             for (state, modifier) in self.state_modifier_keys.items():\n1999                 if modifier in key:\n2000                     self._state.discard(state)\n2001             self._on_key_release(event)\n2002 \n2003     def _on_key_release(self, event):\n2004         \"\"\"Key release event handler.\"\"\"\n2005 \n2006     def set_visible(self, visible):\n2007         \"\"\"Set the visibility of our artists.\"\"\"\n2008         self.visible = visible\n2009         for artist in self.artists:\n2010             artist.set_visible(visible)\n2011 \n2012 \n2013 class SpanSelector(_SelectorWidget):\n2014     \"\"\"\n2015     Visually select a min/max range on a single axis and call a function with\n2016     those values.\n2017 \n2018     To guarantee that the selector remains responsive, keep a reference to it.\n2019 \n2020     In order to turn off the SpanSelector, set ``span_selector.active`` to\n2021     False.  To turn it back on, set it to True.\n2022 \n2023     Press and release events triggered at the same coordinates outside the\n2024     selection will clear the selector, except when\n2025     ``ignore_event_outside=True``.\n2026 \n2027     Parameters\n2028     ----------\n2029     ax : `matplotlib.axes.Axes`\n2030 \n2031     onselect : callable\n2032         A callback function that is called after a release event and the\n2033         selection is created, changed or removed.\n2034         It must have the signature::\n2035 \n2036             def on_select(min: float, max: float) -> Any\n2037 \n2038     direction : {\"horizontal\", \"vertical\"}\n2039         The direction along which to draw the span selector.\n2040 \n2041     minspan : float, default: 0\n2042         If selection is less than or equal to *minspan*, the selection is\n2043         removed (when already existing) or cancelled.\n2044 \n2045     useblit : bool, default: False\n2046         If True, use the backend-dependent blitting features for faster\n2047         canvas updates.\n2048 \n2049     props : dict, optional\n2050         Dictionary of `matplotlib.patches.Patch` properties.\n2051         Default:\n2052 \n2053             ``dict(facecolor='red', alpha=0.5)``\n2054 \n2055     onmove_callback : func(min, max), min/max are floats, default: None\n2056         Called on mouse move while the span is being selected.\n2057 \n2058     span_stays : bool, default: False\n2059         If True, the span stays visible after the mouse is released.\n2060         Deprecated, use *interactive* instead.\n2061 \n2062     interactive : bool, default: False\n2063         Whether to draw a set of handles that allow interaction with the\n2064         widget after it is drawn.\n2065 \n2066     button : `.MouseButton` or list of `.MouseButton`, default: all buttons\n2067         The mouse buttons which activate the span selector.\n2068 \n2069     handle_props : dict, default: None\n2070         Properties of the handle lines at the edges of the span. Only used\n2071         when *interactive* is True. See `matplotlib.lines.Line2D` for valid\n2072         properties.\n2073 \n2074     grab_range : float, default: 10\n2075         Distance in pixels within which the interactive tool handles can be\n2076         activated.\n2077 \n2078     drag_from_anywhere : bool, default: False\n2079         If `True`, the widget can be moved by clicking anywhere within\n2080         its bounds.\n2081 \n2082     ignore_event_outside : bool, default: False\n2083         If `True`, the event triggered outside the span selector will be\n2084         ignored.\n2085 \n2086     Examples\n2087     --------\n2088     >>> import matplotlib.pyplot as plt\n2089     >>> import matplotlib.widgets as mwidgets\n2090     >>> fig, ax = plt.subplots()\n2091     >>> ax.plot([1, 2, 3], [10, 50, 100])\n2092     >>> def onselect(vmin, vmax):\n2093     ...     print(vmin, vmax)\n2094     >>> span = mwidgets.SpanSelector(ax, onselect, 'horizontal',\n2095     ...                              props=dict(facecolor='blue', alpha=0.5))\n2096     >>> fig.show()\n2097 \n2098     See also: :doc:`/gallery/widgets/span_selector`\n2099     \"\"\"\n2100 \n2101     @_api.rename_parameter(\"3.5\", \"rectprops\", \"props\")\n2102     @_api.rename_parameter(\"3.5\", \"span_stays\", \"interactive\")\n2103     def __init__(self, ax, onselect, direction, minspan=0, useblit=False,\n2104                  props=None, onmove_callback=None, interactive=False,\n2105                  button=None, handle_props=None, grab_range=10,\n2106                  drag_from_anywhere=False, ignore_event_outside=False):\n2107 \n2108         super().__init__(ax, onselect, useblit=useblit, button=button)\n2109 \n2110         if props is None:\n2111             props = dict(facecolor='red', alpha=0.5)\n2112 \n2113         props['animated'] = self.useblit\n2114 \n2115         self.direction = direction\n2116 \n2117         self._rect = None\n2118         self.visible = True\n2119         self._extents_on_press = None\n2120 \n2121         # self._pressv is deprecated and we don't use it internally anymore\n2122         # but we maintain it until it is removed\n2123         self._pressv = None\n2124 \n2125         self._props = props\n2126         self.onmove_callback = onmove_callback\n2127         self.minspan = minspan\n2128 \n2129         self.grab_range = grab_range\n2130         self._interactive = interactive\n2131         self.drag_from_anywhere = drag_from_anywhere\n2132         self.ignore_event_outside = ignore_event_outside\n2133 \n2134         # Reset canvas so that `new_axes` connects events.\n2135         self.canvas = None\n2136         self.artists = []\n2137         self.new_axes(ax)\n2138 \n2139         # Setup handles\n2140         handle_props = {\n2141             'color': props.get('facecolor', 'r'),\n2142             **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}\n2143 \n2144         if self._interactive:\n2145             self._edge_order = ['min', 'max']\n2146             self._setup_edge_handle(handle_props)\n2147 \n2148         self._active_handle = None\n2149 \n2150         # prev attribute is deprecated but we still need to maintain it\n2151         self._prev = (0, 0)\n2152 \n2153     rect = _api.deprecate_privatize_attribute(\"3.5\")\n2154 \n2155     rectprops = _api.deprecated(\"3.5\")(\n2156         property(lambda self: self._props)\n2157         )\n2158 \n2159     active_handle = _api.deprecate_privatize_attribute(\"3.5\")\n2160 \n2161     pressv = _api.deprecate_privatize_attribute(\"3.5\")\n2162 \n2163     span_stays = _api.deprecated(\"3.5\")(\n2164         property(lambda self: self._interactive)\n2165         )\n2166 \n2167     prev = _api.deprecate_privatize_attribute(\"3.5\")\n2168 \n2169     def new_axes(self, ax):\n2170         \"\"\"Set SpanSelector to operate on a new Axes.\"\"\"\n2171         self.ax = ax\n2172         if self.canvas is not ax.figure.canvas:\n2173             if self.canvas is not None:\n2174                 self.disconnect_events()\n2175 \n2176             self.canvas = ax.figure.canvas\n2177             self.connect_default_events()\n2178 \n2179         # Reset\n2180         self._selection_completed = False\n2181 \n2182         if self.direction == 'horizontal':\n2183             trans = ax.get_xaxis_transform()\n2184             w, h = 0, 1\n2185         else:\n2186             trans = ax.get_yaxis_transform()\n2187             w, h = 1, 0\n2188         self._rect = Rectangle((0, 0), w, h,\n2189                                transform=trans,\n2190                                visible=False,\n2191                                **self._props)\n2192 \n2193         self.ax.add_patch(self._rect)\n2194         if len(self.artists) > 0:\n2195             self.artists[0] = self._rect\n2196         else:\n2197             self.artists.append(self._rect)\n2198 \n2199     def _setup_edge_handle(self, props):\n2200         # Define initial position using the axis bounds to keep the same bounds\n2201         if self.direction == 'horizontal':\n2202             positions = self.ax.get_xbound()\n2203         else:\n2204             positions = self.ax.get_ybound()\n2205         self._edge_handles = ToolLineHandles(self.ax, positions,\n2206                                              direction=self.direction,\n2207                                              line_props=props,\n2208                                              useblit=self.useblit)\n2209         self.artists.extend([line for line in self._edge_handles.artists])\n2210 \n2211     def _set_cursor(self, enabled):\n2212         \"\"\"Update the canvas cursor based on direction of the selector.\"\"\"\n2213         if enabled:\n2214             cursor = (backend_tools.Cursors.RESIZE_HORIZONTAL\n2215                       if self.direction == 'horizontal' else\n2216                       backend_tools.Cursors.RESIZE_VERTICAL)\n2217         else:\n2218             cursor = backend_tools.Cursors.POINTER\n2219 \n2220         self.ax.figure.canvas.set_cursor(cursor)\n2221 \n2222     def connect_default_events(self):\n2223         # docstring inherited\n2224         super().connect_default_events()\n2225         if getattr(self, '_interactive', False):\n2226             self.connect_event('motion_notify_event', self._hover)\n2227 \n2228     def _press(self, event):\n2229         \"\"\"Button press event handler.\"\"\"\n2230         self._set_cursor(True)\n2231         if self._interactive and self._rect.get_visible():\n2232             self._set_active_handle(event)\n2233         else:\n2234             self._active_handle = None\n2235 \n2236         if self._active_handle is None or not self._interactive:\n2237             # Clear previous rectangle before drawing new rectangle.\n2238             self.update()\n2239 \n2240         v = event.xdata if self.direction == 'horizontal' else event.ydata\n2241         # self._pressv and self._prev are deprecated but we still need to\n2242         # maintain them\n2243         self._pressv = v\n2244         self._prev = self._get_data(event)\n2245 \n2246         if self._active_handle is None and not self.ignore_event_outside:\n2247             # when the press event outside the span, we initially set the\n2248             # visibility to False and extents to (v, v)\n2249             # update will be called when setting the extents\n2250             self.visible = False\n2251             self.extents = v, v\n2252             # We need to set the visibility back, so the span selector will be\n2253             # drawn when necessary (span width > 0)\n2254             self.visible = True\n2255         else:\n2256             self.set_visible(True)\n2257 \n2258         return False\n2259 \n2260     @property\n2261     def direction(self):\n2262         \"\"\"Direction of the span selector: 'vertical' or 'horizontal'.\"\"\"\n2263         return self._direction\n2264 \n2265     @direction.setter\n2266     def direction(self, direction):\n2267         \"\"\"Set the direction of the span selector.\"\"\"\n2268         _api.check_in_list(['horizontal', 'vertical'], direction=direction)\n2269         if hasattr(self, '_direction') and direction != self._direction:\n2270             # remove previous artists\n2271             self._rect.remove()\n2272             if self._interactive:\n2273                 self._edge_handles.remove()\n2274                 for artist in self._edge_handles.artists:\n2275                     self.artists.remove(artist)\n2276             self._direction = direction\n2277             self.new_axes(self.ax)\n2278             if self._interactive:\n2279                 self._setup_edge_handle(self._edge_handles._line_props)\n2280         else:\n2281             self._direction = direction\n2282 \n2283     def _release(self, event):\n2284         \"\"\"Button release event handler.\"\"\"\n2285         self._set_cursor(False)\n2286         # self._pressv is deprecated but we still need to maintain it\n2287         self._pressv = None\n2288 \n2289         if not self._interactive:\n2290             self._rect.set_visible(False)\n2291 \n2292         if (self._active_handle is None and self._selection_completed and\n2293                 self.ignore_event_outside):\n2294             return\n2295 \n2296         vmin, vmax = self.extents\n2297         span = vmax - vmin\n2298 \n2299         if span <= self.minspan:\n2300             # Remove span and set self._selection_completed = False\n2301             self.set_visible(False)\n2302             if self._selection_completed:\n2303                 # Call onselect, only when the span is already existing\n2304                 self.onselect(vmin, vmax)\n2305             self._selection_completed = False\n2306         else:\n2307             self.onselect(vmin, vmax)\n2308             self._selection_completed = True\n2309 \n2310         self.update()\n2311 \n2312         self._active_handle = None\n2313 \n2314         return False\n2315 \n2316     def _hover(self, event):\n2317         \"\"\"Update the canvas cursor if it's over a handle.\"\"\"\n2318         if self.ignore(event):\n2319             return\n2320 \n2321         if self._active_handle is not None:\n2322             # Do nothing if button is pressed and a handle is active, which may\n2323             # occur with drag_from_anywhere=True.\n2324             return\n2325 \n2326         _, e_dist = self._edge_handles.closest(event.x, event.y)\n2327         self._set_cursor(e_dist <= self.grab_range)\n2328 \n2329     def _onmove(self, event):\n2330         \"\"\"Motion notify event handler.\"\"\"\n2331 \n2332         # self._prev are deprecated but we still need to maintain it\n2333         self._prev = self._get_data(event)\n2334 \n2335         v = event.xdata if self.direction == 'horizontal' else event.ydata\n2336         if self.direction == 'horizontal':\n2337             vpress = self._eventpress.xdata\n2338         else:\n2339             vpress = self._eventpress.ydata\n2340 \n2341         # move existing span\n2342         # When \"dragging from anywhere\", `self._active_handle` is set to 'C'\n2343         # (match notation used in the RectangleSelector)\n2344         if self._active_handle == 'C' and self._extents_on_press is not None:\n2345             vmin, vmax = self._extents_on_press\n2346             dv = v - vpress\n2347             vmin += dv\n2348             vmax += dv\n2349 \n2350         # resize an existing shape\n2351         elif self._active_handle and self._active_handle != 'C':\n2352             vmin, vmax = self._extents_on_press\n2353             if self._active_handle == 'min':\n2354                 vmin = v\n2355             else:\n2356                 vmax = v\n2357         # new shape\n2358         else:\n2359             # Don't create a new span if there is already one when\n2360             # ignore_event_outside=True\n2361             if self.ignore_event_outside and self._selection_completed:\n2362                 return\n2363             vmin, vmax = vpress, v\n2364             if vmin > vmax:\n2365                 vmin, vmax = vmax, vmin\n2366 \n2367         self.extents = vmin, vmax\n2368 \n2369         if self.onmove_callback is not None:\n2370             self.onmove_callback(vmin, vmax)\n2371 \n2372         return False\n2373 \n2374     def _draw_shape(self, vmin, vmax):\n2375         if vmin > vmax:\n2376             vmin, vmax = vmax, vmin\n2377         if self.direction == 'horizontal':\n2378             self._rect.set_x(vmin)\n2379             self._rect.set_width(vmax - vmin)\n2380         else:\n2381             self._rect.set_y(vmin)\n2382             self._rect.set_height(vmax - vmin)\n2383 \n2384     def _set_active_handle(self, event):\n2385         \"\"\"Set active handle based on the location of the mouse event.\"\"\"\n2386         # Note: event.xdata/ydata in data coordinates, event.x/y in pixels\n2387         e_idx, e_dist = self._edge_handles.closest(event.x, event.y)\n2388 \n2389         # Prioritise center handle over other handles\n2390         # Use 'C' to match the notation used in the RectangleSelector\n2391         if 'move' in self._state:\n2392             self._active_handle = 'C'\n2393         elif e_dist > self.grab_range:\n2394             # Not close to any handles\n2395             self._active_handle = None\n2396             if self.drag_from_anywhere and self._contains(event):\n2397                 # Check if we've clicked inside the region\n2398                 self._active_handle = 'C'\n2399                 self._extents_on_press = self.extents\n2400             else:\n2401                 self._active_handle = None\n2402                 return\n2403         else:\n2404             # Closest to an edge handle\n2405             self._active_handle = self._edge_order[e_idx]\n2406 \n2407         # Save coordinates of rectangle at the start of handle movement.\n2408         self._extents_on_press = self.extents\n2409 \n2410     def _contains(self, event):\n2411         \"\"\"Return True if event is within the patch.\"\"\"\n2412         return self._rect.contains(event, radius=0)[0]\n2413 \n2414     @property\n2415     def extents(self):\n2416         \"\"\"Return extents of the span selector.\"\"\"\n2417         if self.direction == 'horizontal':\n2418             vmin = self._rect.get_x()\n2419             vmax = vmin + self._rect.get_width()\n2420         else:\n2421             vmin = self._rect.get_y()\n2422             vmax = vmin + self._rect.get_height()\n2423         return vmin, vmax\n2424 \n2425     @extents.setter\n2426     def extents(self, extents):\n2427         # Update displayed shape\n2428         self._draw_shape(*extents)\n2429         if self._interactive:\n2430             # Update displayed handles\n2431             self._edge_handles.set_data(self.extents)\n2432         self.set_visible(self.visible)\n2433         self.update()\n2434 \n2435 \n2436 class ToolLineHandles:\n2437     \"\"\"\n2438     Control handles for canvas tools.\n2439 \n2440     Parameters\n2441     ----------\n2442     ax : `matplotlib.axes.Axes`\n2443         Matplotlib axes where tool handles are displayed.\n2444     positions : 1D array\n2445         Positions of handles in data coordinates.\n2446     direction : {\"horizontal\", \"vertical\"}\n2447         Direction of handles, either 'vertical' or 'horizontal'\n2448     line_props : dict, optional\n2449         Additional line properties. See `matplotlib.lines.Line2D`.\n2450     useblit : bool, default: True\n2451         Whether to use blitting for faster drawing (if supported by the\n2452         backend).\n2453     \"\"\"\n2454 \n2455     def __init__(self, ax, positions, direction, line_props=None,\n2456                  useblit=True):\n2457         self.ax = ax\n2458 \n2459         _api.check_in_list(['horizontal', 'vertical'], direction=direction)\n2460         self._direction = direction\n2461 \n2462         if line_props is None:\n2463             line_props = {}\n2464         line_props.update({'visible': False, 'animated': useblit})\n2465 \n2466         line_fun = ax.axvline if self.direction == 'horizontal' else ax.axhline\n2467         self._line_props = line_props\n2468 \n2469         self.artists = [line_fun(p, **line_props) for p in positions]\n2470 \n2471     @property\n2472     def positions(self):\n2473         \"\"\"Positions of the handle in data coordinates.\"\"\"\n2474         method = 'get_xdata' if self.direction == 'horizontal' else 'get_ydata'\n2475         return [getattr(line, method)()[0] for line in self.artists]\n2476 \n2477     @property\n2478     def direction(self):\n2479         \"\"\"Direction of the handle: 'vertical' or 'horizontal'.\"\"\"\n2480         return self._direction\n2481 \n2482     def set_data(self, positions):\n2483         \"\"\"\n2484         Set x or y positions of handles, depending if the lines are vertical\n2485         of horizontal.\n2486 \n2487         Parameters\n2488         ----------\n2489         positions : tuple of length 2\n2490             Set the positions of the handle in data coordinates\n2491         \"\"\"\n2492         method = 'set_xdata' if self.direction == 'horizontal' else 'set_ydata'\n2493         for line, p in zip(self.artists, positions):\n2494             getattr(line, method)([p, p])\n2495 \n2496     def set_visible(self, value):\n2497         \"\"\"Set the visibility state of the handles artist.\"\"\"\n2498         for artist in self.artists:\n2499             artist.set_visible(value)\n2500 \n2501     def set_animated(self, value):\n2502         \"\"\"Set the animated state of the handles artist.\"\"\"\n2503         for artist in self.artists:\n2504             artist.set_animated(value)\n2505 \n2506     def remove(self):\n2507         \"\"\"Remove the handles artist from the figure.\"\"\"\n2508         for artist in self.artists:\n2509             artist.remove()\n2510 \n2511     def closest(self, x, y):\n2512         \"\"\"\n2513         Return index and pixel distance to closest handle.\n2514 \n2515         Parameters\n2516         ----------\n2517         x, y : float\n2518             x, y position from which the distance will be calculated to\n2519             determinate the closest handle\n2520 \n2521         Returns\n2522         -------\n2523         index, distance : index of the handle and its distance from\n2524             position x, y\n2525         \"\"\"\n2526         if self.direction == 'horizontal':\n2527             p_pts = np.array([\n2528                 self.ax.transData.transform((p, 0))[0] for p in self.positions\n2529                 ])\n2530             dist = abs(p_pts - x)\n2531         else:\n2532             p_pts = np.array([\n2533                 self.ax.transData.transform((0, p))[1] for p in self.positions\n2534                 ])\n2535             dist = abs(p_pts - y)\n2536         index = np.argmin(dist)\n2537         return index, dist[index]\n2538 \n2539 \n2540 class ToolHandles:\n2541     \"\"\"\n2542     Control handles for canvas tools.\n2543 \n2544     Parameters\n2545     ----------\n2546     ax : `matplotlib.axes.Axes`\n2547         Matplotlib axes where tool handles are displayed.\n2548     x, y : 1D arrays\n2549         Coordinates of control handles.\n2550     marker : str, default: 'o'\n2551         Shape of marker used to display handle. See `matplotlib.pyplot.plot`.\n2552     marker_props : dict, optional\n2553         Additional marker properties. See `matplotlib.lines.Line2D`.\n2554     useblit : bool, default: True\n2555         Whether to use blitting for faster drawing (if supported by the\n2556         backend).\n2557     \"\"\"\n2558 \n2559     def __init__(self, ax, x, y, marker='o', marker_props=None, useblit=True):\n2560         self.ax = ax\n2561         props = {'marker': marker, 'markersize': 7, 'markerfacecolor': 'w',\n2562                  'linestyle': 'none', 'alpha': 0.5, 'visible': False,\n2563                  'label': '_nolegend_',\n2564                  **cbook.normalize_kwargs(marker_props, Line2D._alias_map)}\n2565         self._markers = Line2D(x, y, animated=useblit, **props)\n2566         self.ax.add_line(self._markers)\n2567         self.artist = self._markers\n2568 \n2569     @property\n2570     def x(self):\n2571         return self._markers.get_xdata()\n2572 \n2573     @property\n2574     def y(self):\n2575         return self._markers.get_ydata()\n2576 \n2577     def set_data(self, pts, y=None):\n2578         \"\"\"Set x and y positions of handles.\"\"\"\n2579         if y is not None:\n2580             x = pts\n2581             pts = np.array([x, y])\n2582         self._markers.set_data(pts)\n2583 \n2584     def set_visible(self, val):\n2585         self._markers.set_visible(val)\n2586 \n2587     def set_animated(self, val):\n2588         self._markers.set_animated(val)\n2589 \n2590     def closest(self, x, y):\n2591         \"\"\"Return index and pixel distance to closest index.\"\"\"\n2592         pts = np.column_stack([self.x, self.y])\n2593         # Transform data coordinates to pixel coordinates.\n2594         pts = self.ax.transData.transform(pts)\n2595         diff = pts - [x, y]\n2596         dist = np.hypot(*diff.T)\n2597         min_index = np.argmin(dist)\n2598         return min_index, dist[min_index]\n2599 \n2600 \n2601 _RECTANGLESELECTOR_PARAMETERS_DOCSTRING = \\\n2602     r\"\"\"\n2603     Parameters\n2604     ----------\n2605     ax : `~matplotlib.axes.Axes`\n2606         The parent axes for the widget.\n2607 \n2608     onselect : function\n2609         A callback function that is called after a release event and the\n2610         selection is created, changed or removed.\n2611         It must have the signature::\n2612 \n2613             def onselect(eclick: MouseEvent, erelease: MouseEvent)\n2614 \n2615         where *eclick* and *erelease* are the mouse click and release\n2616         `.MouseEvent`\\s that start and complete the selection.\n2617 \n2618     minspanx : float, default: 0\n2619         Selections with an x-span less than or equal to *minspanx* are removed\n2620         (when already existing) or cancelled.\n2621 \n2622     minspany : float, default: 0\n2623         Selections with an y-span less than or equal to *minspanx* are removed\n2624         (when already existing) or cancelled.\n2625 \n2626     useblit : bool, default: False\n2627         Whether to use blitting for faster drawing (if supported by the\n2628         backend).\n2629 \n2630     props : dict, optional\n2631         Properties with which the __ARTIST_NAME__ is drawn. See\n2632         `matplotlib.patches.Patch` for valid properties.\n2633         Default:\n2634 \n2635         ``dict(facecolor='red', edgecolor='black', alpha=0.2, fill=True)``\n2636 \n2637     spancoords : {\"data\", \"pixels\"}, default: \"data\"\n2638         Whether to interpret *minspanx* and *minspany* in data or in pixel\n2639         coordinates.\n2640 \n2641     button : `.MouseButton`, list of `.MouseButton`, default: all buttons\n2642         Button(s) that trigger rectangle selection.\n2643 \n2644     grab_range : float, default: 10\n2645         Distance in pixels within which the interactive tool handles can be\n2646         activated.\n2647 \n2648     handle_props : dict, optional\n2649         Properties with which the interactive handles (marker artists) are\n2650         drawn. See the marker arguments in `matplotlib.lines.Line2D` for valid\n2651         properties.  Default values are defined in ``mpl.rcParams`` except for\n2652         the default value of ``markeredgecolor`` which will be the same as the\n2653         ``edgecolor`` property in *props*.\n2654 \n2655     interactive : bool, default: False\n2656         Whether to draw a set of handles that allow interaction with the\n2657         widget after it is drawn.\n2658 \n2659     state_modifier_keys : dict, optional\n2660         Keyboard modifiers which affect the widget's behavior.  Values\n2661         amend the defaults.\n2662 \n2663         - \"move\": Move the existing shape, default: no modifier.\n2664         - \"clear\": Clear the current shape, default: \"escape\".\n2665         - \"square\": Makes the shape square, default: \"shift\".\n2666         - \"center\": Make the initial point the center of the shape,\n2667           default: \"ctrl\".\n2668 \n2669         \"square\" and \"center\" can be combined.\n2670 \n2671     drag_from_anywhere : bool, default: False\n2672         If `True`, the widget can be moved by clicking anywhere within\n2673         its bounds.\n2674 \n2675     ignore_event_outside : bool, default: False\n2676         If `True`, the event triggered outside the span selector will be\n2677         ignored.\n2678 \n2679     \"\"\"\n2680 \n2681 \n2682 @docstring.Substitution(_RECTANGLESELECTOR_PARAMETERS_DOCSTRING.replace(\n2683     '__ARTIST_NAME__', 'rectangle'))\n2684 class RectangleSelector(_SelectorWidget):\n2685     \"\"\"\n2686     Select a rectangular region of an axes.\n2687 \n2688     For the cursor to remain responsive you must keep a reference to it.\n2689 \n2690     Press and release events triggered at the same coordinates outside the\n2691     selection will clear the selector, except when\n2692     ``ignore_event_outside=True``.\n2693 \n2694     %s\n2695 \n2696     Examples\n2697     --------\n2698     >>> import matplotlib.pyplot as plt\n2699     >>> import matplotlib.widgets as mwidgets\n2700     >>> fig, ax = plt.subplots()\n2701     >>> ax.plot([1, 2, 3], [10, 50, 100])\n2702     >>> def onselect(eclick, erelease):\n2703     ...     print(eclick.xdata, eclick.ydata)\n2704     ...     print(erelease.xdata, erelease.ydata)\n2705     >>> props = dict(facecolor='blue', alpha=0.5)\n2706     >>> rect = mwidgets.RectangleSelector(ax, onselect, interactive=True,\n2707                                           props=props)\n2708     >>> fig.show()\n2709 \n2710     See also: :doc:`/gallery/widgets/rectangle_selector`\n2711     \"\"\"\n2712 \n2713     _shape_klass = Rectangle\n2714 \n2715     @_api.rename_parameter(\"3.5\", \"maxdist\", \"grab_range\")\n2716     @_api.rename_parameter(\"3.5\", \"marker_props\", \"handle_props\")\n2717     @_api.rename_parameter(\"3.5\", \"rectprops\", \"props\")\n2718     @_api.delete_parameter(\"3.5\", \"drawtype\")\n2719     @_api.delete_parameter(\"3.5\", \"lineprops\")\n2720     def __init__(self, ax, onselect, drawtype='box',\n2721                  minspanx=0, minspany=0, useblit=False,\n2722                  lineprops=None, props=None, spancoords='data',\n2723                  button=None, grab_range=10, handle_props=None,\n2724                  interactive=False, state_modifier_keys=None,\n2725                  drag_from_anywhere=False, ignore_event_outside=False):\n2726         super().__init__(ax, onselect, useblit=useblit, button=button,\n2727                          state_modifier_keys=state_modifier_keys)\n2728 \n2729         self._to_draw = None\n2730         self.visible = True\n2731         self._interactive = interactive\n2732         self.drag_from_anywhere = drag_from_anywhere\n2733         self.ignore_event_outside = ignore_event_outside\n2734 \n2735         if drawtype == 'none':  # draw a line but make it invisible\n2736             _api.warn_deprecated(\n2737                 \"3.5\", message=\"Support for drawtype='none' is deprecated \"\n2738                                \"since %(since)s and will be removed \"\n2739                                \"%(removal)s.\"\n2740                                \"Use props=dict(visible=False) instead.\")\n2741             drawtype = 'line'\n2742             self.visible = False\n2743 \n2744         if drawtype == 'box':\n2745             if props is None:\n2746                 props = dict(facecolor='red', edgecolor='black',\n2747                              alpha=0.2, fill=True)\n2748             props['animated'] = self.useblit\n2749             _props = props\n2750             self.visible = _props.pop('visible', self.visible)\n2751             self._to_draw = self._shape_klass((0, 0), 0, 1, visible=False,\n2752                                               **_props)\n2753             self.ax.add_patch(self._to_draw)\n2754         if drawtype == 'line':\n2755             _api.warn_deprecated(\n2756                 \"3.5\", message=\"Support for drawtype='line' is deprecated \"\n2757                                \"since %(since)s and will be removed \"\n2758                                \"%(removal)s.\")\n2759             if lineprops is None:\n2760                 lineprops = dict(color='black', linestyle='-',\n2761                                  linewidth=2, alpha=0.5)\n2762             lineprops['animated'] = self.useblit\n2763             self.lineprops = lineprops\n2764             self._to_draw = Line2D([0, 0], [0, 0], visible=False,\n2765                                    **self.lineprops)\n2766             self.ax.add_line(self._to_draw)\n2767 \n2768         self.minspanx = minspanx\n2769         self.minspany = minspany\n2770 \n2771         _api.check_in_list(['data', 'pixels'], spancoords=spancoords)\n2772         self.spancoords = spancoords\n2773         self._drawtype = drawtype\n2774 \n2775         self.grab_range = grab_range\n2776 \n2777         handle_props = {\n2778             'markeredgecolor': (props or {}).get('edgecolor', 'black'),\n2779             **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}\n2780 \n2781         self._corner_order = ['NW', 'NE', 'SE', 'SW']\n2782         xc, yc = self.corners\n2783         self._corner_handles = ToolHandles(self.ax, xc, yc,\n2784                                            marker_props=handle_props,\n2785                                            useblit=self.useblit)\n2786 \n2787         self._edge_order = ['W', 'N', 'E', 'S']\n2788         xe, ye = self.edge_centers\n2789         self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',\n2790                                          marker_props=handle_props,\n2791                                          useblit=self.useblit)\n2792 \n2793         xc, yc = self.center\n2794         self._center_handle = ToolHandles(self.ax, [xc], [yc], marker='s',\n2795                                           marker_props=handle_props,\n2796                                           useblit=self.useblit)\n2797 \n2798         self._active_handle = None\n2799 \n2800         self.artists = [self._to_draw, self._center_handle.artist,\n2801                         self._corner_handles.artist,\n2802                         self._edge_handles.artist]\n2803 \n2804         if not self._interactive:\n2805             self.artists = [self._to_draw]\n2806 \n2807         self._extents_on_press = None\n2808 \n2809     to_draw = _api.deprecate_privatize_attribute(\"3.5\")\n2810 \n2811     drawtype = _api.deprecate_privatize_attribute(\"3.5\")\n2812 \n2813     active_handle = _api.deprecate_privatize_attribute(\"3.5\")\n2814 \n2815     interactive = _api.deprecate_privatize_attribute(\"3.5\")\n2816 \n2817     maxdist = _api.deprecated(\"3.5\", name=\"maxdist\", alternative=\"grab_range\")(\n2818         property(lambda self: self.grab_range,\n2819                  lambda self, value: setattr(self, \"grab_range\", value)))\n2820 \n2821     def _press(self, event):\n2822         \"\"\"Button press event handler.\"\"\"\n2823         # make the drawn box/line visible get the click-coordinates,\n2824         # button, ...\n2825         if self._interactive and self._to_draw.get_visible():\n2826             self._set_active_handle(event)\n2827         else:\n2828             self._active_handle = None\n2829 \n2830         if self._active_handle is None or not self._interactive:\n2831             # Clear previous rectangle before drawing new rectangle.\n2832             self.update()\n2833 \n2834         if self._active_handle is None and not self.ignore_event_outside:\n2835             x = event.xdata\n2836             y = event.ydata\n2837             self.visible = False\n2838             self.extents = x, x, y, y\n2839             self.visible = True\n2840         else:\n2841             self.set_visible(True)\n2842 \n2843         return False\n2844 \n2845     def _release(self, event):\n2846         \"\"\"Button release event handler.\"\"\"\n2847         if not self._interactive:\n2848             self._to_draw.set_visible(False)\n2849 \n2850         if (self._active_handle is None and self._selection_completed and\n2851                 self.ignore_event_outside):\n2852             return\n2853 \n2854         # update the eventpress and eventrelease with the resulting extents\n2855         x0, x1, y0, y1 = self.extents\n2856         self._eventpress.xdata = x0\n2857         self._eventpress.ydata = y0\n2858         xy0 = self.ax.transData.transform([x0, y0])\n2859         self._eventpress.x, self._eventpress.y = xy0\n2860 \n2861         self._eventrelease.xdata = x1\n2862         self._eventrelease.ydata = y1\n2863         xy1 = self.ax.transData.transform([x1, y1])\n2864         self._eventrelease.x, self._eventrelease.y = xy1\n2865 \n2866         # calculate dimensions of box or line\n2867         if self.spancoords == 'data':\n2868             spanx = abs(self._eventpress.xdata - self._eventrelease.xdata)\n2869             spany = abs(self._eventpress.ydata - self._eventrelease.ydata)\n2870         elif self.spancoords == 'pixels':\n2871             spanx = abs(self._eventpress.x - self._eventrelease.x)\n2872             spany = abs(self._eventpress.y - self._eventrelease.y)\n2873         else:\n2874             _api.check_in_list(['data', 'pixels'],\n2875                                spancoords=self.spancoords)\n2876         # check if drawn distance (if it exists) is not too small in\n2877         # either x or y-direction\n2878         minspanxy = (spanx <= self.minspanx or spany <= self.minspany)\n2879         if (self._drawtype != 'none' and minspanxy):\n2880             for artist in self.artists:\n2881                 artist.set_visible(False)\n2882             if self._selection_completed:\n2883                 # Call onselect, only when the selection is already existing\n2884                 self.onselect(self._eventpress, self._eventrelease)\n2885             self._selection_completed = False\n2886         else:\n2887             self.onselect(self._eventpress, self._eventrelease)\n2888             self._selection_completed = True\n2889 \n2890         self.update()\n2891         self._active_handle = None\n2892 \n2893         return False\n2894 \n2895     def _onmove(self, event):\n2896         \"\"\"Motion notify event handler.\"\"\"\n2897         # resize an existing shape\n2898         if self._active_handle and self._active_handle != 'C':\n2899             x0, x1, y0, y1 = self._extents_on_press\n2900             if self._active_handle in ['E', 'W'] + self._corner_order:\n2901                 x1 = event.xdata\n2902             if self._active_handle in ['N', 'S'] + self._corner_order:\n2903                 y1 = event.ydata\n2904 \n2905         # move existing shape\n2906         elif (('move' in self._state or self._active_handle == 'C' or\n2907                (self.drag_from_anywhere and self._contains(event))) and\n2908               self._extents_on_press is not None):\n2909             x0, x1, y0, y1 = self._extents_on_press\n2910             dx = event.xdata - self._eventpress.xdata\n2911             dy = event.ydata - self._eventpress.ydata\n2912             x0 += dx\n2913             x1 += dx\n2914             y0 += dy\n2915             y1 += dy\n2916 \n2917         # new shape\n2918         else:\n2919             # Don't create a new rectangle if there is already one when\n2920             # ignore_event_outside=True\n2921             if self.ignore_event_outside and self._selection_completed:\n2922                 return\n2923             center = [self._eventpress.xdata, self._eventpress.ydata]\n2924             center_pix = [self._eventpress.x, self._eventpress.y]\n2925             dx = (event.xdata - center[0]) / 2.\n2926             dy = (event.ydata - center[1]) / 2.\n2927 \n2928             # square shape\n2929             if 'square' in self._state:\n2930                 dx_pix = abs(event.x - center_pix[0])\n2931                 dy_pix = abs(event.y - center_pix[1])\n2932                 if not dx_pix:\n2933                     return\n2934                 maxd = max(abs(dx_pix), abs(dy_pix))\n2935                 if abs(dx_pix) < maxd:\n2936                     dx *= maxd / (abs(dx_pix) + 1e-6)\n2937                 if abs(dy_pix) < maxd:\n2938                     dy *= maxd / (abs(dy_pix) + 1e-6)\n2939 \n2940             # from center\n2941             if 'center' in self._state:\n2942                 dx *= 2\n2943                 dy *= 2\n2944 \n2945             # from corner\n2946             else:\n2947                 center[0] += dx\n2948                 center[1] += dy\n2949 \n2950             x0, x1, y0, y1 = (center[0] - dx, center[0] + dx,\n2951                               center[1] - dy, center[1] + dy)\n2952 \n2953         self.extents = x0, x1, y0, y1\n2954 \n2955     @property\n2956     def _rect_bbox(self):\n2957         if self._drawtype == 'box':\n2958             x0 = self._to_draw.get_x()\n2959             y0 = self._to_draw.get_y()\n2960             width = self._to_draw.get_width()\n2961             height = self._to_draw.get_height()\n2962             return x0, y0, width, height\n2963         else:\n2964             x, y = self._to_draw.get_data()\n2965             x0, x1 = min(x), max(x)\n2966             y0, y1 = min(y), max(y)\n2967             return x0, y0, x1 - x0, y1 - y0\n2968 \n2969     @property\n2970     def corners(self):\n2971         \"\"\"Corners of rectangle from lower left, moving clockwise.\"\"\"\n2972         x0, y0, width, height = self._rect_bbox\n2973         xc = x0, x0 + width, x0 + width, x0\n2974         yc = y0, y0, y0 + height, y0 + height\n2975         return xc, yc\n2976 \n2977     @property\n2978     def edge_centers(self):\n2979         \"\"\"Midpoint of rectangle edges from left, moving anti-clockwise.\"\"\"\n2980         x0, y0, width, height = self._rect_bbox\n2981         w = width / 2.\n2982         h = height / 2.\n2983         xe = x0, x0 + w, x0 + width, x0 + w\n2984         ye = y0 + h, y0, y0 + h, y0 + height\n2985         return xe, ye\n2986 \n2987     @property\n2988     def center(self):\n2989         \"\"\"Center of rectangle.\"\"\"\n2990         x0, y0, width, height = self._rect_bbox\n2991         return x0 + width / 2., y0 + height / 2.\n2992 \n2993     @property\n2994     def extents(self):\n2995         \"\"\"Return (xmin, xmax, ymin, ymax).\"\"\"\n2996         x0, y0, width, height = self._rect_bbox\n2997         xmin, xmax = sorted([x0, x0 + width])\n2998         ymin, ymax = sorted([y0, y0 + height])\n2999         return xmin, xmax, ymin, ymax\n3000 \n3001     @extents.setter\n3002     def extents(self, extents):\n3003         # Update displayed shape\n3004         self._draw_shape(extents)\n3005         # Update displayed handles\n3006         self._corner_handles.set_data(*self.corners)\n3007         self._edge_handles.set_data(*self.edge_centers)\n3008         self._center_handle.set_data(*self.center)\n3009         self.set_visible(self.visible)\n3010         self.update()\n3011 \n3012     draw_shape = _api.deprecate_privatize_attribute('3.5')\n3013 \n3014     def _draw_shape(self, extents):\n3015         x0, x1, y0, y1 = extents\n3016         xmin, xmax = sorted([x0, x1])\n3017         ymin, ymax = sorted([y0, y1])\n3018         xlim = sorted(self.ax.get_xlim())\n3019         ylim = sorted(self.ax.get_ylim())\n3020 \n3021         xmin = max(xlim[0], xmin)\n3022         ymin = max(ylim[0], ymin)\n3023         xmax = min(xmax, xlim[1])\n3024         ymax = min(ymax, ylim[1])\n3025 \n3026         if self._drawtype == 'box':\n3027             self._to_draw.set_x(xmin)\n3028             self._to_draw.set_y(ymin)\n3029             self._to_draw.set_width(xmax - xmin)\n3030             self._to_draw.set_height(ymax - ymin)\n3031 \n3032         elif self._drawtype == 'line':\n3033             self._to_draw.set_data([xmin, xmax], [ymin, ymax])\n3034 \n3035     def _set_active_handle(self, event):\n3036         \"\"\"Set active handle based on the location of the mouse event.\"\"\"\n3037         # Note: event.xdata/ydata in data coordinates, event.x/y in pixels\n3038         c_idx, c_dist = self._corner_handles.closest(event.x, event.y)\n3039         e_idx, e_dist = self._edge_handles.closest(event.x, event.y)\n3040         m_idx, m_dist = self._center_handle.closest(event.x, event.y)\n3041 \n3042         if 'move' in self._state:\n3043             self._active_handle = 'C'\n3044             self._extents_on_press = self.extents\n3045         # Set active handle as closest handle, if mouse click is close enough.\n3046         elif m_dist < self.grab_range * 2:\n3047             # Prioritise center handle over other handles\n3048             self._active_handle = 'C'\n3049         elif (c_dist > self.grab_range and\n3050                   e_dist > self.grab_range):\n3051             # Not close to any handles\n3052             if self.drag_from_anywhere and self._contains(event):\n3053                 # Check if we've clicked inside the region\n3054                 self._active_handle = 'C'\n3055                 self._extents_on_press = self.extents\n3056             else:\n3057                 self._active_handle = None\n3058                 return\n3059         elif c_dist < e_dist:\n3060             # Closest to a corner handle\n3061             self._active_handle = self._corner_order[c_idx]\n3062         else:\n3063             # Closest to an edge handle\n3064             self._active_handle = self._edge_order[e_idx]\n3065 \n3066         # Save coordinates of rectangle at the start of handle movement.\n3067         x0, x1, y0, y1 = self.extents\n3068         # Switch variables so that only x1 and/or y1 are updated on move.\n3069         if self._active_handle in ['W', 'SW', 'NW']:\n3070             x0, x1 = x1, event.xdata\n3071         if self._active_handle in ['N', 'NW', 'NE']:\n3072             y0, y1 = y1, event.ydata\n3073         self._extents_on_press = x0, x1, y0, y1\n3074 \n3075     def _contains(self, event):\n3076         \"\"\"Return True if event is within the patch.\"\"\"\n3077         return self._to_draw.contains(event, radius=0)[0]\n3078 \n3079     @property\n3080     def geometry(self):\n3081         \"\"\"\n3082         Return an array of shape (2, 5) containing the\n3083         x (``RectangleSelector.geometry[1, :]``) and\n3084         y (``RectangleSelector.geometry[0, :]``) coordinates\n3085         of the four corners of the rectangle starting and ending\n3086         in the top left corner.\n3087         \"\"\"\n3088         if hasattr(self._to_draw, 'get_verts'):\n3089             xfm = self.ax.transData.inverted()\n3090             y, x = xfm.transform(self._to_draw.get_verts()).T\n3091             return np.array([x, y])\n3092         else:\n3093             return np.array(self._to_draw.get_data())\n3094 \n3095 \n3096 @docstring.Substitution(_RECTANGLESELECTOR_PARAMETERS_DOCSTRING.replace(\n3097     '__ARTIST_NAME__', 'ellipse'))\n3098 class EllipseSelector(RectangleSelector):\n3099     \"\"\"\n3100     Select an elliptical region of an axes.\n3101 \n3102     For the cursor to remain responsive you must keep a reference to it.\n3103 \n3104     Press and release events triggered at the same coordinates outside the\n3105     selection will clear the selector, except when\n3106     ``ignore_event_outside=True``.\n3107 \n3108     %s\n3109 \n3110     Examples\n3111     --------\n3112     :doc:`/gallery/widgets/rectangle_selector`\n3113     \"\"\"\n3114 \n3115     _shape_klass = Ellipse\n3116     draw_shape = _api.deprecate_privatize_attribute('3.5')\n3117 \n3118     def _draw_shape(self, extents):\n3119         x0, x1, y0, y1 = extents\n3120         xmin, xmax = sorted([x0, x1])\n3121         ymin, ymax = sorted([y0, y1])\n3122         center = [x0 + (x1 - x0) / 2., y0 + (y1 - y0) / 2.]\n3123         a = (xmax - xmin) / 2.\n3124         b = (ymax - ymin) / 2.\n3125 \n3126         if self._drawtype == 'box':\n3127             self._to_draw.center = center\n3128             self._to_draw.width = 2 * a\n3129             self._to_draw.height = 2 * b\n3130         else:\n3131             rad = np.deg2rad(np.arange(31) * 12)\n3132             x = a * np.cos(rad) + center[0]\n3133             y = b * np.sin(rad) + center[1]\n3134             self._to_draw.set_data(x, y)\n3135 \n3136     @property\n3137     def _rect_bbox(self):\n3138         if self._drawtype == 'box':\n3139             x, y = self._to_draw.center\n3140             width = self._to_draw.width\n3141             height = self._to_draw.height\n3142             return x - width / 2., y - height / 2., width, height\n3143         else:\n3144             x, y = self._to_draw.get_data()\n3145             x0, x1 = min(x), max(x)\n3146             y0, y1 = min(y), max(y)\n3147             return x0, y0, x1 - x0, y1 - y0\n3148 \n3149 \n3150 class LassoSelector(_SelectorWidget):\n3151     \"\"\"\n3152     Selection curve of an arbitrary shape.\n3153 \n3154     For the selector to remain responsive you must keep a reference to it.\n3155 \n3156     The selected path can be used in conjunction with `~.Path.contains_point`\n3157     to select data points from an image.\n3158 \n3159     In contrast to `Lasso`, `LassoSelector` is written with an interface\n3160     similar to `RectangleSelector` and `SpanSelector`, and will continue to\n3161     interact with the axes until disconnected.\n3162 \n3163     Example usage::\n3164 \n3165         ax = plt.subplot()\n3166         ax.plot(x, y)\n3167 \n3168         def onselect(verts):\n3169             print(verts)\n3170         lasso = LassoSelector(ax, onselect)\n3171 \n3172     Parameters\n3173     ----------\n3174     ax : `~matplotlib.axes.Axes`\n3175         The parent axes for the widget.\n3176     onselect : function\n3177         Whenever the lasso is released, the *onselect* function is called and\n3178         passed the vertices of the selected path.\n3179     useblit : bool, default: True\n3180         Whether to use blitting for faster drawing (if supported by the\n3181         backend).\n3182     props : dict, optional\n3183         Properties with which the line is drawn, see `matplotlib.lines.Line2D`\n3184         for valid properties. Default values are defined in ``mpl.rcParams``.\n3185     button : `.MouseButton` or list of `.MouseButton`, optional\n3186         The mouse buttons used for rectangle selection.  Default is ``None``,\n3187         which corresponds to all buttons.\n3188     \"\"\"\n3189 \n3190     @_api.rename_parameter(\"3.5\", \"lineprops\", \"props\")\n3191     def __init__(self, ax, onselect=None, useblit=True, props=None,\n3192                  button=None):\n3193         super().__init__(ax, onselect, useblit=useblit, button=button)\n3194         self.verts = None\n3195         if props is None:\n3196             props = dict()\n3197         # self.useblit may be != useblit, if the canvas doesn't support blit.\n3198         props.update(animated=self.useblit, visible=False)\n3199         self.line = Line2D([], [], **props)\n3200         self.ax.add_line(self.line)\n3201         self.artists = [self.line]\n3202 \n3203     @_api.deprecated(\"3.5\", alternative=\"press\")\n3204     def onpress(self, event):\n3205         self.press(event)\n3206 \n3207     def _press(self, event):\n3208         self.verts = [self._get_data(event)]\n3209         self.line.set_visible(True)\n3210 \n3211     @_api.deprecated(\"3.5\", alternative=\"release\")\n3212     def onrelease(self, event):\n3213         self.release(event)\n3214 \n3215     def _release(self, event):\n3216         if self.verts is not None:\n3217             self.verts.append(self._get_data(event))\n3218             self.onselect(self.verts)\n3219         self.line.set_data([[], []])\n3220         self.line.set_visible(False)\n3221         self.verts = None\n3222 \n3223     def _onmove(self, event):\n3224         if self.verts is None:\n3225             return\n3226         self.verts.append(self._get_data(event))\n3227         self.line.set_data(list(zip(*self.verts)))\n3228         self.update()\n3229 \n3230 \n3231 class PolygonSelector(_SelectorWidget):\n3232     \"\"\"\n3233     Select a polygon region of an axes.\n3234 \n3235     Place vertices with each mouse click, and make the selection by completing\n3236     the polygon (clicking on the first vertex). Once drawn individual vertices\n3237     can be moved by clicking and dragging with the left mouse button, or\n3238     removed by clicking the right mouse button.\n3239 \n3240     In addition, the following modifier keys can be used:\n3241 \n3242     - Hold *ctrl* and click and drag a vertex to reposition it before the\n3243       polygon has been completed.\n3244     - Hold the *shift* key and click and drag anywhere in the axes to move\n3245       all vertices.\n3246     - Press the *esc* key to start a new polygon.\n3247 \n3248     For the selector to remain responsive you must keep a reference to it.\n3249 \n3250     Parameters\n3251     ----------\n3252     ax : `~matplotlib.axes.Axes`\n3253         The parent axes for the widget.\n3254 \n3255     onselect : function\n3256         When a polygon is completed or modified after completion,\n3257         the *onselect* function is called and passed a list of the vertices as\n3258         ``(xdata, ydata)`` tuples.\n3259 \n3260     useblit : bool, default: False\n3261         Whether to use blitting for faster drawing (if supported by the\n3262         backend).\n3263 \n3264     props : dict, optional\n3265         Properties with which the line is drawn, see `matplotlib.lines.Line2D`\n3266         for valid properties.\n3267         Default:\n3268 \n3269             ``dict(color='k', linestyle='-', linewidth=2, alpha=0.5)``\n3270 \n3271     handle_props : dict, optional\n3272         Artist properties for the markers drawn at the vertices of the polygon.\n3273         See the marker arguments in `matplotlib.lines.Line2D` for valid\n3274         properties.  Default values are defined in ``mpl.rcParams`` except for\n3275         the default value of ``markeredgecolor`` which will be the same as the\n3276         ``color`` property in *props*.\n3277 \n3278     grab_range : float, default: 10\n3279         A vertex is selected (to complete the polygon or to move a vertex) if\n3280         the mouse click is within *grab_range* pixels of the vertex.\n3281 \n3282     Examples\n3283     --------\n3284     :doc:`/gallery/widgets/polygon_selector_demo`\n3285 \n3286     Notes\n3287     -----\n3288     If only one point remains after removing points, the selector reverts to an\n3289     incomplete state and you can start drawing a new polygon from the existing\n3290     point.\n3291     \"\"\"\n3292 \n3293     @_api.rename_parameter(\"3.5\", \"lineprops\", \"props\")\n3294     @_api.rename_parameter(\"3.5\", \"markerprops\", \"handle_props\")\n3295     @_api.rename_parameter(\"3.5\", \"vertex_select_radius\", \"grab_range\")\n3296     def __init__(self, ax, onselect, useblit=False,\n3297                  props=None, handle_props=None, grab_range=10):\n3298         # The state modifiers 'move', 'square', and 'center' are expected by\n3299         # _SelectorWidget but are not supported by PolygonSelector\n3300         # Note: could not use the existing 'move' state modifier in-place of\n3301         # 'move_all' because _SelectorWidget automatically discards 'move'\n3302         # from the state on button release.\n3303         state_modifier_keys = dict(clear='escape', move_vertex='control',\n3304                                    move_all='shift', move='not-applicable',\n3305                                    square='not-applicable',\n3306                                    center='not-applicable')\n3307         super().__init__(ax, onselect, useblit=useblit,\n3308                          state_modifier_keys=state_modifier_keys)\n3309 \n3310         self._xs, self._ys = [0], [0]\n3311 \n3312         if props is None:\n3313             props = dict(color='k', linestyle='-', linewidth=2, alpha=0.5)\n3314         props['animated'] = self.useblit\n3315         self.line = Line2D(self._xs, self._ys, **props)\n3316         self.ax.add_line(self.line)\n3317 \n3318         if handle_props is None:\n3319             handle_props = dict(markeredgecolor='k',\n3320                                 markerfacecolor=props.get('color', 'k'))\n3321         self._polygon_handles = ToolHandles(self.ax, self._xs, self._ys,\n3322                                             useblit=self.useblit,\n3323                                             marker_props=handle_props)\n3324 \n3325         self._active_handle_idx = -1\n3326         self.grab_range = grab_range\n3327 \n3328         self.artists = [self.line, self._polygon_handles.artist]\n3329         self.set_visible(True)\n3330 \n3331     vertex_select_radius = _api.deprecated(\"3.5\", name=\"vertex_select_radius\",\n3332                                            alternative=\"grab_range\")(\n3333         property(lambda self: self.grab_range,\n3334                  lambda self, value: setattr(self, \"grab_range\", value))\n3335         )\n3336 \n3337     @property\n3338     def _nverts(self):\n3339         return len(self._xs)\n3340 \n3341     def _remove_vertex(self, i):\n3342         \"\"\"Remove vertex with index i.\"\"\"\n3343         if (self._nverts > 2 and\n3344                 self._selection_completed and\n3345                 i in (0, self._nverts - 1)):\n3346             # If selecting the first or final vertex, remove both first and\n3347             # last vertex as they are the same for a closed polygon\n3348             self._xs.pop(0)\n3349             self._ys.pop(0)\n3350             self._xs.pop(-1)\n3351             self._ys.pop(-1)\n3352             # Close the polygon again by appending the new first vertex to the\n3353             # end\n3354             self._xs.append(self._xs[0])\n3355             self._ys.append(self._ys[0])\n3356         else:\n3357             self._xs.pop(i)\n3358             self._ys.pop(i)\n3359         if self._nverts <= 2:\n3360             # If only one point left, return to incomplete state to let user\n3361             # start drawing again\n3362             self._selection_completed = False\n3363 \n3364     def _press(self, event):\n3365         \"\"\"Button press event handler.\"\"\"\n3366         # Check for selection of a tool handle.\n3367         if ((self._selection_completed or 'move_vertex' in self._state)\n3368                 and len(self._xs) > 0):\n3369             h_idx, h_dist = self._polygon_handles.closest(event.x, event.y)\n3370             if h_dist < self.grab_range:\n3371                 self._active_handle_idx = h_idx\n3372         # Save the vertex positions at the time of the press event (needed to\n3373         # support the 'move_all' state modifier).\n3374         self._xs_at_press, self._ys_at_press = self._xs.copy(), self._ys.copy()\n3375 \n3376     def _release(self, event):\n3377         \"\"\"Button release event handler.\"\"\"\n3378         # Release active tool handle.\n3379         if self._active_handle_idx >= 0:\n3380             if event.button == 3:\n3381                 self._remove_vertex(self._active_handle_idx)\n3382                 self._draw_polygon()\n3383             self._active_handle_idx = -1\n3384 \n3385         # Complete the polygon.\n3386         elif (len(self._xs) > 3\n3387               and self._xs[-1] == self._xs[0]\n3388               and self._ys[-1] == self._ys[0]):\n3389             self._selection_completed = True\n3390 \n3391         # Place new vertex.\n3392         elif (not self._selection_completed\n3393               and 'move_all' not in self._state\n3394               and 'move_vertex' not in self._state):\n3395             self._xs.insert(-1, event.xdata)\n3396             self._ys.insert(-1, event.ydata)\n3397 \n3398         if self._selection_completed:\n3399             self.onselect(self.verts)\n3400 \n3401     def onmove(self, event):\n3402         \"\"\"Cursor move event handler and validator.\"\"\"\n3403         # Method overrides _SelectorWidget.onmove because the polygon selector\n3404         # needs to process the move callback even if there is no button press.\n3405         # _SelectorWidget.onmove include logic to ignore move event if\n3406         # _eventpress is None.\n3407         if not self.ignore(event):\n3408             event = self._clean_event(event)\n3409             self._onmove(event)\n3410             return True\n3411         return False\n3412 \n3413     def _onmove(self, event):\n3414         \"\"\"Cursor move event handler.\"\"\"\n3415         # Move the active vertex (ToolHandle).\n3416         if self._active_handle_idx >= 0:\n3417             idx = self._active_handle_idx\n3418             self._xs[idx], self._ys[idx] = event.xdata, event.ydata\n3419             # Also update the end of the polygon line if the first vertex is\n3420             # the active handle and the polygon is completed.\n3421             if idx == 0 and self._selection_completed:\n3422                 self._xs[-1], self._ys[-1] = event.xdata, event.ydata\n3423 \n3424         # Move all vertices.\n3425         elif 'move_all' in self._state and self._eventpress:\n3426             dx = event.xdata - self._eventpress.xdata\n3427             dy = event.ydata - self._eventpress.ydata\n3428             for k in range(len(self._xs)):\n3429                 self._xs[k] = self._xs_at_press[k] + dx\n3430                 self._ys[k] = self._ys_at_press[k] + dy\n3431 \n3432         # Do nothing if completed or waiting for a move.\n3433         elif (self._selection_completed\n3434               or 'move_vertex' in self._state or 'move_all' in self._state):\n3435             return\n3436 \n3437         # Position pending vertex.\n3438         else:\n3439             # Calculate distance to the start vertex.\n3440             x0, y0 = self.line.get_transform().transform((self._xs[0],\n3441                                                           self._ys[0]))\n3442             v0_dist = np.hypot(x0 - event.x, y0 - event.y)\n3443             # Lock on to the start vertex if near it and ready to complete.\n3444             if len(self._xs) > 3 and v0_dist < self.grab_range:\n3445                 self._xs[-1], self._ys[-1] = self._xs[0], self._ys[0]\n3446             else:\n3447                 self._xs[-1], self._ys[-1] = event.xdata, event.ydata\n3448 \n3449         self._draw_polygon()\n3450 \n3451     def _on_key_press(self, event):\n3452         \"\"\"Key press event handler.\"\"\"\n3453         # Remove the pending vertex if entering the 'move_vertex' or\n3454         # 'move_all' mode\n3455         if (not self._selection_completed\n3456                 and ('move_vertex' in self._state or\n3457                      'move_all' in self._state)):\n3458             self._xs, self._ys = self._xs[:-1], self._ys[:-1]\n3459             self._draw_polygon()\n3460 \n3461     def _on_key_release(self, event):\n3462         \"\"\"Key release event handler.\"\"\"\n3463         # Add back the pending vertex if leaving the 'move_vertex' or\n3464         # 'move_all' mode (by checking the released key)\n3465         if (not self._selection_completed\n3466                 and\n3467                 (event.key == self.state_modifier_keys.get('move_vertex')\n3468                  or event.key == self.state_modifier_keys.get('move_all'))):\n3469             self._xs.append(event.xdata)\n3470             self._ys.append(event.ydata)\n3471             self._draw_polygon()\n3472         # Reset the polygon if the released key is the 'clear' key.\n3473         elif event.key == self.state_modifier_keys.get('clear'):\n3474             event = self._clean_event(event)\n3475             self._xs, self._ys = [event.xdata], [event.ydata]\n3476             self._selection_completed = False\n3477             self.set_visible(True)\n3478 \n3479     def _draw_polygon(self):\n3480         \"\"\"Redraw the polygon based on the new vertex positions.\"\"\"\n3481         self.line.set_data(self._xs, self._ys)\n3482         # Only show one tool handle at the start and end vertex of the polygon\n3483         # if the polygon is completed or the user is locked on to the start\n3484         # vertex.\n3485         if (self._selection_completed\n3486                 or (len(self._xs) > 3\n3487                     and self._xs[-1] == self._xs[0]\n3488                     and self._ys[-1] == self._ys[0])):\n3489             self._polygon_handles.set_data(self._xs[:-1], self._ys[:-1])\n3490         else:\n3491             self._polygon_handles.set_data(self._xs, self._ys)\n3492         self.update()\n3493 \n3494     @property\n3495     def verts(self):\n3496         \"\"\"The polygon vertices, as a list of ``(x, y)`` pairs.\"\"\"\n3497         return list(zip(self._xs[:-1], self._ys[:-1]))\n3498 \n3499 \n3500 class Lasso(AxesWidget):\n3501     \"\"\"\n3502     Selection curve of an arbitrary shape.\n3503 \n3504     The selected path can be used in conjunction with\n3505     `~matplotlib.path.Path.contains_point` to select data points from an image.\n3506 \n3507     Unlike `LassoSelector`, this must be initialized with a starting\n3508     point *xy*, and the `Lasso` events are destroyed upon release.\n3509 \n3510     Parameters\n3511     ----------\n3512     ax : `~matplotlib.axes.Axes`\n3513         The parent axes for the widget.\n3514     xy : (float, float)\n3515         Coordinates of the start of the lasso.\n3516     useblit : bool, default: True\n3517         Whether to use blitting for faster drawing (if supported by the\n3518         backend).\n3519     callback : callable\n3520         Whenever the lasso is released, the *callback* function is called and\n3521         passed the vertices of the selected path.\n3522     \"\"\"\n3523 \n3524     def __init__(self, ax, xy, callback=None, useblit=True):\n3525         super().__init__(ax)\n3526 \n3527         self.useblit = useblit and self.canvas.supports_blit\n3528         if self.useblit:\n3529             self.background = self.canvas.copy_from_bbox(self.ax.bbox)\n3530 \n3531         x, y = xy\n3532         self.verts = [(x, y)]\n3533         self.line = Line2D([x], [y], linestyle='-', color='black', lw=2)\n3534         self.ax.add_line(self.line)\n3535         self.callback = callback\n3536         self.connect_event('button_release_event', self.onrelease)\n3537         self.connect_event('motion_notify_event', self.onmove)\n3538 \n3539     def onrelease(self, event):\n3540         if self.ignore(event):\n3541             return\n3542         if self.verts is not None:\n3543             self.verts.append((event.xdata, event.ydata))\n3544             if len(self.verts) > 2:\n3545                 self.callback(self.verts)\n3546             self.ax.lines.remove(self.line)\n3547         self.verts = None\n3548         self.disconnect_events()\n3549 \n3550     def onmove(self, event):\n3551         if self.ignore(event):\n3552             return\n3553         if self.verts is None:\n3554             return\n3555         if event.inaxes != self.ax:\n3556             return\n3557         if event.button != 1:\n3558             return\n3559         self.verts.append((event.xdata, event.ydata))\n3560 \n3561         self.line.set_data(list(zip(*self.verts)))\n3562 \n3563         if self.useblit:\n3564             self.canvas.restore_region(self.background)\n3565             self.ax.draw_artist(self.line)\n3566             self.canvas.blit(self.ax.bbox)\n3567         else:\n3568             self.canvas.draw_idle()\n",
        "intended_behavior": "Create or update methods within the selector's class to manage color and other properties without directly accessing low-level attributes like `rect`. Implement a mechanism, possibly leveraging `handle_props` or similar, that allows for a clean, maintainable way to update visual properties. This approach should respect the encapsulation of the selector's properties and provide a clear migration path from deprecated methods."
    }
]