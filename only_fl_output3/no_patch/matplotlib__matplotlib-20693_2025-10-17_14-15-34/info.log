2025-10-17 14:15:34.838 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 14:15:41.665 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=319, output_tokens=12, cost=0.003550
2025-10-17 14:15:41.666 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 14:15:41.669 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:15:50.534 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=625, output_tokens=312, cost=0.015610
2025-10-17 14:15:50.540 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:15:53.787 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=666, output_tokens=56, cost=0.008340
2025-10-17 14:15:53.789 | DEBUG    | Extracted a valid json.
2025-10-17 14:15:53.789 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"selector.rect.set_color\")",
        "search_code(\"selector.rectprops.update\")",
        "search_method(\"set_\")",
        "search_code(\"handle_props\")"
    ],
    "bug_locations": []
}
2025-10-17 14:15:53.884 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:15:53.885 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:16:11.678 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1162, output_tokens=763, cost=0.034510
2025-10-17 14:16:11.686 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:16:21.090 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2141, output_tokens=343, cost=0.031700
2025-10-17 14:16:21.097 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:16:25.427 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=697, output_tokens=122, cost=0.010630
2025-10-17 14:16:25.428 | DEBUG    | Extracted a valid json.
2025-10-17 14:16:25.428 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/widgets.py",
            "class": "",
            "method": "",
            "intended_behavior": "Create or update methods within the selector's class to manage color and other properties without directly accessing low-level attributes like `rect`. Implement a mechanism, possibly leveraging `handle_props` or similar, that allows for a clean, maintainable way to update visual properties. This approach should respect the encapsulation of the selector's properties and provide a clear migration path from deprecated methods."
        }
    ]
}
2025-10-17 14:16:25.439 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/widgets.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 GUI neutral widgets
3 ===================
4 
5 Widgets that are designed to work for any of the GUI backends.
6 All of these widgets require you to predefine a `matplotlib.axes.Axes`
7 instance and pass that as the first parameter.  Matplotlib doesn't try to
8 be too smart with respect to layout -- you will have to figure out how
9 wide and tall you want your Axes to be to accommodate your widget.
10 """
11 
12 from contextlib import ExitStack
13 import copy
14 from numbers import Integral, Number
15 
16 import numpy as np
17 
18 import matplotlib as mpl
19 from matplotlib import docstring
20 from . import _api, backend_tools, cbook, colors, ticker
21 from .lines import Line2D
22 from .patches import Circle, Rectangle, Ellipse
23 
24 
25 class LockDraw:
26     """
27     Some widgets, like the cursor, draw onto the canvas, and this is not
28     desirable under all circumstances, like when the toolbar is in zoom-to-rect
29     mode and drawing a rectangle.  To avoid this, a widget can acquire a
30     canvas' lock with ``canvas.widgetlock(widget)`` before drawing on the
31     canvas; this will prevent other widgets from doing so at the same time (if
32     they also try to acquire the lock first).
33     """
34 
35     def __init__(self):
36         self._owner = None
37 
38     def __call__(self, o):
39         """Reserve the lock for *o*."""
40         if not self.available(o):
41             raise ValueError('already locked')
42         self._owner = o
43 
44     def release(self, o):
45         """Release the lock from *o*."""
46         if not self.available(o):
47             raise ValueError('you do not own this lock')
48         self._owner = None
49 
50     def available(self, o):
51         """Return whether drawing is available to *o*."""
52         return not self.locked() or self.isowner(o)
53 
54     def isowner(self, o):
55         """Return whether *o* owns this lock."""
56         return self._owner is o
57 
58     def locked(self):
59         """Return whether the lock is currently held by an owner."""
60         return self._owner is not None
61 
62 
63 class Widget:
64     """
65     Abstract base class for GUI neutral widgets.
66     """
67     drawon = True
68     eventson = True
69     _active = True
70 
71     def set_active(self, active):
72         """Set whether the widget is active."""
73         self._active = active
74 
75     def get_active(self):
76         """Get whether the widget is active."""
77         return self._active
78 
79     # set_active is overridden by SelectorWidgets.
80     active = property(get_active, set_active, doc="Is the widget active?")
81 
82     def ignore(self, event):
83         """
84         Return whether *event* should be ignored.
85 
86         This method should be called at the beginning of any event callback.
87         """
88         return not self.active
89 
90 
91 class AxesWidget(Widget):
92     """
93     Widget connected to a single `~matplotlib.axes.Axes`.
94 
95     To guarantee that the widget remains responsive and not garbage-collected,
96     a reference to the object should be maintained by the user.
97 
98     This is necessary because the callback registry
99     maintains only weak-refs to the functions, which are member
100     functions of the widget.  If there are no references to the widget
101     object it may be garbage collected which will disconnect the callbacks.
102 
103     Attributes
104     ----------
105     ax : `~matplotlib.axes.Axes`
106         The parent axes for the widget.
107     canvas : `~matplotlib.backend_bases.FigureCanvasBase`
108         The parent figure canvas for the widget.
109     active : bool
110         If False, the widget does not respond to events.
111     """
112 
113     cids = _api.deprecated("3.4")(property(lambda self: self._cids))
114 
115     def __init__(self, ax):
116         self.ax = ax
117         self.canvas = ax.figure.canvas
118         self._cids = []
119 
120     def connect_event(self, event, callback):
121         """
122         Connect a callback function with an event.
123 
124         This should be used in lieu of ``figure.canvas.mpl_connect`` since this
125         function stores callback ids for later clean up.
126         """
127         cid = self.canvas.mpl_connect(event, callback)
128         self._cids.append(cid)
129 
130     def disconnect_events(self):
131         """Disconnect all events created by this widget."""
132         for c in self._cids:
133             self.canvas.mpl_disconnect(c)
134 
135 
136 class Button(AxesWidget):
137     """
138     A GUI neutral button.
139 
140     For the button to remain responsive you must keep a reference to it.
141     Call `.on_clicked` to connect to the button.
142 
143     Attributes
144     ----------
145     ax
146         The `matplotlib.axes.Axes` the button renders into.
147     label
148         A `matplotlib.text.Text` instance.
149     color
150         The color of the button when not hovering.
151     hovercolor
152         The color of the button when hovering.
153     """
154 
155     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
156         lambda self: len(self._observers.callbacks['clicked'])))
157     observers = _api.deprecated("3.4")(property(
158         lambda self: self._observers.callbacks['clicked']))
159 
160     def __init__(self, ax, label, image=None,
161                  color='0.85', hovercolor='0.95'):
162         """
163         Parameters
164         ----------
165         ax : `~matplotlib.axes.Axes`
166             The `~.axes.Axes` instance the button will be placed into.
167         label : str
168             The button text.
169         image : array-like or PIL Image
170             The image to place in the button, if not *None*.  The parameter is
171             directly forwarded to `~matplotlib.axes.Axes.imshow`.
172         color : color
173             The color of the button when not activated.
174         hovercolor : color
175             The color of the button when the mouse is over it.
176         """
177         super().__init__(ax)
178 
179         if image is not None:
180             ax.imshow(image)
181         self.label = ax.text(0.5, 0.5, label,
182                              verticalalignment='center',
183                              horizontalalignment='center',
184                              transform=ax.transAxes)
185 
186         self._observers = cbook.CallbackRegistry()
187 
188         self.connect_event('button_press_event', self._click)
189         self.connect_event('button_release_event', self._release)
190         self.connect_event('motion_notify_event', self._motion)
191         ax.set_navigate(False)
192         ax.set_facecolor(color)
193         ax.set_xticks([])
194         ax.set_yticks([])
195         self.color = color
196         self.hovercolor = hovercolor
197 
198     def _click(self, event):
199         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:
200             return
201         if event.canvas.mouse_grabber != self.ax:
202             event.canvas.grab_mouse(self.ax)
203 
204     def _release(self, event):
205         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:
206             return
207         event.canvas.release_mouse(self.ax)
208         if self.eventson and event.inaxes == self.ax:
209             self._observers.process('clicked', event)
210 
211     def _motion(self, event):
212         if self.ignore(event):
213             return
214         c = self.hovercolor if event.inaxes == self.ax else self.color
215         if not colors.same_color(c, self.ax.get_facecolor()):
216             self.ax.set_facecolor(c)
217             if self.drawon:
218                 self.ax.figure.canvas.draw()
219 
220     def on_clicked(self, func):
221         """
222         Connect the callback function *func* to button click events.
223 
224         Returns a connection id, which can be used to disconnect the callback.
225         """
226         return self._observers.connect('clicked', lambda event: func(event))
227 
228     def disconnect(self, cid):
229         """Remove the callback function with connection id *cid*."""
230         self._observers.disconnect(cid)
231 
232 
233 class SliderBase(AxesWidget):
234     """
235     The base class for constructing Slider widgets. Not intended for direct
236     usage.
237 
238     For the slider to remain responsive you must maintain a reference to it.
239     """
240     def __init__(self, ax, orientation, closedmin, closedmax,
241                  valmin, valmax, valfmt, dragging, valstep):
242         if ax.name == '3d':
243             raise ValueError('Sliders cannot be added to 3D Axes')
244 
245         super().__init__(ax)
246         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
247 
248         self.orientation = orientation
249         self.closedmin = closedmin
250         self.closedmax = closedmax
251         self.valmin = valmin
252         self.valmax = valmax
253         self.valstep = valstep
254         self.drag_active = False
255         self.valfmt = valfmt
256 
257         if orientation == "vertical":
258             ax.set_ylim((valmin, valmax))
259             axis = ax.yaxis
260         else:
261             ax.set_xlim((valmin, valmax))
262             axis = ax.xaxis
263 
264         self._fmt = axis.get_major_formatter()
265         if not isinstance(self._fmt, ticker.ScalarFormatter):
266             self._fmt = ticker.ScalarFormatter()
267             self._fmt.set_axis(axis)
268         self._fmt.set_useOffset(False)  # No additive offset.
269         self._fmt.set_useMathText(True)  # x sign before multiplicative offset.
270 
271         ax.set_axis_off()
272         ax.set_navigate(False)
273 
274         self.connect_event("button_press_event", self._update)
275         self.connect_event("button_release_event", self._update)
276         if dragging:
277             self.connect_event("motion_notify_event", self._update)
278         self._observers = cbook.CallbackRegistry()
279 
280     def _stepped_value(self, val):
281         """Return *val* coerced to closest number in the ``valstep`` grid."""
282         if isinstance(self.valstep, Number):
283             val = (self.valmin
284                    + round((val - self.valmin) / self.valstep) * self.valstep)
285         elif self.valstep is not None:
286             valstep = np.asanyarray(self.valstep)
287             if valstep.ndim != 1:
288                 raise ValueError(
289                     f"valstep must have 1 dimension but has {valstep.ndim}"
290                 )
291             val = valstep[np.argmin(np.abs(valstep - val))]
292         return val
293 
294     def disconnect(self, cid):
295         """
296         Remove the observer with connection id *cid*.
297 
298         Parameters
299         ----------
300         cid : int
301             Connection id of the observer to be removed.
302         """
303         self._observers.disconnect(cid)
304 
305     def reset(self):
306         """Reset the slider to the initial value."""
307         if self.val != self.valinit:
308             self.set_val(self.valinit)
309 
310 
311 class Slider(SliderBase):
312     """
313     A slider representing a floating point range.
314 
315     Create a slider from *valmin* to *valmax* in axes *ax*. For the slider to
316     remain responsive you must maintain a reference to it. Call
317     :meth:`on_changed` to connect to the slider event.
318 
319     Attributes
320     ----------
321     val : float
322         Slider value.
323     """
324 
325     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
326         lambda self: len(self._observers.callbacks['changed'])))
327     observers = _api.deprecated("3.4")(property(
328         lambda self: self._observers.callbacks['changed']))
329 
330     def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt=None,
331                  closedmin=True, closedmax=True, slidermin=None,
332                  slidermax=None, dragging=True, valstep=None,
333                  orientation='horizontal', *, initcolor='r',
334                  track_color='lightgrey', handle_style=None, **kwargs):
335         """
336         Parameters
337         ----------
338         ax : Axes
339             The Axes to put the slider in.
340 
341         label : str
342             Slider label.
343 
344         valmin : float
345             The minimum value of the slider.
346 
347         valmax : float
348             The maximum value of the slider.
349 
350         valinit : float, default: 0.5
351             The slider initial position.
352 
353         valfmt : str, default: None
354             %-format string used to format the slider value.  If None, a
355             `.ScalarFormatter` is used instead.
356 
357         closedmin : bool, default: True
358             Whether the slider interval is closed on the bottom.
359 
360         closedmax : bool, default: True
361             Whether the slider interval is closed on the top.
362 
363         slidermin : Slider, default: None
364             Do not allow the current slider to have a value less than
365             the value of the Slider *slidermin*.
366 
367         slidermax : Slider, default: None
368             Do not allow the current slider to have a value greater than
369             the value of the Slider *slidermax*.
370 
371         dragging : bool, default: True
372             If True the slider can be dragged by the mouse.
373 
374         valstep : float or array-like, default: None
375             If a float, the slider will snap to multiples of *valstep*.
376             If an array the slider will snap to the values in the array.
377 
378         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
379             The orientation of the slider.
380 
381         initcolor : color, default: 'r'
382             The color of the line at the *valinit* position. Set to ``'none'``
383             for no line.
384 
385         track_color : color, default: 'lightgrey'
386             The color of the background track. The track is accessible for
387             further styling via the *track* attribute.
388 
389         handle_style : dict
390             Properties of the slider handle. Default values are
391 
392             ========= ===== ======= ========================================
393             Key       Value Default Description
394             ========= ===== ======= ========================================
395             facecolor color 'white' The facecolor of the slider handle.
396             edgecolor color '.75'   The edgecolor of the slider handle.
397             size      int   10      The size of the slider handle in points.
398             ========= ===== ======= ========================================
399 
400             Other values will be transformed as marker{foo} and passed to the
401             `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will
402             result in ``markerstyle = 'x'``.
403 
404         Notes
405         -----
406         Additional kwargs are passed on to ``self.poly`` which is the
407         `~matplotlib.patches.Polygon` that draws the slider knob.  See the
408         `.Polygon` documentation for valid property names (``facecolor``,
409         ``edgecolor``, ``alpha``, etc.).
410         """
411         super().__init__(ax, orientation, closedmin, closedmax,
412                          valmin, valmax, valfmt, dragging, valstep)
413 
414         if slidermin is not None and not hasattr(slidermin, 'val'):
415             raise ValueError(
416                 f"Argument slidermin ({type(slidermin)}) has no 'val'")
417         if slidermax is not None and not hasattr(slidermax, 'val'):
418             raise ValueError(
419                 f"Argument slidermax ({type(slidermax)}) has no 'val'")
420         self.slidermin = slidermin
421         self.slidermax = slidermax
422         valinit = self._value_in_bounds(valinit)
423         if valinit is None:
424             valinit = valmin
425         self.val = valinit
426         self.valinit = valinit
427 
428         defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}
429         handle_style = {} if handle_style is None else handle_style
430         marker_props = {
431             f'marker{k}': v for k, v in {**defaults, **handle_style}.items()
432         }
433 
434         if orientation == 'vertical':
435             self.track = Rectangle(
436                 (.25, 0), .5, 1,
437                 transform=ax.transAxes,
438                 facecolor=track_color
439             )
440             ax.add_patch(self.track)
441             self.poly = ax.axhspan(valmin, valinit, .25, .75, **kwargs)
442             self.hline = ax.axhline(valinit, .15, .85, color=initcolor, lw=1)
443             handleXY = [[0.5], [valinit]]
444         else:
445             self.track = Rectangle(
446                 (0, .25), 1, .5,
447                 transform=ax.transAxes,
448                 facecolor=track_color
449             )
450             ax.add_patch(self.track)
451             self.poly = ax.axvspan(valmin, valinit, .25, .75, **kwargs)
452             # These asymmetric limits (.2, .9) minimize the asymmetry
453             # above and below the *poly* when rendered to pixels.
454             # This seems to be different for Horizontal and Vertical lines.
455             # For discussion see:
456             # https://github.com/matplotlib/matplotlib/pull/19265
457             self.vline = ax.axvline(valinit, .2, .9, color=initcolor, lw=1)
458             handleXY = [[valinit], [0.5]]
459         self._handle, = ax.plot(
460             *handleXY,
461             "o",
462             **marker_props,
463             clip_on=False
464         )
465 
466         if orientation == 'vertical':
467             self.label = ax.text(0.5, 1.02, label, transform=ax.transAxes,
468                                  verticalalignment='bottom',
469                                  horizontalalignment='center')
470 
471             self.valtext = ax.text(0.5, -0.02, self._format(valinit),
472                                    transform=ax.transAxes,
473                                    verticalalignment='top',
474                                    horizontalalignment='center')
475         else:
476             self.label = ax.text(-0.02, 0.5, label, transform=ax.transAxes,
477                                  verticalalignment='center',
478                                  horizontalalignment='right')
479 
480             self.valtext = ax.text(1.02, 0.5, self._format(valinit),
481                                    transform=ax.transAxes,
482                                    verticalalignment='center',
483                                    horizontalalignment='left')
484 
485         self.set_val(valinit)
486 
487     def _value_in_bounds(self, val):
488         """Makes sure *val* is with given bounds."""
489         val = self._stepped_value(val)
490 
491         if val <= self.valmin:
492             if not self.closedmin:
493                 return
494             val = self.valmin
495         elif val >= self.valmax:
496             if not self.closedmax:
497                 return
498             val = self.valmax
499 
500         if self.slidermin is not None and val <= self.slidermin.val:
501             if not self.closedmin:
502                 return
503             val = self.slidermin.val
504 
505         if self.slidermax is not None and val >= self.slidermax.val:
506             if not self.closedmax:
507                 return
508             val = self.slidermax.val
509         return val
510 
511     def _update(self, event):
512         """Update the slider position."""
513         if self.ignore(event) or event.button != 1:
514             return
515 
516         if event.name == 'button_press_event' and event.inaxes == self.ax:
517             self.drag_active = True
518             event.canvas.grab_mouse(self.ax)
519 
520         if not self.drag_active:
521             return
522 
523         elif ((event.name == 'button_release_event') or
524               (event.name == 'button_press_event' and
525                event.inaxes != self.ax)):
526             self.drag_active = False
527             event.canvas.release_mouse(self.ax)
528             return
529         if self.orientation == 'vertical':
530             val = self._value_in_bounds(event.ydata)
531         else:
532             val = self._value_in_bounds(event.xdata)
533         if val not in [None, self.val]:
534             self.set_val(val)
535 
536     def _format(self, val):
537         """Pretty-print *val*."""
538         if self.valfmt is not None:
539             return self.valfmt % val
540         else:
541             _, s, _ = self._fmt.format_ticks([self.valmin, val, self.valmax])
542             # fmt.get_offset is actually the multiplicative factor, if any.
543             return s + self._fmt.get_offset()
544 
545     def set_val(self, val):
546         """
547         Set slider value to *val*.
548 
549         Parameters
550         ----------
551         val : float
552         """
553         xy = self.poly.xy
554         if self.orientation == 'vertical':
555             xy[1] = .25, val
556             xy[2] = .75, val
557             self._handle.set_ydata([val])
558         else:
559             xy[2] = val, .75
560             xy[3] = val, .25
561             self._handle.set_xdata([val])
562         self.poly.xy = xy
563         self.valtext.set_text(self._format(val))
564         if self.drawon:
565             self.ax.figure.canvas.draw_idle()
566         self.val = val
567         if self.eventson:
568             self._observers.process('changed', val)
569 
570     def on_changed(self, func):
571         """
572         Connect *func* as callback function to changes of the slider value.
573 
574         Parameters
575         ----------
576         func : callable
577             Function to call when slider is changed.
578             The function must accept a single float as its arguments.
579 
580         Returns
581         -------
582         int
583             Connection id (which can be used to disconnect *func*).
584         """
585         return self._observers.connect('changed', lambda val: func(val))
586 
587 
588 class RangeSlider(SliderBase):
589     """
590     A slider representing a range of floating point values. Defines the min and
591     max of the range via the *val* attribute as a tuple of (min, max).
592 
593     Create a slider that defines a range contained within [*valmin*, *valmax*]
594     in axes *ax*. For the slider to remain responsive you must maintain a
595     reference to it. Call :meth:`on_changed` to connect to the slider event.
596 
597     Attributes
598     ----------
599     val : tuple of float
600         Slider value.
601     """
602 
603     def __init__(
604         self,
605         ax,
606         label,
607         valmin,
608         valmax,
609         valinit=None,
610         valfmt=None,
611         closedmin=True,
612         closedmax=True,
613         dragging=True,
614         valstep=None,
615         orientation="horizontal",
616         track_color='lightgrey',
617         handle_style=None,
618         **kwargs,
619     ):
620         """
621         Parameters
622         ----------
623         ax : Axes
624             The Axes to put the slider in.
625 
626         label : str
627             Slider label.
628 
629         valmin : float
630             The minimum value of the slider.
631 
632         valmax : float
633             The maximum value of the slider.
634 
635         valinit : tuple of float or None, default: None
636             The initial positions of the slider. If None the initial positions
637             will be at the 25th and 75th percentiles of the range.
638 
639         valfmt : str, default: None
640             %-format string used to format the slider values.  If None, a
641             `.ScalarFormatter` is used instead.
642 
643         closedmin : bool, default: True
644             Whether the slider interval is closed on the bottom.
645 
646         closedmax : bool, default: True
647             Whether the slider interval is closed on the top.
648 
649         dragging : bool, default: True
650             If True the slider can be dragged by the mouse.
651 
652         valstep : float, default: None
653             If given, the slider will snap to multiples of *valstep*.
654 
655         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
656             The orientation of the slider.
657 
658         track_color : color, default: 'lightgrey'
659             The color of the background track. The track is accessible for
660             further styling via the *track* attribute.
661 
662         handle_style : dict
663             Properties of the slider handles. Default values are
664 
665             ========= ===== ======= =========================================
666             Key       Value Default Description
667             ========= ===== ======= =========================================
668             facecolor color 'white' The facecolor of the slider handles.
669             edgecolor color '.75'   The edgecolor of the slider handles.
670             size      int   10      The size of the slider handles in points.
671             ========= ===== ======= =========================================
672 
673             Other values will be transformed as marker{foo} and passed to the
674             `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will
675             result in ``markerstyle = 'x'``.
676 
677         Notes
678         -----
679         Additional kwargs are passed on to ``self.poly`` which is the
680         `~matplotlib.patches.Polygon` that draws the slider knob.  See the
681         `.Polygon` documentation for valid property names (``facecolor``,
682         ``edgecolor``, ``alpha``, etc.).
683         """
684         super().__init__(ax, orientation, closedmin, closedmax,
685                          valmin, valmax, valfmt, dragging, valstep)
686 
687         # Set a value to allow _value_in_bounds() to work.
688         self.val = [valmin, valmax]
689         if valinit is None:
690             # Place at the 25th and 75th percentiles
691             extent = valmax - valmin
692             valinit = np.array([valmin + extent * 0.25,
693                                 valmin + extent * 0.75])
694         else:
695             valinit = self._value_in_bounds(valinit)
696         self.val = valinit
697         self.valinit = valinit
698 
699         defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}
700         handle_style = {} if handle_style is None else handle_style
701         marker_props = {
702             f'marker{k}': v for k, v in {**defaults, **handle_style}.items()
703         }
704 
705         if orientation == "vertical":
706             self.track = Rectangle(
707                 (.25, 0), .5, 2,
708                 transform=ax.transAxes,
709                 facecolor=track_color
710             )
711             ax.add_patch(self.track)
712             self.poly = ax.axhspan(valinit[0], valinit[1], 0, 1, **kwargs)
713             handleXY_1 = [.5, valinit[0]]
714             handleXY_2 = [.5, valinit[1]]
715         else:
716             self.track = Rectangle(
717                 (0, .25), 1, .5,
718                 transform=ax.transAxes,
719                 facecolor=track_color
720             )
721             ax.add_patch(self.track)
722             self.poly = ax.axvspan(valinit[0], valinit[1], 0, 1, **kwargs)
723             handleXY_1 = [valinit[0], .5]
724             handleXY_2 = [valinit[1], .5]
725         self._handles = [
726             ax.plot(
727                 *handleXY_1,
728                 "o",
729                 **marker_props,
730                 clip_on=False
731             )[0],
732             ax.plot(
733                 *handleXY_2,
734                 "o",
735                 **marker_props,
736                 clip_on=False
737             )[0]
738         ]
739 
740         if orientation == "vertical":
741             self.label = ax.text(
742                 0.5,
743                 1.02,
744                 label,
745                 transform=ax.transAxes,
746                 verticalalignment="bottom",
747                 horizontalalignment="center",
748             )
749 
750             self.valtext = ax.text(
751                 0.5,
752                 -0.02,
753                 self._format(valinit),
754                 transform=ax.transAxes,
755                 verticalalignment="top",
756                 horizontalalignment="center",
757             )
758         else:
759             self.label = ax.text(
760                 -0.02,
761                 0.5,
762                 label,
763                 transform=ax.transAxes,
764                 verticalalignment="center",
765                 horizontalalignment="right",
766             )
767 
768             self.valtext = ax.text(
769                 1.02,
770                 0.5,
771                 self._format(valinit),
772                 transform=ax.transAxes,
773                 verticalalignment="center",
774                 horizontalalignment="left",
775             )
776 
777         self._active_handle = None
778         self.set_val(valinit)
779 
780     def _min_in_bounds(self, min):
781         """Ensure the new min value is between valmin and self.val[1]."""
782         if min <= self.valmin:
783             if not self.closedmin:
784                 return self.val[0]
785             min = self.valmin
786 
787         if min > self.val[1]:
788             min = self.val[1]
789         return self._stepped_value(min)
790 
791     def _max_in_bounds(self, max):
792         """Ensure the new max value is between valmax and self.val[0]."""
793         if max >= self.valmax:
794             if not self.closedmax:
795                 return self.val[1]
796             max = self.valmax
797 
798         if max <= self.val[0]:
799             max = self.val[0]
800         return self._stepped_value(max)
801 
802     def _value_in_bounds(self, vals):
803         """Clip min, max values to the bounds."""
804         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))
805 
806     def _update_val_from_pos(self, pos):
807         """Update the slider value based on a given position."""
808         idx = np.argmin(np.abs(self.val - pos))
809         if idx == 0:
810             val = self._min_in_bounds(pos)
811             self.set_min(val)
812         else:
813             val = self._max_in_bounds(pos)
814             self.set_max(val)
815         if self._active_handle:
816             self._active_handle.set_xdata([val])
817 
818     def _update(self, event):
819         """Update the slider position."""
820         if self.ignore(event) or event.button != 1:
821             return
822 
823         if event.name == "button_press_event" and event.inaxes == self.ax:
824             self.drag_active = True
825             event.canvas.grab_mouse(self.ax)
826 
827         if not self.drag_active:
828             return
829 
830         elif (event.name == "button_release_event") or (
831             event.name == "button_press_event" and event.inaxes != self.ax
832         ):
833             self.drag_active = False
834             event.canvas.release_mouse(self.ax)
835             self._active_handle = None
836             return
837 
838         # determine which handle was grabbed
839         handle = self._handles[
840             np.argmin(
841                 np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])
842             )
843         ]
844         # these checks ensure smooth behavior if the handles swap which one
845         # has a higher value. i.e. if one is dragged over and past the other.
846         if handle is not self._active_handle:
847             self._active_handle = handle
848 
849         if self.orientation == "vertical":
850             self._update_val_from_pos(event.ydata)
851         else:
852             self._update_val_from_pos(event.xdata)
853 
854     def _format(self, val):
855         """Pretty-print *val*."""
856         if self.valfmt is not None:
857             return f"({self.valfmt % val[0]}, {self.valfmt % val[1]})"
858         else:
859             _, s1, s2, _ = self._fmt.format_ticks(
860                 [self.valmin, *val, self.valmax]
861             )
862             # fmt.get_offset is actually the multiplicative factor, if any.
863             s1 += self._fmt.get_offset()
864             s2 += self._fmt.get_offset()
865             # Use f string to avoid issues with backslashes when cast to a str
866             return f"({s1}, {s2})"
867 
868     def set_min(self, min):
869         """
870         Set the lower value of the slider to *min*.
871 
872         Parameters
873         ----------
874         min : float
875         """
876         self.set_val((min, self.val[1]))
877 
878     def set_max(self, max):
879         """
880         Set the lower value of the slider to *max*.
881 
882         Parameters
883         ----------
884         max : float
885         """
886         self.set_val((self.val[0], max))
887 
888     def set_val(self, val):
889         """
890         Set slider value to *val*.
891 
892         Parameters
893         ----------
894         val : tuple or array-like of float
895         """
896         val = np.sort(np.asanyarray(val))
897         if val.shape != (2,):
898             raise ValueError(
899                 f"val must have shape (2,) but has shape {val.shape}"
900             )
901         val[0] = self._min_in_bounds(val[0])
902         val[1] = self._max_in_bounds(val[1])
903         xy = self.poly.xy
904         if self.orientation == "vertical":
905             xy[0] = .25, val[0]
906             xy[1] = .25, val[1]
907             xy[2] = .75, val[1]
908             xy[3] = .75, val[0]
909             xy[4] = .25, val[0]
910         else:
911             xy[0] = val[0], .25
912             xy[1] = val[0], .75
913             xy[2] = val[1], .75
914             xy[3] = val[1], .25
915             xy[4] = val[0], .25
916         self.poly.xy = xy
917         self.valtext.set_text(self._format(val))
918         if self.drawon:
919             self.ax.figure.canvas.draw_idle()
920         self.val = val
921         if self.eventson:
922             self._observers.process("changed", val)
923 
924     def on_changed(self, func):
925         """
926         Connect *func* as callback function to changes of the slider value.
927 
928         Parameters
929         ----------
930         func : callable
931             Function to call when slider is changed. The function
932             must accept a numpy array with shape (2,) as its argument.
933 
934         Returns
935         -------
936         int
937             Connection id (which can be used to disconnect *func*).
938         """
939         return self._observers.connect('changed', lambda val: func(val))
940 
941 
942 class CheckButtons(AxesWidget):
943     r"""
944     A GUI neutral set of check buttons.
945 
946     For the check buttons to remain responsive you must keep a
947     reference to this object.
948 
949     Connect to the CheckButtons with the `.on_clicked` method.
950 
951     Attributes
952     ----------
953     ax : `~matplotlib.axes.Axes`
954         The parent axes for the widget.
955     labels : list of `.Text`
956 
957     rectangles : list of `.Rectangle`
958 
959     lines : list of (`.Line2D`, `.Line2D`) pairs
960         List of lines for the x's in the check boxes.  These lines exist for
961         each box, but have ``set_visible(False)`` when its box is not checked.
962     """
963 
964     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
965         lambda self: len(self._observers.callbacks['clicked'])))
966     observers = _api.deprecated("3.4")(property(
967         lambda self: self._observers.callbacks['clicked']))
968 
969     def __init__(self, ax, labels, actives=None):
970         """
971         Add check buttons to `matplotlib.axes.Axes` instance *ax*.
972 
973         Parameters
974         ----------
975         ax : `~matplotlib.axes.Axes`
976             The parent axes for the widget.
977 
978         labels : list of str
979             The labels of the check buttons.
980 
981         actives : list of bool, optional
982             The initial check states of the buttons. The list must have the
983             same length as *labels*. If not given, all buttons are unchecked.
984         """
985         super().__init__(ax)
986 
987         ax.set_xticks([])
988         ax.set_yticks([])
989         ax.set_navigate(False)
990 
991         if actives is None:
992             actives = [False] * len(labels)
993 
994         if len(labels) > 1:
995             dy = 1. / (len(labels) + 1)
996             ys = np.linspace(1 - dy, dy, len(labels))
997         else:
998             dy = 0.25
999             ys = [0.5]
1000 
1001         axcolor = ax.get_facecolor()
1002 
1003         self.labels = []
1004         self.lines = []
1005         self.rectangles = []
1006 
1007         lineparams = {'color': 'k', 'linewidth': 1.25,
1008                       'transform': ax.transAxes, 'solid_capstyle': 'butt'}
1009         for y, label, active in zip(ys, labels, actives):
1010             t = ax.text(0.25, y, label, transform=ax.transAxes,
1011                         horizontalalignment='left',
1012                         verticalalignment='center')
1013 
1014             w, h = dy / 2, dy / 2
1015             x, y = 0.05, y - h / 2
1016 
1017             p = Rectangle(xy=(x, y), width=w, height=h, edgecolor='black',
1018                           facecolor=axcolor, transform=ax.transAxes)
1019 
1020             l1 = Line2D([x, x + w], [y + h, y], **lineparams)
1021             l2 = Line2D([x, x + w], [y, y + h], **lineparams)
1022 
1023             l1.set_visible(active)
1024             l2.set_visible(active)
1025             self.labels.append(t)
1026             self.rectangles.append(p)
1027             self.lines.append((l1, l2))
1028             ax.add_patch(p)
1029             ax.add_line(l1)
1030             ax.add_line(l2)
1031 
1032         self.connect_event('button_press_event', self._clicked)
1033 
1034         self._observers = cbook.CallbackRegistry()
1035 
1036     def _clicked(self, event):
1037         if self.ignore(event) or event.button != 1 or event.inaxes != self.ax:
1038             return
1039         for i, (p, t) in enumerate(zip(self.rectangles, self.labels)):
1040             if (t.get_window_extent().contains(event.x, event.y) or
1041                     p.get_window_extent().contains(event.x, event.y)):
1042                 self.set_active(i)
1043                 break
1044 
1045     def set_active(self, index):
1046         """
1047         Toggle (activate or deactivate) a check button by index.
1048 
1049         Callbacks will be triggered if :attr:`eventson` is True.
1050 
1051         Parameters
1052         ----------
1053         index : int
1054             Index of the check button to toggle.
1055 
1056         Raises
1057         ------
1058         ValueError
1059             If *index* is invalid.
1060         """
1061         if index not in range(len(self.labels)):
1062             raise ValueError(f'Invalid CheckButton index: {index}')
1063 
1064         l1, l2 = self.lines[index]
1065         l1.set_visible(not l1.get_visible())
1066         l2.set_visible(not l2.get_visible())
1067 
1068         if self.drawon:
1069             self.ax.figure.canvas.draw()
1070 
1071         if self.eventson:
1072             self._observers.process('clicked', self.labels[index].get_text())
1073 
1074     def get_status(self):
1075         """
1076         Return a tuple of the status (True/False) of all of the check buttons.
1077         """
1078         return [l1.get_visible() for (l1, l2) in self.lines]
1079 
1080     def on_clicked(self, func):
1081         """
1082         Connect the callback function *func* to button click events.
1083 
1084         Returns a connection id, which can be used to disconnect the callback.
1085         """
1086         return self._observers.connect('clicked', lambda text: func(text))
1087 
1088     def disconnect(self, cid):
1089         """Remove the observer with connection id *cid*."""
1090         self._observers.disconnect(cid)
1091 
1092 
1093 class TextBox(AxesWidget):
1094     """
1095     A GUI neutral text input box.
1096 
1097     For the text box to remain responsive you must keep a reference to it.
1098 
1099     Call `.on_text_change` to be updated whenever the text changes.
1100 
1101     Call `.on_submit` to be updated whenever the user hits enter or
1102     leaves the text entry field.
1103 
1104     Attributes
1105     ----------
1106     ax : `~matplotlib.axes.Axes`
1107         The parent axes for the widget.
1108     label : `.Text`
1109 
1110     color : color
1111         The color of the text box when not hovering.
1112     hovercolor : color
1113         The color of the text box when hovering.
1114     """
1115 
1116     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
1117         lambda self: sum(len(d) for d in self._observers.callbacks.values())))
1118     change_observers = _api.deprecated("3.4")(property(
1119         lambda self: self._observers.callbacks['change']))
1120     submit_observers = _api.deprecated("3.4")(property(
1121         lambda self: self._observers.callbacks['submit']))
1122     DIST_FROM_LEFT = _api.deprecate_privatize_attribute("3.5")
1123 
1124     def __init__(self, ax, label, initial='',
1125                  color='.95', hovercolor='1', label_pad=.01,
1126                  textalignment="left"):
1127         """
1128         Parameters
1129         ----------
1130         ax : `~matplotlib.axes.Axes`
1131             The `~.axes.Axes` instance the button will be placed into.
1132         label : str
1133             Label for this text box.
1134         initial : str
1135             Initial value in the text box.
1136         color : color
1137             The color of the box.
1138         hovercolor : color
1139             The color of the box when the mouse is over it.
1140         label_pad : float
1141             The distance between the label and the right side of the textbox.
1142         textalignment : {'left', 'center', 'right'}
1143             The horizontal location of the text.
1144         """
1145         super().__init__(ax)
1146 
1147         self._DIST_FROM_LEFT = .05
1148 
1149         self._text_position = _api.check_getitem(
1150             {"left": 0.05, "center": 0.5, "right": 0.95},
1151             textalignment=textalignment)
1152 
1153         self.label = ax.text(
1154             -label_pad, 0.5, label, transform=ax.transAxes,
1155             verticalalignment='center', horizontalalignment='right')
1156 
1157         # TextBox's text object should not parse mathtext at all.
1158         self.text_disp = self.ax.text(
1159             self._text_position, 0.5, initial, transform=self.ax.transAxes,
1160             verticalalignment='center', horizontalalignment=textalignment,
1161             parse_math=False)
1162 
1163         self._observers = cbook.CallbackRegistry()
1164 
1165         ax.set(
1166             xlim=(0, 1), ylim=(0, 1),  # s.t. cursor appears from first click.
1167             navigate=False, facecolor=color,
1168             xticks=[], yticks=[])
1169 
1170         self.cursor_index = 0
1171 
1172         self.cursor = ax.vlines(0, 0, 0, visible=False, color="k", lw=1,
1173                                 transform=mpl.transforms.IdentityTransform())
1174 
1175         self.connect_event('button_press_event', self._click)
1176         self.connect_event('button_release_event', self._release)
1177         self.connect_event('motion_notify_event', self._motion)
1178         self.connect_event('key_press_event', self._keypress)
1179         self.connect_event('resize_event', self._resize)
1180 
1181         self.color = color
1182         self.hovercolor = hovercolor
1183 
1184         self.capturekeystrokes = False
1185 
1186     @property
1187     def text(self):
1188         return self.text_disp.get_text()
1189 
1190     def _rendercursor(self):
1191         # this is a hack to figure out where the cursor should go.
1192         # we draw the text up to where the cursor should go, measure
1193         # and save its dimensions, draw the real text, then put the cursor
1194         # at the saved dimensions
1195 
1196         # This causes a single extra draw if the figure has never been rendered
1197         # yet, which should be fine as we're going to repeatedly re-render the
1198         # figure later anyways.
1199         if self.ax.figure._cachedRenderer is None:
1200             self.ax.figure.canvas.draw()
1201 
1202         text = self.text_disp.get_text()  # Save value before overwriting it.
1203         widthtext = text[:self.cursor_index]
1204 
1205         bb_text = self.text_disp.get_window_extent()
1206         self.text_disp.set_text(widthtext or ",")
1207         bb_widthtext = self.text_disp.get_window_extent()
1208 
1209         if bb_text.y0 == bb_text.y1:  # Restoring the height if no text.
1210             bb_text.y0 -= (bb_widthtext.y1-bb_widthtext.y0)/2
1211             bb_text.y1 += (bb_widthtext.y1-bb_widthtext.y0)/2
1212         elif not widthtext:  # Keep width to 0.
1213             bb_text.x1 = bb_text.x0
1214         else:  # Move the cursor using width of bb_widthtext.
1215             bb_text.x1 = bb_text.x0 + (bb_widthtext.x1 - bb_widthtext.x0)
1216 
1217         self.cursor.set(
1218             segments=[[(bb_text.x1, bb_text.y0), (bb_text.x1, bb_text.y1)]],
1219             visible=True)
1220         self.text_disp.set_text(text)
1221 
1222         self.ax.figure.canvas.draw()
1223 
1224     def _release(self, event):
1225         if self.ignore(event):
1226             return
1227         if event.canvas.mouse_grabber != self.ax:
1228             return
1229         event.canvas.release_mouse(self.ax)
1230 
1231     def _keypress(self, event):
1232         if self.ignore(event):
1233             return
1234         if self.capturekeystrokes:
1235             key = event.key
1236             text = self.text
1237             if len(key) == 1:
1238                 text = (text[:self.cursor_index] + key +
1239                         text[self.cursor_index:])
1240                 self.cursor_index += 1
1241             elif key == "right":
1242                 if self.cursor_index != len(text):
1243                     self.cursor_index += 1
1244             elif key == "left":
1245                 if self.cursor_index != 0:
1246                     self.cursor_index -= 1
1247             elif key == "home":
1248                 self.cursor_index = 0
1249             elif key == "end":
1250                 self.cursor_index = len(text)
1251             elif key == "backspace":
1252                 if self.cursor_index != 0:
1253                     text = (text[:self.cursor_index - 1] +
1254                             text[self.cursor_index:])
1255                     self.cursor_index -= 1
1256             elif key == "delete":
1257                 if self.cursor_index != len(self.text):
1258                     text = (text[:self.cursor_index] +
1259                             text[self.cursor_index + 1:])
1260             self.text_disp.set_text(text)
1261             self._rendercursor()
1262             if self.eventson:
1263                 self._observers.process('change', self.text)
1264                 if key in ["enter", "return"]:
1265                     self._observers.process('submit', self.text)
1266 
1267     def set_val(self, val):
1268         newval = str(val)
1269         if self.text == newval:
1270             return
1271         self.text_disp.set_text(newval)
1272         self._rendercursor()
1273         if self.eventson:
1274             self._observers.process('change', self.text)
1275             self._observers.process('submit', self.text)
1276 
1277     def begin_typing(self, x):
1278         self.capturekeystrokes = True
1279         # Disable keypress shortcuts, which may otherwise cause the figure to
1280         # be saved, closed, etc., until the user stops typing.  The way to
1281         # achieve this depends on whether toolmanager is in use.
1282         stack = ExitStack()  # Register cleanup actions when user stops typing.
1283         self._on_stop_typing = stack.close
1284         toolmanager = getattr(
1285             self.ax.figure.canvas.manager, "toolmanager", None)
1286         if toolmanager is not None:
1287             # If using toolmanager, lock keypresses, and plan to release the
1288             # lock when typing stops.
1289             toolmanager.keypresslock(self)
1290             stack.push(toolmanager.keypresslock.release, self)
1291         else:
1292             # If not using toolmanager, disable all keypress-related rcParams.
1293             # Avoid spurious warnings if keymaps are getting deprecated.
1294             with _api.suppress_matplotlib_deprecation_warning():
1295                 stack.enter_context(mpl.rc_context(
1296                     {k: [] for k in mpl.rcParams if k.startswith("keymap.")}))
1297 
1298     def stop_typing(self):
1299         if self.capturekeystrokes:
1300             self._on_stop_typing()
1301             self._on_stop_typing = None
1302             notifysubmit = True
1303         else:
1304             notifysubmit = False
1305         self.capturekeystrokes = False
1306         self.cursor.set_visible(False)
1307         self.ax.figure.canvas.draw()
1308         if notifysubmit and self.eventson:
1309             # Because process() might throw an error in the user's code, only
1310             # call it once we've already done our cleanup.
1311             self._observers.process('submit', self.text)
1312 
1313     def position_cursor(self, x):
1314         # now, we have to figure out where the cursor goes.
1315         # approximate it based on assuming all characters the same length
1316         if len(self.text) == 0:
1317             self.cursor_index = 0
1318         else:
1319             bb = self.text_disp.get_window_extent()
1320             ratio = np.clip((x - bb.x0) / bb.width, 0, 1)
1321             self.cursor_index = int(len(self.text) * ratio)
1322         self._rendercursor()
1323 
1324     def _click(self, event):
1325         if self.ignore(event):
1326             return
1327         if event.inaxes != self.ax:
1328             self.stop_typing()
1329             return
1330         if not self.eventson:
1331             return
1332         if event.canvas.mouse_grabber != self.ax:
1333             event.canvas.grab_mouse(self.ax)
1334         if not self.capturekeystrokes:
1335             self.begin_typing(event.x)
1336         self.position_cursor(event.x)
1337 
1338     def _resize(self, event):
1339         self.stop_typing()
1340 
1341     def _motion(self, event):
1342         if self.ignore(event):
1343             return
1344         c = self.hovercolor if event.inaxes == self.ax else self.color
1345         if not colors.same_color(c, self.ax.get_facecolor()):
1346             self.ax.set_facecolor(c)
1347             if self.drawon:
1348                 self.ax.figure.canvas.draw()
1349 
1350     def on_text_change(self, func):
1351         """
1352         When the text changes, call this *func* with event.
1353 
1354         A connection id is returned which can be used to disconnect.
1355         """
1356         return self._observers.connect('change', lambda text: func(text))
1357 
1358     def on_submit(self, func):
1359         """
1360         When the user hits enter or leaves the submission box, call this
1361         *func* with event.
1362 
1363         A connection id is returned which can be used to disconnect.
1364         """
1365         return self._observers.connect('submit', lambda text: func(text))
1366 
1367     def disconnect(self, cid):
1368         """Remove the observer with connection id *cid*."""
1369         self._observers.disconnect(cid)
1370 
1371 
1372 class RadioButtons(AxesWidget):
1373     """
1374     A GUI neutral radio button.
1375 
1376     For the buttons to remain responsive you must keep a reference to this
1377     object.
1378 
1379     Connect to the RadioButtons with the `.on_clicked` method.
1380 
1381     Attributes
1382     ----------
1383     ax : `~matplotlib.axes.Axes`
1384         The parent axes for the widget.
1385     activecolor : color
1386         The color of the selected button.
1387     labels : list of `.Text`
1388         The button labels.
1389     circles : list of `~.patches.Circle`
1390         The buttons.
1391     value_selected : str
1392         The label text of the currently selected button.
1393     """
1394 
1395     def __init__(self, ax, labels, active=0, activecolor='blue'):
1396         """
1397         Add radio buttons to an `~.axes.Axes`.
1398 
1399         Parameters
1400         ----------
1401         ax : `~matplotlib.axes.Axes`
1402             The axes to add the buttons to.
1403         labels : list of str
1404             The button labels.
1405         active : int
1406             The index of the initially selected button.
1407         activecolor : color
1408             The color of the selected button.
1409         """
1410         super().__init__(ax)
1411         self.activecolor = activecolor
1412         self.value_selected = None
1413 
1414         ax.set_xticks([])
1415         ax.set_yticks([])
1416         ax.set_navigate(False)
1417         dy = 1. / (len(labels) + 1)
1418         ys = np.linspace(1 - dy, dy, len(labels))
1419         cnt = 0
1420         axcolor = ax.get_facecolor()
1421 
1422         # scale the radius of the circle with the spacing between each one
1423         circle_radius = dy / 2 - 0.01
1424         # default to hard-coded value if the radius becomes too large
1425         circle_radius = min(circle_radius, 0.05)
1426 
1427         self.labels = []
1428         self.circles = []
1429         for y, label in zip(ys, labels):
1430             t = ax.text(0.25, y, label, transform=ax.transAxes,
1431                         horizontalalignment='left',
1432                         verticalalignment='center')
1433 
1434             if cnt == active:
1435                 self.value_selected = label
1436                 facecolor = activecolor
1437             else:
1438                 facecolor = axcolor
1439 
1440             p = Circle(xy=(0.15, y), radius=circle_radius, edgecolor='black',
1441                        facecolor=facecolor, transform=ax.transAxes)
1442 
1443             self.labels.append(t)
1444             self.circles.append(p)
1445             ax.add_patch(p)
1446             cnt += 1
1447 
1448         self.connect_event('button_press_event', self._clicked)
1449 
1450         self._observers = cbook.CallbackRegistry()
1451 
1452     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
1453         lambda self: len(self._observers.callbacks['clicked'])))
1454     observers = _api.deprecated("3.4")(property(
1455         lambda self: self._observers.callbacks['clicked']))
1456 
1457     def _clicked(self, event):
1458         if self.ignore(event) or event.button != 1 or event.inaxes != self.ax:
1459             return
1460         pclicked = self.ax.transAxes.inverted().transform((event.x, event.y))
1461         distances = {}
1462         for i, (p, t) in enumerate(zip(self.circles, self.labels)):
1463             if (t.get_window_extent().contains(event.x, event.y)
1464                     or np.linalg.norm(pclicked - p.center) < p.radius):
1465                 distances[i] = np.linalg.norm(pclicked - p.center)
1466         if len(distances) > 0:
1467             closest = min(distances, key=distances.get)
1468             self.set_active(closest)
1469 
1470     def set_active(self, index):
1471         """
1472         Select button with number *index*.
1473 
1474         Callbacks will be triggered if :attr:`eventson` is True.
1475         """
1476         if index not in range(len(self.labels)):
1477             raise ValueError(f'Invalid RadioButton index: {index}')
1478 
1479         self.value_selected = self.labels[index].get_text()
1480 
1481         for i, p in enumerate(self.circles):
1482             if i == index:
1483                 color = self.activecolor
1484             else:
1485                 color = self.ax.get_facecolor()
1486             p.set_facecolor(color)
1487 
1488         if self.drawon:
1489             self.ax.figure.canvas.draw()
1490 
1491         if self.eventson:
1492             self._observers.process('clicked', self.labels[index].get_text())
1493 
1494     def on_clicked(self, func):
1495         """
1496         Connect the callback function *func* to button click events.
1497 
1498         Returns a connection id, which can be used to disconnect the callback.
1499         """
1500         return self._observers.connect('clicked', func)
1501 
1502     def disconnect(self, cid):
1503         """Remove the observer with connection id *cid*."""
1504         self._observers.disconnect(cid)
1505 
1506 
1507 class SubplotTool(Widget):
1508     """
1509     A tool to adjust the subplot params of a `matplotlib.figure.Figure`.
1510     """
1511 
1512     def __init__(self, targetfig, toolfig):
1513         """
1514         Parameters
1515         ----------
1516         targetfig : `.Figure`
1517             The figure instance to adjust.
1518         toolfig : `.Figure`
1519             The figure instance to embed the subplot tool into.
1520         """
1521 
1522         self.figure = toolfig
1523         self.targetfig = targetfig
1524         toolfig.subplots_adjust(left=0.2, right=0.9)
1525         toolfig.suptitle("Click on slider to adjust subplot param")
1526 
1527         self._sliders = []
1528         names = ["left", "bottom", "right", "top", "wspace", "hspace"]
1529         # The last subplot, removed below, keeps space for the "Reset" button.
1530         for name, ax in zip(names, toolfig.subplots(len(names) + 1)):
1531             ax.set_navigate(False)
1532             slider = Slider(ax, name,
1533                             0, 1, getattr(targetfig.subplotpars, name))
1534             slider.on_changed(self._on_slider_changed)
1535             self._sliders.append(slider)
1536         toolfig.axes[-1].remove()
1537         (self.sliderleft, self.sliderbottom, self.sliderright, self.slidertop,
1538          self.sliderwspace, self.sliderhspace) = self._sliders
1539         for slider in [self.sliderleft, self.sliderbottom,
1540                        self.sliderwspace, self.sliderhspace]:
1541             slider.closedmax = False
1542         for slider in [self.sliderright, self.slidertop]:
1543             slider.closedmin = False
1544 
1545         # constraints
1546         self.sliderleft.slidermax = self.sliderright
1547         self.sliderright.slidermin = self.sliderleft
1548         self.sliderbottom.slidermax = self.slidertop
1549         self.slidertop.slidermin = self.sliderbottom
1550 
1551         bax = toolfig.add_axes([0.8, 0.05, 0.15, 0.075])
1552         self.buttonreset = Button(bax, 'Reset')
1553         self.buttonreset.on_clicked(self._on_reset)
1554 
1555     def _on_slider_changed(self, _):
1556         self.targetfig.subplots_adjust(
1557             **{slider.label.get_text(): slider.val
1558                for slider in self._sliders})
1559         if self.drawon:
1560             self.targetfig.canvas.draw()
1561 
1562     def _on_reset(self, event):
1563         with ExitStack() as stack:
1564             # Temporarily disable drawing on self and self's sliders, and
1565             # disconnect slider events (as the subplotparams can be temporarily
1566             # invalid, depending on the order in which they are restored).
1567             stack.enter_context(cbook._setattr_cm(self, drawon=False))
1568             for slider in self._sliders:
1569                 stack.enter_context(
1570                     cbook._setattr_cm(slider, drawon=False, eventson=False))
1571             # Reset the slider to the initial position.
1572             for slider in self._sliders:
1573                 slider.reset()
1574         if self.drawon:
1575             event.canvas.draw()  # Redraw the subplottool canvas.
1576         self._on_slider_changed(None)  # Apply changes to the target window.
1577 
1578 
1579 class Cursor(AxesWidget):
1580     """
1581     A crosshair cursor that spans the axes and moves with mouse cursor.
1582 
1583     For the cursor to remain responsive you must keep a reference to it.
1584 
1585     Parameters
1586     ----------
1587     ax : `matplotlib.axes.Axes`
1588         The `~.axes.Axes` to attach the cursor to.
1589     horizOn : bool, default: True
1590         Whether to draw the horizontal line.
1591     vertOn : bool, default: True
1592         Whether to draw the vertical line.
1593     useblit : bool, default: False
1594         Use blitting for faster drawing if supported by the backend.
1595 
1596     Other Parameters
1597     ----------------
1598     **lineprops
1599         `.Line2D` properties that control the appearance of the lines.
1600         See also `~.Axes.axhline`.
1601 
1602     Examples
1603     --------
1604     See :doc:`/gallery/widgets/cursor`.
1605     """
1606 
1607     def __init__(self, ax, horizOn=True, vertOn=True, useblit=False,
1608                  **lineprops):
1609         super().__init__(ax)
1610 
1611         self.connect_event('motion_notify_event', self.onmove)
1612         self.connect_event('draw_event', self.clear)
1613 
1614         self.visible = True
1615         self.horizOn = horizOn
1616         self.vertOn = vertOn
1617         self.useblit = useblit and self.canvas.supports_blit
1618 
1619         if self.useblit:
1620             lineprops['animated'] = True
1621         self.lineh = ax.axhline(ax.get_ybound()[0], visible=False, **lineprops)
1622         self.linev = ax.axvline(ax.get_xbound()[0], visible=False, **lineprops)
1623 
1624         self.background = None
1625         self.needclear = False
1626 
1627     def clear(self, event):
1628         """Internal event handler to clear the cursor."""
1629         if self.ignore(event):
1630             return
1631         if self.useblit:
1632             self.background = self.canvas.copy_from_bbox(self.ax.bbox)
1633         self.linev.set_visible(False)
1634         self.lineh.set_visible(False)
1635 
1636     def onmove(self, event):
1637         """Internal event handler to draw the cursor when the mouse moves."""
1638         if self.ignore(event):
1639             return
1640         if not self.canvas.widgetlock.available(self):
1641             return
1642         if event.inaxes != self.ax:
1643             self.linev.set_visible(False)
1644             self.lineh.set_visible(False)
1645 
1646             if self.needclear:
1647                 self.canvas.draw()
1648                 self.needclear = False
1649             return
1650         self.needclear = True
1651         if not self.visible:
1652             return
1653         self.linev.set_xdata((event.xdata, event.xdata))
1654 
1655         self.lineh.set_ydata((event.ydata, event.ydata))
1656         self.linev.set_visible(self.visible and self.vertOn)
1657         self.lineh.set_visible(self.visible and self.horizOn)
1658 
1659         self._update()
1660 
1661     def _update(self):
1662         if self.useblit:
1663             if self.background is not None:
1664                 self.canvas.restore_region(self.background)
1665             self.ax.draw_artist(self.linev)
1666             self.ax.draw_artist(self.lineh)
1667             self.canvas.blit(self.ax.bbox)
1668         else:
1669             self.canvas.draw_idle()
1670         return False
1671 
1672 
1673 class MultiCursor(Widget):
1674     """
1675     Provide a vertical (default) and/or horizontal line cursor shared between
1676     multiple axes.
1677 
1678     For the cursor to remain responsive you must keep a reference to it.
1679 
1680     Example usage::
1681 
1682         from matplotlib.widgets import MultiCursor
1683         import matplotlib.pyplot as plt
1684         import numpy as np
1685 
1686         fig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)
1687         t = np.arange(0.0, 2.0, 0.01)
1688         ax1.plot(t, np.sin(2*np.pi*t))
1689         ax2.plot(t, np.sin(4*np.pi*t))
1690 
1691         multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1,
1692                             horizOn=False, vertOn=True)
1693         plt.show()
1694 
1695     """
1696     def __init__(self, canvas, axes, useblit=True, horizOn=False, vertOn=True,
1697                  **lineprops):
1698 
1699         self.canvas = canvas
1700         self.axes = axes
1701         self.horizOn = horizOn
1702         self.vertOn = vertOn
1703 
1704         xmin, xmax = axes[-1].get_xlim()
1705         ymin, ymax = axes[-1].get_ylim()
1706         xmid = 0.5 * (xmin + xmax)
1707         ymid = 0.5 * (ymin + ymax)
1708 
1709         self.visible = True
1710         self.useblit = useblit and self.canvas.supports_blit
1711         self.background = None
1712         self.needclear = False
1713 
1714         if self.useblit:
1715             lineprops['animated'] = True
1716 
1717         if vertOn:
1718             self.vlines = [ax.axvline(xmid, visible=False, **lineprops)
1719                            for ax in axes]
1720         else:
1721             self.vlines = []
1722 
1723         if horizOn:
1724             self.hlines = [ax.axhline(ymid, visible=False, **lineprops)
1725                            for ax in axes]
1726         else:
1727             self.hlines = []
1728 
1729         self.connect()
1730 
1731     def connect(self):
1732         """Connect events."""
1733         self._cidmotion = self.canvas.mpl_connect('motion_notify_event',
1734                                                   self.onmove)
1735         self._ciddraw = self.canvas.mpl_connect('draw_event', self.clear)
1736 
1737     def disconnect(self):
1738         """Disconnect events."""
1739         self.canvas.mpl_disconnect(self._cidmotion)
1740         self.canvas.mpl_disconnect(self._ciddraw)
1741 
1742     def clear(self, event):
1743         """Clear the cursor."""
1744         if self.ignore(event):
1745             return
1746         if self.useblit:
1747             self.background = (
1748                 self.canvas.copy_from_bbox(self.canvas.figure.bbox))
1749         for line in self.vlines + self.hlines:
1750             line.set_visible(False)
1751 
1752     def onmove(self, event):
1753         if self.ignore(event):
1754             return
1755         if event.inaxes not in self.axes:
1756             return
1757         if not self.canvas.widgetlock.available(self):
1758             return
1759         self.needclear = True
1760         if not self.visible:
1761             return
1762         if self.vertOn:
1763             for line in self.vlines:
1764                 line.set_xdata((event.xdata, event.xdata))
1765                 line.set_visible(self.visible)
1766         if self.horizOn:
1767             for line in self.hlines:
1768                 line.set_ydata((event.ydata, event.ydata))
1769                 line.set_visible(self.visible)
1770         self._update()
1771 
1772     def _update(self):
1773         if self.useblit:
1774             if self.background is not None:
1775                 self.canvas.restore_region(self.background)
1776             if self.vertOn:
1777                 for ax, line in zip(self.axes, self.vlines):
1778                     ax.draw_artist(line)
1779             if self.horizOn:
1780                 for ax, line in zip(self.axes, self.hlines):
1781                     ax.draw_artist(line)
1782             self.canvas.blit()
1783         else:
1784             self.canvas.draw_idle()
1785 
1786 
1787 class _SelectorWidget(AxesWidget):
1788 
1789     def __init__(self, ax, onselect, useblit=False, button=None,
1790                  state_modifier_keys=None):
1791         super().__init__(ax)
1792 
1793         self.visible = True
1794         self.onselect = onselect
1795         self.useblit = useblit and self.canvas.supports_blit
1796         self.connect_default_events()
1797 
1798         self.state_modifier_keys = dict(move=' ', clear='escape',
1799                                         square='shift', center='control')
1800         self.state_modifier_keys.update(state_modifier_keys or {})
1801 
1802         self.background = None
1803         self.artists = []
1804 
1805         if isinstance(button, Integral):
1806             self.validButtons = [button]
1807         else:
1808             self.validButtons = button
1809 
1810         # Set to True when a selection is completed, otherwise is False
1811         self._selection_completed = False
1812 
1813         # will save the data (position at mouseclick)
1814         self._eventpress = None
1815         # will save the data (pos. at mouserelease)
1816         self._eventrelease = None
1817         self._prev_event = None
1818         self._state = set()
1819 
1820     eventpress = _api.deprecate_privatize_attribute("3.5")
1821     eventrelease = _api.deprecate_privatize_attribute("3.5")
1822     state = _api.deprecate_privatize_attribute("3.5")
1823 
1824     def set_active(self, active):
1825         super().set_active(active)
1826         if active:
1827             self.update_background(None)
1828 
1829     def update_background(self, event):
1830         """Force an update of the background."""
1831         # If you add a call to `ignore` here, you'll want to check edge case:
1832         # `release` can call a draw event even when `ignore` is True.
1833         if not self.useblit:
1834             return
1835         # Make sure that widget artists don't get accidentally included in the
1836         # background, by re-rendering the background if needed (and then
1837         # re-re-rendering the canvas with the visible widget artists).
1838         needs_redraw = any(artist.get_visible() for artist in self.artists)
1839         with ExitStack() as stack:
1840             if needs_redraw:
1841                 for artist in self.artists:
1842                     stack.enter_context(artist._cm_set(visible=False))
1843                 self.canvas.draw()
1844             self.background = self.canvas.copy_from_bbox(self.ax.bbox)
1845         if needs_redraw:
1846             for artist in self.artists:
1847                 self.ax.draw_artist(artist)
1848 
1849     def connect_default_events(self):
1850         """Connect the major canvas events to methods."""
1851         self.connect_event('motion_notify_event', self.onmove)
1852         self.connect_event('button_press_event', self.press)
1853         self.connect_event('button_release_event', self.release)
1854         self.connect_event('draw_event', self.update_background)
1855         self.connect_event('key_press_event', self.on_key_press)
1856         self.connect_event('key_release_event', self.on_key_release)
1857         self.connect_event('scroll_event', self.on_scroll)
1858 
1859     def ignore(self, event):
1860         # docstring inherited
1861         if not self.active or not self.ax.get_visible():
1862             return True
1863         # If canvas was locked
1864         if not self.canvas.widgetlock.available(self):
1865             return True
1866         if not hasattr(event, 'button'):
1867             event.button = None
1868         # Only do rectangle selection if event was triggered
1869         # with a desired button
1870         if (self.validButtons is not None
1871                 and event.button not in self.validButtons):
1872             return True
1873         # If no button was pressed yet ignore the event if it was out
1874         # of the axes
1875         if self._eventpress is None:
1876             return event.inaxes != self.ax
1877         # If a button was pressed, check if the release-button is the same.
1878         if event.button == self._eventpress.button:
1879             return False
1880         # If a button was pressed, check if the release-button is the same.
1881         return (event.inaxes != self.ax or
1882                 event.button != self._eventpress.button)
1883 
1884     def update(self):
1885         """Draw using blit() or draw_idle(), depending on ``self.useblit``."""
1886         if not self.ax.get_visible() or self.ax.figure._cachedRenderer is None:
1887             return False
1888         if self.useblit:
1889             if self.background is not None:
1890                 self.canvas.restore_region(self.background)
1891             else:
1892                 self.update_background(None)
1893             for artist in self.artists:
1894                 self.ax.draw_artist(artist)
1895             self.canvas.blit(self.ax.bbox)
1896         else:
1897             self.canvas.draw_idle()
1898         return False
1899 
1900     def _get_data(self, event):
1901         """Get the xdata and ydata for event, with limits."""
1902         if event.xdata is None:
1903             return None, None
1904         xdata = np.clip(event.xdata, *self.ax.get_xbound())
1905         ydata = np.clip(event.ydata, *self.ax.get_ybound())
1906         return xdata, ydata
1907 
1908     def _clean_event(self, event):
1909         """
1910         Preprocess an event:
1911 
1912         - Replace *event* by the previous event if *event* has no ``xdata``.
1913         - Clip ``xdata`` and ``ydata`` to the axes limits.
1914         - Update the previous event.
1915         """
1916         if event.xdata is None:
1917             event = self._prev_event
1918         else:
1919             event = copy.copy(event)
1920         event.xdata, event.ydata = self._get_data(event)
1921         self._prev_event = event
1922         return event
1923 
1924     def press(self, event):
1925         """Button press handler and validator."""
1926         if not self.ignore(event):
1927             event = self._clean_event(event)
1928             self._eventpress = event
1929             self._prev_event = event
1930             key = event.key or ''
1931             key = key.replace('ctrl', 'control')
1932             # move state is locked in on a button press
1933             if key == self.state_modifier_keys['move']:
1934                 self._state.add('move')
1935             self._press(event)
1936             return True
1937         return False
1938 
1939     def _press(self, event):
1940         """Button press event handler."""
1941 
1942     def release(self, event):
1943         """Button release event handler and validator."""
1944         if not self.ignore(event) and self._eventpress:
1945             event = self._clean_event(event)
1946             self._eventrelease = event
1947             self._release(event)
1948             self._eventpress = None
1949             self._eventrelease = None
1950             self._state.discard('move')
1951             return True
1952         return False
1953 
1954     def _release(self, event):
1955         """Button release event handler."""
1956 
1957     def onmove(self, event):
1958         """Cursor move event handler and validator."""
1959         if not self.ignore(event) and self._eventpress:
1960             event = self._clean_event(event)
1961             self._onmove(event)
1962             return True
1963         return False
1964 
1965     def _onmove(self, event):
1966         """Cursor move event handler."""
1967 
1968     def on_scroll(self, event):
1969         """Mouse scroll event handler and validator."""
1970         if not self.ignore(event):
1971             self._on_scroll(event)
1972 
1973     def _on_scroll(self, event):
1974         """Mouse scroll event handler."""
1975 
1976     def on_key_press(self, event):
1977         """Key press event handler and validator for all selection widgets."""
1978         if self.active:
1979             key = event.key or ''
1980             key = key.replace('ctrl', 'control')
1981             if key == self.state_modifier_keys['clear']:
1982                 for artist in self.artists:
1983                     artist.set_visible(False)
1984                 self.update()
1985                 return
1986             for (state, modifier) in self.state_modifier_keys.items():
1987                 if modifier in key:
1988                     self._state.add(state)
1989             self._on_key_press(event)
1990 
1991     def _on_key_press(self, event):
1992         """Key press event handler - for widget-specific key press actions."""
1993 
1994     def on_key_release(self, event):
1995         """Key release event handler and validator."""
1996         if self.active:
1997             key = event.key or ''
1998             for (state, modifier) in self.state_modifier_keys.items():
1999                 if modifier in key:
2000                     self._state.discard(state)
2001             self._on_key_release(event)
2002 
2003     def _on_key_release(self, event):
2004         """Key release event handler."""
2005 
2006     def set_visible(self, visible):
2007         """Set the visibility of our artists."""
2008         self.visible = visible
2009         for artist in self.artists:
2010             artist.set_visible(visible)
2011 
2012 
2013 class SpanSelector(_SelectorWidget):
2014     """
2015     Visually select a min/max range on a single axis and call a function with
2016     those values.
2017 
2018     To guarantee that the selector remains responsive, keep a reference to it.
2019 
2020     In order to turn off the SpanSelector, set ``span_selector.active`` to
2021     False.  To turn it back on, set it to True.
2022 
2023     Press and release events triggered at the same coordinates outside the
2024     selection will clear the selector, except when
2025     ``ignore_event_outside=True``.
2026 
2027     Parameters
2028     ----------
2029     ax : `matplotlib.axes.Axes`
2030 
2031     onselect : callable
2032         A callback function that is called after a release event and the
2033         selection is created, changed or removed.
2034         It must have the signature::
2035 
2036             def on_select(min: float, max: float) -> Any
2037 
2038     direction : {"horizontal", "vertical"}
2039         The direction along which to draw the span selector.
2040 
2041     minspan : float, default: 0
2042         If selection is less than or equal to *minspan*, the selection is
2043         removed (when already existing) or cancelled.
2044 
2045     useblit : bool, default: False
2046         If True, use the backend-dependent blitting features for faster
2047         canvas updates.
2048 
2049     props : dict, optional
2050         Dictionary of `matplotlib.patches.Patch` properties.
2051         Default:
2052 
2053             ``dict(facecolor='red', alpha=0.5)``
2054 
2055     onmove_callback : func(min, max), min/max are floats, default: None
2056         Called on mouse move while the span is being selected.
2057 
2058     span_stays : bool, default: False
2059         If True, the span stays visible after the mouse is released.
2060         Deprecated, use *interactive* instead.
2061 
2062     interactive : bool, default: False
2063         Whether to draw a set of handles that allow interaction with the
2064         widget after it is drawn.
2065 
2066     button : `.MouseButton` or list of `.MouseButton`, default: all buttons
2067         The mouse buttons which activate the span selector.
2068 
2069     handle_props : dict, default: None
2070         Properties of the handle lines at the edges of the span. Only used
2071         when *interactive* is True. See `matplotlib.lines.Line2D` for valid
2072         properties.
2073 
2074     grab_range : float, default: 10
2075         Distance in pixels within which the interactive tool handles can be
2076         activated.
2077 
2078     drag_from_anywhere : bool, default: False
2079         If `True`, the widget can be moved by clicking anywhere within
2080         its bounds.
2081 
2082     ignore_event_outside : bool, default: False
2083         If `True`, the event triggered outside the span selector will be
2084         ignored.
2085 
2086     Examples
2087     --------
2088     >>> import matplotlib.pyplot as plt
2089     >>> import matplotlib.widgets as mwidgets
2090     >>> fig, ax = plt.subplots()
2091     >>> ax.plot([1, 2, 3], [10, 50, 100])
2092     >>> def onselect(vmin, vmax):
2093     ...     print(vmin, vmax)
2094     >>> span = mwidgets.SpanSelector(ax, onselect, 'horizontal',
2095     ...                              props=dict(facecolor='blue', alpha=0.5))
2096     >>> fig.show()
2097 
2098     See also: :doc:`/gallery/widgets/span_selector`
2099     """
2100 
2101     @_api.rename_parameter("3.5", "rectprops", "props")
2102     @_api.rename_parameter("3.5", "span_stays", "interactive")
2103     def __init__(self, ax, onselect, direction, minspan=0, useblit=False,
2104                  props=None, onmove_callback=None, interactive=False,
2105                  button=None, handle_props=None, grab_range=10,
2106                  drag_from_anywhere=False, ignore_event_outside=False):
2107 
2108         super().__init__(ax, onselect, useblit=useblit, button=button)
2109 
2110         if props is None:
2111             props = dict(facecolor='red', alpha=0.5)
2112 
2113         props['animated'] = self.useblit
2114 
2115         self.direction = direction
2116 
2117         self._rect = None
2118         self.visible = True
2119         self._extents_on_press = None
2120 
2121         # self._pressv is deprecated and we don't use it internally anymore
2122         # but we maintain it until it is removed
2123         self._pressv = None
2124 
2125         self._props = props
2126         self.onmove_callback = onmove_callback
2127         self.minspan = minspan
2128 
2129         self.grab_range = grab_range
2130         self._interactive = interactive
2131         self.drag_from_anywhere = drag_from_anywhere
2132         self.ignore_event_outside = ignore_event_outside
2133 
2134         # Reset canvas so that `new_axes` connects events.
2135         self.canvas = None
2136         self.artists = []
2137         self.new_axes(ax)
2138 
2139         # Setup handles
2140         handle_props = {
2141             'color': props.get('facecolor', 'r'),
2142             **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}
2143 
2144         if self._interactive:
2145             self._edge_order = ['min', 'max']
2146             self._setup_edge_handle(handle_props)
2147 
2148         self._active_handle = None
2149 
2150         # prev attribute is deprecated but we still need to maintain it
2151         self._prev = (0, 0)
2152 
2153     rect = _api.deprecate_privatize_attribute("3.5")
2154 
2155     rectprops = _api.deprecated("3.5")(
2156         property(lambda self: self._props)
2157         )
2158 
2159     active_handle = _api.deprecate_privatize_attribute("3.5")
2160 
2161     pressv = _api.deprecate_privatize_attribute("3.5")
2162 
2163     span_stays = _api.deprecated("3.5")(
2164         property(lambda self: self._interactive)
2165         )
2166 
2167     prev = _api.deprecate_privatize_attribute("3.5")
2168 
2169     def new_axes(self, ax):
2170         """Set SpanSelector to operate on a new Axes."""
2171         self.ax = ax
2172         if self.canvas is not ax.figure.canvas:
2173             if self.canvas is not None:
2174                 self.disconnect_events()
2175 
2176             self.canvas = ax.figure.canvas
2177             self.connect_default_events()
2178 
2179         # Reset
2180         self._selection_completed = False
2181 
2182         if self.direction == 'horizontal':
2183             trans = ax.get_xaxis_transform()
2184             w, h = 0, 1
2185         else:
2186             trans = ax.get_yaxis_transform()
2187             w, h = 1, 0
2188         self._rect = Rectangle((0, 0), w, h,
2189                                transform=trans,
2190                                visible=False,
2191                                **self._props)
2192 
2193         self.ax.add_patch(self._rect)
2194         if len(self.artists) > 0:
2195             self.artists[0] = self._rect
2196         else:
2197             self.artists.append(self._rect)
2198 
2199     def _setup_edge_handle(self, props):
2200         # Define initial position using the axis bounds to keep the same bounds
2201         if self.direction == 'horizontal':
2202             positions = self.ax.get_xbound()
2203         else:
2204             positions = self.ax.get_ybound()
2205         self._edge_handles = ToolLineHandles(self.ax, positions,
2206                                              direction=self.direction,
2207                                              line_props=props,
2208                                              useblit=self.useblit)
2209         self.artists.extend([line for line in self._edge_handles.artists])
2210 
2211     def _set_cursor(self, enabled):
2212         """Update the canvas cursor based on direction of the selector."""
2213         if enabled:
2214             cursor = (backend_tools.Cursors.RESIZE_HORIZONTAL
2215                       if self.direction == 'horizontal' else
2216                       backend_tools.Cursors.RESIZE_VERTICAL)
2217         else:
2218             cursor = backend_tools.Cursors.POINTER
2219 
2220         self.ax.figure.canvas.set_cursor(cursor)
2221 
2222     def connect_default_events(self):
2223         # docstring inherited
2224         super().connect_default_events()
2225         if getattr(self, '_interactive', False):
2226             self.connect_event('motion_notify_event', self._hover)
2227 
2228     def _press(self, event):
2229         """Button press event handler."""
2230         self._set_cursor(True)
2231         if self._interactive and self._rect.get_visible():
2232             self._set_active_handle(event)
2233         else:
2234             self._active_handle = None
2235 
2236         if self._active_handle is None or not self._interactive:
2237             # Clear previous rectangle before drawing new rectangle.
2238             self.update()
2239 
2240         v = event.xdata if self.direction == 'horizontal' else event.ydata
2241         # self._pressv and self._prev are deprecated but we still need to
2242         # maintain them
2243         self._pressv = v
2244         self._prev = self._get_data(event)
2245 
2246         if self._active_handle is None and not self.ignore_event_outside:
2247             # when the press event outside the span, we initially set the
2248             # visibility to False and extents to (v, v)
2249             # update will be called when setting the extents
2250             self.visible = False
2251             self.extents = v, v
2252             # We need to set the visibility back, so the span selector will be
2253             # drawn when necessary (span width > 0)
2254             self.visible = True
2255         else:
2256             self.set_visible(True)
2257 
2258         return False
2259 
2260     @property
2261     def direction(self):
2262         """Direction of the span selector: 'vertical' or 'horizontal'."""
2263         return self._direction
2264 
2265     @direction.setter
2266     def direction(self, direction):
2267         """Set the direction of the span selector."""
2268         _api.check_in_list(['horizontal', 'vertical'], direction=direction)
2269         if hasattr(self, '_direction') and direction != self._direction:
2270             # remove previous artists
2271             self._rect.remove()
2272             if self._interactive:
2273                 self._edge_handles.remove()
2274                 for artist in self._edge_handles.artists:
2275                     self.artists.remove(artist)
2276             self._direction = direction
2277             self.new_axes(self.ax)
2278             if self._interactive:
2279                 self._setup_edge_handle(self._edge_handles._line_props)
2280         else:
2281             self._direction = direction
2282 
2283     def _release(self, event):
2284         """Button release event handler."""
2285         self._set_cursor(False)
2286         # self._pressv is deprecated but we still need to maintain it
2287         self._pressv = None
2288 
2289         if not self._interactive:
2290             self._rect.set_visible(False)
2291 
2292         if (self._active_handle is None and self._selection_completed and
2293                 self.ignore_event_outside):
2294             return
2295 
2296         vmin, vmax = self.extents
2297         span = vmax - vmin
2298 
2299         if span <= self.minspan:
2300             # Remove span and set self._selection_completed = False
2301             self.set_visible(False)
2302             if self._selection_completed:
2303                 # Call onselect, only when the span is already existing
2304                 self.onselect(vmin, vmax)
2305             self._selection_completed = False
2306         else:
2307             self.onselect(vmin, vmax)
2308             self._selection_completed = True
2309 
2310         self.update()
2311 
2312         self._active_handle = None
2313 
2314         return False
2315 
2316     def _hover(self, event):
2317         """Update the canvas cursor if it's over a handle."""
2318         if self.ignore(event):
2319             return
2320 
2321         if self._active_handle is not None:
2322             # Do nothing if button is pressed and a handle is active, which may
2323             # occur with drag_from_anywhere=True.
2324             return
2325 
2326         _, e_dist = self._edge_handles.closest(event.x, event.y)
2327         self._set_cursor(e_dist <= self.grab_range)
2328 
2329     def _onmove(self, event):
2330         """Motion notify event handler."""
2331 
2332         # self._prev are deprecated but we still need to maintain it
2333         self._prev = self._get_data(event)
2334 
2335         v = event.xdata if self.direction == 'horizontal' else event.ydata
2336         if self.direction == 'horizontal':
2337             vpress = self._eventpress.xdata
2338         else:
2339             vpress = self._eventpress.ydata
2340 
2341         # move existing span
2342         # When "dragging from anywhere", `self._active_handle` is set to 'C'
2343         # (match notation used in the RectangleSelector)
2344         if self._active_handle == 'C' and self._extents_on_press is not None:
2345             vmin, vmax = self._extents_on_press
2346             dv = v - vpress
2347             vmin += dv
2348             vmax += dv
2349 
2350         # resize an existing shape
2351         elif self._active_handle and self._active_handle != 'C':
2352             vmin, vmax = self._extents_on_press
2353             if self._active_handle == 'min':
2354                 vmin = v
2355             else:
2356                 vmax = v
2357         # new shape
2358         else:
2359             # Don't create a new span if there is already one when
2360             # ignore_event_outside=True
2361             if self.ignore_event_outside and self._selection_completed:
2362                 return
2363             vmin, vmax = vpress, v
2364             if vmin > vmax:
2365                 vmin, vmax = vmax, vmin
2366 
2367         self.extents = vmin, vmax
2368 
2369         if self.onmove_callback is not None:
2370             self.onmove_callback(vmin, vmax)
2371 
2372         return False
2373 
2374     def _draw_shape(self, vmin, vmax):
2375         if vmin > vmax:
2376             vmin, vmax = vmax, vmin
2377         if self.direction == 'horizontal':
2378             self._rect.set_x(vmin)
2379             self._rect.set_width(vmax - vmin)
2380         else:
2381             self._rect.set_y(vmin)
2382             self._rect.set_height(vmax - vmin)
2383 
2384     def _set_active_handle(self, event):
2385         """Set active handle based on the location of the mouse event."""
2386         # Note: event.xdata/ydata in data coordinates, event.x/y in pixels
2387         e_idx, e_dist = self._edge_handles.closest(event.x, event.y)
2388 
2389         # Prioritise center handle over other handles
2390         # Use 'C' to match the notation used in the RectangleSelector
2391         if 'move' in self._state:
2392             self._active_handle = 'C'
2393         elif e_dist > self.grab_range:
2394             # Not close to any handles
2395             self._active_handle = None
2396             if self.drag_from_anywhere and self._contains(event):
2397                 # Check if we've clicked inside the region
2398                 self._active_handle = 'C'
2399                 self._extents_on_press = self.extents
2400             else:
2401                 self._active_handle = None
2402                 return
2403         else:
2404             # Closest to an edge handle
2405             self._active_handle = self._edge_order[e_idx]
2406 
2407         # Save coordinates of rectangle at the start of handle movement.
2408         self._extents_on_press = self.extents
2409 
2410     def _contains(self, event):
2411         """Return True if event is within the patch."""
2412         return self._rect.contains(event, radius=0)[0]
2413 
2414     @property
2415     def extents(self):
2416         """Return extents of the span selector."""
2417         if self.direction == 'horizontal':
2418             vmin = self._rect.get_x()
2419             vmax = vmin + self._rect.get_width()
2420         else:
2421             vmin = self._rect.get_y()
2422             vmax = vmin + self._rect.get_height()
2423         return vmin, vmax
2424 
2425     @extents.setter
2426     def extents(self, extents):
2427         # Update displayed shape
2428         self._draw_shape(*extents)
2429         if self._interactive:
2430             # Update displayed handles
2431             self._edge_handles.set_data(self.extents)
2432         self.set_visible(self.visible)
2433         self.update()
2434 
2435 
2436 class ToolLineHandles:
2437     """
2438     Control handles for canvas tools.
2439 
2440     Parameters
2441     ----------
2442     ax : `matplotlib.axes.Axes`
2443         Matplotlib axes where tool handles are displayed.
2444     positions : 1D array
2445         Positions of handles in data coordinates.
2446     direction : {"horizontal", "vertical"}
2447         Direction of handles, either 'vertical' or 'horizontal'
2448     line_props : dict, optional
2449         Additional line properties. See `matplotlib.lines.Line2D`.
2450     useblit : bool, default: True
2451         Whether to use blitting for faster drawing (if supported by the
2452         backend).
2453     """
2454 
2455     def __init__(self, ax, positions, direction, line_props=None,
2456                  useblit=True):
2457         self.ax = ax
2458 
2459         _api.check_in_list(['horizontal', 'vertical'], direction=direction)
2460         self._direction = direction
2461 
2462         if line_props is None:
2463             line_props = {}
2464         line_props.update({'visible': False, 'animated': useblit})
2465 
2466         line_fun = ax.axvline if self.direction == 'horizontal' else ax.axhline
2467         self._line_props = line_props
2468 
2469         self.artists = [line_fun(p, **line_props) for p in positions]
2470 
2471     @property
2472     def positions(self):
2473         """Positions of the handle in data coordinates."""
2474         method = 'get_xdata' if self.direction == 'horizontal' else 'get_ydata'
2475         return [getattr(line, method)()[0] for line in self.artists]
2476 
2477     @property
2478     def direction(self):
2479         """Direction of the handle: 'vertical' or 'horizontal'."""
2480         return self._direction
2481 
2482     def set_data(self, positions):
2483         """
2484         Set x or y positions of handles, depending if the lines are vertical
2485         of horizontal.
2486 
2487         Parameters
2488         ----------
2489         positions : tuple of length 2
2490             Set the positions of the handle in data coordinates
2491         """
2492         method = 'set_xdata' if self.direction == 'horizontal' else 'set_ydata'
2493         for line, p in zip(self.artists, positions):
2494             getattr(line, method)([p, p])
2495 
2496     def set_visible(self, value):
2497         """Set the visibility state of the handles artist."""
2498         for artist in self.artists:
2499             artist.set_visible(value)
2500 
2501     def set_animated(self, value):
2502         """Set the animated state of the handles artist."""
2503         for artist in self.artists:
2504             artist.set_animated(value)
2505 
2506     def remove(self):
2507         """Remove the handles artist from the figure."""
2508         for artist in self.artists:
2509             artist.remove()
2510 
2511     def closest(self, x, y):
2512         """
2513         Return index and pixel distance to closest handle.
2514 
2515         Parameters
2516         ----------
2517         x, y : float
2518             x, y position from which the distance will be calculated to
2519             determinate the closest handle
2520 
2521         Returns
2522         -------
2523         index, distance : index of the handle and its distance from
2524             position x, y
2525         """
2526         if self.direction == 'horizontal':
2527             p_pts = np.array([
2528                 self.ax.transData.transform((p, 0))[0] for p in self.positions
2529                 ])
2530             dist = abs(p_pts - x)
2531         else:
2532             p_pts = np.array([
2533                 self.ax.transData.transform((0, p))[1] for p in self.positions
2534                 ])
2535             dist = abs(p_pts - y)
2536         index = np.argmin(dist)
2537         return index, dist[index]
2538 
2539 
2540 class ToolHandles:
2541     """
2542     Control handles for canvas tools.
2543 
2544     Parameters
2545     ----------
2546     ax : `matplotlib.axes.Axes`
2547         Matplotlib axes where tool handles are displayed.
2548     x, y : 1D arrays
2549         Coordinates of control handles.
2550     marker : str, default: 'o'
2551         Shape of marker used to display handle. See `matplotlib.pyplot.plot`.
2552     marker_props : dict, optional
2553         Additional marker properties. See `matplotlib.lines.Line2D`.
2554     useblit : bool, default: True
2555         Whether to use blitting for faster drawing (if supported by the
2556         backend).
2557     """
2558 
2559     def __init__(self, ax, x, y, marker='o', marker_props=None, useblit=True):
2560         self.ax = ax
2561         props = {'marker': marker, 'markersize': 7, 'markerfacecolor': 'w',
2562                  'linestyle': 'none', 'alpha': 0.5, 'visible': False,
2563                  'label': '_nolegend_',
2564                  **cbook.normalize_kwargs(marker_props, Line2D._alias_map)}
2565         self._markers = Line2D(x, y, animated=useblit, **props)
2566         self.ax.add_line(self._markers)
2567         self.artist = self._markers
2568 
2569     @property
2570     def x(self):
2571         return self._markers.get_xdata()
2572 
2573     @property
2574     def y(self):
2575         return self._markers.get_ydata()
2576 
2577     def set_data(self, pts, y=None):
2578         """Set x and y positions of handles."""
2579         if y is not None:
2580             x = pts
2581             pts = np.array([x, y])
2582         self._markers.set_data(pts)
2583 
2584     def set_visible(self, val):
2585         self._markers.set_visible(val)
2586 
2587     def set_animated(self, val):
2588         self._markers.set_animated(val)
2589 
2590     def closest(self, x, y):
2591         """Return index and pixel distance to closest index."""
2592         pts = np.column_stack([self.x, self.y])
2593         # Transform data coordinates to pixel coordinates.
2594         pts = self.ax.transData.transform(pts)
2595         diff = pts - [x, y]
2596         dist = np.hypot(*diff.T)
2597         min_index = np.argmin(dist)
2598         return min_index, dist[min_index]
2599 
2600 
2601 _RECTANGLESELECTOR_PARAMETERS_DOCSTRING = \
2602     r"""
2603     Parameters
2604     ----------
2605     ax : `~matplotlib.axes.Axes`
2606         The parent axes for the widget.
2607 
2608     onselect : function
2609         A callback function that is called after a release event and the
2610         selection is created, changed or removed.
2611         It must have the signature::
2612 
2613             def onselect(eclick: MouseEvent, erelease: MouseEvent)
2614 
2615         where *eclick* and *erelease* are the mouse click and release
2616         `.MouseEvent`\s that start and complete the selection.
2617 
2618     minspanx : float, default: 0
2619         Selections with an x-span less than or equal to *minspanx* are removed
2620         (when already existing) or cancelled.
2621 
2622     minspany : float, default: 0
2623         Selections with an y-span less than or equal to *minspanx* are removed
2624         (when already existing) or cancelled.
2625 
2626     useblit : bool, default: False
2627         Whether to use blitting for faster drawing (if supported by the
2628         backend).
2629 
2630     props : dict, optional
2631         Properties with which the __ARTIST_NAME__ is drawn. See
2632         `matplotlib.patches.Patch` for valid properties.
2633         Default:
2634 
2635         ``dict(facecolor='red', edgecolor='black', alpha=0.2, fill=True)``
2636 
2637     spancoords : {"data", "pixels"}, default: "data"
2638         Whether to interpret *minspanx* and *minspany* in data or in pixel
2639         coordinates.
2640 
2641     button : `.MouseButton`, list of `.MouseButton`, default: all buttons
2642         Button(s) that trigger rectangle selection.
2643 
2644     grab_range : float, default: 10
2645         Distance in pixels within which the interactive tool handles can be
2646         activated.
2647 
2648     handle_props : dict, optional
2649         Properties with which the interactive handles (marker artists) are
2650         drawn. See the marker arguments in `matplotlib.lines.Line2D` for valid
2651         properties.  Default values are defined in ``mpl.rcParams`` except for
2652         the default value of ``markeredgecolor`` which will be the same as the
2653         ``edgecolor`` property in *props*.
2654 
2655     interactive : bool, default: False
2656         Whether to draw a set of handles that allow interaction with the
2657         widget after it is drawn.
2658 
2659     state_modifier_keys : dict, optional
2660         Keyboard modifiers which affect the widget's behavior.  Values
2661         amend the defaults.
2662 
2663         - "move": Move the existing shape, default: no modifier.
2664         - "clear": Clear the current shape, default: "escape".
2665         - "square": Makes the shape square, default: "shift".
2666         - "center": Make the initial point the center of the shape,
2667           default: "ctrl".
2668 
2669         "square" and "center" can be combined.
2670 
2671     drag_from_anywhere : bool, default: False
2672         If `True`, the widget can be moved by clicking anywhere within
2673         its bounds.
2674 
2675     ignore_event_outside : bool, default: False
2676         If `True`, the event triggered outside the span selector will be
2677         ignored.
2678 
2679     """
2680 
2681 
2682 @docstring.Substitution(_RECTANGLESELECTOR_PARAMETERS_DOCSTRING.replace(
2683     '__ARTIST_NAME__', 'rectangle'))
2684 class RectangleSelector(_SelectorWidget):
2685     """
2686     Select a rectangular region of an axes.
2687 
2688     For the cursor to remain responsive you must keep a reference to it.
2689 
2690     Press and release events triggered at the same coordinates outside the
2691     selection will clear the selector, except when
2692     ``ignore_event_outside=True``.
2693 
2694     %s
2695 
2696     Examples
2697     --------
2698     >>> import matplotlib.pyplot as plt
2699     >>> import matplotlib.widgets as mwidgets
2700     >>> fig, ax = plt.subplots()
2701     >>> ax.plot([1, 2, 3], [10, 50, 100])
2702     >>> def onselect(eclick, erelease):
2703     ...     print(eclick.xdata, eclick.ydata)
2704     ...     print(erelease.xdata, erelease.ydata)
2705     >>> props = dict(facecolor='blue', alpha=0.5)
2706     >>> rect = mwidgets.RectangleSelector(ax, onselect, interactive=True,
2707                                           props=props)
2708     >>> fig.show()
2709 
2710     See also: :doc:`/gallery/widgets/rectangle_selector`
2711     """
2712 
2713     _shape_klass = Rectangle
2714 
2715     @_api.rename_parameter("3.5", "maxdist", "grab_range")
2716     @_api.rename_parameter("3.5", "marker_props", "handle_props")
2717     @_api.rename_parameter("3.5", "rectprops", "props")
2718     @_api.delete_parameter("3.5", "drawtype")
2719     @_api.delete_parameter("3.5", "lineprops")
2720     def __init__(self, ax, onselect, drawtype='box',
2721                  minspanx=0, minspany=0, useblit=False,
2722                  lineprops=None, props=None, spancoords='data',
2723                  button=None, grab_range=10, handle_props=None,
2724                  interactive=False, state_modifier_keys=None,
2725                  drag_from_anywhere=False, ignore_event_outside=False):
2726         super().__init__(ax, onselect, useblit=useblit, button=button,
2727                          state_modifier_keys=state_modifier_keys)
2728 
2729         self._to_draw = None
2730         self.visible = True
2731         self._interactive = interactive
2732         self.drag_from_anywhere = drag_from_anywhere
2733         self.ignore_event_outside = ignore_event_outside
2734 
2735         if drawtype == 'none':  # draw a line but make it invisible
2736             _api.warn_deprecated(
2737                 "3.5", message="Support for drawtype='none' is deprecated "
2738                                "since %(since)s and will be removed "
2739                                "%(removal)s."
2740                                "Use props=dict(visible=False) instead.")
2741             drawtype = 'line'
2742             self.visible = False
2743 
2744         if drawtype == 'box':
2745             if props is None:
2746                 props = dict(facecolor='red', edgecolor='black',
2747                              alpha=0.2, fill=True)
2748             props['animated'] = self.useblit
2749             _props = props
2750             self.visible = _props.pop('visible', self.visible)
2751             self._to_draw = self._shape_klass((0, 0), 0, 1, visible=False,
2752                                               **_props)
2753             self.ax.add_patch(self._to_draw)
2754         if drawtype == 'line':
2755             _api.warn_deprecated(
2756                 "3.5", message="Support for drawtype='line' is deprecated "
2757                                "since %(since)s and will be removed "
2758                                "%(removal)s.")
2759             if lineprops is None:
2760                 lineprops = dict(color='black', linestyle='-',
2761                                  linewidth=2, alpha=0.5)
2762             lineprops['animated'] = self.useblit
2763             self.lineprops = lineprops
2764             self._to_draw = Line2D([0, 0], [0, 0], visible=False,
2765                                    **self.lineprops)
2766             self.ax.add_line(self._to_draw)
2767 
2768         self.minspanx = minspanx
2769         self.minspany = minspany
2770 
2771         _api.check_in_list(['data', 'pixels'], spancoords=spancoords)
2772         self.spancoords = spancoords
2773         self._drawtype = drawtype
2774 
2775         self.grab_range = grab_range
2776 
2777         handle_props = {
2778             'markeredgecolor': (props or {}).get('edgecolor', 'black'),
2779             **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}
2780 
2781         self._corner_order = ['NW', 'NE', 'SE', 'SW']
2782         xc, yc = self.corners
2783         self._corner_handles = ToolHandles(self.ax, xc, yc,
2784                                            marker_props=handle_props,
2785                                            useblit=self.useblit)
2786 
2787         self._edge_order = ['W', 'N', 'E', 'S']
2788         xe, ye = self.edge_centers
2789         self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',
2790                                          marker_props=handle_props,
2791                                          useblit=self.useblit)
2792 
2793         xc, yc = self.center
2794         self._center_handle = ToolHandles(self.ax, [xc], [yc], marker='s',
2795                                           marker_props=handle_props,
2796                                           useblit=self.useblit)
2797 
2798         self._active_handle = None
2799 
2800         self.artists = [self._to_draw, self._center_handle.artist,
2801                         self._corner_handles.artist,
2802                         self._edge_handles.artist]
2803 
2804         if not self._interactive:
2805             self.artists = [self._to_draw]
2806 
2807         self._extents_on_press = None
2808 
2809     to_draw = _api.deprecate_privatize_attribute("3.5")
2810 
2811     drawtype = _api.deprecate_privatize_attribute("3.5")
2812 
2813     active_handle = _api.deprecate_privatize_attribute("3.5")
2814 
2815     interactive = _api.deprecate_privatize_attribute("3.5")
2816 
2817     maxdist = _api.deprecated("3.5", name="maxdist", alternative="grab_range")(
2818         property(lambda self: self.grab_range,
2819                  lambda self, value: setattr(self, "grab_range", value)))
2820 
2821     def _press(self, event):
2822         """Button press event handler."""
2823         # make the drawn box/line visible get the click-coordinates,
2824         # button, ...
2825         if self._interactive and self._to_draw.get_visible():
2826             self._set_active_handle(event)
2827         else:
2828             self._active_handle = None
2829 
2830         if self._active_handle is None or not self._interactive:
2831             # Clear previous rectangle before drawing new rectangle.
2832             self.update()
2833 
2834         if self._active_handle is None and not self.ignore_event_outside:
2835             x = event.xdata
2836             y = event.ydata
2837             self.visible = False
2838             self.extents = x, x, y, y
2839             self.visible = True
2840         else:
2841             self.set_visible(True)
2842 
2843         return False
2844 
2845     def _release(self, event):
2846         """Button release event handler."""
2847         if not self._interactive:
2848             self._to_draw.set_visible(False)
2849 
2850         if (self._active_handle is None and self._selection_completed and
2851                 self.ignore_event_outside):
2852             return
2853 
2854         # update the eventpress and eventrelease with the resulting extents
2855         x0, x1, y0, y1 = self.extents
2856         self._eventpress.xdata = x0
2857         self._eventpress.ydata = y0
2858         xy0 = self.ax.transData.transform([x0, y0])
2859         self._eventpress.x, self._eventpress.y = xy0
2860 
2861         self._eventrelease.xdata = x1
2862         self._eventrelease.ydata = y1
2863         xy1 = self.ax.transData.transform([x1, y1])
2864         self._eventrelease.x, self._eventrelease.y = xy1
2865 
2866         # calculate dimensions of box or line
2867         if self.spancoords == 'data':
2868             spanx = abs(self._eventpress.xdata - self._eventrelease.xdata)
2869             spany = abs(self._eventpress.ydata - self._eventrelease.ydata)
2870         elif self.spancoords == 'pixels':
2871             spanx = abs(self._eventpress.x - self._eventrelease.x)
2872             spany = abs(self._eventpress.y - self._eventrelease.y)
2873         else:
2874             _api.check_in_list(['data', 'pixels'],
2875                                spancoords=self.spancoords)
2876         # check if drawn distance (if it exists) is not too small in
2877         # either x or y-direction
2878         minspanxy = (spanx <= self.minspanx or spany <= self.minspany)
2879         if (self._drawtype != 'none' and minspanxy):
2880             for artist in self.artists:
2881                 artist.set_visible(False)
2882             if self._selection_completed:
2883                 # Call onselect, only when the selection is already existing
2884                 self.onselect(self._eventpress, self._eventrelease)
2885             self._selection_completed = False
2886         else:
2887             self.onselect(self._eventpress, self._eventrelease)
2888             self._selection_completed = True
2889 
2890         self.update()
2891         self._active_handle = None
2892 
2893         return False
2894 
2895     def _onmove(self, event):
2896         """Motion notify event handler."""
2897         # resize an existing shape
2898         if self._active_handle and self._active_handle != 'C':
2899             x0, x1, y0, y1 = self._extents_on_press
2900             if self._active_handle in ['E', 'W'] + self._corner_order:
2901                 x1 = event.xdata
2902             if self._active_handle in ['N', 'S'] + self._corner_order:
2903                 y1 = event.ydata
2904 
2905         # move existing shape
2906         elif (('move' in self._state or self._active_handle == 'C' or
2907                (self.drag_from_anywhere and self._contains(event))) and
2908               self._extents_on_press is not None):
2909             x0, x1, y0, y1 = self._extents_on_press
2910             dx = event.xdata - self._eventpress.xdata
2911             dy = event.ydata - self._eventpress.ydata
2912             x0 += dx
2913             x1 += dx
2914             y0 += dy
2915             y1 += dy
2916 
2917         # new shape
2918         else:
2919             # Don't create a new rectangle if there is already one when
2920             # ignore_event_outside=True
2921             if self.ignore_event_outside and self._selection_completed:
2922                 return
2923             center = [self._eventpress.xdata, self._eventpress.ydata]
2924             center_pix = [self._eventpress.x, self._eventpress.y]
2925             dx = (event.xdata - center[0]) / 2.
2926             dy = (event.ydata - center[1]) / 2.
2927 
2928             # square shape
2929             if 'square' in self._state:
2930                 dx_pix = abs(event.x - center_pix[0])
2931                 dy_pix = abs(event.y - center_pix[1])
2932                 if not dx_pix:
2933                     return
2934                 maxd = max(abs(dx_pix), abs(dy_pix))
2935                 if abs(dx_pix) < maxd:
2936                     dx *= maxd / (abs(dx_pix) + 1e-6)
2937                 if abs(dy_pix) < maxd:
2938                     dy *= maxd / (abs(dy_pix) + 1e-6)
2939 
2940             # from center
2941             if 'center' in self._state:
2942                 dx *= 2
2943                 dy *= 2
2944 
2945             # from corner
2946             else:
2947                 center[0] += dx
2948                 center[1] += dy
2949 
2950             x0, x1, y0, y1 = (center[0] - dx, center[0] + dx,
2951                               center[1] - dy, center[1] + dy)
2952 
2953         self.extents = x0, x1, y0, y1
2954 
2955     @property
2956     def _rect_bbox(self):
2957         if self._drawtype == 'box':
2958             x0 = self._to_draw.get_x()
2959             y0 = self._to_draw.get_y()
2960             width = self._to_draw.get_width()
2961             height = self._to_draw.get_height()
2962             return x0, y0, width, height
2963         else:
2964             x, y = self._to_draw.get_data()
2965             x0, x1 = min(x), max(x)
2966             y0, y1 = min(y), max(y)
2967             return x0, y0, x1 - x0, y1 - y0
2968 
2969     @property
2970     def corners(self):
2971         """Corners of rectangle from lower left, moving clockwise."""
2972         x0, y0, width, height = self._rect_bbox
2973         xc = x0, x0 + width, x0 + width, x0
2974         yc = y0, y0, y0 + height, y0 + height
2975         return xc, yc
2976 
2977     @property
2978     def edge_centers(self):
2979         """Midpoint of rectangle edges from left, moving anti-clockwise."""
2980         x0, y0, width, height = self._rect_bbox
2981         w = width / 2.
2982         h = height / 2.
2983         xe = x0, x0 + w, x0 + width, x0 + w
2984         ye = y0 + h, y0, y0 + h, y0 + height
2985         return xe, ye
2986 
2987     @property
2988     def center(self):
2989         """Center of rectangle."""
2990         x0, y0, width, height = self._rect_bbox
2991         return x0 + width / 2., y0 + height / 2.
2992 
2993     @property
2994     def extents(self):
2995         """Return (xmin, xmax, ymin, ymax)."""
2996         x0, y0, width, height = self._rect_bbox
2997         xmin, xmax = sorted([x0, x0 + width])
2998         ymin, ymax = sorted([y0, y0 + height])
2999         return xmin, xmax, ymin, ymax
3000 
3001     @extents.setter
3002     def extents(self, extents):
3003         # Update displayed shape
3004         self._draw_shape(extents)
3005         # Update displayed handles
3006         self._corner_handles.set_data(*self.corners)
3007         self._edge_handles.set_data(*self.edge_centers)
3008         self._center_handle.set_data(*self.center)
3009         self.set_visible(self.visible)
3010         self.update()
3011 
3012     draw_shape = _api.deprecate_privatize_attribute('3.5')
3013 
3014     def _draw_shape(self, extents):
3015         x0, x1, y0, y1 = extents
3016         xmin, xmax = sorted([x0, x1])
3017         ymin, ymax = sorted([y0, y1])
3018         xlim = sorted(self.ax.get_xlim())
3019         ylim = sorted(self.ax.get_ylim())
3020 
3021         xmin = max(xlim[0], xmin)
3022         ymin = max(ylim[0], ymin)
3023         xmax = min(xmax, xlim[1])
3024         ymax = min(ymax, ylim[1])
3025 
3026         if self._drawtype == 'box':
3027             self._to_draw.set_x(xmin)
3028             self._to_draw.set_y(ymin)
3029             self._to_draw.set_width(xmax - xmin)
3030             self._to_draw.set_height(ymax - ymin)
3031 
3032         elif self._drawtype == 'line':
3033             self._to_draw.set_data([xmin, xmax], [ymin, ymax])
3034 
3035     def _set_active_handle(self, event):
3036         """Set active handle based on the location of the mouse event."""
3037         # Note: event.xdata/ydata in data coordinates, event.x/y in pixels
3038         c_idx, c_dist = self._corner_handles.closest(event.x, event.y)
3039         e_idx, e_dist = self._edge_handles.closest(event.x, event.y)
3040         m_idx, m_dist = self._center_handle.closest(event.x, event.y)
3041 
3042         if 'move' in self._state:
3043             self._active_handle = 'C'
3044             self._extents_on_press = self.extents
3045         # Set active handle as closest handle, if mouse click is close enough.
3046         elif m_dist < self.grab_range * 2:
3047             # Prioritise center handle over other handles
3048             self._active_handle = 'C'
3049         elif (c_dist > self.grab_range and
3050                   e_dist > self.grab_range):
3051             # Not close to any handles
3052             if self.drag_from_anywhere and self._contains(event):
3053                 # Check if we've clicked inside the region
3054                 self._active_handle = 'C'
3055                 self._extents_on_press = self.extents
3056             else:
3057                 self._active_handle = None
3058                 return
3059         elif c_dist < e_dist:
3060             # Closest to a corner handle
3061             self._active_handle = self._corner_order[c_idx]
3062         else:
3063             # Closest to an edge handle
3064             self._active_handle = self._edge_order[e_idx]
3065 
3066         # Save coordinates of rectangle at the start of handle movement.
3067         x0, x1, y0, y1 = self.extents
3068         # Switch variables so that only x1 and/or y1 are updated on move.
3069         if self._active_handle in ['W', 'SW', 'NW']:
3070             x0, x1 = x1, event.xdata
3071         if self._active_handle in ['N', 'NW', 'NE']:
3072             y0, y1 = y1, event.ydata
3073         self._extents_on_press = x0, x1, y0, y1
3074 
3075     def _contains(self, event):
3076         """Return True if event is within the patch."""
3077         return self._to_draw.contains(event, radius=0)[0]
3078 
3079     @property
3080     def geometry(self):
3081         """
3082         Return an array of shape (2, 5) containing the
3083         x (``RectangleSelector.geometry[1, :]``) and
3084         y (``RectangleSelector.geometry[0, :]``) coordinates
3085         of the four corners of the rectangle starting and ending
3086         in the top left corner.
3087         """
3088         if hasattr(self._to_draw, 'get_verts'):
3089             xfm = self.ax.transData.inverted()
3090             y, x = xfm.transform(self._to_draw.get_verts()).T
3091             return np.array([x, y])
3092         else:
3093             return np.array(self._to_draw.get_data())
3094 
3095 
3096 @docstring.Substitution(_RECTANGLESELECTOR_PARAMETERS_DOCSTRING.replace(
3097     '__ARTIST_NAME__', 'ellipse'))
3098 class EllipseSelector(RectangleSelector):
3099     """
3100     Select an elliptical region of an axes.
3101 
3102     For the cursor to remain responsive you must keep a reference to it.
3103 
3104     Press and release events triggered at the same coordinates outside the
3105     selection will clear the selector, except when
3106     ``ignore_event_outside=True``.
3107 
3108     %s
3109 
3110     Examples
3111     --------
3112     :doc:`/gallery/widgets/rectangle_selector`
3113     """
3114 
3115     _shape_klass = Ellipse
3116     draw_shape = _api.deprecate_privatize_attribute('3.5')
3117 
3118     def _draw_shape(self, extents):
3119         x0, x1, y0, y1 = extents
3120         xmin, xmax = sorted([x0, x1])
3121         ymin, ymax = sorted([y0, y1])
3122         center = [x0 + (x1 - x0) / 2., y0 + (y1 - y0) / 2.]
3123         a = (xmax - xmin) / 2.
3124         b = (ymax - ymin) / 2.
3125 
3126         if self._drawtype == 'box':
3127             self._to_draw.center = center
3128             self._to_draw.width = 2 * a
3129             self._to_draw.height = 2 * b
3130         else:
3131             rad = np.deg2rad(np.arange(31) * 12)
3132             x = a * np.cos(rad) + center[0]
3133             y = b * np.sin(rad) + center[1]
3134             self._to_draw.set_data(x, y)
3135 
3136     @property
3137     def _rect_bbox(self):
3138         if self._drawtype == 'box':
3139             x, y = self._to_draw.center
3140             width = self._to_draw.width
3141             height = self._to_draw.height
3142             return x - width / 2., y - height / 2., width, height
3143         else:
3144             x, y = self._to_draw.get_data()
3145             x0, x1 = min(x), max(x)
3146             y0, y1 = min(y), max(y)
3147             return x0, y0, x1 - x0, y1 - y0
3148 
3149 
3150 class LassoSelector(_SelectorWidget):
3151     """
3152     Selection curve of an arbitrary shape.
3153 
3154     For the selector to remain responsive you must keep a reference to it.
3155 
3156     The selected path can be used in conjunction with `~.Path.contains_point`
3157     to select data points from an image.
3158 
3159     In contrast to `Lasso`, `LassoSelector` is written with an interface
3160     similar to `RectangleSelector` and `SpanSelector`, and will continue to
3161     interact with the axes until disconnected.
3162 
3163     Example usage::
3164 
3165         ax = plt.subplot()
3166         ax.plot(x, y)
3167 
3168         def onselect(verts):
3169             print(verts)
3170         lasso = LassoSelector(ax, onselect)
3171 
3172     Parameters
3173     ----------
3174     ax : `~matplotlib.axes.Axes`
3175         The parent axes for the widget.
3176     onselect : function
3177         Whenever the lasso is released, the *onselect* function is called and
3178         passed the vertices of the selected path.
3179     useblit : bool, default: True
3180         Whether to use blitting for faster drawing (if supported by the
3181         backend).
3182     props : dict, optional
3183         Properties with which the line is drawn, see `matplotlib.lines.Line2D`
3184         for valid properties. Default values are defined in ``mpl.rcParams``.
3185     button : `.MouseButton` or list of `.MouseButton`, optional
3186         The mouse buttons used for rectangle selection.  Default is ``None``,
3187         which corresponds to all buttons.
3188     """
3189 
3190     @_api.rename_parameter("3.5", "lineprops", "props")
3191     def __init__(self, ax, onselect=None, useblit=True, props=None,
3192                  button=None):
3193         super().__init__(ax, onselect, useblit=useblit, button=button)
3194         self.verts = None
3195         if props is None:
3196             props = dict()
3197         # self.useblit may be != useblit, if the canvas doesn't support blit.
3198         props.update(animated=self.useblit, visible=False)
3199         self.line = Line2D([], [], **props)
3200         self.ax.add_line(self.line)
3201         self.artists = [self.line]
3202 
3203     @_api.deprecated("3.5", alternative="press")
3204     def onpress(self, event):
3205         self.press(event)
3206 
3207     def _press(self, event):
3208         self.verts = [self._get_data(event)]
3209         self.line.set_visible(True)
3210 
3211     @_api.deprecated("3.5", alternative="release")
3212     def onrelease(self, event):
3213         self.release(event)
3214 
3215     def _release(self, event):
3216         if self.verts is not None:
3217             self.verts.append(self._get_data(event))
3218             self.onselect(self.verts)
3219         self.line.set_data([[], []])
3220         self.line.set_visible(False)
3221         self.verts = None
3222 
3223     def _onmove(self, event):
3224         if self.verts is None:
3225             return
3226         self.verts.append(self._get_data(event))
3227         self.line.set_data(list(zip(*self.verts)))
3228         self.update()
3229 
3230 
3231 class PolygonSelector(_SelectorWidget):
3232     """
3233     Select a polygon region of an axes.
3234 
3235     Place vertices with each mouse click, and make the selection by completing
3236     the polygon (clicking on the first vertex). Once drawn individual vertices
3237     can be moved by clicking and dragging with the left mouse button, or
3238     removed by clicking the right mouse button.
3239 
3240     In addition, the following modifier keys can be used:
3241 
3242     - Hold *ctrl* and click and drag a vertex to reposition it before the
3243       polygon has been completed.
3244     - Hold the *shift* key and click and drag anywhere in the axes to move
3245       all vertices.
3246     - Press the *esc* key to start a new polygon.
3247 
3248     For the selector to remain responsive you must keep a reference to it.
3249 
3250     Parameters
3251     ----------
3252     ax : `~matplotlib.axes.Axes`
3253         The parent axes for the widget.
3254 
3255     onselect : function
3256         When a polygon is completed or modified after completion,
3257         the *onselect* function is called and passed a list of the vertices as
3258         ``(xdata, ydata)`` tuples.
3259 
3260     useblit : bool, default: False
3261         Whether to use blitting for faster drawing (if supported by the
3262         backend).
3263 
3264     props : dict, optional
3265         Properties with which the line is drawn, see `matplotlib.lines.Line2D`
3266         for valid properties.
3267         Default:
3268 
3269             ``dict(color='k', linestyle='-', linewidth=2, alpha=0.5)``
3270 
3271     handle_props : dict, optional
3272         Artist properties for the markers drawn at the vertices of the polygon.
3273         See the marker arguments in `matplotlib.lines.Line2D` for valid
3274         properties.  Default values are defined in ``mpl.rcParams`` except for
3275         the default value of ``markeredgecolor`` which will be the same as the
3276         ``color`` property in *props*.
3277 
3278     grab_range : float, default: 10
3279         A vertex is selected (to complete the polygon or to move a vertex) if
3280         the mouse click is within *grab_range* pixels of the vertex.
3281 
3282     Examples
3283     --------
3284     :doc:`/gallery/widgets/polygon_selector_demo`
3285 
3286     Notes
3287     -----
3288     If only one point remains after removing points, the selector reverts to an
3289     incomplete state and you can start drawing a new polygon from the existing
3290     point.
3291     """
3292 
3293     @_api.rename_parameter("3.5", "lineprops", "props")
3294     @_api.rename_parameter("3.5", "markerprops", "handle_props")
3295     @_api.rename_parameter("3.5", "vertex_select_radius", "grab_range")
3296     def __init__(self, ax, onselect, useblit=False,
3297                  props=None, handle_props=None, grab_range=10):
3298         # The state modifiers 'move', 'square', and 'center' are expected by
3299         # _SelectorWidget but are not supported by PolygonSelector
3300         # Note: could not use the existing 'move' state modifier in-place of
3301         # 'move_all' because _SelectorWidget automatically discards 'move'
3302         # from the state on button release.
3303         state_modifier_keys = dict(clear='escape', move_vertex='control',
3304                                    move_all='shift', move='not-applicable',
3305                                    square='not-applicable',
3306                                    center='not-applicable')
3307         super().__init__(ax, onselect, useblit=useblit,
3308                          state_modifier_keys=state_modifier_keys)
3309 
3310         self._xs, self._ys = [0], [0]
3311 
3312         if props is None:
3313             props = dict(color='k', linestyle='-', linewidth=2, alpha=0.5)
3314         props['animated'] = self.useblit
3315         self.line = Line2D(self._xs, self._ys, **props)
3316         self.ax.add_line(self.line)
3317 
3318         if handle_props is None:
3319             handle_props = dict(markeredgecolor='k',
3320                                 markerfacecolor=props.get('color', 'k'))
3321         self._polygon_handles = ToolHandles(self.ax, self._xs, self._ys,
3322                                             useblit=self.useblit,
3323                                             marker_props=handle_props)
3324 
3325         self._active_handle_idx = -1
3326         self.grab_range = grab_range
3327 
3328         self.artists = [self.line, self._polygon_handles.artist]
3329         self.set_visible(True)
3330 
3331     vertex_select_radius = _api.deprecated("3.5", name="vertex_select_radius",
3332                                            alternative="grab_range")(
3333         property(lambda self: self.grab_range,
3334                  lambda self, value: setattr(self, "grab_range", value))
3335         )
3336 
3337     @property
3338     def _nverts(self):
3339         return len(self._xs)
3340 
3341     def _remove_vertex(self, i):
3342         """Remove vertex with index i."""
3343         if (self._nverts > 2 and
3344                 self._selection_completed and
3345                 i in (0, self._nverts - 1)):
3346             # If selecting the first or final vertex, remove both first and
3347             # last vertex as they are the same for a closed polygon
3348             self._xs.pop(0)
3349             self._ys.pop(0)
3350             self._xs.pop(-1)
3351             self._ys.pop(-1)
3352             # Close the polygon again by appending the new first vertex to the
3353             # end
3354             self._xs.append(self._xs[0])
3355             self._ys.append(self._ys[0])
3356         else:
3357             self._xs.pop(i)
3358             self._ys.pop(i)
3359         if self._nverts <= 2:
3360             # If only one point left, return to incomplete state to let user
3361             # start drawing again
3362             self._selection_completed = False
3363 
3364     def _press(self, event):
3365         """Button press event handler."""
3366         # Check for selection of a tool handle.
3367         if ((self._selection_completed or 'move_vertex' in self._state)
3368                 and len(self._xs) > 0):
3369             h_idx, h_dist = self._polygon_handles.closest(event.x, event.y)
3370             if h_dist < self.grab_range:
3371                 self._active_handle_idx = h_idx
3372         # Save the vertex positions at the time of the press event (needed to
3373         # support the 'move_all' state modifier).
3374         self._xs_at_press, self._ys_at_press = self._xs.copy(), self._ys.copy()
3375 
3376     def _release(self, event):
3377         """Button release event handler."""
3378         # Release active tool handle.
3379         if self._active_handle_idx >= 0:
3380             if event.button == 3:
3381                 self._remove_vertex(self._active_handle_idx)
3382                 self._draw_polygon()
3383             self._active_handle_idx = -1
3384 
3385         # Complete the polygon.
3386         elif (len(self._xs) > 3
3387               and self._xs[-1] == self._xs[0]
3388               and self._ys[-1] == self._ys[0]):
3389             self._selection_completed = True
3390 
3391         # Place new vertex.
3392         elif (not self._selection_completed
3393               and 'move_all' not in self._state
3394               and 'move_vertex' not in self._state):
3395             self._xs.insert(-1, event.xdata)
3396             self._ys.insert(-1, event.ydata)
3397 
3398         if self._selection_completed:
3399             self.onselect(self.verts)
3400 
3401     def onmove(self, event):
3402         """Cursor move event handler and validator."""
3403         # Method overrides _SelectorWidget.onmove because the polygon selector
3404         # needs to process the move callback even if there is no button press.
3405         # _SelectorWidget.onmove include logic to ignore move event if
3406         # _eventpress is None.
3407         if not self.ignore(event):
3408             event = self._clean_event(event)
3409             self._onmove(event)
3410             return True
3411         return False
3412 
3413     def _onmove(self, event):
3414         """Cursor move event handler."""
3415         # Move the active vertex (ToolHandle).
3416         if self._active_handle_idx >= 0:
3417             idx = self._active_handle_idx
3418             self._xs[idx], self._ys[idx] = event.xdata, event.ydata
3419             # Also update the end of the polygon line if the first vertex is
3420             # the active handle and the polygon is completed.
3421             if idx == 0 and self._selection_completed:
3422                 self._xs[-1], self._ys[-1] = event.xdata, event.ydata
3423 
3424         # Move all vertices.
3425         elif 'move_all' in self._state and self._eventpress:
3426             dx = event.xdata - self._eventpress.xdata
3427             dy = event.ydata - self._eventpress.ydata
3428             for k in range(len(self._xs)):
3429                 self._xs[k] = self._xs_at_press[k] + dx
3430                 self._ys[k] = self._ys_at_press[k] + dy
3431 
3432         # Do nothing if completed or waiting for a move.
3433         elif (self._selection_completed
3434               or 'move_vertex' in self._state or 'move_all' in self._state):
3435             return
3436 
3437         # Position pending vertex.
3438         else:
3439             # Calculate distance to the start vertex.
3440             x0, y0 = self.line.get_transform().transform((self._xs[0],
3441                                                           self._ys[0]))
3442             v0_dist = np.hypot(x0 - event.x, y0 - event.y)
3443             # Lock on to the start vertex if near it and ready to complete.
3444             if len(self._xs) > 3 and v0_dist < self.grab_range:
3445                 self._xs[-1], self._ys[-1] = self._xs[0], self._ys[0]
3446             else:
3447                 self._xs[-1], self._ys[-1] = event.xdata, event.ydata
3448 
3449         self._draw_polygon()
3450 
3451     def _on_key_press(self, event):
3452         """Key press event handler."""
3453         # Remove the pending vertex if entering the 'move_vertex' or
3454         # 'move_all' mode
3455         if (not self._selection_completed
3456                 and ('move_vertex' in self._state or
3457                      'move_all' in self._state)):
3458             self._xs, self._ys = self._xs[:-1], self._ys[:-1]
3459             self._draw_polygon()
3460 
3461     def _on_key_release(self, event):
3462         """Key release event handler."""
3463         # Add back the pending vertex if leaving the 'move_vertex' or
3464         # 'move_all' mode (by checking the released key)
3465         if (not self._selection_completed
3466                 and
3467                 (event.key == self.state_modifier_keys.get('move_vertex')
3468                  or event.key == self.state_modifier_keys.get('move_all'))):
3469             self._xs.append(event.xdata)
3470             self._ys.append(event.ydata)
3471             self._draw_polygon()
3472         # Reset the polygon if the released key is the 'clear' key.
3473         elif event.key == self.state_modifier_keys.get('clear'):
3474             event = self._clean_event(event)
3475             self._xs, self._ys = [event.xdata], [event.ydata]
3476             self._selection_completed = False
3477             self.set_visible(True)
3478 
3479     def _draw_polygon(self):
3480         """Redraw the polygon based on the new vertex positions."""
3481         self.line.set_data(self._xs, self._ys)
3482         # Only show one tool handle at the start and end vertex of the polygon
3483         # if the polygon is completed or the user is locked on to the start
3484         # vertex.
3485         if (self._selection_completed
3486                 or (len(self._xs) > 3
3487                     and self._xs[-1] == self._xs[0]
3488                     and self._ys[-1] == self._ys[0])):
3489             self._polygon_handles.set_data(self._xs[:-1], self._ys[:-1])
3490         else:
3491             self._polygon_handles.set_data(self._xs, self._ys)
3492         self.update()
3493 
3494     @property
3495     def verts(self):
3496         """The polygon vertices, as a list of ``(x, y)`` pairs."""
3497         return list(zip(self._xs[:-1], self._ys[:-1]))
3498 
3499 
3500 class Lasso(AxesWidget):
3501     """
3502     Selection curve of an arbitrary shape.
3503 
3504     The selected path can be used in conjunction with
3505     `~matplotlib.path.Path.contains_point` to select data points from an image.
3506 
3507     Unlike `LassoSelector`, this must be initialized with a starting
3508     point *xy*, and the `Lasso` events are destroyed upon release.
3509 
3510     Parameters
3511     ----------
3512     ax : `~matplotlib.axes.Axes`
3513         The parent axes for the widget.
3514     xy : (float, float)
3515         Coordinates of the start of the lasso.
3516     useblit : bool, default: True
3517         Whether to use blitting for faster drawing (if supported by the
3518         backend).
3519     callback : callable
3520         Whenever the lasso is released, the *callback* function is called and
3521         passed the vertices of the selected path.
3522     """
3523 
3524     def __init__(self, ax, xy, callback=None, useblit=True):
3525         super().__init__(ax)
3526 
3527         self.useblit = useblit and self.canvas.supports_blit
3528         if self.useblit:
3529             self.background = self.canvas.copy_from_bbox(self.ax.bbox)
3530 
3531         x, y = xy
3532         self.verts = [(x, y)]
3533         self.line = Line2D([x], [y], linestyle='-', color='black', lw=2)
3534         self.ax.add_line(self.line)
3535         self.callback = callback
3536         self.connect_event('button_release_event', self.onrelease)
3537         self.connect_event('motion_notify_event', self.onmove)
3538 
3539     def onrelease(self, event):
3540         if self.ignore(event):
3541             return
3542         if self.verts is not None:
3543             self.verts.append((event.xdata, event.ydata))
3544             if len(self.verts) > 2:
3545                 self.callback(self.verts)
3546             self.ax.lines.remove(self.line)
3547         self.verts = None
3548         self.disconnect_events()
3549 
3550     def onmove(self, event):
3551         if self.ignore(event):
3552             return
3553         if self.verts is None:
3554             return
3555         if event.inaxes != self.ax:
3556             return
3557         if event.button != 1:
3558             return
3559         self.verts.append((event.xdata, event.ydata))
3560 
3561         self.line.set_data(list(zip(*self.verts)))
3562 
3563         if self.useblit:
3564             self.canvas.restore_region(self.background)
3565             self.ax.draw_artist(self.line)
3566             self.canvas.blit(self.ax.bbox)
3567         else:
3568             self.canvas.draw_idle()

</code><intended_behavior>Create or update methods within the selector's class to manage color and other properties without directly accessing low-level attributes like `rect`. Implement a mechanism, possibly leveraging `handle_props` or similar, that allows for a clean, maintainable way to update visual properties. This approach should respect the encapsulation of the selector's properties and provide a clear migration path from deprecated methods.</intended_behavior>]
2025-10-17 14:16:25.439 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/widgets.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 GUI neutral widgets
3 ===================
4 
5 Widgets that are designed to work for any of the GUI backends.
6 All of these widgets require you to predefine a `matplotlib.axes.Axes`
7 instance and pass that as the first parameter.  Matplotlib doesn't try to
8 be too smart with respect to layout -- you will have to figure out how
9 wide and tall you want your Axes to be to accommodate your widget.
10 """
11 
12 from contextlib import ExitStack
13 import copy
14 from numbers import Integral, Number
15 
16 import numpy as np
17 
18 import matplotlib as mpl
19 from matplotlib import docstring
20 from . import _api, backend_tools, cbook, colors, ticker
21 from .lines import Line2D
22 from .patches import Circle, Rectangle, Ellipse
23 
24 
25 class LockDraw:
26     """
27     Some widgets, like the cursor, draw onto the canvas, and this is not
28     desirable under all circumstances, like when the toolbar is in zoom-to-rect
29     mode and drawing a rectangle.  To avoid this, a widget can acquire a
30     canvas' lock with ``canvas.widgetlock(widget)`` before drawing on the
31     canvas; this will prevent other widgets from doing so at the same time (if
32     they also try to acquire the lock first).
33     """
34 
35     def __init__(self):
36         self._owner = None
37 
38     def __call__(self, o):
39         """Reserve the lock for *o*."""
40         if not self.available(o):
41             raise ValueError('already locked')
42         self._owner = o
43 
44     def release(self, o):
45         """Release the lock from *o*."""
46         if not self.available(o):
47             raise ValueError('you do not own this lock')
48         self._owner = None
49 
50     def available(self, o):
51         """Return whether drawing is available to *o*."""
52         return not self.locked() or self.isowner(o)
53 
54     def isowner(self, o):
55         """Return whether *o* owns this lock."""
56         return self._owner is o
57 
58     def locked(self):
59         """Return whether the lock is currently held by an owner."""
60         return self._owner is not None
61 
62 
63 class Widget:
64     """
65     Abstract base class for GUI neutral widgets.
66     """
67     drawon = True
68     eventson = True
69     _active = True
70 
71     def set_active(self, active):
72         """Set whether the widget is active."""
73         self._active = active
74 
75     def get_active(self):
76         """Get whether the widget is active."""
77         return self._active
78 
79     # set_active is overridden by SelectorWidgets.
80     active = property(get_active, set_active, doc="Is the widget active?")
81 
82     def ignore(self, event):
83         """
84         Return whether *event* should be ignored.
85 
86         This method should be called at the beginning of any event callback.
87         """
88         return not self.active
89 
90 
91 class AxesWidget(Widget):
92     """
93     Widget connected to a single `~matplotlib.axes.Axes`.
94 
95     To guarantee that the widget remains responsive and not garbage-collected,
96     a reference to the object should be maintained by the user.
97 
98     This is necessary because the callback registry
99     maintains only weak-refs to the functions, which are member
100     functions of the widget.  If there are no references to the widget
101     object it may be garbage collected which will disconnect the callbacks.
102 
103     Attributes
104     ----------
105     ax : `~matplotlib.axes.Axes`
106         The parent axes for the widget.
107     canvas : `~matplotlib.backend_bases.FigureCanvasBase`
108         The parent figure canvas for the widget.
109     active : bool
110         If False, the widget does not respond to events.
111     """
112 
113     cids = _api.deprecated("3.4")(property(lambda self: self._cids))
114 
115     def __init__(self, ax):
116         self.ax = ax
117         self.canvas = ax.figure.canvas
118         self._cids = []
119 
120     def connect_event(self, event, callback):
121         """
122         Connect a callback function with an event.
123 
124         This should be used in lieu of ``figure.canvas.mpl_connect`` since this
125         function stores callback ids for later clean up.
126         """
127         cid = self.canvas.mpl_connect(event, callback)
128         self._cids.append(cid)
129 
130     def disconnect_events(self):
131         """Disconnect all events created by this widget."""
132         for c in self._cids:
133             self.canvas.mpl_disconnect(c)
134 
135 
136 class Button(AxesWidget):
137     """
138     A GUI neutral button.
139 
140     For the button to remain responsive you must keep a reference to it.
141     Call `.on_clicked` to connect to the button.
142 
143     Attributes
144     ----------
145     ax
146         The `matplotlib.axes.Axes` the button renders into.
147     label
148         A `matplotlib.text.Text` instance.
149     color
150         The color of the button when not hovering.
151     hovercolor
152         The color of the button when hovering.
153     """
154 
155     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
156         lambda self: len(self._observers.callbacks['clicked'])))
157     observers = _api.deprecated("3.4")(property(
158         lambda self: self._observers.callbacks['clicked']))
159 
160     def __init__(self, ax, label, image=None,
161                  color='0.85', hovercolor='0.95'):
162         """
163         Parameters
164         ----------
165         ax : `~matplotlib.axes.Axes`
166             The `~.axes.Axes` instance the button will be placed into.
167         label : str
168             The button text.
169         image : array-like or PIL Image
170             The image to place in the button, if not *None*.  The parameter is
171             directly forwarded to `~matplotlib.axes.Axes.imshow`.
172         color : color
173             The color of the button when not activated.
174         hovercolor : color
175             The color of the button when the mouse is over it.
176         """
177         super().__init__(ax)
178 
179         if image is not None:
180             ax.imshow(image)
181         self.label = ax.text(0.5, 0.5, label,
182                              verticalalignment='center',
183                              horizontalalignment='center',
184                              transform=ax.transAxes)
185 
186         self._observers = cbook.CallbackRegistry()
187 
188         self.connect_event('button_press_event', self._click)
189         self.connect_event('button_release_event', self._release)
190         self.connect_event('motion_notify_event', self._motion)
191         ax.set_navigate(False)
192         ax.set_facecolor(color)
193         ax.set_xticks([])
194         ax.set_yticks([])
195         self.color = color
196         self.hovercolor = hovercolor
197 
198     def _click(self, event):
199         if self.ignore(event) or event.inaxes != self.ax or not self.eventson:
200             return
201         if event.canvas.mouse_grabber != self.ax:
202             event.canvas.grab_mouse(self.ax)
203 
204     def _release(self, event):
205         if self.ignore(event) or event.canvas.mouse_grabber != self.ax:
206             return
207         event.canvas.release_mouse(self.ax)
208         if self.eventson and event.inaxes == self.ax:
209             self._observers.process('clicked', event)
210 
211     def _motion(self, event):
212         if self.ignore(event):
213             return
214         c = self.hovercolor if event.inaxes == self.ax else self.color
215         if not colors.same_color(c, self.ax.get_facecolor()):
216             self.ax.set_facecolor(c)
217             if self.drawon:
218                 self.ax.figure.canvas.draw()
219 
220     def on_clicked(self, func):
221         """
222         Connect the callback function *func* to button click events.
223 
224         Returns a connection id, which can be used to disconnect the callback.
225         """
226         return self._observers.connect('clicked', lambda event: func(event))
227 
228     def disconnect(self, cid):
229         """Remove the callback function with connection id *cid*."""
230         self._observers.disconnect(cid)
231 
232 
233 class SliderBase(AxesWidget):
234     """
235     The base class for constructing Slider widgets. Not intended for direct
236     usage.
237 
238     For the slider to remain responsive you must maintain a reference to it.
239     """
240     def __init__(self, ax, orientation, closedmin, closedmax,
241                  valmin, valmax, valfmt, dragging, valstep):
242         if ax.name == '3d':
243             raise ValueError('Sliders cannot be added to 3D Axes')
244 
245         super().__init__(ax)
246         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
247 
248         self.orientation = orientation
249         self.closedmin = closedmin
250         self.closedmax = closedmax
251         self.valmin = valmin
252         self.valmax = valmax
253         self.valstep = valstep
254         self.drag_active = False
255         self.valfmt = valfmt
256 
257         if orientation == "vertical":
258             ax.set_ylim((valmin, valmax))
259             axis = ax.yaxis
260         else:
261             ax.set_xlim((valmin, valmax))
262             axis = ax.xaxis
263 
264         self._fmt = axis.get_major_formatter()
265         if not isinstance(self._fmt, ticker.ScalarFormatter):
266             self._fmt = ticker.ScalarFormatter()
267             self._fmt.set_axis(axis)
268         self._fmt.set_useOffset(False)  # No additive offset.
269         self._fmt.set_useMathText(True)  # x sign before multiplicative offset.
270 
271         ax.set_axis_off()
272         ax.set_navigate(False)
273 
274         self.connect_event("button_press_event", self._update)
275         self.connect_event("button_release_event", self._update)
276         if dragging:
277             self.connect_event("motion_notify_event", self._update)
278         self._observers = cbook.CallbackRegistry()
279 
280     def _stepped_value(self, val):
281         """Return *val* coerced to closest number in the ``valstep`` grid."""
282         if isinstance(self.valstep, Number):
283             val = (self.valmin
284                    + round((val - self.valmin) / self.valstep) * self.valstep)
285         elif self.valstep is not None:
286             valstep = np.asanyarray(self.valstep)
287             if valstep.ndim != 1:
288                 raise ValueError(
289                     f"valstep must have 1 dimension but has {valstep.ndim}"
290                 )
291             val = valstep[np.argmin(np.abs(valstep - val))]
292         return val
293 
294     def disconnect(self, cid):
295         """
296         Remove the observer with connection id *cid*.
297 
298         Parameters
299         ----------
300         cid : int
301             Connection id of the observer to be removed.
302         """
303         self._observers.disconnect(cid)
304 
305     def reset(self):
306         """Reset the slider to the initial value."""
307         if self.val != self.valinit:
308             self.set_val(self.valinit)
309 
310 
311 class Slider(SliderBase):
312     """
313     A slider representing a floating point range.
314 
315     Create a slider from *valmin* to *valmax* in axes *ax*. For the slider to
316     remain responsive you must maintain a reference to it. Call
317     :meth:`on_changed` to connect to the slider event.
318 
319     Attributes
320     ----------
321     val : float
322         Slider value.
323     """
324 
325     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
326         lambda self: len(self._observers.callbacks['changed'])))
327     observers = _api.deprecated("3.4")(property(
328         lambda self: self._observers.callbacks['changed']))
329 
330     def __init__(self, ax, label, valmin, valmax, valinit=0.5, valfmt=None,
331                  closedmin=True, closedmax=True, slidermin=None,
332                  slidermax=None, dragging=True, valstep=None,
333                  orientation='horizontal', *, initcolor='r',
334                  track_color='lightgrey', handle_style=None, **kwargs):
335         """
336         Parameters
337         ----------
338         ax : Axes
339             The Axes to put the slider in.
340 
341         label : str
342             Slider label.
343 
344         valmin : float
345             The minimum value of the slider.
346 
347         valmax : float
348             The maximum value of the slider.
349 
350         valinit : float, default: 0.5
351             The slider initial position.
352 
353         valfmt : str, default: None
354             %-format string used to format the slider value.  If None, a
355             `.ScalarFormatter` is used instead.
356 
357         closedmin : bool, default: True
358             Whether the slider interval is closed on the bottom.
359 
360         closedmax : bool, default: True
361             Whether the slider interval is closed on the top.
362 
363         slidermin : Slider, default: None
364             Do not allow the current slider to have a value less than
365             the value of the Slider *slidermin*.
366 
367         slidermax : Slider, default: None
368             Do not allow the current slider to have a value greater than
369             the value of the Slider *slidermax*.
370 
371         dragging : bool, default: True
372             If True the slider can be dragged by the mouse.
373 
374         valstep : float or array-like, default: None
375             If a float, the slider will snap to multiples of *valstep*.
376             If an array the slider will snap to the values in the array.
377 
378         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
379             The orientation of the slider.
380 
381         initcolor : color, default: 'r'
382             The color of the line at the *valinit* position. Set to ``'none'``
383             for no line.
384 
385         track_color : color, default: 'lightgrey'
386             The color of the background track. The track is accessible for
387             further styling via the *track* attribute.
388 
389         handle_style : dict
390             Properties of the slider handle. Default values are
391 
392             ========= ===== ======= ========================================
393             Key       Value Default Description
394             ========= ===== ======= ========================================
395             facecolor color 'white' The facecolor of the slider handle.
396             edgecolor color '.75'   The edgecolor of the slider handle.
397             size      int   10      The size of the slider handle in points.
398             ========= ===== ======= ========================================
399 
400             Other values will be transformed as marker{foo} and passed to the
401             `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will
402             result in ``markerstyle = 'x'``.
403 
404         Notes
405         -----
406         Additional kwargs are passed on to ``self.poly`` which is the
407         `~matplotlib.patches.Polygon` that draws the slider knob.  See the
408         `.Polygon` documentation for valid property names (``facecolor``,
409         ``edgecolor``, ``alpha``, etc.).
410         """
411         super().__init__(ax, orientation, closedmin, closedmax,
412                          valmin, valmax, valfmt, dragging, valstep)
413 
414         if slidermin is not None and not hasattr(slidermin, 'val'):
415             raise ValueError(
416                 f"Argument slidermin ({type(slidermin)}) has no 'val'")
417         if slidermax is not None and not hasattr(slidermax, 'val'):
418             raise ValueError(
419                 f"Argument slidermax ({type(slidermax)}) has no 'val'")
420         self.slidermin = slidermin
421         self.slidermax = slidermax
422         valinit = self._value_in_bounds(valinit)
423         if valinit is None:
424             valinit = valmin
425         self.val = valinit
426         self.valinit = valinit
427 
428         defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}
429         handle_style = {} if handle_style is None else handle_style
430         marker_props = {
431             f'marker{k}': v for k, v in {**defaults, **handle_style}.items()
432         }
433 
434         if orientation == 'vertical':
435             self.track = Rectangle(
436                 (.25, 0), .5, 1,
437                 transform=ax.transAxes,
438                 facecolor=track_color
439             )
440             ax.add_patch(self.track)
441             self.poly = ax.axhspan(valmin, valinit, .25, .75, **kwargs)
442             self.hline = ax.axhline(valinit, .15, .85, color=initcolor, lw=1)
443             handleXY = [[0.5], [valinit]]
444         else:
445             self.track = Rectangle(
446                 (0, .25), 1, .5,
447                 transform=ax.transAxes,
448                 facecolor=track_color
449             )
450             ax.add_patch(self.track)
451             self.poly = ax.axvspan(valmin, valinit, .25, .75, **kwargs)
452             # These asymmetric limits (.2, .9) minimize the asymmetry
453             # above and below the *poly* when rendered to pixels.
454             # This seems to be different for Horizontal and Vertical lines.
455             # For discussion see:
456             # https://github.com/matplotlib/matplotlib/pull/19265
457             self.vline = ax.axvline(valinit, .2, .9, color=initcolor, lw=1)
458             handleXY = [[valinit], [0.5]]
459         self._handle, = ax.plot(
460             *handleXY,
461             "o",
462             **marker_props,
463             clip_on=False
464         )
465 
466         if orientation == 'vertical':
467             self.label = ax.text(0.5, 1.02, label, transform=ax.transAxes,
468                                  verticalalignment='bottom',
469                                  horizontalalignment='center')
470 
471             self.valtext = ax.text(0.5, -0.02, self._format(valinit),
472                                    transform=ax.transAxes,
473                                    verticalalignment='top',
474                                    horizontalalignment='center')
475         else:
476             self.label = ax.text(-0.02, 0.5, label, transform=ax.transAxes,
477                                  verticalalignment='center',
478                                  horizontalalignment='right')
479 
480             self.valtext = ax.text(1.02, 0.5, self._format(valinit),
481                                    transform=ax.transAxes,
482                                    verticalalignment='center',
483                                    horizontalalignment='left')
484 
485         self.set_val(valinit)
486 
487     def _value_in_bounds(self, val):
488         """Makes sure *val* is with given bounds."""
489         val = self._stepped_value(val)
490 
491         if val <= self.valmin:
492             if not self.closedmin:
493                 return
494             val = self.valmin
495         elif val >= self.valmax:
496             if not self.closedmax:
497                 return
498             val = self.valmax
499 
500         if self.slidermin is not None and val <= self.slidermin.val:
501             if not self.closedmin:
502                 return
503             val = self.slidermin.val
504 
505         if self.slidermax is not None and val >= self.slidermax.val:
506             if not self.closedmax:
507                 return
508             val = self.slidermax.val
509         return val
510 
511     def _update(self, event):
512         """Update the slider position."""
513         if self.ignore(event) or event.button != 1:
514             return
515 
516         if event.name == 'button_press_event' and event.inaxes == self.ax:
517             self.drag_active = True
518             event.canvas.grab_mouse(self.ax)
519 
520         if not self.drag_active:
521             return
522 
523         elif ((event.name == 'button_release_event') or
524               (event.name == 'button_press_event' and
525                event.inaxes != self.ax)):
526             self.drag_active = False
527             event.canvas.release_mouse(self.ax)
528             return
529         if self.orientation == 'vertical':
530             val = self._value_in_bounds(event.ydata)
531         else:
532             val = self._value_in_bounds(event.xdata)
533         if val not in [None, self.val]:
534             self.set_val(val)
535 
536     def _format(self, val):
537         """Pretty-print *val*."""
538         if self.valfmt is not None:
539             return self.valfmt % val
540         else:
541             _, s, _ = self._fmt.format_ticks([self.valmin, val, self.valmax])
542             # fmt.get_offset is actually the multiplicative factor, if any.
543             return s + self._fmt.get_offset()
544 
545     def set_val(self, val):
546         """
547         Set slider value to *val*.
548 
549         Parameters
550         ----------
551         val : float
552         """
553         xy = self.poly.xy
554         if self.orientation == 'vertical':
555             xy[1] = .25, val
556             xy[2] = .75, val
557             self._handle.set_ydata([val])
558         else:
559             xy[2] = val, .75
560             xy[3] = val, .25
561             self._handle.set_xdata([val])
562         self.poly.xy = xy
563         self.valtext.set_text(self._format(val))
564         if self.drawon:
565             self.ax.figure.canvas.draw_idle()
566         self.val = val
567         if self.eventson:
568             self._observers.process('changed', val)
569 
570     def on_changed(self, func):
571         """
572         Connect *func* as callback function to changes of the slider value.
573 
574         Parameters
575         ----------
576         func : callable
577             Function to call when slider is changed.
578             The function must accept a single float as its arguments.
579 
580         Returns
581         -------
582         int
583             Connection id (which can be used to disconnect *func*).
584         """
585         return self._observers.connect('changed', lambda val: func(val))
586 
587 
588 class RangeSlider(SliderBase):
589     """
590     A slider representing a range of floating point values. Defines the min and
591     max of the range via the *val* attribute as a tuple of (min, max).
592 
593     Create a slider that defines a range contained within [*valmin*, *valmax*]
594     in axes *ax*. For the slider to remain responsive you must maintain a
595     reference to it. Call :meth:`on_changed` to connect to the slider event.
596 
597     Attributes
598     ----------
599     val : tuple of float
600         Slider value.
601     """
602 
603     def __init__(
604         self,
605         ax,
606         label,
607         valmin,
608         valmax,
609         valinit=None,
610         valfmt=None,
611         closedmin=True,
612         closedmax=True,
613         dragging=True,
614         valstep=None,
615         orientation="horizontal",
616         track_color='lightgrey',
617         handle_style=None,
618         **kwargs,
619     ):
620         """
621         Parameters
622         ----------
623         ax : Axes
624             The Axes to put the slider in.
625 
626         label : str
627             Slider label.
628 
629         valmin : float
630             The minimum value of the slider.
631 
632         valmax : float
633             The maximum value of the slider.
634 
635         valinit : tuple of float or None, default: None
636             The initial positions of the slider. If None the initial positions
637             will be at the 25th and 75th percentiles of the range.
638 
639         valfmt : str, default: None
640             %-format string used to format the slider values.  If None, a
641             `.ScalarFormatter` is used instead.
642 
643         closedmin : bool, default: True
644             Whether the slider interval is closed on the bottom.
645 
646         closedmax : bool, default: True
647             Whether the slider interval is closed on the top.
648 
649         dragging : bool, default: True
650             If True the slider can be dragged by the mouse.
651 
652         valstep : float, default: None
653             If given, the slider will snap to multiples of *valstep*.
654 
655         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
656             The orientation of the slider.
657 
658         track_color : color, default: 'lightgrey'
659             The color of the background track. The track is accessible for
660             further styling via the *track* attribute.
661 
662         handle_style : dict
663             Properties of the slider handles. Default values are
664 
665             ========= ===== ======= =========================================
666             Key       Value Default Description
667             ========= ===== ======= =========================================
668             facecolor color 'white' The facecolor of the slider handles.
669             edgecolor color '.75'   The edgecolor of the slider handles.
670             size      int   10      The size of the slider handles in points.
671             ========= ===== ======= =========================================
672 
673             Other values will be transformed as marker{foo} and passed to the
674             `~.Line2D` constructor. e.g. ``handle_style = {'style'='x'}`` will
675             result in ``markerstyle = 'x'``.
676 
677         Notes
678         -----
679         Additional kwargs are passed on to ``self.poly`` which is the
680         `~matplotlib.patches.Polygon` that draws the slider knob.  See the
681         `.Polygon` documentation for valid property names (``facecolor``,
682         ``edgecolor``, ``alpha``, etc.).
683         """
684         super().__init__(ax, orientation, closedmin, closedmax,
685                          valmin, valmax, valfmt, dragging, valstep)
686 
687         # Set a value to allow _value_in_bounds() to work.
688         self.val = [valmin, valmax]
689         if valinit is None:
690             # Place at the 25th and 75th percentiles
691             extent = valmax - valmin
692             valinit = np.array([valmin + extent * 0.25,
693                                 valmin + extent * 0.75])
694         else:
695             valinit = self._value_in_bounds(valinit)
696         self.val = valinit
697         self.valinit = valinit
698 
699         defaults = {'facecolor': 'white', 'edgecolor': '.75', 'size': 10}
700         handle_style = {} if handle_style is None else handle_style
701         marker_props = {
702             f'marker{k}': v for k, v in {**defaults, **handle_style}.items()
703         }
704 
705         if orientation == "vertical":
706             self.track = Rectangle(
707                 (.25, 0), .5, 2,
708                 transform=ax.transAxes,
709                 facecolor=track_color
710             )
711             ax.add_patch(self.track)
712             self.poly = ax.axhspan(valinit[0], valinit[1], 0, 1, **kwargs)
713             handleXY_1 = [.5, valinit[0]]
714             handleXY_2 = [.5, valinit[1]]
715         else:
716             self.track = Rectangle(
717                 (0, .25), 1, .5,
718                 transform=ax.transAxes,
719                 facecolor=track_color
720             )
721             ax.add_patch(self.track)
722             self.poly = ax.axvspan(valinit[0], valinit[1], 0, 1, **kwargs)
723             handleXY_1 = [valinit[0], .5]
724             handleXY_2 = [valinit[1], .5]
725         self._handles = [
726             ax.plot(
727                 *handleXY_1,
728                 "o",
729                 **marker_props,
730                 clip_on=False
731             )[0],
732             ax.plot(
733                 *handleXY_2,
734                 "o",
735                 **marker_props,
736                 clip_on=False
737             )[0]
738         ]
739 
740         if orientation == "vertical":
741             self.label = ax.text(
742                 0.5,
743                 1.02,
744                 label,
745                 transform=ax.transAxes,
746                 verticalalignment="bottom",
747                 horizontalalignment="center",
748             )
749 
750             self.valtext = ax.text(
751                 0.5,
752                 -0.02,
753                 self._format(valinit),
754                 transform=ax.transAxes,
755                 verticalalignment="top",
756                 horizontalalignment="center",
757             )
758         else:
759             self.label = ax.text(
760                 -0.02,
761                 0.5,
762                 label,
763                 transform=ax.transAxes,
764                 verticalalignment="center",
765                 horizontalalignment="right",
766             )
767 
768             self.valtext = ax.text(
769                 1.02,
770                 0.5,
771                 self._format(valinit),
772                 transform=ax.transAxes,
773                 verticalalignment="center",
774                 horizontalalignment="left",
775             )
776 
777         self._active_handle = None
778         self.set_val(valinit)
779 
780     def _min_in_bounds(self, min):
781         """Ensure the new min value is between valmin and self.val[1]."""
782         if min <= self.valmin:
783             if not self.closedmin:
784                 return self.val[0]
785             min = self.valmin
786 
787         if min > self.val[1]:
788             min = self.val[1]
789         return self._stepped_value(min)
790 
791     def _max_in_bounds(self, max):
792         """Ensure the new max value is between valmax and self.val[0]."""
793         if max >= self.valmax:
794             if not self.closedmax:
795                 return self.val[1]
796             max = self.valmax
797 
798         if max <= self.val[0]:
799             max = self.val[0]
800         return self._stepped_value(max)
801 
802     def _value_in_bounds(self, vals):
803         """Clip min, max values to the bounds."""
804         return (self._min_in_bounds(vals[0]), self._max_in_bounds(vals[1]))
805 
806     def _update_val_from_pos(self, pos):
807         """Update the slider value based on a given position."""
808         idx = np.argmin(np.abs(self.val - pos))
809         if idx == 0:
810             val = self._min_in_bounds(pos)
811             self.set_min(val)
812         else:
813             val = self._max_in_bounds(pos)
814             self.set_max(val)
815         if self._active_handle:
816             self._active_handle.set_xdata([val])
817 
818     def _update(self, event):
819         """Update the slider position."""
820         if self.ignore(event) or event.button != 1:
821             return
822 
823         if event.name == "button_press_event" and event.inaxes == self.ax:
824             self.drag_active = True
825             event.canvas.grab_mouse(self.ax)
826 
827         if not self.drag_active:
828             return
829 
830         elif (event.name == "button_release_event") or (
831             event.name == "button_press_event" and event.inaxes != self.ax
832         ):
833             self.drag_active = False
834             event.canvas.release_mouse(self.ax)
835             self._active_handle = None
836             return
837 
838         # determine which handle was grabbed
839         handle = self._handles[
840             np.argmin(
841                 np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])
842             )
843         ]
844         # these checks ensure smooth behavior if the handles swap which one
845         # has a higher value. i.e. if one is dragged over and past the other.
846         if handle is not self._active_handle:
847             self._active_handle = handle
848 
849         if self.orientation == "vertical":
850             self._update_val_from_pos(event.ydata)
851         else:
852             self._update_val_from_pos(event.xdata)
853 
854     def _format(self, val):
855         """Pretty-print *val*."""
856         if self.valfmt is not None:
857             return f"({self.valfmt % val[0]}, {self.valfmt % val[1]})"
858         else:
859             _, s1, s2, _ = self._fmt.format_ticks(
860                 [self.valmin, *val, self.valmax]
861             )
862             # fmt.get_offset is actually the multiplicative factor, if any.
863             s1 += self._fmt.get_offset()
864             s2 += self._fmt.get_offset()
865             # Use f string to avoid issues with backslashes when cast to a str
866             return f"({s1}, {s2})"
867 
868     def set_min(self, min):
869         """
870         Set the lower value of the slider to *min*.
871 
872         Parameters
873         ----------
874         min : float
875         """
876         self.set_val((min, self.val[1]))
877 
878     def set_max(self, max):
879         """
880         Set the lower value of the slider to *max*.
881 
882         Parameters
883         ----------
884         max : float
885         """
886         self.set_val((self.val[0], max))
887 
888     def set_val(self, val):
889         """
890         Set slider value to *val*.
891 
892         Parameters
893         ----------
894         val : tuple or array-like of float
895         """
896         val = np.sort(np.asanyarray(val))
897         if val.shape != (2,):
898             raise ValueError(
899                 f"val must have shape (2,) but has shape {val.shape}"
900             )
901         val[0] = self._min_in_bounds(val[0])
902         val[1] = self._max_in_bounds(val[1])
903         xy = self.poly.xy
904         if self.orientation == "vertical":
905             xy[0] = .25, val[0]
906             xy[1] = .25, val[1]
907             xy[2] = .75, val[1]
908             xy[3] = .75, val[0]
909             xy[4] = .25, val[0]
910         else:
911             xy[0] = val[0], .25
912             xy[1] = val[0], .75
913             xy[2] = val[1], .75
914             xy[3] = val[1], .25
915             xy[4] = val[0], .25
916         self.poly.xy = xy
917         self.valtext.set_text(self._format(val))
918         if self.drawon:
919             self.ax.figure.canvas.draw_idle()
920         self.val = val
921         if self.eventson:
922             self._observers.process("changed", val)
923 
924     def on_changed(self, func):
925         """
926         Connect *func* as callback function to changes of the slider value.
927 
928         Parameters
929         ----------
930         func : callable
931             Function to call when slider is changed. The function
932             must accept a numpy array with shape (2,) as its argument.
933 
934         Returns
935         -------
936         int
937             Connection id (which can be used to disconnect *func*).
938         """
939         return self._observers.connect('changed', lambda val: func(val))
940 
941 
942 class CheckButtons(AxesWidget):
943     r"""
944     A GUI neutral set of check buttons.
945 
946     For the check buttons to remain responsive you must keep a
947     reference to this object.
948 
949     Connect to the CheckButtons with the `.on_clicked` method.
950 
951     Attributes
952     ----------
953     ax : `~matplotlib.axes.Axes`
954         The parent axes for the widget.
955     labels : list of `.Text`
956 
957     rectangles : list of `.Rectangle`
958 
959     lines : list of (`.Line2D`, `.Line2D`) pairs
960         List of lines for the x's in the check boxes.  These lines exist for
961         each box, but have ``set_visible(False)`` when its box is not checked.
962     """
963 
964     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
965         lambda self: len(self._observers.callbacks['clicked'])))
966     observers = _api.deprecated("3.4")(property(
967         lambda self: self._observers.callbacks['clicked']))
968 
969     def __init__(self, ax, labels, actives=None):
970         """
971         Add check buttons to `matplotlib.axes.Axes` instance *ax*.
972 
973         Parameters
974         ----------
975         ax : `~matplotlib.axes.Axes`
976             The parent axes for the widget.
977 
978         labels : list of str
979             The labels of the check buttons.
980 
981         actives : list of bool, optional
982             The initial check states of the buttons. The list must have the
983             same length as *labels*. If not given, all buttons are unchecked.
984         """
985         super().__init__(ax)
986 
987         ax.set_xticks([])
988         ax.set_yticks([])
989         ax.set_navigate(False)
990 
991         if actives is None:
992             actives = [False] * len(labels)
993 
994         if len(labels) > 1:
995             dy = 1. / (len(labels) + 1)
996             ys = np.linspace(1 - dy, dy, len(labels))
997         else:
998             dy = 0.25
999             ys = [0.5]
1000 
1001         axcolor = ax.get_facecolor()
1002 
1003         self.labels = []
1004         self.lines = []
1005         self.rectangles = []
1006 
1007         lineparams = {'color': 'k', 'linewidth': 1.25,
1008                       'transform': ax.transAxes, 'solid_capstyle': 'butt'}
1009         for y, label, active in zip(ys, labels, actives):
1010             t = ax.text(0.25, y, label, transform=ax.transAxes,
1011                         horizontalalignment='left',
1012                         verticalalignment='center')
1013 
1014             w, h = dy / 2, dy / 2
1015             x, y = 0.05, y - h / 2
1016 
1017             p = Rectangle(xy=(x, y), width=w, height=h, edgecolor='black',
1018                           facecolor=axcolor, transform=ax.transAxes)
1019 
1020             l1 = Line2D([x, x + w], [y + h, y], **lineparams)
1021             l2 = Line2D([x, x + w], [y, y + h], **lineparams)
1022 
1023             l1.set_visible(active)
1024             l2.set_visible(active)
1025             self.labels.append(t)
1026             self.rectangles.append(p)
1027             self.lines.append((l1, l2))
1028             ax.add_patch(p)
1029             ax.add_line(l1)
1030             ax.add_line(l2)
1031 
1032         self.connect_event('button_press_event', self._clicked)
1033 
1034         self._observers = cbook.CallbackRegistry()
1035 
1036     def _clicked(self, event):
1037         if self.ignore(event) or event.button != 1 or event.inaxes != self.ax:
1038             return
1039         for i, (p, t) in enumerate(zip(self.rectangles, self.labels)):
1040             if (t.get_window_extent().contains(event.x, event.y) or
1041                     p.get_window_extent().contains(event.x, event.y)):
1042                 self.set_active(i)
1043                 break
1044 
1045     def set_active(self, index):
1046         """
1047         Toggle (activate or deactivate) a check button by index.
1048 
1049         Callbacks will be triggered if :attr:`eventson` is True.
1050 
1051         Parameters
1052         ----------
1053         index : int
1054             Index of the check button to toggle.
1055 
1056         Raises
1057         ------
1058         ValueError
1059             If *index* is invalid.
1060         """
1061         if index not in range(len(self.labels)):
1062             raise ValueError(f'Invalid CheckButton index: {index}')
1063 
1064         l1, l2 = self.lines[index]
1065         l1.set_visible(not l1.get_visible())
1066         l2.set_visible(not l2.get_visible())
1067 
1068         if self.drawon:
1069             self.ax.figure.canvas.draw()
1070 
1071         if self.eventson:
1072             self._observers.process('clicked', self.labels[index].get_text())
1073 
1074     def get_status(self):
1075         """
1076         Return a tuple of the status (True/False) of all of the check buttons.
1077         """
1078         return [l1.get_visible() for (l1, l2) in self.lines]
1079 
1080     def on_clicked(self, func):
1081         """
1082         Connect the callback function *func* to button click events.
1083 
1084         Returns a connection id, which can be used to disconnect the callback.
1085         """
1086         return self._observers.connect('clicked', lambda text: func(text))
1087 
1088     def disconnect(self, cid):
1089         """Remove the observer with connection id *cid*."""
1090         self._observers.disconnect(cid)
1091 
1092 
1093 class TextBox(AxesWidget):
1094     """
1095     A GUI neutral text input box.
1096 
1097     For the text box to remain responsive you must keep a reference to it.
1098 
1099     Call `.on_text_change` to be updated whenever the text changes.
1100 
1101     Call `.on_submit` to be updated whenever the user hits enter or
1102     leaves the text entry field.
1103 
1104     Attributes
1105     ----------
1106     ax : `~matplotlib.axes.Axes`
1107         The parent axes for the widget.
1108     label : `.Text`
1109 
1110     color : color
1111         The color of the text box when not hovering.
1112     hovercolor : color
1113         The color of the text box when hovering.
1114     """
1115 
1116     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
1117         lambda self: sum(len(d) for d in self._observers.callbacks.values())))
1118     change_observers = _api.deprecated("3.4")(property(
1119         lambda self: self._observers.callbacks['change']))
1120     submit_observers = _api.deprecated("3.4")(property(
1121         lambda self: self._observers.callbacks['submit']))
1122     DIST_FROM_LEFT = _api.deprecate_privatize_attribute("3.5")
1123 
1124     def __init__(self, ax, label, initial='',
1125                  color='.95', hovercolor='1', label_pad=.01,
1126                  textalignment="left"):
1127         """
1128         Parameters
1129         ----------
1130         ax : `~matplotlib.axes.Axes`
1131             The `~.axes.Axes` instance the button will be placed into.
1132         label : str
1133             Label for this text box.
1134         initial : str
1135             Initial value in the text box.
1136         color : color
1137             The color of the box.
1138         hovercolor : color
1139             The color of the box when the mouse is over it.
1140         label_pad : float
1141             The distance between the label and the right side of the textbox.
1142         textalignment : {'left', 'center', 'right'}
1143             The horizontal location of the text.
1144         """
1145         super().__init__(ax)
1146 
1147         self._DIST_FROM_LEFT = .05
1148 
1149         self._text_position = _api.check_getitem(
1150             {"left": 0.05, "center": 0.5, "right": 0.95},
1151             textalignment=textalignment)
1152 
1153         self.label = ax.text(
1154             -label_pad, 0.5, label, transform=ax.transAxes,
1155             verticalalignment='center', horizontalalignment='right')
1156 
1157         # TextBox's text object should not parse mathtext at all.
1158         self.text_disp = self.ax.text(
1159             self._text_position, 0.5, initial, transform=self.ax.transAxes,
1160             verticalalignment='center', horizontalalignment=textalignment,
1161             parse_math=False)
1162 
1163         self._observers = cbook.CallbackRegistry()
1164 
1165         ax.set(
1166             xlim=(0, 1), ylim=(0, 1),  # s.t. cursor appears from first click.
1167             navigate=False, facecolor=color,
1168             xticks=[], yticks=[])
1169 
1170         self.cursor_index = 0
1171 
1172         self.cursor = ax.vlines(0, 0, 0, visible=False, color="k", lw=1,
1173                                 transform=mpl.transforms.IdentityTransform())
1174 
1175         self.connect_event('button_press_event', self._click)
1176         self.connect_event('button_release_event', self._release)
1177         self.connect_event('motion_notify_event', self._motion)
1178         self.connect_event('key_press_event', self._keypress)
1179         self.connect_event('resize_event', self._resize)
1180 
1181         self.color = color
1182         self.hovercolor = hovercolor
1183 
1184         self.capturekeystrokes = False
1185 
1186     @property
1187     def text(self):
1188         return self.text_disp.get_text()
1189 
1190     def _rendercursor(self):
1191         # this is a hack to figure out where the cursor should go.
1192         # we draw the text up to where the cursor should go, measure
1193         # and save its dimensions, draw the real text, then put the cursor
1194         # at the saved dimensions
1195 
1196         # This causes a single extra draw if the figure has never been rendered
1197         # yet, which should be fine as we're going to repeatedly re-render the
1198         # figure later anyways.
1199         if self.ax.figure._cachedRenderer is None:
1200             self.ax.figure.canvas.draw()
1201 
1202         text = self.text_disp.get_text()  # Save value before overwriting it.
1203         widthtext = text[:self.cursor_index]
1204 
1205         bb_text = self.text_disp.get_window_extent()
1206         self.text_disp.set_text(widthtext or ",")
1207         bb_widthtext = self.text_disp.get_window_extent()
1208 
1209         if bb_text.y0 == bb_text.y1:  # Restoring the height if no text.
1210             bb_text.y0 -= (bb_widthtext.y1-bb_widthtext.y0)/2
1211             bb_text.y1 += (bb_widthtext.y1-bb_widthtext.y0)/2
1212         elif not widthtext:  # Keep width to 0.
1213             bb_text.x1 = bb_text.x0
1214         else:  # Move the cursor using width of bb_widthtext.
1215             bb_text.x1 = bb_text.x0 + (bb_widthtext.x1 - bb_widthtext.x0)
1216 
1217         self.cursor.set(
1218             segments=[[(bb_text.x1, bb_text.y0), (bb_text.x1, bb_text.y1)]],
1219             visible=True)
1220         self.text_disp.set_text(text)
1221 
1222         self.ax.figure.canvas.draw()
1223 
1224     def _release(self, event):
1225         if self.ignore(event):
1226             return
1227         if event.canvas.mouse_grabber != self.ax:
1228             return
1229         event.canvas.release_mouse(self.ax)
1230 
1231     def _keypress(self, event):
1232         if self.ignore(event):
1233             return
1234         if self.capturekeystrokes:
1235             key = event.key
1236             text = self.text
1237             if len(key) == 1:
1238                 text = (text[:self.cursor_index] + key +
1239                         text[self.cursor_index:])
1240                 self.cursor_index += 1
1241             elif key == "right":
1242                 if self.cursor_index != len(text):
1243                     self.cursor_index += 1
1244             elif key == "left":
1245                 if self.cursor_index != 0:
1246                     self.cursor_index -= 1
1247             elif key == "home":
1248                 self.cursor_index = 0
1249             elif key == "end":
1250                 self.cursor_index = len(text)
1251             elif key == "backspace":
1252                 if self.cursor_index != 0:
1253                     text = (text[:self.cursor_index - 1] +
1254                             text[self.cursor_index:])
1255                     self.cursor_index -= 1
1256             elif key == "delete":
1257                 if self.cursor_index != len(self.text):
1258                     text = (text[:self.cursor_index] +
1259                             text[self.cursor_index + 1:])
1260             self.text_disp.set_text(text)
1261             self._rendercursor()
1262             if self.eventson:
1263                 self._observers.process('change', self.text)
1264                 if key in ["enter", "return"]:
1265                     self._observers.process('submit', self.text)
1266 
1267     def set_val(self, val):
1268         newval = str(val)
1269         if self.text == newval:
1270             return
1271         self.text_disp.set_text(newval)
1272         self._rendercursor()
1273         if self.eventson:
1274             self._observers.process('change', self.text)
1275             self._observers.process('submit', self.text)
1276 
1277     def begin_typing(self, x):
1278         self.capturekeystrokes = True
1279         # Disable keypress shortcuts, which may otherwise cause the figure to
1280         # be saved, closed, etc., until the user stops typing.  The way to
1281         # achieve this depends on whether toolmanager is in use.
1282         stack = ExitStack()  # Register cleanup actions when user stops typing.
1283         self._on_stop_typing = stack.close
1284         toolmanager = getattr(
1285             self.ax.figure.canvas.manager, "toolmanager", None)
1286         if toolmanager is not None:
1287             # If using toolmanager, lock keypresses, and plan to release the
1288             # lock when typing stops.
1289             toolmanager.keypresslock(self)
1290             stack.push(toolmanager.keypresslock.release, self)
1291         else:
1292             # If not using toolmanager, disable all keypress-related rcParams.
1293             # Avoid spurious warnings if keymaps are getting deprecated.
1294             with _api.suppress_matplotlib_deprecation_warning():
1295                 stack.enter_context(mpl.rc_context(
1296                     {k: [] for k in mpl.rcParams if k.startswith("keymap.")}))
1297 
1298     def stop_typing(self):
1299         if self.capturekeystrokes:
1300             self._on_stop_typing()
1301             self._on_stop_typing = None
1302             notifysubmit = True
1303         else:
1304             notifysubmit = False
1305         self.capturekeystrokes = False
1306         self.cursor.set_visible(False)
1307         self.ax.figure.canvas.draw()
1308         if notifysubmit and self.eventson:
1309             # Because process() might throw an error in the user's code, only
1310             # call it once we've already done our cleanup.
1311             self._observers.process('submit', self.text)
1312 
1313     def position_cursor(self, x):
1314         # now, we have to figure out where the cursor goes.
1315         # approximate it based on assuming all characters the same length
1316         if len(self.text) == 0:
1317             self.cursor_index = 0
1318         else:
1319             bb = self.text_disp.get_window_extent()
1320             ratio = np.clip((x - bb.x0) / bb.width, 0, 1)
1321             self.cursor_index = int(len(self.text) * ratio)
1322         self._rendercursor()
1323 
1324     def _click(self, event):
1325         if self.ignore(event):
1326             return
1327         if event.inaxes != self.ax:
1328             self.stop_typing()
1329             return
1330         if not self.eventson:
1331             return
1332         if event.canvas.mouse_grabber != self.ax:
1333             event.canvas.grab_mouse(self.ax)
1334         if not self.capturekeystrokes:
1335             self.begin_typing(event.x)
1336         self.position_cursor(event.x)
1337 
1338     def _resize(self, event):
1339         self.stop_typing()
1340 
1341     def _motion(self, event):
1342         if self.ignore(event):
1343             return
1344         c = self.hovercolor if event.inaxes == self.ax else self.color
1345         if not colors.same_color(c, self.ax.get_facecolor()):
1346             self.ax.set_facecolor(c)
1347             if self.drawon:
1348                 self.ax.figure.canvas.draw()
1349 
1350     def on_text_change(self, func):
1351         """
1352         When the text changes, call this *func* with event.
1353 
1354         A connection id is returned which can be used to disconnect.
1355         """
1356         return self._observers.connect('change', lambda text: func(text))
1357 
1358     def on_submit(self, func):
1359         """
1360         When the user hits enter or leaves the submission box, call this
1361         *func* with event.
1362 
1363         A connection id is returned which can be used to disconnect.
1364         """
1365         return self._observers.connect('submit', lambda text: func(text))
1366 
1367     def disconnect(self, cid):
1368         """Remove the observer with connection id *cid*."""
1369         self._observers.disconnect(cid)
1370 
1371 
1372 class RadioButtons(AxesWidget):
1373     """
1374     A GUI neutral radio button.
1375 
1376     For the buttons to remain responsive you must keep a reference to this
1377     object.
1378 
1379     Connect to the RadioButtons with the `.on_clicked` method.
1380 
1381     Attributes
1382     ----------
1383     ax : `~matplotlib.axes.Axes`
1384         The parent axes for the widget.
1385     activecolor : color
1386         The color of the selected button.
1387     labels : list of `.Text`
1388         The button labels.
1389     circles : list of `~.patches.Circle`
1390         The buttons.
1391     value_selected : str
1392         The label text of the currently selected button.
1393     """
1394 
1395     def __init__(self, ax, labels, active=0, activecolor='blue'):
1396         """
1397         Add radio buttons to an `~.axes.Axes`.
1398 
1399         Parameters
1400         ----------
1401         ax : `~matplotlib.axes.Axes`
1402             The axes to add the buttons to.
1403         labels : list of str
1404             The button labels.
1405         active : int
1406             The index of the initially selected button.
1407         activecolor : color
1408             The color of the selected button.
1409         """
1410         super().__init__(ax)
1411         self.activecolor = activecolor
1412         self.value_selected = None
1413 
1414         ax.set_xticks([])
1415         ax.set_yticks([])
1416         ax.set_navigate(False)
1417         dy = 1. / (len(labels) + 1)
1418         ys = np.linspace(1 - dy, dy, len(labels))
1419         cnt = 0
1420         axcolor = ax.get_facecolor()
1421 
1422         # scale the radius of the circle with the spacing between each one
1423         circle_radius = dy / 2 - 0.01
1424         # default to hard-coded value if the radius becomes too large
1425         circle_radius = min(circle_radius, 0.05)
1426 
1427         self.labels = []
1428         self.circles = []
1429         for y, label in zip(ys, labels):
1430             t = ax.text(0.25, y, label, transform=ax.transAxes,
1431                         horizontalalignment='left',
1432                         verticalalignment='center')
1433 
1434             if cnt == active:
1435                 self.value_selected = label
1436                 facecolor = activecolor
1437             else:
1438                 facecolor = axcolor
1439 
1440             p = Circle(xy=(0.15, y), radius=circle_radius, edgecolor='black',
1441                        facecolor=facecolor, transform=ax.transAxes)
1442 
1443             self.labels.append(t)
1444             self.circles.append(p)
1445             ax.add_patch(p)
1446             cnt += 1
1447 
1448         self.connect_event('button_press_event', self._clicked)
1449 
1450         self._observers = cbook.CallbackRegistry()
1451 
1452     cnt = _api.deprecated("3.4")(property(  # Not real, but close enough.
1453         lambda self: len(self._observers.callbacks['clicked'])))
1454     observers = _api.deprecated("3.4")(property(
1455         lambda self: self._observers.callbacks['clicked']))
1456 
1457     def _clicked(self, event):
1458         if self.ignore(event) or event.button != 1 or event.inaxes != self.ax:
1459             return
1460         pclicked = self.ax.transAxes.inverted().transform((event.x, event.y))
1461         distances = {}
1462         for i, (p, t) in enumerate(zip(self.circles, self.labels)):
1463             if (t.get_window_extent().contains(event.x, event.y)
1464                     or np.linalg.norm(pclicked - p.center) < p.radius):
1465                 distances[i] = np.linalg.norm(pclicked - p.center)
1466         if len(distances) > 0:
1467             closest = min(distances, key=distances.get)
1468             self.set_active(closest)
1469 
1470     def set_active(self, index):
1471         """
1472         Select button with number *index*.
1473 
1474         Callbacks will be triggered if :attr:`eventson` is True.
1475         """
1476         if index not in range(len(self.labels)):
1477             raise ValueError(f'Invalid RadioButton index: {index}')
1478 
1479         self.value_selected = self.labels[index].get_text()
1480 
1481         for i, p in enumerate(self.circles):
1482             if i == index:
1483                 color = self.activecolor
1484             else:
1485                 color = self.ax.get_facecolor()
1486             p.set_facecolor(color)
1487 
1488         if self.drawon:
1489             self.ax.figure.canvas.draw()
1490 
1491         if self.eventson:
1492             self._observers.process('clicked', self.labels[index].get_text())
1493 
1494     def on_clicked(self, func):
1495         """
1496         Connect the callback function *func* to button click events.
1497 
1498         Returns a connection id, which can be used to disconnect the callback.
1499         """
1500         return self._observers.connect('clicked', func)
1501 
1502     def disconnect(self, cid):
1503         """Remove the observer with connection id *cid*."""
1504         self._observers.disconnect(cid)
1505 
1506 
1507 class SubplotTool(Widget):
1508     """
1509     A tool to adjust the subplot params of a `matplotlib.figure.Figure`.
1510     """
1511 
1512     def __init__(self, targetfig, toolfig):
1513         """
1514         Parameters
1515         ----------
1516         targetfig : `.Figure`
1517             The figure instance to adjust.
1518         toolfig : `.Figure`
1519             The figure instance to embed the subplot tool into.
1520         """
1521 
1522         self.figure = toolfig
1523         self.targetfig = targetfig
1524         toolfig.subplots_adjust(left=0.2, right=0.9)
1525         toolfig.suptitle("Click on slider to adjust subplot param")
1526 
1527         self._sliders = []
1528         names = ["left", "bottom", "right", "top", "wspace", "hspace"]
1529         # The last subplot, removed below, keeps space for the "Reset" button.
1530         for name, ax in zip(names, toolfig.subplots(len(names) + 1)):
1531             ax.set_navigate(False)
1532             slider = Slider(ax, name,
1533                             0, 1, getattr(targetfig.subplotpars, name))
1534             slider.on_changed(self._on_slider_changed)
1535             self._sliders.append(slider)
1536         toolfig.axes[-1].remove()
1537         (self.sliderleft, self.sliderbottom, self.sliderright, self.slidertop,
1538          self.sliderwspace, self.sliderhspace) = self._sliders
1539         for slider in [self.sliderleft, self.sliderbottom,
1540                        self.sliderwspace, self.sliderhspace]:
1541             slider.closedmax = False
1542         for slider in [self.sliderright, self.slidertop]:
1543             slider.closedmin = False
1544 
1545         # constraints
1546         self.sliderleft.slidermax = self.sliderright
1547         self.sliderright.slidermin = self.sliderleft
1548         self.sliderbottom.slidermax = self.slidertop
1549         self.slidertop.slidermin = self.sliderbottom
1550 
1551         bax = toolfig.add_axes([0.8, 0.05, 0.15, 0.075])
1552         self.buttonreset = Button(bax, 'Reset')
1553         self.buttonreset.on_clicked(self._on_reset)
1554 
1555     def _on_slider_changed(self, _):
1556         self.targetfig.subplots_adjust(
1557             **{slider.label.get_text(): slider.val
1558                for slider in self._sliders})
1559         if self.drawon:
1560             self.targetfig.canvas.draw()
1561 
1562     def _on_reset(self, event):
1563         with ExitStack() as stack:
1564             # Temporarily disable drawing on self and self's sliders, and
1565             # disconnect slider events (as the subplotparams can be temporarily
1566             # invalid, depending on the order in which they are restored).
1567             stack.enter_context(cbook._setattr_cm(self, drawon=False))
1568             for slider in self._sliders:
1569                 stack.enter_context(
1570                     cbook._setattr_cm(slider, drawon=False, eventson=False))
1571             # Reset the slider to the initial position.
1572             for slider in self._sliders:
1573                 slider.reset()
1574         if self.drawon:
1575             event.canvas.draw()  # Redraw the subplottool canvas.
1576         self._on_slider_changed(None)  # Apply changes to the target window.
1577 
1578 
1579 class Cursor(AxesWidget):
1580     """
1581     A crosshair cursor that spans the axes and moves with mouse cursor.
1582 
1583     For the cursor to remain responsive you must keep a reference to it.
1584 
1585     Parameters
1586     ----------
1587     ax : `matplotlib.axes.Axes`
1588         The `~.axes.Axes` to attach the cursor to.
1589     horizOn : bool, default: True
1590         Whether to draw the horizontal line.
1591     vertOn : bool, default: True
1592         Whether to draw the vertical line.
1593     useblit : bool, default: False
1594         Use blitting for faster drawing if supported by the backend.
1595 
1596     Other Parameters
1597     ----------------
1598     **lineprops
1599         `.Line2D` properties that control the appearance of the lines.
1600         See also `~.Axes.axhline`.
1601 
1602     Examples
1603     --------
1604     See :doc:`/gallery/widgets/cursor`.
1605     """
1606 
1607     def __init__(self, ax, horizOn=True, vertOn=True, useblit=False,
1608                  **lineprops):
1609         super().__init__(ax)
1610 
1611         self.connect_event('motion_notify_event', self.onmove)
1612         self.connect_event('draw_event', self.clear)
1613 
1614         self.visible = True
1615         self.horizOn = horizOn
1616         self.vertOn = vertOn
1617         self.useblit = useblit and self.canvas.supports_blit
1618 
1619         if self.useblit:
1620             lineprops['animated'] = True
1621         self.lineh = ax.axhline(ax.get_ybound()[0], visible=False, **lineprops)
1622         self.linev = ax.axvline(ax.get_xbound()[0], visible=False, **lineprops)
1623 
1624         self.background = None
1625         self.needclear = False
1626 
1627     def clear(self, event):
1628         """Internal event handler to clear the cursor."""
1629         if self.ignore(event):
1630             return
1631         if self.useblit:
1632             self.background = self.canvas.copy_from_bbox(self.ax.bbox)
1633         self.linev.set_visible(False)
1634         self.lineh.set_visible(False)
1635 
1636     def onmove(self, event):
1637         """Internal event handler to draw the cursor when the mouse moves."""
1638         if self.ignore(event):
1639             return
1640         if not self.canvas.widgetlock.available(self):
1641             return
1642         if event.inaxes != self.ax:
1643             self.linev.set_visible(False)
1644             self.lineh.set_visible(False)
1645 
1646             if self.needclear:
1647                 self.canvas.draw()
1648                 self.needclear = False
1649             return
1650         self.needclear = True
1651         if not self.visible:
1652             return
1653         self.linev.set_xdata((event.xdata, event.xdata))
1654 
1655         self.lineh.set_ydata((event.ydata, event.ydata))
1656         self.linev.set_visible(self.visible and self.vertOn)
1657         self.lineh.set_visible(self.visible and self.horizOn)
1658 
1659         self._update()
1660 
1661     def _update(self):
1662         if self.useblit:
1663             if self.background is not None:
1664                 self.canvas.restore_region(self.background)
1665             self.ax.draw_artist(self.linev)
1666             self.ax.draw_artist(self.lineh)
1667             self.canvas.blit(self.ax.bbox)
1668         else:
1669             self.canvas.draw_idle()
1670         return False
1671 
1672 
1673 class MultiCursor(Widget):
1674     """
1675     Provide a vertical (default) and/or horizontal line cursor shared between
1676     multiple axes.
1677 
1678     For the cursor to remain responsive you must keep a reference to it.
1679 
1680     Example usage::
1681 
1682         from matplotlib.widgets import MultiCursor
1683         import matplotlib.pyplot as plt
1684         import numpy as np
1685 
1686         fig, (ax1, ax2) = plt.subplots(nrows=2, sharex=True)
1687         t = np.arange(0.0, 2.0, 0.01)
1688         ax1.plot(t, np.sin(2*np.pi*t))
1689         ax2.plot(t, np.sin(4*np.pi*t))
1690 
1691         multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1,
1692                             horizOn=False, vertOn=True)
1693         plt.show()
1694 
1695     """
1696     def __init__(self, canvas, axes, useblit=True, horizOn=False, vertOn=True,
1697                  **lineprops):
1698 
1699         self.canvas = canvas
1700         self.axes = axes
1701         self.horizOn = horizOn
1702         self.vertOn = vertOn
1703 
1704         xmin, xmax = axes[-1].get_xlim()
1705         ymin, ymax = axes[-1].get_ylim()
1706         xmid = 0.5 * (xmin + xmax)
1707         ymid = 0.5 * (ymin + ymax)
1708 
1709         self.visible = True
1710         self.useblit = useblit and self.canvas.supports_blit
1711         self.background = None
1712         self.needclear = False
1713 
1714         if self.useblit:
1715             lineprops['animated'] = True
1716 
1717         if vertOn:
1718             self.vlines = [ax.axvline(xmid, visible=False, **lineprops)
1719                            for ax in axes]
1720         else:
1721             self.vlines = []
1722 
1723         if horizOn:
1724             self.hlines = [ax.axhline(ymid, visible=False, **lineprops)
1725                            for ax in axes]
1726         else:
1727             self.hlines = []
1728 
1729         self.connect()
1730 
1731     def connect(self):
1732         """Connect events."""
1733         self._cidmotion = self.canvas.mpl_connect('motion_notify_event',
1734                                                   self.onmove)
1735         self._ciddraw = self.canvas.mpl_connect('draw_event', self.clear)
1736 
1737     def disconnect(self):
1738         """Disconnect events."""
1739         self.canvas.mpl_disconnect(self._cidmotion)
1740         self.canvas.mpl_disconnect(self._ciddraw)
1741 
1742     def clear(self, event):
1743         """Clear the cursor."""
1744         if self.ignore(event):
1745             return
1746         if self.useblit:
1747             self.background = (
1748                 self.canvas.copy_from_bbox(self.canvas.figure.bbox))
1749         for line in self.vlines + self.hlines:
1750             line.set_visible(False)
1751 
1752     def onmove(self, event):
1753         if self.ignore(event):
1754             return
1755         if event.inaxes not in self.axes:
1756             return
1757         if not self.canvas.widgetlock.available(self):
1758             return
1759         self.needclear = True
1760         if not self.visible:
1761             return
1762         if self.vertOn:
1763             for line in self.vlines:
1764                 line.set_xdata((event.xdata, event.xdata))
1765                 line.set_visible(self.visible)
1766         if self.horizOn:
1767             for line in self.hlines:
1768                 line.set_ydata((event.ydata, event.ydata))
1769                 line.set_visible(self.visible)
1770         self._update()
1771 
1772     def _update(self):
1773         if self.useblit:
1774             if self.background is not None:
1775                 self.canvas.restore_region(self.background)
1776             if self.vertOn:
1777                 for ax, line in zip(self.axes, self.vlines):
1778                     ax.draw_artist(line)
1779             if self.horizOn:
1780                 for ax, line in zip(self.axes, self.hlines):
1781                     ax.draw_artist(line)
1782             self.canvas.blit()
1783         else:
1784             self.canvas.draw_idle()
1785 
1786 
1787 class _SelectorWidget(AxesWidget):
1788 
1789     def __init__(self, ax, onselect, useblit=False, button=None,
1790                  state_modifier_keys=None):
1791         super().__init__(ax)
1792 
1793         self.visible = True
1794         self.onselect = onselect
1795         self.useblit = useblit and self.canvas.supports_blit
1796         self.connect_default_events()
1797 
1798         self.state_modifier_keys = dict(move=' ', clear='escape',
1799                                         square='shift', center='control')
1800         self.state_modifier_keys.update(state_modifier_keys or {})
1801 
1802         self.background = None
1803         self.artists = []
1804 
1805         if isinstance(button, Integral):
1806             self.validButtons = [button]
1807         else:
1808             self.validButtons = button
1809 
1810         # Set to True when a selection is completed, otherwise is False
1811         self._selection_completed = False
1812 
1813         # will save the data (position at mouseclick)
1814         self._eventpress = None
1815         # will save the data (pos. at mouserelease)
1816         self._eventrelease = None
1817         self._prev_event = None
1818         self._state = set()
1819 
1820     eventpress = _api.deprecate_privatize_attribute("3.5")
1821     eventrelease = _api.deprecate_privatize_attribute("3.5")
1822     state = _api.deprecate_privatize_attribute("3.5")
1823 
1824     def set_active(self, active):
1825         super().set_active(active)
1826         if active:
1827             self.update_background(None)
1828 
1829     def update_background(self, event):
1830         """Force an update of the background."""
1831         # If you add a call to `ignore` here, you'll want to check edge case:
1832         # `release` can call a draw event even when `ignore` is True.
1833         if not self.useblit:
1834             return
1835         # Make sure that widget artists don't get accidentally included in the
1836         # background, by re-rendering the background if needed (and then
1837         # re-re-rendering the canvas with the visible widget artists).
1838         needs_redraw = any(artist.get_visible() for artist in self.artists)
1839         with ExitStack() as stack:
1840             if needs_redraw:
1841                 for artist in self.artists:
1842                     stack.enter_context(artist._cm_set(visible=False))
1843                 self.canvas.draw()
1844             self.background = self.canvas.copy_from_bbox(self.ax.bbox)
1845         if needs_redraw:
1846             for artist in self.artists:
1847                 self.ax.draw_artist(artist)
1848 
1849     def connect_default_events(self):
1850         """Connect the major canvas events to methods."""
1851         self.connect_event('motion_notify_event', self.onmove)
1852         self.connect_event('button_press_event', self.press)
1853         self.connect_event('button_release_event', self.release)
1854         self.connect_event('draw_event', self.update_background)
1855         self.connect_event('key_press_event', self.on_key_press)
1856         self.connect_event('key_release_event', self.on_key_release)
1857         self.connect_event('scroll_event', self.on_scroll)
1858 
1859     def ignore(self, event):
1860         # docstring inherited
1861         if not self.active or not self.ax.get_visible():
1862             return True
1863         # If canvas was locked
1864         if not self.canvas.widgetlock.available(self):
1865             return True
1866         if not hasattr(event, 'button'):
1867             event.button = None
1868         # Only do rectangle selection if event was triggered
1869         # with a desired button
1870         if (self.validButtons is not None
1871                 and event.button not in self.validButtons):
1872             return True
1873         # If no button was pressed yet ignore the event if it was out
1874         # of the axes
1875         if self._eventpress is None:
1876             return event.inaxes != self.ax
1877         # If a button was pressed, check if the release-button is the same.
1878         if event.button == self._eventpress.button:
1879             return False
1880         # If a button was pressed, check if the release-button is the same.
1881         return (event.inaxes != self.ax or
1882                 event.button != self._eventpress.button)
1883 
1884     def update(self):
1885         """Draw using blit() or draw_idle(), depending on ``self.useblit``."""
1886         if not self.ax.get_visible() or self.ax.figure._cachedRenderer is None:
1887             return False
1888         if self.useblit:
1889             if self.background is not None:
1890                 self.canvas.restore_region(self.background)
1891             else:
1892                 self.update_background(None)
1893             for artist in self.artists:
1894                 self.ax.draw_artist(artist)
1895             self.canvas.blit(self.ax.bbox)
1896         else:
1897             self.canvas.draw_idle()
1898         return False
1899 
1900     def _get_data(self, event):
1901         """Get the xdata and ydata for event, with limits."""
1902         if event.xdata is None:
1903             return None, None
1904         xdata = np.clip(event.xdata, *self.ax.get_xbound())
1905         ydata = np.clip(event.ydata, *self.ax.get_ybound())
1906         return xdata, ydata
1907 
1908     def _clean_event(self, event):
1909         """
1910         Preprocess an event:
1911 
1912         - Replace *event* by the previous event if *event* has no ``xdata``.
1913         - Clip ``xdata`` and ``ydata`` to the axes limits.
1914         - Update the previous event.
1915         """
1916         if event.xdata is None:
1917             event = self._prev_event
1918         else:
1919             event = copy.copy(event)
1920         event.xdata, event.ydata = self._get_data(event)
1921         self._prev_event = event
1922         return event
1923 
1924     def press(self, event):
1925         """Button press handler and validator."""
1926         if not self.ignore(event):
1927             event = self._clean_event(event)
1928             self._eventpress = event
1929             self._prev_event = event
1930             key = event.key or ''
1931             key = key.replace('ctrl', 'control')
1932             # move state is locked in on a button press
1933             if key == self.state_modifier_keys['move']:
1934                 self._state.add('move')
1935             self._press(event)
1936             return True
1937         return False
1938 
1939     def _press(self, event):
1940         """Button press event handler."""
1941 
1942     def release(self, event):
1943         """Button release event handler and validator."""
1944         if not self.ignore(event) and self._eventpress:
1945             event = self._clean_event(event)
1946             self._eventrelease = event
1947             self._release(event)
1948             self._eventpress = None
1949             self._eventrelease = None
1950             self._state.discard('move')
1951             return True
1952         return False
1953 
1954     def _release(self, event):
1955         """Button release event handler."""
1956 
1957     def onmove(self, event):
1958         """Cursor move event handler and validator."""
1959         if not self.ignore(event) and self._eventpress:
1960             event = self._clean_event(event)
1961             self._onmove(event)
1962             return True
1963         return False
1964 
1965     def _onmove(self, event):
1966         """Cursor move event handler."""
1967 
1968     def on_scroll(self, event):
1969         """Mouse scroll event handler and validator."""
1970         if not self.ignore(event):
1971             self._on_scroll(event)
1972 
1973     def _on_scroll(self, event):
1974         """Mouse scroll event handler."""
1975 
1976     def on_key_press(self, event):
1977         """Key press event handler and validator for all selection widgets."""
1978         if self.active:
1979             key = event.key or ''
1980             key = key.replace('ctrl', 'control')
1981             if key == self.state_modifier_keys['clear']:
1982                 for artist in self.artists:
1983                     artist.set_visible(False)
1984                 self.update()
1985                 return
1986             for (state, modifier) in self.state_modifier_keys.items():
1987                 if modifier in key:
1988                     self._state.add(state)
1989             self._on_key_press(event)
1990 
1991     def _on_key_press(self, event):
1992         """Key press event handler - for widget-specific key press actions."""
1993 
1994     def on_key_release(self, event):
1995         """Key release event handler and validator."""
1996         if self.active:
1997             key = event.key or ''
1998             for (state, modifier) in self.state_modifier_keys.items():
1999                 if modifier in key:
2000                     self._state.discard(state)
2001             self._on_key_release(event)
2002 
2003     def _on_key_release(self, event):
2004         """Key release event handler."""
2005 
2006     def set_visible(self, visible):
2007         """Set the visibility of our artists."""
2008         self.visible = visible
2009         for artist in self.artists:
2010             artist.set_visible(visible)
2011 
2012 
2013 class SpanSelector(_SelectorWidget):
2014     """
2015     Visually select a min/max range on a single axis and call a function with
2016     those values.
2017 
2018     To guarantee that the selector remains responsive, keep a reference to it.
2019 
2020     In order to turn off the SpanSelector, set ``span_selector.active`` to
2021     False.  To turn it back on, set it to True.
2022 
2023     Press and release events triggered at the same coordinates outside the
2024     selection will clear the selector, except when
2025     ``ignore_event_outside=True``.
2026 
2027     Parameters
2028     ----------
2029     ax : `matplotlib.axes.Axes`
2030 
2031     onselect : callable
2032         A callback function that is called after a release event and the
2033         selection is created, changed or removed.
2034         It must have the signature::
2035 
2036             def on_select(min: float, max: float) -> Any
2037 
2038     direction : {"horizontal", "vertical"}
2039         The direction along which to draw the span selector.
2040 
2041     minspan : float, default: 0
2042         If selection is less than or equal to *minspan*, the selection is
2043         removed (when already existing) or cancelled.
2044 
2045     useblit : bool, default: False
2046         If True, use the backend-dependent blitting features for faster
2047         canvas updates.
2048 
2049     props : dict, optional
2050         Dictionary of `matplotlib.patches.Patch` properties.
2051         Default:
2052 
2053             ``dict(facecolor='red', alpha=0.5)``
2054 
2055     onmove_callback : func(min, max), min/max are floats, default: None
2056         Called on mouse move while the span is being selected.
2057 
2058     span_stays : bool, default: False
2059         If True, the span stays visible after the mouse is released.
2060         Deprecated, use *interactive* instead.
2061 
2062     interactive : bool, default: False
2063         Whether to draw a set of handles that allow interaction with the
2064         widget after it is drawn.
2065 
2066     button : `.MouseButton` or list of `.MouseButton`, default: all buttons
2067         The mouse buttons which activate the span selector.
2068 
2069     handle_props : dict, default: None
2070         Properties of the handle lines at the edges of the span. Only used
2071         when *interactive* is True. See `matplotlib.lines.Line2D` for valid
2072         properties.
2073 
2074     grab_range : float, default: 10
2075         Distance in pixels within which the interactive tool handles can be
2076         activated.
2077 
2078     drag_from_anywhere : bool, default: False
2079         If `True`, the widget can be moved by clicking anywhere within
2080         its bounds.
2081 
2082     ignore_event_outside : bool, default: False
2083         If `True`, the event triggered outside the span selector will be
2084         ignored.
2085 
2086     Examples
2087     --------
2088     >>> import matplotlib.pyplot as plt
2089     >>> import matplotlib.widgets as mwidgets
2090     >>> fig, ax = plt.subplots()
2091     >>> ax.plot([1, 2, 3], [10, 50, 100])
2092     >>> def onselect(vmin, vmax):
2093     ...     print(vmin, vmax)
2094     >>> span = mwidgets.SpanSelector(ax, onselect, 'horizontal',
2095     ...                              props=dict(facecolor='blue', alpha=0.5))
2096     >>> fig.show()
2097 
2098     See also: :doc:`/gallery/widgets/span_selector`
2099     """
2100 
2101     @_api.rename_parameter("3.5", "rectprops", "props")
2102     @_api.rename_parameter("3.5", "span_stays", "interactive")
2103     def __init__(self, ax, onselect, direction, minspan=0, useblit=False,
2104                  props=None, onmove_callback=None, interactive=False,
2105                  button=None, handle_props=None, grab_range=10,
2106                  drag_from_anywhere=False, ignore_event_outside=False):
2107 
2108         super().__init__(ax, onselect, useblit=useblit, button=button)
2109 
2110         if props is None:
2111             props = dict(facecolor='red', alpha=0.5)
2112 
2113         props['animated'] = self.useblit
2114 
2115         self.direction = direction
2116 
2117         self._rect = None
2118         self.visible = True
2119         self._extents_on_press = None
2120 
2121         # self._pressv is deprecated and we don't use it internally anymore
2122         # but we maintain it until it is removed
2123         self._pressv = None
2124 
2125         self._props = props
2126         self.onmove_callback = onmove_callback
2127         self.minspan = minspan
2128 
2129         self.grab_range = grab_range
2130         self._interactive = interactive
2131         self.drag_from_anywhere = drag_from_anywhere
2132         self.ignore_event_outside = ignore_event_outside
2133 
2134         # Reset canvas so that `new_axes` connects events.
2135         self.canvas = None
2136         self.artists = []
2137         self.new_axes(ax)
2138 
2139         # Setup handles
2140         handle_props = {
2141             'color': props.get('facecolor', 'r'),
2142             **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}
2143 
2144         if self._interactive:
2145             self._edge_order = ['min', 'max']
2146             self._setup_edge_handle(handle_props)
2147 
2148         self._active_handle = None
2149 
2150         # prev attribute is deprecated but we still need to maintain it
2151         self._prev = (0, 0)
2152 
2153     rect = _api.deprecate_privatize_attribute("3.5")
2154 
2155     rectprops = _api.deprecated("3.5")(
2156         property(lambda self: self._props)
2157         )
2158 
2159     active_handle = _api.deprecate_privatize_attribute("3.5")
2160 
2161     pressv = _api.deprecate_privatize_attribute("3.5")
2162 
2163     span_stays = _api.deprecated("3.5")(
2164         property(lambda self: self._interactive)
2165         )
2166 
2167     prev = _api.deprecate_privatize_attribute("3.5")
2168 
2169     def new_axes(self, ax):
2170         """Set SpanSelector to operate on a new Axes."""
2171         self.ax = ax
2172         if self.canvas is not ax.figure.canvas:
2173             if self.canvas is not None:
2174                 self.disconnect_events()
2175 
2176             self.canvas = ax.figure.canvas
2177             self.connect_default_events()
2178 
2179         # Reset
2180         self._selection_completed = False
2181 
2182         if self.direction == 'horizontal':
2183             trans = ax.get_xaxis_transform()
2184             w, h = 0, 1
2185         else:
2186             trans = ax.get_yaxis_transform()
2187             w, h = 1, 0
2188         self._rect = Rectangle((0, 0), w, h,
2189                                transform=trans,
2190                                visible=False,
2191                                **self._props)
2192 
2193         self.ax.add_patch(self._rect)
2194         if len(self.artists) > 0:
2195             self.artists[0] = self._rect
2196         else:
2197             self.artists.append(self._rect)
2198 
2199     def _setup_edge_handle(self, props):
2200         # Define initial position using the axis bounds to keep the same bounds
2201         if self.direction == 'horizontal':
2202             positions = self.ax.get_xbound()
2203         else:
2204             positions = self.ax.get_ybound()
2205         self._edge_handles = ToolLineHandles(self.ax, positions,
2206                                              direction=self.direction,
2207                                              line_props=props,
2208                                              useblit=self.useblit)
2209         self.artists.extend([line for line in self._edge_handles.artists])
2210 
2211     def _set_cursor(self, enabled):
2212         """Update the canvas cursor based on direction of the selector."""
2213         if enabled:
2214             cursor = (backend_tools.Cursors.RESIZE_HORIZONTAL
2215                       if self.direction == 'horizontal' else
2216                       backend_tools.Cursors.RESIZE_VERTICAL)
2217         else:
2218             cursor = backend_tools.Cursors.POINTER
2219 
2220         self.ax.figure.canvas.set_cursor(cursor)
2221 
2222     def connect_default_events(self):
2223         # docstring inherited
2224         super().connect_default_events()
2225         if getattr(self, '_interactive', False):
2226             self.connect_event('motion_notify_event', self._hover)
2227 
2228     def _press(self, event):
2229         """Button press event handler."""
2230         self._set_cursor(True)
2231         if self._interactive and self._rect.get_visible():
2232             self._set_active_handle(event)
2233         else:
2234             self._active_handle = None
2235 
2236         if self._active_handle is None or not self._interactive:
2237             # Clear previous rectangle before drawing new rectangle.
2238             self.update()
2239 
2240         v = event.xdata if self.direction == 'horizontal' else event.ydata
2241         # self._pressv and self._prev are deprecated but we still need to
2242         # maintain them
2243         self._pressv = v
2244         self._prev = self._get_data(event)
2245 
2246         if self._active_handle is None and not self.ignore_event_outside:
2247             # when the press event outside the span, we initially set the
2248             # visibility to False and extents to (v, v)
2249             # update will be called when setting the extents
2250             self.visible = False
2251             self.extents = v, v
2252             # We need to set the visibility back, so the span selector will be
2253             # drawn when necessary (span width > 0)
2254             self.visible = True
2255         else:
2256             self.set_visible(True)
2257 
2258         return False
2259 
2260     @property
2261     def direction(self):
2262         """Direction of the span selector: 'vertical' or 'horizontal'."""
2263         return self._direction
2264 
2265     @direction.setter
2266     def direction(self, direction):
2267         """Set the direction of the span selector."""
2268         _api.check_in_list(['horizontal', 'vertical'], direction=direction)
2269         if hasattr(self, '_direction') and direction != self._direction:
2270             # remove previous artists
2271             self._rect.remove()
2272             if self._interactive:
2273                 self._edge_handles.remove()
2274                 for artist in self._edge_handles.artists:
2275                     self.artists.remove(artist)
2276             self._direction = direction
2277             self.new_axes(self.ax)
2278             if self._interactive:
2279                 self._setup_edge_handle(self._edge_handles._line_props)
2280         else:
2281             self._direction = direction
2282 
2283     def _release(self, event):
2284         """Button release event handler."""
2285         self._set_cursor(False)
2286         # self._pressv is deprecated but we still need to maintain it
2287         self._pressv = None
2288 
2289         if not self._interactive:
2290             self._rect.set_visible(False)
2291 
2292         if (self._active_handle is None and self._selection_completed and
2293                 self.ignore_event_outside):
2294             return
2295 
2296         vmin, vmax = self.extents
2297         span = vmax - vmin
2298 
2299         if span <= self.minspan:
2300             # Remove span and set self._selection_completed = False
2301             self.set_visible(False)
2302             if self._selection_completed:
2303                 # Call onselect, only when the span is already existing
2304                 self.onselect(vmin, vmax)
2305             self._selection_completed = False
2306         else:
2307             self.onselect(vmin, vmax)
2308             self._selection_completed = True
2309 
2310         self.update()
2311 
2312         self._active_handle = None
2313 
2314         return False
2315 
2316     def _hover(self, event):
2317         """Update the canvas cursor if it's over a handle."""
2318         if self.ignore(event):
2319             return
2320 
2321         if self._active_handle is not None:
2322             # Do nothing if button is pressed and a handle is active, which may
2323             # occur with drag_from_anywhere=True.
2324             return
2325 
2326         _, e_dist = self._edge_handles.closest(event.x, event.y)
2327         self._set_cursor(e_dist <= self.grab_range)
2328 
2329     def _onmove(self, event):
2330         """Motion notify event handler."""
2331 
2332         # self._prev are deprecated but we still need to maintain it
2333         self._prev = self._get_data(event)
2334 
2335         v = event.xdata if self.direction == 'horizontal' else event.ydata
2336         if self.direction == 'horizontal':
2337             vpress = self._eventpress.xdata
2338         else:
2339             vpress = self._eventpress.ydata
2340 
2341         # move existing span
2342         # When "dragging from anywhere", `self._active_handle` is set to 'C'
2343         # (match notation used in the RectangleSelector)
2344         if self._active_handle == 'C' and self._extents_on_press is not None:
2345             vmin, vmax = self._extents_on_press
2346             dv = v - vpress
2347             vmin += dv
2348             vmax += dv
2349 
2350         # resize an existing shape
2351         elif self._active_handle and self._active_handle != 'C':
2352             vmin, vmax = self._extents_on_press
2353             if self._active_handle == 'min':
2354                 vmin = v
2355             else:
2356                 vmax = v
2357         # new shape
2358         else:
2359             # Don't create a new span if there is already one when
2360             # ignore_event_outside=True
2361             if self.ignore_event_outside and self._selection_completed:
2362                 return
2363             vmin, vmax = vpress, v
2364             if vmin > vmax:
2365                 vmin, vmax = vmax, vmin
2366 
2367         self.extents = vmin, vmax
2368 
2369         if self.onmove_callback is not None:
2370             self.onmove_callback(vmin, vmax)
2371 
2372         return False
2373 
2374     def _draw_shape(self, vmin, vmax):
2375         if vmin > vmax:
2376             vmin, vmax = vmax, vmin
2377         if self.direction == 'horizontal':
2378             self._rect.set_x(vmin)
2379             self._rect.set_width(vmax - vmin)
2380         else:
2381             self._rect.set_y(vmin)
2382             self._rect.set_height(vmax - vmin)
2383 
2384     def _set_active_handle(self, event):
2385         """Set active handle based on the location of the mouse event."""
2386         # Note: event.xdata/ydata in data coordinates, event.x/y in pixels
2387         e_idx, e_dist = self._edge_handles.closest(event.x, event.y)
2388 
2389         # Prioritise center handle over other handles
2390         # Use 'C' to match the notation used in the RectangleSelector
2391         if 'move' in self._state:
2392             self._active_handle = 'C'
2393         elif e_dist > self.grab_range:
2394             # Not close to any handles
2395             self._active_handle = None
2396             if self.drag_from_anywhere and self._contains(event):
2397                 # Check if we've clicked inside the region
2398                 self._active_handle = 'C'
2399                 self._extents_on_press = self.extents
2400             else:
2401                 self._active_handle = None
2402                 return
2403         else:
2404             # Closest to an edge handle
2405             self._active_handle = self._edge_order[e_idx]
2406 
2407         # Save coordinates of rectangle at the start of handle movement.
2408         self._extents_on_press = self.extents
2409 
2410     def _contains(self, event):
2411         """Return True if event is within the patch."""
2412         return self._rect.contains(event, radius=0)[0]
2413 
2414     @property
2415     def extents(self):
2416         """Return extents of the span selector."""
2417         if self.direction == 'horizontal':
2418             vmin = self._rect.get_x()
2419             vmax = vmin + self._rect.get_width()
2420         else:
2421             vmin = self._rect.get_y()
2422             vmax = vmin + self._rect.get_height()
2423         return vmin, vmax
2424 
2425     @extents.setter
2426     def extents(self, extents):
2427         # Update displayed shape
2428         self._draw_shape(*extents)
2429         if self._interactive:
2430             # Update displayed handles
2431             self._edge_handles.set_data(self.extents)
2432         self.set_visible(self.visible)
2433         self.update()
2434 
2435 
2436 class ToolLineHandles:
2437     """
2438     Control handles for canvas tools.
2439 
2440     Parameters
2441     ----------
2442     ax : `matplotlib.axes.Axes`
2443         Matplotlib axes where tool handles are displayed.
2444     positions : 1D array
2445         Positions of handles in data coordinates.
2446     direction : {"horizontal", "vertical"}
2447         Direction of handles, either 'vertical' or 'horizontal'
2448     line_props : dict, optional
2449         Additional line properties. See `matplotlib.lines.Line2D`.
2450     useblit : bool, default: True
2451         Whether to use blitting for faster drawing (if supported by the
2452         backend).
2453     """
2454 
2455     def __init__(self, ax, positions, direction, line_props=None,
2456                  useblit=True):
2457         self.ax = ax
2458 
2459         _api.check_in_list(['horizontal', 'vertical'], direction=direction)
2460         self._direction = direction
2461 
2462         if line_props is None:
2463             line_props = {}
2464         line_props.update({'visible': False, 'animated': useblit})
2465 
2466         line_fun = ax.axvline if self.direction == 'horizontal' else ax.axhline
2467         self._line_props = line_props
2468 
2469         self.artists = [line_fun(p, **line_props) for p in positions]
2470 
2471     @property
2472     def positions(self):
2473         """Positions of the handle in data coordinates."""
2474         method = 'get_xdata' if self.direction == 'horizontal' else 'get_ydata'
2475         return [getattr(line, method)()[0] for line in self.artists]
2476 
2477     @property
2478     def direction(self):
2479         """Direction of the handle: 'vertical' or 'horizontal'."""
2480         return self._direction
2481 
2482     def set_data(self, positions):
2483         """
2484         Set x or y positions of handles, depending if the lines are vertical
2485         of horizontal.
2486 
2487         Parameters
2488         ----------
2489         positions : tuple of length 2
2490             Set the positions of the handle in data coordinates
2491         """
2492         method = 'set_xdata' if self.direction == 'horizontal' else 'set_ydata'
2493         for line, p in zip(self.artists, positions):
2494             getattr(line, method)([p, p])
2495 
2496     def set_visible(self, value):
2497         """Set the visibility state of the handles artist."""
2498         for artist in self.artists:
2499             artist.set_visible(value)
2500 
2501     def set_animated(self, value):
2502         """Set the animated state of the handles artist."""
2503         for artist in self.artists:
2504             artist.set_animated(value)
2505 
2506     def remove(self):
2507         """Remove the handles artist from the figure."""
2508         for artist in self.artists:
2509             artist.remove()
2510 
2511     def closest(self, x, y):
2512         """
2513         Return index and pixel distance to closest handle.
2514 
2515         Parameters
2516         ----------
2517         x, y : float
2518             x, y position from which the distance will be calculated to
2519             determinate the closest handle
2520 
2521         Returns
2522         -------
2523         index, distance : index of the handle and its distance from
2524             position x, y
2525         """
2526         if self.direction == 'horizontal':
2527             p_pts = np.array([
2528                 self.ax.transData.transform((p, 0))[0] for p in self.positions
2529                 ])
2530             dist = abs(p_pts - x)
2531         else:
2532             p_pts = np.array([
2533                 self.ax.transData.transform((0, p))[1] for p in self.positions
2534                 ])
2535             dist = abs(p_pts - y)
2536         index = np.argmin(dist)
2537         return index, dist[index]
2538 
2539 
2540 class ToolHandles:
2541     """
2542     Control handles for canvas tools.
2543 
2544     Parameters
2545     ----------
2546     ax : `matplotlib.axes.Axes`
2547         Matplotlib axes where tool handles are displayed.
2548     x, y : 1D arrays
2549         Coordinates of control handles.
2550     marker : str, default: 'o'
2551         Shape of marker used to display handle. See `matplotlib.pyplot.plot`.
2552     marker_props : dict, optional
2553         Additional marker properties. See `matplotlib.lines.Line2D`.
2554     useblit : bool, default: True
2555         Whether to use blitting for faster drawing (if supported by the
2556         backend).
2557     """
2558 
2559     def __init__(self, ax, x, y, marker='o', marker_props=None, useblit=True):
2560         self.ax = ax
2561         props = {'marker': marker, 'markersize': 7, 'markerfacecolor': 'w',
2562                  'linestyle': 'none', 'alpha': 0.5, 'visible': False,
2563                  'label': '_nolegend_',
2564                  **cbook.normalize_kwargs(marker_props, Line2D._alias_map)}
2565         self._markers = Line2D(x, y, animated=useblit, **props)
2566         self.ax.add_line(self._markers)
2567         self.artist = self._markers
2568 
2569     @property
2570     def x(self):
2571         return self._markers.get_xdata()
2572 
2573     @property
2574     def y(self):
2575         return self._markers.get_ydata()
2576 
2577     def set_data(self, pts, y=None):
2578         """Set x and y positions of handles."""
2579         if y is not None:
2580             x = pts
2581             pts = np.array([x, y])
2582         self._markers.set_data(pts)
2583 
2584     def set_visible(self, val):
2585         self._markers.set_visible(val)
2586 
2587     def set_animated(self, val):
2588         self._markers.set_animated(val)
2589 
2590     def closest(self, x, y):
2591         """Return index and pixel distance to closest index."""
2592         pts = np.column_stack([self.x, self.y])
2593         # Transform data coordinates to pixel coordinates.
2594         pts = self.ax.transData.transform(pts)
2595         diff = pts - [x, y]
2596         dist = np.hypot(*diff.T)
2597         min_index = np.argmin(dist)
2598         return min_index, dist[min_index]
2599 
2600 
2601 _RECTANGLESELECTOR_PARAMETERS_DOCSTRING = \
2602     r"""
2603     Parameters
2604     ----------
2605     ax : `~matplotlib.axes.Axes`
2606         The parent axes for the widget.
2607 
2608     onselect : function
2609         A callback function that is called after a release event and the
2610         selection is created, changed or removed.
2611         It must have the signature::
2612 
2613             def onselect(eclick: MouseEvent, erelease: MouseEvent)
2614 
2615         where *eclick* and *erelease* are the mouse click and release
2616         `.MouseEvent`\s that start and complete the selection.
2617 
2618     minspanx : float, default: 0
2619         Selections with an x-span less than or equal to *minspanx* are removed
2620         (when already existing) or cancelled.
2621 
2622     minspany : float, default: 0
2623         Selections with an y-span less than or equal to *minspanx* are removed
2624         (when already existing) or cancelled.
2625 
2626     useblit : bool, default: False
2627         Whether to use blitting for faster drawing (if supported by the
2628         backend).
2629 
2630     props : dict, optional
2631         Properties with which the __ARTIST_NAME__ is drawn. See
2632         `matplotlib.patches.Patch` for valid properties.
2633         Default:
2634 
2635         ``dict(facecolor='red', edgecolor='black', alpha=0.2, fill=True)``
2636 
2637     spancoords : {"data", "pixels"}, default: "data"
2638         Whether to interpret *minspanx* and *minspany* in data or in pixel
2639         coordinates.
2640 
2641     button : `.MouseButton`, list of `.MouseButton`, default: all buttons
2642         Button(s) that trigger rectangle selection.
2643 
2644     grab_range : float, default: 10
2645         Distance in pixels within which the interactive tool handles can be
2646         activated.
2647 
2648     handle_props : dict, optional
2649         Properties with which the interactive handles (marker artists) are
2650         drawn. See the marker arguments in `matplotlib.lines.Line2D` for valid
2651         properties.  Default values are defined in ``mpl.rcParams`` except for
2652         the default value of ``markeredgecolor`` which will be the same as the
2653         ``edgecolor`` property in *props*.
2654 
2655     interactive : bool, default: False
2656         Whether to draw a set of handles that allow interaction with the
2657         widget after it is drawn.
2658 
2659     state_modifier_keys : dict, optional
2660         Keyboard modifiers which affect the widget's behavior.  Values
2661         amend the defaults.
2662 
2663         - "move": Move the existing shape, default: no modifier.
2664         - "clear": Clear the current shape, default: "escape".
2665         - "square": Makes the shape square, default: "shift".
2666         - "center": Make the initial point the center of the shape,
2667           default: "ctrl".
2668 
2669         "square" and "center" can be combined.
2670 
2671     drag_from_anywhere : bool, default: False
2672         If `True`, the widget can be moved by clicking anywhere within
2673         its bounds.
2674 
2675     ignore_event_outside : bool, default: False
2676         If `True`, the event triggered outside the span selector will be
2677         ignored.
2678 
2679     """
2680 
2681 
2682 @docstring.Substitution(_RECTANGLESELECTOR_PARAMETERS_DOCSTRING.replace(
2683     '__ARTIST_NAME__', 'rectangle'))
2684 class RectangleSelector(_SelectorWidget):
2685     """
2686     Select a rectangular region of an axes.
2687 
2688     For the cursor to remain responsive you must keep a reference to it.
2689 
2690     Press and release events triggered at the same coordinates outside the
2691     selection will clear the selector, except when
2692     ``ignore_event_outside=True``.
2693 
2694     %s
2695 
2696     Examples
2697     --------
2698     >>> import matplotlib.pyplot as plt
2699     >>> import matplotlib.widgets as mwidgets
2700     >>> fig, ax = plt.subplots()
2701     >>> ax.plot([1, 2, 3], [10, 50, 100])
2702     >>> def onselect(eclick, erelease):
2703     ...     print(eclick.xdata, eclick.ydata)
2704     ...     print(erelease.xdata, erelease.ydata)
2705     >>> props = dict(facecolor='blue', alpha=0.5)
2706     >>> rect = mwidgets.RectangleSelector(ax, onselect, interactive=True,
2707                                           props=props)
2708     >>> fig.show()
2709 
2710     See also: :doc:`/gallery/widgets/rectangle_selector`
2711     """
2712 
2713     _shape_klass = Rectangle
2714 
2715     @_api.rename_parameter("3.5", "maxdist", "grab_range")
2716     @_api.rename_parameter("3.5", "marker_props", "handle_props")
2717     @_api.rename_parameter("3.5", "rectprops", "props")
2718     @_api.delete_parameter("3.5", "drawtype")
2719     @_api.delete_parameter("3.5", "lineprops")
2720     def __init__(self, ax, onselect, drawtype='box',
2721                  minspanx=0, minspany=0, useblit=False,
2722                  lineprops=None, props=None, spancoords='data',
2723                  button=None, grab_range=10, handle_props=None,
2724                  interactive=False, state_modifier_keys=None,
2725                  drag_from_anywhere=False, ignore_event_outside=False):
2726         super().__init__(ax, onselect, useblit=useblit, button=button,
2727                          state_modifier_keys=state_modifier_keys)
2728 
2729         self._to_draw = None
2730         self.visible = True
2731         self._interactive = interactive
2732         self.drag_from_anywhere = drag_from_anywhere
2733         self.ignore_event_outside = ignore_event_outside
2734 
2735         if drawtype == 'none':  # draw a line but make it invisible
2736             _api.warn_deprecated(
2737                 "3.5", message="Support for drawtype='none' is deprecated "
2738                                "since %(since)s and will be removed "
2739                                "%(removal)s."
2740                                "Use props=dict(visible=False) instead.")
2741             drawtype = 'line'
2742             self.visible = False
2743 
2744         if drawtype == 'box':
2745             if props is None:
2746                 props = dict(facecolor='red', edgecolor='black',
2747                              alpha=0.2, fill=True)
2748             props['animated'] = self.useblit
2749             _props = props
2750             self.visible = _props.pop('visible', self.visible)
2751             self._to_draw = self._shape_klass((0, 0), 0, 1, visible=False,
2752                                               **_props)
2753             self.ax.add_patch(self._to_draw)
2754         if drawtype == 'line':
2755             _api.warn_deprecated(
2756                 "3.5", message="Support for drawtype='line' is deprecated "
2757                                "since %(since)s and will be removed "
2758                                "%(removal)s.")
2759             if lineprops is None:
2760                 lineprops = dict(color='black', linestyle='-',
2761                                  linewidth=2, alpha=0.5)
2762             lineprops['animated'] = self.useblit
2763             self.lineprops = lineprops
2764             self._to_draw = Line2D([0, 0], [0, 0], visible=False,
2765                                    **self.lineprops)
2766             self.ax.add_line(self._to_draw)
2767 
2768         self.minspanx = minspanx
2769         self.minspany = minspany
2770 
2771         _api.check_in_list(['data', 'pixels'], spancoords=spancoords)
2772         self.spancoords = spancoords
2773         self._drawtype = drawtype
2774 
2775         self.grab_range = grab_range
2776 
2777         handle_props = {
2778             'markeredgecolor': (props or {}).get('edgecolor', 'black'),
2779             **cbook.normalize_kwargs(handle_props, Line2D._alias_map)}
2780 
2781         self._corner_order = ['NW', 'NE', 'SE', 'SW']
2782         xc, yc = self.corners
2783         self._corner_handles = ToolHandles(self.ax, xc, yc,
2784                                            marker_props=handle_props,
2785                                            useblit=self.useblit)
2786 
2787         self._edge_order = ['W', 'N', 'E', 'S']
2788         xe, ye = self.edge_centers
2789         self._edge_handles = ToolHandles(self.ax, xe, ye, marker='s',
2790                                          marker_props=handle_props,
2791                                          useblit=self.useblit)
2792 
2793         xc, yc = self.center
2794         self._center_handle = ToolHandles(self.ax, [xc], [yc], marker='s',
2795                                           marker_props=handle_props,
2796                                           useblit=self.useblit)
2797 
2798         self._active_handle = None
2799 
2800         self.artists = [self._to_draw, self._center_handle.artist,
2801                         self._corner_handles.artist,
2802                         self._edge_handles.artist]
2803 
2804         if not self._interactive:
2805             self.artists = [self._to_draw]
2806 
2807         self._extents_on_press = None
2808 
2809     to_draw = _api.deprecate_privatize_attribute("3.5")
2810 
2811     drawtype = _api.deprecate_privatize_attribute("3.5")
2812 
2813     active_handle = _api.deprecate_privatize_attribute("3.5")
2814 
2815     interactive = _api.deprecate_privatize_attribute("3.5")
2816 
2817     maxdist = _api.deprecated("3.5", name="maxdist", alternative="grab_range")(
2818         property(lambda self: self.grab_range,
2819                  lambda self, value: setattr(self, "grab_range", value)))
2820 
2821     def _press(self, event):
2822         """Button press event handler."""
2823         # make the drawn box/line visible get the click-coordinates,
2824         # button, ...
2825         if self._interactive and self._to_draw.get_visible():
2826             self._set_active_handle(event)
2827         else:
2828             self._active_handle = None
2829 
2830         if self._active_handle is None or not self._interactive:
2831             # Clear previous rectangle before drawing new rectangle.
2832             self.update()
2833 
2834         if self._active_handle is None and not self.ignore_event_outside:
2835             x = event.xdata
2836             y = event.ydata
2837             self.visible = False
2838             self.extents = x, x, y, y
2839             self.visible = True
2840         else:
2841             self.set_visible(True)
2842 
2843         return False
2844 
2845     def _release(self, event):
2846         """Button release event handler."""
2847         if not self._interactive:
2848             self._to_draw.set_visible(False)
2849 
2850         if (self._active_handle is None and self._selection_completed and
2851                 self.ignore_event_outside):
2852             return
2853 
2854         # update the eventpress and eventrelease with the resulting extents
2855         x0, x1, y0, y1 = self.extents
2856         self._eventpress.xdata = x0
2857         self._eventpress.ydata = y0
2858         xy0 = self.ax.transData.transform([x0, y0])
2859         self._eventpress.x, self._eventpress.y = xy0
2860 
2861         self._eventrelease.xdata = x1
2862         self._eventrelease.ydata = y1
2863         xy1 = self.ax.transData.transform([x1, y1])
2864         self._eventrelease.x, self._eventrelease.y = xy1
2865 
2866         # calculate dimensions of box or line
2867         if self.spancoords == 'data':
2868             spanx = abs(self._eventpress.xdata - self._eventrelease.xdata)
2869             spany = abs(self._eventpress.ydata - self._eventrelease.ydata)
2870         elif self.spancoords == 'pixels':
2871             spanx = abs(self._eventpress.x - self._eventrelease.x)
2872             spany = abs(self._eventpress.y - self._eventrelease.y)
2873         else:
2874             _api.check_in_list(['data', 'pixels'],
2875                                spancoords=self.spancoords)
2876         # check if drawn distance (if it exists) is not too small in
2877         # either x or y-direction
2878         minspanxy = (spanx <= self.minspanx or spany <= self.minspany)
2879         if (self._drawtype != 'none' and minspanxy):
2880             for artist in self.artists:
2881                 artist.set_visible(False)
2882             if self._selection_completed:
2883                 # Call onselect, only when the selection is already existing
2884                 self.onselect(self._eventpress, self._eventrelease)
2885             self._selection_completed = False
2886         else:
2887             self.onselect(self._eventpress, self._eventrelease)
2888             self._selection_completed = True
2889 
2890         self.update()
2891         self._active_handle = None
2892 
2893         return False
2894 
2895     def _onmove(self, event):
2896         """Motion notify event handler."""
2897         # resize an existing shape
2898         if self._active_handle and self._active_handle != 'C':
2899             x0, x1, y0, y1 = self._extents_on_press
2900             if self._active_handle in ['E', 'W'] + self._corner_order:
2901                 x1 = event.xdata
2902             if self._active_handle in ['N', 'S'] + self._corner_order:
2903                 y1 = event.ydata
2904 
2905         # move existing shape
2906         elif (('move' in self._state or self._active_handle == 'C' or
2907                (self.drag_from_anywhere and self._contains(event))) and
2908               self._extents_on_press is not None):
2909             x0, x1, y0, y1 = self._extents_on_press
2910             dx = event.xdata - self._eventpress.xdata
2911             dy = event.ydata - self._eventpress.ydata
2912             x0 += dx
2913             x1 += dx
2914             y0 += dy
2915             y1 += dy
2916 
2917         # new shape
2918         else:
2919             # Don't create a new rectangle if there is already one when
2920             # ignore_event_outside=True
2921             if self.ignore_event_outside and self._selection_completed:
2922                 return
2923             center = [self._eventpress.xdata, self._eventpress.ydata]
2924             center_pix = [self._eventpress.x, self._eventpress.y]
2925             dx = (event.xdata - center[0]) / 2.
2926             dy = (event.ydata - center[1]) / 2.
2927 
2928             # square shape
2929             if 'square' in self._state:
2930                 dx_pix = abs(event.x - center_pix[0])
2931                 dy_pix = abs(event.y - center_pix[1])
2932                 if not dx_pix:
2933                     return
2934                 maxd = max(abs(dx_pix), abs(dy_pix))
2935                 if abs(dx_pix) < maxd:
2936                     dx *= maxd / (abs(dx_pix) + 1e-6)
2937                 if abs(dy_pix) < maxd:
2938                     dy *= maxd / (abs(dy_pix) + 1e-6)
2939 
2940             # from center
2941             if 'center' in self._state:
2942                 dx *= 2
2943                 dy *= 2
2944 
2945             # from corner
2946             else:
2947                 center[0] += dx
2948                 center[1] += dy
2949 
2950             x0, x1, y0, y1 = (center[0] - dx, center[0] + dx,
2951                               center[1] - dy, center[1] + dy)
2952 
2953         self.extents = x0, x1, y0, y1
2954 
2955     @property
2956     def _rect_bbox(self):
2957         if self._drawtype == 'box':
2958             x0 = self._to_draw.get_x()
2959             y0 = self._to_draw.get_y()
2960             width = self._to_draw.get_width()
2961             height = self._to_draw.get_height()
2962             return x0, y0, width, height
2963         else:
2964             x, y = self._to_draw.get_data()
2965             x0, x1 = min(x), max(x)
2966             y0, y1 = min(y), max(y)
2967             return x0, y0, x1 - x0, y1 - y0
2968 
2969     @property
2970     def corners(self):
2971         """Corners of rectangle from lower left, moving clockwise."""
2972         x0, y0, width, height = self._rect_bbox
2973         xc = x0, x0 + width, x0 + width, x0
2974         yc = y0, y0, y0 + height, y0 + height
2975         return xc, yc
2976 
2977     @property
2978     def edge_centers(self):
2979         """Midpoint of rectangle edges from left, moving anti-clockwise."""
2980         x0, y0, width, height = self._rect_bbox
2981         w = width / 2.
2982         h = height / 2.
2983         xe = x0, x0 + w, x0 + width, x0 + w
2984         ye = y0 + h, y0, y0 + h, y0 + height
2985         return xe, ye
2986 
2987     @property
2988     def center(self):
2989         """Center of rectangle."""
2990         x0, y0, width, height = self._rect_bbox
2991         return x0 + width / 2., y0 + height / 2.
2992 
2993     @property
2994     def extents(self):
2995         """Return (xmin, xmax, ymin, ymax)."""
2996         x0, y0, width, height = self._rect_bbox
2997         xmin, xmax = sorted([x0, x0 + width])
2998         ymin, ymax = sorted([y0, y0 + height])
2999         return xmin, xmax, ymin, ymax
3000 
3001     @extents.setter
3002     def extents(self, extents):
3003         # Update displayed shape
3004         self._draw_shape(extents)
3005         # Update displayed handles
3006         self._corner_handles.set_data(*self.corners)
3007         self._edge_handles.set_data(*self.edge_centers)
3008         self._center_handle.set_data(*self.center)
3009         self.set_visible(self.visible)
3010         self.update()
3011 
3012     draw_shape = _api.deprecate_privatize_attribute('3.5')
3013 
3014     def _draw_shape(self, extents):
3015         x0, x1, y0, y1 = extents
3016         xmin, xmax = sorted([x0, x1])
3017         ymin, ymax = sorted([y0, y1])
3018         xlim = sorted(self.ax.get_xlim())
3019         ylim = sorted(self.ax.get_ylim())
3020 
3021         xmin = max(xlim[0], xmin)
3022         ymin = max(ylim[0], ymin)
3023         xmax = min(xmax, xlim[1])
3024         ymax = min(ymax, ylim[1])
3025 
3026         if self._drawtype == 'box':
3027             self._to_draw.set_x(xmin)
3028             self._to_draw.set_y(ymin)
3029             self._to_draw.set_width(xmax - xmin)
3030             self._to_draw.set_height(ymax - ymin)
3031 
3032         elif self._drawtype == 'line':
3033             self._to_draw.set_data([xmin, xmax], [ymin, ymax])
3034 
3035     def _set_active_handle(self, event):
3036         """Set active handle based on the location of the mouse event."""
3037         # Note: event.xdata/ydata in data coordinates, event.x/y in pixels
3038         c_idx, c_dist = self._corner_handles.closest(event.x, event.y)
3039         e_idx, e_dist = self._edge_handles.closest(event.x, event.y)
3040         m_idx, m_dist = self._center_handle.closest(event.x, event.y)
3041 
3042         if 'move' in self._state:
3043             self._active_handle = 'C'
3044             self._extents_on_press = self.extents
3045         # Set active handle as closest handle, if mouse click is close enough.
3046         elif m_dist < self.grab_range * 2:
3047             # Prioritise center handle over other handles
3048             self._active_handle = 'C'
3049         elif (c_dist > self.grab_range and
3050                   e_dist > self.grab_range):
3051             # Not close to any handles
3052             if self.drag_from_anywhere and self._contains(event):
3053                 # Check if we've clicked inside the region
3054                 self._active_handle = 'C'
3055                 self._extents_on_press = self.extents
3056             else:
3057                 self._active_handle = None
3058                 return
3059         elif c_dist < e_dist:
3060             # Closest to a corner handle
3061             self._active_handle = self._corner_order[c_idx]
3062         else:
3063             # Closest to an edge handle
3064             self._active_handle = self._edge_order[e_idx]
3065 
3066         # Save coordinates of rectangle at the start of handle movement.
3067         x0, x1, y0, y1 = self.extents
3068         # Switch variables so that only x1 and/or y1 are updated on move.
3069         if self._active_handle in ['W', 'SW', 'NW']:
3070             x0, x1 = x1, event.xdata
3071         if self._active_handle in ['N', 'NW', 'NE']:
3072             y0, y1 = y1, event.ydata
3073         self._extents_on_press = x0, x1, y0, y1
3074 
3075     def _contains(self, event):
3076         """Return True if event is within the patch."""
3077         return self._to_draw.contains(event, radius=0)[0]
3078 
3079     @property
3080     def geometry(self):
3081         """
3082         Return an array of shape (2, 5) containing the
3083         x (``RectangleSelector.geometry[1, :]``) and
3084         y (``RectangleSelector.geometry[0, :]``) coordinates
3085         of the four corners of the rectangle starting and ending
3086         in the top left corner.
3087         """
3088         if hasattr(self._to_draw, 'get_verts'):
3089             xfm = self.ax.transData.inverted()
3090             y, x = xfm.transform(self._to_draw.get_verts()).T
3091             return np.array([x, y])
3092         else:
3093             return np.array(self._to_draw.get_data())
3094 
3095 
3096 @docstring.Substitution(_RECTANGLESELECTOR_PARAMETERS_DOCSTRING.replace(
3097     '__ARTIST_NAME__', 'ellipse'))
3098 class EllipseSelector(RectangleSelector):
3099     """
3100     Select an elliptical region of an axes.
3101 
3102     For the cursor to remain responsive you must keep a reference to it.
3103 
3104     Press and release events triggered at the same coordinates outside the
3105     selection will clear the selector, except when
3106     ``ignore_event_outside=True``.
3107 
3108     %s
3109 
3110     Examples
3111     --------
3112     :doc:`/gallery/widgets/rectangle_selector`
3113     """
3114 
3115     _shape_klass = Ellipse
3116     draw_shape = _api.deprecate_privatize_attribute('3.5')
3117 
3118     def _draw_shape(self, extents):
3119         x0, x1, y0, y1 = extents
3120         xmin, xmax = sorted([x0, x1])
3121         ymin, ymax = sorted([y0, y1])
3122         center = [x0 + (x1 - x0) / 2., y0 + (y1 - y0) / 2.]
3123         a = (xmax - xmin) / 2.
3124         b = (ymax - ymin) / 2.
3125 
3126         if self._drawtype == 'box':
3127             self._to_draw.center = center
3128             self._to_draw.width = 2 * a
3129             self._to_draw.height = 2 * b
3130         else:
3131             rad = np.deg2rad(np.arange(31) * 12)
3132             x = a * np.cos(rad) + center[0]
3133             y = b * np.sin(rad) + center[1]
3134             self._to_draw.set_data(x, y)
3135 
3136     @property
3137     def _rect_bbox(self):
3138         if self._drawtype == 'box':
3139             x, y = self._to_draw.center
3140             width = self._to_draw.width
3141             height = self._to_draw.height
3142             return x - width / 2., y - height / 2., width, height
3143         else:
3144             x, y = self._to_draw.get_data()
3145             x0, x1 = min(x), max(x)
3146             y0, y1 = min(y), max(y)
3147             return x0, y0, x1 - x0, y1 - y0
3148 
3149 
3150 class LassoSelector(_SelectorWidget):
3151     """
3152     Selection curve of an arbitrary shape.
3153 
3154     For the selector to remain responsive you must keep a reference to it.
3155 
3156     The selected path can be used in conjunction with `~.Path.contains_point`
3157     to select data points from an image.
3158 
3159     In contrast to `Lasso`, `LassoSelector` is written with an interface
3160     similar to `RectangleSelector` and `SpanSelector`, and will continue to
3161     interact with the axes until disconnected.
3162 
3163     Example usage::
3164 
3165         ax = plt.subplot()
3166         ax.plot(x, y)
3167 
3168         def onselect(verts):
3169             print(verts)
3170         lasso = LassoSelector(ax, onselect)
3171 
3172     Parameters
3173     ----------
3174     ax : `~matplotlib.axes.Axes`
3175         The parent axes for the widget.
3176     onselect : function
3177         Whenever the lasso is released, the *onselect* function is called and
3178         passed the vertices of the selected path.
3179     useblit : bool, default: True
3180         Whether to use blitting for faster drawing (if supported by the
3181         backend).
3182     props : dict, optional
3183         Properties with which the line is drawn, see `matplotlib.lines.Line2D`
3184         for valid properties. Default values are defined in ``mpl.rcParams``.
3185     button : `.MouseButton` or list of `.MouseButton`, optional
3186         The mouse buttons used for rectangle selection.  Default is ``None``,
3187         which corresponds to all buttons.
3188     """
3189 
3190     @_api.rename_parameter("3.5", "lineprops", "props")
3191     def __init__(self, ax, onselect=None, useblit=True, props=None,
3192                  button=None):
3193         super().__init__(ax, onselect, useblit=useblit, button=button)
3194         self.verts = None
3195         if props is None:
3196             props = dict()
3197         # self.useblit may be != useblit, if the canvas doesn't support blit.
3198         props.update(animated=self.useblit, visible=False)
3199         self.line = Line2D([], [], **props)
3200         self.ax.add_line(self.line)
3201         self.artists = [self.line]
3202 
3203     @_api.deprecated("3.5", alternative="press")
3204     def onpress(self, event):
3205         self.press(event)
3206 
3207     def _press(self, event):
3208         self.verts = [self._get_data(event)]
3209         self.line.set_visible(True)
3210 
3211     @_api.deprecated("3.5", alternative="release")
3212     def onrelease(self, event):
3213         self.release(event)
3214 
3215     def _release(self, event):
3216         if self.verts is not None:
3217             self.verts.append(self._get_data(event))
3218             self.onselect(self.verts)
3219         self.line.set_data([[], []])
3220         self.line.set_visible(False)
3221         self.verts = None
3222 
3223     def _onmove(self, event):
3224         if self.verts is None:
3225             return
3226         self.verts.append(self._get_data(event))
3227         self.line.set_data(list(zip(*self.verts)))
3228         self.update()
3229 
3230 
3231 class PolygonSelector(_SelectorWidget):
3232     """
3233     Select a polygon region of an axes.
3234 
3235     Place vertices with each mouse click, and make the selection by completing
3236     the polygon (clicking on the first vertex). Once drawn individual vertices
3237     can be moved by clicking and dragging with the left mouse button, or
3238     removed by clicking the right mouse button.
3239 
3240     In addition, the following modifier keys can be used:
3241 
3242     - Hold *ctrl* and click and drag a vertex to reposition it before the
3243       polygon has been completed.
3244     - Hold the *shift* key and click and drag anywhere in the axes to move
3245       all vertices.
3246     - Press the *esc* key to start a new polygon.
3247 
3248     For the selector to remain responsive you must keep a reference to it.
3249 
3250     Parameters
3251     ----------
3252     ax : `~matplotlib.axes.Axes`
3253         The parent axes for the widget.
3254 
3255     onselect : function
3256         When a polygon is completed or modified after completion,
3257         the *onselect* function is called and passed a list of the vertices as
3258         ``(xdata, ydata)`` tuples.
3259 
3260     useblit : bool, default: False
3261         Whether to use blitting for faster drawing (if supported by the
3262         backend).
3263 
3264     props : dict, optional
3265         Properties with which the line is drawn, see `matplotlib.lines.Line2D`
3266         for valid properties.
3267         Default:
3268 
3269             ``dict(color='k', linestyle='-', linewidth=2, alpha=0.5)``
3270 
3271     handle_props : dict, optional
3272         Artist properties for the markers drawn at the vertices of the polygon.
3273         See the marker arguments in `matplotlib.lines.Line2D` for valid
3274         properties.  Default values are defined in ``mpl.rcParams`` except for
3275         the default value of ``markeredgecolor`` which will be the same as the
3276         ``color`` property in *props*.
3277 
3278     grab_range : float, default: 10
3279         A vertex is selected (to complete the polygon or to move a vertex) if
3280         the mouse click is within *grab_range* pixels of the vertex.
3281 
3282     Examples
3283     --------
3284     :doc:`/gallery/widgets/polygon_selector_demo`
3285 
3286     Notes
3287     -----
3288     If only one point remains after removing points, the selector reverts to an
3289     incomplete state and you can start drawing a new polygon from the existing
3290     point.
3291     """
3292 
3293     @_api.rename_parameter("3.5", "lineprops", "props")
3294     @_api.rename_parameter("3.5", "markerprops", "handle_props")
3295     @_api.rename_parameter("3.5", "vertex_select_radius", "grab_range")
3296     def __init__(self, ax, onselect, useblit=False,
3297                  props=None, handle_props=None, grab_range=10):
3298         # The state modifiers 'move', 'square', and 'center' are expected by
3299         # _SelectorWidget but are not supported by PolygonSelector
3300         # Note: could not use the existing 'move' state modifier in-place of
3301         # 'move_all' because _SelectorWidget automatically discards 'move'
3302         # from the state on button release.
3303         state_modifier_keys = dict(clear='escape', move_vertex='control',
3304                                    move_all='shift', move='not-applicable',
3305                                    square='not-applicable',
3306                                    center='not-applicable')
3307         super().__init__(ax, onselect, useblit=useblit,
3308                          state_modifier_keys=state_modifier_keys)
3309 
3310         self._xs, self._ys = [0], [0]
3311 
3312         if props is None:
3313             props = dict(color='k', linestyle='-', linewidth=2, alpha=0.5)
3314         props['animated'] = self.useblit
3315         self.line = Line2D(self._xs, self._ys, **props)
3316         self.ax.add_line(self.line)
3317 
3318         if handle_props is None:
3319             handle_props = dict(markeredgecolor='k',
3320                                 markerfacecolor=props.get('color', 'k'))
3321         self._polygon_handles = ToolHandles(self.ax, self._xs, self._ys,
3322                                             useblit=self.useblit,
3323                                             marker_props=handle_props)
3324 
3325         self._active_handle_idx = -1
3326         self.grab_range = grab_range
3327 
3328         self.artists = [self.line, self._polygon_handles.artist]
3329         self.set_visible(True)
3330 
3331     vertex_select_radius = _api.deprecated("3.5", name="vertex_select_radius",
3332                                            alternative="grab_range")(
3333         property(lambda self: self.grab_range,
3334                  lambda self, value: setattr(self, "grab_range", value))
3335         )
3336 
3337     @property
3338     def _nverts(self):
3339         return len(self._xs)
3340 
3341     def _remove_vertex(self, i):
3342         """Remove vertex with index i."""
3343         if (self._nverts > 2 and
3344                 self._selection_completed and
3345                 i in (0, self._nverts - 1)):
3346             # If selecting the first or final vertex, remove both first and
3347             # last vertex as they are the same for a closed polygon
3348             self._xs.pop(0)
3349             self._ys.pop(0)
3350             self._xs.pop(-1)
3351             self._ys.pop(-1)
3352             # Close the polygon again by appending the new first vertex to the
3353             # end
3354             self._xs.append(self._xs[0])
3355             self._ys.append(self._ys[0])
3356         else:
3357             self._xs.pop(i)
3358             self._ys.pop(i)
3359         if self._nverts <= 2:
3360             # If only one point left, return to incomplete state to let user
3361             # start drawing again
3362             self._selection_completed = False
3363 
3364     def _press(self, event):
3365         """Button press event handler."""
3366         # Check for selection of a tool handle.
3367         if ((self._selection_completed or 'move_vertex' in self._state)
3368                 and len(self._xs) > 0):
3369             h_idx, h_dist = self._polygon_handles.closest(event.x, event.y)
3370             if h_dist < self.grab_range:
3371                 self._active_handle_idx = h_idx
3372         # Save the vertex positions at the time of the press event (needed to
3373         # support the 'move_all' state modifier).
3374         self._xs_at_press, self._ys_at_press = self._xs.copy(), self._ys.copy()
3375 
3376     def _release(self, event):
3377         """Button release event handler."""
3378         # Release active tool handle.
3379         if self._active_handle_idx >= 0:
3380             if event.button == 3:
3381                 self._remove_vertex(self._active_handle_idx)
3382                 self._draw_polygon()
3383             self._active_handle_idx = -1
3384 
3385         # Complete the polygon.
3386         elif (len(self._xs) > 3
3387               and self._xs[-1] == self._xs[0]
3388               and self._ys[-1] == self._ys[0]):
3389             self._selection_completed = True
3390 
3391         # Place new vertex.
3392         elif (not self._selection_completed
3393               and 'move_all' not in self._state
3394               and 'move_vertex' not in self._state):
3395             self._xs.insert(-1, event.xdata)
3396             self._ys.insert(-1, event.ydata)
3397 
3398         if self._selection_completed:
3399             self.onselect(self.verts)
3400 
3401     def onmove(self, event):
3402         """Cursor move event handler and validator."""
3403         # Method overrides _SelectorWidget.onmove because the polygon selector
3404         # needs to process the move callback even if there is no button press.
3405         # _SelectorWidget.onmove include logic to ignore move event if
3406         # _eventpress is None.
3407         if not self.ignore(event):
3408             event = self._clean_event(event)
3409             self._onmove(event)
3410             return True
3411         return False
3412 
3413     def _onmove(self, event):
3414         """Cursor move event handler."""
3415         # Move the active vertex (ToolHandle).
3416         if self._active_handle_idx >= 0:
3417             idx = self._active_handle_idx
3418             self._xs[idx], self._ys[idx] = event.xdata, event.ydata
3419             # Also update the end of the polygon line if the first vertex is
3420             # the active handle and the polygon is completed.
3421             if idx == 0 and self._selection_completed:
3422                 self._xs[-1], self._ys[-1] = event.xdata, event.ydata
3423 
3424         # Move all vertices.
3425         elif 'move_all' in self._state and self._eventpress:
3426             dx = event.xdata - self._eventpress.xdata
3427             dy = event.ydata - self._eventpress.ydata
3428             for k in range(len(self._xs)):
3429                 self._xs[k] = self._xs_at_press[k] + dx
3430                 self._ys[k] = self._ys_at_press[k] + dy
3431 
3432         # Do nothing if completed or waiting for a move.
3433         elif (self._selection_completed
3434               or 'move_vertex' in self._state or 'move_all' in self._state):
3435             return
3436 
3437         # Position pending vertex.
3438         else:
3439             # Calculate distance to the start vertex.
3440             x0, y0 = self.line.get_transform().transform((self._xs[0],
3441                                                           self._ys[0]))
3442             v0_dist = np.hypot(x0 - event.x, y0 - event.y)
3443             # Lock on to the start vertex if near it and ready to complete.
3444             if len(self._xs) > 3 and v0_dist < self.grab_range:
3445                 self._xs[-1], self._ys[-1] = self._xs[0], self._ys[0]
3446             else:
3447                 self._xs[-1], self._ys[-1] = event.xdata, event.ydata
3448 
3449         self._draw_polygon()
3450 
3451     def _on_key_press(self, event):
3452         """Key press event handler."""
3453         # Remove the pending vertex if entering the 'move_vertex' or
3454         # 'move_all' mode
3455         if (not self._selection_completed
3456                 and ('move_vertex' in self._state or
3457                      'move_all' in self._state)):
3458             self._xs, self._ys = self._xs[:-1], self._ys[:-1]
3459             self._draw_polygon()
3460 
3461     def _on_key_release(self, event):
3462         """Key release event handler."""
3463         # Add back the pending vertex if leaving the 'move_vertex' or
3464         # 'move_all' mode (by checking the released key)
3465         if (not self._selection_completed
3466                 and
3467                 (event.key == self.state_modifier_keys.get('move_vertex')
3468                  or event.key == self.state_modifier_keys.get('move_all'))):
3469             self._xs.append(event.xdata)
3470             self._ys.append(event.ydata)
3471             self._draw_polygon()
3472         # Reset the polygon if the released key is the 'clear' key.
3473         elif event.key == self.state_modifier_keys.get('clear'):
3474             event = self._clean_event(event)
3475             self._xs, self._ys = [event.xdata], [event.ydata]
3476             self._selection_completed = False
3477             self.set_visible(True)
3478 
3479     def _draw_polygon(self):
3480         """Redraw the polygon based on the new vertex positions."""
3481         self.line.set_data(self._xs, self._ys)
3482         # Only show one tool handle at the start and end vertex of the polygon
3483         # if the polygon is completed or the user is locked on to the start
3484         # vertex.
3485         if (self._selection_completed
3486                 or (len(self._xs) > 3
3487                     and self._xs[-1] == self._xs[0]
3488                     and self._ys[-1] == self._ys[0])):
3489             self._polygon_handles.set_data(self._xs[:-1], self._ys[:-1])
3490         else:
3491             self._polygon_handles.set_data(self._xs, self._ys)
3492         self.update()
3493 
3494     @property
3495     def verts(self):
3496         """The polygon vertices, as a list of ``(x, y)`` pairs."""
3497         return list(zip(self._xs[:-1], self._ys[:-1]))
3498 
3499 
3500 class Lasso(AxesWidget):
3501     """
3502     Selection curve of an arbitrary shape.
3503 
3504     The selected path can be used in conjunction with
3505     `~matplotlib.path.Path.contains_point` to select data points from an image.
3506 
3507     Unlike `LassoSelector`, this must be initialized with a starting
3508     point *xy*, and the `Lasso` events are destroyed upon release.
3509 
3510     Parameters
3511     ----------
3512     ax : `~matplotlib.axes.Axes`
3513         The parent axes for the widget.
3514     xy : (float, float)
3515         Coordinates of the start of the lasso.
3516     useblit : bool, default: True
3517         Whether to use blitting for faster drawing (if supported by the
3518         backend).
3519     callback : callable
3520         Whenever the lasso is released, the *callback* function is called and
3521         passed the vertices of the selected path.
3522     """
3523 
3524     def __init__(self, ax, xy, callback=None, useblit=True):
3525         super().__init__(ax)
3526 
3527         self.useblit = useblit and self.canvas.supports_blit
3528         if self.useblit:
3529             self.background = self.canvas.copy_from_bbox(self.ax.bbox)
3530 
3531         x, y = xy
3532         self.verts = [(x, y)]
3533         self.line = Line2D([x], [y], linestyle='-', color='black', lw=2)
3534         self.ax.add_line(self.line)
3535         self.callback = callback
3536         self.connect_event('button_release_event', self.onrelease)
3537         self.connect_event('motion_notify_event', self.onmove)
3538 
3539     def onrelease(self, event):
3540         if self.ignore(event):
3541             return
3542         if self.verts is not None:
3543             self.verts.append((event.xdata, event.ydata))
3544             if len(self.verts) > 2:
3545                 self.callback(self.verts)
3546             self.ax.lines.remove(self.line)
3547         self.verts = None
3548         self.disconnect_events()
3549 
3550     def onmove(self, event):
3551         if self.ignore(event):
3552             return
3553         if self.verts is None:
3554             return
3555         if event.inaxes != self.ax:
3556             return
3557         if event.button != 1:
3558             return
3559         self.verts.append((event.xdata, event.ydata))
3560 
3561         self.line.set_data(list(zip(*self.verts)))
3562 
3563         if self.useblit:
3564             self.canvas.restore_region(self.background)
3565             self.ax.draw_artist(self.line)
3566             self.canvas.blit(self.ax.bbox)
3567         else:
3568             self.canvas.draw_idle()

</code><intended_behavior>Create or update methods within the selector's class to manage color and other properties without directly accessing low-level attributes like `rect`. Implement a mechanism, possibly leveraging `handle_props` or similar, that allows for a clean, maintainable way to update visual properties. This approach should respect the encapsulation of the selector's properties and provide a clear migration path from deprecated methods.</intended_behavior>]
2025-10-17 14:16:25.440 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 14:16:25.440 | INFO     | Search-only: skipping patch selection
2025-10-17 14:16:25.634 | INFO     | Task matplotlib__matplotlib-20693 completed successfully.
2025-10-17 14:16:25.634 | INFO     | No patch generated. You can try running ACR again.
