2025-10-17 20:40:46.167 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 20:40:54.569 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=110, output_tokens=12, cost=0.001460
2025-10-17 20:40:54.570 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 20:40:54.573 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:40:59.067 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=418, output_tokens=153, cost=0.008770
2025-10-17 20:40:59.069 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:41:02.304 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=507, output_tokens=27, cost=0.005880
2025-10-17 20:41:02.305 | DEBUG    | Extracted a valid json.
2025-10-17 20:41:02.305 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"S\")", "search_method(\"Half\")"],
    "bug_locations": []
}
2025-10-17 20:41:02.309 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:41:02.310 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:41:14.556 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=411, cost=0.019510
2025-10-17 20:41:14.566 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:41:15.527 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1345, output_tokens=3, cost=0.013540
2025-10-17 20:41:15.529 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:41:17.710 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=357, output_tokens=14, cost=0.003990
2025-10-17 20:41:17.711 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 20:41:17.712 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 20:41:20.630 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=357, output_tokens=14, cost=0.003990
2025-10-17 20:41:20.631 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 20:41:20.631 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 20:41:22.730 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=357, output_tokens=14, cost=0.003990
2025-10-17 20:41:22.731 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 20:41:22.732 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 20:41:23.773 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=357, output_tokens=14, cost=0.003990
2025-10-17 20:41:23.774 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 20:41:23.774 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 20:41:26.347 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=357, output_tokens=14, cost=0.003990
2025-10-17 20:41:26.348 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 20:41:26.348 | DEBUG    | Agent proxy return the following json: None
2025-10-17 20:41:26.349 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 20:41:26.350 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 20:41:26.350 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:41:38.909 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1375, output_tokens=446, cost=0.027130
2025-10-17 20:41:38.917 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:41:40.554 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=800, output_tokens=33, cost=0.008990
2025-10-17 20:41:40.555 | DEBUG    | Extracted a valid json.
2025-10-17 20:41:40.556 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"//\")",
        "search_code(\".5\")"
    ],
    "bug_locations": []
}
2025-10-17 20:41:47.856 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:41:47.856 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:42:03.956 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=9437, output_tokens=581, cost=0.111800
2025-10-17 20:42:03.961 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:42:13.599 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=10234, output_tokens=338, cost=0.112480
2025-10-17 20:42:13.606 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:42:19.012 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=164, cost=0.011840
2025-10-17 20:42:19.013 | DEBUG    | Extracted a valid json.
2025-10-17 20:42:19.013 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/core/numbers.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that division between numbers, especially involving fractions or symbolic representations like 'Half', follows Python's standard arithmetic rules, allowing for floor division without raising an error unless mathematically justified (e.g., division by zero)."
        },
        {
            "file": "sympy/core/power.py",
            "class": "",
            "method": "",
            "intended_behavior": "Correctly evaluate and simplify expressions involving division and power operation to avoid misinterpretations or errors, specifically ensuring that floor division is handled in line with Python's arithmetic rules when applicable."
        }
    ]
}
2025-10-17 20:42:19.024 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import absolute_import, print_function, division
2 
3 import numbers
4 import decimal
5 import fractions
6 import math
7 import re as regex
8 
9 from .containers import Tuple
10 from .sympify import converter, sympify, _sympify, SympifyError, _convert_numpy_types
11 from .singleton import S, Singleton
12 from .expr import Expr, AtomicExpr
13 from .decorators import _sympifyit
14 from .cache import cacheit, clear_cache
15 from .logic import fuzzy_not
16 from sympy.core.compatibility import (
17     as_int, integer_types, long, string_types, with_metaclass, HAS_GMPY,
18     SYMPY_INTS, int_info)
19 from sympy.core.cache import lru_cache
20 
21 import mpmath
22 import mpmath.libmp as mlib
23 from mpmath.libmp.backend import MPZ
24 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed
25 from mpmath.ctx_mp import mpnumeric
26 from mpmath.libmp.libmpf import (
27     finf as _mpf_inf, fninf as _mpf_ninf,
28     fnan as _mpf_nan, fzero as _mpf_zero, _normalize as mpf_normalize,
29     prec_to_dps)
30 from sympy.utilities.misc import debug, filldedent
31 from .evaluate import global_evaluate
32 
33 from sympy.utilities.exceptions import SymPyDeprecationWarning
34 
35 rnd = mlib.round_nearest
36 
37 _LOG2 = math.log(2)
38 
39 
40 def comp(z1, z2, tol=None):
41     """Return a bool indicating whether the error between z1 and z2 is <= tol.
42 
43     If ``tol`` is None then True will be returned if there is a significant
44     difference between the numbers: ``abs(z1 - z2)*10**p <= 1/2`` where ``p``
45     is the lower of the precisions of the values. A comparison of strings will
46     be made if ``z1`` is a Number and a) ``z2`` is a string or b) ``tol`` is ''
47     and ``z2`` is a Number.
48 
49     When ``tol`` is a nonzero value, if z2 is non-zero and ``|z1| > 1``
50     the error is normalized by ``|z1|``, so if you want to see if the
51     absolute error between ``z1`` and ``z2`` is <= ``tol`` then call this
52     as ``comp(z1 - z2, 0, tol)``.
53     """
54     if type(z2) is str:
55         if not isinstance(z1, Number):
56             raise ValueError('when z2 is a str z1 must be a Number')
57         return str(z1) == z2
58     if not z1:
59         z1, z2 = z2, z1
60     if not z1:
61         return True
62     if not tol:
63         if tol is None:
64             if type(z2) is str and getattr(z1, 'is_Number', False):
65                 return str(z1) == z2
66             a, b = Float(z1), Float(z2)
67             return int(abs(a - b)*10**prec_to_dps(
68                 min(a._prec, b._prec)))*2 <= 1
69         elif all(getattr(i, 'is_Number', False) for i in (z1, z2)):
70             return z1._prec == z2._prec and str(z1) == str(z2)
71         raise ValueError('exact comparison requires two Numbers')
72     diff = abs(z1 - z2)
73     az1 = abs(z1)
74     if z2 and az1 > 1:
75         return diff/az1 <= tol
76     else:
77         return diff <= tol
78 
79 
80 def mpf_norm(mpf, prec):
81     """Return the mpf tuple normalized appropriately for the indicated
82     precision after doing a check to see if zero should be returned or
83     not when the mantissa is 0. ``mpf_normlize`` always assumes that this
84     is zero, but it may not be since the mantissa for mpf's values "+inf",
85     "-inf" and "nan" have a mantissa of zero, too.
86 
87     Note: this is not intended to validate a given mpf tuple, so sending
88     mpf tuples that were not created by mpmath may produce bad results. This
89     is only a wrapper to ``mpf_normalize`` which provides the check for non-
90     zero mpfs that have a 0 for the mantissa.
91     """
92     sign, man, expt, bc = mpf
93     if not man:
94         # hack for mpf_normalize which does not do this;
95         # it assumes that if man is zero the result is 0
96         # (see issue 6639)
97         if not bc:
98             return _mpf_zero
99         else:
100             # don't change anything; this should already
101             # be a well formed mpf tuple
102             return mpf
103 
104     # Necessary if mpmath is using the gmpy backend
105     from mpmath.libmp.backend import MPZ
106     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
107     return rv
108 
109 # TODO: we should use the warnings module
110 _errdict = {"divide": False}
111 
112 
113 def seterr(divide=False):
114     """
115     Should sympy raise an exception on 0/0 or return a nan?
116 
117     divide == True .... raise an exception
118     divide == False ... return nan
119     """
120     if _errdict["divide"] != divide:
121         clear_cache()
122         _errdict["divide"] = divide
123 
124 
125 def _as_integer_ratio(p):
126     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)
127     p = [1, -1][neg_pow % 2]*man
128     if expt < 0:
129         q = 2**-expt
130     else:
131         q = 1
132         p *= 2**expt
133     return int(p), int(q)
134 
135 
136 def _decimal_to_Rational_prec(dec):
137     """Convert an ordinary decimal instance to a Rational."""
138     if not dec.is_finite():
139         raise TypeError("dec must be finite, got %s." % dec)
140     s, d, e = dec.as_tuple()
141     prec = len(d)
142     if e >= 0:  # it's an integer
143         rv = Integer(int(dec))
144     else:
145         s = (-1)**s
146         d = sum([di*10**i for i, di in enumerate(reversed(d))])
147         rv = Rational(s*d, 10**-e)
148     return rv, prec
149 
150 
151 _floatpat = regex.compile(r"[-+]?((\d*\.\d+)|(\d+\.?))")
152 def _literal_float(f):
153     """Return True if n starts like a floating point number."""
154     return bool(_floatpat.match(f))
155 
156 # (a,b) -> gcd(a,b)
157 
158 # TODO caching with decorator, but not to degrade performance
159 
160 @lru_cache(1024)
161 def igcd(*args):
162     """Computes nonnegative integer greatest common divisor.
163 
164     The algorithm is based on the well known Euclid's algorithm. To
165     improve speed, igcd() has its own caching mechanism implemented.
166 
167     Examples
168     ========
169 
170     >>> from sympy.core.numbers import igcd
171     >>> igcd(2, 4)
172     2
173     >>> igcd(5, 10, 15)
174     5
175 
176     """
177     if len(args) < 2:
178         raise TypeError(
179             'igcd() takes at least 2 arguments (%s given)' % len(args))
180     args_temp = [abs(as_int(i)) for i in args]
181     if 1 in args_temp:
182         return 1
183     a = args_temp.pop()
184     for b in args_temp:
185         a = igcd2(a, b) if b else a
186     return a
187 
188 
189 try:
190     from math import gcd as igcd2
191 except ImportError:
192     def igcd2(a, b):
193         """Compute gcd of two Python integers a and b."""
194         if (a.bit_length() > BIGBITS and
195             b.bit_length() > BIGBITS):
196             return igcd_lehmer(a, b)
197 
198         a, b = abs(a), abs(b)
199         while b:
200             a, b = b, a % b
201         return a
202 
203 
204 # Use Lehmer's algorithm only for very large numbers.
205 # The limit could be different on Python 2.7 and 3.x.
206 # If so, then this could be defined in compatibility.py.
207 BIGBITS = 5000
208 def igcd_lehmer(a, b):
209     """Computes greatest common divisor of two integers.
210 
211     Euclid's algorithm for the computation of the greatest
212     common divisor  gcd(a, b)  of two (positive) integers
213     a and b is based on the division identity
214         a = q*b + r,
215     where the quotient  q  and the remainder  r  are integers
216     and  0 <= r < b. Then each common divisor of  a  and  b
217     divides  r, and it follows that  gcd(a, b) == gcd(b, r).
218     The algorithm works by constructing the sequence
219     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn
220     is the remainder from the division of the two preceding
221     elements.
222 
223     In Python, q = a // b  and  r = a % b  are obtained by the
224     floor division and the remainder operations, respectively.
225     These are the most expensive arithmetic operations, especially
226     for large  a  and  b.
227 
228     Lehmer's algorithm is based on the observation that the quotients
229     qn = r(n-1) // rn  are in general small integers even
230     when  a  and  b  are very large. Hence the quotients can be
231     usually determined from a relatively small number of most
232     significant bits.
233 
234     The efficiency of the algorithm is further enhanced by not
235     computing each long remainder in Euclid's sequence. The remainders
236     are linear combinations of  a  and  b  with integer coefficients
237     derived from the quotients. The coefficients can be computed
238     as far as the quotients can be determined from the chosen
239     most significant parts of  a  and  b. Only then a new pair of
240     consecutive remainders is computed and the algorithm starts
241     anew with this pair.
242 
243     References
244     ==========
245 
246     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
247 
248     """
249     a, b = abs(as_int(a)), abs(as_int(b))
250     if a < b:
251         a, b = b, a
252 
253     # The algorithm works by using one or two digit division
254     # whenever possible. The outer loop will replace the
255     # pair (a, b) with a pair of shorter consecutive elements
256     # of the Euclidean gcd sequence until a and b
257     # fit into two Python (long) int digits.
258     nbits = 2*int_info.bits_per_digit
259 
260     while a.bit_length() > nbits and b != 0:
261         # Quotients are mostly small integers that can
262         # be determined from most significant bits.
263         n = a.bit_length() - nbits
264         x, y = int(a >> n), int(b >> n)  # most significant bits
265 
266         # Elements of the Euclidean gcd sequence are linear
267         # combinations of a and b with integer coefficients.
268         # Compute the coefficients of consecutive pairs
269         #     a' = A*a + B*b, b' = C*a + D*b
270         # using small integer arithmetic as far as possible.
271         A, B, C, D = 1, 0, 0, 1  # initial values
272 
273         while True:
274             # The coefficients alternate in sign while looping.
275             # The inner loop combines two steps to keep track
276             # of the signs.
277 
278             # At this point we have
279             #   A > 0, B <= 0, C <= 0, D > 0,
280             #   x' = x + B <= x < x" = x + A,
281             #   y' = y + C <= y < y" = y + D,
282             # and
283             #   x'*N <= a' < x"*N, y'*N <= b' < y"*N,
284             # where N = 2**n.
285 
286             # Now, if y' > 0, and x"//y' and x'//y" agree,
287             # then their common value is equal to  q = a'//b'.
288             # In addition,
289             #   x'%y" = x' - q*y" < x" - q*y' = x"%y',
290             # and
291             #   (x'%y")*N < a'%b' < (x"%y')*N.
292 
293             # On the other hand, we also have  x//y == q,
294             # and therefore
295             #   x'%y" = x + B - q*(y + D) = x%y + B',
296             #   x"%y' = x + A - q*(y + C) = x%y + A',
297             # where
298             #    B' = B - q*D < 0, A' = A - q*C > 0.
299 
300             if y + C <= 0:
301                 break
302             q = (x + A) // (y + C)
303 
304             # Now  x'//y" <= q, and equality holds if
305             #   x' - q*y" = (x - q*y) + (B - q*D) >= 0.
306             # This is a minor optimization to avoid division.
307             x_qy, B_qD = x - q*y, B - q*D
308             if x_qy + B_qD < 0:
309                 break
310 
311             # Next step in the Euclidean sequence.
312             x, y = y, x_qy
313             A, B, C, D = C, D, A - q*C, B_qD
314 
315             # At this point the signs of the coefficients
316             # change and their roles are interchanged.
317             #   A <= 0, B > 0, C > 0, D < 0,
318             #   x' = x + A <= x < x" = x + B,
319             #   y' = y + D < y < y" = y + C.
320 
321             if y + D <= 0:
322                 break
323             q = (x + B) // (y + D)
324             x_qy, A_qC = x - q*y, A - q*C
325             if x_qy + A_qC < 0:
326                 break
327 
328             x, y = y, x_qy
329             A, B, C, D = C, D, A_qC, B - q*D
330             # Now the conditions on top of the loop
331             # are again satisfied.
332             #   A > 0, B < 0, C < 0, D > 0.
333 
334         if B == 0:
335             # This can only happen when y == 0 in the beginning
336             # and the inner loop does nothing.
337             # Long division is forced.
338             a, b = b, a % b
339             continue
340 
341         # Compute new long arguments using the coefficients.
342         a, b = A*a + B*b, C*a + D*b
343 
344     # Small divisors. Finish with the standard algorithm.
345     while b:
346         a, b = b, a % b
347 
348     return a
349 
350 
351 def ilcm(*args):
352     """Computes integer least common multiple.
353 
354     Examples
355     ========
356 
357     >>> from sympy.core.numbers import ilcm
358     >>> ilcm(5, 10)
359     10
360     >>> ilcm(7, 3)
361     21
362     >>> ilcm(5, 10, 15)
363     30
364 
365     """
366     if len(args) < 2:
367         raise TypeError(
368             'ilcm() takes at least 2 arguments (%s given)' % len(args))
369     if 0 in args:
370         return 0
371     a = args[0]
372     for b in args[1:]:
373         a = a // igcd(a, b) * b # since gcd(a,b) | a
374     return a
375 
376 
377 def igcdex(a, b):
378     """Returns x, y, g such that g = x*a + y*b = gcd(a, b).
379 
380        >>> from sympy.core.numbers import igcdex
381        >>> igcdex(2, 3)
382        (-1, 1, 1)
383        >>> igcdex(10, 12)
384        (-1, 1, 2)
385 
386        >>> x, y, g = igcdex(100, 2004)
387        >>> x, y, g
388        (-20, 1, 4)
389        >>> x*100 + y*2004
390        4
391 
392     """
393     if (not a) and (not b):
394         return (0, 1, 0)
395 
396     if not a:
397         return (0, b//abs(b), abs(b))
398     if not b:
399         return (a//abs(a), 0, abs(a))
400 
401     if a < 0:
402         a, x_sign = -a, -1
403     else:
404         x_sign = 1
405 
406     if b < 0:
407         b, y_sign = -b, -1
408     else:
409         y_sign = 1
410 
411     x, y, r, s = 1, 0, 0, 1
412 
413     while b:
414         (c, q) = (a % b, a // b)
415         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)
416 
417     return (x*x_sign, y*y_sign, a)
418 
419 
420 def mod_inverse(a, m):
421     """
422     Return the number c such that, (a * c) = 1 (mod m)
423     where c has the same sign as m. If no such value exists,
424     a ValueError is raised.
425 
426     Examples
427     ========
428 
429     >>> from sympy import S
430     >>> from sympy.core.numbers import mod_inverse
431 
432     Suppose we wish to find multiplicative inverse x of
433     3 modulo 11. This is the same as finding x such
434     that 3 * x = 1 (mod 11). One value of x that satisfies
435     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).
436     This is the value return by mod_inverse:
437 
438     >>> mod_inverse(3, 11)
439     4
440     >>> mod_inverse(-3, 11)
441     7
442 
443     When there is a common factor between the numerators of
444     ``a`` and ``m`` the inverse does not exist:
445 
446     >>> mod_inverse(2, 4)
447     Traceback (most recent call last):
448     ...
449     ValueError: inverse of 2 mod 4 does not exist
450 
451     >>> mod_inverse(S(2)/7, S(5)/2)
452     7/2
453 
454     References
455     ==========
456     - https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
457     - https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
458     """
459     c = None
460     try:
461         a, m = as_int(a), as_int(m)
462         if m != 1 and m != -1:
463             x, y, g = igcdex(a, m)
464             if g == 1:
465                 c = x % m
466     except ValueError:
467         a, m = sympify(a), sympify(m)
468         if not (a.is_number and m.is_number):
469             raise TypeError(filldedent('''
470                 Expected numbers for arguments; symbolic `mod_inverse`
471                 is not implemented
472                 but symbolic expressions can be handled with the
473                 similar function,
474                 sympy.polys.polytools.invert'''))
475         big = (m > 1)
476         if not (big is S.true or big is S.false):
477             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)
478         elif big:
479             c = 1/a
480     if c is None:
481         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))
482     return c
483 
484 
485 class Number(AtomicExpr):
486     """Represents atomic numbers in SymPy.
487 
488     Floating point numbers are represented by the Float class.
489     Rational numbers (of any size) are represented by the Rational class.
490     Integer numbers (of any size) are represented by the Integer class.
491     Float and Rational are subclasses of Number; Integer is a subclass
492     of Rational.
493 
494     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is
495     a different object from the floating point number obtained with
496     Python division ``2/3``. Even for numbers that are exactly
497     represented in binary, there is a difference between how two forms,
498     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.
499     The rational form is to be preferred in symbolic computations.
500 
501     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or
502     complex numbers ``3 + 4*I``, are not instances of Number class as
503     they are not atomic.
504 
505     See Also
506     ========
507 
508     Float, Integer, Rational
509     """
510     is_commutative = True
511     is_number = True
512     is_Number = True
513 
514     __slots__ = []
515 
516     # Used to make max(x._prec, y._prec) return x._prec when only x is a float
517     _prec = -1
518 
519     def __new__(cls, *obj):
520         if len(obj) == 1:
521             obj = obj[0]
522 
523         if isinstance(obj, Number):
524             return obj
525         if isinstance(obj, SYMPY_INTS):
526             return Integer(obj)
527         if isinstance(obj, tuple) and len(obj) == 2:
528             return Rational(*obj)
529         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):
530             return Float(obj)
531         if isinstance(obj, string_types):
532             val = sympify(obj)
533             if isinstance(val, Number):
534                 return val
535             else:
536                 raise ValueError('String "%s" does not denote a Number' % obj)
537         msg = "expected str|int|long|float|Decimal|Number object but got %r"
538         raise TypeError(msg % type(obj).__name__)
539 
540     def invert(self, other, *gens, **args):
541         from sympy.polys.polytools import invert
542         if getattr(other, 'is_number', True):
543             return mod_inverse(self, other)
544         return invert(self, other, *gens, **args)
545 
546     def __divmod__(self, other):
547         from .containers import Tuple
548 
549         try:
550             other = Number(other)
551         except TypeError:
552             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
553             raise TypeError(msg % (type(self).__name__, type(other).__name__))
554         if not other:
555             raise ZeroDivisionError('modulo by zero')
556         if self.is_Integer and other.is_Integer:
557             return Tuple(*divmod(self.p, other.p))
558         else:
559             rat = self/other
560         w = int(rat) if rat > 0 else int(rat) - 1
561         r = self - other*w
562         return Tuple(w, r)
563 
564     def __rdivmod__(self, other):
565         try:
566             other = Number(other)
567         except TypeError:
568             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
569             raise TypeError(msg % (type(other).__name__, type(self).__name__))
570         return divmod(other, self)
571 
572     def _as_mpf_val(self, prec):
573         """Evaluation of mpf tuple accurate to at least prec bits."""
574         raise NotImplementedError('%s needs ._as_mpf_val() method' %
575             (self.__class__.__name__))
576 
577     def _eval_evalf(self, prec):
578         return Float._new(self._as_mpf_val(prec), prec)
579 
580     def _as_mpf_op(self, prec):
581         prec = max(prec, self._prec)
582         return self._as_mpf_val(prec), prec
583 
584     def __float__(self):
585         return mlib.to_float(self._as_mpf_val(53))
586 
587     def floor(self):
588         raise NotImplementedError('%s needs .floor() method' %
589             (self.__class__.__name__))
590 
591     def ceiling(self):
592         raise NotImplementedError('%s needs .ceiling() method' %
593             (self.__class__.__name__))
594 
595     def __floor__(self):
596         return self.floor()
597 
598     def __ceil__(self):
599         return self.ceiling()
600 
601     def _eval_conjugate(self):
602         return self
603 
604     def _eval_order(self, *symbols):
605         from sympy import Order
606         # Order(5, x, y) -> Order(1,x,y)
607         return Order(S.One, *symbols)
608 
609     def _eval_subs(self, old, new):
610         if old == -self:
611             return -new
612         return self  # there is no other possibility
613 
614     def _eval_is_finite(self):
615         return True
616 
617     @classmethod
618     def class_key(cls):
619         return 1, 0, 'Number'
620 
621     @cacheit
622     def sort_key(self, order=None):
623         return self.class_key(), (0, ()), (), self
624 
625     @_sympifyit('other', NotImplemented)
626     def __add__(self, other):
627         if isinstance(other, Number) and global_evaluate[0]:
628             if other is S.NaN:
629                 return S.NaN
630             elif other is S.Infinity:
631                 return S.Infinity
632             elif other is S.NegativeInfinity:
633                 return S.NegativeInfinity
634         return AtomicExpr.__add__(self, other)
635 
636     @_sympifyit('other', NotImplemented)
637     def __sub__(self, other):
638         if isinstance(other, Number) and global_evaluate[0]:
639             if other is S.NaN:
640                 return S.NaN
641             elif other is S.Infinity:
642                 return S.NegativeInfinity
643             elif other is S.NegativeInfinity:
644                 return S.Infinity
645         return AtomicExpr.__sub__(self, other)
646 
647     @_sympifyit('other', NotImplemented)
648     def __mul__(self, other):
649         if isinstance(other, Number) and global_evaluate[0]:
650             if other is S.NaN:
651                 return S.NaN
652             elif other is S.Infinity:
653                 if self.is_zero:
654                     return S.NaN
655                 elif self.is_positive:
656                     return S.Infinity
657                 else:
658                     return S.NegativeInfinity
659             elif other is S.NegativeInfinity:
660                 if self.is_zero:
661                     return S.NaN
662                 elif self.is_positive:
663                     return S.NegativeInfinity
664                 else:
665                     return S.Infinity
666         elif isinstance(other, Tuple):
667             return NotImplemented
668         return AtomicExpr.__mul__(self, other)
669 
670     @_sympifyit('other', NotImplemented)
671     def __div__(self, other):
672         if isinstance(other, Number) and global_evaluate[0]:
673             if other is S.NaN:
674                 return S.NaN
675             elif other is S.Infinity or other is S.NegativeInfinity:
676                 return S.Zero
677         return AtomicExpr.__div__(self, other)
678 
679     __truediv__ = __div__
680 
681     def __eq__(self, other):
682         raise NotImplementedError('%s needs .__eq__() method' %
683             (self.__class__.__name__))
684 
685     def __ne__(self, other):
686         raise NotImplementedError('%s needs .__ne__() method' %
687             (self.__class__.__name__))
688 
689     def __lt__(self, other):
690         try:
691             other = _sympify(other)
692         except SympifyError:
693             raise TypeError("Invalid comparison %s < %s" % (self, other))
694         raise NotImplementedError('%s needs .__lt__() method' %
695             (self.__class__.__name__))
696 
697     def __le__(self, other):
698         try:
699             other = _sympify(other)
700         except SympifyError:
701             raise TypeError("Invalid comparison %s <= %s" % (self, other))
702         raise NotImplementedError('%s needs .__le__() method' %
703             (self.__class__.__name__))
704 
705     def __gt__(self, other):
706         try:
707             other = _sympify(other)
708         except SympifyError:
709             raise TypeError("Invalid comparison %s > %s" % (self, other))
710         return _sympify(other).__lt__(self)
711 
712     def __ge__(self, other):
713         try:
714             other = _sympify(other)
715         except SympifyError:
716             raise TypeError("Invalid comparison %s >= %s" % (self, other))
717         return _sympify(other).__le__(self)
718 
719     def __hash__(self):
720         return super(Number, self).__hash__()
721 
722     def is_constant(self, *wrt, **flags):
723         return True
724 
725     def as_coeff_mul(self, *deps, **kwargs):
726         # a -> c*t
727         if self.is_Rational or not kwargs.pop('rational', True):
728             return self, tuple()
729         elif self.is_negative:
730             return S.NegativeOne, (-self,)
731         return S.One, (self,)
732 
733     def as_coeff_add(self, *deps):
734         # a -> c + t
735         if self.is_Rational:
736             return self, tuple()
737         return S.Zero, (self,)
738 
739     def as_coeff_Mul(self, rational=False):
740         """Efficiently extract the coefficient of a product. """
741         if rational and not self.is_Rational:
742             return S.One, self
743         return (self, S.One) if self else (S.One, self)
744 
745     def as_coeff_Add(self, rational=False):
746         """Efficiently extract the coefficient of a summation. """
747         if not rational:
748             return self, S.Zero
749         return S.Zero, self
750 
751     def gcd(self, other):
752         """Compute GCD of `self` and `other`. """
753         from sympy.polys import gcd
754         return gcd(self, other)
755 
756     def lcm(self, other):
757         """Compute LCM of `self` and `other`. """
758         from sympy.polys import lcm
759         return lcm(self, other)
760 
761     def cofactors(self, other):
762         """Compute GCD and cofactors of `self` and `other`. """
763         from sympy.polys import cofactors
764         return cofactors(self, other)
765 
766 
767 class Float(Number):
768     """Represent a floating-point number of arbitrary precision.
769 
770     Examples
771     ========
772 
773     >>> from sympy import Float
774     >>> Float(3.5)
775     3.50000000000000
776     >>> Float(3)
777     3.00000000000000
778 
779     Creating Floats from strings (and Python ``int`` and ``long``
780     types) will give a minimum precision of 15 digits, but the
781     precision will automatically increase to capture all digits
782     entered.
783 
784     >>> Float(1)
785     1.00000000000000
786     >>> Float(10**20)
787     100000000000000000000.
788     >>> Float('1e20')
789     100000000000000000000.
790 
791     However, *floating-point* numbers (Python ``float`` types) retain
792     only 15 digits of precision:
793 
794     >>> Float(1e20)
795     1.00000000000000e+20
796     >>> Float(1.23456789123456789)
797     1.23456789123457
798 
799     It may be preferable to enter high-precision decimal numbers
800     as strings:
801 
802     Float('1.23456789123456789')
803     1.23456789123456789
804 
805     The desired number of digits can also be specified:
806 
807     >>> Float('1e-3', 3)
808     0.00100
809     >>> Float(100, 4)
810     100.0
811 
812     Float can automatically count significant figures if a null string
813     is sent for the precision; spaces or underscores are also allowed. (Auto-
814     counting is only allowed for strings, ints and longs).
815 
816     >>> Float('123 456 789.123_456', '')
817     123456789.123456
818     >>> Float('12e-3', '')
819     0.012
820     >>> Float(3, '')
821     3.
822 
823     If a number is written in scientific notation, only the digits before the
824     exponent are considered significant if a decimal appears, otherwise the
825     "e" signifies only how to move the decimal:
826 
827     >>> Float('60.e2', '')  # 2 digits significant
828     6.0e+3
829     >>> Float('60e2', '')  # 4 digits significant
830     6000.
831     >>> Float('600e-2', '')  # 3 digits significant
832     6.00
833 
834     Notes
835     =====
836 
837     Floats are inexact by their nature unless their value is a binary-exact
838     value.
839 
840     >>> approx, exact = Float(.1, 1), Float(.125, 1)
841 
842     For calculation purposes, evalf needs to be able to change the precision
843     but this will not increase the accuracy of the inexact value. The
844     following is the most accurate 5-digit approximation of a value of 0.1
845     that had only 1 digit of precision:
846 
847     >>> approx.evalf(5)
848     0.099609
849 
850     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
851     can be passed to Float or evalf to obtain an arbitrary precision with
852     matching accuracy:
853 
854     >>> Float(exact, 5)
855     0.12500
856     >>> exact.evalf(20)
857     0.12500000000000000000
858 
859     Trying to make a high-precision Float from a float is not disallowed,
860     but one must keep in mind that the *underlying float* (not the apparent
861     decimal value) is being obtained with high precision. For example, 0.3
862     does not have a finite binary representation. The closest rational is
863     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
864     0.3 to 20 digits of precision you will not see the same thing as 0.3
865     followed by 19 zeros:
866 
867     >>> Float(0.3, 20)
868     0.29999999999999998890
869 
870     If you want a 20-digit value of the decimal 0.3 (not the floating point
871     approximation of 0.3) you should send the 0.3 as a string. The underlying
872     representation is still binary but a higher precision than Python's float
873     is used:
874 
875     >>> Float('0.3', 20)
876     0.30000000000000000000
877 
878     Although you can increase the precision of an existing Float using Float
879     it will not increase the accuracy -- the underlying value is not changed:
880 
881     >>> def show(f): # binary rep of Float
882     ...     from sympy import Mul, Pow
883     ...     s, m, e, b = f._mpf_
884     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
885     ...     print('%s at prec=%s' % (v, f._prec))
886     ...
887     >>> t = Float('0.3', 3)
888     >>> show(t)
889     4915/2**14 at prec=13
890     >>> show(Float(t, 20)) # higher prec, not higher accuracy
891     4915/2**14 at prec=70
892     >>> show(Float(t, 2)) # lower prec
893     307/2**10 at prec=10
894 
895     The same thing happens when evalf is used on a Float:
896 
897     >>> show(t.evalf(20))
898     4915/2**14 at prec=70
899     >>> show(t.evalf(2))
900     307/2**10 at prec=10
901 
902     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
903     produce the number (-1)**n*c*2**p:
904 
905     >>> n, c, p = 1, 5, 0
906     >>> (-1)**n*c*2**p
907     -5
908     >>> Float((1, 5, 0))
909     -5.00000000000000
910 
911     An actual mpf tuple also contains the number of bits in c as the last
912     element of the tuple:
913 
914     >>> _._mpf_
915     (1, 5, 0, 3)
916 
917     This is not needed for instantiation and is not the same thing as the
918     precision. The mpf tuple and the precision are two separate quantities
919     that Float tracks.
920 
921     """
922     __slots__ = ['_mpf_', '_prec']
923 
924     # A Float represents many real numbers,
925     # both rational and irrational.
926     is_rational = None
927     is_irrational = None
928     is_number = True
929 
930     is_real = True
931 
932     is_Float = True
933 
934     def __new__(cls, num, dps=None, prec=None, precision=None):
935         if prec is not None:
936             SymPyDeprecationWarning(
937                             feature="Using 'prec=XX' to denote decimal precision",
938                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
939                                               "for binary precision",
940                             issue=12820,
941                             deprecated_since_version="1.1").warn()
942             dps = prec
943         del prec  # avoid using this deprecated kwarg
944 
945         if dps is not None and precision is not None:
946             raise ValueError('Both decimal and binary precision supplied. '
947                              'Supply only one. ')
948 
949         if isinstance(num, string_types):
950             # Float already accepts spaces as digit separators; in Py 3.6
951             # underscores are allowed. In anticipation of that, we ignore
952             # legally placed underscores
953             num = num.replace(' ', '')
954             if '_' in num:
955                 if num.startswith('_') or num.endswith('_') or any(
956                         i in num for i in ('__', '_.', '._')):
957                     # copy Py 3.6 error
958                     raise ValueError("could not convert string to float: '%s'" % num)
959                 num = num.replace('_', '')
960             if num.startswith('.') and len(num) > 1:
961                 num = '0' + num
962             elif num.startswith('-.') and len(num) > 2:
963                 num = '-0.' + num[2:]
964             elif num == 'inf' or num == '+inf':
965                 return S.Infinity
966             elif num == '-inf':
967                 return S.NegativeInfinity
968         elif isinstance(num, float) and num == 0:
969             num = '0'
970         elif isinstance(num, float) and num == float('inf'):
971             return S.Infinity
972         elif isinstance(num, float) and num == float('-inf'):
973             return S.NegativeInfinity
974         elif isinstance(num, (SYMPY_INTS, Integer)):
975             num = str(num)  # faster than mlib.from_int
976         elif num is S.Infinity:
977             return num
978         elif num is S.NegativeInfinity:
979             return num
980         elif type(num).__module__ == 'numpy': # support for numpy datatypes
981             num = _convert_numpy_types(num)
982         elif isinstance(num, mpmath.mpf):
983             if precision is None:
984                 if dps is None:
985                     precision = num.context.prec
986             num = num._mpf_
987 
988         if dps is None and precision is None:
989             dps = 15
990             if isinstance(num, Float):
991                 return num
992             if isinstance(num, string_types) and _literal_float(num):
993                 try:
994                     Num = decimal.Decimal(num)
995                 except decimal.InvalidOperation:
996                     pass
997                 else:
998                     isint = '.' not in num
999                     num, dps = _decimal_to_Rational_prec(Num)
1000                     if num.is_Integer and isint:
1001                         dps = max(dps, len(str(num).lstrip('-')))
1002                     dps = max(15, dps)
1003                     precision = mlib.libmpf.dps_to_prec(dps)
1004         elif precision == '' and dps is None or precision is None and dps == '':
1005             if not isinstance(num, string_types):
1006                 raise ValueError('The null string can only be used when '
1007                 'the number to Float is passed as a string or an integer.')
1008             ok = None
1009             if _literal_float(num):
1010                 try:
1011                     Num = decimal.Decimal(num)
1012                 except decimal.InvalidOperation:
1013                     pass
1014                 else:
1015                     isint = '.' not in num
1016                     num, dps = _decimal_to_Rational_prec(Num)
1017                     if num.is_Integer and isint:
1018                         dps = max(dps, len(str(num).lstrip('-')))
1019                         precision = mlib.libmpf.dps_to_prec(dps)
1020                     ok = True
1021             if ok is None:
1022                 raise ValueError('string-float not recognized: %s' % num)
1023 
1024         # decimal precision(dps) is set and maybe binary precision(precision)
1025         # as well.From here on binary precision is used to compute the Float.
1026         # Hence, if supplied use binary precision else translate from decimal
1027         # precision.
1028 
1029         if precision is None or precision == '':
1030             precision = mlib.libmpf.dps_to_prec(dps)
1031 
1032         precision = int(precision)
1033 
1034         if isinstance(num, float):
1035             _mpf_ = mlib.from_float(num, precision, rnd)
1036         elif isinstance(num, string_types):
1037             _mpf_ = mlib.from_str(num, precision, rnd)
1038         elif isinstance(num, decimal.Decimal):
1039             if num.is_finite():
1040                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1041             elif num.is_nan():
1042                 return S.NaN
1043             elif num.is_infinite():
1044                 if num > 0:
1045                     return S.Infinity
1046                 else:
1047                     return S.NegativeInfinity
1048             else:
1049                 raise ValueError("unexpected decimal value %s" % str(num))
1050         elif isinstance(num, tuple) and len(num) in (3, 4):
1051             if type(num[1]) is str:
1052                 # it's a hexadecimal (coming from a pickled object)
1053                 # assume that it is in standard form
1054                 num = list(num)
1055                 # If we're loading an object pickled in Python 2 into
1056                 # Python 3, we may need to strip a tailing 'L' because
1057                 # of a shim for int on Python 3, see issue #13470.
1058                 if num[1].endswith('L'):
1059                     num[1] = num[1][:-1]
1060                 num[1] = MPZ(num[1], 16)
1061                 _mpf_ = tuple(num)
1062             else:
1063                 if len(num) == 4:
1064                     # handle normalization hack
1065                     return Float._new(num, precision)
1066                 else:
1067                     return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)
1068         else:
1069             try:
1070                 _mpf_ = num._as_mpf_val(precision)
1071             except (NotImplementedError, AttributeError):
1072                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1073 
1074         # special cases
1075         if _mpf_ == _mpf_zero:
1076             pass  # we want a Float
1077         elif _mpf_ == _mpf_nan:
1078             return S.NaN
1079         elif _mpf_ == _mpf_inf:
1080             return S.Infinity
1081         elif _mpf_ == _mpf_ninf:
1082             return S.NegativeInfinity
1083 
1084         obj = Expr.__new__(cls)
1085         obj._mpf_ = _mpf_
1086         obj._prec = precision
1087         return obj
1088 
1089     @classmethod
1090     def _new(cls, _mpf_, _prec):
1091         # special cases
1092         if _mpf_ == _mpf_zero:
1093             return S.Zero  # XXX this is different from Float which gives 0.0
1094         elif _mpf_ == _mpf_nan:
1095             return S.NaN
1096         elif _mpf_ == _mpf_inf:
1097             return S.Infinity
1098         elif _mpf_ == _mpf_ninf:
1099             return S.NegativeInfinity
1100 
1101         obj = Expr.__new__(cls)
1102         obj._mpf_ = mpf_norm(_mpf_, _prec)
1103         # XXX: Should this be obj._prec = obj._mpf_[3]?
1104         obj._prec = _prec
1105         return obj
1106 
1107     # mpz can't be pickled
1108     def __getnewargs__(self):
1109         return (mlib.to_pickable(self._mpf_),)
1110 
1111     def __getstate__(self):
1112         return {'_prec': self._prec}
1113 
1114     def _hashable_content(self):
1115         return (self._mpf_, self._prec)
1116 
1117     def floor(self):
1118         return Integer(int(mlib.to_int(
1119             mlib.mpf_floor(self._mpf_, self._prec))))
1120 
1121     def ceiling(self):
1122         return Integer(int(mlib.to_int(
1123             mlib.mpf_ceil(self._mpf_, self._prec))))
1124 
1125     def __floor__(self):
1126         return self.floor()
1127 
1128     def __ceil__(self):
1129         return self.ceiling()
1130 
1131 
1132     @property
1133     def num(self):
1134         return mpmath.mpf(self._mpf_)
1135 
1136     def _as_mpf_val(self, prec):
1137         rv = mpf_norm(self._mpf_, prec)
1138         if rv != self._mpf_ and self._prec == prec:
1139             debug(self._mpf_, rv)
1140         return rv
1141 
1142     def _as_mpf_op(self, prec):
1143         return self._mpf_, max(prec, self._prec)
1144 
1145     def _eval_is_finite(self):
1146         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1147             return False
1148         return True
1149 
1150     def _eval_is_infinite(self):
1151         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1152             return True
1153         return False
1154 
1155     def _eval_is_integer(self):
1156         return self._mpf_ == _mpf_zero
1157 
1158     def _eval_is_negative(self):
1159         if self._mpf_ == _mpf_ninf:
1160             return True
1161         if self._mpf_ == _mpf_inf:
1162             return False
1163         return self.num < 0
1164 
1165     def _eval_is_positive(self):
1166         if self._mpf_ == _mpf_inf:
1167             return True
1168         if self._mpf_ == _mpf_ninf:
1169             return False
1170         return self.num > 0
1171 
1172     def _eval_is_zero(self):
1173         return self._mpf_ == _mpf_zero
1174 
1175     def __nonzero__(self):
1176         return self._mpf_ != _mpf_zero
1177 
1178     __bool__ = __nonzero__
1179 
1180     def __neg__(self):
1181         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1182 
1183     @_sympifyit('other', NotImplemented)
1184     def __add__(self, other):
1185         if isinstance(other, Number) and global_evaluate[0]:
1186             rhs, prec = other._as_mpf_op(self._prec)
1187             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1188         return Number.__add__(self, other)
1189 
1190     @_sympifyit('other', NotImplemented)
1191     def __sub__(self, other):
1192         if isinstance(other, Number) and global_evaluate[0]:
1193             rhs, prec = other._as_mpf_op(self._prec)
1194             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1195         return Number.__sub__(self, other)
1196 
1197     @_sympifyit('other', NotImplemented)
1198     def __mul__(self, other):
1199         if isinstance(other, Number) and global_evaluate[0]:
1200             rhs, prec = other._as_mpf_op(self._prec)
1201             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1202         return Number.__mul__(self, other)
1203 
1204     @_sympifyit('other', NotImplemented)
1205     def __div__(self, other):
1206         if isinstance(other, Number) and other != 0 and global_evaluate[0]:
1207             rhs, prec = other._as_mpf_op(self._prec)
1208             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1209         return Number.__div__(self, other)
1210 
1211     __truediv__ = __div__
1212 
1213     @_sympifyit('other', NotImplemented)
1214     def __mod__(self, other):
1215         if isinstance(other, Rational) and other.q != 1 and global_evaluate[0]:
1216             # calculate mod with Rationals, *then* round the result
1217             return Float(Rational.__mod__(Rational(self), other),
1218                          precision=self._prec)
1219         if isinstance(other, Float) and global_evaluate[0]:
1220             r = self/other
1221             if r == int(r):
1222                 return Float(0, precision=max(self._prec, other._prec))
1223         if isinstance(other, Number) and global_evaluate[0]:
1224             rhs, prec = other._as_mpf_op(self._prec)
1225             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1226         return Number.__mod__(self, other)
1227 
1228     @_sympifyit('other', NotImplemented)
1229     def __rmod__(self, other):
1230         if isinstance(other, Float) and global_evaluate[0]:
1231             return other.__mod__(self)
1232         if isinstance(other, Number) and global_evaluate[0]:
1233             rhs, prec = other._as_mpf_op(self._prec)
1234             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1235         return Number.__rmod__(self, other)
1236 
1237     def _eval_power(self, expt):
1238         """
1239         expt is symbolic object but not equal to 0, 1
1240 
1241         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1242                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1243         """
1244         if self == 0:
1245             if expt.is_positive:
1246                 return S.Zero
1247             if expt.is_negative:
1248                 return S.Infinity
1249         if isinstance(expt, Number):
1250             if isinstance(expt, Integer):
1251                 prec = self._prec
1252                 return Float._new(
1253                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1254             elif isinstance(expt, Rational) and \
1255                     expt.p == 1 and expt.q % 2 and self.is_negative:
1256                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1257                     -self)._eval_power(expt)
1258             expt, prec = expt._as_mpf_op(self._prec)
1259             mpfself = self._mpf_
1260             try:
1261                 y = mpf_pow(mpfself, expt, prec, rnd)
1262                 return Float._new(y, prec)
1263             except mlib.ComplexResult:
1264                 re, im = mlib.mpc_pow(
1265                     (mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)
1266                 return Float._new(re, prec) + \
1267                     Float._new(im, prec)*S.ImaginaryUnit
1268 
1269     def __abs__(self):
1270         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1271 
1272     def __int__(self):
1273         if self._mpf_ == _mpf_zero:
1274             return 0
1275         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1276 
1277     __long__ = __int__
1278 
1279     def __eq__(self, other):
1280         if isinstance(other, float):
1281             # coerce to Float at same precision
1282             o = Float(other)
1283             try:
1284                 ompf = o._as_mpf_val(self._prec)
1285             except ValueError:
1286                 return False
1287             return bool(mlib.mpf_eq(self._mpf_, ompf))
1288         try:
1289             other = _sympify(other)
1290         except SympifyError:
1291             return NotImplemented
1292         if other.is_NumberSymbol:
1293             if other.is_irrational:
1294                 return False
1295             return other.__eq__(self)
1296         if other.is_Float:
1297             return bool(mlib.mpf_eq(self._mpf_, other._mpf_))
1298         if other.is_Number:
1299             # numbers should compare at the same precision;
1300             # all _as_mpf_val routines should be sure to abide
1301             # by the request to change the prec if necessary; if
1302             # they don't, the equality test will fail since it compares
1303             # the mpf tuples
1304             ompf = other._as_mpf_val(self._prec)
1305             return bool(mlib.mpf_eq(self._mpf_, ompf))
1306         return False    # Float != non-Number
1307 
1308     def __ne__(self, other):
1309         return not self == other
1310 
1311     def __gt__(self, other):
1312         try:
1313             other = _sympify(other)
1314         except SympifyError:
1315             raise TypeError("Invalid comparison %s > %s" % (self, other))
1316         if other.is_NumberSymbol:
1317             return other.__lt__(self)
1318         if other.is_Rational and not other.is_Integer:
1319             self *= other.q
1320             other = _sympify(other.p)
1321         elif other.is_comparable:
1322             other = other.evalf()
1323         if other.is_Number and other is not S.NaN:
1324             return _sympify(bool(
1325                 mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))
1326         return Expr.__gt__(self, other)
1327 
1328     def __ge__(self, other):
1329         try:
1330             other = _sympify(other)
1331         except SympifyError:
1332             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1333         if other.is_NumberSymbol:
1334             return other.__le__(self)
1335         if other.is_Rational and not other.is_Integer:
1336             self *= other.q
1337             other = _sympify(other.p)
1338         elif other.is_comparable:
1339             other = other.evalf()
1340         if other.is_Number and other is not S.NaN:
1341             return _sympify(bool(
1342                 mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))
1343         return Expr.__ge__(self, other)
1344 
1345     def __lt__(self, other):
1346         try:
1347             other = _sympify(other)
1348         except SympifyError:
1349             raise TypeError("Invalid comparison %s < %s" % (self, other))
1350         if other.is_NumberSymbol:
1351             return other.__gt__(self)
1352         if other.is_Rational and not other.is_Integer:
1353             self *= other.q
1354             other = _sympify(other.p)
1355         elif other.is_comparable:
1356             other = other.evalf()
1357         if other.is_Number and other is not S.NaN:
1358             return _sympify(bool(
1359                 mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))
1360         return Expr.__lt__(self, other)
1361 
1362     def __le__(self, other):
1363         try:
1364             other = _sympify(other)
1365         except SympifyError:
1366             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1367         if other.is_NumberSymbol:
1368             return other.__ge__(self)
1369         if other.is_Rational and not other.is_Integer:
1370             self *= other.q
1371             other = _sympify(other.p)
1372         elif other.is_comparable:
1373             other = other.evalf()
1374         if other.is_Number and other is not S.NaN:
1375             return _sympify(bool(
1376                 mlib.mpf_le(self._mpf_, other._as_mpf_val(self._prec))))
1377         return Expr.__le__(self, other)
1378 
1379     def __hash__(self):
1380         return super(Float, self).__hash__()
1381 
1382     def epsilon_eq(self, other, epsilon="1e-15"):
1383         return abs(self - other) < Float(epsilon)
1384 
1385     def _sage_(self):
1386         import sage.all as sage
1387         return sage.RealNumber(str(self))
1388 
1389     def __format__(self, format_spec):
1390         return format(decimal.Decimal(str(self)), format_spec)
1391 
1392 
1393 # Add sympify converters
1394 converter[float] = converter[decimal.Decimal] = Float
1395 
1396 # this is here to work nicely in Sage
1397 RealNumber = Float
1398 
1399 
1400 class Rational(Number):
1401     """Represents rational numbers (p/q) of any size.
1402 
1403     Examples
1404     ========
1405 
1406     >>> from sympy import Rational, nsimplify, S, pi
1407     >>> Rational(1, 2)
1408     1/2
1409 
1410     Rational is unprejudiced in accepting input. If a float is passed, the
1411     underlying value of the binary representation will be returned:
1412 
1413     >>> Rational(.5)
1414     1/2
1415     >>> Rational(.2)
1416     3602879701896397/18014398509481984
1417 
1418     If the simpler representation of the float is desired then consider
1419     limiting the denominator to the desired value or convert the float to
1420     a string (which is roughly equivalent to limiting the denominator to
1421     10**12):
1422 
1423     >>> Rational(str(.2))
1424     1/5
1425     >>> Rational(.2).limit_denominator(10**12)
1426     1/5
1427 
1428     An arbitrarily precise Rational is obtained when a string literal is
1429     passed:
1430 
1431     >>> Rational("1.23")
1432     123/100
1433     >>> Rational('1e-2')
1434     1/100
1435     >>> Rational(".1")
1436     1/10
1437     >>> Rational('1e-2/3.2')
1438     1/320
1439 
1440     The conversion of other types of strings can be handled by
1441     the sympify() function, and conversion of floats to expressions
1442     or simple fractions can be handled with nsimplify:
1443 
1444     >>> S('.[3]')  # repeating digits in brackets
1445     1/3
1446     >>> S('3**2/10')  # general expressions
1447     9/10
1448     >>> nsimplify(.3)  # numbers that have a simple form
1449     3/10
1450 
1451     But if the input does not reduce to a literal Rational, an error will
1452     be raised:
1453 
1454     >>> Rational(pi)
1455     Traceback (most recent call last):
1456     ...
1457     TypeError: invalid input: pi
1458 
1459 
1460     Low-level
1461     ---------
1462 
1463     Access numerator and denominator as .p and .q:
1464 
1465     >>> r = Rational(3, 4)
1466     >>> r
1467     3/4
1468     >>> r.p
1469     3
1470     >>> r.q
1471     4
1472 
1473     Note that p and q return integers (not SymPy Integers) so some care
1474     is needed when using them in expressions:
1475 
1476     >>> r.p/r.q
1477     0.75
1478 
1479     See Also
1480     ========
1481     sympify, sympy.simplify.simplify.nsimplify
1482     """
1483     is_real = True
1484     is_integer = False
1485     is_rational = True
1486     is_number = True
1487 
1488     __slots__ = ['p', 'q']
1489 
1490     is_Rational = True
1491 
1492     @cacheit
1493     def __new__(cls, p, q=None, gcd=None):
1494         if q is None:
1495             if isinstance(p, Rational):
1496                 return p
1497 
1498             if isinstance(p, SYMPY_INTS):
1499                 pass
1500             else:
1501                 if isinstance(p, (float, Float)):
1502                     return Rational(*_as_integer_ratio(p))
1503 
1504                 if not isinstance(p, string_types):
1505                     try:
1506                         p = sympify(p)
1507                     except (SympifyError, SyntaxError):
1508                         pass  # error will raise below
1509                 else:
1510                     if p.count('/') > 1:
1511                         raise TypeError('invalid input: %s' % p)
1512                     p = p.replace(' ', '')
1513                     pq = p.rsplit('/', 1)
1514                     if len(pq) == 2:
1515                         p, q = pq
1516                         fp = fractions.Fraction(p)
1517                         fq = fractions.Fraction(q)
1518                         p = fp/fq
1519                     try:
1520                         p = fractions.Fraction(p)
1521                     except ValueError:
1522                         pass  # error will raise below
1523                     else:
1524                         return Rational(p.numerator, p.denominator, 1)
1525 
1526                 if not isinstance(p, Rational):
1527                     raise TypeError('invalid input: %s' % p)
1528 
1529             q = 1
1530             gcd = 1
1531         else:
1532             p = Rational(p)
1533             q = Rational(q)
1534 
1535         if isinstance(q, Rational):
1536             p *= q.q
1537             q = q.p
1538         if isinstance(p, Rational):
1539             q *= p.q
1540             p = p.p
1541 
1542         # p and q are now integers
1543         if q == 0:
1544             if p == 0:
1545                 if _errdict["divide"]:
1546                     raise ValueError("Indeterminate 0/0")
1547                 else:
1548                     return S.NaN
1549             return S.ComplexInfinity
1550         if q < 0:
1551             q = -q
1552             p = -p
1553         if not gcd:
1554             gcd = igcd(abs(p), q)
1555         if gcd > 1:
1556             p //= gcd
1557             q //= gcd
1558         if q == 1:
1559             return Integer(p)
1560         if p == 1 and q == 2:
1561             return S.Half
1562         obj = Expr.__new__(cls)
1563         obj.p = p
1564         obj.q = q
1565         return obj
1566 
1567     def limit_denominator(self, max_denominator=1000000):
1568         """Closest Rational to self with denominator at most max_denominator.
1569 
1570         >>> from sympy import Rational
1571         >>> Rational('3.141592653589793').limit_denominator(10)
1572         22/7
1573         >>> Rational('3.141592653589793').limit_denominator(100)
1574         311/99
1575 
1576         """
1577         f = fractions.Fraction(self.p, self.q)
1578         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))
1579 
1580     def __getnewargs__(self):
1581         return (self.p, self.q)
1582 
1583     def _hashable_content(self):
1584         return (self.p, self.q)
1585 
1586     def _eval_is_positive(self):
1587         return self.p > 0
1588 
1589     def _eval_is_zero(self):
1590         return self.p == 0
1591 
1592     def __neg__(self):
1593         return Rational(-self.p, self.q)
1594 
1595     @_sympifyit('other', NotImplemented)
1596     def __add__(self, other):
1597         if global_evaluate[0]:
1598             if isinstance(other, Integer):
1599                 return Rational(self.p + self.q*other.p, self.q, 1)
1600             elif isinstance(other, Rational):
1601                 #TODO: this can probably be optimized more
1602                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)
1603             elif isinstance(other, Float):
1604                 return other + self
1605             else:
1606                 return Number.__add__(self, other)
1607         return Number.__add__(self, other)
1608     __radd__ = __add__
1609 
1610     @_sympifyit('other', NotImplemented)
1611     def __sub__(self, other):
1612         if global_evaluate[0]:
1613             if isinstance(other, Integer):
1614                 return Rational(self.p - self.q*other.p, self.q, 1)
1615             elif isinstance(other, Rational):
1616                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)
1617             elif isinstance(other, Float):
1618                 return -other + self
1619             else:
1620                 return Number.__sub__(self, other)
1621         return Number.__sub__(self, other)
1622     @_sympifyit('other', NotImplemented)
1623     def __rsub__(self, other):
1624         if global_evaluate[0]:
1625             if isinstance(other, Integer):
1626                 return Rational(self.q*other.p - self.p, self.q, 1)
1627             elif isinstance(other, Rational):
1628                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)
1629             elif isinstance(other, Float):
1630                 return -self + other
1631             else:
1632                 return Number.__rsub__(self, other)
1633         return Number.__rsub__(self, other)
1634     @_sympifyit('other', NotImplemented)
1635     def __mul__(self, other):
1636         if global_evaluate[0]:
1637             if isinstance(other, Integer):
1638                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))
1639             elif isinstance(other, Rational):
1640                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))
1641             elif isinstance(other, Float):
1642                 return other*self
1643             else:
1644                 return Number.__mul__(self, other)
1645         return Number.__mul__(self, other)
1646     __rmul__ = __mul__
1647 
1648     @_sympifyit('other', NotImplemented)
1649     def __div__(self, other):
1650         if global_evaluate[0]:
1651             if isinstance(other, Integer):
1652                 if self.p and other.p == S.Zero:
1653                     return S.ComplexInfinity
1654                 else:
1655                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))
1656             elif isinstance(other, Rational):
1657                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1658             elif isinstance(other, Float):
1659                 return self*(1/other)
1660             else:
1661                 return Number.__div__(self, other)
1662         return Number.__div__(self, other)
1663     @_sympifyit('other', NotImplemented)
1664     def __rdiv__(self, other):
1665         if global_evaluate[0]:
1666             if isinstance(other, Integer):
1667                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))
1668             elif isinstance(other, Rational):
1669                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1670             elif isinstance(other, Float):
1671                 return other*(1/self)
1672             else:
1673                 return Number.__rdiv__(self, other)
1674         return Number.__rdiv__(self, other)
1675     __truediv__ = __div__
1676 
1677     @_sympifyit('other', NotImplemented)
1678     def __mod__(self, other):
1679         if global_evaluate[0]:
1680             if isinstance(other, Rational):
1681                 n = (self.p*other.q) // (other.p*self.q)
1682                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)
1683             if isinstance(other, Float):
1684                 # calculate mod with Rationals, *then* round the answer
1685                 return Float(self.__mod__(Rational(other)),
1686                              precision=other._prec)
1687             return Number.__mod__(self, other)
1688         return Number.__mod__(self, other)
1689 
1690     @_sympifyit('other', NotImplemented)
1691     def __rmod__(self, other):
1692         if isinstance(other, Rational):
1693             return Rational.__mod__(other, self)
1694         return Number.__rmod__(self, other)
1695 
1696     def _eval_power(self, expt):
1697         if isinstance(expt, Number):
1698             if isinstance(expt, Float):
1699                 return self._eval_evalf(expt._prec)**expt
1700             if expt.is_negative:
1701                 # (3/4)**-2 -> (4/3)**2
1702                 ne = -expt
1703                 if (ne is S.One):
1704                     return Rational(self.q, self.p)
1705                 if self.is_negative:
1706                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne
1707                 else:
1708                     return Rational(self.q, self.p)**ne
1709             if expt is S.Infinity:  # -oo already caught by test for negative
1710                 if self.p > self.q:
1711                     # (3/2)**oo -> oo
1712                     return S.Infinity
1713                 if self.p < -self.q:
1714                     # (-3/2)**oo -> oo + I*oo
1715                     return S.Infinity + S.Infinity*S.ImaginaryUnit
1716                 return S.Zero
1717             if isinstance(expt, Integer):
1718                 # (4/3)**2 -> 4**2 / 3**2
1719                 return Rational(self.p**expt.p, self.q**expt.p, 1)
1720             if isinstance(expt, Rational):
1721                 if self.p != 1:
1722                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)
1723                     return Integer(self.p)**expt*Integer(self.q)**(-expt)
1724                 # as the above caught negative self.p, now self is positive
1725                 return Integer(self.q)**Rational(
1726                 expt.p*(expt.q - 1), expt.q) / \
1727                     Integer(self.q)**Integer(expt.p)
1728 
1729         if self.is_negative and expt.is_even:
1730             return (-self)**expt
1731 
1732         return
1733 
1734     def _as_mpf_val(self, prec):
1735         return mlib.from_rational(self.p, self.q, prec, rnd)
1736 
1737     def _mpmath_(self, prec, rnd):
1738         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))
1739 
1740     def __abs__(self):
1741         return Rational(abs(self.p), self.q)
1742 
1743     def __int__(self):
1744         p, q = self.p, self.q
1745         if p < 0:
1746             return -int(-p//q)
1747         return int(p//q)
1748 
1749     __long__ = __int__
1750 
1751     def floor(self):
1752         return Integer(self.p // self.q)
1753 
1754     def ceiling(self):
1755         return -Integer(-self.p // self.q)
1756 
1757     def __floor__(self):
1758         return self.floor()
1759 
1760     def __ceil__(self):
1761         return self.ceiling()
1762 
1763     def __eq__(self, other):
1764         try:
1765             other = _sympify(other)
1766         except SympifyError:
1767             return NotImplemented
1768         if other.is_NumberSymbol:
1769             if other.is_irrational:
1770                 return False
1771             return other.__eq__(self)
1772         if other.is_Number:
1773             if other.is_Rational:
1774                 # a Rational is always in reduced form so will never be 2/4
1775                 # so we can just check equivalence of args
1776                 return self.p == other.p and self.q == other.q
1777             if other.is_Float:
1778                 return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)
1779         return False
1780 
1781     def __ne__(self, other):
1782         return not self == other
1783 
1784     def __gt__(self, other):
1785         try:
1786             other = _sympify(other)
1787         except SympifyError:
1788             raise TypeError("Invalid comparison %s > %s" % (self, other))
1789         if other.is_NumberSymbol:
1790             return other.__lt__(self)
1791         expr = self
1792         if other.is_Number:
1793             if other.is_Rational:
1794                 return _sympify(bool(self.p*other.q > self.q*other.p))
1795             if other.is_Float:
1796                 return _sympify(bool(mlib.mpf_gt(
1797                     self._as_mpf_val(other._prec), other._mpf_)))
1798         elif other.is_number and other.is_real:
1799             expr, other = Integer(self.p), self.q*other
1800         return Expr.__gt__(expr, other)
1801 
1802     def __ge__(self, other):
1803         try:
1804             other = _sympify(other)
1805         except SympifyError:
1806             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1807         if other.is_NumberSymbol:
1808             return other.__le__(self)
1809         expr = self
1810         if other.is_Number:
1811             if other.is_Rational:
1812                  return _sympify(bool(self.p*other.q >= self.q*other.p))
1813             if other.is_Float:
1814                 return _sympify(bool(mlib.mpf_ge(
1815                     self._as_mpf_val(other._prec), other._mpf_)))
1816         elif other.is_number and other.is_real:
1817             expr, other = Integer(self.p), self.q*other
1818         return Expr.__ge__(expr, other)
1819 
1820     def __lt__(self, other):
1821         try:
1822             other = _sympify(other)
1823         except SympifyError:
1824             raise TypeError("Invalid comparison %s < %s" % (self, other))
1825         if other.is_NumberSymbol:
1826             return other.__gt__(self)
1827         expr = self
1828         if other.is_Number:
1829             if other.is_Rational:
1830                 return _sympify(bool(self.p*other.q < self.q*other.p))
1831             if other.is_Float:
1832                 return _sympify(bool(mlib.mpf_lt(
1833                     self._as_mpf_val(other._prec), other._mpf_)))
1834         elif other.is_number and other.is_real:
1835             expr, other = Integer(self.p), self.q*other
1836         return Expr.__lt__(expr, other)
1837 
1838     def __le__(self, other):
1839         try:
1840             other = _sympify(other)
1841         except SympifyError:
1842             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1843         expr = self
1844         if other.is_NumberSymbol:
1845             return other.__ge__(self)
1846         elif other.is_Number:
1847             if other.is_Rational:
1848                 return _sympify(bool(self.p*other.q <= self.q*other.p))
1849             if other.is_Float:
1850                 return _sympify(bool(mlib.mpf_le(
1851                     self._as_mpf_val(other._prec), other._mpf_)))
1852         elif other.is_number and other.is_real:
1853             expr, other = Integer(self.p), self.q*other
1854         return Expr.__le__(expr, other)
1855 
1856     def __hash__(self):
1857         return super(Rational, self).__hash__()
1858 
1859     def factors(self, limit=None, use_trial=True, use_rho=False,
1860                 use_pm1=False, verbose=False, visual=False):
1861         """A wrapper to factorint which return factors of self that are
1862         smaller than limit (or cheap to compute). Special methods of
1863         factoring are disabled by default so that only trial division is used.
1864         """
1865         from sympy.ntheory import factorrat
1866 
1867         return factorrat(self, limit=limit, use_trial=use_trial,
1868                       use_rho=use_rho, use_pm1=use_pm1,
1869                       verbose=verbose).copy()
1870 
1871     def numerator(self):
1872         return self.p
1873 
1874     def denominator(self):
1875         return self.q
1876 
1877     @_sympifyit('other', NotImplemented)
1878     def gcd(self, other):
1879         if isinstance(other, Rational):
1880             if other is S.Zero:
1881                 return other
1882             return Rational(
1883                 Integer(igcd(self.p, other.p)),
1884                 Integer(ilcm(self.q, other.q)))
1885         return Number.gcd(self, other)
1886 
1887     @_sympifyit('other', NotImplemented)
1888     def lcm(self, other):
1889         if isinstance(other, Rational):
1890             return Rational(
1891                 self.p // igcd(self.p, other.p) * other.p,
1892                 igcd(self.q, other.q))
1893         return Number.lcm(self, other)
1894 
1895     def as_numer_denom(self):
1896         return Integer(self.p), Integer(self.q)
1897 
1898     def _sage_(self):
1899         import sage.all as sage
1900         return sage.Integer(self.p)/sage.Integer(self.q)
1901 
1902     def as_content_primitive(self, radical=False, clear=True):
1903         """Return the tuple (R, self/R) where R is the positive Rational
1904         extracted from self.
1905 
1906         Examples
1907         ========
1908 
1909         >>> from sympy import S
1910         >>> (S(-3)/2).as_content_primitive()
1911         (3/2, -1)
1912 
1913         See docstring of Expr.as_content_primitive for more examples.
1914         """
1915 
1916         if self:
1917             if self.is_positive:
1918                 return self, S.One
1919             return -self, S.NegativeOne
1920         return S.One, self
1921 
1922     def as_coeff_Mul(self, rational=False):
1923         """Efficiently extract the coefficient of a product. """
1924         return self, S.One
1925 
1926     def as_coeff_Add(self, rational=False):
1927         """Efficiently extract the coefficient of a summation. """
1928         return self, S.Zero
1929 
1930 
1931 class Integer(Rational):
1932     """Represents integer numbers of any size.
1933 
1934     Examples
1935     ========
1936 
1937     >>> from sympy import Integer
1938     >>> Integer(3)
1939     3
1940 
1941     If a float or a rational is passed to Integer, the fractional part
1942     will be discarded; the effect is of rounding toward zero.
1943 
1944     >>> Integer(3.8)
1945     3
1946     >>> Integer(-3.8)
1947     -3
1948 
1949     A string is acceptable input if it can be parsed as an integer:
1950 
1951     >>> Integer("9" * 20)
1952     99999999999999999999
1953 
1954     It is rarely needed to explicitly instantiate an Integer, because
1955     Python integers are automatically converted to Integer when they
1956     are used in SymPy expressions.
1957     """
1958     q = 1
1959     is_integer = True
1960     is_number = True
1961 
1962     is_Integer = True
1963 
1964     __slots__ = ['p']
1965 
1966     def _as_mpf_val(self, prec):
1967         return mlib.from_int(self.p, prec, rnd)
1968 
1969     def _mpmath_(self, prec, rnd):
1970         return mpmath.make_mpf(self._as_mpf_val(prec))
1971 
1972     @cacheit
1973     def __new__(cls, i):
1974         if isinstance(i, string_types):
1975             i = i.replace(' ', '')
1976         # whereas we cannot, in general, make a Rational from an
1977         # arbitrary expression, we can make an Integer unambiguously
1978         # (except when a non-integer expression happens to round to
1979         # an integer). So we proceed by taking int() of the input and
1980         # let the int routines determine whether the expression can
1981         # be made into an int or whether an error should be raised.
1982         try:
1983             ival = int(i)
1984         except TypeError:
1985             raise TypeError(
1986                 "Argument of Integer should be of numeric type, got %s." % i)
1987         # We only work with well-behaved integer types. This converts, for
1988         # example, numpy.int32 instances.
1989         if ival == 1:
1990             return S.One
1991         if ival == -1:
1992             return S.NegativeOne
1993         if ival == 0:
1994             return S.Zero
1995         obj = Expr.__new__(cls)
1996         obj.p = ival
1997         return obj
1998 
1999     def __getnewargs__(self):
2000         return (self.p,)
2001 
2002     # Arithmetic operations are here for efficiency
2003     def __int__(self):
2004         return self.p
2005 
2006     __long__ = __int__
2007 
2008     def floor(self):
2009         return Integer(self.p)
2010 
2011     def ceiling(self):
2012         return Integer(self.p)
2013 
2014     def __floor__(self):
2015         return self.floor()
2016 
2017     def __ceil__(self):
2018         return self.ceiling()
2019 
2020     def __neg__(self):
2021         return Integer(-self.p)
2022 
2023     def __abs__(self):
2024         if self.p >= 0:
2025             return self
2026         else:
2027             return Integer(-self.p)
2028 
2029     def __divmod__(self, other):
2030         from .containers import Tuple
2031         if isinstance(other, Integer) and global_evaluate[0]:
2032             return Tuple(*(divmod(self.p, other.p)))
2033         else:
2034             return Number.__divmod__(self, other)
2035 
2036     def __rdivmod__(self, other):
2037         from .containers import Tuple
2038         if isinstance(other, integer_types) and global_evaluate[0]:
2039             return Tuple(*(divmod(other, self.p)))
2040         else:
2041             try:
2042                 other = Number(other)
2043             except TypeError:
2044                 msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
2045                 oname = type(other).__name__
2046                 sname = type(self).__name__
2047                 raise TypeError(msg % (oname, sname))
2048             return Number.__divmod__(other, self)
2049 
2050     # TODO make it decorator + bytecodehacks?
2051     def __add__(self, other):
2052         if global_evaluate[0]:
2053             if isinstance(other, integer_types):
2054                 return Integer(self.p + other)
2055             elif isinstance(other, Integer):
2056                 return Integer(self.p + other.p)
2057             elif isinstance(other, Rational):
2058                 return Rational(self.p*other.q + other.p, other.q, 1)
2059             return Rational.__add__(self, other)
2060         else:
2061             return Add(self, other)
2062 
2063     def __radd__(self, other):
2064         if global_evaluate[0]:
2065             if isinstance(other, integer_types):
2066                 return Integer(other + self.p)
2067             elif isinstance(other, Rational):
2068                 return Rational(other.p + self.p*other.q, other.q, 1)
2069             return Rational.__radd__(self, other)
2070         return Rational.__radd__(self, other)
2071 
2072     def __sub__(self, other):
2073         if global_evaluate[0]:
2074             if isinstance(other, integer_types):
2075                 return Integer(self.p - other)
2076             elif isinstance(other, Integer):
2077                 return Integer(self.p - other.p)
2078             elif isinstance(other, Rational):
2079                 return Rational(self.p*other.q - other.p, other.q, 1)
2080             return Rational.__sub__(self, other)
2081         return Rational.__sub__(self, other)
2082 
2083     def __rsub__(self, other):
2084         if global_evaluate[0]:
2085             if isinstance(other, integer_types):
2086                 return Integer(other - self.p)
2087             elif isinstance(other, Rational):
2088                 return Rational(other.p - self.p*other.q, other.q, 1)
2089             return Rational.__rsub__(self, other)
2090         return Rational.__rsub__(self, other)
2091 
2092     def __mul__(self, other):
2093         if global_evaluate[0]:
2094             if isinstance(other, integer_types):
2095                 return Integer(self.p*other)
2096             elif isinstance(other, Integer):
2097                 return Integer(self.p*other.p)
2098             elif isinstance(other, Rational):
2099                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))
2100             return Rational.__mul__(self, other)
2101         return Rational.__mul__(self, other)
2102 
2103     def __rmul__(self, other):
2104         if global_evaluate[0]:
2105             if isinstance(other, integer_types):
2106                 return Integer(other*self.p)
2107             elif isinstance(other, Rational):
2108                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))
2109             return Rational.__rmul__(self, other)
2110         return Rational.__rmul__(self, other)
2111 
2112     def __mod__(self, other):
2113         if global_evaluate[0]:
2114             if isinstance(other, integer_types):
2115                 return Integer(self.p % other)
2116             elif isinstance(other, Integer):
2117                 return Integer(self.p % other.p)
2118             return Rational.__mod__(self, other)
2119         return Rational.__mod__(self, other)
2120 
2121     def __rmod__(self, other):
2122         if global_evaluate[0]:
2123             if isinstance(other, integer_types):
2124                 return Integer(other % self.p)
2125             elif isinstance(other, Integer):
2126                 return Integer(other.p % self.p)
2127             return Rational.__rmod__(self, other)
2128         return Rational.__rmod__(self, other)
2129 
2130     def __eq__(self, other):
2131         if isinstance(other, integer_types):
2132             return (self.p == other)
2133         elif isinstance(other, Integer):
2134             return (self.p == other.p)
2135         return Rational.__eq__(self, other)
2136 
2137     def __ne__(self, other):
2138         return not self == other
2139 
2140     def __gt__(self, other):
2141         try:
2142             other = _sympify(other)
2143         except SympifyError:
2144             raise TypeError("Invalid comparison %s > %s" % (self, other))
2145         if other.is_Integer:
2146             return _sympify(self.p > other.p)
2147         return Rational.__gt__(self, other)
2148 
2149     def __lt__(self, other):
2150         try:
2151             other = _sympify(other)
2152         except SympifyError:
2153             raise TypeError("Invalid comparison %s < %s" % (self, other))
2154         if other.is_Integer:
2155             return _sympify(self.p < other.p)
2156         return Rational.__lt__(self, other)
2157 
2158     def __ge__(self, other):
2159         try:
2160             other = _sympify(other)
2161         except SympifyError:
2162             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2163         if other.is_Integer:
2164             return _sympify(self.p >= other.p)
2165         return Rational.__ge__(self, other)
2166 
2167     def __le__(self, other):
2168         try:
2169             other = _sympify(other)
2170         except SympifyError:
2171             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2172         if other.is_Integer:
2173             return _sympify(self.p <= other.p)
2174         return Rational.__le__(self, other)
2175 
2176     def __hash__(self):
2177         return hash(self.p)
2178 
2179     def __index__(self):
2180         return self.p
2181 
2182     ########################################
2183 
2184     def _eval_is_odd(self):
2185         return bool(self.p % 2)
2186 
2187     def _eval_power(self, expt):
2188         """
2189         Tries to do some simplifications on self**expt
2190 
2191         Returns None if no further simplifications can be done
2192 
2193         When exponent is a fraction (so we have for example a square root),
2194         we try to find a simpler representation by factoring the argument
2195         up to factors of 2**15, e.g.
2196 
2197           - sqrt(4) becomes 2
2198           - sqrt(-4) becomes 2*I
2199           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)
2200 
2201         Further simplification would require a special call to factorint on
2202         the argument which is not done here for sake of speed.
2203 
2204         """
2205         from sympy import perfect_power
2206 
2207         if expt is S.Infinity:
2208             if self.p > S.One:
2209                 return S.Infinity
2210             # cases -1, 0, 1 are done in their respective classes
2211             return S.Infinity + S.ImaginaryUnit*S.Infinity
2212         if expt is S.NegativeInfinity:
2213             return Rational(1, self)**S.Infinity
2214         if not isinstance(expt, Number):
2215             # simplify when expt is even
2216             # (-2)**k --> 2**k
2217             if self.is_negative and expt.is_even:
2218                 return (-self)**expt
2219         if isinstance(expt, Float):
2220             # Rational knows how to exponentiate by a Float
2221             return super(Integer, self)._eval_power(expt)
2222         if not isinstance(expt, Rational):
2223             return
2224         if expt is S.Half and self.is_negative:
2225             # we extract I for this special case since everyone is doing so
2226             return S.ImaginaryUnit*Pow(-self, expt)
2227         if expt.is_negative:
2228             # invert base and change sign on exponent
2229             ne = -expt
2230             if self.is_negative:
2231                     return S.NegativeOne**expt*Rational(1, -self)**ne
2232             else:
2233                 return Rational(1, self.p)**ne
2234         # see if base is a perfect root, sqrt(4) --> 2
2235         x, xexact = integer_nthroot(abs(self.p), expt.q)
2236         if xexact:
2237             # if it's a perfect root we've finished
2238             result = Integer(x**abs(expt.p))
2239             if self.is_negative:
2240                 result *= S.NegativeOne**expt
2241             return result
2242 
2243         # The following is an algorithm where we collect perfect roots
2244         # from the factors of base.
2245 
2246         # if it's not an nth root, it still might be a perfect power
2247         b_pos = int(abs(self.p))
2248         p = perfect_power(b_pos)
2249         if p is not False:
2250             dict = {p[0]: p[1]}
2251         else:
2252             dict = Integer(b_pos).factors(limit=2**15)
2253 
2254         # now process the dict of factors
2255         out_int = 1  # integer part
2256         out_rad = 1  # extracted radicals
2257         sqr_int = 1
2258         sqr_gcd = 0
2259         sqr_dict = {}
2260         for prime, exponent in dict.items():
2261             exponent *= expt.p
2262             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)
2263             div_e, div_m = divmod(exponent, expt.q)
2264             if div_e > 0:
2265                 out_int *= prime**div_e
2266             if div_m > 0:
2267                 # see if the reduced exponent shares a gcd with e.q
2268                 # (2**2)**(1/10) -> 2**(1/5)
2269                 g = igcd(div_m, expt.q)
2270                 if g != 1:
2271                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))
2272                 else:
2273                     sqr_dict[prime] = div_m
2274         # identify gcd of remaining powers
2275         for p, ex in sqr_dict.items():
2276             if sqr_gcd == 0:
2277                 sqr_gcd = ex
2278             else:
2279                 sqr_gcd = igcd(sqr_gcd, ex)
2280                 if sqr_gcd == 1:
2281                     break
2282         for k, v in sqr_dict.items():
2283             sqr_int *= k**(v//sqr_gcd)
2284         if sqr_int == b_pos and out_int == 1 and out_rad == 1:
2285             result = None
2286         else:
2287             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))
2288             if self.is_negative:
2289                 result *= Pow(S.NegativeOne, expt)
2290         return result
2291 
2292     def _eval_is_prime(self):
2293         from sympy.ntheory import isprime
2294 
2295         return isprime(self)
2296 
2297     def _eval_is_composite(self):
2298         if self > 1:
2299             return fuzzy_not(self.is_prime)
2300         else:
2301             return False
2302 
2303     def as_numer_denom(self):
2304         return self, S.One
2305 
2306     def __floordiv__(self, other):
2307         return Integer(self.p // Integer(other).p)
2308 
2309     def __rfloordiv__(self, other):
2310         return Integer(Integer(other).p // self.p)
2311 
2312 # Add sympify converters
2313 for i_type in integer_types:
2314     converter[i_type] = Integer
2315 
2316 
2317 class AlgebraicNumber(Expr):
2318     """Class for representing algebraic numbers in SymPy. """
2319 
2320     __slots__ = ['rep', 'root', 'alias', 'minpoly']
2321 
2322     is_AlgebraicNumber = True
2323     is_algebraic = True
2324     is_number = True
2325 
2326     def __new__(cls, expr, coeffs=None, alias=None, **args):
2327         """Construct a new algebraic number. """
2328         from sympy import Poly
2329         from sympy.polys.polyclasses import ANP, DMP
2330         from sympy.polys.numberfields import minimal_polynomial
2331         from sympy.core.symbol import Symbol
2332 
2333         expr = sympify(expr)
2334 
2335         if isinstance(expr, (tuple, Tuple)):
2336             minpoly, root = expr
2337 
2338             if not minpoly.is_Poly:
2339                 minpoly = Poly(minpoly)
2340         elif expr.is_AlgebraicNumber:
2341             minpoly, root = expr.minpoly, expr.root
2342         else:
2343             minpoly, root = minimal_polynomial(
2344                 expr, args.get('gen'), polys=True), expr
2345 
2346         dom = minpoly.get_domain()
2347 
2348         if coeffs is not None:
2349             if not isinstance(coeffs, ANP):
2350                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)
2351                 scoeffs = Tuple(*coeffs)
2352             else:
2353                 rep = DMP.from_list(coeffs.to_list(), 0, dom)
2354                 scoeffs = Tuple(*coeffs.to_list())
2355 
2356             if rep.degree() >= minpoly.degree():
2357                 rep = rep.rem(minpoly.rep)
2358 
2359         else:
2360             rep = DMP.from_list([1, 0], 0, dom)
2361             scoeffs = Tuple(1, 0)
2362 
2363         sargs = (root, scoeffs)
2364 
2365         if alias is not None:
2366             if not isinstance(alias, Symbol):
2367                 alias = Symbol(alias)
2368             sargs = sargs + (alias,)
2369 
2370         obj = Expr.__new__(cls, *sargs)
2371 
2372         obj.rep = rep
2373         obj.root = root
2374         obj.alias = alias
2375         obj.minpoly = minpoly
2376 
2377         return obj
2378 
2379     def __hash__(self):
2380         return super(AlgebraicNumber, self).__hash__()
2381 
2382     def _eval_evalf(self, prec):
2383         return self.as_expr()._evalf(prec)
2384 
2385     @property
2386     def is_aliased(self):
2387         """Returns ``True`` if ``alias`` was set. """
2388         return self.alias is not None
2389 
2390     def as_poly(self, x=None):
2391         """Create a Poly instance from ``self``. """
2392         from sympy import Dummy, Poly, PurePoly
2393         if x is not None:
2394             return Poly.new(self.rep, x)
2395         else:
2396             if self.alias is not None:
2397                 return Poly.new(self.rep, self.alias)
2398             else:
2399                 return PurePoly.new(self.rep, Dummy('x'))
2400 
2401     def as_expr(self, x=None):
2402         """Create a Basic expression from ``self``. """
2403         return self.as_poly(x or self.root).as_expr().expand()
2404 
2405     def coeffs(self):
2406         """Returns all SymPy coefficients of an algebraic number. """
2407         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]
2408 
2409     def native_coeffs(self):
2410         """Returns all native coefficients of an algebraic number. """
2411         return self.rep.all_coeffs()
2412 
2413     def to_algebraic_integer(self):
2414         """Convert ``self`` to an algebraic integer. """
2415         from sympy import Poly
2416         f = self.minpoly
2417 
2418         if f.LC() == 1:
2419             return self
2420 
2421         coeff = f.LC()**(f.degree() - 1)
2422         poly = f.compose(Poly(f.gen/f.LC()))
2423 
2424         minpoly = poly*coeff
2425         root = f.LC()*self.root
2426 
2427         return AlgebraicNumber((minpoly, root), self.coeffs())
2428 
2429     def _eval_simplify(self, ratio, measure, rational, inverse):
2430         from sympy.polys import CRootOf, minpoly
2431 
2432         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:
2433             if minpoly(self.root - r).is_Symbol:
2434                 # use the matching root if it's simpler
2435                 if measure(r) < ratio*measure(self.root):
2436                     return AlgebraicNumber(r)
2437         return self
2438 
2439 
2440 class RationalConstant(Rational):
2441     """
2442     Abstract base class for rationals with specific behaviors
2443 
2444     Derived classes must define class attributes p and q and should probably all
2445     be singletons.
2446     """
2447     __slots__ = []
2448 
2449     def __new__(cls):
2450         return AtomicExpr.__new__(cls)
2451 
2452 
2453 class IntegerConstant(Integer):
2454     __slots__ = []
2455 
2456     def __new__(cls):
2457         return AtomicExpr.__new__(cls)
2458 
2459 
2460 class Zero(with_metaclass(Singleton, IntegerConstant)):
2461     """The number zero.
2462 
2463     Zero is a singleton, and can be accessed by ``S.Zero``
2464 
2465     Examples
2466     ========
2467 
2468     >>> from sympy import S, Integer, zoo
2469     >>> Integer(0) is S.Zero
2470     True
2471     >>> 1/S.Zero
2472     zoo
2473 
2474     References
2475     ==========
2476 
2477     .. [1] https://en.wikipedia.org/wiki/Zero
2478     """
2479 
2480     p = 0
2481     q = 1
2482     is_positive = False
2483     is_negative = False
2484     is_zero = True
2485     is_number = True
2486 
2487     __slots__ = []
2488 
2489     @staticmethod
2490     def __abs__():
2491         return S.Zero
2492 
2493     @staticmethod
2494     def __neg__():
2495         return S.Zero
2496 
2497     def _eval_power(self, expt):
2498         if expt.is_positive:
2499             return self
2500         if expt.is_negative:
2501             return S.ComplexInfinity
2502         if expt.is_real is False:
2503             return S.NaN
2504         # infinities are already handled with pos and neg
2505         # tests above; now throw away leading numbers on Mul
2506         # exponent
2507         coeff, terms = expt.as_coeff_Mul()
2508         if coeff.is_negative:
2509             return S.ComplexInfinity**terms
2510         if coeff is not S.One:  # there is a Number to discard
2511             return self**terms
2512 
2513     def _eval_order(self, *symbols):
2514         # Order(0,x) -> 0
2515         return self
2516 
2517     def __nonzero__(self):
2518         return False
2519 
2520     __bool__ = __nonzero__
2521 
2522     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted
2523         """Efficiently extract the coefficient of a summation. """
2524         return S.One, self
2525 
2526 
2527 class One(with_metaclass(Singleton, IntegerConstant)):
2528     """The number one.
2529 
2530     One is a singleton, and can be accessed by ``S.One``.
2531 
2532     Examples
2533     ========
2534 
2535     >>> from sympy import S, Integer
2536     >>> Integer(1) is S.One
2537     True
2538 
2539     References
2540     ==========
2541 
2542     .. [1] https://en.wikipedia.org/wiki/1_%28number%29
2543     """
2544     is_number = True
2545 
2546     p = 1
2547     q = 1
2548 
2549     __slots__ = []
2550 
2551     @staticmethod
2552     def __abs__():
2553         return S.One
2554 
2555     @staticmethod
2556     def __neg__():
2557         return S.NegativeOne
2558 
2559     def _eval_power(self, expt):
2560         return self
2561 
2562     def _eval_order(self, *symbols):
2563         return
2564 
2565     @staticmethod
2566     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,
2567                 verbose=False, visual=False):
2568         if visual:
2569             return S.One
2570         else:
2571             return {}
2572 
2573 
2574 class NegativeOne(with_metaclass(Singleton, IntegerConstant)):
2575     """The number negative one.
2576 
2577     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.
2578 
2579     Examples
2580     ========
2581 
2582     >>> from sympy import S, Integer
2583     >>> Integer(-1) is S.NegativeOne
2584     True
2585 
2586     See Also
2587     ========
2588 
2589     One
2590 
2591     References
2592     ==========
2593 
2594     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29
2595 
2596     """
2597     is_number = True
2598 
2599     p = -1
2600     q = 1
2601 
2602     __slots__ = []
2603 
2604     @staticmethod
2605     def __abs__():
2606         return S.One
2607 
2608     @staticmethod
2609     def __neg__():
2610         return S.One
2611 
2612     def _eval_power(self, expt):
2613         if expt.is_odd:
2614             return S.NegativeOne
2615         if expt.is_even:
2616             return S.One
2617         if isinstance(expt, Number):
2618             if isinstance(expt, Float):
2619                 return Float(-1.0)**expt
2620             if expt is S.NaN:
2621                 return S.NaN
2622             if expt is S.Infinity or expt is S.NegativeInfinity:
2623                 return S.NaN
2624             if expt is S.Half:
2625                 return S.ImaginaryUnit
2626             if isinstance(expt, Rational):
2627                 if expt.q == 2:
2628                     return S.ImaginaryUnit**Integer(expt.p)
2629                 i, r = divmod(expt.p, expt.q)
2630                 if i:
2631                     return self**i*self**Rational(r, expt.q)
2632         return
2633 
2634 
2635 class Half(with_metaclass(Singleton, RationalConstant)):
2636     """The rational number 1/2.
2637 
2638     Half is a singleton, and can be accessed by ``S.Half``.
2639 
2640     Examples
2641     ========
2642 
2643     >>> from sympy import S, Rational
2644     >>> Rational(1, 2) is S.Half
2645     True
2646 
2647     References
2648     ==========
2649 
2650     .. [1] https://en.wikipedia.org/wiki/One_half
2651     """
2652     is_number = True
2653 
2654     p = 1
2655     q = 2
2656 
2657     __slots__ = []
2658 
2659     @staticmethod
2660     def __abs__():
2661         return S.Half
2662 
2663 
2664 class Infinity(with_metaclass(Singleton, Number)):
2665     r"""Positive infinite quantity.
2666 
2667     In real analysis the symbol `\infty` denotes an unbounded
2668     limit: `x\to\infty` means that `x` grows without bound.
2669 
2670     Infinity is often used not only to define a limit but as a value
2671     in the affinely extended real number system.  Points labeled `+\infty`
2672     and `-\infty` can be added to the topological space of the real numbers,
2673     producing the two-point compactification of the real numbers.  Adding
2674     algebraic properties to this gives us the extended real numbers.
2675 
2676     Infinity is a singleton, and can be accessed by ``S.Infinity``,
2677     or can be imported as ``oo``.
2678 
2679     Examples
2680     ========
2681 
2682     >>> from sympy import oo, exp, limit, Symbol
2683     >>> 1 + oo
2684     oo
2685     >>> 42/oo
2686     0
2687     >>> x = Symbol('x')
2688     >>> limit(exp(x), x, oo)
2689     oo
2690 
2691     See Also
2692     ========
2693 
2694     NegativeInfinity, NaN
2695 
2696     References
2697     ==========
2698 
2699     .. [1] https://en.wikipedia.org/wiki/Infinity
2700     """
2701 
2702     is_commutative = True
2703     is_positive = True
2704     is_infinite = True
2705     is_number = True
2706     is_prime = False
2707 
2708     __slots__ = []
2709 
2710     def __new__(cls):
2711         return AtomicExpr.__new__(cls)
2712 
2713     def _latex(self, printer):
2714         return r"\infty"
2715 
2716     def _eval_subs(self, old, new):
2717         if self == old:
2718             return new
2719 
2720     @_sympifyit('other', NotImplemented)
2721     def __add__(self, other):
2722         if isinstance(other, Number):
2723             if other is S.NegativeInfinity or other is S.NaN:
2724                 return S.NaN
2725             return self
2726         return NotImplemented
2727     __radd__ = __add__
2728 
2729     @_sympifyit('other', NotImplemented)
2730     def __sub__(self, other):
2731         if isinstance(other, Number):
2732             if other is S.Infinity or other is S.NaN:
2733                 return S.NaN
2734             return self
2735         return NotImplemented
2736 
2737     @_sympifyit('other', NotImplemented)
2738     def __rsub__(self, other):
2739         return (-self).__add__(other)
2740 
2741     @_sympifyit('other', NotImplemented)
2742     def __mul__(self, other):
2743         if isinstance(other, Number):
2744             if other.is_zero or other is S.NaN:
2745                 return S.NaN
2746             if other.is_positive:
2747                 return self
2748             return S.NegativeInfinity
2749         return NotImplemented
2750     __rmul__ = __mul__
2751 
2752     @_sympifyit('other', NotImplemented)
2753     def __div__(self, other):
2754         if isinstance(other, Number):
2755             if other is S.Infinity or \
2756                 other is S.NegativeInfinity or \
2757                     other is S.NaN:
2758                 return S.NaN
2759             if other.is_nonnegative:
2760                 return self
2761             return S.NegativeInfinity
2762         return NotImplemented
2763 
2764     __truediv__ = __div__
2765 
2766     def __abs__(self):
2767         return S.Infinity
2768 
2769     def __neg__(self):
2770         return S.NegativeInfinity
2771 
2772     def _eval_power(self, expt):
2773         """
2774         ``expt`` is symbolic object but not equal to 0 or 1.
2775 
2776         ================ ======= ==============================
2777         Expression       Result  Notes
2778         ================ ======= ==============================
2779         ``oo ** nan``    ``nan``
2780         ``oo ** -p``     ``0``   ``p`` is number, ``oo``
2781         ================ ======= ==============================
2782 
2783         See Also
2784         ========
2785         Pow
2786         NaN
2787         NegativeInfinity
2788 
2789         """
2790         from sympy.functions import re
2791 
2792         if expt.is_positive:
2793             return S.Infinity
2794         if expt.is_negative:
2795             return S.Zero
2796         if expt is S.NaN:
2797             return S.NaN
2798         if expt is S.ComplexInfinity:
2799             return S.NaN
2800         if expt.is_real is False and expt.is_number:
2801             expt_real = re(expt)
2802             if expt_real.is_positive:
2803                 return S.ComplexInfinity
2804             if expt_real.is_negative:
2805                 return S.Zero
2806             if expt_real.is_zero:
2807                 return S.NaN
2808 
2809             return self**expt.evalf()
2810 
2811     def _as_mpf_val(self, prec):
2812         return mlib.finf
2813 
2814     def _sage_(self):
2815         import sage.all as sage
2816         return sage.oo
2817 
2818     def __hash__(self):
2819         return super(Infinity, self).__hash__()
2820 
2821     def __eq__(self, other):
2822         return other is S.Infinity or other == float('inf')
2823 
2824     def __ne__(self, other):
2825         return other is not S.Infinity and other != float('inf')
2826 
2827     def __lt__(self, other):
2828         try:
2829             other = _sympify(other)
2830         except SympifyError:
2831             raise TypeError("Invalid comparison %s < %s" % (self, other))
2832         if other.is_real:
2833             return S.false
2834         return Expr.__lt__(self, other)
2835 
2836     def __le__(self, other):
2837         try:
2838             other = _sympify(other)
2839         except SympifyError:
2840             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2841         if other.is_real:
2842             if other.is_finite or other is S.NegativeInfinity:
2843                 return S.false
2844             elif other.is_nonpositive:
2845                 return S.false
2846             elif other.is_infinite and other.is_positive:
2847                 return S.true
2848         return Expr.__le__(self, other)
2849 
2850     def __gt__(self, other):
2851         try:
2852             other = _sympify(other)
2853         except SympifyError:
2854             raise TypeError("Invalid comparison %s > %s" % (self, other))
2855         if other.is_real:
2856             if other.is_finite or other is S.NegativeInfinity:
2857                 return S.true
2858             elif other.is_nonpositive:
2859                 return S.true
2860             elif other.is_infinite and other.is_positive:
2861                 return S.false
2862         return Expr.__gt__(self, other)
2863 
2864     def __ge__(self, other):
2865         try:
2866             other = _sympify(other)
2867         except SympifyError:
2868             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2869         if other.is_real:
2870             return S.true
2871         return Expr.__ge__(self, other)
2872 
2873     def __mod__(self, other):
2874         return S.NaN
2875 
2876     __rmod__ = __mod__
2877 
2878     def floor(self):
2879         return self
2880 
2881     def ceiling(self):
2882         return self
2883 
2884 oo = S.Infinity
2885 
2886 
2887 class NegativeInfinity(with_metaclass(Singleton, Number)):
2888     """Negative infinite quantity.
2889 
2890     NegativeInfinity is a singleton, and can be accessed
2891     by ``S.NegativeInfinity``.
2892 
2893     See Also
2894     ========
2895 
2896     Infinity
2897     """
2898 
2899     is_commutative = True
2900     is_negative = True
2901     is_infinite = True
2902     is_number = True
2903 
2904     __slots__ = []
2905 
2906     def __new__(cls):
2907         return AtomicExpr.__new__(cls)
2908 
2909     def _latex(self, printer):
2910         return r"-\infty"
2911 
2912     def _eval_subs(self, old, new):
2913         if self == old:
2914             return new
2915 
2916     @_sympifyit('other', NotImplemented)
2917     def __add__(self, other):
2918         if isinstance(other, Number):
2919             if other is S.Infinity or other is S.NaN:
2920                 return S.NaN
2921             return self
2922         return NotImplemented
2923     __radd__ = __add__
2924 
2925     @_sympifyit('other', NotImplemented)
2926     def __sub__(self, other):
2927         if isinstance(other, Number):
2928             if other is S.NegativeInfinity or other is S.NaN:
2929                 return S.NaN
2930             return self
2931         return NotImplemented
2932 
2933     @_sympifyit('other', NotImplemented)
2934     def __rsub__(self, other):
2935         return (-self).__add__(other)
2936 
2937     @_sympifyit('other', NotImplemented)
2938     def __mul__(self, other):
2939         if isinstance(other, Number):
2940             if other.is_zero or other is S.NaN:
2941                 return S.NaN
2942             if other.is_positive:
2943                 return self
2944             return S.Infinity
2945         return NotImplemented
2946     __rmul__ = __mul__
2947 
2948     @_sympifyit('other', NotImplemented)
2949     def __div__(self, other):
2950         if isinstance(other, Number):
2951             if other is S.Infinity or \
2952                 other is S.NegativeInfinity or \
2953                     other is S.NaN:
2954                 return S.NaN
2955             if other.is_nonnegative:
2956                 return self
2957             return S.Infinity
2958         return NotImplemented
2959 
2960     __truediv__ = __div__
2961 
2962     def __abs__(self):
2963         return S.Infinity
2964 
2965     def __neg__(self):
2966         return S.Infinity
2967 
2968     def _eval_power(self, expt):
2969         """
2970         ``expt`` is symbolic object but not equal to 0 or 1.
2971 
2972         ================ ======= ==============================
2973         Expression       Result  Notes
2974         ================ ======= ==============================
2975         ``(-oo) ** nan`` ``nan``
2976         ``(-oo) ** oo``  ``nan``
2977         ``(-oo) ** -oo`` ``nan``
2978         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer
2979         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer
2980         ================ ======= ==============================
2981 
2982         See Also
2983         ========
2984 
2985         Infinity
2986         Pow
2987         NaN
2988 
2989         """
2990         if expt.is_number:
2991             if expt is S.NaN or \
2992                 expt is S.Infinity or \
2993                     expt is S.NegativeInfinity:
2994                 return S.NaN
2995 
2996             if isinstance(expt, Integer) and expt.is_positive:
2997                 if expt.is_odd:
2998                     return S.NegativeInfinity
2999                 else:
3000                     return S.Infinity
3001 
3002             return S.NegativeOne**expt*S.Infinity**expt
3003 
3004     def _as_mpf_val(self, prec):
3005         return mlib.fninf
3006 
3007     def _sage_(self):
3008         import sage.all as sage
3009         return -(sage.oo)
3010 
3011     def __hash__(self):
3012         return super(NegativeInfinity, self).__hash__()
3013 
3014     def __eq__(self, other):
3015         return other is S.NegativeInfinity or other == float('-inf')
3016 
3017     def __ne__(self, other):
3018         return other is not S.NegativeInfinity and other != float('-inf')
3019 
3020     def __lt__(self, other):
3021         try:
3022             other = _sympify(other)
3023         except SympifyError:
3024             raise TypeError("Invalid comparison %s < %s" % (self, other))
3025         if other.is_real:
3026             if other.is_finite or other is S.Infinity:
3027                 return S.true
3028             elif other.is_nonnegative:
3029                 return S.true
3030             elif other.is_infinite and other.is_negative:
3031                 return S.false
3032         return Expr.__lt__(self, other)
3033 
3034     def __le__(self, other):
3035         try:
3036             other = _sympify(other)
3037         except SympifyError:
3038             raise TypeError("Invalid comparison %s <= %s" % (self, other))
3039         if other.is_real:
3040             return S.true
3041         return Expr.__le__(self, other)
3042 
3043     def __gt__(self, other):
3044         try:
3045             other = _sympify(other)
3046         except SympifyError:
3047             raise TypeError("Invalid comparison %s > %s" % (self, other))
3048         if other.is_real:
3049             return S.false
3050         return Expr.__gt__(self, other)
3051 
3052     def __ge__(self, other):
3053         try:
3054             other = _sympify(other)
3055         except SympifyError:
3056             raise TypeError("Invalid comparison %s >= %s" % (self, other))
3057         if other.is_real:
3058             if other.is_finite or other is S.Infinity:
3059                 return S.false
3060             elif other.is_nonnegative:
3061                 return S.false
3062             elif other.is_infinite and other.is_negative:
3063                 return S.true
3064         return Expr.__ge__(self, other)
3065 
3066     def __mod__(self, other):
3067         return S.NaN
3068 
3069     __rmod__ = __mod__
3070 
3071     def floor(self):
3072         return self
3073 
3074     def ceiling(self):
3075         return self
3076 
3077 
3078 class NaN(with_metaclass(Singleton, Number)):
3079     """
3080     Not a Number.
3081 
3082     This serves as a place holder for numeric values that are indeterminate.
3083     Most operations on NaN, produce another NaN.  Most indeterminate forms,
3084     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``
3085     and ``oo**0``, which all produce ``1`` (this is consistent with Python's
3086     float).
3087 
3088     NaN is loosely related to floating point nan, which is defined in the
3089     IEEE 754 floating point standard, and corresponds to the Python
3090     ``float('nan')``.  Differences are noted below.
3091 
3092     NaN is mathematically not equal to anything else, even NaN itself.  This
3093     explains the initially counter-intuitive results with ``Eq`` and ``==`` in
3094     the examples below.
3095 
3096     NaN is not comparable so inequalities raise a TypeError.  This is in
3097     constrast with floating point nan where all inequalities are false.
3098 
3099     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported
3100     as ``nan``.
3101 
3102     Examples
3103     ========
3104 
3105     >>> from sympy import nan, S, oo, Eq
3106     >>> nan is S.NaN
3107     True
3108     >>> oo - oo
3109     nan
3110     >>> nan + 1
3111     nan
3112     >>> Eq(nan, nan)   # mathematical equality
3113     False
3114     >>> nan == nan     # structural equality
3115     True
3116 
3117     References
3118     ==========
3119 
3120     .. [1] https://en.wikipedia.org/wiki/NaN
3121 
3122     """
3123     is_commutative = True
3124     is_real = None
3125     is_rational = None
3126     is_algebraic = None
3127     is_transcendental = None
3128     is_integer = None
3129     is_comparable = False
3130     is_finite = None
3131     is_zero = None
3132     is_prime = None
3133     is_positive = None
3134     is_negative = None
3135     is_number = True
3136 
3137     __slots__ = []
3138 
3139     def __new__(cls):
3140         return AtomicExpr.__new__(cls)
3141 
3142     def _latex(self, printer):
3143         return r"\text{NaN}"
3144 
3145     @_sympifyit('other', NotImplemented)
3146     def __add__(self, other):
3147         return self
3148 
3149     @_sympifyit('other', NotImplemented)
3150     def __sub__(self, other):
3151         return self
3152 
3153     @_sympifyit('other', NotImplemented)
3154     def __mul__(self, other):
3155         return self
3156 
3157     @_sympifyit('other', NotImplemented)
3158     def __div__(self, other):
3159         return self
3160 
3161     __truediv__ = __div__
3162 
3163     def floor(self):
3164         return self
3165 
3166     def ceiling(self):
3167         return self
3168 
3169     def _as_mpf_val(self, prec):
3170         return _mpf_nan
3171 
3172     def _sage_(self):
3173         import sage.all as sage
3174         return sage.NaN
3175 
3176     def __hash__(self):
3177         return super(NaN, self).__hash__()
3178 
3179     def __eq__(self, other):
3180         # NaN is structurally equal to another NaN
3181         return other is S.NaN
3182 
3183     def __ne__(self, other):
3184         return other is not S.NaN
3185 
3186     def _eval_Eq(self, other):
3187         # NaN is not mathematically equal to anything, even NaN
3188         return S.false
3189 
3190     # Expr will _sympify and raise TypeError
3191     __gt__ = Expr.__gt__
3192     __ge__ = Expr.__ge__
3193     __lt__ = Expr.__lt__
3194     __le__ = Expr.__le__
3195 
3196 nan = S.NaN
3197 
3198 
3199 class ComplexInfinity(with_metaclass(Singleton, AtomicExpr)):
3200     r"""Complex infinity.
3201 
3202     In complex analysis the symbol `\tilde\infty`, called "complex
3203     infinity", represents a quantity with infinite magnitude, but
3204     undetermined complex phase.
3205 
3206     ComplexInfinity is a singleton, and can be accessed by
3207     ``S.ComplexInfinity``, or can be imported as ``zoo``.
3208 
3209     Examples
3210     ========
3211 
3212     >>> from sympy import zoo, oo
3213     >>> zoo + 42
3214     zoo
3215     >>> 42/zoo
3216     0
3217     >>> zoo + zoo
3218     nan
3219     >>> zoo*zoo
3220     zoo
3221 
3222     See Also
3223     ========
3224 
3225     Infinity
3226     """
3227 
3228     is_commutative = True
3229     is_infinite = True
3230     is_number = True
3231     is_prime = False
3232     is_complex = True
3233     is_real = False
3234 
3235     __slots__ = []
3236 
3237     def __new__(cls):
3238         return AtomicExpr.__new__(cls)
3239 
3240     def _latex(self, printer):
3241         return r"\tilde{\infty}"
3242 
3243     @staticmethod
3244     def __abs__():
3245         return S.Infinity
3246 
3247     def floor(self):
3248         return self
3249 
3250     def ceiling(self):
3251         return self
3252 
3253     @staticmethod
3254     def __neg__():
3255         return S.ComplexInfinity
3256 
3257     def _eval_power(self, expt):
3258         if expt is S.ComplexInfinity:
3259             return S.NaN
3260 
3261         if isinstance(expt, Number):
3262             if expt is S.Zero:
3263                 return S.NaN
3264             else:
3265                 if expt.is_positive:
3266                     return S.ComplexInfinity
3267                 else:
3268                     return S.Zero
3269 
3270     def _sage_(self):
3271         import sage.all as sage
3272         return sage.UnsignedInfinityRing.gen()
3273 
3274 
3275 zoo = S.ComplexInfinity
3276 
3277 
3278 class NumberSymbol(AtomicExpr):
3279 
3280     is_commutative = True
3281     is_finite = True
3282     is_number = True
3283 
3284     __slots__ = []
3285 
3286     is_NumberSymbol = True
3287 
3288     def __new__(cls):
3289         return AtomicExpr.__new__(cls)
3290 
3291     def approximation(self, number_cls):
3292         """ Return an interval with number_cls endpoints
3293         that contains the value of NumberSymbol.
3294         If not implemented, then return None.
3295         """
3296 
3297     def _eval_evalf(self, prec):
3298         return Float._new(self._as_mpf_val(prec), prec)
3299 
3300     def __eq__(self, other):
3301         try:
3302             other = _sympify(other)
3303         except SympifyError:
3304             return NotImplemented
3305         if self is other:
3306             return True
3307         if other.is_Number and self.is_irrational:
3308             return False
3309 
3310         return False    # NumberSymbol != non-(Number|self)
3311 
3312     def __ne__(self, other):
3313         return not self == other
3314 
3315     def __le__(self, other):
3316         if self is other:
3317             return S.true
3318         return Expr.__le__(self, other)
3319 
3320     def __ge__(self, other):
3321         if self is other:
3322             return S.true
3323         return Expr.__ge__(self, other)
3324 
3325     def __int__(self):
3326         # subclass with appropriate return value
3327         raise NotImplementedError
3328 
3329     def __long__(self):
3330         return self.__int__()
3331 
3332     def __hash__(self):
3333         return super(NumberSymbol, self).__hash__()
3334 
3335 
3336 class Exp1(with_metaclass(Singleton, NumberSymbol)):
3337     r"""The `e` constant.
3338 
3339     The transcendental number `e = 2.718281828\ldots` is the base of the
3340     natural logarithm and of the exponential function, `e = \exp(1)`.
3341     Sometimes called Euler's number or Napier's constant.
3342 
3343     Exp1 is a singleton, and can be accessed by ``S.Exp1``,
3344     or can be imported as ``E``.
3345 
3346     Examples
3347     ========
3348 
3349     >>> from sympy import exp, log, E
3350     >>> E is exp(1)
3351     True
3352     >>> log(E)
3353     1
3354 
3355     References
3356     ==========
3357 
3358     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29
3359     """
3360 
3361     is_real = True
3362     is_positive = True
3363     is_negative = False  # XXX Forces is_negative/is_nonnegative
3364     is_irrational = True
3365     is_number = True
3366     is_algebraic = False
3367     is_transcendental = True
3368 
3369     __slots__ = []
3370 
3371     def _latex(self, printer):
3372         return r"e"
3373 
3374     @staticmethod
3375     def __abs__():
3376         return S.Exp1
3377 
3378     def __int__(self):
3379         return 2
3380 
3381     def _as_mpf_val(self, prec):
3382         return mpf_e(prec)
3383 
3384     def approximation_interval(self, number_cls):
3385         if issubclass(number_cls, Integer):
3386             return (Integer(2), Integer(3))
3387         elif issubclass(number_cls, Rational):
3388             pass
3389 
3390     def _eval_power(self, expt):
3391         from sympy import exp
3392         return exp(expt)
3393 
3394     def _eval_rewrite_as_sin(self, **kwargs):
3395         from sympy import sin
3396         I = S.ImaginaryUnit
3397         return sin(I + S.Pi/2) - I*sin(I)
3398 
3399     def _eval_rewrite_as_cos(self, **kwargs):
3400         from sympy import cos
3401         I = S.ImaginaryUnit
3402         return cos(I) + I*cos(I + S.Pi/2)
3403 
3404     def _sage_(self):
3405         import sage.all as sage
3406         return sage.e
3407 E = S.Exp1
3408 
3409 
3410 class Pi(with_metaclass(Singleton, NumberSymbol)):
3411     r"""The `\pi` constant.
3412 
3413     The transcendental number `\pi = 3.141592654\ldots` represents the ratio
3414     of a circle's circumference to its diameter, the area of the unit circle,
3415     the half-period of trigonometric functions, and many other things
3416     in mathematics.
3417 
3418     Pi is a singleton, and can be accessed by ``S.Pi``, or can
3419     be imported as ``pi``.
3420 
3421     Examples
3422     ========
3423 
3424     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol
3425     >>> S.Pi
3426     pi
3427     >>> pi > 3
3428     True
3429     >>> pi.is_irrational
3430     True
3431     >>> x = Symbol('x')
3432     >>> sin(x + 2*pi)
3433     sin(x)
3434     >>> integrate(exp(-x**2), (x, -oo, oo))
3435     sqrt(pi)
3436 
3437     References
3438     ==========
3439 
3440     .. [1] https://en.wikipedia.org/wiki/Pi
3441     """
3442 
3443     is_real = True
3444     is_positive = True
3445     is_negative = False
3446     is_irrational = True
3447     is_number = True
3448     is_algebraic = False
3449     is_transcendental = True
3450 
3451     __slots__ = []
3452 
3453     def _latex(self, printer):
3454         return r"\pi"
3455 
3456     @staticmethod
3457     def __abs__():
3458         return S.Pi
3459 
3460     def __int__(self):
3461         return 3
3462 
3463     def _as_mpf_val(self, prec):
3464         return mpf_pi(prec)
3465 
3466     def approximation_interval(self, number_cls):
3467         if issubclass(number_cls, Integer):
3468             return (Integer(3), Integer(4))
3469         elif issubclass(number_cls, Rational):
3470             return (Rational(223, 71), Rational(22, 7))
3471 
3472     def _sage_(self):
3473         import sage.all as sage
3474         return sage.pi
3475 pi = S.Pi
3476 
3477 
3478 class GoldenRatio(with_metaclass(Singleton, NumberSymbol)):
3479     r"""The golden ratio, `\phi`.
3480 
3481     `\phi = \frac{1 + \sqrt{5}}{2}` is algebraic number.  Two quantities
3482     are in the golden ratio if their ratio is the same as the ratio of
3483     their sum to the larger of the two quantities, i.e. their maximum.
3484 
3485     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.
3486 
3487     Examples
3488     ========
3489 
3490     >>> from sympy import S
3491     >>> S.GoldenRatio > 1
3492     True
3493     >>> S.GoldenRatio.expand(func=True)
3494     1/2 + sqrt(5)/2
3495     >>> S.GoldenRatio.is_irrational
3496     True
3497 
3498     References
3499     ==========
3500 
3501     .. [1] https://en.wikipedia.org/wiki/Golden_ratio
3502     """
3503 
3504     is_real = True
3505     is_positive = True
3506     is_negative = False
3507     is_irrational = True
3508     is_number = True
3509     is_algebraic = True
3510     is_transcendental = False
3511 
3512     __slots__ = []
3513 
3514     def _latex(self, printer):
3515         return r"\phi"
3516 
3517     def __int__(self):
3518         return 1
3519 
3520     def _as_mpf_val(self, prec):
3521          # XXX track down why this has to be increased
3522         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)
3523         return mpf_norm(rv, prec)
3524 
3525     def _eval_expand_func(self, **hints):
3526         from sympy import sqrt
3527         return S.Half + S.Half*sqrt(5)
3528 
3529     def approximation_interval(self, number_cls):
3530         if issubclass(number_cls, Integer):
3531             return (S.One, Rational(2))
3532         elif issubclass(number_cls, Rational):
3533             pass
3534 
3535     def _sage_(self):
3536         import sage.all as sage
3537         return sage.golden_ratio
3538 
3539     _eval_rewrite_as_sqrt = _eval_expand_func
3540 
3541 
3542 class TribonacciConstant(with_metaclass(Singleton, NumberSymbol)):
3543     r"""The tribonacci constant.
3544 
3545     The tribonacci numbers are like the Fibonacci numbers, but instead
3546     of starting with two predetermined terms, the sequence starts with
3547     three predetermined terms and each term afterwards is the sum of the
3548     preceding three terms.
3549 
3550     The tribonacci constant is the ratio toward which adjacent tribonacci
3551     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,
3552     and also satisfies the equation `x + x^{-3} = 2`.
3553 
3554     TribonacciConstant is a singleton, and can be accessed
3555     by ``S.TribonacciConstant``.
3556 
3557     Examples
3558     ========
3559 
3560     >>> from sympy import S
3561     >>> S.TribonacciConstant > 1
3562     True
3563     >>> S.TribonacciConstant.expand(func=True)
3564     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3
3565     >>> S.TribonacciConstant.is_irrational
3566     True
3567     >>> S.TribonacciConstant.n(20)
3568     1.8392867552141611326
3569 
3570     References
3571     ==========
3572 
3573     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers
3574     """
3575 
3576     is_real = True
3577     is_positive = True
3578     is_negative = False
3579     is_irrational = True
3580     is_number = True
3581     is_algebraic = True
3582     is_transcendental = False
3583 
3584     __slots__ = []
3585 
3586     def _latex(self, printer):
3587         return r"\text{TribonacciConstant}"
3588 
3589     def __int__(self):
3590         return 2
3591 
3592     def _eval_evalf(self, prec):
3593         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)
3594         return Float(rv, precision=prec)
3595 
3596     def _eval_expand_func(self, **hints):
3597         from sympy import sqrt, cbrt
3598         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3
3599 
3600     def approximation_interval(self, number_cls):
3601         if issubclass(number_cls, Integer):
3602             return (S.One, Rational(2))
3603         elif issubclass(number_cls, Rational):
3604             pass
3605 
3606     _eval_rewrite_as_sqrt = _eval_expand_func
3607 
3608 
3609 class EulerGamma(with_metaclass(Singleton, NumberSymbol)):
3610     r"""The Euler-Mascheroni constant.
3611 
3612     `\gamma = 0.5772157\ldots` (also called Euler's constant) is a mathematical
3613     constant recurring in analysis and number theory.  It is defined as the
3614     limiting difference between the harmonic series and the
3615     natural logarithm:
3616 
3617     .. math:: \gamma = \lim\limits_{n\to\infty}
3618               \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln n\right)
3619 
3620     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.
3621 
3622     Examples
3623     ========
3624 
3625     >>> from sympy import S
3626     >>> S.EulerGamma.is_irrational
3627     >>> S.EulerGamma > 0
3628     True
3629     >>> S.EulerGamma > 1
3630     False
3631 
3632     References
3633     ==========
3634 
3635     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant
3636     """
3637 
3638     is_real = True
3639     is_positive = True
3640     is_negative = False
3641     is_irrational = None
3642     is_number = True
3643 
3644     __slots__ = []
3645 
3646     def _latex(self, printer):
3647         return r"\gamma"
3648 
3649     def __int__(self):
3650         return 0
3651 
3652     def _as_mpf_val(self, prec):
3653          # XXX track down why this has to be increased
3654         v = mlib.libhyper.euler_fixed(prec + 10)
3655         rv = mlib.from_man_exp(v, -prec - 10)
3656         return mpf_norm(rv, prec)
3657 
3658     def approximation_interval(self, number_cls):
3659         if issubclass(number_cls, Integer):
3660             return (S.Zero, S.One)
3661         elif issubclass(number_cls, Rational):
3662             return (S.Half, Rational(3, 5))
3663 
3664     def _sage_(self):
3665         import sage.all as sage
3666         return sage.euler_gamma
3667 
3668 
3669 class Catalan(with_metaclass(Singleton, NumberSymbol)):
3670     r"""Catalan's constant.
3671 
3672     `K = 0.91596559\ldots` is given by the infinite series
3673 
3674     .. math:: K = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}
3675 
3676     Catalan is a singleton, and can be accessed by ``S.Catalan``.
3677 
3678     Examples
3679     ========
3680 
3681     >>> from sympy import S
3682     >>> S.Catalan.is_irrational
3683     >>> S.Catalan > 0
3684     True
3685     >>> S.Catalan > 1
3686     False
3687 
3688     References
3689     ==========
3690 
3691     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant
3692     """
3693 
3694     is_real = True
3695     is_positive = True
3696     is_negative = False
3697     is_irrational = None
3698     is_number = True
3699 
3700     __slots__ = []
3701 
3702     def __int__(self):
3703         return 0
3704 
3705     def _as_mpf_val(self, prec):
3706         # XXX track down why this has to be increased
3707         v = mlib.catalan_fixed(prec + 10)
3708         rv = mlib.from_man_exp(v, -prec - 10)
3709         return mpf_norm(rv, prec)
3710 
3711     def approximation_interval(self, number_cls):
3712         if issubclass(number_cls, Integer):
3713             return (S.Zero, S.One)
3714         elif issubclass(number_cls, Rational):
3715             return (Rational(9, 10), S.One)
3716 
3717     def _sage_(self):
3718         import sage.all as sage
3719         return sage.catalan
3720 
3721 
3722 class ImaginaryUnit(with_metaclass(Singleton, AtomicExpr)):
3723     r"""The imaginary unit, `i = \sqrt{-1}`.
3724 
3725     I is a singleton, and can be accessed by ``S.I``, or can be
3726     imported as ``I``.
3727 
3728     Examples
3729     ========
3730 
3731     >>> from sympy import I, sqrt
3732     >>> sqrt(-1)
3733     I
3734     >>> I*I
3735     -1
3736     >>> 1/I
3737     -I
3738 
3739     References
3740     ==========
3741 
3742     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit
3743     """
3744 
3745     is_commutative = True
3746     is_imaginary = True
3747     is_finite = True
3748     is_number = True
3749     is_algebraic = True
3750     is_transcendental = False
3751 
3752     __slots__ = []
3753 
3754     def _latex(self, printer):
3755         return printer._settings['imaginary_unit_latex']
3756 
3757     @staticmethod
3758     def __abs__():
3759         return S.One
3760 
3761     def _eval_evalf(self, prec):
3762         return self
3763 
3764     def _eval_conjugate(self):
3765         return -S.ImaginaryUnit
3766 
3767     def _eval_power(self, expt):
3768         """
3769         b is I = sqrt(-1)
3770         e is symbolic object but not equal to 0, 1
3771 
3772         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal
3773         I**0 mod 4 -> 1
3774         I**1 mod 4 -> I
3775         I**2 mod 4 -> -1
3776         I**3 mod 4 -> -I
3777         """
3778 
3779         if isinstance(expt, Number):
3780             if isinstance(expt, Integer):
3781                 expt = expt.p % 4
3782                 if expt == 0:
3783                     return S.One
3784                 if expt == 1:
3785                     return S.ImaginaryUnit
3786                 if expt == 2:
3787                     return -S.One
3788                 return -S.ImaginaryUnit
3789         return
3790 
3791     def as_base_exp(self):
3792         return S.NegativeOne, S.Half
3793 
3794     def _sage_(self):
3795         import sage.all as sage
3796         return sage.I
3797 
3798     @property
3799     def _mpc_(self):
3800         return (Float(0)._mpf_, Float(1)._mpf_)
3801 
3802 I = S.ImaginaryUnit
3803 
3804 
3805 def sympify_fractions(f):
3806     return Rational(f.numerator, f.denominator, 1)
3807 
3808 converter[fractions.Fraction] = sympify_fractions
3809 
3810 try:
3811     if HAS_GMPY == 2:
3812         import gmpy2 as gmpy
3813     elif HAS_GMPY == 1:
3814         import gmpy
3815     else:
3816         raise ImportError
3817 
3818     def sympify_mpz(x):
3819         return Integer(long(x))
3820 
3821     def sympify_mpq(x):
3822         return Rational(long(x.numerator), long(x.denominator))
3823 
3824     converter[type(gmpy.mpz(1))] = sympify_mpz
3825     converter[type(gmpy.mpq(1, 2))] = sympify_mpq
3826 except ImportError:
3827     pass
3828 
3829 
3830 def sympify_mpmath(x):
3831     return Expr._from_mpmath(x, x.context.prec)
3832 
3833 converter[mpnumeric] = sympify_mpmath
3834 
3835 
3836 def sympify_mpq(x):
3837     p, q = x._mpq_
3838     return Rational(p, q, 1)
3839 
3840 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpq
3841 
3842 
3843 def sympify_complex(a):
3844     real, imag = list(map(sympify, (a.real, a.imag)))
3845     return real + S.ImaginaryUnit*imag
3846 
3847 converter[complex] = sympify_complex
3848 
3849 from .power import Pow, integer_nthroot
3850 from .mul import Mul
3851 Mul.identity = One()
3852 from .add import Add
3853 Add.identity = Zero()
3854 
3855 def _register_classes():
3856     numbers.Number.register(Number)
3857     numbers.Real.register(Float)
3858     numbers.Rational.register(Rational)
3859     numbers.Rational.register(Integer)
3860 
3861 _register_classes()

</code><intended_behavior>Ensure that division between numbers, especially involving fractions or symbolic representations like 'Half', follows Python's standard arithmetic rules, allowing for floor division without raising an error unless mathematically justified (e.g., division by zero).</intended_behavior>, <file>sympy/core/power.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from math import log as _log
4 
5 from .sympify import _sympify
6 from .cache import cacheit
7 from .singleton import S
8 from .expr import Expr
9 from .evalf import PrecisionExhausted
10 from .function import (_coeff_isneg, expand_complex, expand_multinomial,
11     expand_mul)
12 from .logic import fuzzy_bool, fuzzy_not, fuzzy_and
13 from .compatibility import as_int, range
14 from .evaluate import global_evaluate
15 from sympy.utilities.iterables import sift
16 
17 from mpmath.libmp import sqrtrem as mpmath_sqrtrem
18 
19 from math import sqrt as _sqrt
20 
21 
22 
23 def isqrt(n):
24     """Return the largest integer less than or equal to sqrt(n)."""
25     if n < 17984395633462800708566937239552:
26         return int(_sqrt(n))
27     return integer_nthroot(int(n), 2)[0]
28 
29 
30 def integer_nthroot(y, n):
31     """
32     Return a tuple containing x = floor(y**(1/n))
33     and a boolean indicating whether the result is exact (that is,
34     whether x**n == y).
35 
36     Examples
37     ========
38 
39     >>> from sympy import integer_nthroot
40     >>> integer_nthroot(16, 2)
41     (4, True)
42     >>> integer_nthroot(26, 2)
43     (5, False)
44 
45     To simply determine if a number is a perfect square, the is_square
46     function should be used:
47 
48     >>> from sympy.ntheory.primetest import is_square
49     >>> is_square(26)
50     False
51 
52     See Also
53     ========
54     sympy.ntheory.primetest.is_square
55     integer_log
56     """
57     y, n = as_int(y), as_int(n)
58     if y < 0:
59         raise ValueError("y must be nonnegative")
60     if n < 1:
61         raise ValueError("n must be positive")
62     if y in (0, 1):
63         return y, True
64     if n == 1:
65         return y, True
66     if n == 2:
67         x, rem = mpmath_sqrtrem(y)
68         return int(x), not rem
69     if n > y:
70         return 1, False
71     # Get initial estimate for Newton's method. Care must be taken to
72     # avoid overflow
73     try:
74         guess = int(y**(1./n) + 0.5)
75     except OverflowError:
76         exp = _log(y, 2)/n
77         if exp > 53:
78             shift = int(exp - 53)
79             guess = int(2.0**(exp - shift) + 1) << shift
80         else:
81             guess = int(2.0**exp)
82     if guess > 2**50:
83         # Newton iteration
84         xprev, x = -1, guess
85         while 1:
86             t = x**(n - 1)
87             xprev, x = x, ((n - 1)*x + y//t)//n
88             if abs(x - xprev) < 2:
89                 break
90     else:
91         x = guess
92     # Compensate
93     t = x**n
94     while t < y:
95         x += 1
96         t = x**n
97     while t > y:
98         x -= 1
99         t = x**n
100     return int(x), t == y  # int converts long to int if possible
101 
102 
103 def integer_log(y, x):
104     """Returns (e, bool) where e is the largest nonnegative integer
105     such that |y| >= |x**e| and bool is True if y == x**e
106 
107     Examples
108     ========
109 
110     >>> from sympy import integer_log
111     >>> integer_log(125, 5)
112     (3, True)
113     >>> integer_log(17, 9)
114     (1, False)
115     >>> integer_log(4, -2)
116     (2, True)
117     >>> integer_log(-125,-5)
118     (3, True)
119 
120     See Also
121     ========
122     integer_nthroot
123     sympy.ntheory.primetest.is_square
124     sympy.ntheory.factor_.multiplicity
125     sympy.ntheory.factor_.perfect_power
126     """
127     if x == 1:
128         raise ValueError('x cannot take value as 1')
129     if y == 0:
130         raise ValueError('y cannot take value as 0')
131 
132     if x in (-2, 2):
133         x = int(x)
134         y = as_int(y)
135         e = y.bit_length() - 1
136         return e, x**e == y
137     if x < 0:
138         n, b = integer_log(y if y > 0 else -y, -x)
139         return n, b and bool(n % 2 if y < 0 else not n % 2)
140 
141     x = as_int(x)
142     y = as_int(y)
143     r = e = 0
144     while y >= x:
145         d = x
146         m = 1
147         while y >= d:
148             y, rem = divmod(y, d)
149             r = r or rem
150             e += m
151             if y > d:
152                 d *= d
153                 m *= 2
154     return e, r == 0 and y == 1
155 
156 
157 class Pow(Expr):
158     """
159     Defines the expression x**y as "x raised to a power y"
160 
161     Singleton definitions involving (0, 1, -1, oo, -oo, I, -I):
162 
163     +--------------+---------+-----------------------------------------------+
164     | expr         | value   | reason                                        |
165     +==============+=========+===============================================+
166     | z**0         | 1       | Although arguments over 0**0 exist, see [2].  |
167     +--------------+---------+-----------------------------------------------+
168     | z**1         | z       |                                               |
169     +--------------+---------+-----------------------------------------------+
170     | (-oo)**(-1)  | 0       |                                               |
171     +--------------+---------+-----------------------------------------------+
172     | (-1)**-1     | -1      |                                               |
173     +--------------+---------+-----------------------------------------------+
174     | S.Zero**-1   | zoo     | This is not strictly true, as 0**-1 may be    |
175     |              |         | undefined, but is convenient in some contexts |
176     |              |         | where the base is assumed to be positive.     |
177     +--------------+---------+-----------------------------------------------+
178     | 1**-1        | 1       |                                               |
179     +--------------+---------+-----------------------------------------------+
180     | oo**-1       | 0       |                                               |
181     +--------------+---------+-----------------------------------------------+
182     | 0**oo        | 0       | Because for all complex numbers z near        |
183     |              |         | 0, z**oo -> 0.                                |
184     +--------------+---------+-----------------------------------------------+
185     | 0**-oo       | zoo     | This is not strictly true, as 0**oo may be    |
186     |              |         | oscillating between positive and negative     |
187     |              |         | values or rotating in the complex plane.      |
188     |              |         | It is convenient, however, when the base      |
189     |              |         | is positive.                                  |
190     +--------------+---------+-----------------------------------------------+
191     | 1**oo        | nan     | Because there are various cases where         |
192     | 1**-oo       |         | lim(x(t),t)=1, lim(y(t),t)=oo (or -oo),       |
193     |              |         | but lim( x(t)**y(t), t) != 1.  See [3].       |
194     +--------------+---------+-----------------------------------------------+
195     | b**zoo       | nan     | Because b**z has no limit as z -> zoo         |
196     +--------------+---------+-----------------------------------------------+
197     | (-1)**oo     | nan     | Because of oscillations in the limit.         |
198     | (-1)**(-oo)  |         |                                               |
199     +--------------+---------+-----------------------------------------------+
200     | oo**oo       | oo      |                                               |
201     +--------------+---------+-----------------------------------------------+
202     | oo**-oo      | 0       |                                               |
203     +--------------+---------+-----------------------------------------------+
204     | (-oo)**oo    | nan     |                                               |
205     | (-oo)**-oo   |         |                                               |
206     +--------------+---------+-----------------------------------------------+
207     | oo**I        | nan     | oo**e could probably be best thought of as    |
208     | (-oo)**I     |         | the limit of x**e for real x as x tends to    |
209     |              |         | oo. If e is I, then the limit does not exist  |
210     |              |         | and nan is used to indicate that.             |
211     +--------------+---------+-----------------------------------------------+
212     | oo**(1+I)    | zoo     | If the real part of e is positive, then the   |
213     | (-oo)**(1+I) |         | limit of abs(x**e) is oo. So the limit value  |
214     |              |         | is zoo.                                       |
215     +--------------+---------+-----------------------------------------------+
216     | oo**(-1+I)   | 0       | If the real part of e is negative, then the   |
217     | -oo**(-1+I)  |         | limit is 0.                                   |
218     +--------------+---------+-----------------------------------------------+
219 
220     Because symbolic computations are more flexible that floating point
221     calculations and we prefer to never return an incorrect answer,
222     we choose not to conform to all IEEE 754 conventions.  This helps
223     us avoid extra test-case code in the calculation of limits.
224 
225     See Also
226     ========
227 
228     sympy.core.numbers.Infinity
229     sympy.core.numbers.NegativeInfinity
230     sympy.core.numbers.NaN
231 
232     References
233     ==========
234 
235     .. [1] https://en.wikipedia.org/wiki/Exponentiation
236     .. [2] https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_power_of_zero
237     .. [3] https://en.wikipedia.org/wiki/Indeterminate_forms
238 
239     """
240     is_Pow = True
241 
242     __slots__ = ['is_commutative']
243 
244     @cacheit
245     def __new__(cls, b, e, evaluate=None):
246         if evaluate is None:
247             evaluate = global_evaluate[0]
248         from sympy.functions.elementary.exponential import exp_polar
249 
250         b = _sympify(b)
251         e = _sympify(e)
252         if evaluate:
253             if e is S.ComplexInfinity:
254                 return S.NaN
255             if e is S.Zero:
256                 return S.One
257             elif e is S.One:
258                 return b
259             # Only perform autosimplification if exponent or base is a Symbol or number
260             elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and\
261                 e.is_integer and _coeff_isneg(b):
262                 if e.is_even:
263                     b = -b
264                 elif e.is_odd:
265                     return -Pow(-b, e)
266             if S.NaN in (b, e):  # XXX S.NaN**x -> S.NaN under assumption that x != 0
267                 return S.NaN
268             elif b is S.One:
269                 if abs(e).is_infinite:
270                     return S.NaN
271                 return S.One
272             else:
273                 # recognize base as E
274                 if not e.is_Atom and b is not S.Exp1 and not isinstance(b, exp_polar):
275                     from sympy import numer, denom, log, sign, im, factor_terms
276                     c, ex = factor_terms(e, sign=False).as_coeff_Mul()
277                     den = denom(ex)
278                     if isinstance(den, log) and den.args[0] == b:
279                         return S.Exp1**(c*numer(ex))
280                     elif den.is_Add:
281                         s = sign(im(b))
282                         if s.is_Number and s and den == \
283                                 log(-factor_terms(b, sign=False)) + s*S.ImaginaryUnit*S.Pi:
284                             return S.Exp1**(c*numer(ex))
285 
286                 obj = b._eval_power(e)
287                 if obj is not None:
288                     return obj
289         obj = Expr.__new__(cls, b, e)
290         obj = cls._exec_constructor_postprocessors(obj)
291         if not isinstance(obj, Pow):
292             return obj
293         obj.is_commutative = (b.is_commutative and e.is_commutative)
294         return obj
295 
296     @property
297     def base(self):
298         return self._args[0]
299 
300     @property
301     def exp(self):
302         return self._args[1]
303 
304     @classmethod
305     def class_key(cls):
306         return 3, 2, cls.__name__
307 
308     def _eval_refine(self, assumptions):
309         from sympy.assumptions.ask import ask, Q
310         b, e = self.as_base_exp()
311         if ask(Q.integer(e), assumptions) and _coeff_isneg(b):
312             if ask(Q.even(e), assumptions):
313                 return Pow(-b, e)
314             elif ask(Q.odd(e), assumptions):
315                 return -Pow(-b, e)
316 
317     def _eval_power(self, other):
318         from sympy import Abs, arg, exp, floor, im, log, re, sign
319         b, e = self.as_base_exp()
320         if b is S.NaN:
321             return (b**e)**other  # let __new__ handle it
322 
323         s = None
324         if other.is_integer:
325             s = 1
326         elif b.is_polar:  # e.g. exp_polar, besselj, var('p', polar=True)...
327             s = 1
328         elif e.is_real is not None:
329             # helper functions ===========================
330             def _half(e):
331                 """Return True if the exponent has a literal 2 as the
332                 denominator, else None."""
333                 if getattr(e, 'q', None) == 2:
334                     return True
335                 n, d = e.as_numer_denom()
336                 if n.is_integer and d == 2:
337                     return True
338             def _n2(e):
339                 """Return ``e`` evaluated to a Number with 2 significant
340                 digits, else None."""
341                 try:
342                     rv = e.evalf(2, strict=True)
343                     if rv.is_Number:
344                         return rv
345                 except PrecisionExhausted:
346                     pass
347             # ===================================================
348             if e.is_real:
349                 # we need _half(other) with constant floor or
350                 # floor(S.Half - e*arg(b)/2/pi) == 0
351 
352                 # handle -1 as special case
353                 if e == -1:
354                     # floor arg. is 1/2 + arg(b)/2/pi
355                     if _half(other):
356                         if b.is_negative is True:
357                             return S.NegativeOne**other*Pow(-b, e*other)
358                         if b.is_real is False:
359                             return Pow(b.conjugate()/Abs(b)**2, other)
360                 elif e.is_even:
361                     if b.is_real:
362                         b = abs(b)
363                     if b.is_imaginary:
364                         b = abs(im(b))*S.ImaginaryUnit
365 
366                 if (abs(e) < 1) == True or e == 1:
367                     s = 1  # floor = 0
368                 elif b.is_nonnegative:
369                     s = 1  # floor = 0
370                 elif re(b).is_nonnegative and (abs(e) < 2) == True:
371                     s = 1  # floor = 0
372                 elif fuzzy_not(im(b).is_zero) and abs(e) == 2:
373                     s = 1  # floor = 0
374                 elif _half(other):
375                     s = exp(2*S.Pi*S.ImaginaryUnit*other*floor(
376                         S.Half - e*arg(b)/(2*S.Pi)))
377                     if s.is_real and _n2(sign(s) - s) == 0:
378                         s = sign(s)
379                     else:
380                         s = None
381             else:
382                 # e.is_real is False requires:
383                 #     _half(other) with constant floor or
384                 #     floor(S.Half - im(e*log(b))/2/pi) == 0
385                 try:
386                     s = exp(2*S.ImaginaryUnit*S.Pi*other*
387                         floor(S.Half - im(e*log(b))/2/S.Pi))
388                     # be careful to test that s is -1 or 1 b/c sign(I) == I:
389                     # so check that s is real
390                     if s.is_real and _n2(sign(s) - s) == 0:
391                         s = sign(s)
392                     else:
393                         s = None
394                 except PrecisionExhausted:
395                     s = None
396 
397         if s is not None:
398             return s*Pow(b, e*other)
399 
400     def _eval_Mod(self, q):
401         if self.exp.is_integer and self.exp.is_positive:
402             if q.is_integer and self.base % q == 0:
403                 return S.Zero
404 
405             '''
406             For unevaluated Integer power, use built-in pow modular
407             exponentiation, if powers are not too large wrt base.
408             '''
409             if self.base.is_Integer and self.exp.is_Integer and q.is_Integer:
410                 b, e, m = int(self.base), int(self.exp), int(q)
411                 # For very large powers, use totient reduction if e >= lg(m).
412                 # Bound on m, is for safe factorization memory wise ie m^(1/4).
413                 # For pollard-rho to be faster than built-in pow lg(e) > m^(1/4)
414                 # check is added.
415                 mb = m.bit_length()
416                 if mb <= 80  and e >= mb and e.bit_length()**4 >= m:
417                     from sympy.ntheory import totient
418                     phi = totient(m)
419                     return pow(b, phi + e%phi, m)
420                 else:
421                     return pow(b, e, m)
422 
423     def _eval_is_even(self):
424         if self.exp.is_integer and self.exp.is_positive:
425             return self.base.is_even
426 
427     def _eval_is_positive(self):
428         from sympy import log
429         if self.base == self.exp:
430             if self.base.is_nonnegative:
431                 return True
432         elif self.base.is_positive:
433             if self.exp.is_real:
434                 return True
435         elif self.base.is_negative:
436             if self.exp.is_even:
437                 return True
438             if self.exp.is_odd:
439                 return False
440         elif self.base.is_zero:
441             if self.exp.is_real:
442                 return self.exp.is_zero
443         elif self.base.is_nonpositive:
444             if self.exp.is_odd:
445                 return False
446         elif self.base.is_imaginary:
447             if self.exp.is_integer:
448                 m = self.exp % 4
449                 if m.is_zero:
450                     return True
451                 if m.is_integer and m.is_zero is False:
452                     return False
453             if self.exp.is_imaginary:
454                 return log(self.base).is_imaginary
455 
456     def _eval_is_negative(self):
457         if self.base.is_negative:
458             if self.exp.is_odd:
459                 return True
460             if self.exp.is_even:
461                 return False
462         elif self.base.is_positive:
463             if self.exp.is_real:
464                 return False
465         elif self.base.is_zero:
466             if self.exp.is_real:
467                 return False
468         elif self.base.is_nonnegative:
469             if self.exp.is_nonnegative:
470                 return False
471         elif self.base.is_nonpositive:
472             if self.exp.is_even:
473                 return False
474         elif self.base.is_real:
475             if self.exp.is_even:
476                 return False
477 
478     def _eval_is_zero(self):
479         if self.base.is_zero:
480             if self.exp.is_positive:
481                 return True
482             elif self.exp.is_nonpositive:
483                 return False
484         elif self.base.is_zero is False:
485             if self.exp.is_finite:
486                 return False
487             elif self.exp.is_infinite:
488                 if (1 - abs(self.base)).is_positive:
489                     return self.exp.is_positive
490                 elif (1 - abs(self.base)).is_negative:
491                     return self.exp.is_negative
492         else:
493             # when self.base.is_zero is None
494             return None
495 
496     def _eval_is_integer(self):
497         b, e = self.args
498         if b.is_rational:
499             if b.is_integer is False and e.is_positive:
500                 return False  # rat**nonneg
501         if b.is_integer and e.is_integer:
502             if b is S.NegativeOne:
503                 return True
504             if e.is_nonnegative or e.is_positive:
505                 return True
506         if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):
507             if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):
508                 return False
509         if b.is_Number and e.is_Number:
510             check = self.func(*self.args)
511             return check.is_Integer
512 
513     def _eval_is_real(self):
514         from sympy import arg, exp, log, Mul
515         real_b = self.base.is_real
516         if real_b is None:
517             if self.base.func == exp and self.base.args[0].is_imaginary:
518                 return self.exp.is_imaginary
519             return
520         real_e = self.exp.is_real
521         if real_e is None:
522             return
523         if real_b and real_e:
524             if self.base.is_positive:
525                 return True
526             elif self.base.is_nonnegative:
527                 if self.exp.is_nonnegative:
528                     return True
529             else:
530                 if self.exp.is_integer:
531                     return True
532                 elif self.base.is_negative:
533                     if self.exp.is_Rational:
534                         return False
535         if real_e and self.exp.is_negative:
536             return Pow(self.base, -self.exp).is_real
537         im_b = self.base.is_imaginary
538         im_e = self.exp.is_imaginary
539         if im_b:
540             if self.exp.is_integer:
541                 if self.exp.is_even:
542                     return True
543                 elif self.exp.is_odd:
544                     return False
545             elif im_e and log(self.base).is_imaginary:
546                 return True
547             elif self.exp.is_Add:
548                 c, a = self.exp.as_coeff_Add()
549                 if c and c.is_Integer:
550                     return Mul(
551                         self.base**c, self.base**a, evaluate=False).is_real
552             elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):
553                 if (self.exp/2).is_integer is False:
554                     return False
555         if real_b and im_e:
556             if self.base is S.NegativeOne:
557                 return True
558             c = self.exp.coeff(S.ImaginaryUnit)
559             if c:
560                 ok = (c*log(self.base)/S.Pi).is_Integer
561                 if ok is not None:
562                     return ok
563 
564         if real_b is False:  # we already know it's not imag
565             i = arg(self.base)*self.exp/S.Pi
566             return i.is_integer
567 
568     def _eval_is_complex(self):
569         if all(a.is_complex for a in self.args):
570             return True
571 
572     def _eval_is_imaginary(self):
573         from sympy import arg, log
574         if self.base.is_imaginary:
575             if self.exp.is_integer:
576                 odd = self.exp.is_odd
577                 if odd is not None:
578                     return odd
579                 return
580 
581         if self.exp.is_imaginary:
582             imlog = log(self.base).is_imaginary
583             if imlog is not None:
584                 return False  # I**i -> real; (2*I)**i -> complex ==> not imaginary
585 
586         if self.base.is_real and self.exp.is_real:
587             if self.base.is_positive:
588                 return False
589             else:
590                 rat = self.exp.is_rational
591                 if not rat:
592                     return rat
593                 if self.exp.is_integer:
594                     return False
595                 else:
596                     half = (2*self.exp).is_integer
597                     if half:
598                         return self.base.is_negative
599                     return half
600 
601         if self.base.is_real is False:  # we already know it's not imag
602             i = arg(self.base)*self.exp/S.Pi
603             isodd = (2*i).is_odd
604             if isodd is not None:
605                 return isodd
606 
607         if self.exp.is_negative:
608             return (1/self).is_imaginary
609 
610     def _eval_is_odd(self):
611         if self.exp.is_integer:
612             if self.exp.is_positive:
613                 return self.base.is_odd
614             elif self.exp.is_nonnegative and self.base.is_odd:
615                 return True
616             elif self.base is S.NegativeOne:
617                 return True
618 
619     def _eval_is_finite(self):
620         if self.exp.is_negative:
621             if self.base.is_zero:
622                 return False
623             if self.base.is_infinite:
624                 return True
625         c1 = self.base.is_finite
626         if c1 is None:
627             return
628         c2 = self.exp.is_finite
629         if c2 is None:
630             return
631         if c1 and c2:
632             if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):
633                 return True
634 
635     def _eval_is_prime(self):
636         '''
637         An integer raised to the n(>=2)-th power cannot be a prime.
638         '''
639         if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:
640             return False
641 
642     def _eval_is_composite(self):
643         """
644         A power is composite if both base and exponent are greater than 1
645         """
646         if (self.base.is_integer and self.exp.is_integer and
647             ((self.base - 1).is_positive and (self.exp - 1).is_positive or
648             (self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):
649             return True
650 
651     def _eval_is_polar(self):
652         return self.base.is_polar
653 
654     def _eval_subs(self, old, new):
655         from sympy import exp, log, Symbol
656         def _check(ct1, ct2, old):
657             """Return (bool, pow, remainder_pow) where, if bool is True, then the
658             exponent of Pow `old` will combine with `pow` so the substitution
659             is valid, otherwise bool will be False.
660 
661             For noncommutative objects, `pow` will be an integer, and a factor
662             `Pow(old.base, remainder_pow)` needs to be included. If there is
663             no such factor, None is returned. For commutative objects,
664             remainder_pow is always None.
665 
666             cti are the coefficient and terms of an exponent of self or old
667             In this _eval_subs routine a change like (b**(2*x)).subs(b**x, y)
668             will give y**2 since (b**x)**2 == b**(2*x); if that equality does
669             not hold then the substitution should not occur so `bool` will be
670             False.
671 
672             """
673             coeff1, terms1 = ct1
674             coeff2, terms2 = ct2
675             if terms1 == terms2:
676                 if old.is_commutative:
677                     # Allow fractional powers for commutative objects
678                     pow = coeff1/coeff2
679                     try:
680                         pow = as_int(pow, strict=False)
681                         combines = True
682                     except ValueError:
683                         combines = isinstance(Pow._eval_power(
684                             Pow(*old.as_base_exp(), evaluate=False),
685                             pow), (Pow, exp, Symbol))
686                     return combines, pow, None
687                 else:
688                     # With noncommutative symbols, substitute only integer powers
689                     if not isinstance(terms1, tuple):
690                         terms1 = (terms1,)
691                     if not all(term.is_integer for term in terms1):
692                         return False, None, None
693 
694                     try:
695                         # Round pow toward zero
696                         pow, remainder = divmod(as_int(coeff1), as_int(coeff2))
697                         if pow < 0 and remainder != 0:
698                             pow += 1
699                             remainder -= as_int(coeff2)
700 
701                         if remainder == 0:
702                             remainder_pow = None
703                         else:
704                             remainder_pow = Mul(remainder, *terms1)
705 
706                         return True, pow, remainder_pow
707                     except ValueError:
708                         # Can't substitute
709                         pass
710 
711             return False, None, None
712 
713         if old == self.base:
714             return new**self.exp._subs(old, new)
715 
716         # issue 10829: (4**x - 3*y + 2).subs(2**x, y) -> y**2 - 3*y + 2
717         if isinstance(old, self.func) and self.exp == old.exp:
718             l = log(self.base, old.base)
719             if l.is_Number:
720                 return Pow(new, l)
721 
722         if isinstance(old, self.func) and self.base == old.base:
723             if self.exp.is_Add is False:
724                 ct1 = self.exp.as_independent(Symbol, as_Add=False)
725                 ct2 = old.exp.as_independent(Symbol, as_Add=False)
726                 ok, pow, remainder_pow = _check(ct1, ct2, old)
727                 if ok:
728                     # issue 5180: (x**(6*y)).subs(x**(3*y),z)->z**2
729                     result = self.func(new, pow)
730                     if remainder_pow is not None:
731                         result = Mul(result, Pow(old.base, remainder_pow))
732                     return result
733             else:  # b**(6*x + a).subs(b**(3*x), y) -> y**2 * b**a
734                 # exp(exp(x) + exp(x**2)).subs(exp(exp(x)), w) -> w * exp(exp(x**2))
735                 oarg = old.exp
736                 new_l = []
737                 o_al = []
738                 ct2 = oarg.as_coeff_mul()
739                 for a in self.exp.args:
740                     newa = a._subs(old, new)
741                     ct1 = newa.as_coeff_mul()
742                     ok, pow, remainder_pow = _check(ct1, ct2, old)
743                     if ok:
744                         new_l.append(new**pow)
745                         if remainder_pow is not None:
746                             o_al.append(remainder_pow)
747                         continue
748                     elif not old.is_commutative and not newa.is_integer:
749                         # If any term in the exponent is non-integer,
750                         # we do not do any substitutions in the noncommutative case
751                         return
752                     o_al.append(newa)
753                 if new_l:
754                     expo = Add(*o_al)
755                     new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)
756                     return Mul(*new_l)
757 
758         if isinstance(old, exp) and self.exp.is_real and self.base.is_positive:
759             ct1 = old.args[0].as_independent(Symbol, as_Add=False)
760             ct2 = (self.exp*log(self.base)).as_independent(
761                 Symbol, as_Add=False)
762             ok, pow, remainder_pow = _check(ct1, ct2, old)
763             if ok:
764                 result = self.func(new, pow)  # (2**x).subs(exp(x*log(2)), z) -> z
765                 if remainder_pow is not None:
766                     result = Mul(result, Pow(old.base, remainder_pow))
767                 return result
768 
769     def as_base_exp(self):
770         """Return base and exp of self.
771 
772         If base is 1/Integer, then return Integer, -exp. If this extra
773         processing is not needed, the base and exp properties will
774         give the raw arguments
775 
776         Examples
777         ========
778 
779         >>> from sympy import Pow, S
780         >>> p = Pow(S.Half, 2, evaluate=False)
781         >>> p.as_base_exp()
782         (2, -2)
783         >>> p.args
784         (1/2, 2)
785 
786         """
787 
788         b, e = self.args
789         if b.is_Rational and b.p == 1 and b.q != 1:
790             return Integer(b.q), -e
791         return b, e
792 
793     def _eval_adjoint(self):
794         from sympy.functions.elementary.complexes import adjoint
795         i, p = self.exp.is_integer, self.base.is_positive
796         if i:
797             return adjoint(self.base)**self.exp
798         if p:
799             return self.base**adjoint(self.exp)
800         if i is False and p is False:
801             expanded = expand_complex(self)
802             if expanded != self:
803                 return adjoint(expanded)
804 
805     def _eval_conjugate(self):
806         from sympy.functions.elementary.complexes import conjugate as c
807         i, p = self.exp.is_integer, self.base.is_positive
808         if i:
809             return c(self.base)**self.exp
810         if p:
811             return self.base**c(self.exp)
812         if i is False and p is False:
813             expanded = expand_complex(self)
814             if expanded != self:
815                 return c(expanded)
816         if self.is_real:
817             return self
818 
819     def _eval_transpose(self):
820         from sympy.functions.elementary.complexes import transpose
821         i, p = self.exp.is_integer, self.base.is_complex
822         if p:
823             return self.base**self.exp
824         if i:
825             return transpose(self.base)**self.exp
826         if i is False and p is False:
827             expanded = expand_complex(self)
828             if expanded != self:
829                 return transpose(expanded)
830 
831     def _eval_expand_power_exp(self, **hints):
832         """a**(n + m) -> a**n*a**m"""
833         b = self.base
834         e = self.exp
835         if e.is_Add and e.is_commutative:
836             expr = []
837             for x in e.args:
838                 expr.append(self.func(self.base, x))
839             return Mul(*expr)
840         return self.func(b, e)
841 
842     def _eval_expand_power_base(self, **hints):
843         """(a*b)**n -> a**n * b**n"""
844         force = hints.get('force', False)
845 
846         b = self.base
847         e = self.exp
848         if not b.is_Mul:
849             return self
850 
851         cargs, nc = b.args_cnc(split_1=False)
852 
853         # expand each term - this is top-level-only
854         # expansion but we have to watch out for things
855         # that don't have an _eval_expand method
856         if nc:
857             nc = [i._eval_expand_power_base(**hints)
858                 if hasattr(i, '_eval_expand_power_base') else i
859                 for i in nc]
860 
861             if e.is_Integer:
862                 if e.is_positive:
863                     rv = Mul(*nc*e)
864                 else:
865                     rv = Mul(*[i**-1 for i in nc[::-1]]*-e)
866                 if cargs:
867                     rv *= Mul(*cargs)**e
868                 return rv
869 
870             if not cargs:
871                 return self.func(Mul(*nc), e, evaluate=False)
872 
873             nc = [Mul(*nc)]
874 
875         # sift the commutative bases
876         other, maybe_real = sift(cargs, lambda x: x.is_real is False,
877             binary=True)
878         def pred(x):
879             if x is S.ImaginaryUnit:
880                 return S.ImaginaryUnit
881             polar = x.is_polar
882             if polar:
883                 return True
884             if polar is None:
885                 return fuzzy_bool(x.is_nonnegative)
886         sifted = sift(maybe_real, pred)
887         nonneg = sifted[True]
888         other += sifted[None]
889         neg = sifted[False]
890         imag = sifted[S.ImaginaryUnit]
891         if imag:
892             I = S.ImaginaryUnit
893             i = len(imag) % 4
894             if i == 0:
895                 pass
896             elif i == 1:
897                 other.append(I)
898             elif i == 2:
899                 if neg:
900                     nonn = -neg.pop()
901                     if nonn is not S.One:
902                         nonneg.append(nonn)
903                 else:
904                     neg.append(S.NegativeOne)
905             else:
906                 if neg:
907                     nonn = -neg.pop()
908                     if nonn is not S.One:
909                         nonneg.append(nonn)
910                 else:
911                     neg.append(S.NegativeOne)
912                 other.append(I)
913             del imag
914 
915         # bring out the bases that can be separated from the base
916 
917         if force or e.is_integer:
918             # treat all commutatives the same and put nc in other
919             cargs = nonneg + neg + other
920             other = nc
921         else:
922             # this is just like what is happening automatically, except
923             # that now we are doing it for an arbitrary exponent for which
924             # no automatic expansion is done
925 
926             assert not e.is_Integer
927 
928             # handle negatives by making them all positive and putting
929             # the residual -1 in other
930             if len(neg) > 1:
931                 o = S.One
932                 if not other and neg[0].is_Number:
933                     o *= neg.pop(0)
934                 if len(neg) % 2:
935                     o = -o
936                 for n in neg:
937                     nonneg.append(-n)
938                 if o is not S.One:
939                     other.append(o)
940             elif neg and other:
941                 if neg[0].is_Number and neg[0] is not S.NegativeOne:
942                     other.append(S.NegativeOne)
943                     nonneg.append(-neg[0])
944                 else:
945                     other.extend(neg)
946             else:
947                 other.extend(neg)
948             del neg
949 
950             cargs = nonneg
951             other += nc
952 
953         rv = S.One
954         if cargs:
955             rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])
956         if other:
957             rv *= self.func(Mul(*other), e, evaluate=False)
958         return rv
959 
960     def _eval_expand_multinomial(self, **hints):
961         """(a + b + ..)**n -> a**n + n*a**(n-1)*b + .., n is nonzero integer"""
962 
963         base, exp = self.args
964         result = self
965 
966         if exp.is_Rational and exp.p > 0 and base.is_Add:
967             if not exp.is_Integer:
968                 n = Integer(exp.p // exp.q)
969 
970                 if not n:
971                     return result
972                 else:
973                     radical, result = self.func(base, exp - n), []
974 
975                     expanded_base_n = self.func(base, n)
976                     if expanded_base_n.is_Pow:
977                         expanded_base_n = \
978                             expanded_base_n._eval_expand_multinomial()
979                     for term in Add.make_args(expanded_base_n):
980                         result.append(term*radical)
981 
982                     return Add(*result)
983 
984             n = int(exp)
985 
986             if base.is_commutative:
987                 order_terms, other_terms = [], []
988 
989                 for b in base.args:
990                     if b.is_Order:
991                         order_terms.append(b)
992                     else:
993                         other_terms.append(b)
994 
995                 if order_terms:
996                     # (f(x) + O(x^n))^m -> f(x)^m + m*f(x)^{m-1} *O(x^n)
997                     f = Add(*other_terms)
998                     o = Add(*order_terms)
999 
1000                     if n == 2:
1001                         return expand_multinomial(f**n, deep=False) + n*f*o
1002                     else:
1003                         g = expand_multinomial(f**(n - 1), deep=False)
1004                         return expand_mul(f*g, deep=False) + n*g*o
1005 
1006                 if base.is_number:
1007                     # Efficiently expand expressions of the form (a + b*I)**n
1008                     # where 'a' and 'b' are real numbers and 'n' is integer.
1009                     a, b = base.as_real_imag()
1010 
1011                     if a.is_Rational and b.is_Rational:
1012                         if not a.is_Integer:
1013                             if not b.is_Integer:
1014                                 k = self.func(a.q * b.q, n)
1015                                 a, b = a.p*b.q, a.q*b.p
1016                             else:
1017                                 k = self.func(a.q, n)
1018                                 a, b = a.p, a.q*b
1019                         elif not b.is_Integer:
1020                             k = self.func(b.q, n)
1021                             a, b = a*b.q, b.p
1022                         else:
1023                             k = 1
1024 
1025                         a, b, c, d = int(a), int(b), 1, 0
1026 
1027                         while n:
1028                             if n & 1:
1029                                 c, d = a*c - b*d, b*c + a*d
1030                                 n -= 1
1031                             a, b = a*a - b*b, 2*a*b
1032                             n //= 2
1033 
1034                         I = S.ImaginaryUnit
1035 
1036                         if k == 1:
1037                             return c + I*d
1038                         else:
1039                             return Integer(c)/k + I*d/k
1040 
1041                 p = other_terms
1042                 # (x + y)**3 -> x**3 + 3*x**2*y + 3*x*y**2 + y**3
1043                 # in this particular example:
1044                 # p = [x,y]; n = 3
1045                 # so now it's easy to get the correct result -- we get the
1046                 # coefficients first:
1047                 from sympy import multinomial_coefficients
1048                 from sympy.polys.polyutils import basic_from_dict
1049                 expansion_dict = multinomial_coefficients(len(p), n)
1050                 # in our example: {(3, 0): 1, (1, 2): 3, (0, 3): 1, (2, 1): 3}
1051                 # and now construct the expression.
1052                 return basic_from_dict(expansion_dict, *p)
1053             else:
1054                 if n == 2:
1055                     return Add(*[f*g for f in base.args for g in base.args])
1056                 else:
1057                     multi = (base**(n - 1))._eval_expand_multinomial()
1058                     if multi.is_Add:
1059                         return Add(*[f*g for f in base.args
1060                             for g in multi.args])
1061                     else:
1062                         # XXX can this ever happen if base was an Add?
1063                         return Add(*[f*multi for f in base.args])
1064         elif (exp.is_Rational and exp.p < 0 and base.is_Add and
1065                 abs(exp.p) > exp.q):
1066             return 1 / self.func(base, -exp)._eval_expand_multinomial()
1067         elif exp.is_Add and base.is_Number:
1068             #  a + b      a  b
1069             # n      --> n  n  , where n, a, b are Numbers
1070 
1071             coeff, tail = S.One, S.Zero
1072             for term in exp.args:
1073                 if term.is_Number:
1074                     coeff *= self.func(base, term)
1075                 else:
1076                     tail += term
1077 
1078             return coeff * self.func(base, tail)
1079         else:
1080             return result
1081 
1082     def as_real_imag(self, deep=True, **hints):
1083         from sympy import atan2, cos, im, re, sin
1084         from sympy.polys.polytools import poly
1085 
1086         if self.exp.is_Integer:
1087             exp = self.exp
1088             re, im = self.base.as_real_imag(deep=deep)
1089             if not im:
1090                 return self, S.Zero
1091             a, b = symbols('a b', cls=Dummy)
1092             if exp >= 0:
1093                 if re.is_Number and im.is_Number:
1094                     # We can be more efficient in this case
1095                     expr = expand_multinomial(self.base**exp)
1096                     if expr != self:
1097                         return expr.as_real_imag()
1098 
1099                 expr = poly(
1100                     (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp
1101             else:
1102                 mag = re**2 + im**2
1103                 re, im = re/mag, -im/mag
1104                 if re.is_Number and im.is_Number:
1105                     # We can be more efficient in this case
1106                     expr = expand_multinomial((re + im*S.ImaginaryUnit)**-exp)
1107                     if expr != self:
1108                         return expr.as_real_imag()
1109 
1110                 expr = poly((a + b)**-exp)
1111 
1112             # Terms with even b powers will be real
1113             r = [i for i in expr.terms() if not i[0][1] % 2]
1114             re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])
1115             # Terms with odd b powers will be imaginary
1116             r = [i for i in expr.terms() if i[0][1] % 4 == 1]
1117             im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])
1118             r = [i for i in expr.terms() if i[0][1] % 4 == 3]
1119             im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])
1120 
1121             return (re_part.subs({a: re, b: S.ImaginaryUnit*im}),
1122             im_part1.subs({a: re, b: im}) + im_part3.subs({a: re, b: -im}))
1123 
1124         elif self.exp.is_Rational:
1125             re, im = self.base.as_real_imag(deep=deep)
1126 
1127             if im.is_zero and self.exp is S.Half:
1128                 if re.is_nonnegative:
1129                     return self, S.Zero
1130                 if re.is_nonpositive:
1131                     return S.Zero, (-self.base)**self.exp
1132 
1133             # XXX: This is not totally correct since for x**(p/q) with
1134             #      x being imaginary there are actually q roots, but
1135             #      only a single one is returned from here.
1136             r = self.func(self.func(re, 2) + self.func(im, 2), S.Half)
1137             t = atan2(im, re)
1138 
1139             rp, tp = self.func(r, self.exp), t*self.exp
1140 
1141             return (rp*cos(tp), rp*sin(tp))
1142         else:
1143 
1144             if deep:
1145                 hints['complex'] = False
1146 
1147                 expanded = self.expand(deep, **hints)
1148                 if hints.get('ignore') == expanded:
1149                     return None
1150                 else:
1151                     return (re(expanded), im(expanded))
1152             else:
1153                 return (re(self), im(self))
1154 
1155     def _eval_derivative(self, s):
1156         from sympy import log
1157         dbase = self.base.diff(s)
1158         dexp = self.exp.diff(s)
1159         return self * (dexp * log(self.base) + dbase * self.exp/self.base)
1160 
1161     def _eval_evalf(self, prec):
1162         base, exp = self.as_base_exp()
1163         base = base._evalf(prec)
1164         if not exp.is_Integer:
1165             exp = exp._evalf(prec)
1166         if exp.is_negative and base.is_number and base.is_real is False:
1167             base = base.conjugate() / (base * base.conjugate())._evalf(prec)
1168             exp = -exp
1169             return self.func(base, exp).expand()
1170         return self.func(base, exp)
1171 
1172     def _eval_is_polynomial(self, syms):
1173         if self.exp.has(*syms):
1174             return False
1175 
1176         if self.base.has(*syms):
1177             return bool(self.base._eval_is_polynomial(syms) and
1178                 self.exp.is_Integer and (self.exp >= 0))
1179         else:
1180             return True
1181 
1182     def _eval_is_rational(self):
1183         # The evaluation of self.func below can be very expensive in the case
1184         # of integer**integer if the exponent is large.  We should try to exit
1185         # before that if possible:
1186         if (self.exp.is_integer and self.base.is_rational
1187                 and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero]))):
1188             return True
1189         p = self.func(*self.as_base_exp())  # in case it's unevaluated
1190         if not p.is_Pow:
1191             return p.is_rational
1192         b, e = p.as_base_exp()
1193         if e.is_Rational and b.is_Rational:
1194             # we didn't check that e is not an Integer
1195             # because Rational**Integer autosimplifies
1196             return False
1197         if e.is_integer:
1198             if b.is_rational:
1199                 if fuzzy_not(b.is_zero) or e.is_nonnegative:
1200                     return True
1201                 if b == e:  # always rational, even for 0**0
1202                     return True
1203             elif b.is_irrational:
1204                 return e.is_zero
1205 
1206     def _eval_is_algebraic(self):
1207         def _is_one(expr):
1208             try:
1209                 return (expr - 1).is_zero
1210             except ValueError:
1211                 # when the operation is not allowed
1212                 return False
1213 
1214         if self.base.is_zero or _is_one(self.base):
1215             return True
1216         elif self.exp.is_rational:
1217             if self.base.is_algebraic is False:
1218                 return self.exp.is_zero
1219             return self.base.is_algebraic
1220         elif self.base.is_algebraic and self.exp.is_algebraic:
1221             if ((fuzzy_not(self.base.is_zero)
1222                 and fuzzy_not(_is_one(self.base)))
1223                 or self.base.is_integer is False
1224                 or self.base.is_irrational):
1225                 return self.exp.is_rational
1226 
1227     def _eval_is_rational_function(self, syms):
1228         if self.exp.has(*syms):
1229             return False
1230 
1231         if self.base.has(*syms):
1232             return self.base._eval_is_rational_function(syms) and \
1233                 self.exp.is_Integer
1234         else:
1235             return True
1236 
1237     def _eval_is_algebraic_expr(self, syms):
1238         if self.exp.has(*syms):
1239             return False
1240 
1241         if self.base.has(*syms):
1242             return self.base._eval_is_algebraic_expr(syms) and \
1243                 self.exp.is_Rational
1244         else:
1245             return True
1246 
1247     def _eval_rewrite_as_exp(self, base, expo, **kwargs):
1248         from sympy import exp, log, I, arg
1249 
1250         if base.is_zero or base.has(exp) or expo.has(exp):
1251             return base**expo
1252 
1253         if base.has(Symbol):
1254             # delay evaluation if expo is non symbolic
1255             # (as exp(x*log(5)) automatically reduces to x**5)
1256             return exp(log(base)*expo, evaluate=expo.has(Symbol))
1257 
1258         else:
1259             return exp((log(abs(base)) + I*arg(base))*expo)
1260 
1261     def as_numer_denom(self):
1262         if not self.is_commutative:
1263             return self, S.One
1264         base, exp = self.as_base_exp()
1265         n, d = base.as_numer_denom()
1266         # this should be the same as ExpBase.as_numer_denom wrt
1267         # exponent handling
1268         neg_exp = exp.is_negative
1269         if not neg_exp and not (-exp).is_negative:
1270             neg_exp = _coeff_isneg(exp)
1271         int_exp = exp.is_integer
1272         # the denominator cannot be separated from the numerator if
1273         # its sign is unknown unless the exponent is an integer, e.g.
1274         # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the
1275         # denominator is negative the numerator and denominator can
1276         # be negated and the denominator (now positive) separated.
1277         if not (d.is_real or int_exp):
1278             n = base
1279             d = S.One
1280         dnonpos = d.is_nonpositive
1281         if dnonpos:
1282             n, d = -n, -d
1283         elif dnonpos is None and not int_exp:
1284             n = base
1285             d = S.One
1286         if neg_exp:
1287             n, d = d, n
1288             exp = -exp
1289         if exp.is_infinite:
1290             if n is S.One and d is not S.One:
1291                 return n, self.func(d, exp)
1292             if n is not S.One and d is S.One:
1293                 return self.func(n, exp), d
1294         return self.func(n, exp), self.func(d, exp)
1295 
1296     def matches(self, expr, repl_dict={}, old=False):
1297         expr = _sympify(expr)
1298 
1299         # special case, pattern = 1 and expr.exp can match to 0
1300         if expr is S.One:
1301             d = repl_dict.copy()
1302             d = self.exp.matches(S.Zero, d)
1303             if d is not None:
1304                 return d
1305 
1306         # make sure the expression to be matched is an Expr
1307         if not isinstance(expr, Expr):
1308             return None
1309 
1310         b, e = expr.as_base_exp()
1311 
1312         # special case number
1313         sb, se = self.as_base_exp()
1314         if sb.is_Symbol and se.is_Integer and expr:
1315             if e.is_rational:
1316                 return sb.matches(b**(e/se), repl_dict)
1317             return sb.matches(expr**(1/se), repl_dict)
1318 
1319         d = repl_dict.copy()
1320         d = self.base.matches(b, d)
1321         if d is None:
1322             return None
1323 
1324         d = self.exp.xreplace(d).matches(e, d)
1325         if d is None:
1326             return Expr.matches(self, expr, repl_dict)
1327         return d
1328 
1329     def _eval_nseries(self, x, n, logx):
1330         # NOTE! This function is an important part of the gruntz algorithm
1331         #       for computing limits. It has to return a generalized power
1332         #       series with coefficients in C(log, log(x)). In more detail:
1333         # It has to return an expression
1334         #     c_0*x**e_0 + c_1*x**e_1 + ... (finitely many terms)
1335         # where e_i are numbers (not necessarily integers) and c_i are
1336         # expressions involving only numbers, the log function, and log(x).
1337         from sympy import ceiling, collect, exp, log, O, Order, powsimp
1338         b, e = self.args
1339         if e.is_Integer:
1340             if e > 0:
1341                 # positive integer powers are easy to expand, e.g.:
1342                 # sin(x)**4 = (x - x**3/3 + ...)**4 = ...
1343                 return expand_multinomial(self.func(b._eval_nseries(x, n=n,
1344                     logx=logx), e), deep=False)
1345             elif e is S.NegativeOne:
1346                 # this is also easy to expand using the formula:
1347                 # 1/(1 + x) = 1 - x + x**2 - x**3 ...
1348                 # so we need to rewrite base to the form "1 + x"
1349 
1350                 nuse = n
1351                 cf = 1
1352 
1353                 try:
1354                     ord = b.as_leading_term(x)
1355                     cf = Order(ord, x).getn()
1356                     if cf and cf.is_Number:
1357                         nuse = n + 2*ceiling(cf)
1358                     else:
1359                         cf = 1
1360                 except NotImplementedError:
1361                     pass
1362 
1363                 b_orig, prefactor = b, O(1, x)
1364                 while prefactor.is_Order:
1365                     nuse += 1
1366                     b = b_orig._eval_nseries(x, n=nuse, logx=logx)
1367                     prefactor = b.as_leading_term(x)
1368 
1369                 # express "rest" as: rest = 1 + k*x**l + ... + O(x**n)
1370                 rest = expand_mul((b - prefactor)/prefactor)
1371 
1372                 if rest.is_Order:
1373                     return 1/prefactor + rest/prefactor + O(x**n, x)
1374 
1375                 k, l = rest.leadterm(x)
1376                 if l.is_Rational and l > 0:
1377                     pass
1378                 elif l.is_number and l > 0:
1379                     l = l.evalf()
1380                 elif l == 0:
1381                     k = k.simplify()
1382                     if k == 0:
1383                         # if prefactor == w**4 + x**2*w**4 + 2*x*w**4, we need to
1384                         # factor the w**4 out using collect:
1385                         return 1/collect(prefactor, x)
1386                     else:
1387                         raise NotImplementedError()
1388                 else:
1389                     raise NotImplementedError()
1390 
1391                 if cf < 0:
1392                     cf = S.One/abs(cf)
1393 
1394                 try:
1395                     dn = Order(1/prefactor, x).getn()
1396                     if dn and dn < 0:
1397                         pass
1398                     else:
1399                         dn = 0
1400                 except NotImplementedError:
1401                     dn = 0
1402 
1403                 terms = [1/prefactor]
1404                 for m in range(1, ceiling((n - dn + 1)/l*cf)):
1405                     new_term = terms[-1]*(-rest)
1406                     if new_term.is_Pow:
1407                         new_term = new_term._eval_expand_multinomial(
1408                             deep=False)
1409                     else:
1410                         new_term = expand_mul(new_term, deep=False)
1411                     terms.append(new_term)
1412                 terms.append(O(x**n, x))
1413                 return powsimp(Add(*terms), deep=True, combine='exp')
1414             else:
1415                 # negative powers are rewritten to the cases above, for
1416                 # example:
1417                 # sin(x)**(-4) = 1/(sin(x)**4) = ...
1418                 # and expand the denominator:
1419                 nuse, denominator = n, O(1, x)
1420                 while denominator.is_Order:
1421                     denominator = (b**(-e))._eval_nseries(x, n=nuse, logx=logx)
1422                     nuse += 1
1423                 if 1/denominator == self:
1424                     return self
1425                 # now we have a type 1/f(x), that we know how to expand
1426                 return (1/denominator)._eval_nseries(x, n=n, logx=logx)
1427 
1428         if e.has(Symbol):
1429             return exp(e*log(b))._eval_nseries(x, n=n, logx=logx)
1430 
1431         # see if the base is as simple as possible
1432         bx = b
1433         while bx.is_Pow and bx.exp.is_Rational:
1434             bx = bx.base
1435         if bx == x:
1436             return self
1437 
1438         # work for b(x)**e where e is not an Integer and does not contain x
1439         # and hopefully has no other symbols
1440 
1441         def e2int(e):
1442             """return the integer value (if possible) of e and a
1443             flag indicating whether it is bounded or not."""
1444             n = e.limit(x, 0)
1445             infinite = n.is_infinite
1446             if not infinite:
1447                 # XXX was int or floor intended? int used to behave like floor
1448                 # so int(-Rational(1, 2)) returned -1 rather than int's 0
1449                 try:
1450                     n = int(n)
1451                 except TypeError:
1452                     # well, the n is something more complicated (like 1 + log(2))
1453                     try:
1454                         n = int(n.evalf()) + 1  # XXX why is 1 being added?
1455                     except TypeError:
1456                         pass  # hope that base allows this to be resolved
1457                 n = _sympify(n)
1458             return n, infinite
1459 
1460         order = O(x**n, x)
1461         ei, infinite = e2int(e)
1462         b0 = b.limit(x, 0)
1463         if infinite and (b0 is S.One or b0.has(Symbol)):
1464             # XXX what order
1465             if b0 is S.One:
1466                 resid = (b - 1)
1467                 if resid.is_positive:
1468                     return S.Infinity
1469                 elif resid.is_negative:
1470                     return S.Zero
1471                 raise ValueError('cannot determine sign of %s' % resid)
1472 
1473             return b0**ei
1474 
1475         if (b0 is S.Zero or b0.is_infinite):
1476             if infinite is not False:
1477                 return b0**e  # XXX what order
1478 
1479             if not ei.is_number:  # if not, how will we proceed?
1480                 raise ValueError(
1481                     'expecting numerical exponent but got %s' % ei)
1482 
1483             nuse = n - ei
1484 
1485             if e.is_real and e.is_positive:
1486                 lt = b.as_leading_term(x)
1487 
1488                 # Try to correct nuse (= m) guess from:
1489                 # (lt + rest + O(x**m))**e =
1490                 # lt**e*(1 + rest/lt + O(x**m)/lt)**e =
1491                 # lt**e + ... + O(x**m)*lt**(e - 1) = ... + O(x**n)
1492                 try:
1493                     cf = Order(lt, x).getn()
1494                     nuse = ceiling(n - cf*(e - 1))
1495                 except NotImplementedError:
1496                     pass
1497 
1498             bs = b._eval_nseries(x, n=nuse, logx=logx)
1499             terms = bs.removeO()
1500             if terms.is_Add:
1501                 bs = terms
1502                 lt = terms.as_leading_term(x)
1503 
1504                 # bs -> lt + rest -> lt*(1 + (bs/lt - 1))
1505                 return ((self.func(lt, e) * self.func((bs/lt).expand(), e).nseries(
1506                     x, n=nuse, logx=logx)).expand() + order)
1507 
1508             if bs.is_Add:
1509                 from sympy import O
1510                 # So, bs + O() == terms
1511                 c = Dummy('c')
1512                 res = []
1513                 for arg in bs.args:
1514                     if arg.is_Order:
1515                         arg = c*arg.expr
1516                     res.append(arg)
1517                 bs = Add(*res)
1518                 rv = (bs**e).series(x).subs(c, O(1, x))
1519                 rv += order
1520                 return rv
1521 
1522             rv = bs**e
1523             if terms != bs:
1524                 rv += order
1525             return rv
1526 
1527         # either b0 is bounded but neither 1 nor 0 or e is infinite
1528         # b -> b0 + (b - b0) -> b0 * (1 + (b/b0 - 1))
1529         o2 = order*(b0**-e)
1530         z = (b/b0 - 1)
1531         o = O(z, x)
1532         if o is S.Zero or o2 is S.Zero:
1533             infinite = True
1534         else:
1535             if o.expr.is_number:
1536                 e2 = log(o2.expr*x)/log(x)
1537             else:
1538                 e2 = log(o2.expr)/log(o.expr)
1539             n, infinite = e2int(e2)
1540         if infinite:
1541             # requested accuracy gives infinite series,
1542             # order is probably non-polynomial e.g. O(exp(-1/x), x).
1543             r = 1 + z
1544         else:
1545             l = []
1546             g = None
1547             for i in range(n + 2):
1548                 g = self._taylor_term(i, z, g)
1549                 g = g.nseries(x, n=n, logx=logx)
1550                 l.append(g)
1551             r = Add(*l)
1552         return expand_mul(r*b0**e) + order
1553 
1554     def _eval_as_leading_term(self, x):
1555         from sympy import exp, log
1556         if not self.exp.has(x):
1557             return self.func(self.base.as_leading_term(x), self.exp)
1558         return exp(self.exp * log(self.base)).as_leading_term(x)
1559 
1560     @cacheit
1561     def _taylor_term(self, n, x, *previous_terms): # of (1 + x)**e
1562         from sympy import binomial
1563         return binomial(self.exp, n) * self.func(x, n)
1564 
1565     def _sage_(self):
1566         return self.args[0]._sage_()**self.args[1]._sage_()
1567 
1568     def as_content_primitive(self, radical=False, clear=True):
1569         """Return the tuple (R, self/R) where R is the positive Rational
1570         extracted from self.
1571 
1572         Examples
1573         ========
1574 
1575         >>> from sympy import sqrt
1576         >>> sqrt(4 + 4*sqrt(2)).as_content_primitive()
1577         (2, sqrt(1 + sqrt(2)))
1578         >>> sqrt(3 + 3*sqrt(2)).as_content_primitive()
1579         (1, sqrt(3)*sqrt(1 + sqrt(2)))
1580 
1581         >>> from sympy import expand_power_base, powsimp, Mul
1582         >>> from sympy.abc import x, y
1583 
1584         >>> ((2*x + 2)**2).as_content_primitive()
1585         (4, (x + 1)**2)
1586         >>> (4**((1 + y)/2)).as_content_primitive()
1587         (2, 4**(y/2))
1588         >>> (3**((1 + y)/2)).as_content_primitive()
1589         (1, 3**((y + 1)/2))
1590         >>> (3**((5 + y)/2)).as_content_primitive()
1591         (9, 3**((y + 1)/2))
1592         >>> eq = 3**(2 + 2*x)
1593         >>> powsimp(eq) == eq
1594         True
1595         >>> eq.as_content_primitive()
1596         (9, 3**(2*x))
1597         >>> powsimp(Mul(*_))
1598         3**(2*x + 2)
1599 
1600         >>> eq = (2 + 2*x)**y
1601         >>> s = expand_power_base(eq); s.is_Mul, s
1602         (False, (2*x + 2)**y)
1603         >>> eq.as_content_primitive()
1604         (1, (2*(x + 1))**y)
1605         >>> s = expand_power_base(_[1]); s.is_Mul, s
1606         (True, 2**y*(x + 1)**y)
1607 
1608         See docstring of Expr.as_content_primitive for more examples.
1609         """
1610 
1611         b, e = self.as_base_exp()
1612         b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))
1613         ce, pe = e.as_content_primitive(radical=radical, clear=clear)
1614         if b.is_Rational:
1615             #e
1616             #= ce*pe
1617             #= ce*(h + t)
1618             #= ce*h + ce*t
1619             #=> self
1620             #= b**(ce*h)*b**(ce*t)
1621             #= b**(cehp/cehq)*b**(ce*t)
1622             #= b**(iceh + r/cehq)*b**(ce*t)
1623             #= b**(iceh)*b**(r/cehq)*b**(ce*t)
1624             #= b**(iceh)*b**(ce*t + r/cehq)
1625             h, t = pe.as_coeff_Add()
1626             if h.is_Rational:
1627                 ceh = ce*h
1628                 c = self.func(b, ceh)
1629                 r = S.Zero
1630                 if not c.is_Rational:
1631                     iceh, r = divmod(ceh.p, ceh.q)
1632                     c = self.func(b, iceh)
1633                 return c, self.func(b, _keep_coeff(ce, t + r/ce/ceh.q))
1634         e = _keep_coeff(ce, pe)
1635         # b**e = (h*t)**e = h**e*t**e = c*m*t**e
1636         if e.is_Rational and b.is_Mul:
1637             h, t = b.as_content_primitive(radical=radical, clear=clear)  # h is positive
1638             c, m = self.func(h, e).as_coeff_Mul()  # so c is positive
1639             m, me = m.as_base_exp()
1640             if m is S.One or me == e:  # probably always true
1641                 # return the following, not return c, m*Pow(t, e)
1642                 # which would change Pow into Mul; we let sympy
1643                 # decide what to do by using the unevaluated Mul, e.g
1644                 # should it stay as sqrt(2 + 2*sqrt(5)) or become
1645                 # sqrt(2)*sqrt(1 + sqrt(5))
1646                 return c, self.func(_keep_coeff(m, t), e)
1647         return S.One, self.func(b, e)
1648 
1649     def is_constant(self, *wrt, **flags):
1650         expr = self
1651         if flags.get('simplify', True):
1652             expr = expr.simplify()
1653         b, e = expr.as_base_exp()
1654         bz = b.equals(0)
1655         if bz:  # recalculate with assumptions in case it's unevaluated
1656             new = b**e
1657             if new != expr:
1658                 return new.is_constant()
1659         econ = e.is_constant(*wrt)
1660         bcon = b.is_constant(*wrt)
1661         if bcon:
1662             if econ:
1663                 return True
1664             bz = b.equals(0)
1665             if bz is False:
1666                 return False
1667         elif bcon is None:
1668             return None
1669 
1670         return e.equals(0)
1671 
1672     def _eval_difference_delta(self, n, step):
1673         b, e = self.args
1674         if e.has(n) and not b.has(n):
1675             new_e = e.subs(n, n + step)
1676             return (b**(new_e - e) - 1) * self
1677 
1678 
1679 from .add import Add
1680 from .numbers import Integer
1681 from .mul import Mul, _keep_coeff
1682 from .symbol import Symbol, Dummy, symbols

</code><intended_behavior>Correctly evaluate and simplify expressions involving division and power operation to avoid misinterpretations or errors, specifically ensuring that floor division is handled in line with Python's arithmetic rules when applicable.</intended_behavior>]
2025-10-17 20:42:19.025 | INFO     | Search completed. Bug locations: [<file>sympy/core/numbers.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import absolute_import, print_function, division
2 
3 import numbers
4 import decimal
5 import fractions
6 import math
7 import re as regex
8 
9 from .containers import Tuple
10 from .sympify import converter, sympify, _sympify, SympifyError, _convert_numpy_types
11 from .singleton import S, Singleton
12 from .expr import Expr, AtomicExpr
13 from .decorators import _sympifyit
14 from .cache import cacheit, clear_cache
15 from .logic import fuzzy_not
16 from sympy.core.compatibility import (
17     as_int, integer_types, long, string_types, with_metaclass, HAS_GMPY,
18     SYMPY_INTS, int_info)
19 from sympy.core.cache import lru_cache
20 
21 import mpmath
22 import mpmath.libmp as mlib
23 from mpmath.libmp.backend import MPZ
24 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed
25 from mpmath.ctx_mp import mpnumeric
26 from mpmath.libmp.libmpf import (
27     finf as _mpf_inf, fninf as _mpf_ninf,
28     fnan as _mpf_nan, fzero as _mpf_zero, _normalize as mpf_normalize,
29     prec_to_dps)
30 from sympy.utilities.misc import debug, filldedent
31 from .evaluate import global_evaluate
32 
33 from sympy.utilities.exceptions import SymPyDeprecationWarning
34 
35 rnd = mlib.round_nearest
36 
37 _LOG2 = math.log(2)
38 
39 
40 def comp(z1, z2, tol=None):
41     """Return a bool indicating whether the error between z1 and z2 is <= tol.
42 
43     If ``tol`` is None then True will be returned if there is a significant
44     difference between the numbers: ``abs(z1 - z2)*10**p <= 1/2`` where ``p``
45     is the lower of the precisions of the values. A comparison of strings will
46     be made if ``z1`` is a Number and a) ``z2`` is a string or b) ``tol`` is ''
47     and ``z2`` is a Number.
48 
49     When ``tol`` is a nonzero value, if z2 is non-zero and ``|z1| > 1``
50     the error is normalized by ``|z1|``, so if you want to see if the
51     absolute error between ``z1`` and ``z2`` is <= ``tol`` then call this
52     as ``comp(z1 - z2, 0, tol)``.
53     """
54     if type(z2) is str:
55         if not isinstance(z1, Number):
56             raise ValueError('when z2 is a str z1 must be a Number')
57         return str(z1) == z2
58     if not z1:
59         z1, z2 = z2, z1
60     if not z1:
61         return True
62     if not tol:
63         if tol is None:
64             if type(z2) is str and getattr(z1, 'is_Number', False):
65                 return str(z1) == z2
66             a, b = Float(z1), Float(z2)
67             return int(abs(a - b)*10**prec_to_dps(
68                 min(a._prec, b._prec)))*2 <= 1
69         elif all(getattr(i, 'is_Number', False) for i in (z1, z2)):
70             return z1._prec == z2._prec and str(z1) == str(z2)
71         raise ValueError('exact comparison requires two Numbers')
72     diff = abs(z1 - z2)
73     az1 = abs(z1)
74     if z2 and az1 > 1:
75         return diff/az1 <= tol
76     else:
77         return diff <= tol
78 
79 
80 def mpf_norm(mpf, prec):
81     """Return the mpf tuple normalized appropriately for the indicated
82     precision after doing a check to see if zero should be returned or
83     not when the mantissa is 0. ``mpf_normlize`` always assumes that this
84     is zero, but it may not be since the mantissa for mpf's values "+inf",
85     "-inf" and "nan" have a mantissa of zero, too.
86 
87     Note: this is not intended to validate a given mpf tuple, so sending
88     mpf tuples that were not created by mpmath may produce bad results. This
89     is only a wrapper to ``mpf_normalize`` which provides the check for non-
90     zero mpfs that have a 0 for the mantissa.
91     """
92     sign, man, expt, bc = mpf
93     if not man:
94         # hack for mpf_normalize which does not do this;
95         # it assumes that if man is zero the result is 0
96         # (see issue 6639)
97         if not bc:
98             return _mpf_zero
99         else:
100             # don't change anything; this should already
101             # be a well formed mpf tuple
102             return mpf
103 
104     # Necessary if mpmath is using the gmpy backend
105     from mpmath.libmp.backend import MPZ
106     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)
107     return rv
108 
109 # TODO: we should use the warnings module
110 _errdict = {"divide": False}
111 
112 
113 def seterr(divide=False):
114     """
115     Should sympy raise an exception on 0/0 or return a nan?
116 
117     divide == True .... raise an exception
118     divide == False ... return nan
119     """
120     if _errdict["divide"] != divide:
121         clear_cache()
122         _errdict["divide"] = divide
123 
124 
125 def _as_integer_ratio(p):
126     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)
127     p = [1, -1][neg_pow % 2]*man
128     if expt < 0:
129         q = 2**-expt
130     else:
131         q = 1
132         p *= 2**expt
133     return int(p), int(q)
134 
135 
136 def _decimal_to_Rational_prec(dec):
137     """Convert an ordinary decimal instance to a Rational."""
138     if not dec.is_finite():
139         raise TypeError("dec must be finite, got %s." % dec)
140     s, d, e = dec.as_tuple()
141     prec = len(d)
142     if e >= 0:  # it's an integer
143         rv = Integer(int(dec))
144     else:
145         s = (-1)**s
146         d = sum([di*10**i for i, di in enumerate(reversed(d))])
147         rv = Rational(s*d, 10**-e)
148     return rv, prec
149 
150 
151 _floatpat = regex.compile(r"[-+]?((\d*\.\d+)|(\d+\.?))")
152 def _literal_float(f):
153     """Return True if n starts like a floating point number."""
154     return bool(_floatpat.match(f))
155 
156 # (a,b) -> gcd(a,b)
157 
158 # TODO caching with decorator, but not to degrade performance
159 
160 @lru_cache(1024)
161 def igcd(*args):
162     """Computes nonnegative integer greatest common divisor.
163 
164     The algorithm is based on the well known Euclid's algorithm. To
165     improve speed, igcd() has its own caching mechanism implemented.
166 
167     Examples
168     ========
169 
170     >>> from sympy.core.numbers import igcd
171     >>> igcd(2, 4)
172     2
173     >>> igcd(5, 10, 15)
174     5
175 
176     """
177     if len(args) < 2:
178         raise TypeError(
179             'igcd() takes at least 2 arguments (%s given)' % len(args))
180     args_temp = [abs(as_int(i)) for i in args]
181     if 1 in args_temp:
182         return 1
183     a = args_temp.pop()
184     for b in args_temp:
185         a = igcd2(a, b) if b else a
186     return a
187 
188 
189 try:
190     from math import gcd as igcd2
191 except ImportError:
192     def igcd2(a, b):
193         """Compute gcd of two Python integers a and b."""
194         if (a.bit_length() > BIGBITS and
195             b.bit_length() > BIGBITS):
196             return igcd_lehmer(a, b)
197 
198         a, b = abs(a), abs(b)
199         while b:
200             a, b = b, a % b
201         return a
202 
203 
204 # Use Lehmer's algorithm only for very large numbers.
205 # The limit could be different on Python 2.7 and 3.x.
206 # If so, then this could be defined in compatibility.py.
207 BIGBITS = 5000
208 def igcd_lehmer(a, b):
209     """Computes greatest common divisor of two integers.
210 
211     Euclid's algorithm for the computation of the greatest
212     common divisor  gcd(a, b)  of two (positive) integers
213     a and b is based on the division identity
214         a = q*b + r,
215     where the quotient  q  and the remainder  r  are integers
216     and  0 <= r < b. Then each common divisor of  a  and  b
217     divides  r, and it follows that  gcd(a, b) == gcd(b, r).
218     The algorithm works by constructing the sequence
219     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn
220     is the remainder from the division of the two preceding
221     elements.
222 
223     In Python, q = a // b  and  r = a % b  are obtained by the
224     floor division and the remainder operations, respectively.
225     These are the most expensive arithmetic operations, especially
226     for large  a  and  b.
227 
228     Lehmer's algorithm is based on the observation that the quotients
229     qn = r(n-1) // rn  are in general small integers even
230     when  a  and  b  are very large. Hence the quotients can be
231     usually determined from a relatively small number of most
232     significant bits.
233 
234     The efficiency of the algorithm is further enhanced by not
235     computing each long remainder in Euclid's sequence. The remainders
236     are linear combinations of  a  and  b  with integer coefficients
237     derived from the quotients. The coefficients can be computed
238     as far as the quotients can be determined from the chosen
239     most significant parts of  a  and  b. Only then a new pair of
240     consecutive remainders is computed and the algorithm starts
241     anew with this pair.
242 
243     References
244     ==========
245 
246     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
247 
248     """
249     a, b = abs(as_int(a)), abs(as_int(b))
250     if a < b:
251         a, b = b, a
252 
253     # The algorithm works by using one or two digit division
254     # whenever possible. The outer loop will replace the
255     # pair (a, b) with a pair of shorter consecutive elements
256     # of the Euclidean gcd sequence until a and b
257     # fit into two Python (long) int digits.
258     nbits = 2*int_info.bits_per_digit
259 
260     while a.bit_length() > nbits and b != 0:
261         # Quotients are mostly small integers that can
262         # be determined from most significant bits.
263         n = a.bit_length() - nbits
264         x, y = int(a >> n), int(b >> n)  # most significant bits
265 
266         # Elements of the Euclidean gcd sequence are linear
267         # combinations of a and b with integer coefficients.
268         # Compute the coefficients of consecutive pairs
269         #     a' = A*a + B*b, b' = C*a + D*b
270         # using small integer arithmetic as far as possible.
271         A, B, C, D = 1, 0, 0, 1  # initial values
272 
273         while True:
274             # The coefficients alternate in sign while looping.
275             # The inner loop combines two steps to keep track
276             # of the signs.
277 
278             # At this point we have
279             #   A > 0, B <= 0, C <= 0, D > 0,
280             #   x' = x + B <= x < x" = x + A,
281             #   y' = y + C <= y < y" = y + D,
282             # and
283             #   x'*N <= a' < x"*N, y'*N <= b' < y"*N,
284             # where N = 2**n.
285 
286             # Now, if y' > 0, and x"//y' and x'//y" agree,
287             # then their common value is equal to  q = a'//b'.
288             # In addition,
289             #   x'%y" = x' - q*y" < x" - q*y' = x"%y',
290             # and
291             #   (x'%y")*N < a'%b' < (x"%y')*N.
292 
293             # On the other hand, we also have  x//y == q,
294             # and therefore
295             #   x'%y" = x + B - q*(y + D) = x%y + B',
296             #   x"%y' = x + A - q*(y + C) = x%y + A',
297             # where
298             #    B' = B - q*D < 0, A' = A - q*C > 0.
299 
300             if y + C <= 0:
301                 break
302             q = (x + A) // (y + C)
303 
304             # Now  x'//y" <= q, and equality holds if
305             #   x' - q*y" = (x - q*y) + (B - q*D) >= 0.
306             # This is a minor optimization to avoid division.
307             x_qy, B_qD = x - q*y, B - q*D
308             if x_qy + B_qD < 0:
309                 break
310 
311             # Next step in the Euclidean sequence.
312             x, y = y, x_qy
313             A, B, C, D = C, D, A - q*C, B_qD
314 
315             # At this point the signs of the coefficients
316             # change and their roles are interchanged.
317             #   A <= 0, B > 0, C > 0, D < 0,
318             #   x' = x + A <= x < x" = x + B,
319             #   y' = y + D < y < y" = y + C.
320 
321             if y + D <= 0:
322                 break
323             q = (x + B) // (y + D)
324             x_qy, A_qC = x - q*y, A - q*C
325             if x_qy + A_qC < 0:
326                 break
327 
328             x, y = y, x_qy
329             A, B, C, D = C, D, A_qC, B - q*D
330             # Now the conditions on top of the loop
331             # are again satisfied.
332             #   A > 0, B < 0, C < 0, D > 0.
333 
334         if B == 0:
335             # This can only happen when y == 0 in the beginning
336             # and the inner loop does nothing.
337             # Long division is forced.
338             a, b = b, a % b
339             continue
340 
341         # Compute new long arguments using the coefficients.
342         a, b = A*a + B*b, C*a + D*b
343 
344     # Small divisors. Finish with the standard algorithm.
345     while b:
346         a, b = b, a % b
347 
348     return a
349 
350 
351 def ilcm(*args):
352     """Computes integer least common multiple.
353 
354     Examples
355     ========
356 
357     >>> from sympy.core.numbers import ilcm
358     >>> ilcm(5, 10)
359     10
360     >>> ilcm(7, 3)
361     21
362     >>> ilcm(5, 10, 15)
363     30
364 
365     """
366     if len(args) < 2:
367         raise TypeError(
368             'ilcm() takes at least 2 arguments (%s given)' % len(args))
369     if 0 in args:
370         return 0
371     a = args[0]
372     for b in args[1:]:
373         a = a // igcd(a, b) * b # since gcd(a,b) | a
374     return a
375 
376 
377 def igcdex(a, b):
378     """Returns x, y, g such that g = x*a + y*b = gcd(a, b).
379 
380        >>> from sympy.core.numbers import igcdex
381        >>> igcdex(2, 3)
382        (-1, 1, 1)
383        >>> igcdex(10, 12)
384        (-1, 1, 2)
385 
386        >>> x, y, g = igcdex(100, 2004)
387        >>> x, y, g
388        (-20, 1, 4)
389        >>> x*100 + y*2004
390        4
391 
392     """
393     if (not a) and (not b):
394         return (0, 1, 0)
395 
396     if not a:
397         return (0, b//abs(b), abs(b))
398     if not b:
399         return (a//abs(a), 0, abs(a))
400 
401     if a < 0:
402         a, x_sign = -a, -1
403     else:
404         x_sign = 1
405 
406     if b < 0:
407         b, y_sign = -b, -1
408     else:
409         y_sign = 1
410 
411     x, y, r, s = 1, 0, 0, 1
412 
413     while b:
414         (c, q) = (a % b, a // b)
415         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)
416 
417     return (x*x_sign, y*y_sign, a)
418 
419 
420 def mod_inverse(a, m):
421     """
422     Return the number c such that, (a * c) = 1 (mod m)
423     where c has the same sign as m. If no such value exists,
424     a ValueError is raised.
425 
426     Examples
427     ========
428 
429     >>> from sympy import S
430     >>> from sympy.core.numbers import mod_inverse
431 
432     Suppose we wish to find multiplicative inverse x of
433     3 modulo 11. This is the same as finding x such
434     that 3 * x = 1 (mod 11). One value of x that satisfies
435     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).
436     This is the value return by mod_inverse:
437 
438     >>> mod_inverse(3, 11)
439     4
440     >>> mod_inverse(-3, 11)
441     7
442 
443     When there is a common factor between the numerators of
444     ``a`` and ``m`` the inverse does not exist:
445 
446     >>> mod_inverse(2, 4)
447     Traceback (most recent call last):
448     ...
449     ValueError: inverse of 2 mod 4 does not exist
450 
451     >>> mod_inverse(S(2)/7, S(5)/2)
452     7/2
453 
454     References
455     ==========
456     - https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
457     - https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
458     """
459     c = None
460     try:
461         a, m = as_int(a), as_int(m)
462         if m != 1 and m != -1:
463             x, y, g = igcdex(a, m)
464             if g == 1:
465                 c = x % m
466     except ValueError:
467         a, m = sympify(a), sympify(m)
468         if not (a.is_number and m.is_number):
469             raise TypeError(filldedent('''
470                 Expected numbers for arguments; symbolic `mod_inverse`
471                 is not implemented
472                 but symbolic expressions can be handled with the
473                 similar function,
474                 sympy.polys.polytools.invert'''))
475         big = (m > 1)
476         if not (big is S.true or big is S.false):
477             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)
478         elif big:
479             c = 1/a
480     if c is None:
481         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))
482     return c
483 
484 
485 class Number(AtomicExpr):
486     """Represents atomic numbers in SymPy.
487 
488     Floating point numbers are represented by the Float class.
489     Rational numbers (of any size) are represented by the Rational class.
490     Integer numbers (of any size) are represented by the Integer class.
491     Float and Rational are subclasses of Number; Integer is a subclass
492     of Rational.
493 
494     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is
495     a different object from the floating point number obtained with
496     Python division ``2/3``. Even for numbers that are exactly
497     represented in binary, there is a difference between how two forms,
498     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.
499     The rational form is to be preferred in symbolic computations.
500 
501     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or
502     complex numbers ``3 + 4*I``, are not instances of Number class as
503     they are not atomic.
504 
505     See Also
506     ========
507 
508     Float, Integer, Rational
509     """
510     is_commutative = True
511     is_number = True
512     is_Number = True
513 
514     __slots__ = []
515 
516     # Used to make max(x._prec, y._prec) return x._prec when only x is a float
517     _prec = -1
518 
519     def __new__(cls, *obj):
520         if len(obj) == 1:
521             obj = obj[0]
522 
523         if isinstance(obj, Number):
524             return obj
525         if isinstance(obj, SYMPY_INTS):
526             return Integer(obj)
527         if isinstance(obj, tuple) and len(obj) == 2:
528             return Rational(*obj)
529         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):
530             return Float(obj)
531         if isinstance(obj, string_types):
532             val = sympify(obj)
533             if isinstance(val, Number):
534                 return val
535             else:
536                 raise ValueError('String "%s" does not denote a Number' % obj)
537         msg = "expected str|int|long|float|Decimal|Number object but got %r"
538         raise TypeError(msg % type(obj).__name__)
539 
540     def invert(self, other, *gens, **args):
541         from sympy.polys.polytools import invert
542         if getattr(other, 'is_number', True):
543             return mod_inverse(self, other)
544         return invert(self, other, *gens, **args)
545 
546     def __divmod__(self, other):
547         from .containers import Tuple
548 
549         try:
550             other = Number(other)
551         except TypeError:
552             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
553             raise TypeError(msg % (type(self).__name__, type(other).__name__))
554         if not other:
555             raise ZeroDivisionError('modulo by zero')
556         if self.is_Integer and other.is_Integer:
557             return Tuple(*divmod(self.p, other.p))
558         else:
559             rat = self/other
560         w = int(rat) if rat > 0 else int(rat) - 1
561         r = self - other*w
562         return Tuple(w, r)
563 
564     def __rdivmod__(self, other):
565         try:
566             other = Number(other)
567         except TypeError:
568             msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
569             raise TypeError(msg % (type(other).__name__, type(self).__name__))
570         return divmod(other, self)
571 
572     def _as_mpf_val(self, prec):
573         """Evaluation of mpf tuple accurate to at least prec bits."""
574         raise NotImplementedError('%s needs ._as_mpf_val() method' %
575             (self.__class__.__name__))
576 
577     def _eval_evalf(self, prec):
578         return Float._new(self._as_mpf_val(prec), prec)
579 
580     def _as_mpf_op(self, prec):
581         prec = max(prec, self._prec)
582         return self._as_mpf_val(prec), prec
583 
584     def __float__(self):
585         return mlib.to_float(self._as_mpf_val(53))
586 
587     def floor(self):
588         raise NotImplementedError('%s needs .floor() method' %
589             (self.__class__.__name__))
590 
591     def ceiling(self):
592         raise NotImplementedError('%s needs .ceiling() method' %
593             (self.__class__.__name__))
594 
595     def __floor__(self):
596         return self.floor()
597 
598     def __ceil__(self):
599         return self.ceiling()
600 
601     def _eval_conjugate(self):
602         return self
603 
604     def _eval_order(self, *symbols):
605         from sympy import Order
606         # Order(5, x, y) -> Order(1,x,y)
607         return Order(S.One, *symbols)
608 
609     def _eval_subs(self, old, new):
610         if old == -self:
611             return -new
612         return self  # there is no other possibility
613 
614     def _eval_is_finite(self):
615         return True
616 
617     @classmethod
618     def class_key(cls):
619         return 1, 0, 'Number'
620 
621     @cacheit
622     def sort_key(self, order=None):
623         return self.class_key(), (0, ()), (), self
624 
625     @_sympifyit('other', NotImplemented)
626     def __add__(self, other):
627         if isinstance(other, Number) and global_evaluate[0]:
628             if other is S.NaN:
629                 return S.NaN
630             elif other is S.Infinity:
631                 return S.Infinity
632             elif other is S.NegativeInfinity:
633                 return S.NegativeInfinity
634         return AtomicExpr.__add__(self, other)
635 
636     @_sympifyit('other', NotImplemented)
637     def __sub__(self, other):
638         if isinstance(other, Number) and global_evaluate[0]:
639             if other is S.NaN:
640                 return S.NaN
641             elif other is S.Infinity:
642                 return S.NegativeInfinity
643             elif other is S.NegativeInfinity:
644                 return S.Infinity
645         return AtomicExpr.__sub__(self, other)
646 
647     @_sympifyit('other', NotImplemented)
648     def __mul__(self, other):
649         if isinstance(other, Number) and global_evaluate[0]:
650             if other is S.NaN:
651                 return S.NaN
652             elif other is S.Infinity:
653                 if self.is_zero:
654                     return S.NaN
655                 elif self.is_positive:
656                     return S.Infinity
657                 else:
658                     return S.NegativeInfinity
659             elif other is S.NegativeInfinity:
660                 if self.is_zero:
661                     return S.NaN
662                 elif self.is_positive:
663                     return S.NegativeInfinity
664                 else:
665                     return S.Infinity
666         elif isinstance(other, Tuple):
667             return NotImplemented
668         return AtomicExpr.__mul__(self, other)
669 
670     @_sympifyit('other', NotImplemented)
671     def __div__(self, other):
672         if isinstance(other, Number) and global_evaluate[0]:
673             if other is S.NaN:
674                 return S.NaN
675             elif other is S.Infinity or other is S.NegativeInfinity:
676                 return S.Zero
677         return AtomicExpr.__div__(self, other)
678 
679     __truediv__ = __div__
680 
681     def __eq__(self, other):
682         raise NotImplementedError('%s needs .__eq__() method' %
683             (self.__class__.__name__))
684 
685     def __ne__(self, other):
686         raise NotImplementedError('%s needs .__ne__() method' %
687             (self.__class__.__name__))
688 
689     def __lt__(self, other):
690         try:
691             other = _sympify(other)
692         except SympifyError:
693             raise TypeError("Invalid comparison %s < %s" % (self, other))
694         raise NotImplementedError('%s needs .__lt__() method' %
695             (self.__class__.__name__))
696 
697     def __le__(self, other):
698         try:
699             other = _sympify(other)
700         except SympifyError:
701             raise TypeError("Invalid comparison %s <= %s" % (self, other))
702         raise NotImplementedError('%s needs .__le__() method' %
703             (self.__class__.__name__))
704 
705     def __gt__(self, other):
706         try:
707             other = _sympify(other)
708         except SympifyError:
709             raise TypeError("Invalid comparison %s > %s" % (self, other))
710         return _sympify(other).__lt__(self)
711 
712     def __ge__(self, other):
713         try:
714             other = _sympify(other)
715         except SympifyError:
716             raise TypeError("Invalid comparison %s >= %s" % (self, other))
717         return _sympify(other).__le__(self)
718 
719     def __hash__(self):
720         return super(Number, self).__hash__()
721 
722     def is_constant(self, *wrt, **flags):
723         return True
724 
725     def as_coeff_mul(self, *deps, **kwargs):
726         # a -> c*t
727         if self.is_Rational or not kwargs.pop('rational', True):
728             return self, tuple()
729         elif self.is_negative:
730             return S.NegativeOne, (-self,)
731         return S.One, (self,)
732 
733     def as_coeff_add(self, *deps):
734         # a -> c + t
735         if self.is_Rational:
736             return self, tuple()
737         return S.Zero, (self,)
738 
739     def as_coeff_Mul(self, rational=False):
740         """Efficiently extract the coefficient of a product. """
741         if rational and not self.is_Rational:
742             return S.One, self
743         return (self, S.One) if self else (S.One, self)
744 
745     def as_coeff_Add(self, rational=False):
746         """Efficiently extract the coefficient of a summation. """
747         if not rational:
748             return self, S.Zero
749         return S.Zero, self
750 
751     def gcd(self, other):
752         """Compute GCD of `self` and `other`. """
753         from sympy.polys import gcd
754         return gcd(self, other)
755 
756     def lcm(self, other):
757         """Compute LCM of `self` and `other`. """
758         from sympy.polys import lcm
759         return lcm(self, other)
760 
761     def cofactors(self, other):
762         """Compute GCD and cofactors of `self` and `other`. """
763         from sympy.polys import cofactors
764         return cofactors(self, other)
765 
766 
767 class Float(Number):
768     """Represent a floating-point number of arbitrary precision.
769 
770     Examples
771     ========
772 
773     >>> from sympy import Float
774     >>> Float(3.5)
775     3.50000000000000
776     >>> Float(3)
777     3.00000000000000
778 
779     Creating Floats from strings (and Python ``int`` and ``long``
780     types) will give a minimum precision of 15 digits, but the
781     precision will automatically increase to capture all digits
782     entered.
783 
784     >>> Float(1)
785     1.00000000000000
786     >>> Float(10**20)
787     100000000000000000000.
788     >>> Float('1e20')
789     100000000000000000000.
790 
791     However, *floating-point* numbers (Python ``float`` types) retain
792     only 15 digits of precision:
793 
794     >>> Float(1e20)
795     1.00000000000000e+20
796     >>> Float(1.23456789123456789)
797     1.23456789123457
798 
799     It may be preferable to enter high-precision decimal numbers
800     as strings:
801 
802     Float('1.23456789123456789')
803     1.23456789123456789
804 
805     The desired number of digits can also be specified:
806 
807     >>> Float('1e-3', 3)
808     0.00100
809     >>> Float(100, 4)
810     100.0
811 
812     Float can automatically count significant figures if a null string
813     is sent for the precision; spaces or underscores are also allowed. (Auto-
814     counting is only allowed for strings, ints and longs).
815 
816     >>> Float('123 456 789.123_456', '')
817     123456789.123456
818     >>> Float('12e-3', '')
819     0.012
820     >>> Float(3, '')
821     3.
822 
823     If a number is written in scientific notation, only the digits before the
824     exponent are considered significant if a decimal appears, otherwise the
825     "e" signifies only how to move the decimal:
826 
827     >>> Float('60.e2', '')  # 2 digits significant
828     6.0e+3
829     >>> Float('60e2', '')  # 4 digits significant
830     6000.
831     >>> Float('600e-2', '')  # 3 digits significant
832     6.00
833 
834     Notes
835     =====
836 
837     Floats are inexact by their nature unless their value is a binary-exact
838     value.
839 
840     >>> approx, exact = Float(.1, 1), Float(.125, 1)
841 
842     For calculation purposes, evalf needs to be able to change the precision
843     but this will not increase the accuracy of the inexact value. The
844     following is the most accurate 5-digit approximation of a value of 0.1
845     that had only 1 digit of precision:
846 
847     >>> approx.evalf(5)
848     0.099609
849 
850     By contrast, 0.125 is exact in binary (as it is in base 10) and so it
851     can be passed to Float or evalf to obtain an arbitrary precision with
852     matching accuracy:
853 
854     >>> Float(exact, 5)
855     0.12500
856     >>> exact.evalf(20)
857     0.12500000000000000000
858 
859     Trying to make a high-precision Float from a float is not disallowed,
860     but one must keep in mind that the *underlying float* (not the apparent
861     decimal value) is being obtained with high precision. For example, 0.3
862     does not have a finite binary representation. The closest rational is
863     the fraction 5404319552844595/2**54. So if you try to obtain a Float of
864     0.3 to 20 digits of precision you will not see the same thing as 0.3
865     followed by 19 zeros:
866 
867     >>> Float(0.3, 20)
868     0.29999999999999998890
869 
870     If you want a 20-digit value of the decimal 0.3 (not the floating point
871     approximation of 0.3) you should send the 0.3 as a string. The underlying
872     representation is still binary but a higher precision than Python's float
873     is used:
874 
875     >>> Float('0.3', 20)
876     0.30000000000000000000
877 
878     Although you can increase the precision of an existing Float using Float
879     it will not increase the accuracy -- the underlying value is not changed:
880 
881     >>> def show(f): # binary rep of Float
882     ...     from sympy import Mul, Pow
883     ...     s, m, e, b = f._mpf_
884     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)
885     ...     print('%s at prec=%s' % (v, f._prec))
886     ...
887     >>> t = Float('0.3', 3)
888     >>> show(t)
889     4915/2**14 at prec=13
890     >>> show(Float(t, 20)) # higher prec, not higher accuracy
891     4915/2**14 at prec=70
892     >>> show(Float(t, 2)) # lower prec
893     307/2**10 at prec=10
894 
895     The same thing happens when evalf is used on a Float:
896 
897     >>> show(t.evalf(20))
898     4915/2**14 at prec=70
899     >>> show(t.evalf(2))
900     307/2**10 at prec=10
901 
902     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to
903     produce the number (-1)**n*c*2**p:
904 
905     >>> n, c, p = 1, 5, 0
906     >>> (-1)**n*c*2**p
907     -5
908     >>> Float((1, 5, 0))
909     -5.00000000000000
910 
911     An actual mpf tuple also contains the number of bits in c as the last
912     element of the tuple:
913 
914     >>> _._mpf_
915     (1, 5, 0, 3)
916 
917     This is not needed for instantiation and is not the same thing as the
918     precision. The mpf tuple and the precision are two separate quantities
919     that Float tracks.
920 
921     """
922     __slots__ = ['_mpf_', '_prec']
923 
924     # A Float represents many real numbers,
925     # both rational and irrational.
926     is_rational = None
927     is_irrational = None
928     is_number = True
929 
930     is_real = True
931 
932     is_Float = True
933 
934     def __new__(cls, num, dps=None, prec=None, precision=None):
935         if prec is not None:
936             SymPyDeprecationWarning(
937                             feature="Using 'prec=XX' to denote decimal precision",
938                             useinstead="'dps=XX' for decimal precision and 'precision=XX' "\
939                                               "for binary precision",
940                             issue=12820,
941                             deprecated_since_version="1.1").warn()
942             dps = prec
943         del prec  # avoid using this deprecated kwarg
944 
945         if dps is not None and precision is not None:
946             raise ValueError('Both decimal and binary precision supplied. '
947                              'Supply only one. ')
948 
949         if isinstance(num, string_types):
950             # Float already accepts spaces as digit separators; in Py 3.6
951             # underscores are allowed. In anticipation of that, we ignore
952             # legally placed underscores
953             num = num.replace(' ', '')
954             if '_' in num:
955                 if num.startswith('_') or num.endswith('_') or any(
956                         i in num for i in ('__', '_.', '._')):
957                     # copy Py 3.6 error
958                     raise ValueError("could not convert string to float: '%s'" % num)
959                 num = num.replace('_', '')
960             if num.startswith('.') and len(num) > 1:
961                 num = '0' + num
962             elif num.startswith('-.') and len(num) > 2:
963                 num = '-0.' + num[2:]
964             elif num == 'inf' or num == '+inf':
965                 return S.Infinity
966             elif num == '-inf':
967                 return S.NegativeInfinity
968         elif isinstance(num, float) and num == 0:
969             num = '0'
970         elif isinstance(num, float) and num == float('inf'):
971             return S.Infinity
972         elif isinstance(num, float) and num == float('-inf'):
973             return S.NegativeInfinity
974         elif isinstance(num, (SYMPY_INTS, Integer)):
975             num = str(num)  # faster than mlib.from_int
976         elif num is S.Infinity:
977             return num
978         elif num is S.NegativeInfinity:
979             return num
980         elif type(num).__module__ == 'numpy': # support for numpy datatypes
981             num = _convert_numpy_types(num)
982         elif isinstance(num, mpmath.mpf):
983             if precision is None:
984                 if dps is None:
985                     precision = num.context.prec
986             num = num._mpf_
987 
988         if dps is None and precision is None:
989             dps = 15
990             if isinstance(num, Float):
991                 return num
992             if isinstance(num, string_types) and _literal_float(num):
993                 try:
994                     Num = decimal.Decimal(num)
995                 except decimal.InvalidOperation:
996                     pass
997                 else:
998                     isint = '.' not in num
999                     num, dps = _decimal_to_Rational_prec(Num)
1000                     if num.is_Integer and isint:
1001                         dps = max(dps, len(str(num).lstrip('-')))
1002                     dps = max(15, dps)
1003                     precision = mlib.libmpf.dps_to_prec(dps)
1004         elif precision == '' and dps is None or precision is None and dps == '':
1005             if not isinstance(num, string_types):
1006                 raise ValueError('The null string can only be used when '
1007                 'the number to Float is passed as a string or an integer.')
1008             ok = None
1009             if _literal_float(num):
1010                 try:
1011                     Num = decimal.Decimal(num)
1012                 except decimal.InvalidOperation:
1013                     pass
1014                 else:
1015                     isint = '.' not in num
1016                     num, dps = _decimal_to_Rational_prec(Num)
1017                     if num.is_Integer and isint:
1018                         dps = max(dps, len(str(num).lstrip('-')))
1019                         precision = mlib.libmpf.dps_to_prec(dps)
1020                     ok = True
1021             if ok is None:
1022                 raise ValueError('string-float not recognized: %s' % num)
1023 
1024         # decimal precision(dps) is set and maybe binary precision(precision)
1025         # as well.From here on binary precision is used to compute the Float.
1026         # Hence, if supplied use binary precision else translate from decimal
1027         # precision.
1028 
1029         if precision is None or precision == '':
1030             precision = mlib.libmpf.dps_to_prec(dps)
1031 
1032         precision = int(precision)
1033 
1034         if isinstance(num, float):
1035             _mpf_ = mlib.from_float(num, precision, rnd)
1036         elif isinstance(num, string_types):
1037             _mpf_ = mlib.from_str(num, precision, rnd)
1038         elif isinstance(num, decimal.Decimal):
1039             if num.is_finite():
1040                 _mpf_ = mlib.from_str(str(num), precision, rnd)
1041             elif num.is_nan():
1042                 return S.NaN
1043             elif num.is_infinite():
1044                 if num > 0:
1045                     return S.Infinity
1046                 else:
1047                     return S.NegativeInfinity
1048             else:
1049                 raise ValueError("unexpected decimal value %s" % str(num))
1050         elif isinstance(num, tuple) and len(num) in (3, 4):
1051             if type(num[1]) is str:
1052                 # it's a hexadecimal (coming from a pickled object)
1053                 # assume that it is in standard form
1054                 num = list(num)
1055                 # If we're loading an object pickled in Python 2 into
1056                 # Python 3, we may need to strip a tailing 'L' because
1057                 # of a shim for int on Python 3, see issue #13470.
1058                 if num[1].endswith('L'):
1059                     num[1] = num[1][:-1]
1060                 num[1] = MPZ(num[1], 16)
1061                 _mpf_ = tuple(num)
1062             else:
1063                 if len(num) == 4:
1064                     # handle normalization hack
1065                     return Float._new(num, precision)
1066                 else:
1067                     return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)
1068         else:
1069             try:
1070                 _mpf_ = num._as_mpf_val(precision)
1071             except (NotImplementedError, AttributeError):
1072                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_
1073 
1074         # special cases
1075         if _mpf_ == _mpf_zero:
1076             pass  # we want a Float
1077         elif _mpf_ == _mpf_nan:
1078             return S.NaN
1079         elif _mpf_ == _mpf_inf:
1080             return S.Infinity
1081         elif _mpf_ == _mpf_ninf:
1082             return S.NegativeInfinity
1083 
1084         obj = Expr.__new__(cls)
1085         obj._mpf_ = _mpf_
1086         obj._prec = precision
1087         return obj
1088 
1089     @classmethod
1090     def _new(cls, _mpf_, _prec):
1091         # special cases
1092         if _mpf_ == _mpf_zero:
1093             return S.Zero  # XXX this is different from Float which gives 0.0
1094         elif _mpf_ == _mpf_nan:
1095             return S.NaN
1096         elif _mpf_ == _mpf_inf:
1097             return S.Infinity
1098         elif _mpf_ == _mpf_ninf:
1099             return S.NegativeInfinity
1100 
1101         obj = Expr.__new__(cls)
1102         obj._mpf_ = mpf_norm(_mpf_, _prec)
1103         # XXX: Should this be obj._prec = obj._mpf_[3]?
1104         obj._prec = _prec
1105         return obj
1106 
1107     # mpz can't be pickled
1108     def __getnewargs__(self):
1109         return (mlib.to_pickable(self._mpf_),)
1110 
1111     def __getstate__(self):
1112         return {'_prec': self._prec}
1113 
1114     def _hashable_content(self):
1115         return (self._mpf_, self._prec)
1116 
1117     def floor(self):
1118         return Integer(int(mlib.to_int(
1119             mlib.mpf_floor(self._mpf_, self._prec))))
1120 
1121     def ceiling(self):
1122         return Integer(int(mlib.to_int(
1123             mlib.mpf_ceil(self._mpf_, self._prec))))
1124 
1125     def __floor__(self):
1126         return self.floor()
1127 
1128     def __ceil__(self):
1129         return self.ceiling()
1130 
1131 
1132     @property
1133     def num(self):
1134         return mpmath.mpf(self._mpf_)
1135 
1136     def _as_mpf_val(self, prec):
1137         rv = mpf_norm(self._mpf_, prec)
1138         if rv != self._mpf_ and self._prec == prec:
1139             debug(self._mpf_, rv)
1140         return rv
1141 
1142     def _as_mpf_op(self, prec):
1143         return self._mpf_, max(prec, self._prec)
1144 
1145     def _eval_is_finite(self):
1146         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1147             return False
1148         return True
1149 
1150     def _eval_is_infinite(self):
1151         if self._mpf_ in (_mpf_inf, _mpf_ninf):
1152             return True
1153         return False
1154 
1155     def _eval_is_integer(self):
1156         return self._mpf_ == _mpf_zero
1157 
1158     def _eval_is_negative(self):
1159         if self._mpf_ == _mpf_ninf:
1160             return True
1161         if self._mpf_ == _mpf_inf:
1162             return False
1163         return self.num < 0
1164 
1165     def _eval_is_positive(self):
1166         if self._mpf_ == _mpf_inf:
1167             return True
1168         if self._mpf_ == _mpf_ninf:
1169             return False
1170         return self.num > 0
1171 
1172     def _eval_is_zero(self):
1173         return self._mpf_ == _mpf_zero
1174 
1175     def __nonzero__(self):
1176         return self._mpf_ != _mpf_zero
1177 
1178     __bool__ = __nonzero__
1179 
1180     def __neg__(self):
1181         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)
1182 
1183     @_sympifyit('other', NotImplemented)
1184     def __add__(self, other):
1185         if isinstance(other, Number) and global_evaluate[0]:
1186             rhs, prec = other._as_mpf_op(self._prec)
1187             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)
1188         return Number.__add__(self, other)
1189 
1190     @_sympifyit('other', NotImplemented)
1191     def __sub__(self, other):
1192         if isinstance(other, Number) and global_evaluate[0]:
1193             rhs, prec = other._as_mpf_op(self._prec)
1194             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)
1195         return Number.__sub__(self, other)
1196 
1197     @_sympifyit('other', NotImplemented)
1198     def __mul__(self, other):
1199         if isinstance(other, Number) and global_evaluate[0]:
1200             rhs, prec = other._as_mpf_op(self._prec)
1201             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)
1202         return Number.__mul__(self, other)
1203 
1204     @_sympifyit('other', NotImplemented)
1205     def __div__(self, other):
1206         if isinstance(other, Number) and other != 0 and global_evaluate[0]:
1207             rhs, prec = other._as_mpf_op(self._prec)
1208             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)
1209         return Number.__div__(self, other)
1210 
1211     __truediv__ = __div__
1212 
1213     @_sympifyit('other', NotImplemented)
1214     def __mod__(self, other):
1215         if isinstance(other, Rational) and other.q != 1 and global_evaluate[0]:
1216             # calculate mod with Rationals, *then* round the result
1217             return Float(Rational.__mod__(Rational(self), other),
1218                          precision=self._prec)
1219         if isinstance(other, Float) and global_evaluate[0]:
1220             r = self/other
1221             if r == int(r):
1222                 return Float(0, precision=max(self._prec, other._prec))
1223         if isinstance(other, Number) and global_evaluate[0]:
1224             rhs, prec = other._as_mpf_op(self._prec)
1225             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)
1226         return Number.__mod__(self, other)
1227 
1228     @_sympifyit('other', NotImplemented)
1229     def __rmod__(self, other):
1230         if isinstance(other, Float) and global_evaluate[0]:
1231             return other.__mod__(self)
1232         if isinstance(other, Number) and global_evaluate[0]:
1233             rhs, prec = other._as_mpf_op(self._prec)
1234             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)
1235         return Number.__rmod__(self, other)
1236 
1237     def _eval_power(self, expt):
1238         """
1239         expt is symbolic object but not equal to 0, 1
1240 
1241         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->
1242                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)
1243         """
1244         if self == 0:
1245             if expt.is_positive:
1246                 return S.Zero
1247             if expt.is_negative:
1248                 return S.Infinity
1249         if isinstance(expt, Number):
1250             if isinstance(expt, Integer):
1251                 prec = self._prec
1252                 return Float._new(
1253                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)
1254             elif isinstance(expt, Rational) and \
1255                     expt.p == 1 and expt.q % 2 and self.is_negative:
1256                 return Pow(S.NegativeOne, expt, evaluate=False)*(
1257                     -self)._eval_power(expt)
1258             expt, prec = expt._as_mpf_op(self._prec)
1259             mpfself = self._mpf_
1260             try:
1261                 y = mpf_pow(mpfself, expt, prec, rnd)
1262                 return Float._new(y, prec)
1263             except mlib.ComplexResult:
1264                 re, im = mlib.mpc_pow(
1265                     (mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)
1266                 return Float._new(re, prec) + \
1267                     Float._new(im, prec)*S.ImaginaryUnit
1268 
1269     def __abs__(self):
1270         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)
1271 
1272     def __int__(self):
1273         if self._mpf_ == _mpf_zero:
1274             return 0
1275         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down
1276 
1277     __long__ = __int__
1278 
1279     def __eq__(self, other):
1280         if isinstance(other, float):
1281             # coerce to Float at same precision
1282             o = Float(other)
1283             try:
1284                 ompf = o._as_mpf_val(self._prec)
1285             except ValueError:
1286                 return False
1287             return bool(mlib.mpf_eq(self._mpf_, ompf))
1288         try:
1289             other = _sympify(other)
1290         except SympifyError:
1291             return NotImplemented
1292         if other.is_NumberSymbol:
1293             if other.is_irrational:
1294                 return False
1295             return other.__eq__(self)
1296         if other.is_Float:
1297             return bool(mlib.mpf_eq(self._mpf_, other._mpf_))
1298         if other.is_Number:
1299             # numbers should compare at the same precision;
1300             # all _as_mpf_val routines should be sure to abide
1301             # by the request to change the prec if necessary; if
1302             # they don't, the equality test will fail since it compares
1303             # the mpf tuples
1304             ompf = other._as_mpf_val(self._prec)
1305             return bool(mlib.mpf_eq(self._mpf_, ompf))
1306         return False    # Float != non-Number
1307 
1308     def __ne__(self, other):
1309         return not self == other
1310 
1311     def __gt__(self, other):
1312         try:
1313             other = _sympify(other)
1314         except SympifyError:
1315             raise TypeError("Invalid comparison %s > %s" % (self, other))
1316         if other.is_NumberSymbol:
1317             return other.__lt__(self)
1318         if other.is_Rational and not other.is_Integer:
1319             self *= other.q
1320             other = _sympify(other.p)
1321         elif other.is_comparable:
1322             other = other.evalf()
1323         if other.is_Number and other is not S.NaN:
1324             return _sympify(bool(
1325                 mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))
1326         return Expr.__gt__(self, other)
1327 
1328     def __ge__(self, other):
1329         try:
1330             other = _sympify(other)
1331         except SympifyError:
1332             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1333         if other.is_NumberSymbol:
1334             return other.__le__(self)
1335         if other.is_Rational and not other.is_Integer:
1336             self *= other.q
1337             other = _sympify(other.p)
1338         elif other.is_comparable:
1339             other = other.evalf()
1340         if other.is_Number and other is not S.NaN:
1341             return _sympify(bool(
1342                 mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))
1343         return Expr.__ge__(self, other)
1344 
1345     def __lt__(self, other):
1346         try:
1347             other = _sympify(other)
1348         except SympifyError:
1349             raise TypeError("Invalid comparison %s < %s" % (self, other))
1350         if other.is_NumberSymbol:
1351             return other.__gt__(self)
1352         if other.is_Rational and not other.is_Integer:
1353             self *= other.q
1354             other = _sympify(other.p)
1355         elif other.is_comparable:
1356             other = other.evalf()
1357         if other.is_Number and other is not S.NaN:
1358             return _sympify(bool(
1359                 mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))
1360         return Expr.__lt__(self, other)
1361 
1362     def __le__(self, other):
1363         try:
1364             other = _sympify(other)
1365         except SympifyError:
1366             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1367         if other.is_NumberSymbol:
1368             return other.__ge__(self)
1369         if other.is_Rational and not other.is_Integer:
1370             self *= other.q
1371             other = _sympify(other.p)
1372         elif other.is_comparable:
1373             other = other.evalf()
1374         if other.is_Number and other is not S.NaN:
1375             return _sympify(bool(
1376                 mlib.mpf_le(self._mpf_, other._as_mpf_val(self._prec))))
1377         return Expr.__le__(self, other)
1378 
1379     def __hash__(self):
1380         return super(Float, self).__hash__()
1381 
1382     def epsilon_eq(self, other, epsilon="1e-15"):
1383         return abs(self - other) < Float(epsilon)
1384 
1385     def _sage_(self):
1386         import sage.all as sage
1387         return sage.RealNumber(str(self))
1388 
1389     def __format__(self, format_spec):
1390         return format(decimal.Decimal(str(self)), format_spec)
1391 
1392 
1393 # Add sympify converters
1394 converter[float] = converter[decimal.Decimal] = Float
1395 
1396 # this is here to work nicely in Sage
1397 RealNumber = Float
1398 
1399 
1400 class Rational(Number):
1401     """Represents rational numbers (p/q) of any size.
1402 
1403     Examples
1404     ========
1405 
1406     >>> from sympy import Rational, nsimplify, S, pi
1407     >>> Rational(1, 2)
1408     1/2
1409 
1410     Rational is unprejudiced in accepting input. If a float is passed, the
1411     underlying value of the binary representation will be returned:
1412 
1413     >>> Rational(.5)
1414     1/2
1415     >>> Rational(.2)
1416     3602879701896397/18014398509481984
1417 
1418     If the simpler representation of the float is desired then consider
1419     limiting the denominator to the desired value or convert the float to
1420     a string (which is roughly equivalent to limiting the denominator to
1421     10**12):
1422 
1423     >>> Rational(str(.2))
1424     1/5
1425     >>> Rational(.2).limit_denominator(10**12)
1426     1/5
1427 
1428     An arbitrarily precise Rational is obtained when a string literal is
1429     passed:
1430 
1431     >>> Rational("1.23")
1432     123/100
1433     >>> Rational('1e-2')
1434     1/100
1435     >>> Rational(".1")
1436     1/10
1437     >>> Rational('1e-2/3.2')
1438     1/320
1439 
1440     The conversion of other types of strings can be handled by
1441     the sympify() function, and conversion of floats to expressions
1442     or simple fractions can be handled with nsimplify:
1443 
1444     >>> S('.[3]')  # repeating digits in brackets
1445     1/3
1446     >>> S('3**2/10')  # general expressions
1447     9/10
1448     >>> nsimplify(.3)  # numbers that have a simple form
1449     3/10
1450 
1451     But if the input does not reduce to a literal Rational, an error will
1452     be raised:
1453 
1454     >>> Rational(pi)
1455     Traceback (most recent call last):
1456     ...
1457     TypeError: invalid input: pi
1458 
1459 
1460     Low-level
1461     ---------
1462 
1463     Access numerator and denominator as .p and .q:
1464 
1465     >>> r = Rational(3, 4)
1466     >>> r
1467     3/4
1468     >>> r.p
1469     3
1470     >>> r.q
1471     4
1472 
1473     Note that p and q return integers (not SymPy Integers) so some care
1474     is needed when using them in expressions:
1475 
1476     >>> r.p/r.q
1477     0.75
1478 
1479     See Also
1480     ========
1481     sympify, sympy.simplify.simplify.nsimplify
1482     """
1483     is_real = True
1484     is_integer = False
1485     is_rational = True
1486     is_number = True
1487 
1488     __slots__ = ['p', 'q']
1489 
1490     is_Rational = True
1491 
1492     @cacheit
1493     def __new__(cls, p, q=None, gcd=None):
1494         if q is None:
1495             if isinstance(p, Rational):
1496                 return p
1497 
1498             if isinstance(p, SYMPY_INTS):
1499                 pass
1500             else:
1501                 if isinstance(p, (float, Float)):
1502                     return Rational(*_as_integer_ratio(p))
1503 
1504                 if not isinstance(p, string_types):
1505                     try:
1506                         p = sympify(p)
1507                     except (SympifyError, SyntaxError):
1508                         pass  # error will raise below
1509                 else:
1510                     if p.count('/') > 1:
1511                         raise TypeError('invalid input: %s' % p)
1512                     p = p.replace(' ', '')
1513                     pq = p.rsplit('/', 1)
1514                     if len(pq) == 2:
1515                         p, q = pq
1516                         fp = fractions.Fraction(p)
1517                         fq = fractions.Fraction(q)
1518                         p = fp/fq
1519                     try:
1520                         p = fractions.Fraction(p)
1521                     except ValueError:
1522                         pass  # error will raise below
1523                     else:
1524                         return Rational(p.numerator, p.denominator, 1)
1525 
1526                 if not isinstance(p, Rational):
1527                     raise TypeError('invalid input: %s' % p)
1528 
1529             q = 1
1530             gcd = 1
1531         else:
1532             p = Rational(p)
1533             q = Rational(q)
1534 
1535         if isinstance(q, Rational):
1536             p *= q.q
1537             q = q.p
1538         if isinstance(p, Rational):
1539             q *= p.q
1540             p = p.p
1541 
1542         # p and q are now integers
1543         if q == 0:
1544             if p == 0:
1545                 if _errdict["divide"]:
1546                     raise ValueError("Indeterminate 0/0")
1547                 else:
1548                     return S.NaN
1549             return S.ComplexInfinity
1550         if q < 0:
1551             q = -q
1552             p = -p
1553         if not gcd:
1554             gcd = igcd(abs(p), q)
1555         if gcd > 1:
1556             p //= gcd
1557             q //= gcd
1558         if q == 1:
1559             return Integer(p)
1560         if p == 1 and q == 2:
1561             return S.Half
1562         obj = Expr.__new__(cls)
1563         obj.p = p
1564         obj.q = q
1565         return obj
1566 
1567     def limit_denominator(self, max_denominator=1000000):
1568         """Closest Rational to self with denominator at most max_denominator.
1569 
1570         >>> from sympy import Rational
1571         >>> Rational('3.141592653589793').limit_denominator(10)
1572         22/7
1573         >>> Rational('3.141592653589793').limit_denominator(100)
1574         311/99
1575 
1576         """
1577         f = fractions.Fraction(self.p, self.q)
1578         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))
1579 
1580     def __getnewargs__(self):
1581         return (self.p, self.q)
1582 
1583     def _hashable_content(self):
1584         return (self.p, self.q)
1585 
1586     def _eval_is_positive(self):
1587         return self.p > 0
1588 
1589     def _eval_is_zero(self):
1590         return self.p == 0
1591 
1592     def __neg__(self):
1593         return Rational(-self.p, self.q)
1594 
1595     @_sympifyit('other', NotImplemented)
1596     def __add__(self, other):
1597         if global_evaluate[0]:
1598             if isinstance(other, Integer):
1599                 return Rational(self.p + self.q*other.p, self.q, 1)
1600             elif isinstance(other, Rational):
1601                 #TODO: this can probably be optimized more
1602                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)
1603             elif isinstance(other, Float):
1604                 return other + self
1605             else:
1606                 return Number.__add__(self, other)
1607         return Number.__add__(self, other)
1608     __radd__ = __add__
1609 
1610     @_sympifyit('other', NotImplemented)
1611     def __sub__(self, other):
1612         if global_evaluate[0]:
1613             if isinstance(other, Integer):
1614                 return Rational(self.p - self.q*other.p, self.q, 1)
1615             elif isinstance(other, Rational):
1616                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)
1617             elif isinstance(other, Float):
1618                 return -other + self
1619             else:
1620                 return Number.__sub__(self, other)
1621         return Number.__sub__(self, other)
1622     @_sympifyit('other', NotImplemented)
1623     def __rsub__(self, other):
1624         if global_evaluate[0]:
1625             if isinstance(other, Integer):
1626                 return Rational(self.q*other.p - self.p, self.q, 1)
1627             elif isinstance(other, Rational):
1628                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)
1629             elif isinstance(other, Float):
1630                 return -self + other
1631             else:
1632                 return Number.__rsub__(self, other)
1633         return Number.__rsub__(self, other)
1634     @_sympifyit('other', NotImplemented)
1635     def __mul__(self, other):
1636         if global_evaluate[0]:
1637             if isinstance(other, Integer):
1638                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))
1639             elif isinstance(other, Rational):
1640                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))
1641             elif isinstance(other, Float):
1642                 return other*self
1643             else:
1644                 return Number.__mul__(self, other)
1645         return Number.__mul__(self, other)
1646     __rmul__ = __mul__
1647 
1648     @_sympifyit('other', NotImplemented)
1649     def __div__(self, other):
1650         if global_evaluate[0]:
1651             if isinstance(other, Integer):
1652                 if self.p and other.p == S.Zero:
1653                     return S.ComplexInfinity
1654                 else:
1655                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))
1656             elif isinstance(other, Rational):
1657                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1658             elif isinstance(other, Float):
1659                 return self*(1/other)
1660             else:
1661                 return Number.__div__(self, other)
1662         return Number.__div__(self, other)
1663     @_sympifyit('other', NotImplemented)
1664     def __rdiv__(self, other):
1665         if global_evaluate[0]:
1666             if isinstance(other, Integer):
1667                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))
1668             elif isinstance(other, Rational):
1669                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))
1670             elif isinstance(other, Float):
1671                 return other*(1/self)
1672             else:
1673                 return Number.__rdiv__(self, other)
1674         return Number.__rdiv__(self, other)
1675     __truediv__ = __div__
1676 
1677     @_sympifyit('other', NotImplemented)
1678     def __mod__(self, other):
1679         if global_evaluate[0]:
1680             if isinstance(other, Rational):
1681                 n = (self.p*other.q) // (other.p*self.q)
1682                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)
1683             if isinstance(other, Float):
1684                 # calculate mod with Rationals, *then* round the answer
1685                 return Float(self.__mod__(Rational(other)),
1686                              precision=other._prec)
1687             return Number.__mod__(self, other)
1688         return Number.__mod__(self, other)
1689 
1690     @_sympifyit('other', NotImplemented)
1691     def __rmod__(self, other):
1692         if isinstance(other, Rational):
1693             return Rational.__mod__(other, self)
1694         return Number.__rmod__(self, other)
1695 
1696     def _eval_power(self, expt):
1697         if isinstance(expt, Number):
1698             if isinstance(expt, Float):
1699                 return self._eval_evalf(expt._prec)**expt
1700             if expt.is_negative:
1701                 # (3/4)**-2 -> (4/3)**2
1702                 ne = -expt
1703                 if (ne is S.One):
1704                     return Rational(self.q, self.p)
1705                 if self.is_negative:
1706                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne
1707                 else:
1708                     return Rational(self.q, self.p)**ne
1709             if expt is S.Infinity:  # -oo already caught by test for negative
1710                 if self.p > self.q:
1711                     # (3/2)**oo -> oo
1712                     return S.Infinity
1713                 if self.p < -self.q:
1714                     # (-3/2)**oo -> oo + I*oo
1715                     return S.Infinity + S.Infinity*S.ImaginaryUnit
1716                 return S.Zero
1717             if isinstance(expt, Integer):
1718                 # (4/3)**2 -> 4**2 / 3**2
1719                 return Rational(self.p**expt.p, self.q**expt.p, 1)
1720             if isinstance(expt, Rational):
1721                 if self.p != 1:
1722                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)
1723                     return Integer(self.p)**expt*Integer(self.q)**(-expt)
1724                 # as the above caught negative self.p, now self is positive
1725                 return Integer(self.q)**Rational(
1726                 expt.p*(expt.q - 1), expt.q) / \
1727                     Integer(self.q)**Integer(expt.p)
1728 
1729         if self.is_negative and expt.is_even:
1730             return (-self)**expt
1731 
1732         return
1733 
1734     def _as_mpf_val(self, prec):
1735         return mlib.from_rational(self.p, self.q, prec, rnd)
1736 
1737     def _mpmath_(self, prec, rnd):
1738         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))
1739 
1740     def __abs__(self):
1741         return Rational(abs(self.p), self.q)
1742 
1743     def __int__(self):
1744         p, q = self.p, self.q
1745         if p < 0:
1746             return -int(-p//q)
1747         return int(p//q)
1748 
1749     __long__ = __int__
1750 
1751     def floor(self):
1752         return Integer(self.p // self.q)
1753 
1754     def ceiling(self):
1755         return -Integer(-self.p // self.q)
1756 
1757     def __floor__(self):
1758         return self.floor()
1759 
1760     def __ceil__(self):
1761         return self.ceiling()
1762 
1763     def __eq__(self, other):
1764         try:
1765             other = _sympify(other)
1766         except SympifyError:
1767             return NotImplemented
1768         if other.is_NumberSymbol:
1769             if other.is_irrational:
1770                 return False
1771             return other.__eq__(self)
1772         if other.is_Number:
1773             if other.is_Rational:
1774                 # a Rational is always in reduced form so will never be 2/4
1775                 # so we can just check equivalence of args
1776                 return self.p == other.p and self.q == other.q
1777             if other.is_Float:
1778                 return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)
1779         return False
1780 
1781     def __ne__(self, other):
1782         return not self == other
1783 
1784     def __gt__(self, other):
1785         try:
1786             other = _sympify(other)
1787         except SympifyError:
1788             raise TypeError("Invalid comparison %s > %s" % (self, other))
1789         if other.is_NumberSymbol:
1790             return other.__lt__(self)
1791         expr = self
1792         if other.is_Number:
1793             if other.is_Rational:
1794                 return _sympify(bool(self.p*other.q > self.q*other.p))
1795             if other.is_Float:
1796                 return _sympify(bool(mlib.mpf_gt(
1797                     self._as_mpf_val(other._prec), other._mpf_)))
1798         elif other.is_number and other.is_real:
1799             expr, other = Integer(self.p), self.q*other
1800         return Expr.__gt__(expr, other)
1801 
1802     def __ge__(self, other):
1803         try:
1804             other = _sympify(other)
1805         except SympifyError:
1806             raise TypeError("Invalid comparison %s >= %s" % (self, other))
1807         if other.is_NumberSymbol:
1808             return other.__le__(self)
1809         expr = self
1810         if other.is_Number:
1811             if other.is_Rational:
1812                  return _sympify(bool(self.p*other.q >= self.q*other.p))
1813             if other.is_Float:
1814                 return _sympify(bool(mlib.mpf_ge(
1815                     self._as_mpf_val(other._prec), other._mpf_)))
1816         elif other.is_number and other.is_real:
1817             expr, other = Integer(self.p), self.q*other
1818         return Expr.__ge__(expr, other)
1819 
1820     def __lt__(self, other):
1821         try:
1822             other = _sympify(other)
1823         except SympifyError:
1824             raise TypeError("Invalid comparison %s < %s" % (self, other))
1825         if other.is_NumberSymbol:
1826             return other.__gt__(self)
1827         expr = self
1828         if other.is_Number:
1829             if other.is_Rational:
1830                 return _sympify(bool(self.p*other.q < self.q*other.p))
1831             if other.is_Float:
1832                 return _sympify(bool(mlib.mpf_lt(
1833                     self._as_mpf_val(other._prec), other._mpf_)))
1834         elif other.is_number and other.is_real:
1835             expr, other = Integer(self.p), self.q*other
1836         return Expr.__lt__(expr, other)
1837 
1838     def __le__(self, other):
1839         try:
1840             other = _sympify(other)
1841         except SympifyError:
1842             raise TypeError("Invalid comparison %s <= %s" % (self, other))
1843         expr = self
1844         if other.is_NumberSymbol:
1845             return other.__ge__(self)
1846         elif other.is_Number:
1847             if other.is_Rational:
1848                 return _sympify(bool(self.p*other.q <= self.q*other.p))
1849             if other.is_Float:
1850                 return _sympify(bool(mlib.mpf_le(
1851                     self._as_mpf_val(other._prec), other._mpf_)))
1852         elif other.is_number and other.is_real:
1853             expr, other = Integer(self.p), self.q*other
1854         return Expr.__le__(expr, other)
1855 
1856     def __hash__(self):
1857         return super(Rational, self).__hash__()
1858 
1859     def factors(self, limit=None, use_trial=True, use_rho=False,
1860                 use_pm1=False, verbose=False, visual=False):
1861         """A wrapper to factorint which return factors of self that are
1862         smaller than limit (or cheap to compute). Special methods of
1863         factoring are disabled by default so that only trial division is used.
1864         """
1865         from sympy.ntheory import factorrat
1866 
1867         return factorrat(self, limit=limit, use_trial=use_trial,
1868                       use_rho=use_rho, use_pm1=use_pm1,
1869                       verbose=verbose).copy()
1870 
1871     def numerator(self):
1872         return self.p
1873 
1874     def denominator(self):
1875         return self.q
1876 
1877     @_sympifyit('other', NotImplemented)
1878     def gcd(self, other):
1879         if isinstance(other, Rational):
1880             if other is S.Zero:
1881                 return other
1882             return Rational(
1883                 Integer(igcd(self.p, other.p)),
1884                 Integer(ilcm(self.q, other.q)))
1885         return Number.gcd(self, other)
1886 
1887     @_sympifyit('other', NotImplemented)
1888     def lcm(self, other):
1889         if isinstance(other, Rational):
1890             return Rational(
1891                 self.p // igcd(self.p, other.p) * other.p,
1892                 igcd(self.q, other.q))
1893         return Number.lcm(self, other)
1894 
1895     def as_numer_denom(self):
1896         return Integer(self.p), Integer(self.q)
1897 
1898     def _sage_(self):
1899         import sage.all as sage
1900         return sage.Integer(self.p)/sage.Integer(self.q)
1901 
1902     def as_content_primitive(self, radical=False, clear=True):
1903         """Return the tuple (R, self/R) where R is the positive Rational
1904         extracted from self.
1905 
1906         Examples
1907         ========
1908 
1909         >>> from sympy import S
1910         >>> (S(-3)/2).as_content_primitive()
1911         (3/2, -1)
1912 
1913         See docstring of Expr.as_content_primitive for more examples.
1914         """
1915 
1916         if self:
1917             if self.is_positive:
1918                 return self, S.One
1919             return -self, S.NegativeOne
1920         return S.One, self
1921 
1922     def as_coeff_Mul(self, rational=False):
1923         """Efficiently extract the coefficient of a product. """
1924         return self, S.One
1925 
1926     def as_coeff_Add(self, rational=False):
1927         """Efficiently extract the coefficient of a summation. """
1928         return self, S.Zero
1929 
1930 
1931 class Integer(Rational):
1932     """Represents integer numbers of any size.
1933 
1934     Examples
1935     ========
1936 
1937     >>> from sympy import Integer
1938     >>> Integer(3)
1939     3
1940 
1941     If a float or a rational is passed to Integer, the fractional part
1942     will be discarded; the effect is of rounding toward zero.
1943 
1944     >>> Integer(3.8)
1945     3
1946     >>> Integer(-3.8)
1947     -3
1948 
1949     A string is acceptable input if it can be parsed as an integer:
1950 
1951     >>> Integer("9" * 20)
1952     99999999999999999999
1953 
1954     It is rarely needed to explicitly instantiate an Integer, because
1955     Python integers are automatically converted to Integer when they
1956     are used in SymPy expressions.
1957     """
1958     q = 1
1959     is_integer = True
1960     is_number = True
1961 
1962     is_Integer = True
1963 
1964     __slots__ = ['p']
1965 
1966     def _as_mpf_val(self, prec):
1967         return mlib.from_int(self.p, prec, rnd)
1968 
1969     def _mpmath_(self, prec, rnd):
1970         return mpmath.make_mpf(self._as_mpf_val(prec))
1971 
1972     @cacheit
1973     def __new__(cls, i):
1974         if isinstance(i, string_types):
1975             i = i.replace(' ', '')
1976         # whereas we cannot, in general, make a Rational from an
1977         # arbitrary expression, we can make an Integer unambiguously
1978         # (except when a non-integer expression happens to round to
1979         # an integer). So we proceed by taking int() of the input and
1980         # let the int routines determine whether the expression can
1981         # be made into an int or whether an error should be raised.
1982         try:
1983             ival = int(i)
1984         except TypeError:
1985             raise TypeError(
1986                 "Argument of Integer should be of numeric type, got %s." % i)
1987         # We only work with well-behaved integer types. This converts, for
1988         # example, numpy.int32 instances.
1989         if ival == 1:
1990             return S.One
1991         if ival == -1:
1992             return S.NegativeOne
1993         if ival == 0:
1994             return S.Zero
1995         obj = Expr.__new__(cls)
1996         obj.p = ival
1997         return obj
1998 
1999     def __getnewargs__(self):
2000         return (self.p,)
2001 
2002     # Arithmetic operations are here for efficiency
2003     def __int__(self):
2004         return self.p
2005 
2006     __long__ = __int__
2007 
2008     def floor(self):
2009         return Integer(self.p)
2010 
2011     def ceiling(self):
2012         return Integer(self.p)
2013 
2014     def __floor__(self):
2015         return self.floor()
2016 
2017     def __ceil__(self):
2018         return self.ceiling()
2019 
2020     def __neg__(self):
2021         return Integer(-self.p)
2022 
2023     def __abs__(self):
2024         if self.p >= 0:
2025             return self
2026         else:
2027             return Integer(-self.p)
2028 
2029     def __divmod__(self, other):
2030         from .containers import Tuple
2031         if isinstance(other, Integer) and global_evaluate[0]:
2032             return Tuple(*(divmod(self.p, other.p)))
2033         else:
2034             return Number.__divmod__(self, other)
2035 
2036     def __rdivmod__(self, other):
2037         from .containers import Tuple
2038         if isinstance(other, integer_types) and global_evaluate[0]:
2039             return Tuple(*(divmod(other, self.p)))
2040         else:
2041             try:
2042                 other = Number(other)
2043             except TypeError:
2044                 msg = "unsupported operand type(s) for divmod(): '%s' and '%s'"
2045                 oname = type(other).__name__
2046                 sname = type(self).__name__
2047                 raise TypeError(msg % (oname, sname))
2048             return Number.__divmod__(other, self)
2049 
2050     # TODO make it decorator + bytecodehacks?
2051     def __add__(self, other):
2052         if global_evaluate[0]:
2053             if isinstance(other, integer_types):
2054                 return Integer(self.p + other)
2055             elif isinstance(other, Integer):
2056                 return Integer(self.p + other.p)
2057             elif isinstance(other, Rational):
2058                 return Rational(self.p*other.q + other.p, other.q, 1)
2059             return Rational.__add__(self, other)
2060         else:
2061             return Add(self, other)
2062 
2063     def __radd__(self, other):
2064         if global_evaluate[0]:
2065             if isinstance(other, integer_types):
2066                 return Integer(other + self.p)
2067             elif isinstance(other, Rational):
2068                 return Rational(other.p + self.p*other.q, other.q, 1)
2069             return Rational.__radd__(self, other)
2070         return Rational.__radd__(self, other)
2071 
2072     def __sub__(self, other):
2073         if global_evaluate[0]:
2074             if isinstance(other, integer_types):
2075                 return Integer(self.p - other)
2076             elif isinstance(other, Integer):
2077                 return Integer(self.p - other.p)
2078             elif isinstance(other, Rational):
2079                 return Rational(self.p*other.q - other.p, other.q, 1)
2080             return Rational.__sub__(self, other)
2081         return Rational.__sub__(self, other)
2082 
2083     def __rsub__(self, other):
2084         if global_evaluate[0]:
2085             if isinstance(other, integer_types):
2086                 return Integer(other - self.p)
2087             elif isinstance(other, Rational):
2088                 return Rational(other.p - self.p*other.q, other.q, 1)
2089             return Rational.__rsub__(self, other)
2090         return Rational.__rsub__(self, other)
2091 
2092     def __mul__(self, other):
2093         if global_evaluate[0]:
2094             if isinstance(other, integer_types):
2095                 return Integer(self.p*other)
2096             elif isinstance(other, Integer):
2097                 return Integer(self.p*other.p)
2098             elif isinstance(other, Rational):
2099                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))
2100             return Rational.__mul__(self, other)
2101         return Rational.__mul__(self, other)
2102 
2103     def __rmul__(self, other):
2104         if global_evaluate[0]:
2105             if isinstance(other, integer_types):
2106                 return Integer(other*self.p)
2107             elif isinstance(other, Rational):
2108                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))
2109             return Rational.__rmul__(self, other)
2110         return Rational.__rmul__(self, other)
2111 
2112     def __mod__(self, other):
2113         if global_evaluate[0]:
2114             if isinstance(other, integer_types):
2115                 return Integer(self.p % other)
2116             elif isinstance(other, Integer):
2117                 return Integer(self.p % other.p)
2118             return Rational.__mod__(self, other)
2119         return Rational.__mod__(self, other)
2120 
2121     def __rmod__(self, other):
2122         if global_evaluate[0]:
2123             if isinstance(other, integer_types):
2124                 return Integer(other % self.p)
2125             elif isinstance(other, Integer):
2126                 return Integer(other.p % self.p)
2127             return Rational.__rmod__(self, other)
2128         return Rational.__rmod__(self, other)
2129 
2130     def __eq__(self, other):
2131         if isinstance(other, integer_types):
2132             return (self.p == other)
2133         elif isinstance(other, Integer):
2134             return (self.p == other.p)
2135         return Rational.__eq__(self, other)
2136 
2137     def __ne__(self, other):
2138         return not self == other
2139 
2140     def __gt__(self, other):
2141         try:
2142             other = _sympify(other)
2143         except SympifyError:
2144             raise TypeError("Invalid comparison %s > %s" % (self, other))
2145         if other.is_Integer:
2146             return _sympify(self.p > other.p)
2147         return Rational.__gt__(self, other)
2148 
2149     def __lt__(self, other):
2150         try:
2151             other = _sympify(other)
2152         except SympifyError:
2153             raise TypeError("Invalid comparison %s < %s" % (self, other))
2154         if other.is_Integer:
2155             return _sympify(self.p < other.p)
2156         return Rational.__lt__(self, other)
2157 
2158     def __ge__(self, other):
2159         try:
2160             other = _sympify(other)
2161         except SympifyError:
2162             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2163         if other.is_Integer:
2164             return _sympify(self.p >= other.p)
2165         return Rational.__ge__(self, other)
2166 
2167     def __le__(self, other):
2168         try:
2169             other = _sympify(other)
2170         except SympifyError:
2171             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2172         if other.is_Integer:
2173             return _sympify(self.p <= other.p)
2174         return Rational.__le__(self, other)
2175 
2176     def __hash__(self):
2177         return hash(self.p)
2178 
2179     def __index__(self):
2180         return self.p
2181 
2182     ########################################
2183 
2184     def _eval_is_odd(self):
2185         return bool(self.p % 2)
2186 
2187     def _eval_power(self, expt):
2188         """
2189         Tries to do some simplifications on self**expt
2190 
2191         Returns None if no further simplifications can be done
2192 
2193         When exponent is a fraction (so we have for example a square root),
2194         we try to find a simpler representation by factoring the argument
2195         up to factors of 2**15, e.g.
2196 
2197           - sqrt(4) becomes 2
2198           - sqrt(-4) becomes 2*I
2199           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)
2200 
2201         Further simplification would require a special call to factorint on
2202         the argument which is not done here for sake of speed.
2203 
2204         """
2205         from sympy import perfect_power
2206 
2207         if expt is S.Infinity:
2208             if self.p > S.One:
2209                 return S.Infinity
2210             # cases -1, 0, 1 are done in their respective classes
2211             return S.Infinity + S.ImaginaryUnit*S.Infinity
2212         if expt is S.NegativeInfinity:
2213             return Rational(1, self)**S.Infinity
2214         if not isinstance(expt, Number):
2215             # simplify when expt is even
2216             # (-2)**k --> 2**k
2217             if self.is_negative and expt.is_even:
2218                 return (-self)**expt
2219         if isinstance(expt, Float):
2220             # Rational knows how to exponentiate by a Float
2221             return super(Integer, self)._eval_power(expt)
2222         if not isinstance(expt, Rational):
2223             return
2224         if expt is S.Half and self.is_negative:
2225             # we extract I for this special case since everyone is doing so
2226             return S.ImaginaryUnit*Pow(-self, expt)
2227         if expt.is_negative:
2228             # invert base and change sign on exponent
2229             ne = -expt
2230             if self.is_negative:
2231                     return S.NegativeOne**expt*Rational(1, -self)**ne
2232             else:
2233                 return Rational(1, self.p)**ne
2234         # see if base is a perfect root, sqrt(4) --> 2
2235         x, xexact = integer_nthroot(abs(self.p), expt.q)
2236         if xexact:
2237             # if it's a perfect root we've finished
2238             result = Integer(x**abs(expt.p))
2239             if self.is_negative:
2240                 result *= S.NegativeOne**expt
2241             return result
2242 
2243         # The following is an algorithm where we collect perfect roots
2244         # from the factors of base.
2245 
2246         # if it's not an nth root, it still might be a perfect power
2247         b_pos = int(abs(self.p))
2248         p = perfect_power(b_pos)
2249         if p is not False:
2250             dict = {p[0]: p[1]}
2251         else:
2252             dict = Integer(b_pos).factors(limit=2**15)
2253 
2254         # now process the dict of factors
2255         out_int = 1  # integer part
2256         out_rad = 1  # extracted radicals
2257         sqr_int = 1
2258         sqr_gcd = 0
2259         sqr_dict = {}
2260         for prime, exponent in dict.items():
2261             exponent *= expt.p
2262             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)
2263             div_e, div_m = divmod(exponent, expt.q)
2264             if div_e > 0:
2265                 out_int *= prime**div_e
2266             if div_m > 0:
2267                 # see if the reduced exponent shares a gcd with e.q
2268                 # (2**2)**(1/10) -> 2**(1/5)
2269                 g = igcd(div_m, expt.q)
2270                 if g != 1:
2271                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))
2272                 else:
2273                     sqr_dict[prime] = div_m
2274         # identify gcd of remaining powers
2275         for p, ex in sqr_dict.items():
2276             if sqr_gcd == 0:
2277                 sqr_gcd = ex
2278             else:
2279                 sqr_gcd = igcd(sqr_gcd, ex)
2280                 if sqr_gcd == 1:
2281                     break
2282         for k, v in sqr_dict.items():
2283             sqr_int *= k**(v//sqr_gcd)
2284         if sqr_int == b_pos and out_int == 1 and out_rad == 1:
2285             result = None
2286         else:
2287             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))
2288             if self.is_negative:
2289                 result *= Pow(S.NegativeOne, expt)
2290         return result
2291 
2292     def _eval_is_prime(self):
2293         from sympy.ntheory import isprime
2294 
2295         return isprime(self)
2296 
2297     def _eval_is_composite(self):
2298         if self > 1:
2299             return fuzzy_not(self.is_prime)
2300         else:
2301             return False
2302 
2303     def as_numer_denom(self):
2304         return self, S.One
2305 
2306     def __floordiv__(self, other):
2307         return Integer(self.p // Integer(other).p)
2308 
2309     def __rfloordiv__(self, other):
2310         return Integer(Integer(other).p // self.p)
2311 
2312 # Add sympify converters
2313 for i_type in integer_types:
2314     converter[i_type] = Integer
2315 
2316 
2317 class AlgebraicNumber(Expr):
2318     """Class for representing algebraic numbers in SymPy. """
2319 
2320     __slots__ = ['rep', 'root', 'alias', 'minpoly']
2321 
2322     is_AlgebraicNumber = True
2323     is_algebraic = True
2324     is_number = True
2325 
2326     def __new__(cls, expr, coeffs=None, alias=None, **args):
2327         """Construct a new algebraic number. """
2328         from sympy import Poly
2329         from sympy.polys.polyclasses import ANP, DMP
2330         from sympy.polys.numberfields import minimal_polynomial
2331         from sympy.core.symbol import Symbol
2332 
2333         expr = sympify(expr)
2334 
2335         if isinstance(expr, (tuple, Tuple)):
2336             minpoly, root = expr
2337 
2338             if not minpoly.is_Poly:
2339                 minpoly = Poly(minpoly)
2340         elif expr.is_AlgebraicNumber:
2341             minpoly, root = expr.minpoly, expr.root
2342         else:
2343             minpoly, root = minimal_polynomial(
2344                 expr, args.get('gen'), polys=True), expr
2345 
2346         dom = minpoly.get_domain()
2347 
2348         if coeffs is not None:
2349             if not isinstance(coeffs, ANP):
2350                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)
2351                 scoeffs = Tuple(*coeffs)
2352             else:
2353                 rep = DMP.from_list(coeffs.to_list(), 0, dom)
2354                 scoeffs = Tuple(*coeffs.to_list())
2355 
2356             if rep.degree() >= minpoly.degree():
2357                 rep = rep.rem(minpoly.rep)
2358 
2359         else:
2360             rep = DMP.from_list([1, 0], 0, dom)
2361             scoeffs = Tuple(1, 0)
2362 
2363         sargs = (root, scoeffs)
2364 
2365         if alias is not None:
2366             if not isinstance(alias, Symbol):
2367                 alias = Symbol(alias)
2368             sargs = sargs + (alias,)
2369 
2370         obj = Expr.__new__(cls, *sargs)
2371 
2372         obj.rep = rep
2373         obj.root = root
2374         obj.alias = alias
2375         obj.minpoly = minpoly
2376 
2377         return obj
2378 
2379     def __hash__(self):
2380         return super(AlgebraicNumber, self).__hash__()
2381 
2382     def _eval_evalf(self, prec):
2383         return self.as_expr()._evalf(prec)
2384 
2385     @property
2386     def is_aliased(self):
2387         """Returns ``True`` if ``alias`` was set. """
2388         return self.alias is not None
2389 
2390     def as_poly(self, x=None):
2391         """Create a Poly instance from ``self``. """
2392         from sympy import Dummy, Poly, PurePoly
2393         if x is not None:
2394             return Poly.new(self.rep, x)
2395         else:
2396             if self.alias is not None:
2397                 return Poly.new(self.rep, self.alias)
2398             else:
2399                 return PurePoly.new(self.rep, Dummy('x'))
2400 
2401     def as_expr(self, x=None):
2402         """Create a Basic expression from ``self``. """
2403         return self.as_poly(x or self.root).as_expr().expand()
2404 
2405     def coeffs(self):
2406         """Returns all SymPy coefficients of an algebraic number. """
2407         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]
2408 
2409     def native_coeffs(self):
2410         """Returns all native coefficients of an algebraic number. """
2411         return self.rep.all_coeffs()
2412 
2413     def to_algebraic_integer(self):
2414         """Convert ``self`` to an algebraic integer. """
2415         from sympy import Poly
2416         f = self.minpoly
2417 
2418         if f.LC() == 1:
2419             return self
2420 
2421         coeff = f.LC()**(f.degree() - 1)
2422         poly = f.compose(Poly(f.gen/f.LC()))
2423 
2424         minpoly = poly*coeff
2425         root = f.LC()*self.root
2426 
2427         return AlgebraicNumber((minpoly, root), self.coeffs())
2428 
2429     def _eval_simplify(self, ratio, measure, rational, inverse):
2430         from sympy.polys import CRootOf, minpoly
2431 
2432         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:
2433             if minpoly(self.root - r).is_Symbol:
2434                 # use the matching root if it's simpler
2435                 if measure(r) < ratio*measure(self.root):
2436                     return AlgebraicNumber(r)
2437         return self
2438 
2439 
2440 class RationalConstant(Rational):
2441     """
2442     Abstract base class for rationals with specific behaviors
2443 
2444     Derived classes must define class attributes p and q and should probably all
2445     be singletons.
2446     """
2447     __slots__ = []
2448 
2449     def __new__(cls):
2450         return AtomicExpr.__new__(cls)
2451 
2452 
2453 class IntegerConstant(Integer):
2454     __slots__ = []
2455 
2456     def __new__(cls):
2457         return AtomicExpr.__new__(cls)
2458 
2459 
2460 class Zero(with_metaclass(Singleton, IntegerConstant)):
2461     """The number zero.
2462 
2463     Zero is a singleton, and can be accessed by ``S.Zero``
2464 
2465     Examples
2466     ========
2467 
2468     >>> from sympy import S, Integer, zoo
2469     >>> Integer(0) is S.Zero
2470     True
2471     >>> 1/S.Zero
2472     zoo
2473 
2474     References
2475     ==========
2476 
2477     .. [1] https://en.wikipedia.org/wiki/Zero
2478     """
2479 
2480     p = 0
2481     q = 1
2482     is_positive = False
2483     is_negative = False
2484     is_zero = True
2485     is_number = True
2486 
2487     __slots__ = []
2488 
2489     @staticmethod
2490     def __abs__():
2491         return S.Zero
2492 
2493     @staticmethod
2494     def __neg__():
2495         return S.Zero
2496 
2497     def _eval_power(self, expt):
2498         if expt.is_positive:
2499             return self
2500         if expt.is_negative:
2501             return S.ComplexInfinity
2502         if expt.is_real is False:
2503             return S.NaN
2504         # infinities are already handled with pos and neg
2505         # tests above; now throw away leading numbers on Mul
2506         # exponent
2507         coeff, terms = expt.as_coeff_Mul()
2508         if coeff.is_negative:
2509             return S.ComplexInfinity**terms
2510         if coeff is not S.One:  # there is a Number to discard
2511             return self**terms
2512 
2513     def _eval_order(self, *symbols):
2514         # Order(0,x) -> 0
2515         return self
2516 
2517     def __nonzero__(self):
2518         return False
2519 
2520     __bool__ = __nonzero__
2521 
2522     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted
2523         """Efficiently extract the coefficient of a summation. """
2524         return S.One, self
2525 
2526 
2527 class One(with_metaclass(Singleton, IntegerConstant)):
2528     """The number one.
2529 
2530     One is a singleton, and can be accessed by ``S.One``.
2531 
2532     Examples
2533     ========
2534 
2535     >>> from sympy import S, Integer
2536     >>> Integer(1) is S.One
2537     True
2538 
2539     References
2540     ==========
2541 
2542     .. [1] https://en.wikipedia.org/wiki/1_%28number%29
2543     """
2544     is_number = True
2545 
2546     p = 1
2547     q = 1
2548 
2549     __slots__ = []
2550 
2551     @staticmethod
2552     def __abs__():
2553         return S.One
2554 
2555     @staticmethod
2556     def __neg__():
2557         return S.NegativeOne
2558 
2559     def _eval_power(self, expt):
2560         return self
2561 
2562     def _eval_order(self, *symbols):
2563         return
2564 
2565     @staticmethod
2566     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,
2567                 verbose=False, visual=False):
2568         if visual:
2569             return S.One
2570         else:
2571             return {}
2572 
2573 
2574 class NegativeOne(with_metaclass(Singleton, IntegerConstant)):
2575     """The number negative one.
2576 
2577     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.
2578 
2579     Examples
2580     ========
2581 
2582     >>> from sympy import S, Integer
2583     >>> Integer(-1) is S.NegativeOne
2584     True
2585 
2586     See Also
2587     ========
2588 
2589     One
2590 
2591     References
2592     ==========
2593 
2594     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29
2595 
2596     """
2597     is_number = True
2598 
2599     p = -1
2600     q = 1
2601 
2602     __slots__ = []
2603 
2604     @staticmethod
2605     def __abs__():
2606         return S.One
2607 
2608     @staticmethod
2609     def __neg__():
2610         return S.One
2611 
2612     def _eval_power(self, expt):
2613         if expt.is_odd:
2614             return S.NegativeOne
2615         if expt.is_even:
2616             return S.One
2617         if isinstance(expt, Number):
2618             if isinstance(expt, Float):
2619                 return Float(-1.0)**expt
2620             if expt is S.NaN:
2621                 return S.NaN
2622             if expt is S.Infinity or expt is S.NegativeInfinity:
2623                 return S.NaN
2624             if expt is S.Half:
2625                 return S.ImaginaryUnit
2626             if isinstance(expt, Rational):
2627                 if expt.q == 2:
2628                     return S.ImaginaryUnit**Integer(expt.p)
2629                 i, r = divmod(expt.p, expt.q)
2630                 if i:
2631                     return self**i*self**Rational(r, expt.q)
2632         return
2633 
2634 
2635 class Half(with_metaclass(Singleton, RationalConstant)):
2636     """The rational number 1/2.
2637 
2638     Half is a singleton, and can be accessed by ``S.Half``.
2639 
2640     Examples
2641     ========
2642 
2643     >>> from sympy import S, Rational
2644     >>> Rational(1, 2) is S.Half
2645     True
2646 
2647     References
2648     ==========
2649 
2650     .. [1] https://en.wikipedia.org/wiki/One_half
2651     """
2652     is_number = True
2653 
2654     p = 1
2655     q = 2
2656 
2657     __slots__ = []
2658 
2659     @staticmethod
2660     def __abs__():
2661         return S.Half
2662 
2663 
2664 class Infinity(with_metaclass(Singleton, Number)):
2665     r"""Positive infinite quantity.
2666 
2667     In real analysis the symbol `\infty` denotes an unbounded
2668     limit: `x\to\infty` means that `x` grows without bound.
2669 
2670     Infinity is often used not only to define a limit but as a value
2671     in the affinely extended real number system.  Points labeled `+\infty`
2672     and `-\infty` can be added to the topological space of the real numbers,
2673     producing the two-point compactification of the real numbers.  Adding
2674     algebraic properties to this gives us the extended real numbers.
2675 
2676     Infinity is a singleton, and can be accessed by ``S.Infinity``,
2677     or can be imported as ``oo``.
2678 
2679     Examples
2680     ========
2681 
2682     >>> from sympy import oo, exp, limit, Symbol
2683     >>> 1 + oo
2684     oo
2685     >>> 42/oo
2686     0
2687     >>> x = Symbol('x')
2688     >>> limit(exp(x), x, oo)
2689     oo
2690 
2691     See Also
2692     ========
2693 
2694     NegativeInfinity, NaN
2695 
2696     References
2697     ==========
2698 
2699     .. [1] https://en.wikipedia.org/wiki/Infinity
2700     """
2701 
2702     is_commutative = True
2703     is_positive = True
2704     is_infinite = True
2705     is_number = True
2706     is_prime = False
2707 
2708     __slots__ = []
2709 
2710     def __new__(cls):
2711         return AtomicExpr.__new__(cls)
2712 
2713     def _latex(self, printer):
2714         return r"\infty"
2715 
2716     def _eval_subs(self, old, new):
2717         if self == old:
2718             return new
2719 
2720     @_sympifyit('other', NotImplemented)
2721     def __add__(self, other):
2722         if isinstance(other, Number):
2723             if other is S.NegativeInfinity or other is S.NaN:
2724                 return S.NaN
2725             return self
2726         return NotImplemented
2727     __radd__ = __add__
2728 
2729     @_sympifyit('other', NotImplemented)
2730     def __sub__(self, other):
2731         if isinstance(other, Number):
2732             if other is S.Infinity or other is S.NaN:
2733                 return S.NaN
2734             return self
2735         return NotImplemented
2736 
2737     @_sympifyit('other', NotImplemented)
2738     def __rsub__(self, other):
2739         return (-self).__add__(other)
2740 
2741     @_sympifyit('other', NotImplemented)
2742     def __mul__(self, other):
2743         if isinstance(other, Number):
2744             if other.is_zero or other is S.NaN:
2745                 return S.NaN
2746             if other.is_positive:
2747                 return self
2748             return S.NegativeInfinity
2749         return NotImplemented
2750     __rmul__ = __mul__
2751 
2752     @_sympifyit('other', NotImplemented)
2753     def __div__(self, other):
2754         if isinstance(other, Number):
2755             if other is S.Infinity or \
2756                 other is S.NegativeInfinity or \
2757                     other is S.NaN:
2758                 return S.NaN
2759             if other.is_nonnegative:
2760                 return self
2761             return S.NegativeInfinity
2762         return NotImplemented
2763 
2764     __truediv__ = __div__
2765 
2766     def __abs__(self):
2767         return S.Infinity
2768 
2769     def __neg__(self):
2770         return S.NegativeInfinity
2771 
2772     def _eval_power(self, expt):
2773         """
2774         ``expt`` is symbolic object but not equal to 0 or 1.
2775 
2776         ================ ======= ==============================
2777         Expression       Result  Notes
2778         ================ ======= ==============================
2779         ``oo ** nan``    ``nan``
2780         ``oo ** -p``     ``0``   ``p`` is number, ``oo``
2781         ================ ======= ==============================
2782 
2783         See Also
2784         ========
2785         Pow
2786         NaN
2787         NegativeInfinity
2788 
2789         """
2790         from sympy.functions import re
2791 
2792         if expt.is_positive:
2793             return S.Infinity
2794         if expt.is_negative:
2795             return S.Zero
2796         if expt is S.NaN:
2797             return S.NaN
2798         if expt is S.ComplexInfinity:
2799             return S.NaN
2800         if expt.is_real is False and expt.is_number:
2801             expt_real = re(expt)
2802             if expt_real.is_positive:
2803                 return S.ComplexInfinity
2804             if expt_real.is_negative:
2805                 return S.Zero
2806             if expt_real.is_zero:
2807                 return S.NaN
2808 
2809             return self**expt.evalf()
2810 
2811     def _as_mpf_val(self, prec):
2812         return mlib.finf
2813 
2814     def _sage_(self):
2815         import sage.all as sage
2816         return sage.oo
2817 
2818     def __hash__(self):
2819         return super(Infinity, self).__hash__()
2820 
2821     def __eq__(self, other):
2822         return other is S.Infinity or other == float('inf')
2823 
2824     def __ne__(self, other):
2825         return other is not S.Infinity and other != float('inf')
2826 
2827     def __lt__(self, other):
2828         try:
2829             other = _sympify(other)
2830         except SympifyError:
2831             raise TypeError("Invalid comparison %s < %s" % (self, other))
2832         if other.is_real:
2833             return S.false
2834         return Expr.__lt__(self, other)
2835 
2836     def __le__(self, other):
2837         try:
2838             other = _sympify(other)
2839         except SympifyError:
2840             raise TypeError("Invalid comparison %s <= %s" % (self, other))
2841         if other.is_real:
2842             if other.is_finite or other is S.NegativeInfinity:
2843                 return S.false
2844             elif other.is_nonpositive:
2845                 return S.false
2846             elif other.is_infinite and other.is_positive:
2847                 return S.true
2848         return Expr.__le__(self, other)
2849 
2850     def __gt__(self, other):
2851         try:
2852             other = _sympify(other)
2853         except SympifyError:
2854             raise TypeError("Invalid comparison %s > %s" % (self, other))
2855         if other.is_real:
2856             if other.is_finite or other is S.NegativeInfinity:
2857                 return S.true
2858             elif other.is_nonpositive:
2859                 return S.true
2860             elif other.is_infinite and other.is_positive:
2861                 return S.false
2862         return Expr.__gt__(self, other)
2863 
2864     def __ge__(self, other):
2865         try:
2866             other = _sympify(other)
2867         except SympifyError:
2868             raise TypeError("Invalid comparison %s >= %s" % (self, other))
2869         if other.is_real:
2870             return S.true
2871         return Expr.__ge__(self, other)
2872 
2873     def __mod__(self, other):
2874         return S.NaN
2875 
2876     __rmod__ = __mod__
2877 
2878     def floor(self):
2879         return self
2880 
2881     def ceiling(self):
2882         return self
2883 
2884 oo = S.Infinity
2885 
2886 
2887 class NegativeInfinity(with_metaclass(Singleton, Number)):
2888     """Negative infinite quantity.
2889 
2890     NegativeInfinity is a singleton, and can be accessed
2891     by ``S.NegativeInfinity``.
2892 
2893     See Also
2894     ========
2895 
2896     Infinity
2897     """
2898 
2899     is_commutative = True
2900     is_negative = True
2901     is_infinite = True
2902     is_number = True
2903 
2904     __slots__ = []
2905 
2906     def __new__(cls):
2907         return AtomicExpr.__new__(cls)
2908 
2909     def _latex(self, printer):
2910         return r"-\infty"
2911 
2912     def _eval_subs(self, old, new):
2913         if self == old:
2914             return new
2915 
2916     @_sympifyit('other', NotImplemented)
2917     def __add__(self, other):
2918         if isinstance(other, Number):
2919             if other is S.Infinity or other is S.NaN:
2920                 return S.NaN
2921             return self
2922         return NotImplemented
2923     __radd__ = __add__
2924 
2925     @_sympifyit('other', NotImplemented)
2926     def __sub__(self, other):
2927         if isinstance(other, Number):
2928             if other is S.NegativeInfinity or other is S.NaN:
2929                 return S.NaN
2930             return self
2931         return NotImplemented
2932 
2933     @_sympifyit('other', NotImplemented)
2934     def __rsub__(self, other):
2935         return (-self).__add__(other)
2936 
2937     @_sympifyit('other', NotImplemented)
2938     def __mul__(self, other):
2939         if isinstance(other, Number):
2940             if other.is_zero or other is S.NaN:
2941                 return S.NaN
2942             if other.is_positive:
2943                 return self
2944             return S.Infinity
2945         return NotImplemented
2946     __rmul__ = __mul__
2947 
2948     @_sympifyit('other', NotImplemented)
2949     def __div__(self, other):
2950         if isinstance(other, Number):
2951             if other is S.Infinity or \
2952                 other is S.NegativeInfinity or \
2953                     other is S.NaN:
2954                 return S.NaN
2955             if other.is_nonnegative:
2956                 return self
2957             return S.Infinity
2958         return NotImplemented
2959 
2960     __truediv__ = __div__
2961 
2962     def __abs__(self):
2963         return S.Infinity
2964 
2965     def __neg__(self):
2966         return S.Infinity
2967 
2968     def _eval_power(self, expt):
2969         """
2970         ``expt`` is symbolic object but not equal to 0 or 1.
2971 
2972         ================ ======= ==============================
2973         Expression       Result  Notes
2974         ================ ======= ==============================
2975         ``(-oo) ** nan`` ``nan``
2976         ``(-oo) ** oo``  ``nan``
2977         ``(-oo) ** -oo`` ``nan``
2978         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer
2979         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer
2980         ================ ======= ==============================
2981 
2982         See Also
2983         ========
2984 
2985         Infinity
2986         Pow
2987         NaN
2988 
2989         """
2990         if expt.is_number:
2991             if expt is S.NaN or \
2992                 expt is S.Infinity or \
2993                     expt is S.NegativeInfinity:
2994                 return S.NaN
2995 
2996             if isinstance(expt, Integer) and expt.is_positive:
2997                 if expt.is_odd:
2998                     return S.NegativeInfinity
2999                 else:
3000                     return S.Infinity
3001 
3002             return S.NegativeOne**expt*S.Infinity**expt
3003 
3004     def _as_mpf_val(self, prec):
3005         return mlib.fninf
3006 
3007     def _sage_(self):
3008         import sage.all as sage
3009         return -(sage.oo)
3010 
3011     def __hash__(self):
3012         return super(NegativeInfinity, self).__hash__()
3013 
3014     def __eq__(self, other):
3015         return other is S.NegativeInfinity or other == float('-inf')
3016 
3017     def __ne__(self, other):
3018         return other is not S.NegativeInfinity and other != float('-inf')
3019 
3020     def __lt__(self, other):
3021         try:
3022             other = _sympify(other)
3023         except SympifyError:
3024             raise TypeError("Invalid comparison %s < %s" % (self, other))
3025         if other.is_real:
3026             if other.is_finite or other is S.Infinity:
3027                 return S.true
3028             elif other.is_nonnegative:
3029                 return S.true
3030             elif other.is_infinite and other.is_negative:
3031                 return S.false
3032         return Expr.__lt__(self, other)
3033 
3034     def __le__(self, other):
3035         try:
3036             other = _sympify(other)
3037         except SympifyError:
3038             raise TypeError("Invalid comparison %s <= %s" % (self, other))
3039         if other.is_real:
3040             return S.true
3041         return Expr.__le__(self, other)
3042 
3043     def __gt__(self, other):
3044         try:
3045             other = _sympify(other)
3046         except SympifyError:
3047             raise TypeError("Invalid comparison %s > %s" % (self, other))
3048         if other.is_real:
3049             return S.false
3050         return Expr.__gt__(self, other)
3051 
3052     def __ge__(self, other):
3053         try:
3054             other = _sympify(other)
3055         except SympifyError:
3056             raise TypeError("Invalid comparison %s >= %s" % (self, other))
3057         if other.is_real:
3058             if other.is_finite or other is S.Infinity:
3059                 return S.false
3060             elif other.is_nonnegative:
3061                 return S.false
3062             elif other.is_infinite and other.is_negative:
3063                 return S.true
3064         return Expr.__ge__(self, other)
3065 
3066     def __mod__(self, other):
3067         return S.NaN
3068 
3069     __rmod__ = __mod__
3070 
3071     def floor(self):
3072         return self
3073 
3074     def ceiling(self):
3075         return self
3076 
3077 
3078 class NaN(with_metaclass(Singleton, Number)):
3079     """
3080     Not a Number.
3081 
3082     This serves as a place holder for numeric values that are indeterminate.
3083     Most operations on NaN, produce another NaN.  Most indeterminate forms,
3084     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``
3085     and ``oo**0``, which all produce ``1`` (this is consistent with Python's
3086     float).
3087 
3088     NaN is loosely related to floating point nan, which is defined in the
3089     IEEE 754 floating point standard, and corresponds to the Python
3090     ``float('nan')``.  Differences are noted below.
3091 
3092     NaN is mathematically not equal to anything else, even NaN itself.  This
3093     explains the initially counter-intuitive results with ``Eq`` and ``==`` in
3094     the examples below.
3095 
3096     NaN is not comparable so inequalities raise a TypeError.  This is in
3097     constrast with floating point nan where all inequalities are false.
3098 
3099     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported
3100     as ``nan``.
3101 
3102     Examples
3103     ========
3104 
3105     >>> from sympy import nan, S, oo, Eq
3106     >>> nan is S.NaN
3107     True
3108     >>> oo - oo
3109     nan
3110     >>> nan + 1
3111     nan
3112     >>> Eq(nan, nan)   # mathematical equality
3113     False
3114     >>> nan == nan     # structural equality
3115     True
3116 
3117     References
3118     ==========
3119 
3120     .. [1] https://en.wikipedia.org/wiki/NaN
3121 
3122     """
3123     is_commutative = True
3124     is_real = None
3125     is_rational = None
3126     is_algebraic = None
3127     is_transcendental = None
3128     is_integer = None
3129     is_comparable = False
3130     is_finite = None
3131     is_zero = None
3132     is_prime = None
3133     is_positive = None
3134     is_negative = None
3135     is_number = True
3136 
3137     __slots__ = []
3138 
3139     def __new__(cls):
3140         return AtomicExpr.__new__(cls)
3141 
3142     def _latex(self, printer):
3143         return r"\text{NaN}"
3144 
3145     @_sympifyit('other', NotImplemented)
3146     def __add__(self, other):
3147         return self
3148 
3149     @_sympifyit('other', NotImplemented)
3150     def __sub__(self, other):
3151         return self
3152 
3153     @_sympifyit('other', NotImplemented)
3154     def __mul__(self, other):
3155         return self
3156 
3157     @_sympifyit('other', NotImplemented)
3158     def __div__(self, other):
3159         return self
3160 
3161     __truediv__ = __div__
3162 
3163     def floor(self):
3164         return self
3165 
3166     def ceiling(self):
3167         return self
3168 
3169     def _as_mpf_val(self, prec):
3170         return _mpf_nan
3171 
3172     def _sage_(self):
3173         import sage.all as sage
3174         return sage.NaN
3175 
3176     def __hash__(self):
3177         return super(NaN, self).__hash__()
3178 
3179     def __eq__(self, other):
3180         # NaN is structurally equal to another NaN
3181         return other is S.NaN
3182 
3183     def __ne__(self, other):
3184         return other is not S.NaN
3185 
3186     def _eval_Eq(self, other):
3187         # NaN is not mathematically equal to anything, even NaN
3188         return S.false
3189 
3190     # Expr will _sympify and raise TypeError
3191     __gt__ = Expr.__gt__
3192     __ge__ = Expr.__ge__
3193     __lt__ = Expr.__lt__
3194     __le__ = Expr.__le__
3195 
3196 nan = S.NaN
3197 
3198 
3199 class ComplexInfinity(with_metaclass(Singleton, AtomicExpr)):
3200     r"""Complex infinity.
3201 
3202     In complex analysis the symbol `\tilde\infty`, called "complex
3203     infinity", represents a quantity with infinite magnitude, but
3204     undetermined complex phase.
3205 
3206     ComplexInfinity is a singleton, and can be accessed by
3207     ``S.ComplexInfinity``, or can be imported as ``zoo``.
3208 
3209     Examples
3210     ========
3211 
3212     >>> from sympy import zoo, oo
3213     >>> zoo + 42
3214     zoo
3215     >>> 42/zoo
3216     0
3217     >>> zoo + zoo
3218     nan
3219     >>> zoo*zoo
3220     zoo
3221 
3222     See Also
3223     ========
3224 
3225     Infinity
3226     """
3227 
3228     is_commutative = True
3229     is_infinite = True
3230     is_number = True
3231     is_prime = False
3232     is_complex = True
3233     is_real = False
3234 
3235     __slots__ = []
3236 
3237     def __new__(cls):
3238         return AtomicExpr.__new__(cls)
3239 
3240     def _latex(self, printer):
3241         return r"\tilde{\infty}"
3242 
3243     @staticmethod
3244     def __abs__():
3245         return S.Infinity
3246 
3247     def floor(self):
3248         return self
3249 
3250     def ceiling(self):
3251         return self
3252 
3253     @staticmethod
3254     def __neg__():
3255         return S.ComplexInfinity
3256 
3257     def _eval_power(self, expt):
3258         if expt is S.ComplexInfinity:
3259             return S.NaN
3260 
3261         if isinstance(expt, Number):
3262             if expt is S.Zero:
3263                 return S.NaN
3264             else:
3265                 if expt.is_positive:
3266                     return S.ComplexInfinity
3267                 else:
3268                     return S.Zero
3269 
3270     def _sage_(self):
3271         import sage.all as sage
3272         return sage.UnsignedInfinityRing.gen()
3273 
3274 
3275 zoo = S.ComplexInfinity
3276 
3277 
3278 class NumberSymbol(AtomicExpr):
3279 
3280     is_commutative = True
3281     is_finite = True
3282     is_number = True
3283 
3284     __slots__ = []
3285 
3286     is_NumberSymbol = True
3287 
3288     def __new__(cls):
3289         return AtomicExpr.__new__(cls)
3290 
3291     def approximation(self, number_cls):
3292         """ Return an interval with number_cls endpoints
3293         that contains the value of NumberSymbol.
3294         If not implemented, then return None.
3295         """
3296 
3297     def _eval_evalf(self, prec):
3298         return Float._new(self._as_mpf_val(prec), prec)
3299 
3300     def __eq__(self, other):
3301         try:
3302             other = _sympify(other)
3303         except SympifyError:
3304             return NotImplemented
3305         if self is other:
3306             return True
3307         if other.is_Number and self.is_irrational:
3308             return False
3309 
3310         return False    # NumberSymbol != non-(Number|self)
3311 
3312     def __ne__(self, other):
3313         return not self == other
3314 
3315     def __le__(self, other):
3316         if self is other:
3317             return S.true
3318         return Expr.__le__(self, other)
3319 
3320     def __ge__(self, other):
3321         if self is other:
3322             return S.true
3323         return Expr.__ge__(self, other)
3324 
3325     def __int__(self):
3326         # subclass with appropriate return value
3327         raise NotImplementedError
3328 
3329     def __long__(self):
3330         return self.__int__()
3331 
3332     def __hash__(self):
3333         return super(NumberSymbol, self).__hash__()
3334 
3335 
3336 class Exp1(with_metaclass(Singleton, NumberSymbol)):
3337     r"""The `e` constant.
3338 
3339     The transcendental number `e = 2.718281828\ldots` is the base of the
3340     natural logarithm and of the exponential function, `e = \exp(1)`.
3341     Sometimes called Euler's number or Napier's constant.
3342 
3343     Exp1 is a singleton, and can be accessed by ``S.Exp1``,
3344     or can be imported as ``E``.
3345 
3346     Examples
3347     ========
3348 
3349     >>> from sympy import exp, log, E
3350     >>> E is exp(1)
3351     True
3352     >>> log(E)
3353     1
3354 
3355     References
3356     ==========
3357 
3358     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29
3359     """
3360 
3361     is_real = True
3362     is_positive = True
3363     is_negative = False  # XXX Forces is_negative/is_nonnegative
3364     is_irrational = True
3365     is_number = True
3366     is_algebraic = False
3367     is_transcendental = True
3368 
3369     __slots__ = []
3370 
3371     def _latex(self, printer):
3372         return r"e"
3373 
3374     @staticmethod
3375     def __abs__():
3376         return S.Exp1
3377 
3378     def __int__(self):
3379         return 2
3380 
3381     def _as_mpf_val(self, prec):
3382         return mpf_e(prec)
3383 
3384     def approximation_interval(self, number_cls):
3385         if issubclass(number_cls, Integer):
3386             return (Integer(2), Integer(3))
3387         elif issubclass(number_cls, Rational):
3388             pass
3389 
3390     def _eval_power(self, expt):
3391         from sympy import exp
3392         return exp(expt)
3393 
3394     def _eval_rewrite_as_sin(self, **kwargs):
3395         from sympy import sin
3396         I = S.ImaginaryUnit
3397         return sin(I + S.Pi/2) - I*sin(I)
3398 
3399     def _eval_rewrite_as_cos(self, **kwargs):
3400         from sympy import cos
3401         I = S.ImaginaryUnit
3402         return cos(I) + I*cos(I + S.Pi/2)
3403 
3404     def _sage_(self):
3405         import sage.all as sage
3406         return sage.e
3407 E = S.Exp1
3408 
3409 
3410 class Pi(with_metaclass(Singleton, NumberSymbol)):
3411     r"""The `\pi` constant.
3412 
3413     The transcendental number `\pi = 3.141592654\ldots` represents the ratio
3414     of a circle's circumference to its diameter, the area of the unit circle,
3415     the half-period of trigonometric functions, and many other things
3416     in mathematics.
3417 
3418     Pi is a singleton, and can be accessed by ``S.Pi``, or can
3419     be imported as ``pi``.
3420 
3421     Examples
3422     ========
3423 
3424     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol
3425     >>> S.Pi
3426     pi
3427     >>> pi > 3
3428     True
3429     >>> pi.is_irrational
3430     True
3431     >>> x = Symbol('x')
3432     >>> sin(x + 2*pi)
3433     sin(x)
3434     >>> integrate(exp(-x**2), (x, -oo, oo))
3435     sqrt(pi)
3436 
3437     References
3438     ==========
3439 
3440     .. [1] https://en.wikipedia.org/wiki/Pi
3441     """
3442 
3443     is_real = True
3444     is_positive = True
3445     is_negative = False
3446     is_irrational = True
3447     is_number = True
3448     is_algebraic = False
3449     is_transcendental = True
3450 
3451     __slots__ = []
3452 
3453     def _latex(self, printer):
3454         return r"\pi"
3455 
3456     @staticmethod
3457     def __abs__():
3458         return S.Pi
3459 
3460     def __int__(self):
3461         return 3
3462 
3463     def _as_mpf_val(self, prec):
3464         return mpf_pi(prec)
3465 
3466     def approximation_interval(self, number_cls):
3467         if issubclass(number_cls, Integer):
3468             return (Integer(3), Integer(4))
3469         elif issubclass(number_cls, Rational):
3470             return (Rational(223, 71), Rational(22, 7))
3471 
3472     def _sage_(self):
3473         import sage.all as sage
3474         return sage.pi
3475 pi = S.Pi
3476 
3477 
3478 class GoldenRatio(with_metaclass(Singleton, NumberSymbol)):
3479     r"""The golden ratio, `\phi`.
3480 
3481     `\phi = \frac{1 + \sqrt{5}}{2}` is algebraic number.  Two quantities
3482     are in the golden ratio if their ratio is the same as the ratio of
3483     their sum to the larger of the two quantities, i.e. their maximum.
3484 
3485     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.
3486 
3487     Examples
3488     ========
3489 
3490     >>> from sympy import S
3491     >>> S.GoldenRatio > 1
3492     True
3493     >>> S.GoldenRatio.expand(func=True)
3494     1/2 + sqrt(5)/2
3495     >>> S.GoldenRatio.is_irrational
3496     True
3497 
3498     References
3499     ==========
3500 
3501     .. [1] https://en.wikipedia.org/wiki/Golden_ratio
3502     """
3503 
3504     is_real = True
3505     is_positive = True
3506     is_negative = False
3507     is_irrational = True
3508     is_number = True
3509     is_algebraic = True
3510     is_transcendental = False
3511 
3512     __slots__ = []
3513 
3514     def _latex(self, printer):
3515         return r"\phi"
3516 
3517     def __int__(self):
3518         return 1
3519 
3520     def _as_mpf_val(self, prec):
3521          # XXX track down why this has to be increased
3522         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)
3523         return mpf_norm(rv, prec)
3524 
3525     def _eval_expand_func(self, **hints):
3526         from sympy import sqrt
3527         return S.Half + S.Half*sqrt(5)
3528 
3529     def approximation_interval(self, number_cls):
3530         if issubclass(number_cls, Integer):
3531             return (S.One, Rational(2))
3532         elif issubclass(number_cls, Rational):
3533             pass
3534 
3535     def _sage_(self):
3536         import sage.all as sage
3537         return sage.golden_ratio
3538 
3539     _eval_rewrite_as_sqrt = _eval_expand_func
3540 
3541 
3542 class TribonacciConstant(with_metaclass(Singleton, NumberSymbol)):
3543     r"""The tribonacci constant.
3544 
3545     The tribonacci numbers are like the Fibonacci numbers, but instead
3546     of starting with two predetermined terms, the sequence starts with
3547     three predetermined terms and each term afterwards is the sum of the
3548     preceding three terms.
3549 
3550     The tribonacci constant is the ratio toward which adjacent tribonacci
3551     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,
3552     and also satisfies the equation `x + x^{-3} = 2`.
3553 
3554     TribonacciConstant is a singleton, and can be accessed
3555     by ``S.TribonacciConstant``.
3556 
3557     Examples
3558     ========
3559 
3560     >>> from sympy import S
3561     >>> S.TribonacciConstant > 1
3562     True
3563     >>> S.TribonacciConstant.expand(func=True)
3564     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3
3565     >>> S.TribonacciConstant.is_irrational
3566     True
3567     >>> S.TribonacciConstant.n(20)
3568     1.8392867552141611326
3569 
3570     References
3571     ==========
3572 
3573     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers
3574     """
3575 
3576     is_real = True
3577     is_positive = True
3578     is_negative = False
3579     is_irrational = True
3580     is_number = True
3581     is_algebraic = True
3582     is_transcendental = False
3583 
3584     __slots__ = []
3585 
3586     def _latex(self, printer):
3587         return r"\text{TribonacciConstant}"
3588 
3589     def __int__(self):
3590         return 2
3591 
3592     def _eval_evalf(self, prec):
3593         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)
3594         return Float(rv, precision=prec)
3595 
3596     def _eval_expand_func(self, **hints):
3597         from sympy import sqrt, cbrt
3598         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3
3599 
3600     def approximation_interval(self, number_cls):
3601         if issubclass(number_cls, Integer):
3602             return (S.One, Rational(2))
3603         elif issubclass(number_cls, Rational):
3604             pass
3605 
3606     _eval_rewrite_as_sqrt = _eval_expand_func
3607 
3608 
3609 class EulerGamma(with_metaclass(Singleton, NumberSymbol)):
3610     r"""The Euler-Mascheroni constant.
3611 
3612     `\gamma = 0.5772157\ldots` (also called Euler's constant) is a mathematical
3613     constant recurring in analysis and number theory.  It is defined as the
3614     limiting difference between the harmonic series and the
3615     natural logarithm:
3616 
3617     .. math:: \gamma = \lim\limits_{n\to\infty}
3618               \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln n\right)
3619 
3620     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.
3621 
3622     Examples
3623     ========
3624 
3625     >>> from sympy import S
3626     >>> S.EulerGamma.is_irrational
3627     >>> S.EulerGamma > 0
3628     True
3629     >>> S.EulerGamma > 1
3630     False
3631 
3632     References
3633     ==========
3634 
3635     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant
3636     """
3637 
3638     is_real = True
3639     is_positive = True
3640     is_negative = False
3641     is_irrational = None
3642     is_number = True
3643 
3644     __slots__ = []
3645 
3646     def _latex(self, printer):
3647         return r"\gamma"
3648 
3649     def __int__(self):
3650         return 0
3651 
3652     def _as_mpf_val(self, prec):
3653          # XXX track down why this has to be increased
3654         v = mlib.libhyper.euler_fixed(prec + 10)
3655         rv = mlib.from_man_exp(v, -prec - 10)
3656         return mpf_norm(rv, prec)
3657 
3658     def approximation_interval(self, number_cls):
3659         if issubclass(number_cls, Integer):
3660             return (S.Zero, S.One)
3661         elif issubclass(number_cls, Rational):
3662             return (S.Half, Rational(3, 5))
3663 
3664     def _sage_(self):
3665         import sage.all as sage
3666         return sage.euler_gamma
3667 
3668 
3669 class Catalan(with_metaclass(Singleton, NumberSymbol)):
3670     r"""Catalan's constant.
3671 
3672     `K = 0.91596559\ldots` is given by the infinite series
3673 
3674     .. math:: K = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}
3675 
3676     Catalan is a singleton, and can be accessed by ``S.Catalan``.
3677 
3678     Examples
3679     ========
3680 
3681     >>> from sympy import S
3682     >>> S.Catalan.is_irrational
3683     >>> S.Catalan > 0
3684     True
3685     >>> S.Catalan > 1
3686     False
3687 
3688     References
3689     ==========
3690 
3691     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant
3692     """
3693 
3694     is_real = True
3695     is_positive = True
3696     is_negative = False
3697     is_irrational = None
3698     is_number = True
3699 
3700     __slots__ = []
3701 
3702     def __int__(self):
3703         return 0
3704 
3705     def _as_mpf_val(self, prec):
3706         # XXX track down why this has to be increased
3707         v = mlib.catalan_fixed(prec + 10)
3708         rv = mlib.from_man_exp(v, -prec - 10)
3709         return mpf_norm(rv, prec)
3710 
3711     def approximation_interval(self, number_cls):
3712         if issubclass(number_cls, Integer):
3713             return (S.Zero, S.One)
3714         elif issubclass(number_cls, Rational):
3715             return (Rational(9, 10), S.One)
3716 
3717     def _sage_(self):
3718         import sage.all as sage
3719         return sage.catalan
3720 
3721 
3722 class ImaginaryUnit(with_metaclass(Singleton, AtomicExpr)):
3723     r"""The imaginary unit, `i = \sqrt{-1}`.
3724 
3725     I is a singleton, and can be accessed by ``S.I``, or can be
3726     imported as ``I``.
3727 
3728     Examples
3729     ========
3730 
3731     >>> from sympy import I, sqrt
3732     >>> sqrt(-1)
3733     I
3734     >>> I*I
3735     -1
3736     >>> 1/I
3737     -I
3738 
3739     References
3740     ==========
3741 
3742     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit
3743     """
3744 
3745     is_commutative = True
3746     is_imaginary = True
3747     is_finite = True
3748     is_number = True
3749     is_algebraic = True
3750     is_transcendental = False
3751 
3752     __slots__ = []
3753 
3754     def _latex(self, printer):
3755         return printer._settings['imaginary_unit_latex']
3756 
3757     @staticmethod
3758     def __abs__():
3759         return S.One
3760 
3761     def _eval_evalf(self, prec):
3762         return self
3763 
3764     def _eval_conjugate(self):
3765         return -S.ImaginaryUnit
3766 
3767     def _eval_power(self, expt):
3768         """
3769         b is I = sqrt(-1)
3770         e is symbolic object but not equal to 0, 1
3771 
3772         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal
3773         I**0 mod 4 -> 1
3774         I**1 mod 4 -> I
3775         I**2 mod 4 -> -1
3776         I**3 mod 4 -> -I
3777         """
3778 
3779         if isinstance(expt, Number):
3780             if isinstance(expt, Integer):
3781                 expt = expt.p % 4
3782                 if expt == 0:
3783                     return S.One
3784                 if expt == 1:
3785                     return S.ImaginaryUnit
3786                 if expt == 2:
3787                     return -S.One
3788                 return -S.ImaginaryUnit
3789         return
3790 
3791     def as_base_exp(self):
3792         return S.NegativeOne, S.Half
3793 
3794     def _sage_(self):
3795         import sage.all as sage
3796         return sage.I
3797 
3798     @property
3799     def _mpc_(self):
3800         return (Float(0)._mpf_, Float(1)._mpf_)
3801 
3802 I = S.ImaginaryUnit
3803 
3804 
3805 def sympify_fractions(f):
3806     return Rational(f.numerator, f.denominator, 1)
3807 
3808 converter[fractions.Fraction] = sympify_fractions
3809 
3810 try:
3811     if HAS_GMPY == 2:
3812         import gmpy2 as gmpy
3813     elif HAS_GMPY == 1:
3814         import gmpy
3815     else:
3816         raise ImportError
3817 
3818     def sympify_mpz(x):
3819         return Integer(long(x))
3820 
3821     def sympify_mpq(x):
3822         return Rational(long(x.numerator), long(x.denominator))
3823 
3824     converter[type(gmpy.mpz(1))] = sympify_mpz
3825     converter[type(gmpy.mpq(1, 2))] = sympify_mpq
3826 except ImportError:
3827     pass
3828 
3829 
3830 def sympify_mpmath(x):
3831     return Expr._from_mpmath(x, x.context.prec)
3832 
3833 converter[mpnumeric] = sympify_mpmath
3834 
3835 
3836 def sympify_mpq(x):
3837     p, q = x._mpq_
3838     return Rational(p, q, 1)
3839 
3840 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpq
3841 
3842 
3843 def sympify_complex(a):
3844     real, imag = list(map(sympify, (a.real, a.imag)))
3845     return real + S.ImaginaryUnit*imag
3846 
3847 converter[complex] = sympify_complex
3848 
3849 from .power import Pow, integer_nthroot
3850 from .mul import Mul
3851 Mul.identity = One()
3852 from .add import Add
3853 Add.identity = Zero()
3854 
3855 def _register_classes():
3856     numbers.Number.register(Number)
3857     numbers.Real.register(Float)
3858     numbers.Rational.register(Rational)
3859     numbers.Rational.register(Integer)
3860 
3861 _register_classes()

</code><intended_behavior>Ensure that division between numbers, especially involving fractions or symbolic representations like 'Half', follows Python's standard arithmetic rules, allowing for floor division without raising an error unless mathematically justified (e.g., division by zero).</intended_behavior>, <file>sympy/core/power.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from math import log as _log
4 
5 from .sympify import _sympify
6 from .cache import cacheit
7 from .singleton import S
8 from .expr import Expr
9 from .evalf import PrecisionExhausted
10 from .function import (_coeff_isneg, expand_complex, expand_multinomial,
11     expand_mul)
12 from .logic import fuzzy_bool, fuzzy_not, fuzzy_and
13 from .compatibility import as_int, range
14 from .evaluate import global_evaluate
15 from sympy.utilities.iterables import sift
16 
17 from mpmath.libmp import sqrtrem as mpmath_sqrtrem
18 
19 from math import sqrt as _sqrt
20 
21 
22 
23 def isqrt(n):
24     """Return the largest integer less than or equal to sqrt(n)."""
25     if n < 17984395633462800708566937239552:
26         return int(_sqrt(n))
27     return integer_nthroot(int(n), 2)[0]
28 
29 
30 def integer_nthroot(y, n):
31     """
32     Return a tuple containing x = floor(y**(1/n))
33     and a boolean indicating whether the result is exact (that is,
34     whether x**n == y).
35 
36     Examples
37     ========
38 
39     >>> from sympy import integer_nthroot
40     >>> integer_nthroot(16, 2)
41     (4, True)
42     >>> integer_nthroot(26, 2)
43     (5, False)
44 
45     To simply determine if a number is a perfect square, the is_square
46     function should be used:
47 
48     >>> from sympy.ntheory.primetest import is_square
49     >>> is_square(26)
50     False
51 
52     See Also
53     ========
54     sympy.ntheory.primetest.is_square
55     integer_log
56     """
57     y, n = as_int(y), as_int(n)
58     if y < 0:
59         raise ValueError("y must be nonnegative")
60     if n < 1:
61         raise ValueError("n must be positive")
62     if y in (0, 1):
63         return y, True
64     if n == 1:
65         return y, True
66     if n == 2:
67         x, rem = mpmath_sqrtrem(y)
68         return int(x), not rem
69     if n > y:
70         return 1, False
71     # Get initial estimate for Newton's method. Care must be taken to
72     # avoid overflow
73     try:
74         guess = int(y**(1./n) + 0.5)
75     except OverflowError:
76         exp = _log(y, 2)/n
77         if exp > 53:
78             shift = int(exp - 53)
79             guess = int(2.0**(exp - shift) + 1) << shift
80         else:
81             guess = int(2.0**exp)
82     if guess > 2**50:
83         # Newton iteration
84         xprev, x = -1, guess
85         while 1:
86             t = x**(n - 1)
87             xprev, x = x, ((n - 1)*x + y//t)//n
88             if abs(x - xprev) < 2:
89                 break
90     else:
91         x = guess
92     # Compensate
93     t = x**n
94     while t < y:
95         x += 1
96         t = x**n
97     while t > y:
98         x -= 1
99         t = x**n
100     return int(x), t == y  # int converts long to int if possible
101 
102 
103 def integer_log(y, x):
104     """Returns (e, bool) where e is the largest nonnegative integer
105     such that |y| >= |x**e| and bool is True if y == x**e
106 
107     Examples
108     ========
109 
110     >>> from sympy import integer_log
111     >>> integer_log(125, 5)
112     (3, True)
113     >>> integer_log(17, 9)
114     (1, False)
115     >>> integer_log(4, -2)
116     (2, True)
117     >>> integer_log(-125,-5)
118     (3, True)
119 
120     See Also
121     ========
122     integer_nthroot
123     sympy.ntheory.primetest.is_square
124     sympy.ntheory.factor_.multiplicity
125     sympy.ntheory.factor_.perfect_power
126     """
127     if x == 1:
128         raise ValueError('x cannot take value as 1')
129     if y == 0:
130         raise ValueError('y cannot take value as 0')
131 
132     if x in (-2, 2):
133         x = int(x)
134         y = as_int(y)
135         e = y.bit_length() - 1
136         return e, x**e == y
137     if x < 0:
138         n, b = integer_log(y if y > 0 else -y, -x)
139         return n, b and bool(n % 2 if y < 0 else not n % 2)
140 
141     x = as_int(x)
142     y = as_int(y)
143     r = e = 0
144     while y >= x:
145         d = x
146         m = 1
147         while y >= d:
148             y, rem = divmod(y, d)
149             r = r or rem
150             e += m
151             if y > d:
152                 d *= d
153                 m *= 2
154     return e, r == 0 and y == 1
155 
156 
157 class Pow(Expr):
158     """
159     Defines the expression x**y as "x raised to a power y"
160 
161     Singleton definitions involving (0, 1, -1, oo, -oo, I, -I):
162 
163     +--------------+---------+-----------------------------------------------+
164     | expr         | value   | reason                                        |
165     +==============+=========+===============================================+
166     | z**0         | 1       | Although arguments over 0**0 exist, see [2].  |
167     +--------------+---------+-----------------------------------------------+
168     | z**1         | z       |                                               |
169     +--------------+---------+-----------------------------------------------+
170     | (-oo)**(-1)  | 0       |                                               |
171     +--------------+---------+-----------------------------------------------+
172     | (-1)**-1     | -1      |                                               |
173     +--------------+---------+-----------------------------------------------+
174     | S.Zero**-1   | zoo     | This is not strictly true, as 0**-1 may be    |
175     |              |         | undefined, but is convenient in some contexts |
176     |              |         | where the base is assumed to be positive.     |
177     +--------------+---------+-----------------------------------------------+
178     | 1**-1        | 1       |                                               |
179     +--------------+---------+-----------------------------------------------+
180     | oo**-1       | 0       |                                               |
181     +--------------+---------+-----------------------------------------------+
182     | 0**oo        | 0       | Because for all complex numbers z near        |
183     |              |         | 0, z**oo -> 0.                                |
184     +--------------+---------+-----------------------------------------------+
185     | 0**-oo       | zoo     | This is not strictly true, as 0**oo may be    |
186     |              |         | oscillating between positive and negative     |
187     |              |         | values or rotating in the complex plane.      |
188     |              |         | It is convenient, however, when the base      |
189     |              |         | is positive.                                  |
190     +--------------+---------+-----------------------------------------------+
191     | 1**oo        | nan     | Because there are various cases where         |
192     | 1**-oo       |         | lim(x(t),t)=1, lim(y(t),t)=oo (or -oo),       |
193     |              |         | but lim( x(t)**y(t), t) != 1.  See [3].       |
194     +--------------+---------+-----------------------------------------------+
195     | b**zoo       | nan     | Because b**z has no limit as z -> zoo         |
196     +--------------+---------+-----------------------------------------------+
197     | (-1)**oo     | nan     | Because of oscillations in the limit.         |
198     | (-1)**(-oo)  |         |                                               |
199     +--------------+---------+-----------------------------------------------+
200     | oo**oo       | oo      |                                               |
201     +--------------+---------+-----------------------------------------------+
202     | oo**-oo      | 0       |                                               |
203     +--------------+---------+-----------------------------------------------+
204     | (-oo)**oo    | nan     |                                               |
205     | (-oo)**-oo   |         |                                               |
206     +--------------+---------+-----------------------------------------------+
207     | oo**I        | nan     | oo**e could probably be best thought of as    |
208     | (-oo)**I     |         | the limit of x**e for real x as x tends to    |
209     |              |         | oo. If e is I, then the limit does not exist  |
210     |              |         | and nan is used to indicate that.             |
211     +--------------+---------+-----------------------------------------------+
212     | oo**(1+I)    | zoo     | If the real part of e is positive, then the   |
213     | (-oo)**(1+I) |         | limit of abs(x**e) is oo. So the limit value  |
214     |              |         | is zoo.                                       |
215     +--------------+---------+-----------------------------------------------+
216     | oo**(-1+I)   | 0       | If the real part of e is negative, then the   |
217     | -oo**(-1+I)  |         | limit is 0.                                   |
218     +--------------+---------+-----------------------------------------------+
219 
220     Because symbolic computations are more flexible that floating point
221     calculations and we prefer to never return an incorrect answer,
222     we choose not to conform to all IEEE 754 conventions.  This helps
223     us avoid extra test-case code in the calculation of limits.
224 
225     See Also
226     ========
227 
228     sympy.core.numbers.Infinity
229     sympy.core.numbers.NegativeInfinity
230     sympy.core.numbers.NaN
231 
232     References
233     ==========
234 
235     .. [1] https://en.wikipedia.org/wiki/Exponentiation
236     .. [2] https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_power_of_zero
237     .. [3] https://en.wikipedia.org/wiki/Indeterminate_forms
238 
239     """
240     is_Pow = True
241 
242     __slots__ = ['is_commutative']
243 
244     @cacheit
245     def __new__(cls, b, e, evaluate=None):
246         if evaluate is None:
247             evaluate = global_evaluate[0]
248         from sympy.functions.elementary.exponential import exp_polar
249 
250         b = _sympify(b)
251         e = _sympify(e)
252         if evaluate:
253             if e is S.ComplexInfinity:
254                 return S.NaN
255             if e is S.Zero:
256                 return S.One
257             elif e is S.One:
258                 return b
259             # Only perform autosimplification if exponent or base is a Symbol or number
260             elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and\
261                 e.is_integer and _coeff_isneg(b):
262                 if e.is_even:
263                     b = -b
264                 elif e.is_odd:
265                     return -Pow(-b, e)
266             if S.NaN in (b, e):  # XXX S.NaN**x -> S.NaN under assumption that x != 0
267                 return S.NaN
268             elif b is S.One:
269                 if abs(e).is_infinite:
270                     return S.NaN
271                 return S.One
272             else:
273                 # recognize base as E
274                 if not e.is_Atom and b is not S.Exp1 and not isinstance(b, exp_polar):
275                     from sympy import numer, denom, log, sign, im, factor_terms
276                     c, ex = factor_terms(e, sign=False).as_coeff_Mul()
277                     den = denom(ex)
278                     if isinstance(den, log) and den.args[0] == b:
279                         return S.Exp1**(c*numer(ex))
280                     elif den.is_Add:
281                         s = sign(im(b))
282                         if s.is_Number and s and den == \
283                                 log(-factor_terms(b, sign=False)) + s*S.ImaginaryUnit*S.Pi:
284                             return S.Exp1**(c*numer(ex))
285 
286                 obj = b._eval_power(e)
287                 if obj is not None:
288                     return obj
289         obj = Expr.__new__(cls, b, e)
290         obj = cls._exec_constructor_postprocessors(obj)
291         if not isinstance(obj, Pow):
292             return obj
293         obj.is_commutative = (b.is_commutative and e.is_commutative)
294         return obj
295 
296     @property
297     def base(self):
298         return self._args[0]
299 
300     @property
301     def exp(self):
302         return self._args[1]
303 
304     @classmethod
305     def class_key(cls):
306         return 3, 2, cls.__name__
307 
308     def _eval_refine(self, assumptions):
309         from sympy.assumptions.ask import ask, Q
310         b, e = self.as_base_exp()
311         if ask(Q.integer(e), assumptions) and _coeff_isneg(b):
312             if ask(Q.even(e), assumptions):
313                 return Pow(-b, e)
314             elif ask(Q.odd(e), assumptions):
315                 return -Pow(-b, e)
316 
317     def _eval_power(self, other):
318         from sympy import Abs, arg, exp, floor, im, log, re, sign
319         b, e = self.as_base_exp()
320         if b is S.NaN:
321             return (b**e)**other  # let __new__ handle it
322 
323         s = None
324         if other.is_integer:
325             s = 1
326         elif b.is_polar:  # e.g. exp_polar, besselj, var('p', polar=True)...
327             s = 1
328         elif e.is_real is not None:
329             # helper functions ===========================
330             def _half(e):
331                 """Return True if the exponent has a literal 2 as the
332                 denominator, else None."""
333                 if getattr(e, 'q', None) == 2:
334                     return True
335                 n, d = e.as_numer_denom()
336                 if n.is_integer and d == 2:
337                     return True
338             def _n2(e):
339                 """Return ``e`` evaluated to a Number with 2 significant
340                 digits, else None."""
341                 try:
342                     rv = e.evalf(2, strict=True)
343                     if rv.is_Number:
344                         return rv
345                 except PrecisionExhausted:
346                     pass
347             # ===================================================
348             if e.is_real:
349                 # we need _half(other) with constant floor or
350                 # floor(S.Half - e*arg(b)/2/pi) == 0
351 
352                 # handle -1 as special case
353                 if e == -1:
354                     # floor arg. is 1/2 + arg(b)/2/pi
355                     if _half(other):
356                         if b.is_negative is True:
357                             return S.NegativeOne**other*Pow(-b, e*other)
358                         if b.is_real is False:
359                             return Pow(b.conjugate()/Abs(b)**2, other)
360                 elif e.is_even:
361                     if b.is_real:
362                         b = abs(b)
363                     if b.is_imaginary:
364                         b = abs(im(b))*S.ImaginaryUnit
365 
366                 if (abs(e) < 1) == True or e == 1:
367                     s = 1  # floor = 0
368                 elif b.is_nonnegative:
369                     s = 1  # floor = 0
370                 elif re(b).is_nonnegative and (abs(e) < 2) == True:
371                     s = 1  # floor = 0
372                 elif fuzzy_not(im(b).is_zero) and abs(e) == 2:
373                     s = 1  # floor = 0
374                 elif _half(other):
375                     s = exp(2*S.Pi*S.ImaginaryUnit*other*floor(
376                         S.Half - e*arg(b)/(2*S.Pi)))
377                     if s.is_real and _n2(sign(s) - s) == 0:
378                         s = sign(s)
379                     else:
380                         s = None
381             else:
382                 # e.is_real is False requires:
383                 #     _half(other) with constant floor or
384                 #     floor(S.Half - im(e*log(b))/2/pi) == 0
385                 try:
386                     s = exp(2*S.ImaginaryUnit*S.Pi*other*
387                         floor(S.Half - im(e*log(b))/2/S.Pi))
388                     # be careful to test that s is -1 or 1 b/c sign(I) == I:
389                     # so check that s is real
390                     if s.is_real and _n2(sign(s) - s) == 0:
391                         s = sign(s)
392                     else:
393                         s = None
394                 except PrecisionExhausted:
395                     s = None
396 
397         if s is not None:
398             return s*Pow(b, e*other)
399 
400     def _eval_Mod(self, q):
401         if self.exp.is_integer and self.exp.is_positive:
402             if q.is_integer and self.base % q == 0:
403                 return S.Zero
404 
405             '''
406             For unevaluated Integer power, use built-in pow modular
407             exponentiation, if powers are not too large wrt base.
408             '''
409             if self.base.is_Integer and self.exp.is_Integer and q.is_Integer:
410                 b, e, m = int(self.base), int(self.exp), int(q)
411                 # For very large powers, use totient reduction if e >= lg(m).
412                 # Bound on m, is for safe factorization memory wise ie m^(1/4).
413                 # For pollard-rho to be faster than built-in pow lg(e) > m^(1/4)
414                 # check is added.
415                 mb = m.bit_length()
416                 if mb <= 80  and e >= mb and e.bit_length()**4 >= m:
417                     from sympy.ntheory import totient
418                     phi = totient(m)
419                     return pow(b, phi + e%phi, m)
420                 else:
421                     return pow(b, e, m)
422 
423     def _eval_is_even(self):
424         if self.exp.is_integer and self.exp.is_positive:
425             return self.base.is_even
426 
427     def _eval_is_positive(self):
428         from sympy import log
429         if self.base == self.exp:
430             if self.base.is_nonnegative:
431                 return True
432         elif self.base.is_positive:
433             if self.exp.is_real:
434                 return True
435         elif self.base.is_negative:
436             if self.exp.is_even:
437                 return True
438             if self.exp.is_odd:
439                 return False
440         elif self.base.is_zero:
441             if self.exp.is_real:
442                 return self.exp.is_zero
443         elif self.base.is_nonpositive:
444             if self.exp.is_odd:
445                 return False
446         elif self.base.is_imaginary:
447             if self.exp.is_integer:
448                 m = self.exp % 4
449                 if m.is_zero:
450                     return True
451                 if m.is_integer and m.is_zero is False:
452                     return False
453             if self.exp.is_imaginary:
454                 return log(self.base).is_imaginary
455 
456     def _eval_is_negative(self):
457         if self.base.is_negative:
458             if self.exp.is_odd:
459                 return True
460             if self.exp.is_even:
461                 return False
462         elif self.base.is_positive:
463             if self.exp.is_real:
464                 return False
465         elif self.base.is_zero:
466             if self.exp.is_real:
467                 return False
468         elif self.base.is_nonnegative:
469             if self.exp.is_nonnegative:
470                 return False
471         elif self.base.is_nonpositive:
472             if self.exp.is_even:
473                 return False
474         elif self.base.is_real:
475             if self.exp.is_even:
476                 return False
477 
478     def _eval_is_zero(self):
479         if self.base.is_zero:
480             if self.exp.is_positive:
481                 return True
482             elif self.exp.is_nonpositive:
483                 return False
484         elif self.base.is_zero is False:
485             if self.exp.is_finite:
486                 return False
487             elif self.exp.is_infinite:
488                 if (1 - abs(self.base)).is_positive:
489                     return self.exp.is_positive
490                 elif (1 - abs(self.base)).is_negative:
491                     return self.exp.is_negative
492         else:
493             # when self.base.is_zero is None
494             return None
495 
496     def _eval_is_integer(self):
497         b, e = self.args
498         if b.is_rational:
499             if b.is_integer is False and e.is_positive:
500                 return False  # rat**nonneg
501         if b.is_integer and e.is_integer:
502             if b is S.NegativeOne:
503                 return True
504             if e.is_nonnegative or e.is_positive:
505                 return True
506         if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):
507             if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):
508                 return False
509         if b.is_Number and e.is_Number:
510             check = self.func(*self.args)
511             return check.is_Integer
512 
513     def _eval_is_real(self):
514         from sympy import arg, exp, log, Mul
515         real_b = self.base.is_real
516         if real_b is None:
517             if self.base.func == exp and self.base.args[0].is_imaginary:
518                 return self.exp.is_imaginary
519             return
520         real_e = self.exp.is_real
521         if real_e is None:
522             return
523         if real_b and real_e:
524             if self.base.is_positive:
525                 return True
526             elif self.base.is_nonnegative:
527                 if self.exp.is_nonnegative:
528                     return True
529             else:
530                 if self.exp.is_integer:
531                     return True
532                 elif self.base.is_negative:
533                     if self.exp.is_Rational:
534                         return False
535         if real_e and self.exp.is_negative:
536             return Pow(self.base, -self.exp).is_real
537         im_b = self.base.is_imaginary
538         im_e = self.exp.is_imaginary
539         if im_b:
540             if self.exp.is_integer:
541                 if self.exp.is_even:
542                     return True
543                 elif self.exp.is_odd:
544                     return False
545             elif im_e and log(self.base).is_imaginary:
546                 return True
547             elif self.exp.is_Add:
548                 c, a = self.exp.as_coeff_Add()
549                 if c and c.is_Integer:
550                     return Mul(
551                         self.base**c, self.base**a, evaluate=False).is_real
552             elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):
553                 if (self.exp/2).is_integer is False:
554                     return False
555         if real_b and im_e:
556             if self.base is S.NegativeOne:
557                 return True
558             c = self.exp.coeff(S.ImaginaryUnit)
559             if c:
560                 ok = (c*log(self.base)/S.Pi).is_Integer
561                 if ok is not None:
562                     return ok
563 
564         if real_b is False:  # we already know it's not imag
565             i = arg(self.base)*self.exp/S.Pi
566             return i.is_integer
567 
568     def _eval_is_complex(self):
569         if all(a.is_complex for a in self.args):
570             return True
571 
572     def _eval_is_imaginary(self):
573         from sympy import arg, log
574         if self.base.is_imaginary:
575             if self.exp.is_integer:
576                 odd = self.exp.is_odd
577                 if odd is not None:
578                     return odd
579                 return
580 
581         if self.exp.is_imaginary:
582             imlog = log(self.base).is_imaginary
583             if imlog is not None:
584                 return False  # I**i -> real; (2*I)**i -> complex ==> not imaginary
585 
586         if self.base.is_real and self.exp.is_real:
587             if self.base.is_positive:
588                 return False
589             else:
590                 rat = self.exp.is_rational
591                 if not rat:
592                     return rat
593                 if self.exp.is_integer:
594                     return False
595                 else:
596                     half = (2*self.exp).is_integer
597                     if half:
598                         return self.base.is_negative
599                     return half
600 
601         if self.base.is_real is False:  # we already know it's not imag
602             i = arg(self.base)*self.exp/S.Pi
603             isodd = (2*i).is_odd
604             if isodd is not None:
605                 return isodd
606 
607         if self.exp.is_negative:
608             return (1/self).is_imaginary
609 
610     def _eval_is_odd(self):
611         if self.exp.is_integer:
612             if self.exp.is_positive:
613                 return self.base.is_odd
614             elif self.exp.is_nonnegative and self.base.is_odd:
615                 return True
616             elif self.base is S.NegativeOne:
617                 return True
618 
619     def _eval_is_finite(self):
620         if self.exp.is_negative:
621             if self.base.is_zero:
622                 return False
623             if self.base.is_infinite:
624                 return True
625         c1 = self.base.is_finite
626         if c1 is None:
627             return
628         c2 = self.exp.is_finite
629         if c2 is None:
630             return
631         if c1 and c2:
632             if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):
633                 return True
634 
635     def _eval_is_prime(self):
636         '''
637         An integer raised to the n(>=2)-th power cannot be a prime.
638         '''
639         if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:
640             return False
641 
642     def _eval_is_composite(self):
643         """
644         A power is composite if both base and exponent are greater than 1
645         """
646         if (self.base.is_integer and self.exp.is_integer and
647             ((self.base - 1).is_positive and (self.exp - 1).is_positive or
648             (self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):
649             return True
650 
651     def _eval_is_polar(self):
652         return self.base.is_polar
653 
654     def _eval_subs(self, old, new):
655         from sympy import exp, log, Symbol
656         def _check(ct1, ct2, old):
657             """Return (bool, pow, remainder_pow) where, if bool is True, then the
658             exponent of Pow `old` will combine with `pow` so the substitution
659             is valid, otherwise bool will be False.
660 
661             For noncommutative objects, `pow` will be an integer, and a factor
662             `Pow(old.base, remainder_pow)` needs to be included. If there is
663             no such factor, None is returned. For commutative objects,
664             remainder_pow is always None.
665 
666             cti are the coefficient and terms of an exponent of self or old
667             In this _eval_subs routine a change like (b**(2*x)).subs(b**x, y)
668             will give y**2 since (b**x)**2 == b**(2*x); if that equality does
669             not hold then the substitution should not occur so `bool` will be
670             False.
671 
672             """
673             coeff1, terms1 = ct1
674             coeff2, terms2 = ct2
675             if terms1 == terms2:
676                 if old.is_commutative:
677                     # Allow fractional powers for commutative objects
678                     pow = coeff1/coeff2
679                     try:
680                         pow = as_int(pow, strict=False)
681                         combines = True
682                     except ValueError:
683                         combines = isinstance(Pow._eval_power(
684                             Pow(*old.as_base_exp(), evaluate=False),
685                             pow), (Pow, exp, Symbol))
686                     return combines, pow, None
687                 else:
688                     # With noncommutative symbols, substitute only integer powers
689                     if not isinstance(terms1, tuple):
690                         terms1 = (terms1,)
691                     if not all(term.is_integer for term in terms1):
692                         return False, None, None
693 
694                     try:
695                         # Round pow toward zero
696                         pow, remainder = divmod(as_int(coeff1), as_int(coeff2))
697                         if pow < 0 and remainder != 0:
698                             pow += 1
699                             remainder -= as_int(coeff2)
700 
701                         if remainder == 0:
702                             remainder_pow = None
703                         else:
704                             remainder_pow = Mul(remainder, *terms1)
705 
706                         return True, pow, remainder_pow
707                     except ValueError:
708                         # Can't substitute
709                         pass
710 
711             return False, None, None
712 
713         if old == self.base:
714             return new**self.exp._subs(old, new)
715 
716         # issue 10829: (4**x - 3*y + 2).subs(2**x, y) -> y**2 - 3*y + 2
717         if isinstance(old, self.func) and self.exp == old.exp:
718             l = log(self.base, old.base)
719             if l.is_Number:
720                 return Pow(new, l)
721 
722         if isinstance(old, self.func) and self.base == old.base:
723             if self.exp.is_Add is False:
724                 ct1 = self.exp.as_independent(Symbol, as_Add=False)
725                 ct2 = old.exp.as_independent(Symbol, as_Add=False)
726                 ok, pow, remainder_pow = _check(ct1, ct2, old)
727                 if ok:
728                     # issue 5180: (x**(6*y)).subs(x**(3*y),z)->z**2
729                     result = self.func(new, pow)
730                     if remainder_pow is not None:
731                         result = Mul(result, Pow(old.base, remainder_pow))
732                     return result
733             else:  # b**(6*x + a).subs(b**(3*x), y) -> y**2 * b**a
734                 # exp(exp(x) + exp(x**2)).subs(exp(exp(x)), w) -> w * exp(exp(x**2))
735                 oarg = old.exp
736                 new_l = []
737                 o_al = []
738                 ct2 = oarg.as_coeff_mul()
739                 for a in self.exp.args:
740                     newa = a._subs(old, new)
741                     ct1 = newa.as_coeff_mul()
742                     ok, pow, remainder_pow = _check(ct1, ct2, old)
743                     if ok:
744                         new_l.append(new**pow)
745                         if remainder_pow is not None:
746                             o_al.append(remainder_pow)
747                         continue
748                     elif not old.is_commutative and not newa.is_integer:
749                         # If any term in the exponent is non-integer,
750                         # we do not do any substitutions in the noncommutative case
751                         return
752                     o_al.append(newa)
753                 if new_l:
754                     expo = Add(*o_al)
755                     new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)
756                     return Mul(*new_l)
757 
758         if isinstance(old, exp) and self.exp.is_real and self.base.is_positive:
759             ct1 = old.args[0].as_independent(Symbol, as_Add=False)
760             ct2 = (self.exp*log(self.base)).as_independent(
761                 Symbol, as_Add=False)
762             ok, pow, remainder_pow = _check(ct1, ct2, old)
763             if ok:
764                 result = self.func(new, pow)  # (2**x).subs(exp(x*log(2)), z) -> z
765                 if remainder_pow is not None:
766                     result = Mul(result, Pow(old.base, remainder_pow))
767                 return result
768 
769     def as_base_exp(self):
770         """Return base and exp of self.
771 
772         If base is 1/Integer, then return Integer, -exp. If this extra
773         processing is not needed, the base and exp properties will
774         give the raw arguments
775 
776         Examples
777         ========
778 
779         >>> from sympy import Pow, S
780         >>> p = Pow(S.Half, 2, evaluate=False)
781         >>> p.as_base_exp()
782         (2, -2)
783         >>> p.args
784         (1/2, 2)
785 
786         """
787 
788         b, e = self.args
789         if b.is_Rational and b.p == 1 and b.q != 1:
790             return Integer(b.q), -e
791         return b, e
792 
793     def _eval_adjoint(self):
794         from sympy.functions.elementary.complexes import adjoint
795         i, p = self.exp.is_integer, self.base.is_positive
796         if i:
797             return adjoint(self.base)**self.exp
798         if p:
799             return self.base**adjoint(self.exp)
800         if i is False and p is False:
801             expanded = expand_complex(self)
802             if expanded != self:
803                 return adjoint(expanded)
804 
805     def _eval_conjugate(self):
806         from sympy.functions.elementary.complexes import conjugate as c
807         i, p = self.exp.is_integer, self.base.is_positive
808         if i:
809             return c(self.base)**self.exp
810         if p:
811             return self.base**c(self.exp)
812         if i is False and p is False:
813             expanded = expand_complex(self)
814             if expanded != self:
815                 return c(expanded)
816         if self.is_real:
817             return self
818 
819     def _eval_transpose(self):
820         from sympy.functions.elementary.complexes import transpose
821         i, p = self.exp.is_integer, self.base.is_complex
822         if p:
823             return self.base**self.exp
824         if i:
825             return transpose(self.base)**self.exp
826         if i is False and p is False:
827             expanded = expand_complex(self)
828             if expanded != self:
829                 return transpose(expanded)
830 
831     def _eval_expand_power_exp(self, **hints):
832         """a**(n + m) -> a**n*a**m"""
833         b = self.base
834         e = self.exp
835         if e.is_Add and e.is_commutative:
836             expr = []
837             for x in e.args:
838                 expr.append(self.func(self.base, x))
839             return Mul(*expr)
840         return self.func(b, e)
841 
842     def _eval_expand_power_base(self, **hints):
843         """(a*b)**n -> a**n * b**n"""
844         force = hints.get('force', False)
845 
846         b = self.base
847         e = self.exp
848         if not b.is_Mul:
849             return self
850 
851         cargs, nc = b.args_cnc(split_1=False)
852 
853         # expand each term - this is top-level-only
854         # expansion but we have to watch out for things
855         # that don't have an _eval_expand method
856         if nc:
857             nc = [i._eval_expand_power_base(**hints)
858                 if hasattr(i, '_eval_expand_power_base') else i
859                 for i in nc]
860 
861             if e.is_Integer:
862                 if e.is_positive:
863                     rv = Mul(*nc*e)
864                 else:
865                     rv = Mul(*[i**-1 for i in nc[::-1]]*-e)
866                 if cargs:
867                     rv *= Mul(*cargs)**e
868                 return rv
869 
870             if not cargs:
871                 return self.func(Mul(*nc), e, evaluate=False)
872 
873             nc = [Mul(*nc)]
874 
875         # sift the commutative bases
876         other, maybe_real = sift(cargs, lambda x: x.is_real is False,
877             binary=True)
878         def pred(x):
879             if x is S.ImaginaryUnit:
880                 return S.ImaginaryUnit
881             polar = x.is_polar
882             if polar:
883                 return True
884             if polar is None:
885                 return fuzzy_bool(x.is_nonnegative)
886         sifted = sift(maybe_real, pred)
887         nonneg = sifted[True]
888         other += sifted[None]
889         neg = sifted[False]
890         imag = sifted[S.ImaginaryUnit]
891         if imag:
892             I = S.ImaginaryUnit
893             i = len(imag) % 4
894             if i == 0:
895                 pass
896             elif i == 1:
897                 other.append(I)
898             elif i == 2:
899                 if neg:
900                     nonn = -neg.pop()
901                     if nonn is not S.One:
902                         nonneg.append(nonn)
903                 else:
904                     neg.append(S.NegativeOne)
905             else:
906                 if neg:
907                     nonn = -neg.pop()
908                     if nonn is not S.One:
909                         nonneg.append(nonn)
910                 else:
911                     neg.append(S.NegativeOne)
912                 other.append(I)
913             del imag
914 
915         # bring out the bases that can be separated from the base
916 
917         if force or e.is_integer:
918             # treat all commutatives the same and put nc in other
919             cargs = nonneg + neg + other
920             other = nc
921         else:
922             # this is just like what is happening automatically, except
923             # that now we are doing it for an arbitrary exponent for which
924             # no automatic expansion is done
925 
926             assert not e.is_Integer
927 
928             # handle negatives by making them all positive and putting
929             # the residual -1 in other
930             if len(neg) > 1:
931                 o = S.One
932                 if not other and neg[0].is_Number:
933                     o *= neg.pop(0)
934                 if len(neg) % 2:
935                     o = -o
936                 for n in neg:
937                     nonneg.append(-n)
938                 if o is not S.One:
939                     other.append(o)
940             elif neg and other:
941                 if neg[0].is_Number and neg[0] is not S.NegativeOne:
942                     other.append(S.NegativeOne)
943                     nonneg.append(-neg[0])
944                 else:
945                     other.extend(neg)
946             else:
947                 other.extend(neg)
948             del neg
949 
950             cargs = nonneg
951             other += nc
952 
953         rv = S.One
954         if cargs:
955             rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])
956         if other:
957             rv *= self.func(Mul(*other), e, evaluate=False)
958         return rv
959 
960     def _eval_expand_multinomial(self, **hints):
961         """(a + b + ..)**n -> a**n + n*a**(n-1)*b + .., n is nonzero integer"""
962 
963         base, exp = self.args
964         result = self
965 
966         if exp.is_Rational and exp.p > 0 and base.is_Add:
967             if not exp.is_Integer:
968                 n = Integer(exp.p // exp.q)
969 
970                 if not n:
971                     return result
972                 else:
973                     radical, result = self.func(base, exp - n), []
974 
975                     expanded_base_n = self.func(base, n)
976                     if expanded_base_n.is_Pow:
977                         expanded_base_n = \
978                             expanded_base_n._eval_expand_multinomial()
979                     for term in Add.make_args(expanded_base_n):
980                         result.append(term*radical)
981 
982                     return Add(*result)
983 
984             n = int(exp)
985 
986             if base.is_commutative:
987                 order_terms, other_terms = [], []
988 
989                 for b in base.args:
990                     if b.is_Order:
991                         order_terms.append(b)
992                     else:
993                         other_terms.append(b)
994 
995                 if order_terms:
996                     # (f(x) + O(x^n))^m -> f(x)^m + m*f(x)^{m-1} *O(x^n)
997                     f = Add(*other_terms)
998                     o = Add(*order_terms)
999 
1000                     if n == 2:
1001                         return expand_multinomial(f**n, deep=False) + n*f*o
1002                     else:
1003                         g = expand_multinomial(f**(n - 1), deep=False)
1004                         return expand_mul(f*g, deep=False) + n*g*o
1005 
1006                 if base.is_number:
1007                     # Efficiently expand expressions of the form (a + b*I)**n
1008                     # where 'a' and 'b' are real numbers and 'n' is integer.
1009                     a, b = base.as_real_imag()
1010 
1011                     if a.is_Rational and b.is_Rational:
1012                         if not a.is_Integer:
1013                             if not b.is_Integer:
1014                                 k = self.func(a.q * b.q, n)
1015                                 a, b = a.p*b.q, a.q*b.p
1016                             else:
1017                                 k = self.func(a.q, n)
1018                                 a, b = a.p, a.q*b
1019                         elif not b.is_Integer:
1020                             k = self.func(b.q, n)
1021                             a, b = a*b.q, b.p
1022                         else:
1023                             k = 1
1024 
1025                         a, b, c, d = int(a), int(b), 1, 0
1026 
1027                         while n:
1028                             if n & 1:
1029                                 c, d = a*c - b*d, b*c + a*d
1030                                 n -= 1
1031                             a, b = a*a - b*b, 2*a*b
1032                             n //= 2
1033 
1034                         I = S.ImaginaryUnit
1035 
1036                         if k == 1:
1037                             return c + I*d
1038                         else:
1039                             return Integer(c)/k + I*d/k
1040 
1041                 p = other_terms
1042                 # (x + y)**3 -> x**3 + 3*x**2*y + 3*x*y**2 + y**3
1043                 # in this particular example:
1044                 # p = [x,y]; n = 3
1045                 # so now it's easy to get the correct result -- we get the
1046                 # coefficients first:
1047                 from sympy import multinomial_coefficients
1048                 from sympy.polys.polyutils import basic_from_dict
1049                 expansion_dict = multinomial_coefficients(len(p), n)
1050                 # in our example: {(3, 0): 1, (1, 2): 3, (0, 3): 1, (2, 1): 3}
1051                 # and now construct the expression.
1052                 return basic_from_dict(expansion_dict, *p)
1053             else:
1054                 if n == 2:
1055                     return Add(*[f*g for f in base.args for g in base.args])
1056                 else:
1057                     multi = (base**(n - 1))._eval_expand_multinomial()
1058                     if multi.is_Add:
1059                         return Add(*[f*g for f in base.args
1060                             for g in multi.args])
1061                     else:
1062                         # XXX can this ever happen if base was an Add?
1063                         return Add(*[f*multi for f in base.args])
1064         elif (exp.is_Rational and exp.p < 0 and base.is_Add and
1065                 abs(exp.p) > exp.q):
1066             return 1 / self.func(base, -exp)._eval_expand_multinomial()
1067         elif exp.is_Add and base.is_Number:
1068             #  a + b      a  b
1069             # n      --> n  n  , where n, a, b are Numbers
1070 
1071             coeff, tail = S.One, S.Zero
1072             for term in exp.args:
1073                 if term.is_Number:
1074                     coeff *= self.func(base, term)
1075                 else:
1076                     tail += term
1077 
1078             return coeff * self.func(base, tail)
1079         else:
1080             return result
1081 
1082     def as_real_imag(self, deep=True, **hints):
1083         from sympy import atan2, cos, im, re, sin
1084         from sympy.polys.polytools import poly
1085 
1086         if self.exp.is_Integer:
1087             exp = self.exp
1088             re, im = self.base.as_real_imag(deep=deep)
1089             if not im:
1090                 return self, S.Zero
1091             a, b = symbols('a b', cls=Dummy)
1092             if exp >= 0:
1093                 if re.is_Number and im.is_Number:
1094                     # We can be more efficient in this case
1095                     expr = expand_multinomial(self.base**exp)
1096                     if expr != self:
1097                         return expr.as_real_imag()
1098 
1099                 expr = poly(
1100                     (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp
1101             else:
1102                 mag = re**2 + im**2
1103                 re, im = re/mag, -im/mag
1104                 if re.is_Number and im.is_Number:
1105                     # We can be more efficient in this case
1106                     expr = expand_multinomial((re + im*S.ImaginaryUnit)**-exp)
1107                     if expr != self:
1108                         return expr.as_real_imag()
1109 
1110                 expr = poly((a + b)**-exp)
1111 
1112             # Terms with even b powers will be real
1113             r = [i for i in expr.terms() if not i[0][1] % 2]
1114             re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])
1115             # Terms with odd b powers will be imaginary
1116             r = [i for i in expr.terms() if i[0][1] % 4 == 1]
1117             im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])
1118             r = [i for i in expr.terms() if i[0][1] % 4 == 3]
1119             im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])
1120 
1121             return (re_part.subs({a: re, b: S.ImaginaryUnit*im}),
1122             im_part1.subs({a: re, b: im}) + im_part3.subs({a: re, b: -im}))
1123 
1124         elif self.exp.is_Rational:
1125             re, im = self.base.as_real_imag(deep=deep)
1126 
1127             if im.is_zero and self.exp is S.Half:
1128                 if re.is_nonnegative:
1129                     return self, S.Zero
1130                 if re.is_nonpositive:
1131                     return S.Zero, (-self.base)**self.exp
1132 
1133             # XXX: This is not totally correct since for x**(p/q) with
1134             #      x being imaginary there are actually q roots, but
1135             #      only a single one is returned from here.
1136             r = self.func(self.func(re, 2) + self.func(im, 2), S.Half)
1137             t = atan2(im, re)
1138 
1139             rp, tp = self.func(r, self.exp), t*self.exp
1140 
1141             return (rp*cos(tp), rp*sin(tp))
1142         else:
1143 
1144             if deep:
1145                 hints['complex'] = False
1146 
1147                 expanded = self.expand(deep, **hints)
1148                 if hints.get('ignore') == expanded:
1149                     return None
1150                 else:
1151                     return (re(expanded), im(expanded))
1152             else:
1153                 return (re(self), im(self))
1154 
1155     def _eval_derivative(self, s):
1156         from sympy import log
1157         dbase = self.base.diff(s)
1158         dexp = self.exp.diff(s)
1159         return self * (dexp * log(self.base) + dbase * self.exp/self.base)
1160 
1161     def _eval_evalf(self, prec):
1162         base, exp = self.as_base_exp()
1163         base = base._evalf(prec)
1164         if not exp.is_Integer:
1165             exp = exp._evalf(prec)
1166         if exp.is_negative and base.is_number and base.is_real is False:
1167             base = base.conjugate() / (base * base.conjugate())._evalf(prec)
1168             exp = -exp
1169             return self.func(base, exp).expand()
1170         return self.func(base, exp)
1171 
1172     def _eval_is_polynomial(self, syms):
1173         if self.exp.has(*syms):
1174             return False
1175 
1176         if self.base.has(*syms):
1177             return bool(self.base._eval_is_polynomial(syms) and
1178                 self.exp.is_Integer and (self.exp >= 0))
1179         else:
1180             return True
1181 
1182     def _eval_is_rational(self):
1183         # The evaluation of self.func below can be very expensive in the case
1184         # of integer**integer if the exponent is large.  We should try to exit
1185         # before that if possible:
1186         if (self.exp.is_integer and self.base.is_rational
1187                 and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero]))):
1188             return True
1189         p = self.func(*self.as_base_exp())  # in case it's unevaluated
1190         if not p.is_Pow:
1191             return p.is_rational
1192         b, e = p.as_base_exp()
1193         if e.is_Rational and b.is_Rational:
1194             # we didn't check that e is not an Integer
1195             # because Rational**Integer autosimplifies
1196             return False
1197         if e.is_integer:
1198             if b.is_rational:
1199                 if fuzzy_not(b.is_zero) or e.is_nonnegative:
1200                     return True
1201                 if b == e:  # always rational, even for 0**0
1202                     return True
1203             elif b.is_irrational:
1204                 return e.is_zero
1205 
1206     def _eval_is_algebraic(self):
1207         def _is_one(expr):
1208             try:
1209                 return (expr - 1).is_zero
1210             except ValueError:
1211                 # when the operation is not allowed
1212                 return False
1213 
1214         if self.base.is_zero or _is_one(self.base):
1215             return True
1216         elif self.exp.is_rational:
1217             if self.base.is_algebraic is False:
1218                 return self.exp.is_zero
1219             return self.base.is_algebraic
1220         elif self.base.is_algebraic and self.exp.is_algebraic:
1221             if ((fuzzy_not(self.base.is_zero)
1222                 and fuzzy_not(_is_one(self.base)))
1223                 or self.base.is_integer is False
1224                 or self.base.is_irrational):
1225                 return self.exp.is_rational
1226 
1227     def _eval_is_rational_function(self, syms):
1228         if self.exp.has(*syms):
1229             return False
1230 
1231         if self.base.has(*syms):
1232             return self.base._eval_is_rational_function(syms) and \
1233                 self.exp.is_Integer
1234         else:
1235             return True
1236 
1237     def _eval_is_algebraic_expr(self, syms):
1238         if self.exp.has(*syms):
1239             return False
1240 
1241         if self.base.has(*syms):
1242             return self.base._eval_is_algebraic_expr(syms) and \
1243                 self.exp.is_Rational
1244         else:
1245             return True
1246 
1247     def _eval_rewrite_as_exp(self, base, expo, **kwargs):
1248         from sympy import exp, log, I, arg
1249 
1250         if base.is_zero or base.has(exp) or expo.has(exp):
1251             return base**expo
1252 
1253         if base.has(Symbol):
1254             # delay evaluation if expo is non symbolic
1255             # (as exp(x*log(5)) automatically reduces to x**5)
1256             return exp(log(base)*expo, evaluate=expo.has(Symbol))
1257 
1258         else:
1259             return exp((log(abs(base)) + I*arg(base))*expo)
1260 
1261     def as_numer_denom(self):
1262         if not self.is_commutative:
1263             return self, S.One
1264         base, exp = self.as_base_exp()
1265         n, d = base.as_numer_denom()
1266         # this should be the same as ExpBase.as_numer_denom wrt
1267         # exponent handling
1268         neg_exp = exp.is_negative
1269         if not neg_exp and not (-exp).is_negative:
1270             neg_exp = _coeff_isneg(exp)
1271         int_exp = exp.is_integer
1272         # the denominator cannot be separated from the numerator if
1273         # its sign is unknown unless the exponent is an integer, e.g.
1274         # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the
1275         # denominator is negative the numerator and denominator can
1276         # be negated and the denominator (now positive) separated.
1277         if not (d.is_real or int_exp):
1278             n = base
1279             d = S.One
1280         dnonpos = d.is_nonpositive
1281         if dnonpos:
1282             n, d = -n, -d
1283         elif dnonpos is None and not int_exp:
1284             n = base
1285             d = S.One
1286         if neg_exp:
1287             n, d = d, n
1288             exp = -exp
1289         if exp.is_infinite:
1290             if n is S.One and d is not S.One:
1291                 return n, self.func(d, exp)
1292             if n is not S.One and d is S.One:
1293                 return self.func(n, exp), d
1294         return self.func(n, exp), self.func(d, exp)
1295 
1296     def matches(self, expr, repl_dict={}, old=False):
1297         expr = _sympify(expr)
1298 
1299         # special case, pattern = 1 and expr.exp can match to 0
1300         if expr is S.One:
1301             d = repl_dict.copy()
1302             d = self.exp.matches(S.Zero, d)
1303             if d is not None:
1304                 return d
1305 
1306         # make sure the expression to be matched is an Expr
1307         if not isinstance(expr, Expr):
1308             return None
1309 
1310         b, e = expr.as_base_exp()
1311 
1312         # special case number
1313         sb, se = self.as_base_exp()
1314         if sb.is_Symbol and se.is_Integer and expr:
1315             if e.is_rational:
1316                 return sb.matches(b**(e/se), repl_dict)
1317             return sb.matches(expr**(1/se), repl_dict)
1318 
1319         d = repl_dict.copy()
1320         d = self.base.matches(b, d)
1321         if d is None:
1322             return None
1323 
1324         d = self.exp.xreplace(d).matches(e, d)
1325         if d is None:
1326             return Expr.matches(self, expr, repl_dict)
1327         return d
1328 
1329     def _eval_nseries(self, x, n, logx):
1330         # NOTE! This function is an important part of the gruntz algorithm
1331         #       for computing limits. It has to return a generalized power
1332         #       series with coefficients in C(log, log(x)). In more detail:
1333         # It has to return an expression
1334         #     c_0*x**e_0 + c_1*x**e_1 + ... (finitely many terms)
1335         # where e_i are numbers (not necessarily integers) and c_i are
1336         # expressions involving only numbers, the log function, and log(x).
1337         from sympy import ceiling, collect, exp, log, O, Order, powsimp
1338         b, e = self.args
1339         if e.is_Integer:
1340             if e > 0:
1341                 # positive integer powers are easy to expand, e.g.:
1342                 # sin(x)**4 = (x - x**3/3 + ...)**4 = ...
1343                 return expand_multinomial(self.func(b._eval_nseries(x, n=n,
1344                     logx=logx), e), deep=False)
1345             elif e is S.NegativeOne:
1346                 # this is also easy to expand using the formula:
1347                 # 1/(1 + x) = 1 - x + x**2 - x**3 ...
1348                 # so we need to rewrite base to the form "1 + x"
1349 
1350                 nuse = n
1351                 cf = 1
1352 
1353                 try:
1354                     ord = b.as_leading_term(x)
1355                     cf = Order(ord, x).getn()
1356                     if cf and cf.is_Number:
1357                         nuse = n + 2*ceiling(cf)
1358                     else:
1359                         cf = 1
1360                 except NotImplementedError:
1361                     pass
1362 
1363                 b_orig, prefactor = b, O(1, x)
1364                 while prefactor.is_Order:
1365                     nuse += 1
1366                     b = b_orig._eval_nseries(x, n=nuse, logx=logx)
1367                     prefactor = b.as_leading_term(x)
1368 
1369                 # express "rest" as: rest = 1 + k*x**l + ... + O(x**n)
1370                 rest = expand_mul((b - prefactor)/prefactor)
1371 
1372                 if rest.is_Order:
1373                     return 1/prefactor + rest/prefactor + O(x**n, x)
1374 
1375                 k, l = rest.leadterm(x)
1376                 if l.is_Rational and l > 0:
1377                     pass
1378                 elif l.is_number and l > 0:
1379                     l = l.evalf()
1380                 elif l == 0:
1381                     k = k.simplify()
1382                     if k == 0:
1383                         # if prefactor == w**4 + x**2*w**4 + 2*x*w**4, we need to
1384                         # factor the w**4 out using collect:
1385                         return 1/collect(prefactor, x)
1386                     else:
1387                         raise NotImplementedError()
1388                 else:
1389                     raise NotImplementedError()
1390 
1391                 if cf < 0:
1392                     cf = S.One/abs(cf)
1393 
1394                 try:
1395                     dn = Order(1/prefactor, x).getn()
1396                     if dn and dn < 0:
1397                         pass
1398                     else:
1399                         dn = 0
1400                 except NotImplementedError:
1401                     dn = 0
1402 
1403                 terms = [1/prefactor]
1404                 for m in range(1, ceiling((n - dn + 1)/l*cf)):
1405                     new_term = terms[-1]*(-rest)
1406                     if new_term.is_Pow:
1407                         new_term = new_term._eval_expand_multinomial(
1408                             deep=False)
1409                     else:
1410                         new_term = expand_mul(new_term, deep=False)
1411                     terms.append(new_term)
1412                 terms.append(O(x**n, x))
1413                 return powsimp(Add(*terms), deep=True, combine='exp')
1414             else:
1415                 # negative powers are rewritten to the cases above, for
1416                 # example:
1417                 # sin(x)**(-4) = 1/(sin(x)**4) = ...
1418                 # and expand the denominator:
1419                 nuse, denominator = n, O(1, x)
1420                 while denominator.is_Order:
1421                     denominator = (b**(-e))._eval_nseries(x, n=nuse, logx=logx)
1422                     nuse += 1
1423                 if 1/denominator == self:
1424                     return self
1425                 # now we have a type 1/f(x), that we know how to expand
1426                 return (1/denominator)._eval_nseries(x, n=n, logx=logx)
1427 
1428         if e.has(Symbol):
1429             return exp(e*log(b))._eval_nseries(x, n=n, logx=logx)
1430 
1431         # see if the base is as simple as possible
1432         bx = b
1433         while bx.is_Pow and bx.exp.is_Rational:
1434             bx = bx.base
1435         if bx == x:
1436             return self
1437 
1438         # work for b(x)**e where e is not an Integer and does not contain x
1439         # and hopefully has no other symbols
1440 
1441         def e2int(e):
1442             """return the integer value (if possible) of e and a
1443             flag indicating whether it is bounded or not."""
1444             n = e.limit(x, 0)
1445             infinite = n.is_infinite
1446             if not infinite:
1447                 # XXX was int or floor intended? int used to behave like floor
1448                 # so int(-Rational(1, 2)) returned -1 rather than int's 0
1449                 try:
1450                     n = int(n)
1451                 except TypeError:
1452                     # well, the n is something more complicated (like 1 + log(2))
1453                     try:
1454                         n = int(n.evalf()) + 1  # XXX why is 1 being added?
1455                     except TypeError:
1456                         pass  # hope that base allows this to be resolved
1457                 n = _sympify(n)
1458             return n, infinite
1459 
1460         order = O(x**n, x)
1461         ei, infinite = e2int(e)
1462         b0 = b.limit(x, 0)
1463         if infinite and (b0 is S.One or b0.has(Symbol)):
1464             # XXX what order
1465             if b0 is S.One:
1466                 resid = (b - 1)
1467                 if resid.is_positive:
1468                     return S.Infinity
1469                 elif resid.is_negative:
1470                     return S.Zero
1471                 raise ValueError('cannot determine sign of %s' % resid)
1472 
1473             return b0**ei
1474 
1475         if (b0 is S.Zero or b0.is_infinite):
1476             if infinite is not False:
1477                 return b0**e  # XXX what order
1478 
1479             if not ei.is_number:  # if not, how will we proceed?
1480                 raise ValueError(
1481                     'expecting numerical exponent but got %s' % ei)
1482 
1483             nuse = n - ei
1484 
1485             if e.is_real and e.is_positive:
1486                 lt = b.as_leading_term(x)
1487 
1488                 # Try to correct nuse (= m) guess from:
1489                 # (lt + rest + O(x**m))**e =
1490                 # lt**e*(1 + rest/lt + O(x**m)/lt)**e =
1491                 # lt**e + ... + O(x**m)*lt**(e - 1) = ... + O(x**n)
1492                 try:
1493                     cf = Order(lt, x).getn()
1494                     nuse = ceiling(n - cf*(e - 1))
1495                 except NotImplementedError:
1496                     pass
1497 
1498             bs = b._eval_nseries(x, n=nuse, logx=logx)
1499             terms = bs.removeO()
1500             if terms.is_Add:
1501                 bs = terms
1502                 lt = terms.as_leading_term(x)
1503 
1504                 # bs -> lt + rest -> lt*(1 + (bs/lt - 1))
1505                 return ((self.func(lt, e) * self.func((bs/lt).expand(), e).nseries(
1506                     x, n=nuse, logx=logx)).expand() + order)
1507 
1508             if bs.is_Add:
1509                 from sympy import O
1510                 # So, bs + O() == terms
1511                 c = Dummy('c')
1512                 res = []
1513                 for arg in bs.args:
1514                     if arg.is_Order:
1515                         arg = c*arg.expr
1516                     res.append(arg)
1517                 bs = Add(*res)
1518                 rv = (bs**e).series(x).subs(c, O(1, x))
1519                 rv += order
1520                 return rv
1521 
1522             rv = bs**e
1523             if terms != bs:
1524                 rv += order
1525             return rv
1526 
1527         # either b0 is bounded but neither 1 nor 0 or e is infinite
1528         # b -> b0 + (b - b0) -> b0 * (1 + (b/b0 - 1))
1529         o2 = order*(b0**-e)
1530         z = (b/b0 - 1)
1531         o = O(z, x)
1532         if o is S.Zero or o2 is S.Zero:
1533             infinite = True
1534         else:
1535             if o.expr.is_number:
1536                 e2 = log(o2.expr*x)/log(x)
1537             else:
1538                 e2 = log(o2.expr)/log(o.expr)
1539             n, infinite = e2int(e2)
1540         if infinite:
1541             # requested accuracy gives infinite series,
1542             # order is probably non-polynomial e.g. O(exp(-1/x), x).
1543             r = 1 + z
1544         else:
1545             l = []
1546             g = None
1547             for i in range(n + 2):
1548                 g = self._taylor_term(i, z, g)
1549                 g = g.nseries(x, n=n, logx=logx)
1550                 l.append(g)
1551             r = Add(*l)
1552         return expand_mul(r*b0**e) + order
1553 
1554     def _eval_as_leading_term(self, x):
1555         from sympy import exp, log
1556         if not self.exp.has(x):
1557             return self.func(self.base.as_leading_term(x), self.exp)
1558         return exp(self.exp * log(self.base)).as_leading_term(x)
1559 
1560     @cacheit
1561     def _taylor_term(self, n, x, *previous_terms): # of (1 + x)**e
1562         from sympy import binomial
1563         return binomial(self.exp, n) * self.func(x, n)
1564 
1565     def _sage_(self):
1566         return self.args[0]._sage_()**self.args[1]._sage_()
1567 
1568     def as_content_primitive(self, radical=False, clear=True):
1569         """Return the tuple (R, self/R) where R is the positive Rational
1570         extracted from self.
1571 
1572         Examples
1573         ========
1574 
1575         >>> from sympy import sqrt
1576         >>> sqrt(4 + 4*sqrt(2)).as_content_primitive()
1577         (2, sqrt(1 + sqrt(2)))
1578         >>> sqrt(3 + 3*sqrt(2)).as_content_primitive()
1579         (1, sqrt(3)*sqrt(1 + sqrt(2)))
1580 
1581         >>> from sympy import expand_power_base, powsimp, Mul
1582         >>> from sympy.abc import x, y
1583 
1584         >>> ((2*x + 2)**2).as_content_primitive()
1585         (4, (x + 1)**2)
1586         >>> (4**((1 + y)/2)).as_content_primitive()
1587         (2, 4**(y/2))
1588         >>> (3**((1 + y)/2)).as_content_primitive()
1589         (1, 3**((y + 1)/2))
1590         >>> (3**((5 + y)/2)).as_content_primitive()
1591         (9, 3**((y + 1)/2))
1592         >>> eq = 3**(2 + 2*x)
1593         >>> powsimp(eq) == eq
1594         True
1595         >>> eq.as_content_primitive()
1596         (9, 3**(2*x))
1597         >>> powsimp(Mul(*_))
1598         3**(2*x + 2)
1599 
1600         >>> eq = (2 + 2*x)**y
1601         >>> s = expand_power_base(eq); s.is_Mul, s
1602         (False, (2*x + 2)**y)
1603         >>> eq.as_content_primitive()
1604         (1, (2*(x + 1))**y)
1605         >>> s = expand_power_base(_[1]); s.is_Mul, s
1606         (True, 2**y*(x + 1)**y)
1607 
1608         See docstring of Expr.as_content_primitive for more examples.
1609         """
1610 
1611         b, e = self.as_base_exp()
1612         b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))
1613         ce, pe = e.as_content_primitive(radical=radical, clear=clear)
1614         if b.is_Rational:
1615             #e
1616             #= ce*pe
1617             #= ce*(h + t)
1618             #= ce*h + ce*t
1619             #=> self
1620             #= b**(ce*h)*b**(ce*t)
1621             #= b**(cehp/cehq)*b**(ce*t)
1622             #= b**(iceh + r/cehq)*b**(ce*t)
1623             #= b**(iceh)*b**(r/cehq)*b**(ce*t)
1624             #= b**(iceh)*b**(ce*t + r/cehq)
1625             h, t = pe.as_coeff_Add()
1626             if h.is_Rational:
1627                 ceh = ce*h
1628                 c = self.func(b, ceh)
1629                 r = S.Zero
1630                 if not c.is_Rational:
1631                     iceh, r = divmod(ceh.p, ceh.q)
1632                     c = self.func(b, iceh)
1633                 return c, self.func(b, _keep_coeff(ce, t + r/ce/ceh.q))
1634         e = _keep_coeff(ce, pe)
1635         # b**e = (h*t)**e = h**e*t**e = c*m*t**e
1636         if e.is_Rational and b.is_Mul:
1637             h, t = b.as_content_primitive(radical=radical, clear=clear)  # h is positive
1638             c, m = self.func(h, e).as_coeff_Mul()  # so c is positive
1639             m, me = m.as_base_exp()
1640             if m is S.One or me == e:  # probably always true
1641                 # return the following, not return c, m*Pow(t, e)
1642                 # which would change Pow into Mul; we let sympy
1643                 # decide what to do by using the unevaluated Mul, e.g
1644                 # should it stay as sqrt(2 + 2*sqrt(5)) or become
1645                 # sqrt(2)*sqrt(1 + sqrt(5))
1646                 return c, self.func(_keep_coeff(m, t), e)
1647         return S.One, self.func(b, e)
1648 
1649     def is_constant(self, *wrt, **flags):
1650         expr = self
1651         if flags.get('simplify', True):
1652             expr = expr.simplify()
1653         b, e = expr.as_base_exp()
1654         bz = b.equals(0)
1655         if bz:  # recalculate with assumptions in case it's unevaluated
1656             new = b**e
1657             if new != expr:
1658                 return new.is_constant()
1659         econ = e.is_constant(*wrt)
1660         bcon = b.is_constant(*wrt)
1661         if bcon:
1662             if econ:
1663                 return True
1664             bz = b.equals(0)
1665             if bz is False:
1666                 return False
1667         elif bcon is None:
1668             return None
1669 
1670         return e.equals(0)
1671 
1672     def _eval_difference_delta(self, n, step):
1673         b, e = self.args
1674         if e.has(n) and not b.has(n):
1675             new_e = e.subs(n, n + step)
1676             return (b**(new_e - e) - 1) * self
1677 
1678 
1679 from .add import Add
1680 from .numbers import Integer
1681 from .mul import Mul, _keep_coeff
1682 from .symbol import Symbol, Dummy, symbols

</code><intended_behavior>Correctly evaluate and simplify expressions involving division and power operation to avoid misinterpretations or errors, specifically ensuring that floor division is handled in line with Python's arithmetic rules when applicable.</intended_behavior>]
2025-10-17 20:42:19.025 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 20:42:19.025 | INFO     | Search-only: skipping patch selection
2025-10-17 20:42:19.110 | INFO     | Task sympy__sympy-16840 completed successfully.
2025-10-17 20:42:19.111 | INFO     | No patch generated. You can try running ACR again.
