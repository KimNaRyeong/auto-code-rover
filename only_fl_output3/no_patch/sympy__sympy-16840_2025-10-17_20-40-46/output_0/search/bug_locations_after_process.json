[
    {
        "rel_file_path": "sympy/core/numbers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/core/numbers.py",
        "start": 1,
        "end": 3861,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import absolute_import, print_function, division\n2 \n3 import numbers\n4 import decimal\n5 import fractions\n6 import math\n7 import re as regex\n8 \n9 from .containers import Tuple\n10 from .sympify import converter, sympify, _sympify, SympifyError, _convert_numpy_types\n11 from .singleton import S, Singleton\n12 from .expr import Expr, AtomicExpr\n13 from .decorators import _sympifyit\n14 from .cache import cacheit, clear_cache\n15 from .logic import fuzzy_not\n16 from sympy.core.compatibility import (\n17     as_int, integer_types, long, string_types, with_metaclass, HAS_GMPY,\n18     SYMPY_INTS, int_info)\n19 from sympy.core.cache import lru_cache\n20 \n21 import mpmath\n22 import mpmath.libmp as mlib\n23 from mpmath.libmp.backend import MPZ\n24 from mpmath.libmp import mpf_pow, mpf_pi, mpf_e, phi_fixed\n25 from mpmath.ctx_mp import mpnumeric\n26 from mpmath.libmp.libmpf import (\n27     finf as _mpf_inf, fninf as _mpf_ninf,\n28     fnan as _mpf_nan, fzero as _mpf_zero, _normalize as mpf_normalize,\n29     prec_to_dps)\n30 from sympy.utilities.misc import debug, filldedent\n31 from .evaluate import global_evaluate\n32 \n33 from sympy.utilities.exceptions import SymPyDeprecationWarning\n34 \n35 rnd = mlib.round_nearest\n36 \n37 _LOG2 = math.log(2)\n38 \n39 \n40 def comp(z1, z2, tol=None):\n41     \"\"\"Return a bool indicating whether the error between z1 and z2 is <= tol.\n42 \n43     If ``tol`` is None then True will be returned if there is a significant\n44     difference between the numbers: ``abs(z1 - z2)*10**p <= 1/2`` where ``p``\n45     is the lower of the precisions of the values. A comparison of strings will\n46     be made if ``z1`` is a Number and a) ``z2`` is a string or b) ``tol`` is ''\n47     and ``z2`` is a Number.\n48 \n49     When ``tol`` is a nonzero value, if z2 is non-zero and ``|z1| > 1``\n50     the error is normalized by ``|z1|``, so if you want to see if the\n51     absolute error between ``z1`` and ``z2`` is <= ``tol`` then call this\n52     as ``comp(z1 - z2, 0, tol)``.\n53     \"\"\"\n54     if type(z2) is str:\n55         if not isinstance(z1, Number):\n56             raise ValueError('when z2 is a str z1 must be a Number')\n57         return str(z1) == z2\n58     if not z1:\n59         z1, z2 = z2, z1\n60     if not z1:\n61         return True\n62     if not tol:\n63         if tol is None:\n64             if type(z2) is str and getattr(z1, 'is_Number', False):\n65                 return str(z1) == z2\n66             a, b = Float(z1), Float(z2)\n67             return int(abs(a - b)*10**prec_to_dps(\n68                 min(a._prec, b._prec)))*2 <= 1\n69         elif all(getattr(i, 'is_Number', False) for i in (z1, z2)):\n70             return z1._prec == z2._prec and str(z1) == str(z2)\n71         raise ValueError('exact comparison requires two Numbers')\n72     diff = abs(z1 - z2)\n73     az1 = abs(z1)\n74     if z2 and az1 > 1:\n75         return diff/az1 <= tol\n76     else:\n77         return diff <= tol\n78 \n79 \n80 def mpf_norm(mpf, prec):\n81     \"\"\"Return the mpf tuple normalized appropriately for the indicated\n82     precision after doing a check to see if zero should be returned or\n83     not when the mantissa is 0. ``mpf_normlize`` always assumes that this\n84     is zero, but it may not be since the mantissa for mpf's values \"+inf\",\n85     \"-inf\" and \"nan\" have a mantissa of zero, too.\n86 \n87     Note: this is not intended to validate a given mpf tuple, so sending\n88     mpf tuples that were not created by mpmath may produce bad results. This\n89     is only a wrapper to ``mpf_normalize`` which provides the check for non-\n90     zero mpfs that have a 0 for the mantissa.\n91     \"\"\"\n92     sign, man, expt, bc = mpf\n93     if not man:\n94         # hack for mpf_normalize which does not do this;\n95         # it assumes that if man is zero the result is 0\n96         # (see issue 6639)\n97         if not bc:\n98             return _mpf_zero\n99         else:\n100             # don't change anything; this should already\n101             # be a well formed mpf tuple\n102             return mpf\n103 \n104     # Necessary if mpmath is using the gmpy backend\n105     from mpmath.libmp.backend import MPZ\n106     rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n107     return rv\n108 \n109 # TODO: we should use the warnings module\n110 _errdict = {\"divide\": False}\n111 \n112 \n113 def seterr(divide=False):\n114     \"\"\"\n115     Should sympy raise an exception on 0/0 or return a nan?\n116 \n117     divide == True .... raise an exception\n118     divide == False ... return nan\n119     \"\"\"\n120     if _errdict[\"divide\"] != divide:\n121         clear_cache()\n122         _errdict[\"divide\"] = divide\n123 \n124 \n125 def _as_integer_ratio(p):\n126     neg_pow, man, expt, bc = getattr(p, '_mpf_', mpmath.mpf(p)._mpf_)\n127     p = [1, -1][neg_pow % 2]*man\n128     if expt < 0:\n129         q = 2**-expt\n130     else:\n131         q = 1\n132         p *= 2**expt\n133     return int(p), int(q)\n134 \n135 \n136 def _decimal_to_Rational_prec(dec):\n137     \"\"\"Convert an ordinary decimal instance to a Rational.\"\"\"\n138     if not dec.is_finite():\n139         raise TypeError(\"dec must be finite, got %s.\" % dec)\n140     s, d, e = dec.as_tuple()\n141     prec = len(d)\n142     if e >= 0:  # it's an integer\n143         rv = Integer(int(dec))\n144     else:\n145         s = (-1)**s\n146         d = sum([di*10**i for i, di in enumerate(reversed(d))])\n147         rv = Rational(s*d, 10**-e)\n148     return rv, prec\n149 \n150 \n151 _floatpat = regex.compile(r\"[-+]?((\\d*\\.\\d+)|(\\d+\\.?))\")\n152 def _literal_float(f):\n153     \"\"\"Return True if n starts like a floating point number.\"\"\"\n154     return bool(_floatpat.match(f))\n155 \n156 # (a,b) -> gcd(a,b)\n157 \n158 # TODO caching with decorator, but not to degrade performance\n159 \n160 @lru_cache(1024)\n161 def igcd(*args):\n162     \"\"\"Computes nonnegative integer greatest common divisor.\n163 \n164     The algorithm is based on the well known Euclid's algorithm. To\n165     improve speed, igcd() has its own caching mechanism implemented.\n166 \n167     Examples\n168     ========\n169 \n170     >>> from sympy.core.numbers import igcd\n171     >>> igcd(2, 4)\n172     2\n173     >>> igcd(5, 10, 15)\n174     5\n175 \n176     \"\"\"\n177     if len(args) < 2:\n178         raise TypeError(\n179             'igcd() takes at least 2 arguments (%s given)' % len(args))\n180     args_temp = [abs(as_int(i)) for i in args]\n181     if 1 in args_temp:\n182         return 1\n183     a = args_temp.pop()\n184     for b in args_temp:\n185         a = igcd2(a, b) if b else a\n186     return a\n187 \n188 \n189 try:\n190     from math import gcd as igcd2\n191 except ImportError:\n192     def igcd2(a, b):\n193         \"\"\"Compute gcd of two Python integers a and b.\"\"\"\n194         if (a.bit_length() > BIGBITS and\n195             b.bit_length() > BIGBITS):\n196             return igcd_lehmer(a, b)\n197 \n198         a, b = abs(a), abs(b)\n199         while b:\n200             a, b = b, a % b\n201         return a\n202 \n203 \n204 # Use Lehmer's algorithm only for very large numbers.\n205 # The limit could be different on Python 2.7 and 3.x.\n206 # If so, then this could be defined in compatibility.py.\n207 BIGBITS = 5000\n208 def igcd_lehmer(a, b):\n209     \"\"\"Computes greatest common divisor of two integers.\n210 \n211     Euclid's algorithm for the computation of the greatest\n212     common divisor  gcd(a, b)  of two (positive) integers\n213     a and b is based on the division identity\n214         a = q*b + r,\n215     where the quotient  q  and the remainder  r  are integers\n216     and  0 <= r < b. Then each common divisor of  a  and  b\n217     divides  r, and it follows that  gcd(a, b) == gcd(b, r).\n218     The algorithm works by constructing the sequence\n219     r0, r1, r2, ..., where  r0 = a, r1 = b,  and each  rn\n220     is the remainder from the division of the two preceding\n221     elements.\n222 \n223     In Python, q = a // b  and  r = a % b  are obtained by the\n224     floor division and the remainder operations, respectively.\n225     These are the most expensive arithmetic operations, especially\n226     for large  a  and  b.\n227 \n228     Lehmer's algorithm is based on the observation that the quotients\n229     qn = r(n-1) // rn  are in general small integers even\n230     when  a  and  b  are very large. Hence the quotients can be\n231     usually determined from a relatively small number of most\n232     significant bits.\n233 \n234     The efficiency of the algorithm is further enhanced by not\n235     computing each long remainder in Euclid's sequence. The remainders\n236     are linear combinations of  a  and  b  with integer coefficients\n237     derived from the quotients. The coefficients can be computed\n238     as far as the quotients can be determined from the chosen\n239     most significant parts of  a  and  b. Only then a new pair of\n240     consecutive remainders is computed and the algorithm starts\n241     anew with this pair.\n242 \n243     References\n244     ==========\n245 \n246     .. [1] https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm\n247 \n248     \"\"\"\n249     a, b = abs(as_int(a)), abs(as_int(b))\n250     if a < b:\n251         a, b = b, a\n252 \n253     # The algorithm works by using one or two digit division\n254     # whenever possible. The outer loop will replace the\n255     # pair (a, b) with a pair of shorter consecutive elements\n256     # of the Euclidean gcd sequence until a and b\n257     # fit into two Python (long) int digits.\n258     nbits = 2*int_info.bits_per_digit\n259 \n260     while a.bit_length() > nbits and b != 0:\n261         # Quotients are mostly small integers that can\n262         # be determined from most significant bits.\n263         n = a.bit_length() - nbits\n264         x, y = int(a >> n), int(b >> n)  # most significant bits\n265 \n266         # Elements of the Euclidean gcd sequence are linear\n267         # combinations of a and b with integer coefficients.\n268         # Compute the coefficients of consecutive pairs\n269         #     a' = A*a + B*b, b' = C*a + D*b\n270         # using small integer arithmetic as far as possible.\n271         A, B, C, D = 1, 0, 0, 1  # initial values\n272 \n273         while True:\n274             # The coefficients alternate in sign while looping.\n275             # The inner loop combines two steps to keep track\n276             # of the signs.\n277 \n278             # At this point we have\n279             #   A > 0, B <= 0, C <= 0, D > 0,\n280             #   x' = x + B <= x < x\" = x + A,\n281             #   y' = y + C <= y < y\" = y + D,\n282             # and\n283             #   x'*N <= a' < x\"*N, y'*N <= b' < y\"*N,\n284             # where N = 2**n.\n285 \n286             # Now, if y' > 0, and x\"//y' and x'//y\" agree,\n287             # then their common value is equal to  q = a'//b'.\n288             # In addition,\n289             #   x'%y\" = x' - q*y\" < x\" - q*y' = x\"%y',\n290             # and\n291             #   (x'%y\")*N < a'%b' < (x\"%y')*N.\n292 \n293             # On the other hand, we also have  x//y == q,\n294             # and therefore\n295             #   x'%y\" = x + B - q*(y + D) = x%y + B',\n296             #   x\"%y' = x + A - q*(y + C) = x%y + A',\n297             # where\n298             #    B' = B - q*D < 0, A' = A - q*C > 0.\n299 \n300             if y + C <= 0:\n301                 break\n302             q = (x + A) // (y + C)\n303 \n304             # Now  x'//y\" <= q, and equality holds if\n305             #   x' - q*y\" = (x - q*y) + (B - q*D) >= 0.\n306             # This is a minor optimization to avoid division.\n307             x_qy, B_qD = x - q*y, B - q*D\n308             if x_qy + B_qD < 0:\n309                 break\n310 \n311             # Next step in the Euclidean sequence.\n312             x, y = y, x_qy\n313             A, B, C, D = C, D, A - q*C, B_qD\n314 \n315             # At this point the signs of the coefficients\n316             # change and their roles are interchanged.\n317             #   A <= 0, B > 0, C > 0, D < 0,\n318             #   x' = x + A <= x < x\" = x + B,\n319             #   y' = y + D < y < y\" = y + C.\n320 \n321             if y + D <= 0:\n322                 break\n323             q = (x + B) // (y + D)\n324             x_qy, A_qC = x - q*y, A - q*C\n325             if x_qy + A_qC < 0:\n326                 break\n327 \n328             x, y = y, x_qy\n329             A, B, C, D = C, D, A_qC, B - q*D\n330             # Now the conditions on top of the loop\n331             # are again satisfied.\n332             #   A > 0, B < 0, C < 0, D > 0.\n333 \n334         if B == 0:\n335             # This can only happen when y == 0 in the beginning\n336             # and the inner loop does nothing.\n337             # Long division is forced.\n338             a, b = b, a % b\n339             continue\n340 \n341         # Compute new long arguments using the coefficients.\n342         a, b = A*a + B*b, C*a + D*b\n343 \n344     # Small divisors. Finish with the standard algorithm.\n345     while b:\n346         a, b = b, a % b\n347 \n348     return a\n349 \n350 \n351 def ilcm(*args):\n352     \"\"\"Computes integer least common multiple.\n353 \n354     Examples\n355     ========\n356 \n357     >>> from sympy.core.numbers import ilcm\n358     >>> ilcm(5, 10)\n359     10\n360     >>> ilcm(7, 3)\n361     21\n362     >>> ilcm(5, 10, 15)\n363     30\n364 \n365     \"\"\"\n366     if len(args) < 2:\n367         raise TypeError(\n368             'ilcm() takes at least 2 arguments (%s given)' % len(args))\n369     if 0 in args:\n370         return 0\n371     a = args[0]\n372     for b in args[1:]:\n373         a = a // igcd(a, b) * b # since gcd(a,b) | a\n374     return a\n375 \n376 \n377 def igcdex(a, b):\n378     \"\"\"Returns x, y, g such that g = x*a + y*b = gcd(a, b).\n379 \n380        >>> from sympy.core.numbers import igcdex\n381        >>> igcdex(2, 3)\n382        (-1, 1, 1)\n383        >>> igcdex(10, 12)\n384        (-1, 1, 2)\n385 \n386        >>> x, y, g = igcdex(100, 2004)\n387        >>> x, y, g\n388        (-20, 1, 4)\n389        >>> x*100 + y*2004\n390        4\n391 \n392     \"\"\"\n393     if (not a) and (not b):\n394         return (0, 1, 0)\n395 \n396     if not a:\n397         return (0, b//abs(b), abs(b))\n398     if not b:\n399         return (a//abs(a), 0, abs(a))\n400 \n401     if a < 0:\n402         a, x_sign = -a, -1\n403     else:\n404         x_sign = 1\n405 \n406     if b < 0:\n407         b, y_sign = -b, -1\n408     else:\n409         y_sign = 1\n410 \n411     x, y, r, s = 1, 0, 0, 1\n412 \n413     while b:\n414         (c, q) = (a % b, a // b)\n415         (a, b, r, s, x, y) = (b, c, x - q*r, y - q*s, r, s)\n416 \n417     return (x*x_sign, y*y_sign, a)\n418 \n419 \n420 def mod_inverse(a, m):\n421     \"\"\"\n422     Return the number c such that, (a * c) = 1 (mod m)\n423     where c has the same sign as m. If no such value exists,\n424     a ValueError is raised.\n425 \n426     Examples\n427     ========\n428 \n429     >>> from sympy import S\n430     >>> from sympy.core.numbers import mod_inverse\n431 \n432     Suppose we wish to find multiplicative inverse x of\n433     3 modulo 11. This is the same as finding x such\n434     that 3 * x = 1 (mod 11). One value of x that satisfies\n435     this congruence is 4. Because 3 * 4 = 12 and 12 = 1 (mod 11).\n436     This is the value return by mod_inverse:\n437 \n438     >>> mod_inverse(3, 11)\n439     4\n440     >>> mod_inverse(-3, 11)\n441     7\n442 \n443     When there is a common factor between the numerators of\n444     ``a`` and ``m`` the inverse does not exist:\n445 \n446     >>> mod_inverse(2, 4)\n447     Traceback (most recent call last):\n448     ...\n449     ValueError: inverse of 2 mod 4 does not exist\n450 \n451     >>> mod_inverse(S(2)/7, S(5)/2)\n452     7/2\n453 \n454     References\n455     ==========\n456     - https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\n457     - https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm\n458     \"\"\"\n459     c = None\n460     try:\n461         a, m = as_int(a), as_int(m)\n462         if m != 1 and m != -1:\n463             x, y, g = igcdex(a, m)\n464             if g == 1:\n465                 c = x % m\n466     except ValueError:\n467         a, m = sympify(a), sympify(m)\n468         if not (a.is_number and m.is_number):\n469             raise TypeError(filldedent('''\n470                 Expected numbers for arguments; symbolic `mod_inverse`\n471                 is not implemented\n472                 but symbolic expressions can be handled with the\n473                 similar function,\n474                 sympy.polys.polytools.invert'''))\n475         big = (m > 1)\n476         if not (big is S.true or big is S.false):\n477             raise ValueError('m > 1 did not evaluate; try to simplify %s' % m)\n478         elif big:\n479             c = 1/a\n480     if c is None:\n481         raise ValueError('inverse of %s (mod %s) does not exist' % (a, m))\n482     return c\n483 \n484 \n485 class Number(AtomicExpr):\n486     \"\"\"Represents atomic numbers in SymPy.\n487 \n488     Floating point numbers are represented by the Float class.\n489     Rational numbers (of any size) are represented by the Rational class.\n490     Integer numbers (of any size) are represented by the Integer class.\n491     Float and Rational are subclasses of Number; Integer is a subclass\n492     of Rational.\n493 \n494     For example, ``2/3`` is represented as ``Rational(2, 3)`` which is\n495     a different object from the floating point number obtained with\n496     Python division ``2/3``. Even for numbers that are exactly\n497     represented in binary, there is a difference between how two forms,\n498     such as ``Rational(1, 2)`` and ``Float(0.5)``, are used in SymPy.\n499     The rational form is to be preferred in symbolic computations.\n500 \n501     Other kinds of numbers, such as algebraic numbers ``sqrt(2)`` or\n502     complex numbers ``3 + 4*I``, are not instances of Number class as\n503     they are not atomic.\n504 \n505     See Also\n506     ========\n507 \n508     Float, Integer, Rational\n509     \"\"\"\n510     is_commutative = True\n511     is_number = True\n512     is_Number = True\n513 \n514     __slots__ = []\n515 \n516     # Used to make max(x._prec, y._prec) return x._prec when only x is a float\n517     _prec = -1\n518 \n519     def __new__(cls, *obj):\n520         if len(obj) == 1:\n521             obj = obj[0]\n522 \n523         if isinstance(obj, Number):\n524             return obj\n525         if isinstance(obj, SYMPY_INTS):\n526             return Integer(obj)\n527         if isinstance(obj, tuple) and len(obj) == 2:\n528             return Rational(*obj)\n529         if isinstance(obj, (float, mpmath.mpf, decimal.Decimal)):\n530             return Float(obj)\n531         if isinstance(obj, string_types):\n532             val = sympify(obj)\n533             if isinstance(val, Number):\n534                 return val\n535             else:\n536                 raise ValueError('String \"%s\" does not denote a Number' % obj)\n537         msg = \"expected str|int|long|float|Decimal|Number object but got %r\"\n538         raise TypeError(msg % type(obj).__name__)\n539 \n540     def invert(self, other, *gens, **args):\n541         from sympy.polys.polytools import invert\n542         if getattr(other, 'is_number', True):\n543             return mod_inverse(self, other)\n544         return invert(self, other, *gens, **args)\n545 \n546     def __divmod__(self, other):\n547         from .containers import Tuple\n548 \n549         try:\n550             other = Number(other)\n551         except TypeError:\n552             msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n553             raise TypeError(msg % (type(self).__name__, type(other).__name__))\n554         if not other:\n555             raise ZeroDivisionError('modulo by zero')\n556         if self.is_Integer and other.is_Integer:\n557             return Tuple(*divmod(self.p, other.p))\n558         else:\n559             rat = self/other\n560         w = int(rat) if rat > 0 else int(rat) - 1\n561         r = self - other*w\n562         return Tuple(w, r)\n563 \n564     def __rdivmod__(self, other):\n565         try:\n566             other = Number(other)\n567         except TypeError:\n568             msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n569             raise TypeError(msg % (type(other).__name__, type(self).__name__))\n570         return divmod(other, self)\n571 \n572     def _as_mpf_val(self, prec):\n573         \"\"\"Evaluation of mpf tuple accurate to at least prec bits.\"\"\"\n574         raise NotImplementedError('%s needs ._as_mpf_val() method' %\n575             (self.__class__.__name__))\n576 \n577     def _eval_evalf(self, prec):\n578         return Float._new(self._as_mpf_val(prec), prec)\n579 \n580     def _as_mpf_op(self, prec):\n581         prec = max(prec, self._prec)\n582         return self._as_mpf_val(prec), prec\n583 \n584     def __float__(self):\n585         return mlib.to_float(self._as_mpf_val(53))\n586 \n587     def floor(self):\n588         raise NotImplementedError('%s needs .floor() method' %\n589             (self.__class__.__name__))\n590 \n591     def ceiling(self):\n592         raise NotImplementedError('%s needs .ceiling() method' %\n593             (self.__class__.__name__))\n594 \n595     def __floor__(self):\n596         return self.floor()\n597 \n598     def __ceil__(self):\n599         return self.ceiling()\n600 \n601     def _eval_conjugate(self):\n602         return self\n603 \n604     def _eval_order(self, *symbols):\n605         from sympy import Order\n606         # Order(5, x, y) -> Order(1,x,y)\n607         return Order(S.One, *symbols)\n608 \n609     def _eval_subs(self, old, new):\n610         if old == -self:\n611             return -new\n612         return self  # there is no other possibility\n613 \n614     def _eval_is_finite(self):\n615         return True\n616 \n617     @classmethod\n618     def class_key(cls):\n619         return 1, 0, 'Number'\n620 \n621     @cacheit\n622     def sort_key(self, order=None):\n623         return self.class_key(), (0, ()), (), self\n624 \n625     @_sympifyit('other', NotImplemented)\n626     def __add__(self, other):\n627         if isinstance(other, Number) and global_evaluate[0]:\n628             if other is S.NaN:\n629                 return S.NaN\n630             elif other is S.Infinity:\n631                 return S.Infinity\n632             elif other is S.NegativeInfinity:\n633                 return S.NegativeInfinity\n634         return AtomicExpr.__add__(self, other)\n635 \n636     @_sympifyit('other', NotImplemented)\n637     def __sub__(self, other):\n638         if isinstance(other, Number) and global_evaluate[0]:\n639             if other is S.NaN:\n640                 return S.NaN\n641             elif other is S.Infinity:\n642                 return S.NegativeInfinity\n643             elif other is S.NegativeInfinity:\n644                 return S.Infinity\n645         return AtomicExpr.__sub__(self, other)\n646 \n647     @_sympifyit('other', NotImplemented)\n648     def __mul__(self, other):\n649         if isinstance(other, Number) and global_evaluate[0]:\n650             if other is S.NaN:\n651                 return S.NaN\n652             elif other is S.Infinity:\n653                 if self.is_zero:\n654                     return S.NaN\n655                 elif self.is_positive:\n656                     return S.Infinity\n657                 else:\n658                     return S.NegativeInfinity\n659             elif other is S.NegativeInfinity:\n660                 if self.is_zero:\n661                     return S.NaN\n662                 elif self.is_positive:\n663                     return S.NegativeInfinity\n664                 else:\n665                     return S.Infinity\n666         elif isinstance(other, Tuple):\n667             return NotImplemented\n668         return AtomicExpr.__mul__(self, other)\n669 \n670     @_sympifyit('other', NotImplemented)\n671     def __div__(self, other):\n672         if isinstance(other, Number) and global_evaluate[0]:\n673             if other is S.NaN:\n674                 return S.NaN\n675             elif other is S.Infinity or other is S.NegativeInfinity:\n676                 return S.Zero\n677         return AtomicExpr.__div__(self, other)\n678 \n679     __truediv__ = __div__\n680 \n681     def __eq__(self, other):\n682         raise NotImplementedError('%s needs .__eq__() method' %\n683             (self.__class__.__name__))\n684 \n685     def __ne__(self, other):\n686         raise NotImplementedError('%s needs .__ne__() method' %\n687             (self.__class__.__name__))\n688 \n689     def __lt__(self, other):\n690         try:\n691             other = _sympify(other)\n692         except SympifyError:\n693             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n694         raise NotImplementedError('%s needs .__lt__() method' %\n695             (self.__class__.__name__))\n696 \n697     def __le__(self, other):\n698         try:\n699             other = _sympify(other)\n700         except SympifyError:\n701             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n702         raise NotImplementedError('%s needs .__le__() method' %\n703             (self.__class__.__name__))\n704 \n705     def __gt__(self, other):\n706         try:\n707             other = _sympify(other)\n708         except SympifyError:\n709             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n710         return _sympify(other).__lt__(self)\n711 \n712     def __ge__(self, other):\n713         try:\n714             other = _sympify(other)\n715         except SympifyError:\n716             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n717         return _sympify(other).__le__(self)\n718 \n719     def __hash__(self):\n720         return super(Number, self).__hash__()\n721 \n722     def is_constant(self, *wrt, **flags):\n723         return True\n724 \n725     def as_coeff_mul(self, *deps, **kwargs):\n726         # a -> c*t\n727         if self.is_Rational or not kwargs.pop('rational', True):\n728             return self, tuple()\n729         elif self.is_negative:\n730             return S.NegativeOne, (-self,)\n731         return S.One, (self,)\n732 \n733     def as_coeff_add(self, *deps):\n734         # a -> c + t\n735         if self.is_Rational:\n736             return self, tuple()\n737         return S.Zero, (self,)\n738 \n739     def as_coeff_Mul(self, rational=False):\n740         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n741         if rational and not self.is_Rational:\n742             return S.One, self\n743         return (self, S.One) if self else (S.One, self)\n744 \n745     def as_coeff_Add(self, rational=False):\n746         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n747         if not rational:\n748             return self, S.Zero\n749         return S.Zero, self\n750 \n751     def gcd(self, other):\n752         \"\"\"Compute GCD of `self` and `other`. \"\"\"\n753         from sympy.polys import gcd\n754         return gcd(self, other)\n755 \n756     def lcm(self, other):\n757         \"\"\"Compute LCM of `self` and `other`. \"\"\"\n758         from sympy.polys import lcm\n759         return lcm(self, other)\n760 \n761     def cofactors(self, other):\n762         \"\"\"Compute GCD and cofactors of `self` and `other`. \"\"\"\n763         from sympy.polys import cofactors\n764         return cofactors(self, other)\n765 \n766 \n767 class Float(Number):\n768     \"\"\"Represent a floating-point number of arbitrary precision.\n769 \n770     Examples\n771     ========\n772 \n773     >>> from sympy import Float\n774     >>> Float(3.5)\n775     3.50000000000000\n776     >>> Float(3)\n777     3.00000000000000\n778 \n779     Creating Floats from strings (and Python ``int`` and ``long``\n780     types) will give a minimum precision of 15 digits, but the\n781     precision will automatically increase to capture all digits\n782     entered.\n783 \n784     >>> Float(1)\n785     1.00000000000000\n786     >>> Float(10**20)\n787     100000000000000000000.\n788     >>> Float('1e20')\n789     100000000000000000000.\n790 \n791     However, *floating-point* numbers (Python ``float`` types) retain\n792     only 15 digits of precision:\n793 \n794     >>> Float(1e20)\n795     1.00000000000000e+20\n796     >>> Float(1.23456789123456789)\n797     1.23456789123457\n798 \n799     It may be preferable to enter high-precision decimal numbers\n800     as strings:\n801 \n802     Float('1.23456789123456789')\n803     1.23456789123456789\n804 \n805     The desired number of digits can also be specified:\n806 \n807     >>> Float('1e-3', 3)\n808     0.00100\n809     >>> Float(100, 4)\n810     100.0\n811 \n812     Float can automatically count significant figures if a null string\n813     is sent for the precision; spaces or underscores are also allowed. (Auto-\n814     counting is only allowed for strings, ints and longs).\n815 \n816     >>> Float('123 456 789.123_456', '')\n817     123456789.123456\n818     >>> Float('12e-3', '')\n819     0.012\n820     >>> Float(3, '')\n821     3.\n822 \n823     If a number is written in scientific notation, only the digits before the\n824     exponent are considered significant if a decimal appears, otherwise the\n825     \"e\" signifies only how to move the decimal:\n826 \n827     >>> Float('60.e2', '')  # 2 digits significant\n828     6.0e+3\n829     >>> Float('60e2', '')  # 4 digits significant\n830     6000.\n831     >>> Float('600e-2', '')  # 3 digits significant\n832     6.00\n833 \n834     Notes\n835     =====\n836 \n837     Floats are inexact by their nature unless their value is a binary-exact\n838     value.\n839 \n840     >>> approx, exact = Float(.1, 1), Float(.125, 1)\n841 \n842     For calculation purposes, evalf needs to be able to change the precision\n843     but this will not increase the accuracy of the inexact value. The\n844     following is the most accurate 5-digit approximation of a value of 0.1\n845     that had only 1 digit of precision:\n846 \n847     >>> approx.evalf(5)\n848     0.099609\n849 \n850     By contrast, 0.125 is exact in binary (as it is in base 10) and so it\n851     can be passed to Float or evalf to obtain an arbitrary precision with\n852     matching accuracy:\n853 \n854     >>> Float(exact, 5)\n855     0.12500\n856     >>> exact.evalf(20)\n857     0.12500000000000000000\n858 \n859     Trying to make a high-precision Float from a float is not disallowed,\n860     but one must keep in mind that the *underlying float* (not the apparent\n861     decimal value) is being obtained with high precision. For example, 0.3\n862     does not have a finite binary representation. The closest rational is\n863     the fraction 5404319552844595/2**54. So if you try to obtain a Float of\n864     0.3 to 20 digits of precision you will not see the same thing as 0.3\n865     followed by 19 zeros:\n866 \n867     >>> Float(0.3, 20)\n868     0.29999999999999998890\n869 \n870     If you want a 20-digit value of the decimal 0.3 (not the floating point\n871     approximation of 0.3) you should send the 0.3 as a string. The underlying\n872     representation is still binary but a higher precision than Python's float\n873     is used:\n874 \n875     >>> Float('0.3', 20)\n876     0.30000000000000000000\n877 \n878     Although you can increase the precision of an existing Float using Float\n879     it will not increase the accuracy -- the underlying value is not changed:\n880 \n881     >>> def show(f): # binary rep of Float\n882     ...     from sympy import Mul, Pow\n883     ...     s, m, e, b = f._mpf_\n884     ...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)\n885     ...     print('%s at prec=%s' % (v, f._prec))\n886     ...\n887     >>> t = Float('0.3', 3)\n888     >>> show(t)\n889     4915/2**14 at prec=13\n890     >>> show(Float(t, 20)) # higher prec, not higher accuracy\n891     4915/2**14 at prec=70\n892     >>> show(Float(t, 2)) # lower prec\n893     307/2**10 at prec=10\n894 \n895     The same thing happens when evalf is used on a Float:\n896 \n897     >>> show(t.evalf(20))\n898     4915/2**14 at prec=70\n899     >>> show(t.evalf(2))\n900     307/2**10 at prec=10\n901 \n902     Finally, Floats can be instantiated with an mpf tuple (n, c, p) to\n903     produce the number (-1)**n*c*2**p:\n904 \n905     >>> n, c, p = 1, 5, 0\n906     >>> (-1)**n*c*2**p\n907     -5\n908     >>> Float((1, 5, 0))\n909     -5.00000000000000\n910 \n911     An actual mpf tuple also contains the number of bits in c as the last\n912     element of the tuple:\n913 \n914     >>> _._mpf_\n915     (1, 5, 0, 3)\n916 \n917     This is not needed for instantiation and is not the same thing as the\n918     precision. The mpf tuple and the precision are two separate quantities\n919     that Float tracks.\n920 \n921     \"\"\"\n922     __slots__ = ['_mpf_', '_prec']\n923 \n924     # A Float represents many real numbers,\n925     # both rational and irrational.\n926     is_rational = None\n927     is_irrational = None\n928     is_number = True\n929 \n930     is_real = True\n931 \n932     is_Float = True\n933 \n934     def __new__(cls, num, dps=None, prec=None, precision=None):\n935         if prec is not None:\n936             SymPyDeprecationWarning(\n937                             feature=\"Using 'prec=XX' to denote decimal precision\",\n938                             useinstead=\"'dps=XX' for decimal precision and 'precision=XX' \"\\\n939                                               \"for binary precision\",\n940                             issue=12820,\n941                             deprecated_since_version=\"1.1\").warn()\n942             dps = prec\n943         del prec  # avoid using this deprecated kwarg\n944 \n945         if dps is not None and precision is not None:\n946             raise ValueError('Both decimal and binary precision supplied. '\n947                              'Supply only one. ')\n948 \n949         if isinstance(num, string_types):\n950             # Float already accepts spaces as digit separators; in Py 3.6\n951             # underscores are allowed. In anticipation of that, we ignore\n952             # legally placed underscores\n953             num = num.replace(' ', '')\n954             if '_' in num:\n955                 if num.startswith('_') or num.endswith('_') or any(\n956                         i in num for i in ('__', '_.', '._')):\n957                     # copy Py 3.6 error\n958                     raise ValueError(\"could not convert string to float: '%s'\" % num)\n959                 num = num.replace('_', '')\n960             if num.startswith('.') and len(num) > 1:\n961                 num = '0' + num\n962             elif num.startswith('-.') and len(num) > 2:\n963                 num = '-0.' + num[2:]\n964             elif num == 'inf' or num == '+inf':\n965                 return S.Infinity\n966             elif num == '-inf':\n967                 return S.NegativeInfinity\n968         elif isinstance(num, float) and num == 0:\n969             num = '0'\n970         elif isinstance(num, float) and num == float('inf'):\n971             return S.Infinity\n972         elif isinstance(num, float) and num == float('-inf'):\n973             return S.NegativeInfinity\n974         elif isinstance(num, (SYMPY_INTS, Integer)):\n975             num = str(num)  # faster than mlib.from_int\n976         elif num is S.Infinity:\n977             return num\n978         elif num is S.NegativeInfinity:\n979             return num\n980         elif type(num).__module__ == 'numpy': # support for numpy datatypes\n981             num = _convert_numpy_types(num)\n982         elif isinstance(num, mpmath.mpf):\n983             if precision is None:\n984                 if dps is None:\n985                     precision = num.context.prec\n986             num = num._mpf_\n987 \n988         if dps is None and precision is None:\n989             dps = 15\n990             if isinstance(num, Float):\n991                 return num\n992             if isinstance(num, string_types) and _literal_float(num):\n993                 try:\n994                     Num = decimal.Decimal(num)\n995                 except decimal.InvalidOperation:\n996                     pass\n997                 else:\n998                     isint = '.' not in num\n999                     num, dps = _decimal_to_Rational_prec(Num)\n1000                     if num.is_Integer and isint:\n1001                         dps = max(dps, len(str(num).lstrip('-')))\n1002                     dps = max(15, dps)\n1003                     precision = mlib.libmpf.dps_to_prec(dps)\n1004         elif precision == '' and dps is None or precision is None and dps == '':\n1005             if not isinstance(num, string_types):\n1006                 raise ValueError('The null string can only be used when '\n1007                 'the number to Float is passed as a string or an integer.')\n1008             ok = None\n1009             if _literal_float(num):\n1010                 try:\n1011                     Num = decimal.Decimal(num)\n1012                 except decimal.InvalidOperation:\n1013                     pass\n1014                 else:\n1015                     isint = '.' not in num\n1016                     num, dps = _decimal_to_Rational_prec(Num)\n1017                     if num.is_Integer and isint:\n1018                         dps = max(dps, len(str(num).lstrip('-')))\n1019                         precision = mlib.libmpf.dps_to_prec(dps)\n1020                     ok = True\n1021             if ok is None:\n1022                 raise ValueError('string-float not recognized: %s' % num)\n1023 \n1024         # decimal precision(dps) is set and maybe binary precision(precision)\n1025         # as well.From here on binary precision is used to compute the Float.\n1026         # Hence, if supplied use binary precision else translate from decimal\n1027         # precision.\n1028 \n1029         if precision is None or precision == '':\n1030             precision = mlib.libmpf.dps_to_prec(dps)\n1031 \n1032         precision = int(precision)\n1033 \n1034         if isinstance(num, float):\n1035             _mpf_ = mlib.from_float(num, precision, rnd)\n1036         elif isinstance(num, string_types):\n1037             _mpf_ = mlib.from_str(num, precision, rnd)\n1038         elif isinstance(num, decimal.Decimal):\n1039             if num.is_finite():\n1040                 _mpf_ = mlib.from_str(str(num), precision, rnd)\n1041             elif num.is_nan():\n1042                 return S.NaN\n1043             elif num.is_infinite():\n1044                 if num > 0:\n1045                     return S.Infinity\n1046                 else:\n1047                     return S.NegativeInfinity\n1048             else:\n1049                 raise ValueError(\"unexpected decimal value %s\" % str(num))\n1050         elif isinstance(num, tuple) and len(num) in (3, 4):\n1051             if type(num[1]) is str:\n1052                 # it's a hexadecimal (coming from a pickled object)\n1053                 # assume that it is in standard form\n1054                 num = list(num)\n1055                 # If we're loading an object pickled in Python 2 into\n1056                 # Python 3, we may need to strip a tailing 'L' because\n1057                 # of a shim for int on Python 3, see issue #13470.\n1058                 if num[1].endswith('L'):\n1059                     num[1] = num[1][:-1]\n1060                 num[1] = MPZ(num[1], 16)\n1061                 _mpf_ = tuple(num)\n1062             else:\n1063                 if len(num) == 4:\n1064                     # handle normalization hack\n1065                     return Float._new(num, precision)\n1066                 else:\n1067                     return (S.NegativeOne**num[0]*num[1]*S(2)**num[2]).evalf(precision)\n1068         else:\n1069             try:\n1070                 _mpf_ = num._as_mpf_val(precision)\n1071             except (NotImplementedError, AttributeError):\n1072                 _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n1073 \n1074         # special cases\n1075         if _mpf_ == _mpf_zero:\n1076             pass  # we want a Float\n1077         elif _mpf_ == _mpf_nan:\n1078             return S.NaN\n1079         elif _mpf_ == _mpf_inf:\n1080             return S.Infinity\n1081         elif _mpf_ == _mpf_ninf:\n1082             return S.NegativeInfinity\n1083 \n1084         obj = Expr.__new__(cls)\n1085         obj._mpf_ = _mpf_\n1086         obj._prec = precision\n1087         return obj\n1088 \n1089     @classmethod\n1090     def _new(cls, _mpf_, _prec):\n1091         # special cases\n1092         if _mpf_ == _mpf_zero:\n1093             return S.Zero  # XXX this is different from Float which gives 0.0\n1094         elif _mpf_ == _mpf_nan:\n1095             return S.NaN\n1096         elif _mpf_ == _mpf_inf:\n1097             return S.Infinity\n1098         elif _mpf_ == _mpf_ninf:\n1099             return S.NegativeInfinity\n1100 \n1101         obj = Expr.__new__(cls)\n1102         obj._mpf_ = mpf_norm(_mpf_, _prec)\n1103         # XXX: Should this be obj._prec = obj._mpf_[3]?\n1104         obj._prec = _prec\n1105         return obj\n1106 \n1107     # mpz can't be pickled\n1108     def __getnewargs__(self):\n1109         return (mlib.to_pickable(self._mpf_),)\n1110 \n1111     def __getstate__(self):\n1112         return {'_prec': self._prec}\n1113 \n1114     def _hashable_content(self):\n1115         return (self._mpf_, self._prec)\n1116 \n1117     def floor(self):\n1118         return Integer(int(mlib.to_int(\n1119             mlib.mpf_floor(self._mpf_, self._prec))))\n1120 \n1121     def ceiling(self):\n1122         return Integer(int(mlib.to_int(\n1123             mlib.mpf_ceil(self._mpf_, self._prec))))\n1124 \n1125     def __floor__(self):\n1126         return self.floor()\n1127 \n1128     def __ceil__(self):\n1129         return self.ceiling()\n1130 \n1131 \n1132     @property\n1133     def num(self):\n1134         return mpmath.mpf(self._mpf_)\n1135 \n1136     def _as_mpf_val(self, prec):\n1137         rv = mpf_norm(self._mpf_, prec)\n1138         if rv != self._mpf_ and self._prec == prec:\n1139             debug(self._mpf_, rv)\n1140         return rv\n1141 \n1142     def _as_mpf_op(self, prec):\n1143         return self._mpf_, max(prec, self._prec)\n1144 \n1145     def _eval_is_finite(self):\n1146         if self._mpf_ in (_mpf_inf, _mpf_ninf):\n1147             return False\n1148         return True\n1149 \n1150     def _eval_is_infinite(self):\n1151         if self._mpf_ in (_mpf_inf, _mpf_ninf):\n1152             return True\n1153         return False\n1154 \n1155     def _eval_is_integer(self):\n1156         return self._mpf_ == _mpf_zero\n1157 \n1158     def _eval_is_negative(self):\n1159         if self._mpf_ == _mpf_ninf:\n1160             return True\n1161         if self._mpf_ == _mpf_inf:\n1162             return False\n1163         return self.num < 0\n1164 \n1165     def _eval_is_positive(self):\n1166         if self._mpf_ == _mpf_inf:\n1167             return True\n1168         if self._mpf_ == _mpf_ninf:\n1169             return False\n1170         return self.num > 0\n1171 \n1172     def _eval_is_zero(self):\n1173         return self._mpf_ == _mpf_zero\n1174 \n1175     def __nonzero__(self):\n1176         return self._mpf_ != _mpf_zero\n1177 \n1178     __bool__ = __nonzero__\n1179 \n1180     def __neg__(self):\n1181         return Float._new(mlib.mpf_neg(self._mpf_), self._prec)\n1182 \n1183     @_sympifyit('other', NotImplemented)\n1184     def __add__(self, other):\n1185         if isinstance(other, Number) and global_evaluate[0]:\n1186             rhs, prec = other._as_mpf_op(self._prec)\n1187             return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)\n1188         return Number.__add__(self, other)\n1189 \n1190     @_sympifyit('other', NotImplemented)\n1191     def __sub__(self, other):\n1192         if isinstance(other, Number) and global_evaluate[0]:\n1193             rhs, prec = other._as_mpf_op(self._prec)\n1194             return Float._new(mlib.mpf_sub(self._mpf_, rhs, prec, rnd), prec)\n1195         return Number.__sub__(self, other)\n1196 \n1197     @_sympifyit('other', NotImplemented)\n1198     def __mul__(self, other):\n1199         if isinstance(other, Number) and global_evaluate[0]:\n1200             rhs, prec = other._as_mpf_op(self._prec)\n1201             return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)\n1202         return Number.__mul__(self, other)\n1203 \n1204     @_sympifyit('other', NotImplemented)\n1205     def __div__(self, other):\n1206         if isinstance(other, Number) and other != 0 and global_evaluate[0]:\n1207             rhs, prec = other._as_mpf_op(self._prec)\n1208             return Float._new(mlib.mpf_div(self._mpf_, rhs, prec, rnd), prec)\n1209         return Number.__div__(self, other)\n1210 \n1211     __truediv__ = __div__\n1212 \n1213     @_sympifyit('other', NotImplemented)\n1214     def __mod__(self, other):\n1215         if isinstance(other, Rational) and other.q != 1 and global_evaluate[0]:\n1216             # calculate mod with Rationals, *then* round the result\n1217             return Float(Rational.__mod__(Rational(self), other),\n1218                          precision=self._prec)\n1219         if isinstance(other, Float) and global_evaluate[0]:\n1220             r = self/other\n1221             if r == int(r):\n1222                 return Float(0, precision=max(self._prec, other._prec))\n1223         if isinstance(other, Number) and global_evaluate[0]:\n1224             rhs, prec = other._as_mpf_op(self._prec)\n1225             return Float._new(mlib.mpf_mod(self._mpf_, rhs, prec, rnd), prec)\n1226         return Number.__mod__(self, other)\n1227 \n1228     @_sympifyit('other', NotImplemented)\n1229     def __rmod__(self, other):\n1230         if isinstance(other, Float) and global_evaluate[0]:\n1231             return other.__mod__(self)\n1232         if isinstance(other, Number) and global_evaluate[0]:\n1233             rhs, prec = other._as_mpf_op(self._prec)\n1234             return Float._new(mlib.mpf_mod(rhs, self._mpf_, prec, rnd), prec)\n1235         return Number.__rmod__(self, other)\n1236 \n1237     def _eval_power(self, expt):\n1238         \"\"\"\n1239         expt is symbolic object but not equal to 0, 1\n1240 \n1241         (-p)**r -> exp(r*log(-p)) -> exp(r*(log(p) + I*Pi)) ->\n1242                   -> p**r*(sin(Pi*r) + cos(Pi*r)*I)\n1243         \"\"\"\n1244         if self == 0:\n1245             if expt.is_positive:\n1246                 return S.Zero\n1247             if expt.is_negative:\n1248                 return S.Infinity\n1249         if isinstance(expt, Number):\n1250             if isinstance(expt, Integer):\n1251                 prec = self._prec\n1252                 return Float._new(\n1253                     mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)\n1254             elif isinstance(expt, Rational) and \\\n1255                     expt.p == 1 and expt.q % 2 and self.is_negative:\n1256                 return Pow(S.NegativeOne, expt, evaluate=False)*(\n1257                     -self)._eval_power(expt)\n1258             expt, prec = expt._as_mpf_op(self._prec)\n1259             mpfself = self._mpf_\n1260             try:\n1261                 y = mpf_pow(mpfself, expt, prec, rnd)\n1262                 return Float._new(y, prec)\n1263             except mlib.ComplexResult:\n1264                 re, im = mlib.mpc_pow(\n1265                     (mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)\n1266                 return Float._new(re, prec) + \\\n1267                     Float._new(im, prec)*S.ImaginaryUnit\n1268 \n1269     def __abs__(self):\n1270         return Float._new(mlib.mpf_abs(self._mpf_), self._prec)\n1271 \n1272     def __int__(self):\n1273         if self._mpf_ == _mpf_zero:\n1274             return 0\n1275         return int(mlib.to_int(self._mpf_))  # uses round_fast = round_down\n1276 \n1277     __long__ = __int__\n1278 \n1279     def __eq__(self, other):\n1280         if isinstance(other, float):\n1281             # coerce to Float at same precision\n1282             o = Float(other)\n1283             try:\n1284                 ompf = o._as_mpf_val(self._prec)\n1285             except ValueError:\n1286                 return False\n1287             return bool(mlib.mpf_eq(self._mpf_, ompf))\n1288         try:\n1289             other = _sympify(other)\n1290         except SympifyError:\n1291             return NotImplemented\n1292         if other.is_NumberSymbol:\n1293             if other.is_irrational:\n1294                 return False\n1295             return other.__eq__(self)\n1296         if other.is_Float:\n1297             return bool(mlib.mpf_eq(self._mpf_, other._mpf_))\n1298         if other.is_Number:\n1299             # numbers should compare at the same precision;\n1300             # all _as_mpf_val routines should be sure to abide\n1301             # by the request to change the prec if necessary; if\n1302             # they don't, the equality test will fail since it compares\n1303             # the mpf tuples\n1304             ompf = other._as_mpf_val(self._prec)\n1305             return bool(mlib.mpf_eq(self._mpf_, ompf))\n1306         return False    # Float != non-Number\n1307 \n1308     def __ne__(self, other):\n1309         return not self == other\n1310 \n1311     def __gt__(self, other):\n1312         try:\n1313             other = _sympify(other)\n1314         except SympifyError:\n1315             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n1316         if other.is_NumberSymbol:\n1317             return other.__lt__(self)\n1318         if other.is_Rational and not other.is_Integer:\n1319             self *= other.q\n1320             other = _sympify(other.p)\n1321         elif other.is_comparable:\n1322             other = other.evalf()\n1323         if other.is_Number and other is not S.NaN:\n1324             return _sympify(bool(\n1325                 mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))\n1326         return Expr.__gt__(self, other)\n1327 \n1328     def __ge__(self, other):\n1329         try:\n1330             other = _sympify(other)\n1331         except SympifyError:\n1332             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n1333         if other.is_NumberSymbol:\n1334             return other.__le__(self)\n1335         if other.is_Rational and not other.is_Integer:\n1336             self *= other.q\n1337             other = _sympify(other.p)\n1338         elif other.is_comparable:\n1339             other = other.evalf()\n1340         if other.is_Number and other is not S.NaN:\n1341             return _sympify(bool(\n1342                 mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))\n1343         return Expr.__ge__(self, other)\n1344 \n1345     def __lt__(self, other):\n1346         try:\n1347             other = _sympify(other)\n1348         except SympifyError:\n1349             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n1350         if other.is_NumberSymbol:\n1351             return other.__gt__(self)\n1352         if other.is_Rational and not other.is_Integer:\n1353             self *= other.q\n1354             other = _sympify(other.p)\n1355         elif other.is_comparable:\n1356             other = other.evalf()\n1357         if other.is_Number and other is not S.NaN:\n1358             return _sympify(bool(\n1359                 mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))\n1360         return Expr.__lt__(self, other)\n1361 \n1362     def __le__(self, other):\n1363         try:\n1364             other = _sympify(other)\n1365         except SympifyError:\n1366             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n1367         if other.is_NumberSymbol:\n1368             return other.__ge__(self)\n1369         if other.is_Rational and not other.is_Integer:\n1370             self *= other.q\n1371             other = _sympify(other.p)\n1372         elif other.is_comparable:\n1373             other = other.evalf()\n1374         if other.is_Number and other is not S.NaN:\n1375             return _sympify(bool(\n1376                 mlib.mpf_le(self._mpf_, other._as_mpf_val(self._prec))))\n1377         return Expr.__le__(self, other)\n1378 \n1379     def __hash__(self):\n1380         return super(Float, self).__hash__()\n1381 \n1382     def epsilon_eq(self, other, epsilon=\"1e-15\"):\n1383         return abs(self - other) < Float(epsilon)\n1384 \n1385     def _sage_(self):\n1386         import sage.all as sage\n1387         return sage.RealNumber(str(self))\n1388 \n1389     def __format__(self, format_spec):\n1390         return format(decimal.Decimal(str(self)), format_spec)\n1391 \n1392 \n1393 # Add sympify converters\n1394 converter[float] = converter[decimal.Decimal] = Float\n1395 \n1396 # this is here to work nicely in Sage\n1397 RealNumber = Float\n1398 \n1399 \n1400 class Rational(Number):\n1401     \"\"\"Represents rational numbers (p/q) of any size.\n1402 \n1403     Examples\n1404     ========\n1405 \n1406     >>> from sympy import Rational, nsimplify, S, pi\n1407     >>> Rational(1, 2)\n1408     1/2\n1409 \n1410     Rational is unprejudiced in accepting input. If a float is passed, the\n1411     underlying value of the binary representation will be returned:\n1412 \n1413     >>> Rational(.5)\n1414     1/2\n1415     >>> Rational(.2)\n1416     3602879701896397/18014398509481984\n1417 \n1418     If the simpler representation of the float is desired then consider\n1419     limiting the denominator to the desired value or convert the float to\n1420     a string (which is roughly equivalent to limiting the denominator to\n1421     10**12):\n1422 \n1423     >>> Rational(str(.2))\n1424     1/5\n1425     >>> Rational(.2).limit_denominator(10**12)\n1426     1/5\n1427 \n1428     An arbitrarily precise Rational is obtained when a string literal is\n1429     passed:\n1430 \n1431     >>> Rational(\"1.23\")\n1432     123/100\n1433     >>> Rational('1e-2')\n1434     1/100\n1435     >>> Rational(\".1\")\n1436     1/10\n1437     >>> Rational('1e-2/3.2')\n1438     1/320\n1439 \n1440     The conversion of other types of strings can be handled by\n1441     the sympify() function, and conversion of floats to expressions\n1442     or simple fractions can be handled with nsimplify:\n1443 \n1444     >>> S('.[3]')  # repeating digits in brackets\n1445     1/3\n1446     >>> S('3**2/10')  # general expressions\n1447     9/10\n1448     >>> nsimplify(.3)  # numbers that have a simple form\n1449     3/10\n1450 \n1451     But if the input does not reduce to a literal Rational, an error will\n1452     be raised:\n1453 \n1454     >>> Rational(pi)\n1455     Traceback (most recent call last):\n1456     ...\n1457     TypeError: invalid input: pi\n1458 \n1459 \n1460     Low-level\n1461     ---------\n1462 \n1463     Access numerator and denominator as .p and .q:\n1464 \n1465     >>> r = Rational(3, 4)\n1466     >>> r\n1467     3/4\n1468     >>> r.p\n1469     3\n1470     >>> r.q\n1471     4\n1472 \n1473     Note that p and q return integers (not SymPy Integers) so some care\n1474     is needed when using them in expressions:\n1475 \n1476     >>> r.p/r.q\n1477     0.75\n1478 \n1479     See Also\n1480     ========\n1481     sympify, sympy.simplify.simplify.nsimplify\n1482     \"\"\"\n1483     is_real = True\n1484     is_integer = False\n1485     is_rational = True\n1486     is_number = True\n1487 \n1488     __slots__ = ['p', 'q']\n1489 \n1490     is_Rational = True\n1491 \n1492     @cacheit\n1493     def __new__(cls, p, q=None, gcd=None):\n1494         if q is None:\n1495             if isinstance(p, Rational):\n1496                 return p\n1497 \n1498             if isinstance(p, SYMPY_INTS):\n1499                 pass\n1500             else:\n1501                 if isinstance(p, (float, Float)):\n1502                     return Rational(*_as_integer_ratio(p))\n1503 \n1504                 if not isinstance(p, string_types):\n1505                     try:\n1506                         p = sympify(p)\n1507                     except (SympifyError, SyntaxError):\n1508                         pass  # error will raise below\n1509                 else:\n1510                     if p.count('/') > 1:\n1511                         raise TypeError('invalid input: %s' % p)\n1512                     p = p.replace(' ', '')\n1513                     pq = p.rsplit('/', 1)\n1514                     if len(pq) == 2:\n1515                         p, q = pq\n1516                         fp = fractions.Fraction(p)\n1517                         fq = fractions.Fraction(q)\n1518                         p = fp/fq\n1519                     try:\n1520                         p = fractions.Fraction(p)\n1521                     except ValueError:\n1522                         pass  # error will raise below\n1523                     else:\n1524                         return Rational(p.numerator, p.denominator, 1)\n1525 \n1526                 if not isinstance(p, Rational):\n1527                     raise TypeError('invalid input: %s' % p)\n1528 \n1529             q = 1\n1530             gcd = 1\n1531         else:\n1532             p = Rational(p)\n1533             q = Rational(q)\n1534 \n1535         if isinstance(q, Rational):\n1536             p *= q.q\n1537             q = q.p\n1538         if isinstance(p, Rational):\n1539             q *= p.q\n1540             p = p.p\n1541 \n1542         # p and q are now integers\n1543         if q == 0:\n1544             if p == 0:\n1545                 if _errdict[\"divide\"]:\n1546                     raise ValueError(\"Indeterminate 0/0\")\n1547                 else:\n1548                     return S.NaN\n1549             return S.ComplexInfinity\n1550         if q < 0:\n1551             q = -q\n1552             p = -p\n1553         if not gcd:\n1554             gcd = igcd(abs(p), q)\n1555         if gcd > 1:\n1556             p //= gcd\n1557             q //= gcd\n1558         if q == 1:\n1559             return Integer(p)\n1560         if p == 1 and q == 2:\n1561             return S.Half\n1562         obj = Expr.__new__(cls)\n1563         obj.p = p\n1564         obj.q = q\n1565         return obj\n1566 \n1567     def limit_denominator(self, max_denominator=1000000):\n1568         \"\"\"Closest Rational to self with denominator at most max_denominator.\n1569 \n1570         >>> from sympy import Rational\n1571         >>> Rational('3.141592653589793').limit_denominator(10)\n1572         22/7\n1573         >>> Rational('3.141592653589793').limit_denominator(100)\n1574         311/99\n1575 \n1576         \"\"\"\n1577         f = fractions.Fraction(self.p, self.q)\n1578         return Rational(f.limit_denominator(fractions.Fraction(int(max_denominator))))\n1579 \n1580     def __getnewargs__(self):\n1581         return (self.p, self.q)\n1582 \n1583     def _hashable_content(self):\n1584         return (self.p, self.q)\n1585 \n1586     def _eval_is_positive(self):\n1587         return self.p > 0\n1588 \n1589     def _eval_is_zero(self):\n1590         return self.p == 0\n1591 \n1592     def __neg__(self):\n1593         return Rational(-self.p, self.q)\n1594 \n1595     @_sympifyit('other', NotImplemented)\n1596     def __add__(self, other):\n1597         if global_evaluate[0]:\n1598             if isinstance(other, Integer):\n1599                 return Rational(self.p + self.q*other.p, self.q, 1)\n1600             elif isinstance(other, Rational):\n1601                 #TODO: this can probably be optimized more\n1602                 return Rational(self.p*other.q + self.q*other.p, self.q*other.q)\n1603             elif isinstance(other, Float):\n1604                 return other + self\n1605             else:\n1606                 return Number.__add__(self, other)\n1607         return Number.__add__(self, other)\n1608     __radd__ = __add__\n1609 \n1610     @_sympifyit('other', NotImplemented)\n1611     def __sub__(self, other):\n1612         if global_evaluate[0]:\n1613             if isinstance(other, Integer):\n1614                 return Rational(self.p - self.q*other.p, self.q, 1)\n1615             elif isinstance(other, Rational):\n1616                 return Rational(self.p*other.q - self.q*other.p, self.q*other.q)\n1617             elif isinstance(other, Float):\n1618                 return -other + self\n1619             else:\n1620                 return Number.__sub__(self, other)\n1621         return Number.__sub__(self, other)\n1622     @_sympifyit('other', NotImplemented)\n1623     def __rsub__(self, other):\n1624         if global_evaluate[0]:\n1625             if isinstance(other, Integer):\n1626                 return Rational(self.q*other.p - self.p, self.q, 1)\n1627             elif isinstance(other, Rational):\n1628                 return Rational(self.q*other.p - self.p*other.q, self.q*other.q)\n1629             elif isinstance(other, Float):\n1630                 return -self + other\n1631             else:\n1632                 return Number.__rsub__(self, other)\n1633         return Number.__rsub__(self, other)\n1634     @_sympifyit('other', NotImplemented)\n1635     def __mul__(self, other):\n1636         if global_evaluate[0]:\n1637             if isinstance(other, Integer):\n1638                 return Rational(self.p*other.p, self.q, igcd(other.p, self.q))\n1639             elif isinstance(other, Rational):\n1640                 return Rational(self.p*other.p, self.q*other.q, igcd(self.p, other.q)*igcd(self.q, other.p))\n1641             elif isinstance(other, Float):\n1642                 return other*self\n1643             else:\n1644                 return Number.__mul__(self, other)\n1645         return Number.__mul__(self, other)\n1646     __rmul__ = __mul__\n1647 \n1648     @_sympifyit('other', NotImplemented)\n1649     def __div__(self, other):\n1650         if global_evaluate[0]:\n1651             if isinstance(other, Integer):\n1652                 if self.p and other.p == S.Zero:\n1653                     return S.ComplexInfinity\n1654                 else:\n1655                     return Rational(self.p, self.q*other.p, igcd(self.p, other.p))\n1656             elif isinstance(other, Rational):\n1657                 return Rational(self.p*other.q, self.q*other.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1658             elif isinstance(other, Float):\n1659                 return self*(1/other)\n1660             else:\n1661                 return Number.__div__(self, other)\n1662         return Number.__div__(self, other)\n1663     @_sympifyit('other', NotImplemented)\n1664     def __rdiv__(self, other):\n1665         if global_evaluate[0]:\n1666             if isinstance(other, Integer):\n1667                 return Rational(other.p*self.q, self.p, igcd(self.p, other.p))\n1668             elif isinstance(other, Rational):\n1669                 return Rational(other.p*self.q, other.q*self.p, igcd(self.p, other.p)*igcd(self.q, other.q))\n1670             elif isinstance(other, Float):\n1671                 return other*(1/self)\n1672             else:\n1673                 return Number.__rdiv__(self, other)\n1674         return Number.__rdiv__(self, other)\n1675     __truediv__ = __div__\n1676 \n1677     @_sympifyit('other', NotImplemented)\n1678     def __mod__(self, other):\n1679         if global_evaluate[0]:\n1680             if isinstance(other, Rational):\n1681                 n = (self.p*other.q) // (other.p*self.q)\n1682                 return Rational(self.p*other.q - n*other.p*self.q, self.q*other.q)\n1683             if isinstance(other, Float):\n1684                 # calculate mod with Rationals, *then* round the answer\n1685                 return Float(self.__mod__(Rational(other)),\n1686                              precision=other._prec)\n1687             return Number.__mod__(self, other)\n1688         return Number.__mod__(self, other)\n1689 \n1690     @_sympifyit('other', NotImplemented)\n1691     def __rmod__(self, other):\n1692         if isinstance(other, Rational):\n1693             return Rational.__mod__(other, self)\n1694         return Number.__rmod__(self, other)\n1695 \n1696     def _eval_power(self, expt):\n1697         if isinstance(expt, Number):\n1698             if isinstance(expt, Float):\n1699                 return self._eval_evalf(expt._prec)**expt\n1700             if expt.is_negative:\n1701                 # (3/4)**-2 -> (4/3)**2\n1702                 ne = -expt\n1703                 if (ne is S.One):\n1704                     return Rational(self.q, self.p)\n1705                 if self.is_negative:\n1706                     return S.NegativeOne**expt*Rational(self.q, -self.p)**ne\n1707                 else:\n1708                     return Rational(self.q, self.p)**ne\n1709             if expt is S.Infinity:  # -oo already caught by test for negative\n1710                 if self.p > self.q:\n1711                     # (3/2)**oo -> oo\n1712                     return S.Infinity\n1713                 if self.p < -self.q:\n1714                     # (-3/2)**oo -> oo + I*oo\n1715                     return S.Infinity + S.Infinity*S.ImaginaryUnit\n1716                 return S.Zero\n1717             if isinstance(expt, Integer):\n1718                 # (4/3)**2 -> 4**2 / 3**2\n1719                 return Rational(self.p**expt.p, self.q**expt.p, 1)\n1720             if isinstance(expt, Rational):\n1721                 if self.p != 1:\n1722                     # (4/3)**(5/6) -> 4**(5/6)*3**(-5/6)\n1723                     return Integer(self.p)**expt*Integer(self.q)**(-expt)\n1724                 # as the above caught negative self.p, now self is positive\n1725                 return Integer(self.q)**Rational(\n1726                 expt.p*(expt.q - 1), expt.q) / \\\n1727                     Integer(self.q)**Integer(expt.p)\n1728 \n1729         if self.is_negative and expt.is_even:\n1730             return (-self)**expt\n1731 \n1732         return\n1733 \n1734     def _as_mpf_val(self, prec):\n1735         return mlib.from_rational(self.p, self.q, prec, rnd)\n1736 \n1737     def _mpmath_(self, prec, rnd):\n1738         return mpmath.make_mpf(mlib.from_rational(self.p, self.q, prec, rnd))\n1739 \n1740     def __abs__(self):\n1741         return Rational(abs(self.p), self.q)\n1742 \n1743     def __int__(self):\n1744         p, q = self.p, self.q\n1745         if p < 0:\n1746             return -int(-p//q)\n1747         return int(p//q)\n1748 \n1749     __long__ = __int__\n1750 \n1751     def floor(self):\n1752         return Integer(self.p // self.q)\n1753 \n1754     def ceiling(self):\n1755         return -Integer(-self.p // self.q)\n1756 \n1757     def __floor__(self):\n1758         return self.floor()\n1759 \n1760     def __ceil__(self):\n1761         return self.ceiling()\n1762 \n1763     def __eq__(self, other):\n1764         try:\n1765             other = _sympify(other)\n1766         except SympifyError:\n1767             return NotImplemented\n1768         if other.is_NumberSymbol:\n1769             if other.is_irrational:\n1770                 return False\n1771             return other.__eq__(self)\n1772         if other.is_Number:\n1773             if other.is_Rational:\n1774                 # a Rational is always in reduced form so will never be 2/4\n1775                 # so we can just check equivalence of args\n1776                 return self.p == other.p and self.q == other.q\n1777             if other.is_Float:\n1778                 return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n1779         return False\n1780 \n1781     def __ne__(self, other):\n1782         return not self == other\n1783 \n1784     def __gt__(self, other):\n1785         try:\n1786             other = _sympify(other)\n1787         except SympifyError:\n1788             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n1789         if other.is_NumberSymbol:\n1790             return other.__lt__(self)\n1791         expr = self\n1792         if other.is_Number:\n1793             if other.is_Rational:\n1794                 return _sympify(bool(self.p*other.q > self.q*other.p))\n1795             if other.is_Float:\n1796                 return _sympify(bool(mlib.mpf_gt(\n1797                     self._as_mpf_val(other._prec), other._mpf_)))\n1798         elif other.is_number and other.is_real:\n1799             expr, other = Integer(self.p), self.q*other\n1800         return Expr.__gt__(expr, other)\n1801 \n1802     def __ge__(self, other):\n1803         try:\n1804             other = _sympify(other)\n1805         except SympifyError:\n1806             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n1807         if other.is_NumberSymbol:\n1808             return other.__le__(self)\n1809         expr = self\n1810         if other.is_Number:\n1811             if other.is_Rational:\n1812                  return _sympify(bool(self.p*other.q >= self.q*other.p))\n1813             if other.is_Float:\n1814                 return _sympify(bool(mlib.mpf_ge(\n1815                     self._as_mpf_val(other._prec), other._mpf_)))\n1816         elif other.is_number and other.is_real:\n1817             expr, other = Integer(self.p), self.q*other\n1818         return Expr.__ge__(expr, other)\n1819 \n1820     def __lt__(self, other):\n1821         try:\n1822             other = _sympify(other)\n1823         except SympifyError:\n1824             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n1825         if other.is_NumberSymbol:\n1826             return other.__gt__(self)\n1827         expr = self\n1828         if other.is_Number:\n1829             if other.is_Rational:\n1830                 return _sympify(bool(self.p*other.q < self.q*other.p))\n1831             if other.is_Float:\n1832                 return _sympify(bool(mlib.mpf_lt(\n1833                     self._as_mpf_val(other._prec), other._mpf_)))\n1834         elif other.is_number and other.is_real:\n1835             expr, other = Integer(self.p), self.q*other\n1836         return Expr.__lt__(expr, other)\n1837 \n1838     def __le__(self, other):\n1839         try:\n1840             other = _sympify(other)\n1841         except SympifyError:\n1842             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n1843         expr = self\n1844         if other.is_NumberSymbol:\n1845             return other.__ge__(self)\n1846         elif other.is_Number:\n1847             if other.is_Rational:\n1848                 return _sympify(bool(self.p*other.q <= self.q*other.p))\n1849             if other.is_Float:\n1850                 return _sympify(bool(mlib.mpf_le(\n1851                     self._as_mpf_val(other._prec), other._mpf_)))\n1852         elif other.is_number and other.is_real:\n1853             expr, other = Integer(self.p), self.q*other\n1854         return Expr.__le__(expr, other)\n1855 \n1856     def __hash__(self):\n1857         return super(Rational, self).__hash__()\n1858 \n1859     def factors(self, limit=None, use_trial=True, use_rho=False,\n1860                 use_pm1=False, verbose=False, visual=False):\n1861         \"\"\"A wrapper to factorint which return factors of self that are\n1862         smaller than limit (or cheap to compute). Special methods of\n1863         factoring are disabled by default so that only trial division is used.\n1864         \"\"\"\n1865         from sympy.ntheory import factorrat\n1866 \n1867         return factorrat(self, limit=limit, use_trial=use_trial,\n1868                       use_rho=use_rho, use_pm1=use_pm1,\n1869                       verbose=verbose).copy()\n1870 \n1871     def numerator(self):\n1872         return self.p\n1873 \n1874     def denominator(self):\n1875         return self.q\n1876 \n1877     @_sympifyit('other', NotImplemented)\n1878     def gcd(self, other):\n1879         if isinstance(other, Rational):\n1880             if other is S.Zero:\n1881                 return other\n1882             return Rational(\n1883                 Integer(igcd(self.p, other.p)),\n1884                 Integer(ilcm(self.q, other.q)))\n1885         return Number.gcd(self, other)\n1886 \n1887     @_sympifyit('other', NotImplemented)\n1888     def lcm(self, other):\n1889         if isinstance(other, Rational):\n1890             return Rational(\n1891                 self.p // igcd(self.p, other.p) * other.p,\n1892                 igcd(self.q, other.q))\n1893         return Number.lcm(self, other)\n1894 \n1895     def as_numer_denom(self):\n1896         return Integer(self.p), Integer(self.q)\n1897 \n1898     def _sage_(self):\n1899         import sage.all as sage\n1900         return sage.Integer(self.p)/sage.Integer(self.q)\n1901 \n1902     def as_content_primitive(self, radical=False, clear=True):\n1903         \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n1904         extracted from self.\n1905 \n1906         Examples\n1907         ========\n1908 \n1909         >>> from sympy import S\n1910         >>> (S(-3)/2).as_content_primitive()\n1911         (3/2, -1)\n1912 \n1913         See docstring of Expr.as_content_primitive for more examples.\n1914         \"\"\"\n1915 \n1916         if self:\n1917             if self.is_positive:\n1918                 return self, S.One\n1919             return -self, S.NegativeOne\n1920         return S.One, self\n1921 \n1922     def as_coeff_Mul(self, rational=False):\n1923         \"\"\"Efficiently extract the coefficient of a product. \"\"\"\n1924         return self, S.One\n1925 \n1926     def as_coeff_Add(self, rational=False):\n1927         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n1928         return self, S.Zero\n1929 \n1930 \n1931 class Integer(Rational):\n1932     \"\"\"Represents integer numbers of any size.\n1933 \n1934     Examples\n1935     ========\n1936 \n1937     >>> from sympy import Integer\n1938     >>> Integer(3)\n1939     3\n1940 \n1941     If a float or a rational is passed to Integer, the fractional part\n1942     will be discarded; the effect is of rounding toward zero.\n1943 \n1944     >>> Integer(3.8)\n1945     3\n1946     >>> Integer(-3.8)\n1947     -3\n1948 \n1949     A string is acceptable input if it can be parsed as an integer:\n1950 \n1951     >>> Integer(\"9\" * 20)\n1952     99999999999999999999\n1953 \n1954     It is rarely needed to explicitly instantiate an Integer, because\n1955     Python integers are automatically converted to Integer when they\n1956     are used in SymPy expressions.\n1957     \"\"\"\n1958     q = 1\n1959     is_integer = True\n1960     is_number = True\n1961 \n1962     is_Integer = True\n1963 \n1964     __slots__ = ['p']\n1965 \n1966     def _as_mpf_val(self, prec):\n1967         return mlib.from_int(self.p, prec, rnd)\n1968 \n1969     def _mpmath_(self, prec, rnd):\n1970         return mpmath.make_mpf(self._as_mpf_val(prec))\n1971 \n1972     @cacheit\n1973     def __new__(cls, i):\n1974         if isinstance(i, string_types):\n1975             i = i.replace(' ', '')\n1976         # whereas we cannot, in general, make a Rational from an\n1977         # arbitrary expression, we can make an Integer unambiguously\n1978         # (except when a non-integer expression happens to round to\n1979         # an integer). So we proceed by taking int() of the input and\n1980         # let the int routines determine whether the expression can\n1981         # be made into an int or whether an error should be raised.\n1982         try:\n1983             ival = int(i)\n1984         except TypeError:\n1985             raise TypeError(\n1986                 \"Argument of Integer should be of numeric type, got %s.\" % i)\n1987         # We only work with well-behaved integer types. This converts, for\n1988         # example, numpy.int32 instances.\n1989         if ival == 1:\n1990             return S.One\n1991         if ival == -1:\n1992             return S.NegativeOne\n1993         if ival == 0:\n1994             return S.Zero\n1995         obj = Expr.__new__(cls)\n1996         obj.p = ival\n1997         return obj\n1998 \n1999     def __getnewargs__(self):\n2000         return (self.p,)\n2001 \n2002     # Arithmetic operations are here for efficiency\n2003     def __int__(self):\n2004         return self.p\n2005 \n2006     __long__ = __int__\n2007 \n2008     def floor(self):\n2009         return Integer(self.p)\n2010 \n2011     def ceiling(self):\n2012         return Integer(self.p)\n2013 \n2014     def __floor__(self):\n2015         return self.floor()\n2016 \n2017     def __ceil__(self):\n2018         return self.ceiling()\n2019 \n2020     def __neg__(self):\n2021         return Integer(-self.p)\n2022 \n2023     def __abs__(self):\n2024         if self.p >= 0:\n2025             return self\n2026         else:\n2027             return Integer(-self.p)\n2028 \n2029     def __divmod__(self, other):\n2030         from .containers import Tuple\n2031         if isinstance(other, Integer) and global_evaluate[0]:\n2032             return Tuple(*(divmod(self.p, other.p)))\n2033         else:\n2034             return Number.__divmod__(self, other)\n2035 \n2036     def __rdivmod__(self, other):\n2037         from .containers import Tuple\n2038         if isinstance(other, integer_types) and global_evaluate[0]:\n2039             return Tuple(*(divmod(other, self.p)))\n2040         else:\n2041             try:\n2042                 other = Number(other)\n2043             except TypeError:\n2044                 msg = \"unsupported operand type(s) for divmod(): '%s' and '%s'\"\n2045                 oname = type(other).__name__\n2046                 sname = type(self).__name__\n2047                 raise TypeError(msg % (oname, sname))\n2048             return Number.__divmod__(other, self)\n2049 \n2050     # TODO make it decorator + bytecodehacks?\n2051     def __add__(self, other):\n2052         if global_evaluate[0]:\n2053             if isinstance(other, integer_types):\n2054                 return Integer(self.p + other)\n2055             elif isinstance(other, Integer):\n2056                 return Integer(self.p + other.p)\n2057             elif isinstance(other, Rational):\n2058                 return Rational(self.p*other.q + other.p, other.q, 1)\n2059             return Rational.__add__(self, other)\n2060         else:\n2061             return Add(self, other)\n2062 \n2063     def __radd__(self, other):\n2064         if global_evaluate[0]:\n2065             if isinstance(other, integer_types):\n2066                 return Integer(other + self.p)\n2067             elif isinstance(other, Rational):\n2068                 return Rational(other.p + self.p*other.q, other.q, 1)\n2069             return Rational.__radd__(self, other)\n2070         return Rational.__radd__(self, other)\n2071 \n2072     def __sub__(self, other):\n2073         if global_evaluate[0]:\n2074             if isinstance(other, integer_types):\n2075                 return Integer(self.p - other)\n2076             elif isinstance(other, Integer):\n2077                 return Integer(self.p - other.p)\n2078             elif isinstance(other, Rational):\n2079                 return Rational(self.p*other.q - other.p, other.q, 1)\n2080             return Rational.__sub__(self, other)\n2081         return Rational.__sub__(self, other)\n2082 \n2083     def __rsub__(self, other):\n2084         if global_evaluate[0]:\n2085             if isinstance(other, integer_types):\n2086                 return Integer(other - self.p)\n2087             elif isinstance(other, Rational):\n2088                 return Rational(other.p - self.p*other.q, other.q, 1)\n2089             return Rational.__rsub__(self, other)\n2090         return Rational.__rsub__(self, other)\n2091 \n2092     def __mul__(self, other):\n2093         if global_evaluate[0]:\n2094             if isinstance(other, integer_types):\n2095                 return Integer(self.p*other)\n2096             elif isinstance(other, Integer):\n2097                 return Integer(self.p*other.p)\n2098             elif isinstance(other, Rational):\n2099                 return Rational(self.p*other.p, other.q, igcd(self.p, other.q))\n2100             return Rational.__mul__(self, other)\n2101         return Rational.__mul__(self, other)\n2102 \n2103     def __rmul__(self, other):\n2104         if global_evaluate[0]:\n2105             if isinstance(other, integer_types):\n2106                 return Integer(other*self.p)\n2107             elif isinstance(other, Rational):\n2108                 return Rational(other.p*self.p, other.q, igcd(self.p, other.q))\n2109             return Rational.__rmul__(self, other)\n2110         return Rational.__rmul__(self, other)\n2111 \n2112     def __mod__(self, other):\n2113         if global_evaluate[0]:\n2114             if isinstance(other, integer_types):\n2115                 return Integer(self.p % other)\n2116             elif isinstance(other, Integer):\n2117                 return Integer(self.p % other.p)\n2118             return Rational.__mod__(self, other)\n2119         return Rational.__mod__(self, other)\n2120 \n2121     def __rmod__(self, other):\n2122         if global_evaluate[0]:\n2123             if isinstance(other, integer_types):\n2124                 return Integer(other % self.p)\n2125             elif isinstance(other, Integer):\n2126                 return Integer(other.p % self.p)\n2127             return Rational.__rmod__(self, other)\n2128         return Rational.__rmod__(self, other)\n2129 \n2130     def __eq__(self, other):\n2131         if isinstance(other, integer_types):\n2132             return (self.p == other)\n2133         elif isinstance(other, Integer):\n2134             return (self.p == other.p)\n2135         return Rational.__eq__(self, other)\n2136 \n2137     def __ne__(self, other):\n2138         return not self == other\n2139 \n2140     def __gt__(self, other):\n2141         try:\n2142             other = _sympify(other)\n2143         except SympifyError:\n2144             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n2145         if other.is_Integer:\n2146             return _sympify(self.p > other.p)\n2147         return Rational.__gt__(self, other)\n2148 \n2149     def __lt__(self, other):\n2150         try:\n2151             other = _sympify(other)\n2152         except SympifyError:\n2153             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n2154         if other.is_Integer:\n2155             return _sympify(self.p < other.p)\n2156         return Rational.__lt__(self, other)\n2157 \n2158     def __ge__(self, other):\n2159         try:\n2160             other = _sympify(other)\n2161         except SympifyError:\n2162             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n2163         if other.is_Integer:\n2164             return _sympify(self.p >= other.p)\n2165         return Rational.__ge__(self, other)\n2166 \n2167     def __le__(self, other):\n2168         try:\n2169             other = _sympify(other)\n2170         except SympifyError:\n2171             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n2172         if other.is_Integer:\n2173             return _sympify(self.p <= other.p)\n2174         return Rational.__le__(self, other)\n2175 \n2176     def __hash__(self):\n2177         return hash(self.p)\n2178 \n2179     def __index__(self):\n2180         return self.p\n2181 \n2182     ########################################\n2183 \n2184     def _eval_is_odd(self):\n2185         return bool(self.p % 2)\n2186 \n2187     def _eval_power(self, expt):\n2188         \"\"\"\n2189         Tries to do some simplifications on self**expt\n2190 \n2191         Returns None if no further simplifications can be done\n2192 \n2193         When exponent is a fraction (so we have for example a square root),\n2194         we try to find a simpler representation by factoring the argument\n2195         up to factors of 2**15, e.g.\n2196 \n2197           - sqrt(4) becomes 2\n2198           - sqrt(-4) becomes 2*I\n2199           - (2**(3+7)*3**(6+7))**Rational(1,7) becomes 6*18**(3/7)\n2200 \n2201         Further simplification would require a special call to factorint on\n2202         the argument which is not done here for sake of speed.\n2203 \n2204         \"\"\"\n2205         from sympy import perfect_power\n2206 \n2207         if expt is S.Infinity:\n2208             if self.p > S.One:\n2209                 return S.Infinity\n2210             # cases -1, 0, 1 are done in their respective classes\n2211             return S.Infinity + S.ImaginaryUnit*S.Infinity\n2212         if expt is S.NegativeInfinity:\n2213             return Rational(1, self)**S.Infinity\n2214         if not isinstance(expt, Number):\n2215             # simplify when expt is even\n2216             # (-2)**k --> 2**k\n2217             if self.is_negative and expt.is_even:\n2218                 return (-self)**expt\n2219         if isinstance(expt, Float):\n2220             # Rational knows how to exponentiate by a Float\n2221             return super(Integer, self)._eval_power(expt)\n2222         if not isinstance(expt, Rational):\n2223             return\n2224         if expt is S.Half and self.is_negative:\n2225             # we extract I for this special case since everyone is doing so\n2226             return S.ImaginaryUnit*Pow(-self, expt)\n2227         if expt.is_negative:\n2228             # invert base and change sign on exponent\n2229             ne = -expt\n2230             if self.is_negative:\n2231                     return S.NegativeOne**expt*Rational(1, -self)**ne\n2232             else:\n2233                 return Rational(1, self.p)**ne\n2234         # see if base is a perfect root, sqrt(4) --> 2\n2235         x, xexact = integer_nthroot(abs(self.p), expt.q)\n2236         if xexact:\n2237             # if it's a perfect root we've finished\n2238             result = Integer(x**abs(expt.p))\n2239             if self.is_negative:\n2240                 result *= S.NegativeOne**expt\n2241             return result\n2242 \n2243         # The following is an algorithm where we collect perfect roots\n2244         # from the factors of base.\n2245 \n2246         # if it's not an nth root, it still might be a perfect power\n2247         b_pos = int(abs(self.p))\n2248         p = perfect_power(b_pos)\n2249         if p is not False:\n2250             dict = {p[0]: p[1]}\n2251         else:\n2252             dict = Integer(b_pos).factors(limit=2**15)\n2253 \n2254         # now process the dict of factors\n2255         out_int = 1  # integer part\n2256         out_rad = 1  # extracted radicals\n2257         sqr_int = 1\n2258         sqr_gcd = 0\n2259         sqr_dict = {}\n2260         for prime, exponent in dict.items():\n2261             exponent *= expt.p\n2262             # remove multiples of expt.q: (2**12)**(1/10) -> 2*(2**2)**(1/10)\n2263             div_e, div_m = divmod(exponent, expt.q)\n2264             if div_e > 0:\n2265                 out_int *= prime**div_e\n2266             if div_m > 0:\n2267                 # see if the reduced exponent shares a gcd with e.q\n2268                 # (2**2)**(1/10) -> 2**(1/5)\n2269                 g = igcd(div_m, expt.q)\n2270                 if g != 1:\n2271                     out_rad *= Pow(prime, Rational(div_m//g, expt.q//g))\n2272                 else:\n2273                     sqr_dict[prime] = div_m\n2274         # identify gcd of remaining powers\n2275         for p, ex in sqr_dict.items():\n2276             if sqr_gcd == 0:\n2277                 sqr_gcd = ex\n2278             else:\n2279                 sqr_gcd = igcd(sqr_gcd, ex)\n2280                 if sqr_gcd == 1:\n2281                     break\n2282         for k, v in sqr_dict.items():\n2283             sqr_int *= k**(v//sqr_gcd)\n2284         if sqr_int == b_pos and out_int == 1 and out_rad == 1:\n2285             result = None\n2286         else:\n2287             result = out_int*out_rad*Pow(sqr_int, Rational(sqr_gcd, expt.q))\n2288             if self.is_negative:\n2289                 result *= Pow(S.NegativeOne, expt)\n2290         return result\n2291 \n2292     def _eval_is_prime(self):\n2293         from sympy.ntheory import isprime\n2294 \n2295         return isprime(self)\n2296 \n2297     def _eval_is_composite(self):\n2298         if self > 1:\n2299             return fuzzy_not(self.is_prime)\n2300         else:\n2301             return False\n2302 \n2303     def as_numer_denom(self):\n2304         return self, S.One\n2305 \n2306     def __floordiv__(self, other):\n2307         return Integer(self.p // Integer(other).p)\n2308 \n2309     def __rfloordiv__(self, other):\n2310         return Integer(Integer(other).p // self.p)\n2311 \n2312 # Add sympify converters\n2313 for i_type in integer_types:\n2314     converter[i_type] = Integer\n2315 \n2316 \n2317 class AlgebraicNumber(Expr):\n2318     \"\"\"Class for representing algebraic numbers in SymPy. \"\"\"\n2319 \n2320     __slots__ = ['rep', 'root', 'alias', 'minpoly']\n2321 \n2322     is_AlgebraicNumber = True\n2323     is_algebraic = True\n2324     is_number = True\n2325 \n2326     def __new__(cls, expr, coeffs=None, alias=None, **args):\n2327         \"\"\"Construct a new algebraic number. \"\"\"\n2328         from sympy import Poly\n2329         from sympy.polys.polyclasses import ANP, DMP\n2330         from sympy.polys.numberfields import minimal_polynomial\n2331         from sympy.core.symbol import Symbol\n2332 \n2333         expr = sympify(expr)\n2334 \n2335         if isinstance(expr, (tuple, Tuple)):\n2336             minpoly, root = expr\n2337 \n2338             if not minpoly.is_Poly:\n2339                 minpoly = Poly(minpoly)\n2340         elif expr.is_AlgebraicNumber:\n2341             minpoly, root = expr.minpoly, expr.root\n2342         else:\n2343             minpoly, root = minimal_polynomial(\n2344                 expr, args.get('gen'), polys=True), expr\n2345 \n2346         dom = minpoly.get_domain()\n2347 \n2348         if coeffs is not None:\n2349             if not isinstance(coeffs, ANP):\n2350                 rep = DMP.from_sympy_list(sympify(coeffs), 0, dom)\n2351                 scoeffs = Tuple(*coeffs)\n2352             else:\n2353                 rep = DMP.from_list(coeffs.to_list(), 0, dom)\n2354                 scoeffs = Tuple(*coeffs.to_list())\n2355 \n2356             if rep.degree() >= minpoly.degree():\n2357                 rep = rep.rem(minpoly.rep)\n2358 \n2359         else:\n2360             rep = DMP.from_list([1, 0], 0, dom)\n2361             scoeffs = Tuple(1, 0)\n2362 \n2363         sargs = (root, scoeffs)\n2364 \n2365         if alias is not None:\n2366             if not isinstance(alias, Symbol):\n2367                 alias = Symbol(alias)\n2368             sargs = sargs + (alias,)\n2369 \n2370         obj = Expr.__new__(cls, *sargs)\n2371 \n2372         obj.rep = rep\n2373         obj.root = root\n2374         obj.alias = alias\n2375         obj.minpoly = minpoly\n2376 \n2377         return obj\n2378 \n2379     def __hash__(self):\n2380         return super(AlgebraicNumber, self).__hash__()\n2381 \n2382     def _eval_evalf(self, prec):\n2383         return self.as_expr()._evalf(prec)\n2384 \n2385     @property\n2386     def is_aliased(self):\n2387         \"\"\"Returns ``True`` if ``alias`` was set. \"\"\"\n2388         return self.alias is not None\n2389 \n2390     def as_poly(self, x=None):\n2391         \"\"\"Create a Poly instance from ``self``. \"\"\"\n2392         from sympy import Dummy, Poly, PurePoly\n2393         if x is not None:\n2394             return Poly.new(self.rep, x)\n2395         else:\n2396             if self.alias is not None:\n2397                 return Poly.new(self.rep, self.alias)\n2398             else:\n2399                 return PurePoly.new(self.rep, Dummy('x'))\n2400 \n2401     def as_expr(self, x=None):\n2402         \"\"\"Create a Basic expression from ``self``. \"\"\"\n2403         return self.as_poly(x or self.root).as_expr().expand()\n2404 \n2405     def coeffs(self):\n2406         \"\"\"Returns all SymPy coefficients of an algebraic number. \"\"\"\n2407         return [ self.rep.dom.to_sympy(c) for c in self.rep.all_coeffs() ]\n2408 \n2409     def native_coeffs(self):\n2410         \"\"\"Returns all native coefficients of an algebraic number. \"\"\"\n2411         return self.rep.all_coeffs()\n2412 \n2413     def to_algebraic_integer(self):\n2414         \"\"\"Convert ``self`` to an algebraic integer. \"\"\"\n2415         from sympy import Poly\n2416         f = self.minpoly\n2417 \n2418         if f.LC() == 1:\n2419             return self\n2420 \n2421         coeff = f.LC()**(f.degree() - 1)\n2422         poly = f.compose(Poly(f.gen/f.LC()))\n2423 \n2424         minpoly = poly*coeff\n2425         root = f.LC()*self.root\n2426 \n2427         return AlgebraicNumber((minpoly, root), self.coeffs())\n2428 \n2429     def _eval_simplify(self, ratio, measure, rational, inverse):\n2430         from sympy.polys import CRootOf, minpoly\n2431 \n2432         for r in [r for r in self.minpoly.all_roots() if r.func != CRootOf]:\n2433             if minpoly(self.root - r).is_Symbol:\n2434                 # use the matching root if it's simpler\n2435                 if measure(r) < ratio*measure(self.root):\n2436                     return AlgebraicNumber(r)\n2437         return self\n2438 \n2439 \n2440 class RationalConstant(Rational):\n2441     \"\"\"\n2442     Abstract base class for rationals with specific behaviors\n2443 \n2444     Derived classes must define class attributes p and q and should probably all\n2445     be singletons.\n2446     \"\"\"\n2447     __slots__ = []\n2448 \n2449     def __new__(cls):\n2450         return AtomicExpr.__new__(cls)\n2451 \n2452 \n2453 class IntegerConstant(Integer):\n2454     __slots__ = []\n2455 \n2456     def __new__(cls):\n2457         return AtomicExpr.__new__(cls)\n2458 \n2459 \n2460 class Zero(with_metaclass(Singleton, IntegerConstant)):\n2461     \"\"\"The number zero.\n2462 \n2463     Zero is a singleton, and can be accessed by ``S.Zero``\n2464 \n2465     Examples\n2466     ========\n2467 \n2468     >>> from sympy import S, Integer, zoo\n2469     >>> Integer(0) is S.Zero\n2470     True\n2471     >>> 1/S.Zero\n2472     zoo\n2473 \n2474     References\n2475     ==========\n2476 \n2477     .. [1] https://en.wikipedia.org/wiki/Zero\n2478     \"\"\"\n2479 \n2480     p = 0\n2481     q = 1\n2482     is_positive = False\n2483     is_negative = False\n2484     is_zero = True\n2485     is_number = True\n2486 \n2487     __slots__ = []\n2488 \n2489     @staticmethod\n2490     def __abs__():\n2491         return S.Zero\n2492 \n2493     @staticmethod\n2494     def __neg__():\n2495         return S.Zero\n2496 \n2497     def _eval_power(self, expt):\n2498         if expt.is_positive:\n2499             return self\n2500         if expt.is_negative:\n2501             return S.ComplexInfinity\n2502         if expt.is_real is False:\n2503             return S.NaN\n2504         # infinities are already handled with pos and neg\n2505         # tests above; now throw away leading numbers on Mul\n2506         # exponent\n2507         coeff, terms = expt.as_coeff_Mul()\n2508         if coeff.is_negative:\n2509             return S.ComplexInfinity**terms\n2510         if coeff is not S.One:  # there is a Number to discard\n2511             return self**terms\n2512 \n2513     def _eval_order(self, *symbols):\n2514         # Order(0,x) -> 0\n2515         return self\n2516 \n2517     def __nonzero__(self):\n2518         return False\n2519 \n2520     __bool__ = __nonzero__\n2521 \n2522     def as_coeff_Mul(self, rational=False):  # XXX this routine should be deleted\n2523         \"\"\"Efficiently extract the coefficient of a summation. \"\"\"\n2524         return S.One, self\n2525 \n2526 \n2527 class One(with_metaclass(Singleton, IntegerConstant)):\n2528     \"\"\"The number one.\n2529 \n2530     One is a singleton, and can be accessed by ``S.One``.\n2531 \n2532     Examples\n2533     ========\n2534 \n2535     >>> from sympy import S, Integer\n2536     >>> Integer(1) is S.One\n2537     True\n2538 \n2539     References\n2540     ==========\n2541 \n2542     .. [1] https://en.wikipedia.org/wiki/1_%28number%29\n2543     \"\"\"\n2544     is_number = True\n2545 \n2546     p = 1\n2547     q = 1\n2548 \n2549     __slots__ = []\n2550 \n2551     @staticmethod\n2552     def __abs__():\n2553         return S.One\n2554 \n2555     @staticmethod\n2556     def __neg__():\n2557         return S.NegativeOne\n2558 \n2559     def _eval_power(self, expt):\n2560         return self\n2561 \n2562     def _eval_order(self, *symbols):\n2563         return\n2564 \n2565     @staticmethod\n2566     def factors(limit=None, use_trial=True, use_rho=False, use_pm1=False,\n2567                 verbose=False, visual=False):\n2568         if visual:\n2569             return S.One\n2570         else:\n2571             return {}\n2572 \n2573 \n2574 class NegativeOne(with_metaclass(Singleton, IntegerConstant)):\n2575     \"\"\"The number negative one.\n2576 \n2577     NegativeOne is a singleton, and can be accessed by ``S.NegativeOne``.\n2578 \n2579     Examples\n2580     ========\n2581 \n2582     >>> from sympy import S, Integer\n2583     >>> Integer(-1) is S.NegativeOne\n2584     True\n2585 \n2586     See Also\n2587     ========\n2588 \n2589     One\n2590 \n2591     References\n2592     ==========\n2593 \n2594     .. [1] https://en.wikipedia.org/wiki/%E2%88%921_%28number%29\n2595 \n2596     \"\"\"\n2597     is_number = True\n2598 \n2599     p = -1\n2600     q = 1\n2601 \n2602     __slots__ = []\n2603 \n2604     @staticmethod\n2605     def __abs__():\n2606         return S.One\n2607 \n2608     @staticmethod\n2609     def __neg__():\n2610         return S.One\n2611 \n2612     def _eval_power(self, expt):\n2613         if expt.is_odd:\n2614             return S.NegativeOne\n2615         if expt.is_even:\n2616             return S.One\n2617         if isinstance(expt, Number):\n2618             if isinstance(expt, Float):\n2619                 return Float(-1.0)**expt\n2620             if expt is S.NaN:\n2621                 return S.NaN\n2622             if expt is S.Infinity or expt is S.NegativeInfinity:\n2623                 return S.NaN\n2624             if expt is S.Half:\n2625                 return S.ImaginaryUnit\n2626             if isinstance(expt, Rational):\n2627                 if expt.q == 2:\n2628                     return S.ImaginaryUnit**Integer(expt.p)\n2629                 i, r = divmod(expt.p, expt.q)\n2630                 if i:\n2631                     return self**i*self**Rational(r, expt.q)\n2632         return\n2633 \n2634 \n2635 class Half(with_metaclass(Singleton, RationalConstant)):\n2636     \"\"\"The rational number 1/2.\n2637 \n2638     Half is a singleton, and can be accessed by ``S.Half``.\n2639 \n2640     Examples\n2641     ========\n2642 \n2643     >>> from sympy import S, Rational\n2644     >>> Rational(1, 2) is S.Half\n2645     True\n2646 \n2647     References\n2648     ==========\n2649 \n2650     .. [1] https://en.wikipedia.org/wiki/One_half\n2651     \"\"\"\n2652     is_number = True\n2653 \n2654     p = 1\n2655     q = 2\n2656 \n2657     __slots__ = []\n2658 \n2659     @staticmethod\n2660     def __abs__():\n2661         return S.Half\n2662 \n2663 \n2664 class Infinity(with_metaclass(Singleton, Number)):\n2665     r\"\"\"Positive infinite quantity.\n2666 \n2667     In real analysis the symbol `\\infty` denotes an unbounded\n2668     limit: `x\\to\\infty` means that `x` grows without bound.\n2669 \n2670     Infinity is often used not only to define a limit but as a value\n2671     in the affinely extended real number system.  Points labeled `+\\infty`\n2672     and `-\\infty` can be added to the topological space of the real numbers,\n2673     producing the two-point compactification of the real numbers.  Adding\n2674     algebraic properties to this gives us the extended real numbers.\n2675 \n2676     Infinity is a singleton, and can be accessed by ``S.Infinity``,\n2677     or can be imported as ``oo``.\n2678 \n2679     Examples\n2680     ========\n2681 \n2682     >>> from sympy import oo, exp, limit, Symbol\n2683     >>> 1 + oo\n2684     oo\n2685     >>> 42/oo\n2686     0\n2687     >>> x = Symbol('x')\n2688     >>> limit(exp(x), x, oo)\n2689     oo\n2690 \n2691     See Also\n2692     ========\n2693 \n2694     NegativeInfinity, NaN\n2695 \n2696     References\n2697     ==========\n2698 \n2699     .. [1] https://en.wikipedia.org/wiki/Infinity\n2700     \"\"\"\n2701 \n2702     is_commutative = True\n2703     is_positive = True\n2704     is_infinite = True\n2705     is_number = True\n2706     is_prime = False\n2707 \n2708     __slots__ = []\n2709 \n2710     def __new__(cls):\n2711         return AtomicExpr.__new__(cls)\n2712 \n2713     def _latex(self, printer):\n2714         return r\"\\infty\"\n2715 \n2716     def _eval_subs(self, old, new):\n2717         if self == old:\n2718             return new\n2719 \n2720     @_sympifyit('other', NotImplemented)\n2721     def __add__(self, other):\n2722         if isinstance(other, Number):\n2723             if other is S.NegativeInfinity or other is S.NaN:\n2724                 return S.NaN\n2725             return self\n2726         return NotImplemented\n2727     __radd__ = __add__\n2728 \n2729     @_sympifyit('other', NotImplemented)\n2730     def __sub__(self, other):\n2731         if isinstance(other, Number):\n2732             if other is S.Infinity or other is S.NaN:\n2733                 return S.NaN\n2734             return self\n2735         return NotImplemented\n2736 \n2737     @_sympifyit('other', NotImplemented)\n2738     def __rsub__(self, other):\n2739         return (-self).__add__(other)\n2740 \n2741     @_sympifyit('other', NotImplemented)\n2742     def __mul__(self, other):\n2743         if isinstance(other, Number):\n2744             if other.is_zero or other is S.NaN:\n2745                 return S.NaN\n2746             if other.is_positive:\n2747                 return self\n2748             return S.NegativeInfinity\n2749         return NotImplemented\n2750     __rmul__ = __mul__\n2751 \n2752     @_sympifyit('other', NotImplemented)\n2753     def __div__(self, other):\n2754         if isinstance(other, Number):\n2755             if other is S.Infinity or \\\n2756                 other is S.NegativeInfinity or \\\n2757                     other is S.NaN:\n2758                 return S.NaN\n2759             if other.is_nonnegative:\n2760                 return self\n2761             return S.NegativeInfinity\n2762         return NotImplemented\n2763 \n2764     __truediv__ = __div__\n2765 \n2766     def __abs__(self):\n2767         return S.Infinity\n2768 \n2769     def __neg__(self):\n2770         return S.NegativeInfinity\n2771 \n2772     def _eval_power(self, expt):\n2773         \"\"\"\n2774         ``expt`` is symbolic object but not equal to 0 or 1.\n2775 \n2776         ================ ======= ==============================\n2777         Expression       Result  Notes\n2778         ================ ======= ==============================\n2779         ``oo ** nan``    ``nan``\n2780         ``oo ** -p``     ``0``   ``p`` is number, ``oo``\n2781         ================ ======= ==============================\n2782 \n2783         See Also\n2784         ========\n2785         Pow\n2786         NaN\n2787         NegativeInfinity\n2788 \n2789         \"\"\"\n2790         from sympy.functions import re\n2791 \n2792         if expt.is_positive:\n2793             return S.Infinity\n2794         if expt.is_negative:\n2795             return S.Zero\n2796         if expt is S.NaN:\n2797             return S.NaN\n2798         if expt is S.ComplexInfinity:\n2799             return S.NaN\n2800         if expt.is_real is False and expt.is_number:\n2801             expt_real = re(expt)\n2802             if expt_real.is_positive:\n2803                 return S.ComplexInfinity\n2804             if expt_real.is_negative:\n2805                 return S.Zero\n2806             if expt_real.is_zero:\n2807                 return S.NaN\n2808 \n2809             return self**expt.evalf()\n2810 \n2811     def _as_mpf_val(self, prec):\n2812         return mlib.finf\n2813 \n2814     def _sage_(self):\n2815         import sage.all as sage\n2816         return sage.oo\n2817 \n2818     def __hash__(self):\n2819         return super(Infinity, self).__hash__()\n2820 \n2821     def __eq__(self, other):\n2822         return other is S.Infinity or other == float('inf')\n2823 \n2824     def __ne__(self, other):\n2825         return other is not S.Infinity and other != float('inf')\n2826 \n2827     def __lt__(self, other):\n2828         try:\n2829             other = _sympify(other)\n2830         except SympifyError:\n2831             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n2832         if other.is_real:\n2833             return S.false\n2834         return Expr.__lt__(self, other)\n2835 \n2836     def __le__(self, other):\n2837         try:\n2838             other = _sympify(other)\n2839         except SympifyError:\n2840             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n2841         if other.is_real:\n2842             if other.is_finite or other is S.NegativeInfinity:\n2843                 return S.false\n2844             elif other.is_nonpositive:\n2845                 return S.false\n2846             elif other.is_infinite and other.is_positive:\n2847                 return S.true\n2848         return Expr.__le__(self, other)\n2849 \n2850     def __gt__(self, other):\n2851         try:\n2852             other = _sympify(other)\n2853         except SympifyError:\n2854             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n2855         if other.is_real:\n2856             if other.is_finite or other is S.NegativeInfinity:\n2857                 return S.true\n2858             elif other.is_nonpositive:\n2859                 return S.true\n2860             elif other.is_infinite and other.is_positive:\n2861                 return S.false\n2862         return Expr.__gt__(self, other)\n2863 \n2864     def __ge__(self, other):\n2865         try:\n2866             other = _sympify(other)\n2867         except SympifyError:\n2868             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n2869         if other.is_real:\n2870             return S.true\n2871         return Expr.__ge__(self, other)\n2872 \n2873     def __mod__(self, other):\n2874         return S.NaN\n2875 \n2876     __rmod__ = __mod__\n2877 \n2878     def floor(self):\n2879         return self\n2880 \n2881     def ceiling(self):\n2882         return self\n2883 \n2884 oo = S.Infinity\n2885 \n2886 \n2887 class NegativeInfinity(with_metaclass(Singleton, Number)):\n2888     \"\"\"Negative infinite quantity.\n2889 \n2890     NegativeInfinity is a singleton, and can be accessed\n2891     by ``S.NegativeInfinity``.\n2892 \n2893     See Also\n2894     ========\n2895 \n2896     Infinity\n2897     \"\"\"\n2898 \n2899     is_commutative = True\n2900     is_negative = True\n2901     is_infinite = True\n2902     is_number = True\n2903 \n2904     __slots__ = []\n2905 \n2906     def __new__(cls):\n2907         return AtomicExpr.__new__(cls)\n2908 \n2909     def _latex(self, printer):\n2910         return r\"-\\infty\"\n2911 \n2912     def _eval_subs(self, old, new):\n2913         if self == old:\n2914             return new\n2915 \n2916     @_sympifyit('other', NotImplemented)\n2917     def __add__(self, other):\n2918         if isinstance(other, Number):\n2919             if other is S.Infinity or other is S.NaN:\n2920                 return S.NaN\n2921             return self\n2922         return NotImplemented\n2923     __radd__ = __add__\n2924 \n2925     @_sympifyit('other', NotImplemented)\n2926     def __sub__(self, other):\n2927         if isinstance(other, Number):\n2928             if other is S.NegativeInfinity or other is S.NaN:\n2929                 return S.NaN\n2930             return self\n2931         return NotImplemented\n2932 \n2933     @_sympifyit('other', NotImplemented)\n2934     def __rsub__(self, other):\n2935         return (-self).__add__(other)\n2936 \n2937     @_sympifyit('other', NotImplemented)\n2938     def __mul__(self, other):\n2939         if isinstance(other, Number):\n2940             if other.is_zero or other is S.NaN:\n2941                 return S.NaN\n2942             if other.is_positive:\n2943                 return self\n2944             return S.Infinity\n2945         return NotImplemented\n2946     __rmul__ = __mul__\n2947 \n2948     @_sympifyit('other', NotImplemented)\n2949     def __div__(self, other):\n2950         if isinstance(other, Number):\n2951             if other is S.Infinity or \\\n2952                 other is S.NegativeInfinity or \\\n2953                     other is S.NaN:\n2954                 return S.NaN\n2955             if other.is_nonnegative:\n2956                 return self\n2957             return S.Infinity\n2958         return NotImplemented\n2959 \n2960     __truediv__ = __div__\n2961 \n2962     def __abs__(self):\n2963         return S.Infinity\n2964 \n2965     def __neg__(self):\n2966         return S.Infinity\n2967 \n2968     def _eval_power(self, expt):\n2969         \"\"\"\n2970         ``expt`` is symbolic object but not equal to 0 or 1.\n2971 \n2972         ================ ======= ==============================\n2973         Expression       Result  Notes\n2974         ================ ======= ==============================\n2975         ``(-oo) ** nan`` ``nan``\n2976         ``(-oo) ** oo``  ``nan``\n2977         ``(-oo) ** -oo`` ``nan``\n2978         ``(-oo) ** e``   ``oo``  ``e`` is positive even integer\n2979         ``(-oo) ** o``   ``-oo`` ``o`` is positive odd integer\n2980         ================ ======= ==============================\n2981 \n2982         See Also\n2983         ========\n2984 \n2985         Infinity\n2986         Pow\n2987         NaN\n2988 \n2989         \"\"\"\n2990         if expt.is_number:\n2991             if expt is S.NaN or \\\n2992                 expt is S.Infinity or \\\n2993                     expt is S.NegativeInfinity:\n2994                 return S.NaN\n2995 \n2996             if isinstance(expt, Integer) and expt.is_positive:\n2997                 if expt.is_odd:\n2998                     return S.NegativeInfinity\n2999                 else:\n3000                     return S.Infinity\n3001 \n3002             return S.NegativeOne**expt*S.Infinity**expt\n3003 \n3004     def _as_mpf_val(self, prec):\n3005         return mlib.fninf\n3006 \n3007     def _sage_(self):\n3008         import sage.all as sage\n3009         return -(sage.oo)\n3010 \n3011     def __hash__(self):\n3012         return super(NegativeInfinity, self).__hash__()\n3013 \n3014     def __eq__(self, other):\n3015         return other is S.NegativeInfinity or other == float('-inf')\n3016 \n3017     def __ne__(self, other):\n3018         return other is not S.NegativeInfinity and other != float('-inf')\n3019 \n3020     def __lt__(self, other):\n3021         try:\n3022             other = _sympify(other)\n3023         except SympifyError:\n3024             raise TypeError(\"Invalid comparison %s < %s\" % (self, other))\n3025         if other.is_real:\n3026             if other.is_finite or other is S.Infinity:\n3027                 return S.true\n3028             elif other.is_nonnegative:\n3029                 return S.true\n3030             elif other.is_infinite and other.is_negative:\n3031                 return S.false\n3032         return Expr.__lt__(self, other)\n3033 \n3034     def __le__(self, other):\n3035         try:\n3036             other = _sympify(other)\n3037         except SympifyError:\n3038             raise TypeError(\"Invalid comparison %s <= %s\" % (self, other))\n3039         if other.is_real:\n3040             return S.true\n3041         return Expr.__le__(self, other)\n3042 \n3043     def __gt__(self, other):\n3044         try:\n3045             other = _sympify(other)\n3046         except SympifyError:\n3047             raise TypeError(\"Invalid comparison %s > %s\" % (self, other))\n3048         if other.is_real:\n3049             return S.false\n3050         return Expr.__gt__(self, other)\n3051 \n3052     def __ge__(self, other):\n3053         try:\n3054             other = _sympify(other)\n3055         except SympifyError:\n3056             raise TypeError(\"Invalid comparison %s >= %s\" % (self, other))\n3057         if other.is_real:\n3058             if other.is_finite or other is S.Infinity:\n3059                 return S.false\n3060             elif other.is_nonnegative:\n3061                 return S.false\n3062             elif other.is_infinite and other.is_negative:\n3063                 return S.true\n3064         return Expr.__ge__(self, other)\n3065 \n3066     def __mod__(self, other):\n3067         return S.NaN\n3068 \n3069     __rmod__ = __mod__\n3070 \n3071     def floor(self):\n3072         return self\n3073 \n3074     def ceiling(self):\n3075         return self\n3076 \n3077 \n3078 class NaN(with_metaclass(Singleton, Number)):\n3079     \"\"\"\n3080     Not a Number.\n3081 \n3082     This serves as a place holder for numeric values that are indeterminate.\n3083     Most operations on NaN, produce another NaN.  Most indeterminate forms,\n3084     such as ``0/0`` or ``oo - oo` produce NaN.  Two exceptions are ``0**0``\n3085     and ``oo**0``, which all produce ``1`` (this is consistent with Python's\n3086     float).\n3087 \n3088     NaN is loosely related to floating point nan, which is defined in the\n3089     IEEE 754 floating point standard, and corresponds to the Python\n3090     ``float('nan')``.  Differences are noted below.\n3091 \n3092     NaN is mathematically not equal to anything else, even NaN itself.  This\n3093     explains the initially counter-intuitive results with ``Eq`` and ``==`` in\n3094     the examples below.\n3095 \n3096     NaN is not comparable so inequalities raise a TypeError.  This is in\n3097     constrast with floating point nan where all inequalities are false.\n3098 \n3099     NaN is a singleton, and can be accessed by ``S.NaN``, or can be imported\n3100     as ``nan``.\n3101 \n3102     Examples\n3103     ========\n3104 \n3105     >>> from sympy import nan, S, oo, Eq\n3106     >>> nan is S.NaN\n3107     True\n3108     >>> oo - oo\n3109     nan\n3110     >>> nan + 1\n3111     nan\n3112     >>> Eq(nan, nan)   # mathematical equality\n3113     False\n3114     >>> nan == nan     # structural equality\n3115     True\n3116 \n3117     References\n3118     ==========\n3119 \n3120     .. [1] https://en.wikipedia.org/wiki/NaN\n3121 \n3122     \"\"\"\n3123     is_commutative = True\n3124     is_real = None\n3125     is_rational = None\n3126     is_algebraic = None\n3127     is_transcendental = None\n3128     is_integer = None\n3129     is_comparable = False\n3130     is_finite = None\n3131     is_zero = None\n3132     is_prime = None\n3133     is_positive = None\n3134     is_negative = None\n3135     is_number = True\n3136 \n3137     __slots__ = []\n3138 \n3139     def __new__(cls):\n3140         return AtomicExpr.__new__(cls)\n3141 \n3142     def _latex(self, printer):\n3143         return r\"\\text{NaN}\"\n3144 \n3145     @_sympifyit('other', NotImplemented)\n3146     def __add__(self, other):\n3147         return self\n3148 \n3149     @_sympifyit('other', NotImplemented)\n3150     def __sub__(self, other):\n3151         return self\n3152 \n3153     @_sympifyit('other', NotImplemented)\n3154     def __mul__(self, other):\n3155         return self\n3156 \n3157     @_sympifyit('other', NotImplemented)\n3158     def __div__(self, other):\n3159         return self\n3160 \n3161     __truediv__ = __div__\n3162 \n3163     def floor(self):\n3164         return self\n3165 \n3166     def ceiling(self):\n3167         return self\n3168 \n3169     def _as_mpf_val(self, prec):\n3170         return _mpf_nan\n3171 \n3172     def _sage_(self):\n3173         import sage.all as sage\n3174         return sage.NaN\n3175 \n3176     def __hash__(self):\n3177         return super(NaN, self).__hash__()\n3178 \n3179     def __eq__(self, other):\n3180         # NaN is structurally equal to another NaN\n3181         return other is S.NaN\n3182 \n3183     def __ne__(self, other):\n3184         return other is not S.NaN\n3185 \n3186     def _eval_Eq(self, other):\n3187         # NaN is not mathematically equal to anything, even NaN\n3188         return S.false\n3189 \n3190     # Expr will _sympify and raise TypeError\n3191     __gt__ = Expr.__gt__\n3192     __ge__ = Expr.__ge__\n3193     __lt__ = Expr.__lt__\n3194     __le__ = Expr.__le__\n3195 \n3196 nan = S.NaN\n3197 \n3198 \n3199 class ComplexInfinity(with_metaclass(Singleton, AtomicExpr)):\n3200     r\"\"\"Complex infinity.\n3201 \n3202     In complex analysis the symbol `\\tilde\\infty`, called \"complex\n3203     infinity\", represents a quantity with infinite magnitude, but\n3204     undetermined complex phase.\n3205 \n3206     ComplexInfinity is a singleton, and can be accessed by\n3207     ``S.ComplexInfinity``, or can be imported as ``zoo``.\n3208 \n3209     Examples\n3210     ========\n3211 \n3212     >>> from sympy import zoo, oo\n3213     >>> zoo + 42\n3214     zoo\n3215     >>> 42/zoo\n3216     0\n3217     >>> zoo + zoo\n3218     nan\n3219     >>> zoo*zoo\n3220     zoo\n3221 \n3222     See Also\n3223     ========\n3224 \n3225     Infinity\n3226     \"\"\"\n3227 \n3228     is_commutative = True\n3229     is_infinite = True\n3230     is_number = True\n3231     is_prime = False\n3232     is_complex = True\n3233     is_real = False\n3234 \n3235     __slots__ = []\n3236 \n3237     def __new__(cls):\n3238         return AtomicExpr.__new__(cls)\n3239 \n3240     def _latex(self, printer):\n3241         return r\"\\tilde{\\infty}\"\n3242 \n3243     @staticmethod\n3244     def __abs__():\n3245         return S.Infinity\n3246 \n3247     def floor(self):\n3248         return self\n3249 \n3250     def ceiling(self):\n3251         return self\n3252 \n3253     @staticmethod\n3254     def __neg__():\n3255         return S.ComplexInfinity\n3256 \n3257     def _eval_power(self, expt):\n3258         if expt is S.ComplexInfinity:\n3259             return S.NaN\n3260 \n3261         if isinstance(expt, Number):\n3262             if expt is S.Zero:\n3263                 return S.NaN\n3264             else:\n3265                 if expt.is_positive:\n3266                     return S.ComplexInfinity\n3267                 else:\n3268                     return S.Zero\n3269 \n3270     def _sage_(self):\n3271         import sage.all as sage\n3272         return sage.UnsignedInfinityRing.gen()\n3273 \n3274 \n3275 zoo = S.ComplexInfinity\n3276 \n3277 \n3278 class NumberSymbol(AtomicExpr):\n3279 \n3280     is_commutative = True\n3281     is_finite = True\n3282     is_number = True\n3283 \n3284     __slots__ = []\n3285 \n3286     is_NumberSymbol = True\n3287 \n3288     def __new__(cls):\n3289         return AtomicExpr.__new__(cls)\n3290 \n3291     def approximation(self, number_cls):\n3292         \"\"\" Return an interval with number_cls endpoints\n3293         that contains the value of NumberSymbol.\n3294         If not implemented, then return None.\n3295         \"\"\"\n3296 \n3297     def _eval_evalf(self, prec):\n3298         return Float._new(self._as_mpf_val(prec), prec)\n3299 \n3300     def __eq__(self, other):\n3301         try:\n3302             other = _sympify(other)\n3303         except SympifyError:\n3304             return NotImplemented\n3305         if self is other:\n3306             return True\n3307         if other.is_Number and self.is_irrational:\n3308             return False\n3309 \n3310         return False    # NumberSymbol != non-(Number|self)\n3311 \n3312     def __ne__(self, other):\n3313         return not self == other\n3314 \n3315     def __le__(self, other):\n3316         if self is other:\n3317             return S.true\n3318         return Expr.__le__(self, other)\n3319 \n3320     def __ge__(self, other):\n3321         if self is other:\n3322             return S.true\n3323         return Expr.__ge__(self, other)\n3324 \n3325     def __int__(self):\n3326         # subclass with appropriate return value\n3327         raise NotImplementedError\n3328 \n3329     def __long__(self):\n3330         return self.__int__()\n3331 \n3332     def __hash__(self):\n3333         return super(NumberSymbol, self).__hash__()\n3334 \n3335 \n3336 class Exp1(with_metaclass(Singleton, NumberSymbol)):\n3337     r\"\"\"The `e` constant.\n3338 \n3339     The transcendental number `e = 2.718281828\\ldots` is the base of the\n3340     natural logarithm and of the exponential function, `e = \\exp(1)`.\n3341     Sometimes called Euler's number or Napier's constant.\n3342 \n3343     Exp1 is a singleton, and can be accessed by ``S.Exp1``,\n3344     or can be imported as ``E``.\n3345 \n3346     Examples\n3347     ========\n3348 \n3349     >>> from sympy import exp, log, E\n3350     >>> E is exp(1)\n3351     True\n3352     >>> log(E)\n3353     1\n3354 \n3355     References\n3356     ==========\n3357 \n3358     .. [1] https://en.wikipedia.org/wiki/E_%28mathematical_constant%29\n3359     \"\"\"\n3360 \n3361     is_real = True\n3362     is_positive = True\n3363     is_negative = False  # XXX Forces is_negative/is_nonnegative\n3364     is_irrational = True\n3365     is_number = True\n3366     is_algebraic = False\n3367     is_transcendental = True\n3368 \n3369     __slots__ = []\n3370 \n3371     def _latex(self, printer):\n3372         return r\"e\"\n3373 \n3374     @staticmethod\n3375     def __abs__():\n3376         return S.Exp1\n3377 \n3378     def __int__(self):\n3379         return 2\n3380 \n3381     def _as_mpf_val(self, prec):\n3382         return mpf_e(prec)\n3383 \n3384     def approximation_interval(self, number_cls):\n3385         if issubclass(number_cls, Integer):\n3386             return (Integer(2), Integer(3))\n3387         elif issubclass(number_cls, Rational):\n3388             pass\n3389 \n3390     def _eval_power(self, expt):\n3391         from sympy import exp\n3392         return exp(expt)\n3393 \n3394     def _eval_rewrite_as_sin(self, **kwargs):\n3395         from sympy import sin\n3396         I = S.ImaginaryUnit\n3397         return sin(I + S.Pi/2) - I*sin(I)\n3398 \n3399     def _eval_rewrite_as_cos(self, **kwargs):\n3400         from sympy import cos\n3401         I = S.ImaginaryUnit\n3402         return cos(I) + I*cos(I + S.Pi/2)\n3403 \n3404     def _sage_(self):\n3405         import sage.all as sage\n3406         return sage.e\n3407 E = S.Exp1\n3408 \n3409 \n3410 class Pi(with_metaclass(Singleton, NumberSymbol)):\n3411     r\"\"\"The `\\pi` constant.\n3412 \n3413     The transcendental number `\\pi = 3.141592654\\ldots` represents the ratio\n3414     of a circle's circumference to its diameter, the area of the unit circle,\n3415     the half-period of trigonometric functions, and many other things\n3416     in mathematics.\n3417 \n3418     Pi is a singleton, and can be accessed by ``S.Pi``, or can\n3419     be imported as ``pi``.\n3420 \n3421     Examples\n3422     ========\n3423 \n3424     >>> from sympy import S, pi, oo, sin, exp, integrate, Symbol\n3425     >>> S.Pi\n3426     pi\n3427     >>> pi > 3\n3428     True\n3429     >>> pi.is_irrational\n3430     True\n3431     >>> x = Symbol('x')\n3432     >>> sin(x + 2*pi)\n3433     sin(x)\n3434     >>> integrate(exp(-x**2), (x, -oo, oo))\n3435     sqrt(pi)\n3436 \n3437     References\n3438     ==========\n3439 \n3440     .. [1] https://en.wikipedia.org/wiki/Pi\n3441     \"\"\"\n3442 \n3443     is_real = True\n3444     is_positive = True\n3445     is_negative = False\n3446     is_irrational = True\n3447     is_number = True\n3448     is_algebraic = False\n3449     is_transcendental = True\n3450 \n3451     __slots__ = []\n3452 \n3453     def _latex(self, printer):\n3454         return r\"\\pi\"\n3455 \n3456     @staticmethod\n3457     def __abs__():\n3458         return S.Pi\n3459 \n3460     def __int__(self):\n3461         return 3\n3462 \n3463     def _as_mpf_val(self, prec):\n3464         return mpf_pi(prec)\n3465 \n3466     def approximation_interval(self, number_cls):\n3467         if issubclass(number_cls, Integer):\n3468             return (Integer(3), Integer(4))\n3469         elif issubclass(number_cls, Rational):\n3470             return (Rational(223, 71), Rational(22, 7))\n3471 \n3472     def _sage_(self):\n3473         import sage.all as sage\n3474         return sage.pi\n3475 pi = S.Pi\n3476 \n3477 \n3478 class GoldenRatio(with_metaclass(Singleton, NumberSymbol)):\n3479     r\"\"\"The golden ratio, `\\phi`.\n3480 \n3481     `\\phi = \\frac{1 + \\sqrt{5}}{2}` is algebraic number.  Two quantities\n3482     are in the golden ratio if their ratio is the same as the ratio of\n3483     their sum to the larger of the two quantities, i.e. their maximum.\n3484 \n3485     GoldenRatio is a singleton, and can be accessed by ``S.GoldenRatio``.\n3486 \n3487     Examples\n3488     ========\n3489 \n3490     >>> from sympy import S\n3491     >>> S.GoldenRatio > 1\n3492     True\n3493     >>> S.GoldenRatio.expand(func=True)\n3494     1/2 + sqrt(5)/2\n3495     >>> S.GoldenRatio.is_irrational\n3496     True\n3497 \n3498     References\n3499     ==========\n3500 \n3501     .. [1] https://en.wikipedia.org/wiki/Golden_ratio\n3502     \"\"\"\n3503 \n3504     is_real = True\n3505     is_positive = True\n3506     is_negative = False\n3507     is_irrational = True\n3508     is_number = True\n3509     is_algebraic = True\n3510     is_transcendental = False\n3511 \n3512     __slots__ = []\n3513 \n3514     def _latex(self, printer):\n3515         return r\"\\phi\"\n3516 \n3517     def __int__(self):\n3518         return 1\n3519 \n3520     def _as_mpf_val(self, prec):\n3521          # XXX track down why this has to be increased\n3522         rv = mlib.from_man_exp(phi_fixed(prec + 10), -prec - 10)\n3523         return mpf_norm(rv, prec)\n3524 \n3525     def _eval_expand_func(self, **hints):\n3526         from sympy import sqrt\n3527         return S.Half + S.Half*sqrt(5)\n3528 \n3529     def approximation_interval(self, number_cls):\n3530         if issubclass(number_cls, Integer):\n3531             return (S.One, Rational(2))\n3532         elif issubclass(number_cls, Rational):\n3533             pass\n3534 \n3535     def _sage_(self):\n3536         import sage.all as sage\n3537         return sage.golden_ratio\n3538 \n3539     _eval_rewrite_as_sqrt = _eval_expand_func\n3540 \n3541 \n3542 class TribonacciConstant(with_metaclass(Singleton, NumberSymbol)):\n3543     r\"\"\"The tribonacci constant.\n3544 \n3545     The tribonacci numbers are like the Fibonacci numbers, but instead\n3546     of starting with two predetermined terms, the sequence starts with\n3547     three predetermined terms and each term afterwards is the sum of the\n3548     preceding three terms.\n3549 \n3550     The tribonacci constant is the ratio toward which adjacent tribonacci\n3551     numbers tend. It is a root of the polynomial `x^3 - x^2 - x - 1 = 0`,\n3552     and also satisfies the equation `x + x^{-3} = 2`.\n3553 \n3554     TribonacciConstant is a singleton, and can be accessed\n3555     by ``S.TribonacciConstant``.\n3556 \n3557     Examples\n3558     ========\n3559 \n3560     >>> from sympy import S\n3561     >>> S.TribonacciConstant > 1\n3562     True\n3563     >>> S.TribonacciConstant.expand(func=True)\n3564     1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3\n3565     >>> S.TribonacciConstant.is_irrational\n3566     True\n3567     >>> S.TribonacciConstant.n(20)\n3568     1.8392867552141611326\n3569 \n3570     References\n3571     ==========\n3572 \n3573     .. [1] https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers\n3574     \"\"\"\n3575 \n3576     is_real = True\n3577     is_positive = True\n3578     is_negative = False\n3579     is_irrational = True\n3580     is_number = True\n3581     is_algebraic = True\n3582     is_transcendental = False\n3583 \n3584     __slots__ = []\n3585 \n3586     def _latex(self, printer):\n3587         return r\"\\text{TribonacciConstant}\"\n3588 \n3589     def __int__(self):\n3590         return 2\n3591 \n3592     def _eval_evalf(self, prec):\n3593         rv = self._eval_expand_func(function=True)._eval_evalf(prec + 4)\n3594         return Float(rv, precision=prec)\n3595 \n3596     def _eval_expand_func(self, **hints):\n3597         from sympy import sqrt, cbrt\n3598         return (1 + cbrt(19 - 3*sqrt(33)) + cbrt(19 + 3*sqrt(33))) / 3\n3599 \n3600     def approximation_interval(self, number_cls):\n3601         if issubclass(number_cls, Integer):\n3602             return (S.One, Rational(2))\n3603         elif issubclass(number_cls, Rational):\n3604             pass\n3605 \n3606     _eval_rewrite_as_sqrt = _eval_expand_func\n3607 \n3608 \n3609 class EulerGamma(with_metaclass(Singleton, NumberSymbol)):\n3610     r\"\"\"The Euler-Mascheroni constant.\n3611 \n3612     `\\gamma = 0.5772157\\ldots` (also called Euler's constant) is a mathematical\n3613     constant recurring in analysis and number theory.  It is defined as the\n3614     limiting difference between the harmonic series and the\n3615     natural logarithm:\n3616 \n3617     .. math:: \\gamma = \\lim\\limits_{n\\to\\infty}\n3618               \\left(\\sum\\limits_{k=1}^n\\frac{1}{k} - \\ln n\\right)\n3619 \n3620     EulerGamma is a singleton, and can be accessed by ``S.EulerGamma``.\n3621 \n3622     Examples\n3623     ========\n3624 \n3625     >>> from sympy import S\n3626     >>> S.EulerGamma.is_irrational\n3627     >>> S.EulerGamma > 0\n3628     True\n3629     >>> S.EulerGamma > 1\n3630     False\n3631 \n3632     References\n3633     ==========\n3634 \n3635     .. [1] https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant\n3636     \"\"\"\n3637 \n3638     is_real = True\n3639     is_positive = True\n3640     is_negative = False\n3641     is_irrational = None\n3642     is_number = True\n3643 \n3644     __slots__ = []\n3645 \n3646     def _latex(self, printer):\n3647         return r\"\\gamma\"\n3648 \n3649     def __int__(self):\n3650         return 0\n3651 \n3652     def _as_mpf_val(self, prec):\n3653          # XXX track down why this has to be increased\n3654         v = mlib.libhyper.euler_fixed(prec + 10)\n3655         rv = mlib.from_man_exp(v, -prec - 10)\n3656         return mpf_norm(rv, prec)\n3657 \n3658     def approximation_interval(self, number_cls):\n3659         if issubclass(number_cls, Integer):\n3660             return (S.Zero, S.One)\n3661         elif issubclass(number_cls, Rational):\n3662             return (S.Half, Rational(3, 5))\n3663 \n3664     def _sage_(self):\n3665         import sage.all as sage\n3666         return sage.euler_gamma\n3667 \n3668 \n3669 class Catalan(with_metaclass(Singleton, NumberSymbol)):\n3670     r\"\"\"Catalan's constant.\n3671 \n3672     `K = 0.91596559\\ldots` is given by the infinite series\n3673 \n3674     .. math:: K = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{(2k+1)^2}\n3675 \n3676     Catalan is a singleton, and can be accessed by ``S.Catalan``.\n3677 \n3678     Examples\n3679     ========\n3680 \n3681     >>> from sympy import S\n3682     >>> S.Catalan.is_irrational\n3683     >>> S.Catalan > 0\n3684     True\n3685     >>> S.Catalan > 1\n3686     False\n3687 \n3688     References\n3689     ==========\n3690 \n3691     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant\n3692     \"\"\"\n3693 \n3694     is_real = True\n3695     is_positive = True\n3696     is_negative = False\n3697     is_irrational = None\n3698     is_number = True\n3699 \n3700     __slots__ = []\n3701 \n3702     def __int__(self):\n3703         return 0\n3704 \n3705     def _as_mpf_val(self, prec):\n3706         # XXX track down why this has to be increased\n3707         v = mlib.catalan_fixed(prec + 10)\n3708         rv = mlib.from_man_exp(v, -prec - 10)\n3709         return mpf_norm(rv, prec)\n3710 \n3711     def approximation_interval(self, number_cls):\n3712         if issubclass(number_cls, Integer):\n3713             return (S.Zero, S.One)\n3714         elif issubclass(number_cls, Rational):\n3715             return (Rational(9, 10), S.One)\n3716 \n3717     def _sage_(self):\n3718         import sage.all as sage\n3719         return sage.catalan\n3720 \n3721 \n3722 class ImaginaryUnit(with_metaclass(Singleton, AtomicExpr)):\n3723     r\"\"\"The imaginary unit, `i = \\sqrt{-1}`.\n3724 \n3725     I is a singleton, and can be accessed by ``S.I``, or can be\n3726     imported as ``I``.\n3727 \n3728     Examples\n3729     ========\n3730 \n3731     >>> from sympy import I, sqrt\n3732     >>> sqrt(-1)\n3733     I\n3734     >>> I*I\n3735     -1\n3736     >>> 1/I\n3737     -I\n3738 \n3739     References\n3740     ==========\n3741 \n3742     .. [1] https://en.wikipedia.org/wiki/Imaginary_unit\n3743     \"\"\"\n3744 \n3745     is_commutative = True\n3746     is_imaginary = True\n3747     is_finite = True\n3748     is_number = True\n3749     is_algebraic = True\n3750     is_transcendental = False\n3751 \n3752     __slots__ = []\n3753 \n3754     def _latex(self, printer):\n3755         return printer._settings['imaginary_unit_latex']\n3756 \n3757     @staticmethod\n3758     def __abs__():\n3759         return S.One\n3760 \n3761     def _eval_evalf(self, prec):\n3762         return self\n3763 \n3764     def _eval_conjugate(self):\n3765         return -S.ImaginaryUnit\n3766 \n3767     def _eval_power(self, expt):\n3768         \"\"\"\n3769         b is I = sqrt(-1)\n3770         e is symbolic object but not equal to 0, 1\n3771 \n3772         I**r -> (-1)**(r/2) -> exp(r/2*Pi*I) -> sin(Pi*r/2) + cos(Pi*r/2)*I, r is decimal\n3773         I**0 mod 4 -> 1\n3774         I**1 mod 4 -> I\n3775         I**2 mod 4 -> -1\n3776         I**3 mod 4 -> -I\n3777         \"\"\"\n3778 \n3779         if isinstance(expt, Number):\n3780             if isinstance(expt, Integer):\n3781                 expt = expt.p % 4\n3782                 if expt == 0:\n3783                     return S.One\n3784                 if expt == 1:\n3785                     return S.ImaginaryUnit\n3786                 if expt == 2:\n3787                     return -S.One\n3788                 return -S.ImaginaryUnit\n3789         return\n3790 \n3791     def as_base_exp(self):\n3792         return S.NegativeOne, S.Half\n3793 \n3794     def _sage_(self):\n3795         import sage.all as sage\n3796         return sage.I\n3797 \n3798     @property\n3799     def _mpc_(self):\n3800         return (Float(0)._mpf_, Float(1)._mpf_)\n3801 \n3802 I = S.ImaginaryUnit\n3803 \n3804 \n3805 def sympify_fractions(f):\n3806     return Rational(f.numerator, f.denominator, 1)\n3807 \n3808 converter[fractions.Fraction] = sympify_fractions\n3809 \n3810 try:\n3811     if HAS_GMPY == 2:\n3812         import gmpy2 as gmpy\n3813     elif HAS_GMPY == 1:\n3814         import gmpy\n3815     else:\n3816         raise ImportError\n3817 \n3818     def sympify_mpz(x):\n3819         return Integer(long(x))\n3820 \n3821     def sympify_mpq(x):\n3822         return Rational(long(x.numerator), long(x.denominator))\n3823 \n3824     converter[type(gmpy.mpz(1))] = sympify_mpz\n3825     converter[type(gmpy.mpq(1, 2))] = sympify_mpq\n3826 except ImportError:\n3827     pass\n3828 \n3829 \n3830 def sympify_mpmath(x):\n3831     return Expr._from_mpmath(x, x.context.prec)\n3832 \n3833 converter[mpnumeric] = sympify_mpmath\n3834 \n3835 \n3836 def sympify_mpq(x):\n3837     p, q = x._mpq_\n3838     return Rational(p, q, 1)\n3839 \n3840 converter[type(mpmath.rational.mpq(1, 2))] = sympify_mpq\n3841 \n3842 \n3843 def sympify_complex(a):\n3844     real, imag = list(map(sympify, (a.real, a.imag)))\n3845     return real + S.ImaginaryUnit*imag\n3846 \n3847 converter[complex] = sympify_complex\n3848 \n3849 from .power import Pow, integer_nthroot\n3850 from .mul import Mul\n3851 Mul.identity = One()\n3852 from .add import Add\n3853 Add.identity = Zero()\n3854 \n3855 def _register_classes():\n3856     numbers.Number.register(Number)\n3857     numbers.Real.register(Float)\n3858     numbers.Rational.register(Rational)\n3859     numbers.Rational.register(Integer)\n3860 \n3861 _register_classes()\n",
        "intended_behavior": "Ensure that division between numbers, especially involving fractions or symbolic representations like 'Half', follows Python's standard arithmetic rules, allowing for floor division without raising an error unless mathematically justified (e.g., division by zero)."
    },
    {
        "rel_file_path": "sympy/core/power.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/core/power.py",
        "start": 1,
        "end": 1682,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from math import log as _log\n4 \n5 from .sympify import _sympify\n6 from .cache import cacheit\n7 from .singleton import S\n8 from .expr import Expr\n9 from .evalf import PrecisionExhausted\n10 from .function import (_coeff_isneg, expand_complex, expand_multinomial,\n11     expand_mul)\n12 from .logic import fuzzy_bool, fuzzy_not, fuzzy_and\n13 from .compatibility import as_int, range\n14 from .evaluate import global_evaluate\n15 from sympy.utilities.iterables import sift\n16 \n17 from mpmath.libmp import sqrtrem as mpmath_sqrtrem\n18 \n19 from math import sqrt as _sqrt\n20 \n21 \n22 \n23 def isqrt(n):\n24     \"\"\"Return the largest integer less than or equal to sqrt(n).\"\"\"\n25     if n < 17984395633462800708566937239552:\n26         return int(_sqrt(n))\n27     return integer_nthroot(int(n), 2)[0]\n28 \n29 \n30 def integer_nthroot(y, n):\n31     \"\"\"\n32     Return a tuple containing x = floor(y**(1/n))\n33     and a boolean indicating whether the result is exact (that is,\n34     whether x**n == y).\n35 \n36     Examples\n37     ========\n38 \n39     >>> from sympy import integer_nthroot\n40     >>> integer_nthroot(16, 2)\n41     (4, True)\n42     >>> integer_nthroot(26, 2)\n43     (5, False)\n44 \n45     To simply determine if a number is a perfect square, the is_square\n46     function should be used:\n47 \n48     >>> from sympy.ntheory.primetest import is_square\n49     >>> is_square(26)\n50     False\n51 \n52     See Also\n53     ========\n54     sympy.ntheory.primetest.is_square\n55     integer_log\n56     \"\"\"\n57     y, n = as_int(y), as_int(n)\n58     if y < 0:\n59         raise ValueError(\"y must be nonnegative\")\n60     if n < 1:\n61         raise ValueError(\"n must be positive\")\n62     if y in (0, 1):\n63         return y, True\n64     if n == 1:\n65         return y, True\n66     if n == 2:\n67         x, rem = mpmath_sqrtrem(y)\n68         return int(x), not rem\n69     if n > y:\n70         return 1, False\n71     # Get initial estimate for Newton's method. Care must be taken to\n72     # avoid overflow\n73     try:\n74         guess = int(y**(1./n) + 0.5)\n75     except OverflowError:\n76         exp = _log(y, 2)/n\n77         if exp > 53:\n78             shift = int(exp - 53)\n79             guess = int(2.0**(exp - shift) + 1) << shift\n80         else:\n81             guess = int(2.0**exp)\n82     if guess > 2**50:\n83         # Newton iteration\n84         xprev, x = -1, guess\n85         while 1:\n86             t = x**(n - 1)\n87             xprev, x = x, ((n - 1)*x + y//t)//n\n88             if abs(x - xprev) < 2:\n89                 break\n90     else:\n91         x = guess\n92     # Compensate\n93     t = x**n\n94     while t < y:\n95         x += 1\n96         t = x**n\n97     while t > y:\n98         x -= 1\n99         t = x**n\n100     return int(x), t == y  # int converts long to int if possible\n101 \n102 \n103 def integer_log(y, x):\n104     \"\"\"Returns (e, bool) where e is the largest nonnegative integer\n105     such that |y| >= |x**e| and bool is True if y == x**e\n106 \n107     Examples\n108     ========\n109 \n110     >>> from sympy import integer_log\n111     >>> integer_log(125, 5)\n112     (3, True)\n113     >>> integer_log(17, 9)\n114     (1, False)\n115     >>> integer_log(4, -2)\n116     (2, True)\n117     >>> integer_log(-125,-5)\n118     (3, True)\n119 \n120     See Also\n121     ========\n122     integer_nthroot\n123     sympy.ntheory.primetest.is_square\n124     sympy.ntheory.factor_.multiplicity\n125     sympy.ntheory.factor_.perfect_power\n126     \"\"\"\n127     if x == 1:\n128         raise ValueError('x cannot take value as 1')\n129     if y == 0:\n130         raise ValueError('y cannot take value as 0')\n131 \n132     if x in (-2, 2):\n133         x = int(x)\n134         y = as_int(y)\n135         e = y.bit_length() - 1\n136         return e, x**e == y\n137     if x < 0:\n138         n, b = integer_log(y if y > 0 else -y, -x)\n139         return n, b and bool(n % 2 if y < 0 else not n % 2)\n140 \n141     x = as_int(x)\n142     y = as_int(y)\n143     r = e = 0\n144     while y >= x:\n145         d = x\n146         m = 1\n147         while y >= d:\n148             y, rem = divmod(y, d)\n149             r = r or rem\n150             e += m\n151             if y > d:\n152                 d *= d\n153                 m *= 2\n154     return e, r == 0 and y == 1\n155 \n156 \n157 class Pow(Expr):\n158     \"\"\"\n159     Defines the expression x**y as \"x raised to a power y\"\n160 \n161     Singleton definitions involving (0, 1, -1, oo, -oo, I, -I):\n162 \n163     +--------------+---------+-----------------------------------------------+\n164     | expr         | value   | reason                                        |\n165     +==============+=========+===============================================+\n166     | z**0         | 1       | Although arguments over 0**0 exist, see [2].  |\n167     +--------------+---------+-----------------------------------------------+\n168     | z**1         | z       |                                               |\n169     +--------------+---------+-----------------------------------------------+\n170     | (-oo)**(-1)  | 0       |                                               |\n171     +--------------+---------+-----------------------------------------------+\n172     | (-1)**-1     | -1      |                                               |\n173     +--------------+---------+-----------------------------------------------+\n174     | S.Zero**-1   | zoo     | This is not strictly true, as 0**-1 may be    |\n175     |              |         | undefined, but is convenient in some contexts |\n176     |              |         | where the base is assumed to be positive.     |\n177     +--------------+---------+-----------------------------------------------+\n178     | 1**-1        | 1       |                                               |\n179     +--------------+---------+-----------------------------------------------+\n180     | oo**-1       | 0       |                                               |\n181     +--------------+---------+-----------------------------------------------+\n182     | 0**oo        | 0       | Because for all complex numbers z near        |\n183     |              |         | 0, z**oo -> 0.                                |\n184     +--------------+---------+-----------------------------------------------+\n185     | 0**-oo       | zoo     | This is not strictly true, as 0**oo may be    |\n186     |              |         | oscillating between positive and negative     |\n187     |              |         | values or rotating in the complex plane.      |\n188     |              |         | It is convenient, however, when the base      |\n189     |              |         | is positive.                                  |\n190     +--------------+---------+-----------------------------------------------+\n191     | 1**oo        | nan     | Because there are various cases where         |\n192     | 1**-oo       |         | lim(x(t),t)=1, lim(y(t),t)=oo (or -oo),       |\n193     |              |         | but lim( x(t)**y(t), t) != 1.  See [3].       |\n194     +--------------+---------+-----------------------------------------------+\n195     | b**zoo       | nan     | Because b**z has no limit as z -> zoo         |\n196     +--------------+---------+-----------------------------------------------+\n197     | (-1)**oo     | nan     | Because of oscillations in the limit.         |\n198     | (-1)**(-oo)  |         |                                               |\n199     +--------------+---------+-----------------------------------------------+\n200     | oo**oo       | oo      |                                               |\n201     +--------------+---------+-----------------------------------------------+\n202     | oo**-oo      | 0       |                                               |\n203     +--------------+---------+-----------------------------------------------+\n204     | (-oo)**oo    | nan     |                                               |\n205     | (-oo)**-oo   |         |                                               |\n206     +--------------+---------+-----------------------------------------------+\n207     | oo**I        | nan     | oo**e could probably be best thought of as    |\n208     | (-oo)**I     |         | the limit of x**e for real x as x tends to    |\n209     |              |         | oo. If e is I, then the limit does not exist  |\n210     |              |         | and nan is used to indicate that.             |\n211     +--------------+---------+-----------------------------------------------+\n212     | oo**(1+I)    | zoo     | If the real part of e is positive, then the   |\n213     | (-oo)**(1+I) |         | limit of abs(x**e) is oo. So the limit value  |\n214     |              |         | is zoo.                                       |\n215     +--------------+---------+-----------------------------------------------+\n216     | oo**(-1+I)   | 0       | If the real part of e is negative, then the   |\n217     | -oo**(-1+I)  |         | limit is 0.                                   |\n218     +--------------+---------+-----------------------------------------------+\n219 \n220     Because symbolic computations are more flexible that floating point\n221     calculations and we prefer to never return an incorrect answer,\n222     we choose not to conform to all IEEE 754 conventions.  This helps\n223     us avoid extra test-case code in the calculation of limits.\n224 \n225     See Also\n226     ========\n227 \n228     sympy.core.numbers.Infinity\n229     sympy.core.numbers.NegativeInfinity\n230     sympy.core.numbers.NaN\n231 \n232     References\n233     ==========\n234 \n235     .. [1] https://en.wikipedia.org/wiki/Exponentiation\n236     .. [2] https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_power_of_zero\n237     .. [3] https://en.wikipedia.org/wiki/Indeterminate_forms\n238 \n239     \"\"\"\n240     is_Pow = True\n241 \n242     __slots__ = ['is_commutative']\n243 \n244     @cacheit\n245     def __new__(cls, b, e, evaluate=None):\n246         if evaluate is None:\n247             evaluate = global_evaluate[0]\n248         from sympy.functions.elementary.exponential import exp_polar\n249 \n250         b = _sympify(b)\n251         e = _sympify(e)\n252         if evaluate:\n253             if e is S.ComplexInfinity:\n254                 return S.NaN\n255             if e is S.Zero:\n256                 return S.One\n257             elif e is S.One:\n258                 return b\n259             # Only perform autosimplification if exponent or base is a Symbol or number\n260             elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and\\\n261                 e.is_integer and _coeff_isneg(b):\n262                 if e.is_even:\n263                     b = -b\n264                 elif e.is_odd:\n265                     return -Pow(-b, e)\n266             if S.NaN in (b, e):  # XXX S.NaN**x -> S.NaN under assumption that x != 0\n267                 return S.NaN\n268             elif b is S.One:\n269                 if abs(e).is_infinite:\n270                     return S.NaN\n271                 return S.One\n272             else:\n273                 # recognize base as E\n274                 if not e.is_Atom and b is not S.Exp1 and not isinstance(b, exp_polar):\n275                     from sympy import numer, denom, log, sign, im, factor_terms\n276                     c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n277                     den = denom(ex)\n278                     if isinstance(den, log) and den.args[0] == b:\n279                         return S.Exp1**(c*numer(ex))\n280                     elif den.is_Add:\n281                         s = sign(im(b))\n282                         if s.is_Number and s and den == \\\n283                                 log(-factor_terms(b, sign=False)) + s*S.ImaginaryUnit*S.Pi:\n284                             return S.Exp1**(c*numer(ex))\n285 \n286                 obj = b._eval_power(e)\n287                 if obj is not None:\n288                     return obj\n289         obj = Expr.__new__(cls, b, e)\n290         obj = cls._exec_constructor_postprocessors(obj)\n291         if not isinstance(obj, Pow):\n292             return obj\n293         obj.is_commutative = (b.is_commutative and e.is_commutative)\n294         return obj\n295 \n296     @property\n297     def base(self):\n298         return self._args[0]\n299 \n300     @property\n301     def exp(self):\n302         return self._args[1]\n303 \n304     @classmethod\n305     def class_key(cls):\n306         return 3, 2, cls.__name__\n307 \n308     def _eval_refine(self, assumptions):\n309         from sympy.assumptions.ask import ask, Q\n310         b, e = self.as_base_exp()\n311         if ask(Q.integer(e), assumptions) and _coeff_isneg(b):\n312             if ask(Q.even(e), assumptions):\n313                 return Pow(-b, e)\n314             elif ask(Q.odd(e), assumptions):\n315                 return -Pow(-b, e)\n316 \n317     def _eval_power(self, other):\n318         from sympy import Abs, arg, exp, floor, im, log, re, sign\n319         b, e = self.as_base_exp()\n320         if b is S.NaN:\n321             return (b**e)**other  # let __new__ handle it\n322 \n323         s = None\n324         if other.is_integer:\n325             s = 1\n326         elif b.is_polar:  # e.g. exp_polar, besselj, var('p', polar=True)...\n327             s = 1\n328         elif e.is_real is not None:\n329             # helper functions ===========================\n330             def _half(e):\n331                 \"\"\"Return True if the exponent has a literal 2 as the\n332                 denominator, else None.\"\"\"\n333                 if getattr(e, 'q', None) == 2:\n334                     return True\n335                 n, d = e.as_numer_denom()\n336                 if n.is_integer and d == 2:\n337                     return True\n338             def _n2(e):\n339                 \"\"\"Return ``e`` evaluated to a Number with 2 significant\n340                 digits, else None.\"\"\"\n341                 try:\n342                     rv = e.evalf(2, strict=True)\n343                     if rv.is_Number:\n344                         return rv\n345                 except PrecisionExhausted:\n346                     pass\n347             # ===================================================\n348             if e.is_real:\n349                 # we need _half(other) with constant floor or\n350                 # floor(S.Half - e*arg(b)/2/pi) == 0\n351 \n352                 # handle -1 as special case\n353                 if e == -1:\n354                     # floor arg. is 1/2 + arg(b)/2/pi\n355                     if _half(other):\n356                         if b.is_negative is True:\n357                             return S.NegativeOne**other*Pow(-b, e*other)\n358                         if b.is_real is False:\n359                             return Pow(b.conjugate()/Abs(b)**2, other)\n360                 elif e.is_even:\n361                     if b.is_real:\n362                         b = abs(b)\n363                     if b.is_imaginary:\n364                         b = abs(im(b))*S.ImaginaryUnit\n365 \n366                 if (abs(e) < 1) == True or e == 1:\n367                     s = 1  # floor = 0\n368                 elif b.is_nonnegative:\n369                     s = 1  # floor = 0\n370                 elif re(b).is_nonnegative and (abs(e) < 2) == True:\n371                     s = 1  # floor = 0\n372                 elif fuzzy_not(im(b).is_zero) and abs(e) == 2:\n373                     s = 1  # floor = 0\n374                 elif _half(other):\n375                     s = exp(2*S.Pi*S.ImaginaryUnit*other*floor(\n376                         S.Half - e*arg(b)/(2*S.Pi)))\n377                     if s.is_real and _n2(sign(s) - s) == 0:\n378                         s = sign(s)\n379                     else:\n380                         s = None\n381             else:\n382                 # e.is_real is False requires:\n383                 #     _half(other) with constant floor or\n384                 #     floor(S.Half - im(e*log(b))/2/pi) == 0\n385                 try:\n386                     s = exp(2*S.ImaginaryUnit*S.Pi*other*\n387                         floor(S.Half - im(e*log(b))/2/S.Pi))\n388                     # be careful to test that s is -1 or 1 b/c sign(I) == I:\n389                     # so check that s is real\n390                     if s.is_real and _n2(sign(s) - s) == 0:\n391                         s = sign(s)\n392                     else:\n393                         s = None\n394                 except PrecisionExhausted:\n395                     s = None\n396 \n397         if s is not None:\n398             return s*Pow(b, e*other)\n399 \n400     def _eval_Mod(self, q):\n401         if self.exp.is_integer and self.exp.is_positive:\n402             if q.is_integer and self.base % q == 0:\n403                 return S.Zero\n404 \n405             '''\n406             For unevaluated Integer power, use built-in pow modular\n407             exponentiation, if powers are not too large wrt base.\n408             '''\n409             if self.base.is_Integer and self.exp.is_Integer and q.is_Integer:\n410                 b, e, m = int(self.base), int(self.exp), int(q)\n411                 # For very large powers, use totient reduction if e >= lg(m).\n412                 # Bound on m, is for safe factorization memory wise ie m^(1/4).\n413                 # For pollard-rho to be faster than built-in pow lg(e) > m^(1/4)\n414                 # check is added.\n415                 mb = m.bit_length()\n416                 if mb <= 80  and e >= mb and e.bit_length()**4 >= m:\n417                     from sympy.ntheory import totient\n418                     phi = totient(m)\n419                     return pow(b, phi + e%phi, m)\n420                 else:\n421                     return pow(b, e, m)\n422 \n423     def _eval_is_even(self):\n424         if self.exp.is_integer and self.exp.is_positive:\n425             return self.base.is_even\n426 \n427     def _eval_is_positive(self):\n428         from sympy import log\n429         if self.base == self.exp:\n430             if self.base.is_nonnegative:\n431                 return True\n432         elif self.base.is_positive:\n433             if self.exp.is_real:\n434                 return True\n435         elif self.base.is_negative:\n436             if self.exp.is_even:\n437                 return True\n438             if self.exp.is_odd:\n439                 return False\n440         elif self.base.is_zero:\n441             if self.exp.is_real:\n442                 return self.exp.is_zero\n443         elif self.base.is_nonpositive:\n444             if self.exp.is_odd:\n445                 return False\n446         elif self.base.is_imaginary:\n447             if self.exp.is_integer:\n448                 m = self.exp % 4\n449                 if m.is_zero:\n450                     return True\n451                 if m.is_integer and m.is_zero is False:\n452                     return False\n453             if self.exp.is_imaginary:\n454                 return log(self.base).is_imaginary\n455 \n456     def _eval_is_negative(self):\n457         if self.base.is_negative:\n458             if self.exp.is_odd:\n459                 return True\n460             if self.exp.is_even:\n461                 return False\n462         elif self.base.is_positive:\n463             if self.exp.is_real:\n464                 return False\n465         elif self.base.is_zero:\n466             if self.exp.is_real:\n467                 return False\n468         elif self.base.is_nonnegative:\n469             if self.exp.is_nonnegative:\n470                 return False\n471         elif self.base.is_nonpositive:\n472             if self.exp.is_even:\n473                 return False\n474         elif self.base.is_real:\n475             if self.exp.is_even:\n476                 return False\n477 \n478     def _eval_is_zero(self):\n479         if self.base.is_zero:\n480             if self.exp.is_positive:\n481                 return True\n482             elif self.exp.is_nonpositive:\n483                 return False\n484         elif self.base.is_zero is False:\n485             if self.exp.is_finite:\n486                 return False\n487             elif self.exp.is_infinite:\n488                 if (1 - abs(self.base)).is_positive:\n489                     return self.exp.is_positive\n490                 elif (1 - abs(self.base)).is_negative:\n491                     return self.exp.is_negative\n492         else:\n493             # when self.base.is_zero is None\n494             return None\n495 \n496     def _eval_is_integer(self):\n497         b, e = self.args\n498         if b.is_rational:\n499             if b.is_integer is False and e.is_positive:\n500                 return False  # rat**nonneg\n501         if b.is_integer and e.is_integer:\n502             if b is S.NegativeOne:\n503                 return True\n504             if e.is_nonnegative or e.is_positive:\n505                 return True\n506         if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):\n507             if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):\n508                 return False\n509         if b.is_Number and e.is_Number:\n510             check = self.func(*self.args)\n511             return check.is_Integer\n512 \n513     def _eval_is_real(self):\n514         from sympy import arg, exp, log, Mul\n515         real_b = self.base.is_real\n516         if real_b is None:\n517             if self.base.func == exp and self.base.args[0].is_imaginary:\n518                 return self.exp.is_imaginary\n519             return\n520         real_e = self.exp.is_real\n521         if real_e is None:\n522             return\n523         if real_b and real_e:\n524             if self.base.is_positive:\n525                 return True\n526             elif self.base.is_nonnegative:\n527                 if self.exp.is_nonnegative:\n528                     return True\n529             else:\n530                 if self.exp.is_integer:\n531                     return True\n532                 elif self.base.is_negative:\n533                     if self.exp.is_Rational:\n534                         return False\n535         if real_e and self.exp.is_negative:\n536             return Pow(self.base, -self.exp).is_real\n537         im_b = self.base.is_imaginary\n538         im_e = self.exp.is_imaginary\n539         if im_b:\n540             if self.exp.is_integer:\n541                 if self.exp.is_even:\n542                     return True\n543                 elif self.exp.is_odd:\n544                     return False\n545             elif im_e and log(self.base).is_imaginary:\n546                 return True\n547             elif self.exp.is_Add:\n548                 c, a = self.exp.as_coeff_Add()\n549                 if c and c.is_Integer:\n550                     return Mul(\n551                         self.base**c, self.base**a, evaluate=False).is_real\n552             elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):\n553                 if (self.exp/2).is_integer is False:\n554                     return False\n555         if real_b and im_e:\n556             if self.base is S.NegativeOne:\n557                 return True\n558             c = self.exp.coeff(S.ImaginaryUnit)\n559             if c:\n560                 ok = (c*log(self.base)/S.Pi).is_Integer\n561                 if ok is not None:\n562                     return ok\n563 \n564         if real_b is False:  # we already know it's not imag\n565             i = arg(self.base)*self.exp/S.Pi\n566             return i.is_integer\n567 \n568     def _eval_is_complex(self):\n569         if all(a.is_complex for a in self.args):\n570             return True\n571 \n572     def _eval_is_imaginary(self):\n573         from sympy import arg, log\n574         if self.base.is_imaginary:\n575             if self.exp.is_integer:\n576                 odd = self.exp.is_odd\n577                 if odd is not None:\n578                     return odd\n579                 return\n580 \n581         if self.exp.is_imaginary:\n582             imlog = log(self.base).is_imaginary\n583             if imlog is not None:\n584                 return False  # I**i -> real; (2*I)**i -> complex ==> not imaginary\n585 \n586         if self.base.is_real and self.exp.is_real:\n587             if self.base.is_positive:\n588                 return False\n589             else:\n590                 rat = self.exp.is_rational\n591                 if not rat:\n592                     return rat\n593                 if self.exp.is_integer:\n594                     return False\n595                 else:\n596                     half = (2*self.exp).is_integer\n597                     if half:\n598                         return self.base.is_negative\n599                     return half\n600 \n601         if self.base.is_real is False:  # we already know it's not imag\n602             i = arg(self.base)*self.exp/S.Pi\n603             isodd = (2*i).is_odd\n604             if isodd is not None:\n605                 return isodd\n606 \n607         if self.exp.is_negative:\n608             return (1/self).is_imaginary\n609 \n610     def _eval_is_odd(self):\n611         if self.exp.is_integer:\n612             if self.exp.is_positive:\n613                 return self.base.is_odd\n614             elif self.exp.is_nonnegative and self.base.is_odd:\n615                 return True\n616             elif self.base is S.NegativeOne:\n617                 return True\n618 \n619     def _eval_is_finite(self):\n620         if self.exp.is_negative:\n621             if self.base.is_zero:\n622                 return False\n623             if self.base.is_infinite:\n624                 return True\n625         c1 = self.base.is_finite\n626         if c1 is None:\n627             return\n628         c2 = self.exp.is_finite\n629         if c2 is None:\n630             return\n631         if c1 and c2:\n632             if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n633                 return True\n634 \n635     def _eval_is_prime(self):\n636         '''\n637         An integer raised to the n(>=2)-th power cannot be a prime.\n638         '''\n639         if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:\n640             return False\n641 \n642     def _eval_is_composite(self):\n643         \"\"\"\n644         A power is composite if both base and exponent are greater than 1\n645         \"\"\"\n646         if (self.base.is_integer and self.exp.is_integer and\n647             ((self.base - 1).is_positive and (self.exp - 1).is_positive or\n648             (self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):\n649             return True\n650 \n651     def _eval_is_polar(self):\n652         return self.base.is_polar\n653 \n654     def _eval_subs(self, old, new):\n655         from sympy import exp, log, Symbol\n656         def _check(ct1, ct2, old):\n657             \"\"\"Return (bool, pow, remainder_pow) where, if bool is True, then the\n658             exponent of Pow `old` will combine with `pow` so the substitution\n659             is valid, otherwise bool will be False.\n660 \n661             For noncommutative objects, `pow` will be an integer, and a factor\n662             `Pow(old.base, remainder_pow)` needs to be included. If there is\n663             no such factor, None is returned. For commutative objects,\n664             remainder_pow is always None.\n665 \n666             cti are the coefficient and terms of an exponent of self or old\n667             In this _eval_subs routine a change like (b**(2*x)).subs(b**x, y)\n668             will give y**2 since (b**x)**2 == b**(2*x); if that equality does\n669             not hold then the substitution should not occur so `bool` will be\n670             False.\n671 \n672             \"\"\"\n673             coeff1, terms1 = ct1\n674             coeff2, terms2 = ct2\n675             if terms1 == terms2:\n676                 if old.is_commutative:\n677                     # Allow fractional powers for commutative objects\n678                     pow = coeff1/coeff2\n679                     try:\n680                         pow = as_int(pow, strict=False)\n681                         combines = True\n682                     except ValueError:\n683                         combines = isinstance(Pow._eval_power(\n684                             Pow(*old.as_base_exp(), evaluate=False),\n685                             pow), (Pow, exp, Symbol))\n686                     return combines, pow, None\n687                 else:\n688                     # With noncommutative symbols, substitute only integer powers\n689                     if not isinstance(terms1, tuple):\n690                         terms1 = (terms1,)\n691                     if not all(term.is_integer for term in terms1):\n692                         return False, None, None\n693 \n694                     try:\n695                         # Round pow toward zero\n696                         pow, remainder = divmod(as_int(coeff1), as_int(coeff2))\n697                         if pow < 0 and remainder != 0:\n698                             pow += 1\n699                             remainder -= as_int(coeff2)\n700 \n701                         if remainder == 0:\n702                             remainder_pow = None\n703                         else:\n704                             remainder_pow = Mul(remainder, *terms1)\n705 \n706                         return True, pow, remainder_pow\n707                     except ValueError:\n708                         # Can't substitute\n709                         pass\n710 \n711             return False, None, None\n712 \n713         if old == self.base:\n714             return new**self.exp._subs(old, new)\n715 \n716         # issue 10829: (4**x - 3*y + 2).subs(2**x, y) -> y**2 - 3*y + 2\n717         if isinstance(old, self.func) and self.exp == old.exp:\n718             l = log(self.base, old.base)\n719             if l.is_Number:\n720                 return Pow(new, l)\n721 \n722         if isinstance(old, self.func) and self.base == old.base:\n723             if self.exp.is_Add is False:\n724                 ct1 = self.exp.as_independent(Symbol, as_Add=False)\n725                 ct2 = old.exp.as_independent(Symbol, as_Add=False)\n726                 ok, pow, remainder_pow = _check(ct1, ct2, old)\n727                 if ok:\n728                     # issue 5180: (x**(6*y)).subs(x**(3*y),z)->z**2\n729                     result = self.func(new, pow)\n730                     if remainder_pow is not None:\n731                         result = Mul(result, Pow(old.base, remainder_pow))\n732                     return result\n733             else:  # b**(6*x + a).subs(b**(3*x), y) -> y**2 * b**a\n734                 # exp(exp(x) + exp(x**2)).subs(exp(exp(x)), w) -> w * exp(exp(x**2))\n735                 oarg = old.exp\n736                 new_l = []\n737                 o_al = []\n738                 ct2 = oarg.as_coeff_mul()\n739                 for a in self.exp.args:\n740                     newa = a._subs(old, new)\n741                     ct1 = newa.as_coeff_mul()\n742                     ok, pow, remainder_pow = _check(ct1, ct2, old)\n743                     if ok:\n744                         new_l.append(new**pow)\n745                         if remainder_pow is not None:\n746                             o_al.append(remainder_pow)\n747                         continue\n748                     elif not old.is_commutative and not newa.is_integer:\n749                         # If any term in the exponent is non-integer,\n750                         # we do not do any substitutions in the noncommutative case\n751                         return\n752                     o_al.append(newa)\n753                 if new_l:\n754                     expo = Add(*o_al)\n755                     new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)\n756                     return Mul(*new_l)\n757 \n758         if isinstance(old, exp) and self.exp.is_real and self.base.is_positive:\n759             ct1 = old.args[0].as_independent(Symbol, as_Add=False)\n760             ct2 = (self.exp*log(self.base)).as_independent(\n761                 Symbol, as_Add=False)\n762             ok, pow, remainder_pow = _check(ct1, ct2, old)\n763             if ok:\n764                 result = self.func(new, pow)  # (2**x).subs(exp(x*log(2)), z) -> z\n765                 if remainder_pow is not None:\n766                     result = Mul(result, Pow(old.base, remainder_pow))\n767                 return result\n768 \n769     def as_base_exp(self):\n770         \"\"\"Return base and exp of self.\n771 \n772         If base is 1/Integer, then return Integer, -exp. If this extra\n773         processing is not needed, the base and exp properties will\n774         give the raw arguments\n775 \n776         Examples\n777         ========\n778 \n779         >>> from sympy import Pow, S\n780         >>> p = Pow(S.Half, 2, evaluate=False)\n781         >>> p.as_base_exp()\n782         (2, -2)\n783         >>> p.args\n784         (1/2, 2)\n785 \n786         \"\"\"\n787 \n788         b, e = self.args\n789         if b.is_Rational and b.p == 1 and b.q != 1:\n790             return Integer(b.q), -e\n791         return b, e\n792 \n793     def _eval_adjoint(self):\n794         from sympy.functions.elementary.complexes import adjoint\n795         i, p = self.exp.is_integer, self.base.is_positive\n796         if i:\n797             return adjoint(self.base)**self.exp\n798         if p:\n799             return self.base**adjoint(self.exp)\n800         if i is False and p is False:\n801             expanded = expand_complex(self)\n802             if expanded != self:\n803                 return adjoint(expanded)\n804 \n805     def _eval_conjugate(self):\n806         from sympy.functions.elementary.complexes import conjugate as c\n807         i, p = self.exp.is_integer, self.base.is_positive\n808         if i:\n809             return c(self.base)**self.exp\n810         if p:\n811             return self.base**c(self.exp)\n812         if i is False and p is False:\n813             expanded = expand_complex(self)\n814             if expanded != self:\n815                 return c(expanded)\n816         if self.is_real:\n817             return self\n818 \n819     def _eval_transpose(self):\n820         from sympy.functions.elementary.complexes import transpose\n821         i, p = self.exp.is_integer, self.base.is_complex\n822         if p:\n823             return self.base**self.exp\n824         if i:\n825             return transpose(self.base)**self.exp\n826         if i is False and p is False:\n827             expanded = expand_complex(self)\n828             if expanded != self:\n829                 return transpose(expanded)\n830 \n831     def _eval_expand_power_exp(self, **hints):\n832         \"\"\"a**(n + m) -> a**n*a**m\"\"\"\n833         b = self.base\n834         e = self.exp\n835         if e.is_Add and e.is_commutative:\n836             expr = []\n837             for x in e.args:\n838                 expr.append(self.func(self.base, x))\n839             return Mul(*expr)\n840         return self.func(b, e)\n841 \n842     def _eval_expand_power_base(self, **hints):\n843         \"\"\"(a*b)**n -> a**n * b**n\"\"\"\n844         force = hints.get('force', False)\n845 \n846         b = self.base\n847         e = self.exp\n848         if not b.is_Mul:\n849             return self\n850 \n851         cargs, nc = b.args_cnc(split_1=False)\n852 \n853         # expand each term - this is top-level-only\n854         # expansion but we have to watch out for things\n855         # that don't have an _eval_expand method\n856         if nc:\n857             nc = [i._eval_expand_power_base(**hints)\n858                 if hasattr(i, '_eval_expand_power_base') else i\n859                 for i in nc]\n860 \n861             if e.is_Integer:\n862                 if e.is_positive:\n863                     rv = Mul(*nc*e)\n864                 else:\n865                     rv = Mul(*[i**-1 for i in nc[::-1]]*-e)\n866                 if cargs:\n867                     rv *= Mul(*cargs)**e\n868                 return rv\n869 \n870             if not cargs:\n871                 return self.func(Mul(*nc), e, evaluate=False)\n872 \n873             nc = [Mul(*nc)]\n874 \n875         # sift the commutative bases\n876         other, maybe_real = sift(cargs, lambda x: x.is_real is False,\n877             binary=True)\n878         def pred(x):\n879             if x is S.ImaginaryUnit:\n880                 return S.ImaginaryUnit\n881             polar = x.is_polar\n882             if polar:\n883                 return True\n884             if polar is None:\n885                 return fuzzy_bool(x.is_nonnegative)\n886         sifted = sift(maybe_real, pred)\n887         nonneg = sifted[True]\n888         other += sifted[None]\n889         neg = sifted[False]\n890         imag = sifted[S.ImaginaryUnit]\n891         if imag:\n892             I = S.ImaginaryUnit\n893             i = len(imag) % 4\n894             if i == 0:\n895                 pass\n896             elif i == 1:\n897                 other.append(I)\n898             elif i == 2:\n899                 if neg:\n900                     nonn = -neg.pop()\n901                     if nonn is not S.One:\n902                         nonneg.append(nonn)\n903                 else:\n904                     neg.append(S.NegativeOne)\n905             else:\n906                 if neg:\n907                     nonn = -neg.pop()\n908                     if nonn is not S.One:\n909                         nonneg.append(nonn)\n910                 else:\n911                     neg.append(S.NegativeOne)\n912                 other.append(I)\n913             del imag\n914 \n915         # bring out the bases that can be separated from the base\n916 \n917         if force or e.is_integer:\n918             # treat all commutatives the same and put nc in other\n919             cargs = nonneg + neg + other\n920             other = nc\n921         else:\n922             # this is just like what is happening automatically, except\n923             # that now we are doing it for an arbitrary exponent for which\n924             # no automatic expansion is done\n925 \n926             assert not e.is_Integer\n927 \n928             # handle negatives by making them all positive and putting\n929             # the residual -1 in other\n930             if len(neg) > 1:\n931                 o = S.One\n932                 if not other and neg[0].is_Number:\n933                     o *= neg.pop(0)\n934                 if len(neg) % 2:\n935                     o = -o\n936                 for n in neg:\n937                     nonneg.append(-n)\n938                 if o is not S.One:\n939                     other.append(o)\n940             elif neg and other:\n941                 if neg[0].is_Number and neg[0] is not S.NegativeOne:\n942                     other.append(S.NegativeOne)\n943                     nonneg.append(-neg[0])\n944                 else:\n945                     other.extend(neg)\n946             else:\n947                 other.extend(neg)\n948             del neg\n949 \n950             cargs = nonneg\n951             other += nc\n952 \n953         rv = S.One\n954         if cargs:\n955             rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])\n956         if other:\n957             rv *= self.func(Mul(*other), e, evaluate=False)\n958         return rv\n959 \n960     def _eval_expand_multinomial(self, **hints):\n961         \"\"\"(a + b + ..)**n -> a**n + n*a**(n-1)*b + .., n is nonzero integer\"\"\"\n962 \n963         base, exp = self.args\n964         result = self\n965 \n966         if exp.is_Rational and exp.p > 0 and base.is_Add:\n967             if not exp.is_Integer:\n968                 n = Integer(exp.p // exp.q)\n969 \n970                 if not n:\n971                     return result\n972                 else:\n973                     radical, result = self.func(base, exp - n), []\n974 \n975                     expanded_base_n = self.func(base, n)\n976                     if expanded_base_n.is_Pow:\n977                         expanded_base_n = \\\n978                             expanded_base_n._eval_expand_multinomial()\n979                     for term in Add.make_args(expanded_base_n):\n980                         result.append(term*radical)\n981 \n982                     return Add(*result)\n983 \n984             n = int(exp)\n985 \n986             if base.is_commutative:\n987                 order_terms, other_terms = [], []\n988 \n989                 for b in base.args:\n990                     if b.is_Order:\n991                         order_terms.append(b)\n992                     else:\n993                         other_terms.append(b)\n994 \n995                 if order_terms:\n996                     # (f(x) + O(x^n))^m -> f(x)^m + m*f(x)^{m-1} *O(x^n)\n997                     f = Add(*other_terms)\n998                     o = Add(*order_terms)\n999 \n1000                     if n == 2:\n1001                         return expand_multinomial(f**n, deep=False) + n*f*o\n1002                     else:\n1003                         g = expand_multinomial(f**(n - 1), deep=False)\n1004                         return expand_mul(f*g, deep=False) + n*g*o\n1005 \n1006                 if base.is_number:\n1007                     # Efficiently expand expressions of the form (a + b*I)**n\n1008                     # where 'a' and 'b' are real numbers and 'n' is integer.\n1009                     a, b = base.as_real_imag()\n1010 \n1011                     if a.is_Rational and b.is_Rational:\n1012                         if not a.is_Integer:\n1013                             if not b.is_Integer:\n1014                                 k = self.func(a.q * b.q, n)\n1015                                 a, b = a.p*b.q, a.q*b.p\n1016                             else:\n1017                                 k = self.func(a.q, n)\n1018                                 a, b = a.p, a.q*b\n1019                         elif not b.is_Integer:\n1020                             k = self.func(b.q, n)\n1021                             a, b = a*b.q, b.p\n1022                         else:\n1023                             k = 1\n1024 \n1025                         a, b, c, d = int(a), int(b), 1, 0\n1026 \n1027                         while n:\n1028                             if n & 1:\n1029                                 c, d = a*c - b*d, b*c + a*d\n1030                                 n -= 1\n1031                             a, b = a*a - b*b, 2*a*b\n1032                             n //= 2\n1033 \n1034                         I = S.ImaginaryUnit\n1035 \n1036                         if k == 1:\n1037                             return c + I*d\n1038                         else:\n1039                             return Integer(c)/k + I*d/k\n1040 \n1041                 p = other_terms\n1042                 # (x + y)**3 -> x**3 + 3*x**2*y + 3*x*y**2 + y**3\n1043                 # in this particular example:\n1044                 # p = [x,y]; n = 3\n1045                 # so now it's easy to get the correct result -- we get the\n1046                 # coefficients first:\n1047                 from sympy import multinomial_coefficients\n1048                 from sympy.polys.polyutils import basic_from_dict\n1049                 expansion_dict = multinomial_coefficients(len(p), n)\n1050                 # in our example: {(3, 0): 1, (1, 2): 3, (0, 3): 1, (2, 1): 3}\n1051                 # and now construct the expression.\n1052                 return basic_from_dict(expansion_dict, *p)\n1053             else:\n1054                 if n == 2:\n1055                     return Add(*[f*g for f in base.args for g in base.args])\n1056                 else:\n1057                     multi = (base**(n - 1))._eval_expand_multinomial()\n1058                     if multi.is_Add:\n1059                         return Add(*[f*g for f in base.args\n1060                             for g in multi.args])\n1061                     else:\n1062                         # XXX can this ever happen if base was an Add?\n1063                         return Add(*[f*multi for f in base.args])\n1064         elif (exp.is_Rational and exp.p < 0 and base.is_Add and\n1065                 abs(exp.p) > exp.q):\n1066             return 1 / self.func(base, -exp)._eval_expand_multinomial()\n1067         elif exp.is_Add and base.is_Number:\n1068             #  a + b      a  b\n1069             # n      --> n  n  , where n, a, b are Numbers\n1070 \n1071             coeff, tail = S.One, S.Zero\n1072             for term in exp.args:\n1073                 if term.is_Number:\n1074                     coeff *= self.func(base, term)\n1075                 else:\n1076                     tail += term\n1077 \n1078             return coeff * self.func(base, tail)\n1079         else:\n1080             return result\n1081 \n1082     def as_real_imag(self, deep=True, **hints):\n1083         from sympy import atan2, cos, im, re, sin\n1084         from sympy.polys.polytools import poly\n1085 \n1086         if self.exp.is_Integer:\n1087             exp = self.exp\n1088             re, im = self.base.as_real_imag(deep=deep)\n1089             if not im:\n1090                 return self, S.Zero\n1091             a, b = symbols('a b', cls=Dummy)\n1092             if exp >= 0:\n1093                 if re.is_Number and im.is_Number:\n1094                     # We can be more efficient in this case\n1095                     expr = expand_multinomial(self.base**exp)\n1096                     if expr != self:\n1097                         return expr.as_real_imag()\n1098 \n1099                 expr = poly(\n1100                     (a + b)**exp)  # a = re, b = im; expr = (a + b*I)**exp\n1101             else:\n1102                 mag = re**2 + im**2\n1103                 re, im = re/mag, -im/mag\n1104                 if re.is_Number and im.is_Number:\n1105                     # We can be more efficient in this case\n1106                     expr = expand_multinomial((re + im*S.ImaginaryUnit)**-exp)\n1107                     if expr != self:\n1108                         return expr.as_real_imag()\n1109 \n1110                 expr = poly((a + b)**-exp)\n1111 \n1112             # Terms with even b powers will be real\n1113             r = [i for i in expr.terms() if not i[0][1] % 2]\n1114             re_part = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n1115             # Terms with odd b powers will be imaginary\n1116             r = [i for i in expr.terms() if i[0][1] % 4 == 1]\n1117             im_part1 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n1118             r = [i for i in expr.terms() if i[0][1] % 4 == 3]\n1119             im_part3 = Add(*[cc*a**aa*b**bb for (aa, bb), cc in r])\n1120 \n1121             return (re_part.subs({a: re, b: S.ImaginaryUnit*im}),\n1122             im_part1.subs({a: re, b: im}) + im_part3.subs({a: re, b: -im}))\n1123 \n1124         elif self.exp.is_Rational:\n1125             re, im = self.base.as_real_imag(deep=deep)\n1126 \n1127             if im.is_zero and self.exp is S.Half:\n1128                 if re.is_nonnegative:\n1129                     return self, S.Zero\n1130                 if re.is_nonpositive:\n1131                     return S.Zero, (-self.base)**self.exp\n1132 \n1133             # XXX: This is not totally correct since for x**(p/q) with\n1134             #      x being imaginary there are actually q roots, but\n1135             #      only a single one is returned from here.\n1136             r = self.func(self.func(re, 2) + self.func(im, 2), S.Half)\n1137             t = atan2(im, re)\n1138 \n1139             rp, tp = self.func(r, self.exp), t*self.exp\n1140 \n1141             return (rp*cos(tp), rp*sin(tp))\n1142         else:\n1143 \n1144             if deep:\n1145                 hints['complex'] = False\n1146 \n1147                 expanded = self.expand(deep, **hints)\n1148                 if hints.get('ignore') == expanded:\n1149                     return None\n1150                 else:\n1151                     return (re(expanded), im(expanded))\n1152             else:\n1153                 return (re(self), im(self))\n1154 \n1155     def _eval_derivative(self, s):\n1156         from sympy import log\n1157         dbase = self.base.diff(s)\n1158         dexp = self.exp.diff(s)\n1159         return self * (dexp * log(self.base) + dbase * self.exp/self.base)\n1160 \n1161     def _eval_evalf(self, prec):\n1162         base, exp = self.as_base_exp()\n1163         base = base._evalf(prec)\n1164         if not exp.is_Integer:\n1165             exp = exp._evalf(prec)\n1166         if exp.is_negative and base.is_number and base.is_real is False:\n1167             base = base.conjugate() / (base * base.conjugate())._evalf(prec)\n1168             exp = -exp\n1169             return self.func(base, exp).expand()\n1170         return self.func(base, exp)\n1171 \n1172     def _eval_is_polynomial(self, syms):\n1173         if self.exp.has(*syms):\n1174             return False\n1175 \n1176         if self.base.has(*syms):\n1177             return bool(self.base._eval_is_polynomial(syms) and\n1178                 self.exp.is_Integer and (self.exp >= 0))\n1179         else:\n1180             return True\n1181 \n1182     def _eval_is_rational(self):\n1183         # The evaluation of self.func below can be very expensive in the case\n1184         # of integer**integer if the exponent is large.  We should try to exit\n1185         # before that if possible:\n1186         if (self.exp.is_integer and self.base.is_rational\n1187                 and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero]))):\n1188             return True\n1189         p = self.func(*self.as_base_exp())  # in case it's unevaluated\n1190         if not p.is_Pow:\n1191             return p.is_rational\n1192         b, e = p.as_base_exp()\n1193         if e.is_Rational and b.is_Rational:\n1194             # we didn't check that e is not an Integer\n1195             # because Rational**Integer autosimplifies\n1196             return False\n1197         if e.is_integer:\n1198             if b.is_rational:\n1199                 if fuzzy_not(b.is_zero) or e.is_nonnegative:\n1200                     return True\n1201                 if b == e:  # always rational, even for 0**0\n1202                     return True\n1203             elif b.is_irrational:\n1204                 return e.is_zero\n1205 \n1206     def _eval_is_algebraic(self):\n1207         def _is_one(expr):\n1208             try:\n1209                 return (expr - 1).is_zero\n1210             except ValueError:\n1211                 # when the operation is not allowed\n1212                 return False\n1213 \n1214         if self.base.is_zero or _is_one(self.base):\n1215             return True\n1216         elif self.exp.is_rational:\n1217             if self.base.is_algebraic is False:\n1218                 return self.exp.is_zero\n1219             return self.base.is_algebraic\n1220         elif self.base.is_algebraic and self.exp.is_algebraic:\n1221             if ((fuzzy_not(self.base.is_zero)\n1222                 and fuzzy_not(_is_one(self.base)))\n1223                 or self.base.is_integer is False\n1224                 or self.base.is_irrational):\n1225                 return self.exp.is_rational\n1226 \n1227     def _eval_is_rational_function(self, syms):\n1228         if self.exp.has(*syms):\n1229             return False\n1230 \n1231         if self.base.has(*syms):\n1232             return self.base._eval_is_rational_function(syms) and \\\n1233                 self.exp.is_Integer\n1234         else:\n1235             return True\n1236 \n1237     def _eval_is_algebraic_expr(self, syms):\n1238         if self.exp.has(*syms):\n1239             return False\n1240 \n1241         if self.base.has(*syms):\n1242             return self.base._eval_is_algebraic_expr(syms) and \\\n1243                 self.exp.is_Rational\n1244         else:\n1245             return True\n1246 \n1247     def _eval_rewrite_as_exp(self, base, expo, **kwargs):\n1248         from sympy import exp, log, I, arg\n1249 \n1250         if base.is_zero or base.has(exp) or expo.has(exp):\n1251             return base**expo\n1252 \n1253         if base.has(Symbol):\n1254             # delay evaluation if expo is non symbolic\n1255             # (as exp(x*log(5)) automatically reduces to x**5)\n1256             return exp(log(base)*expo, evaluate=expo.has(Symbol))\n1257 \n1258         else:\n1259             return exp((log(abs(base)) + I*arg(base))*expo)\n1260 \n1261     def as_numer_denom(self):\n1262         if not self.is_commutative:\n1263             return self, S.One\n1264         base, exp = self.as_base_exp()\n1265         n, d = base.as_numer_denom()\n1266         # this should be the same as ExpBase.as_numer_denom wrt\n1267         # exponent handling\n1268         neg_exp = exp.is_negative\n1269         if not neg_exp and not (-exp).is_negative:\n1270             neg_exp = _coeff_isneg(exp)\n1271         int_exp = exp.is_integer\n1272         # the denominator cannot be separated from the numerator if\n1273         # its sign is unknown unless the exponent is an integer, e.g.\n1274         # sqrt(a/b) != sqrt(a)/sqrt(b) when a=1 and b=-1. But if the\n1275         # denominator is negative the numerator and denominator can\n1276         # be negated and the denominator (now positive) separated.\n1277         if not (d.is_real or int_exp):\n1278             n = base\n1279             d = S.One\n1280         dnonpos = d.is_nonpositive\n1281         if dnonpos:\n1282             n, d = -n, -d\n1283         elif dnonpos is None and not int_exp:\n1284             n = base\n1285             d = S.One\n1286         if neg_exp:\n1287             n, d = d, n\n1288             exp = -exp\n1289         if exp.is_infinite:\n1290             if n is S.One and d is not S.One:\n1291                 return n, self.func(d, exp)\n1292             if n is not S.One and d is S.One:\n1293                 return self.func(n, exp), d\n1294         return self.func(n, exp), self.func(d, exp)\n1295 \n1296     def matches(self, expr, repl_dict={}, old=False):\n1297         expr = _sympify(expr)\n1298 \n1299         # special case, pattern = 1 and expr.exp can match to 0\n1300         if expr is S.One:\n1301             d = repl_dict.copy()\n1302             d = self.exp.matches(S.Zero, d)\n1303             if d is not None:\n1304                 return d\n1305 \n1306         # make sure the expression to be matched is an Expr\n1307         if not isinstance(expr, Expr):\n1308             return None\n1309 \n1310         b, e = expr.as_base_exp()\n1311 \n1312         # special case number\n1313         sb, se = self.as_base_exp()\n1314         if sb.is_Symbol and se.is_Integer and expr:\n1315             if e.is_rational:\n1316                 return sb.matches(b**(e/se), repl_dict)\n1317             return sb.matches(expr**(1/se), repl_dict)\n1318 \n1319         d = repl_dict.copy()\n1320         d = self.base.matches(b, d)\n1321         if d is None:\n1322             return None\n1323 \n1324         d = self.exp.xreplace(d).matches(e, d)\n1325         if d is None:\n1326             return Expr.matches(self, expr, repl_dict)\n1327         return d\n1328 \n1329     def _eval_nseries(self, x, n, logx):\n1330         # NOTE! This function is an important part of the gruntz algorithm\n1331         #       for computing limits. It has to return a generalized power\n1332         #       series with coefficients in C(log, log(x)). In more detail:\n1333         # It has to return an expression\n1334         #     c_0*x**e_0 + c_1*x**e_1 + ... (finitely many terms)\n1335         # where e_i are numbers (not necessarily integers) and c_i are\n1336         # expressions involving only numbers, the log function, and log(x).\n1337         from sympy import ceiling, collect, exp, log, O, Order, powsimp\n1338         b, e = self.args\n1339         if e.is_Integer:\n1340             if e > 0:\n1341                 # positive integer powers are easy to expand, e.g.:\n1342                 # sin(x)**4 = (x - x**3/3 + ...)**4 = ...\n1343                 return expand_multinomial(self.func(b._eval_nseries(x, n=n,\n1344                     logx=logx), e), deep=False)\n1345             elif e is S.NegativeOne:\n1346                 # this is also easy to expand using the formula:\n1347                 # 1/(1 + x) = 1 - x + x**2 - x**3 ...\n1348                 # so we need to rewrite base to the form \"1 + x\"\n1349 \n1350                 nuse = n\n1351                 cf = 1\n1352 \n1353                 try:\n1354                     ord = b.as_leading_term(x)\n1355                     cf = Order(ord, x).getn()\n1356                     if cf and cf.is_Number:\n1357                         nuse = n + 2*ceiling(cf)\n1358                     else:\n1359                         cf = 1\n1360                 except NotImplementedError:\n1361                     pass\n1362 \n1363                 b_orig, prefactor = b, O(1, x)\n1364                 while prefactor.is_Order:\n1365                     nuse += 1\n1366                     b = b_orig._eval_nseries(x, n=nuse, logx=logx)\n1367                     prefactor = b.as_leading_term(x)\n1368 \n1369                 # express \"rest\" as: rest = 1 + k*x**l + ... + O(x**n)\n1370                 rest = expand_mul((b - prefactor)/prefactor)\n1371 \n1372                 if rest.is_Order:\n1373                     return 1/prefactor + rest/prefactor + O(x**n, x)\n1374 \n1375                 k, l = rest.leadterm(x)\n1376                 if l.is_Rational and l > 0:\n1377                     pass\n1378                 elif l.is_number and l > 0:\n1379                     l = l.evalf()\n1380                 elif l == 0:\n1381                     k = k.simplify()\n1382                     if k == 0:\n1383                         # if prefactor == w**4 + x**2*w**4 + 2*x*w**4, we need to\n1384                         # factor the w**4 out using collect:\n1385                         return 1/collect(prefactor, x)\n1386                     else:\n1387                         raise NotImplementedError()\n1388                 else:\n1389                     raise NotImplementedError()\n1390 \n1391                 if cf < 0:\n1392                     cf = S.One/abs(cf)\n1393 \n1394                 try:\n1395                     dn = Order(1/prefactor, x).getn()\n1396                     if dn and dn < 0:\n1397                         pass\n1398                     else:\n1399                         dn = 0\n1400                 except NotImplementedError:\n1401                     dn = 0\n1402 \n1403                 terms = [1/prefactor]\n1404                 for m in range(1, ceiling((n - dn + 1)/l*cf)):\n1405                     new_term = terms[-1]*(-rest)\n1406                     if new_term.is_Pow:\n1407                         new_term = new_term._eval_expand_multinomial(\n1408                             deep=False)\n1409                     else:\n1410                         new_term = expand_mul(new_term, deep=False)\n1411                     terms.append(new_term)\n1412                 terms.append(O(x**n, x))\n1413                 return powsimp(Add(*terms), deep=True, combine='exp')\n1414             else:\n1415                 # negative powers are rewritten to the cases above, for\n1416                 # example:\n1417                 # sin(x)**(-4) = 1/(sin(x)**4) = ...\n1418                 # and expand the denominator:\n1419                 nuse, denominator = n, O(1, x)\n1420                 while denominator.is_Order:\n1421                     denominator = (b**(-e))._eval_nseries(x, n=nuse, logx=logx)\n1422                     nuse += 1\n1423                 if 1/denominator == self:\n1424                     return self\n1425                 # now we have a type 1/f(x), that we know how to expand\n1426                 return (1/denominator)._eval_nseries(x, n=n, logx=logx)\n1427 \n1428         if e.has(Symbol):\n1429             return exp(e*log(b))._eval_nseries(x, n=n, logx=logx)\n1430 \n1431         # see if the base is as simple as possible\n1432         bx = b\n1433         while bx.is_Pow and bx.exp.is_Rational:\n1434             bx = bx.base\n1435         if bx == x:\n1436             return self\n1437 \n1438         # work for b(x)**e where e is not an Integer and does not contain x\n1439         # and hopefully has no other symbols\n1440 \n1441         def e2int(e):\n1442             \"\"\"return the integer value (if possible) of e and a\n1443             flag indicating whether it is bounded or not.\"\"\"\n1444             n = e.limit(x, 0)\n1445             infinite = n.is_infinite\n1446             if not infinite:\n1447                 # XXX was int or floor intended? int used to behave like floor\n1448                 # so int(-Rational(1, 2)) returned -1 rather than int's 0\n1449                 try:\n1450                     n = int(n)\n1451                 except TypeError:\n1452                     # well, the n is something more complicated (like 1 + log(2))\n1453                     try:\n1454                         n = int(n.evalf()) + 1  # XXX why is 1 being added?\n1455                     except TypeError:\n1456                         pass  # hope that base allows this to be resolved\n1457                 n = _sympify(n)\n1458             return n, infinite\n1459 \n1460         order = O(x**n, x)\n1461         ei, infinite = e2int(e)\n1462         b0 = b.limit(x, 0)\n1463         if infinite and (b0 is S.One or b0.has(Symbol)):\n1464             # XXX what order\n1465             if b0 is S.One:\n1466                 resid = (b - 1)\n1467                 if resid.is_positive:\n1468                     return S.Infinity\n1469                 elif resid.is_negative:\n1470                     return S.Zero\n1471                 raise ValueError('cannot determine sign of %s' % resid)\n1472 \n1473             return b0**ei\n1474 \n1475         if (b0 is S.Zero or b0.is_infinite):\n1476             if infinite is not False:\n1477                 return b0**e  # XXX what order\n1478 \n1479             if not ei.is_number:  # if not, how will we proceed?\n1480                 raise ValueError(\n1481                     'expecting numerical exponent but got %s' % ei)\n1482 \n1483             nuse = n - ei\n1484 \n1485             if e.is_real and e.is_positive:\n1486                 lt = b.as_leading_term(x)\n1487 \n1488                 # Try to correct nuse (= m) guess from:\n1489                 # (lt + rest + O(x**m))**e =\n1490                 # lt**e*(1 + rest/lt + O(x**m)/lt)**e =\n1491                 # lt**e + ... + O(x**m)*lt**(e - 1) = ... + O(x**n)\n1492                 try:\n1493                     cf = Order(lt, x).getn()\n1494                     nuse = ceiling(n - cf*(e - 1))\n1495                 except NotImplementedError:\n1496                     pass\n1497 \n1498             bs = b._eval_nseries(x, n=nuse, logx=logx)\n1499             terms = bs.removeO()\n1500             if terms.is_Add:\n1501                 bs = terms\n1502                 lt = terms.as_leading_term(x)\n1503 \n1504                 # bs -> lt + rest -> lt*(1 + (bs/lt - 1))\n1505                 return ((self.func(lt, e) * self.func((bs/lt).expand(), e).nseries(\n1506                     x, n=nuse, logx=logx)).expand() + order)\n1507 \n1508             if bs.is_Add:\n1509                 from sympy import O\n1510                 # So, bs + O() == terms\n1511                 c = Dummy('c')\n1512                 res = []\n1513                 for arg in bs.args:\n1514                     if arg.is_Order:\n1515                         arg = c*arg.expr\n1516                     res.append(arg)\n1517                 bs = Add(*res)\n1518                 rv = (bs**e).series(x).subs(c, O(1, x))\n1519                 rv += order\n1520                 return rv\n1521 \n1522             rv = bs**e\n1523             if terms != bs:\n1524                 rv += order\n1525             return rv\n1526 \n1527         # either b0 is bounded but neither 1 nor 0 or e is infinite\n1528         # b -> b0 + (b - b0) -> b0 * (1 + (b/b0 - 1))\n1529         o2 = order*(b0**-e)\n1530         z = (b/b0 - 1)\n1531         o = O(z, x)\n1532         if o is S.Zero or o2 is S.Zero:\n1533             infinite = True\n1534         else:\n1535             if o.expr.is_number:\n1536                 e2 = log(o2.expr*x)/log(x)\n1537             else:\n1538                 e2 = log(o2.expr)/log(o.expr)\n1539             n, infinite = e2int(e2)\n1540         if infinite:\n1541             # requested accuracy gives infinite series,\n1542             # order is probably non-polynomial e.g. O(exp(-1/x), x).\n1543             r = 1 + z\n1544         else:\n1545             l = []\n1546             g = None\n1547             for i in range(n + 2):\n1548                 g = self._taylor_term(i, z, g)\n1549                 g = g.nseries(x, n=n, logx=logx)\n1550                 l.append(g)\n1551             r = Add(*l)\n1552         return expand_mul(r*b0**e) + order\n1553 \n1554     def _eval_as_leading_term(self, x):\n1555         from sympy import exp, log\n1556         if not self.exp.has(x):\n1557             return self.func(self.base.as_leading_term(x), self.exp)\n1558         return exp(self.exp * log(self.base)).as_leading_term(x)\n1559 \n1560     @cacheit\n1561     def _taylor_term(self, n, x, *previous_terms): # of (1 + x)**e\n1562         from sympy import binomial\n1563         return binomial(self.exp, n) * self.func(x, n)\n1564 \n1565     def _sage_(self):\n1566         return self.args[0]._sage_()**self.args[1]._sage_()\n1567 \n1568     def as_content_primitive(self, radical=False, clear=True):\n1569         \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n1570         extracted from self.\n1571 \n1572         Examples\n1573         ========\n1574 \n1575         >>> from sympy import sqrt\n1576         >>> sqrt(4 + 4*sqrt(2)).as_content_primitive()\n1577         (2, sqrt(1 + sqrt(2)))\n1578         >>> sqrt(3 + 3*sqrt(2)).as_content_primitive()\n1579         (1, sqrt(3)*sqrt(1 + sqrt(2)))\n1580 \n1581         >>> from sympy import expand_power_base, powsimp, Mul\n1582         >>> from sympy.abc import x, y\n1583 \n1584         >>> ((2*x + 2)**2).as_content_primitive()\n1585         (4, (x + 1)**2)\n1586         >>> (4**((1 + y)/2)).as_content_primitive()\n1587         (2, 4**(y/2))\n1588         >>> (3**((1 + y)/2)).as_content_primitive()\n1589         (1, 3**((y + 1)/2))\n1590         >>> (3**((5 + y)/2)).as_content_primitive()\n1591         (9, 3**((y + 1)/2))\n1592         >>> eq = 3**(2 + 2*x)\n1593         >>> powsimp(eq) == eq\n1594         True\n1595         >>> eq.as_content_primitive()\n1596         (9, 3**(2*x))\n1597         >>> powsimp(Mul(*_))\n1598         3**(2*x + 2)\n1599 \n1600         >>> eq = (2 + 2*x)**y\n1601         >>> s = expand_power_base(eq); s.is_Mul, s\n1602         (False, (2*x + 2)**y)\n1603         >>> eq.as_content_primitive()\n1604         (1, (2*(x + 1))**y)\n1605         >>> s = expand_power_base(_[1]); s.is_Mul, s\n1606         (True, 2**y*(x + 1)**y)\n1607 \n1608         See docstring of Expr.as_content_primitive for more examples.\n1609         \"\"\"\n1610 \n1611         b, e = self.as_base_exp()\n1612         b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))\n1613         ce, pe = e.as_content_primitive(radical=radical, clear=clear)\n1614         if b.is_Rational:\n1615             #e\n1616             #= ce*pe\n1617             #= ce*(h + t)\n1618             #= ce*h + ce*t\n1619             #=> self\n1620             #= b**(ce*h)*b**(ce*t)\n1621             #= b**(cehp/cehq)*b**(ce*t)\n1622             #= b**(iceh + r/cehq)*b**(ce*t)\n1623             #= b**(iceh)*b**(r/cehq)*b**(ce*t)\n1624             #= b**(iceh)*b**(ce*t + r/cehq)\n1625             h, t = pe.as_coeff_Add()\n1626             if h.is_Rational:\n1627                 ceh = ce*h\n1628                 c = self.func(b, ceh)\n1629                 r = S.Zero\n1630                 if not c.is_Rational:\n1631                     iceh, r = divmod(ceh.p, ceh.q)\n1632                     c = self.func(b, iceh)\n1633                 return c, self.func(b, _keep_coeff(ce, t + r/ce/ceh.q))\n1634         e = _keep_coeff(ce, pe)\n1635         # b**e = (h*t)**e = h**e*t**e = c*m*t**e\n1636         if e.is_Rational and b.is_Mul:\n1637             h, t = b.as_content_primitive(radical=radical, clear=clear)  # h is positive\n1638             c, m = self.func(h, e).as_coeff_Mul()  # so c is positive\n1639             m, me = m.as_base_exp()\n1640             if m is S.One or me == e:  # probably always true\n1641                 # return the following, not return c, m*Pow(t, e)\n1642                 # which would change Pow into Mul; we let sympy\n1643                 # decide what to do by using the unevaluated Mul, e.g\n1644                 # should it stay as sqrt(2 + 2*sqrt(5)) or become\n1645                 # sqrt(2)*sqrt(1 + sqrt(5))\n1646                 return c, self.func(_keep_coeff(m, t), e)\n1647         return S.One, self.func(b, e)\n1648 \n1649     def is_constant(self, *wrt, **flags):\n1650         expr = self\n1651         if flags.get('simplify', True):\n1652             expr = expr.simplify()\n1653         b, e = expr.as_base_exp()\n1654         bz = b.equals(0)\n1655         if bz:  # recalculate with assumptions in case it's unevaluated\n1656             new = b**e\n1657             if new != expr:\n1658                 return new.is_constant()\n1659         econ = e.is_constant(*wrt)\n1660         bcon = b.is_constant(*wrt)\n1661         if bcon:\n1662             if econ:\n1663                 return True\n1664             bz = b.equals(0)\n1665             if bz is False:\n1666                 return False\n1667         elif bcon is None:\n1668             return None\n1669 \n1670         return e.equals(0)\n1671 \n1672     def _eval_difference_delta(self, n, step):\n1673         b, e = self.args\n1674         if e.has(n) and not b.has(n):\n1675             new_e = e.subs(n, n + step)\n1676             return (b**(new_e - e) - 1) * self\n1677 \n1678 \n1679 from .add import Add\n1680 from .numbers import Integer\n1681 from .mul import Mul, _keep_coeff\n1682 from .symbol import Symbol, Dummy, symbols\n",
        "intended_behavior": "Correctly evaluate and simplify expressions involving division and power operation to avoid misinterpretations or errors, specifically ensuring that floor division is handled in line with Python's arithmetic rules when applicable."
    }
]