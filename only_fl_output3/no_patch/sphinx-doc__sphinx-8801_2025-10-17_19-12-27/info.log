2025-10-17 19:12:28.016 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 19:12:32.303 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=317, output_tokens=12, cost=0.003530
2025-10-17 19:12:54.146 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=497, output_tokens=1037, cost=0.036080
2025-10-17 19:13:13.615 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=497, output_tokens=804, cost=0.029090
2025-10-17 19:13:14.812 | INFO     | registered non reproducing test 1
2025-10-17 19:13:30.790 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2205, output_tokens=739, cost=0.044220
2025-10-17 19:13:31.984 | INFO     | registered non reproducing test 2
2025-10-17 19:13:31.984 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 19:13:31.990 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:13:37.693 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=618, output_tokens=196, cost=0.012060
2025-10-17 19:13:37.698 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:13:42.025 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=550, output_tokens=56, cost=0.007180
2025-10-17 19:13:42.027 | DEBUG    | Extracted a valid json.
2025-10-17 19:13:42.027 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Foo\")",
        "search_class(\"Bar\")",
        "search_code(\".. autoclass::\")",
        "search_code(\"sphinx.ext.autodoc\")"
    ],
    "bug_locations": []
}
2025-10-17 19:13:42.114 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 19:13:42.115 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 19:13:57.823 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1303, output_tokens=700, cost=0.034030
2025-10-17 19:13:57.830 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 19:14:05.058 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2219, output_tokens=291, cost=0.030920
2025-10-17 19:14:05.064 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 19:14:09.453 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=645, output_tokens=189, cost=0.012120
2025-10-17 19:14:09.454 | DEBUG    | Extracted a valid json.
2025-10-17 19:14:09.454 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code within this file that processes inherited class members for documentation should be updated to ensure that members which are only annotated with type hints and potentially documented with special comment docstrings (`#: docstring`) are recognized as documented. This involves adjusting the logic that determines whether a member is documented to account not only for explicit docstrings but also for type annotations and inline comments considered as docstrings. The modification should retain all existing functionality, including the ability to recognize explicitly documented members, while extending the recognition to annotated only members. This fix should ensure compatibility with the expected Sphinx behavior, where inherited members that are annotated should be automatically documented without requiring the `:undoc-members:` option."
        }
    ]
}
2025-10-17 19:14:09.463 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import re
14 import warnings
15 from inspect import Parameter, Signature
16 from types import ModuleType
17 from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,
18                     TypeVar, Union)
19 
20 from docutils.statemachine import StringList
21 
22 import sphinx
23 from sphinx.application import Sphinx
24 from sphinx.config import ENUM, Config
25 from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,
26                                 RemovedInSphinx60Warning)
27 from sphinx.environment import BuildEnvironment
28 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,
29                                          import_object)
30 from sphinx.ext.autodoc.mock import ismock, mock, undecorate
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect, logging
34 from sphinx.util.docstrings import extract_metadata, prepare_docstring
35 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,
36                                  stringify_signature)
37 from sphinx.util.typing import get_type_hints, restify
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43 
44     from sphinx.ext.autodoc.directive import DocumenterBridge
45 
46 
47 logger = logging.getLogger(__name__)
48 
49 
50 # This type isn't exposed directly in any modules, but can be found
51 # here in most Python versions
52 MethodDescriptorType = type(type.__subclasses__)
53 
54 
55 #: extended signature RE: with explicit module name separated by ::
56 py_ext_sig_re = re.compile(
57     r'''^ ([\w.]+::)?            # explicit module name
58           ([\w.]+\.)?            # module and/or class name(s)
59           (\w+)  \s*             # thing name
60           (?: \((.*)\)           # optional: arguments
61            (?:\s* -> \s* (.*))?  #           return annotation
62           )? $                   # and nothing more
63           ''', re.VERBOSE)
64 special_member_re = re.compile(r'^__\S+__$')
65 
66 
67 def identity(x: Any) -> Any:
68     return x
69 
70 
71 class _All:
72     """A special value for :*-members: that matches to any member."""
73 
74     def __contains__(self, item: Any) -> bool:
75         return True
76 
77 
78 class _Empty:
79     """A special value for :exclude-members: that never matches to any member."""
80 
81     def __contains__(self, item: Any) -> bool:
82         return False
83 
84 
85 ALL = _All()
86 EMPTY = _Empty()
87 UNINITIALIZED_ATTR = object()
88 INSTANCEATTR = object()
89 SLOTSATTR = object()
90 
91 
92 def members_option(arg: Any) -> Union[object, List[str]]:
93     """Used to convert the :members: option to auto directives."""
94     if arg in (None, True):
95         return ALL
96     elif arg is False:
97         return None
98     else:
99         return [x.strip() for x in arg.split(',') if x.strip()]
100 
101 
102 def members_set_option(arg: Any) -> Union[object, Set[str]]:
103     """Used to convert the :members: option to auto directives."""
104     warnings.warn("members_set_option() is deprecated.",
105                   RemovedInSphinx50Warning, stacklevel=2)
106     if arg is None:
107         return ALL
108     return {x.strip() for x in arg.split(',') if x.strip()}
109 
110 
111 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
112     """Used to convert the :exclude-members: option."""
113     if arg in (None, True):
114         return EMPTY
115     return {x.strip() for x in arg.split(',') if x.strip()}
116 
117 
118 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
119     """Used to convert the :members: option to auto directives."""
120     if arg in (None, True):
121         return 'object'
122     else:
123         return arg
124 
125 
126 def member_order_option(arg: Any) -> Optional[str]:
127     """Used to convert the :members: option to auto directives."""
128     if arg in (None, True):
129         return None
130     elif arg in ('alphabetical', 'bysource', 'groupwise'):
131         return arg
132     else:
133         raise ValueError(__('invalid value for member-order option: %s') % arg)
134 
135 
136 SUPPRESS = object()
137 
138 
139 def annotation_option(arg: Any) -> Any:
140     if arg in (None, True):
141         # suppress showing the representation of the object
142         return SUPPRESS
143     else:
144         return arg
145 
146 
147 def bool_option(arg: Any) -> bool:
148     """Used to convert flag options to auto directives.  (Instead of
149     directives.flag(), which returns None).
150     """
151     return True
152 
153 
154 def merge_special_members_option(options: Dict) -> None:
155     """Merge :special-members: option to :members: option."""
156     warnings.warn("merge_special_members_option() is deprecated.",
157                   RemovedInSphinx50Warning, stacklevel=2)
158     if 'special-members' in options and options['special-members'] is not ALL:
159         if options.get('members') is ALL:
160             pass
161         elif options.get('members'):
162             for member in options['special-members']:
163                 if member not in options['members']:
164                     options['members'].append(member)
165         else:
166             options['members'] = options['special-members']
167 
168 
169 def merge_members_option(options: Dict) -> None:
170     """Merge :*-members: option to the :members: option."""
171     if options.get('members') is ALL:
172         # merging is not needed when members: ALL
173         return
174 
175     members = options.setdefault('members', [])
176     for key in {'private-members', 'special-members'}:
177         if key in options and options[key] not in (ALL, None):
178             for member in options[key]:
179                 if member not in members:
180                     members.append(member)
181 
182 
183 # Some useful event listener factories for autodoc-process-docstring.
184 
185 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
186     """Return a listener that removes the first *pre* and last *post*
187     lines of every docstring.  If *what* is a sequence of strings,
188     only docstrings of a type in *what* will be processed.
189 
190     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
191 
192        from sphinx.ext.autodoc import cut_lines
193        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
194 
195     This can (and should) be used in place of :confval:`automodule_skip_lines`.
196     """
197     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
198                 ) -> None:
199         if what and what_ not in what:
200             return
201         del lines[:pre]
202         if post:
203             # remove one trailing blank line.
204             if lines and not lines[-1]:
205                 lines.pop(-1)
206             del lines[-post:]
207         # make sure there is a blank line at the end
208         if lines and lines[-1]:
209             lines.append('')
210     return process
211 
212 
213 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
214             exclude: bool = False) -> Callable:
215     """Return a listener that either keeps, or if *exclude* is True excludes,
216     lines between lines that match the *marker* regular expression.  If no line
217     matches, the resulting docstring would be empty, so no change will be made
218     unless *keepempty* is true.
219 
220     If *what* is a sequence of strings, only docstrings of a type in *what* will
221     be processed.
222     """
223     marker_re = re.compile(marker)
224 
225     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
226                 ) -> None:
227         if what and what_ not in what:
228             return
229         deleted = 0
230         delete = not exclude
231         orig_lines = lines[:]
232         for i, line in enumerate(orig_lines):
233             if delete:
234                 lines.pop(i - deleted)
235                 deleted += 1
236             if marker_re.match(line):
237                 delete = not delete
238                 if delete:
239                     lines.pop(i - deleted)
240                     deleted += 1
241         if not lines and not keepempty:
242             lines[:] = orig_lines
243         # make sure there is a blank line at the end
244         if lines and lines[-1]:
245             lines.append('')
246     return process
247 
248 
249 # This class is used only in ``sphinx.ext.autodoc.directive``,
250 # But we define this class here to keep compatibility (see #4538)
251 class Options(dict):
252     """A dict/attribute hybrid that returns None on nonexisting keys."""
253     def __getattr__(self, name: str) -> Any:
254         try:
255             return self[name.replace('_', '-')]
256         except KeyError:
257             return None
258 
259 
260 class ObjectMember(tuple):
261     """A member of object.
262 
263     This is used for the result of `Documenter.get_object_members()` to
264     represent each member of the object.
265 
266     .. Note::
267 
268        An instance of this class behaves as a tuple of (name, object)
269        for compatibility to old Sphinx.  The behavior will be dropped
270        in the future.  Therefore extensions should not use the tuple
271        interface.
272     """
273 
274     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:
275         return super().__new__(cls, (name, obj))  # type: ignore
276 
277     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,
278                  class_: Any = None, skipped: bool = False) -> None:
279         self.__name__ = name
280         self.object = obj
281         self.docstring = docstring
282         self.skipped = skipped
283         self.class_ = class_
284 
285 
286 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]
287 
288 
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 if ismock(self.object):
426                     self.object = undecorate(self.object)
427                 return True
428             except ImportError as exc:
429                 if raiseerror:
430                     raise
431                 else:
432                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
433                     self.env.note_reread()
434                     return False
435 
436     def get_real_modname(self) -> str:
437         """Get the real module name of an object to document.
438 
439         It can differ from the name of the module through which the object was
440         imported.
441         """
442         return self.get_attr(self.object, '__module__', None) or self.modname
443 
444     def check_module(self) -> bool:
445         """Check if *self.object* is really defined in the module given by
446         *self.modname*.
447         """
448         if self.options.imported_members:
449             return True
450 
451         subject = inspect.unpartial(self.object)
452         modname = self.get_attr(subject, '__module__', None)
453         if modname and modname != self.modname:
454             return False
455         return True
456 
457     def format_args(self, **kwargs: Any) -> str:
458         """Format the argument signature of *self.object*.
459 
460         Should return None if the object does not have a signature.
461         """
462         return None
463 
464     def format_name(self) -> str:
465         """Format the name of *self.object*.
466 
467         This normally should be something that can be parsed by the generated
468         directive, but doesn't need to be (Sphinx will display it unparsed
469         then).
470         """
471         # normally the name doesn't contain the module (except for module
472         # directives of course)
473         return '.'.join(self.objpath) or self.modname
474 
475     def _call_format_args(self, **kwargs: Any) -> str:
476         if kwargs:
477             try:
478                 return self.format_args(**kwargs)
479             except TypeError:
480                 # avoid chaining exceptions, by putting nothing here
481                 pass
482 
483         # retry without arguments for old documenters
484         return self.format_args()
485 
486     def format_signature(self, **kwargs: Any) -> str:
487         """Format the signature (arguments and return annotation) of the object.
488 
489         Let the user process it via the ``autodoc-process-signature`` event.
490         """
491         if self.args is not None:
492             # signature given explicitly
493             args = "(%s)" % self.args
494             retann = self.retann
495         else:
496             # try to introspect the signature
497             try:
498                 retann = None
499                 args = self._call_format_args(**kwargs)
500                 if args:
501                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
502                     if matched:
503                         args = matched.group(1)
504                         retann = matched.group(2)
505             except Exception as exc:
506                 logger.warning(__('error while formatting arguments for %s: %s'),
507                                self.fullname, exc, type='autodoc')
508                 args = None
509 
510         result = self.env.events.emit_firstresult('autodoc-process-signature',
511                                                   self.objtype, self.fullname,
512                                                   self.object, self.options, args, retann)
513         if result:
514             args, retann = result
515 
516         if args is not None:
517             return args + ((' -> %s' % retann) if retann else '')
518         else:
519             return ''
520 
521     def add_directive_header(self, sig: str) -> None:
522         """Add the directive header and options to the generated content."""
523         domain = getattr(self, 'domain', 'py')
524         directive = getattr(self, 'directivetype', self.objtype)
525         name = self.format_name()
526         sourcename = self.get_sourcename()
527 
528         # one signature per line, indented by column
529         prefix = '.. %s:%s:: ' % (domain, directive)
530         for i, sig_line in enumerate(sig.split("\n")):
531             self.add_line('%s%s%s' % (prefix, name, sig_line),
532                           sourcename)
533             if i == 0:
534                 prefix = " " * len(prefix)
535 
536         if self.options.noindex:
537             self.add_line('   :noindex:', sourcename)
538         if self.objpath:
539             # Be explicit about the module, this is necessary since .. class::
540             # etc. don't support a prepended module name
541             self.add_line('   :module: %s' % self.modname, sourcename)
542 
543     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
544         """Decode and return lines of the docstring(s) for the object.
545 
546         When it returns None value, autodoc-process-docstring will not be called for this
547         object.
548         """
549         if encoding is not None:
550             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
551                           % self.__class__.__name__,
552                           RemovedInSphinx40Warning, stacklevel=2)
553         if ignore is not None:
554             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
555                           % self.__class__.__name__,
556                           RemovedInSphinx50Warning, stacklevel=2)
557         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
558                            self.parent, self.object_name)
559         if docstring:
560             tab_width = self.directive.state.document.settings.tab_width
561             return [prepare_docstring(docstring, ignore, tab_width)]
562         return []
563 
564     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
565         """Let the user process the docstrings before adding them."""
566         for docstringlines in docstrings:
567             if self.env.app:
568                 # let extensions preprocess docstrings
569                 self.env.app.emit('autodoc-process-docstring',
570                                   self.objtype, self.fullname, self.object,
571                                   self.options, docstringlines)
572 
573                 if docstringlines and docstringlines[-1] != '':
574                     # append a blank line to the end of the docstring
575                     docstringlines.append('')
576 
577             yield from docstringlines
578 
579     def get_sourcename(self) -> str:
580         if (getattr(self.object, '__module__', None) and
581                 getattr(self.object, '__qualname__', None)):
582             # Get the correct location of docstring from self.object
583             # to support inherited methods
584             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
585         else:
586             fullname = self.fullname
587 
588         if self.analyzer:
589             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
590         else:
591             return 'docstring of %s' % fullname
592 
593     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
594                     ) -> None:
595         """Add content from docstrings, attribute documentation and user."""
596         if no_docstring:
597             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
598                           % self.__class__.__name__,
599                           RemovedInSphinx50Warning, stacklevel=2)
600 
601         # set sourcename and add content from attribute documentation
602         sourcename = self.get_sourcename()
603         if self.analyzer:
604             attr_docs = self.analyzer.find_attr_docs()
605             if self.objpath:
606                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
607                 if key in attr_docs:
608                     no_docstring = True
609                     # make a copy of docstring for attributes to avoid cache
610                     # the change of autodoc-process-docstring event.
611                     docstrings = [list(attr_docs[key])]
612 
613                     for i, line in enumerate(self.process_doc(docstrings)):
614                         self.add_line(line, sourcename, i)
615 
616         # add content from docstrings
617         if not no_docstring:
618             docstrings = self.get_doc()
619             if docstrings is None:
620                 # Do not call autodoc-process-docstring on get_doc() returns None.
621                 pass
622             else:
623                 if not docstrings:
624                     # append at least a dummy docstring, so that the event
625                     # autodoc-process-docstring is fired and can add some
626                     # content if desired
627                     docstrings.append([])
628                 for i, line in enumerate(self.process_doc(docstrings)):
629                     self.add_line(line, sourcename, i)
630 
631         # add additional content (e.g. from document), if present
632         if more_content:
633             for line, src in zip(more_content.data, more_content.items):
634                 self.add_line(line, src[0], src[1])
635 
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]
663 
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret
813 
814     def document_members(self, all_members: bool = False) -> None:
815         """Generate reST for member documentation.
816 
817         If *all_members* is True, do all members, else those given by
818         *self.options.members*.
819         """
820         # set current namespace for finding members
821         self.env.temp_data['autodoc:module'] = self.modname
822         if self.objpath:
823             self.env.temp_data['autodoc:class'] = self.objpath[0]
824 
825         want_all = all_members or self.options.inherited_members or \
826             self.options.members is ALL
827         # find out which members are documentable
828         members_check_module, members = self.get_object_members(want_all)
829 
830         # document non-skipped members
831         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
832         for (mname, member, isattr) in self.filter_members(members, want_all):
833             classes = [cls for cls in self.documenters.values()
834                        if cls.can_document_member(member, mname, isattr, self)]
835             if not classes:
836                 # don't know how to document this member
837                 continue
838             # prefer the documenter with the highest priority
839             classes.sort(key=lambda cls: cls.priority)
840             # give explicitly separated module name, so that members
841             # of inner classes can be documented
842             full_mname = self.modname + '::' + \
843                 '.'.join(self.objpath + [mname])
844             documenter = classes[-1](self.directive, full_mname, self.indent)
845             memberdocumenters.append((documenter, isattr))
846 
847         member_order = self.options.member_order or self.config.autodoc_member_order
848         memberdocumenters = self.sort_members(memberdocumenters, member_order)
849 
850         for documenter, isattr in memberdocumenters:
851             documenter.generate(
852                 all_members=True, real_modname=self.real_modname,
853                 check_module=members_check_module and not isattr)
854 
855         # reset current objects
856         self.env.temp_data['autodoc:module'] = None
857         self.env.temp_data['autodoc:class'] = None
858 
859     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
860                      order: str) -> List[Tuple["Documenter", bool]]:
861         """Sort the given member list."""
862         if order == 'groupwise':
863             # sort by group; alphabetically within groups
864             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
865         elif order == 'bysource':
866             if self.analyzer:
867                 # sort by source order, by virtue of the module analyzer
868                 tagorder = self.analyzer.tagorder
869 
870                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
871                     fullname = entry[0].name.split('::')[1]
872                     return tagorder.get(fullname, len(tagorder))
873                 documenters.sort(key=keyfunc)
874             else:
875                 # Assume that member discovery order matches source order.
876                 # This is a reasonable assumption in Python 3.6 and up, where
877                 # module.__dict__ is insertion-ordered.
878                 pass
879         else:  # alphabetical
880             documenters.sort(key=lambda e: e[0].name)
881 
882         return documenters
883 
884     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
885                  check_module: bool = False, all_members: bool = False) -> None:
886         """Generate reST for the object given by *self.name*, and possibly for
887         its members.
888 
889         If *more_content* is given, include that content. If *real_modname* is
890         given, use that module name to find attribute docs. If *check_module* is
891         True, only generate if the object is defined in the module name it is
892         imported from. If *all_members* is True, document all members.
893         """
894         if not self.parse_name():
895             # need a module to import
896             logger.warning(
897                 __('don\'t know which module to import for autodocumenting '
898                    '%r (try placing a "module" or "currentmodule" directive '
899                    'in the document, or giving an explicit module name)') %
900                 self.name, type='autodoc')
901             return
902 
903         # now, import the module and get object to document
904         if not self.import_object():
905             return
906 
907         # If there is no real module defined, figure out which to use.
908         # The real module is used in the module analyzer to look up the module
909         # where the attribute documentation would actually be found in.
910         # This is used for situations where you have a module that collects the
911         # functions and classes of internal submodules.
912         guess_modname = self.get_real_modname()
913         self.real_modname = real_modname or guess_modname
914 
915         # try to also get a source code analyzer for attribute docs
916         try:
917             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
918             # parse right now, to get PycodeErrors on parsing (results will
919             # be cached anyway)
920             self.analyzer.find_attr_docs()
921         except PycodeError as exc:
922             logger.debug('[autodoc] module analyzer failed: %s', exc)
923             # no source file -- e.g. for builtin and C modules
924             self.analyzer = None
925             # at least add the module.__file__ as a dependency
926             if hasattr(self.module, '__file__') and self.module.__file__:
927                 self.directive.filename_set.add(self.module.__file__)
928         else:
929             self.directive.filename_set.add(self.analyzer.srcname)
930 
931         if self.real_modname != guess_modname:
932             # Add module to dependency list if target object is defined in other module.
933             try:
934                 analyzer = ModuleAnalyzer.for_module(guess_modname)
935                 self.directive.filename_set.add(analyzer.srcname)
936             except PycodeError:
937                 pass
938 
939         # check __module__ of object (for members not given explicitly)
940         if check_module:
941             if not self.check_module():
942                 return
943 
944         sourcename = self.get_sourcename()
945 
946         # make sure that the result starts with an empty line.  This is
947         # necessary for some situations where another directive preprocesses
948         # reST and no starting newline is present
949         self.add_line('', sourcename)
950 
951         # format the object's signature, if any
952         try:
953             sig = self.format_signature()
954         except Exception as exc:
955             logger.warning(__('error while formatting signature for %s: %s'),
956                            self.fullname, exc, type='autodoc')
957             return
958 
959         # generate the directive header and options, if applicable
960         self.add_directive_header(sig)
961         self.add_line('', sourcename)
962 
963         # e.g. the module directive doesn't have content
964         self.indent += self.content_indent
965 
966         # add all content (from docstrings, attribute docs etc.)
967         self.add_content(more_content)
968 
969         # document members, if possible
970         self.document_members(all_members)
971 
972 
973 class ModuleDocumenter(Documenter):
974     """
975     Specialized Documenter subclass for modules.
976     """
977     objtype = 'module'
978     content_indent = ''
979     titles_allowed = True
980 
981     option_spec = {
982         'members': members_option, 'undoc-members': bool_option,
983         'noindex': bool_option, 'inherited-members': inherited_members_option,
984         'show-inheritance': bool_option, 'synopsis': identity,
985         'platform': identity, 'deprecated': bool_option,
986         'member-order': member_order_option, 'exclude-members': exclude_members_option,
987         'private-members': members_option, 'special-members': members_option,
988         'imported-members': bool_option, 'ignore-module-all': bool_option
989     }  # type: Dict[str, Callable]
990 
991     def __init__(self, *args: Any) -> None:
992         super().__init__(*args)
993         merge_members_option(self.options)
994         self.__all__ = None  # type: Optional[Sequence[str]]
995 
996     @classmethod
997     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
998                             ) -> bool:
999         # don't document submodules automatically
1000         return False
1001 
1002     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1003                      ) -> Tuple[str, List[str]]:
1004         if modname is not None:
1005             logger.warning(__('"::" in automodule name doesn\'t make sense'),
1006                            type='autodoc')
1007         return (path or '') + base, []
1008 
1009     def parse_name(self) -> bool:
1010         ret = super().parse_name()
1011         if self.args or self.retann:
1012             logger.warning(__('signature arguments or return annotation '
1013                               'given for automodule %s') % self.fullname,
1014                            type='autodoc')
1015         return ret
1016 
1017     def import_object(self, raiseerror: bool = False) -> bool:
1018         ret = super().import_object(raiseerror)
1019 
1020         try:
1021             if not self.options.ignore_module_all:
1022                 self.__all__ = inspect.getall(self.object)
1023         except ValueError as exc:
1024             # invalid __all__ found.
1025             logger.warning(__('__all__ should be a list of strings, not %r '
1026                               '(in module %s) -- ignoring __all__') %
1027                            (exc.args[0], self.fullname), type='autodoc')
1028 
1029         return ret
1030 
1031     def add_directive_header(self, sig: str) -> None:
1032         Documenter.add_directive_header(self, sig)
1033 
1034         sourcename = self.get_sourcename()
1035 
1036         # add some module-specific options
1037         if self.options.synopsis:
1038             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
1039         if self.options.platform:
1040             self.add_line('   :platform: ' + self.options.platform, sourcename)
1041         if self.options.deprecated:
1042             self.add_line('   :deprecated:', sourcename)
1043 
1044     def get_module_members(self) -> Dict[str, ObjectMember]:
1045         """Get members of target module."""
1046         if self.analyzer:
1047             attr_docs = self.analyzer.attr_docs
1048         else:
1049             attr_docs = {}
1050 
1051         members = {}  # type: Dict[str, ObjectMember]
1052         for name in dir(self.object):
1053             try:
1054                 value = safe_getattr(self.object, name, None)
1055                 if ismock(value):
1056                     value = undecorate(value)
1057                 docstring = attr_docs.get(('', name), [])
1058                 members[name] = ObjectMember(name, value, docstring="\n".join(docstring))
1059             except AttributeError:
1060                 continue
1061 
1062         # annotation only member (ex. attr: int)
1063         for name in inspect.getannotations(self.object):
1064             if name not in members:
1065                 docstring = attr_docs.get(('', name), [])
1066                 members[name] = ObjectMember(name, INSTANCEATTR,
1067                                              docstring="\n".join(docstring))
1068 
1069         return members
1070 
1071     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1072         members = self.get_module_members()
1073         if want_all:
1074             if self.__all__ is None:
1075                 # for implicit module members, check __module__ to avoid
1076                 # documenting imported objects
1077                 return True, list(members.values())
1078             else:
1079                 for member in members.values():
1080                     if member.__name__ not in self.__all__:
1081                         member.skipped = True
1082 
1083                 return False, list(members.values())
1084         else:
1085             memberlist = self.options.members or []
1086             ret = []
1087             for name in memberlist:
1088                 if name in members:
1089                     ret.append(members[name])
1090                 else:
1091                     logger.warning(__('missing attribute mentioned in :members: option: '
1092                                       'module %s, attribute %s') %
1093                                    (safe_getattr(self.object, '__name__', '???'), name),
1094                                    type='autodoc')
1095             return False, ret
1096 
1097     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1098                      order: str) -> List[Tuple["Documenter", bool]]:
1099         if order == 'bysource' and self.__all__:
1100             # Sort alphabetically first (for members not listed on the __all__)
1101             documenters.sort(key=lambda e: e[0].name)
1102 
1103             # Sort by __all__
1104             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1105                 name = entry[0].name.split('::')[1]
1106                 if name in self.__all__:
1107                     return self.__all__.index(name)
1108                 else:
1109                     return len(self.__all__)
1110             documenters.sort(key=keyfunc)
1111 
1112             return documenters
1113         else:
1114             return super().sort_members(documenters, order)
1115 
1116 
1117 class ModuleLevelDocumenter(Documenter):
1118     """
1119     Specialized Documenter subclass for objects on module level (functions,
1120     classes, data/constants).
1121     """
1122     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1123                      ) -> Tuple[str, List[str]]:
1124         if modname is None:
1125             if path:
1126                 modname = path.rstrip('.')
1127             else:
1128                 # if documenting a toplevel object without explicit module,
1129                 # it can be contained in another auto directive ...
1130                 modname = self.env.temp_data.get('autodoc:module')
1131                 # ... or in the scope of a module directive
1132                 if not modname:
1133                     modname = self.env.ref_context.get('py:module')
1134                 # ... else, it stays None, which means invalid
1135         return modname, parents + [base]
1136 
1137 
1138 class ClassLevelDocumenter(Documenter):
1139     """
1140     Specialized Documenter subclass for objects on class level (methods,
1141     attributes).
1142     """
1143     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1144                      ) -> Tuple[str, List[str]]:
1145         if modname is None:
1146             if path:
1147                 mod_cls = path.rstrip('.')
1148             else:
1149                 mod_cls = None
1150                 # if documenting a class-level object without path,
1151                 # there must be a current class, either from a parent
1152                 # auto directive ...
1153                 mod_cls = self.env.temp_data.get('autodoc:class')
1154                 # ... or from a class directive
1155                 if mod_cls is None:
1156                     mod_cls = self.env.ref_context.get('py:class')
1157                 # ... if still None, there's no way to know
1158                 if mod_cls is None:
1159                     return None, []
1160             modname, sep, cls = mod_cls.rpartition('.')
1161             parents = [cls]
1162             # if the module name is still missing, get it like above
1163             if not modname:
1164                 modname = self.env.temp_data.get('autodoc:module')
1165             if not modname:
1166                 modname = self.env.ref_context.get('py:module')
1167             # ... else, it stays None, which means invalid
1168         return modname, parents + [base]
1169 
1170 
1171 class DocstringSignatureMixin:
1172     """
1173     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1174     feature of reading the signature from the docstring.
1175     """
1176     _new_docstrings = None  # type: List[List[str]]
1177     _signatures = None      # type: List[str]
1178 
1179     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1180         if encoding is not None:
1181             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1182                           "deprecated." % self.__class__.__name__,
1183                           RemovedInSphinx40Warning, stacklevel=2)
1184 
1185         # candidates of the object name
1186         valid_names = [self.objpath[-1]]  # type: ignore
1187         if isinstance(self, ClassDocumenter):
1188             valid_names.append('__init__')
1189             if hasattr(self.object, '__mro__'):
1190                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1191 
1192         docstrings = self.get_doc()
1193         if docstrings is None:
1194             return None, None
1195         self._new_docstrings = docstrings[:]
1196         self._signatures = []
1197         result = None
1198         for i, doclines in enumerate(docstrings):
1199             for j, line in enumerate(doclines):
1200                 if not line:
1201                     # no lines in docstring, no match
1202                     break
1203 
1204                 if line.endswith('\\'):
1205                     multiline = True
1206                     line = line.rstrip('\\').rstrip()
1207                 else:
1208                     multiline = False
1209 
1210                 # match first line of docstring against signature RE
1211                 match = py_ext_sig_re.match(line)
1212                 if not match:
1213                     continue
1214                 exmod, path, base, args, retann = match.groups()
1215 
1216                 # the base name must match ours
1217                 if base not in valid_names:
1218                     continue
1219 
1220                 # re-prepare docstring to ignore more leading indentation
1221                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1222                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1223                                                             tabsize=tab_width)
1224 
1225                 if result is None:
1226                     # first signature
1227                     result = args, retann
1228                 else:
1229                     # subsequent signatures
1230                     self._signatures.append("(%s) -> %s" % (args, retann))
1231 
1232                 if multiline:
1233                     # the signature have multiple signatures on docstring
1234                     continue
1235                 else:
1236                     # don't look any further
1237                     break
1238 
1239             if result:
1240                 # finish the loop when signature found
1241                 break
1242 
1243         return result
1244 
1245     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1246         if encoding is not None:
1247             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1248                           % self.__class__.__name__,
1249                           RemovedInSphinx40Warning, stacklevel=2)
1250         if self._new_docstrings is not None:
1251             return self._new_docstrings
1252         return super().get_doc(None, ignore)  # type: ignore
1253 
1254     def format_signature(self, **kwargs: Any) -> str:
1255         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1256             # only act if a signature is not explicitly given already, and if
1257             # the feature is enabled
1258             result = self._find_signature()
1259             if result is not None:
1260                 self.args, self.retann = result
1261         sig = super().format_signature(**kwargs)  # type: ignore
1262         if self._signatures:
1263             return "\n".join([sig] + self._signatures)
1264         else:
1265             return sig
1266 
1267 
1268 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1269     """
1270     Mixin for AttributeDocumenter to provide the
1271     feature of stripping any function signature from the docstring.
1272     """
1273     def format_signature(self, **kwargs: Any) -> str:
1274         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1275             # only act if a signature is not explicitly given already, and if
1276             # the feature is enabled
1277             result = self._find_signature()
1278             if result is not None:
1279                 # Discarding _args is a only difference with
1280                 # DocstringSignatureMixin.format_signature.
1281                 # Documenter.format_signature use self.args value to format.
1282                 _args, self.retann = result
1283         return super().format_signature(**kwargs)
1284 
1285 
1286 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1287     """
1288     Specialized Documenter subclass for functions.
1289     """
1290     objtype = 'function'
1291     member_order = 30
1292 
1293     @classmethod
1294     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1295                             ) -> bool:
1296         # supports functions, builtins and bound methods exported at the module level
1297         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1298                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1299 
1300     def format_args(self, **kwargs: Any) -> str:
1301         if self.config.autodoc_typehints in ('none', 'description'):
1302             kwargs.setdefault('show_annotation', False)
1303 
1304         try:
1305             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1306             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)
1307             args = stringify_signature(sig, **kwargs)
1308         except TypeError as exc:
1309             logger.warning(__("Failed to get a function signature for %s: %s"),
1310                            self.fullname, exc)
1311             return None
1312         except ValueError:
1313             args = ''
1314 
1315         if self.config.strip_signature_backslash:
1316             # escape backslashes for reST
1317             args = args.replace('\\', '\\\\')
1318         return args
1319 
1320     def document_members(self, all_members: bool = False) -> None:
1321         pass
1322 
1323     def add_directive_header(self, sig: str) -> None:
1324         sourcename = self.get_sourcename()
1325         super().add_directive_header(sig)
1326 
1327         if inspect.iscoroutinefunction(self.object):
1328             self.add_line('   :async:', sourcename)
1329 
1330     def format_signature(self, **kwargs: Any) -> str:
1331         sigs = []
1332         if (self.analyzer and
1333                 '.'.join(self.objpath) in self.analyzer.overloads and
1334                 self.config.autodoc_typehints == 'signature'):
1335             # Use signatures for overloaded functions instead of the implementation function.
1336             overloaded = True
1337         else:
1338             overloaded = False
1339             sig = super().format_signature(**kwargs)
1340             sigs.append(sig)
1341 
1342         if inspect.is_singledispatch_function(self.object):
1343             # append signature of singledispatch'ed functions
1344             for typ, func in self.object.registry.items():
1345                 if typ is object:
1346                     pass  # default implementation. skipped.
1347                 else:
1348                     self.annotate_to_first_argument(func, typ)
1349 
1350                     documenter = FunctionDocumenter(self.directive, '')
1351                     documenter.object = func
1352                     documenter.objpath = [None]
1353                     sigs.append(documenter.format_signature())
1354         if overloaded:
1355             actual = inspect.signature(self.object,
1356                                        type_aliases=self.config.autodoc_type_aliases)
1357             __globals__ = safe_getattr(self.object, '__globals__', {})
1358             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1359                 overload = self.merge_default_value(actual, overload)
1360                 overload = evaluate_signature(overload, __globals__,
1361                                               self.config.autodoc_type_aliases)
1362 
1363                 sig = stringify_signature(overload, **kwargs)
1364                 sigs.append(sig)
1365 
1366         return "\n".join(sigs)
1367 
1368     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
1369         """Merge default values of actual implementation to the overload variants."""
1370         parameters = list(overload.parameters.values())
1371         for i, param in enumerate(parameters):
1372             actual_param = actual.parameters.get(param.name)
1373             if actual_param and param.default == '...':
1374                 parameters[i] = param.replace(default=actual_param.default)
1375 
1376         return overload.replace(parameters=parameters)
1377 
1378     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1379         """Annotate type hint to the first argument of function if needed."""
1380         try:
1381             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
1382         except TypeError as exc:
1383             logger.warning(__("Failed to get a function signature for %s: %s"),
1384                            self.fullname, exc)
1385             return
1386         except ValueError:
1387             return
1388 
1389         if len(sig.parameters) == 0:
1390             return
1391 
1392         params = list(sig.parameters.values())
1393         if params[0].annotation is Parameter.empty:
1394             params[0] = params[0].replace(annotation=typ)
1395             try:
1396                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1397             except TypeError:
1398                 # failed to update signature (ex. built-in or extension types)
1399                 return
1400 
1401 
1402 class DecoratorDocumenter(FunctionDocumenter):
1403     """
1404     Specialized Documenter subclass for decorator functions.
1405     """
1406     objtype = 'decorator'
1407 
1408     # must be lower than FunctionDocumenter
1409     priority = -1
1410 
1411     def format_args(self, **kwargs: Any) -> Any:
1412         args = super().format_args(**kwargs)
1413         if ',' in args:
1414             return args
1415         else:
1416             return None
1417 
1418 
1419 # Types which have confusing metaclass signatures it would be best not to show.
1420 # These are listed by name, rather than storing the objects themselves, to avoid
1421 # needing to import the modules.
1422 _METACLASS_CALL_BLACKLIST = [
1423     'enum.EnumMeta.__call__',
1424 ]
1425 
1426 
1427 # Types whose __new__ signature is a pass-thru.
1428 _CLASS_NEW_BLACKLIST = [
1429     'typing.Generic.__new__',
1430 ]
1431 
1432 
1433 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1434     """
1435     Specialized Documenter subclass for classes.
1436     """
1437     objtype = 'class'
1438     member_order = 20
1439     option_spec = {
1440         'members': members_option, 'undoc-members': bool_option,
1441         'noindex': bool_option, 'inherited-members': inherited_members_option,
1442         'show-inheritance': bool_option, 'member-order': member_order_option,
1443         'exclude-members': exclude_members_option,
1444         'private-members': members_option, 'special-members': members_option,
1445     }  # type: Dict[str, Callable]
1446 
1447     _signature_class = None  # type: Any
1448     _signature_method_name = None  # type: str
1449 
1450     def __init__(self, *args: Any) -> None:
1451         super().__init__(*args)
1452         merge_members_option(self.options)
1453 
1454     @classmethod
1455     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1456                             ) -> bool:
1457         return isinstance(member, type)
1458 
1459     def import_object(self, raiseerror: bool = False) -> bool:
1460         ret = super().import_object(raiseerror)
1461         # if the class is documented under another name, document it
1462         # as data/attribute
1463         if ret:
1464             if hasattr(self.object, '__name__'):
1465                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1466             else:
1467                 self.doc_as_attr = True
1468         return ret
1469 
1470     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1471         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1472             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1473             if inspect.is_builtin_class_method(obj, attr):
1474                 return None
1475             attr = self.get_attr(obj, attr, None)
1476             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1477                 return None
1478             return attr
1479 
1480         # This sequence is copied from inspect._signature_from_callable.
1481         # ValueError means that no signature could be found, so we keep going.
1482 
1483         # First, we check the obj has a __signature__ attribute
1484         if (hasattr(self.object, '__signature__') and
1485                 isinstance(self.object.__signature__, Signature)):
1486             return None, None, self.object.__signature__
1487 
1488         # Next, let's see if it has an overloaded __call__ defined
1489         # in its metaclass
1490         call = get_user_defined_function_or_method(type(self.object), '__call__')
1491 
1492         if call is not None:
1493             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1494                 call = None
1495 
1496         if call is not None:
1497             self.env.app.emit('autodoc-before-process-signature', call, True)
1498             try:
1499                 sig = inspect.signature(call, bound_method=True,
1500                                         type_aliases=self.config.autodoc_type_aliases)
1501                 return type(self.object), '__call__', sig
1502             except ValueError:
1503                 pass
1504 
1505         # Now we check if the 'obj' class has a '__new__' method
1506         new = get_user_defined_function_or_method(self.object, '__new__')
1507 
1508         if new is not None:
1509             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1510                 new = None
1511 
1512         if new is not None:
1513             self.env.app.emit('autodoc-before-process-signature', new, True)
1514             try:
1515                 sig = inspect.signature(new, bound_method=True,
1516                                         type_aliases=self.config.autodoc_type_aliases)
1517                 return self.object, '__new__', sig
1518             except ValueError:
1519                 pass
1520 
1521         # Finally, we should have at least __init__ implemented
1522         init = get_user_defined_function_or_method(self.object, '__init__')
1523         if init is not None:
1524             self.env.app.emit('autodoc-before-process-signature', init, True)
1525             try:
1526                 sig = inspect.signature(init, bound_method=True,
1527                                         type_aliases=self.config.autodoc_type_aliases)
1528                 return self.object, '__init__', sig
1529             except ValueError:
1530                 pass
1531 
1532         # None of the attributes are user-defined, so fall back to let inspect
1533         # handle it.
1534         # We don't know the exact method that inspect.signature will read
1535         # the signature from, so just pass the object itself to our hook.
1536         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1537         try:
1538             sig = inspect.signature(self.object, bound_method=False,
1539                                     type_aliases=self.config.autodoc_type_aliases)
1540             return None, None, sig
1541         except ValueError:
1542             pass
1543 
1544         # Still no signature: happens e.g. for old-style classes
1545         # with __init__ in C and no `__text_signature__`.
1546         return None, None, None
1547 
1548     def format_args(self, **kwargs: Any) -> str:
1549         if self.config.autodoc_typehints in ('none', 'description'):
1550             kwargs.setdefault('show_annotation', False)
1551 
1552         try:
1553             self._signature_class, self._signature_method_name, sig = self._get_signature()
1554         except TypeError as exc:
1555             # __signature__ attribute contained junk
1556             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1557                            self.fullname, exc)
1558             return None
1559 
1560         if sig is None:
1561             return None
1562 
1563         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1564 
1565     def format_signature(self, **kwargs: Any) -> str:
1566         if self.doc_as_attr:
1567             return ''
1568 
1569         sig = super().format_signature()
1570         sigs = []
1571 
1572         overloads = self.get_overloaded_signatures()
1573         if overloads and self.config.autodoc_typehints == 'signature':
1574             # Use signatures for overloaded methods instead of the implementation method.
1575             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1576             __globals__ = safe_getattr(method, '__globals__', {})
1577             for overload in overloads:
1578                 overload = evaluate_signature(overload, __globals__,
1579                                               self.config.autodoc_type_aliases)
1580 
1581                 parameters = list(overload.parameters.values())
1582                 overload = overload.replace(parameters=parameters[1:],
1583                                             return_annotation=Parameter.empty)
1584                 sig = stringify_signature(overload, **kwargs)
1585                 sigs.append(sig)
1586         else:
1587             sigs.append(sig)
1588 
1589         return "\n".join(sigs)
1590 
1591     def get_overloaded_signatures(self) -> List[Signature]:
1592         if self._signature_class and self._signature_method_name:
1593             for cls in self._signature_class.__mro__:
1594                 try:
1595                     analyzer = ModuleAnalyzer.for_module(cls.__module__)
1596                     analyzer.analyze()
1597                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])
1598                     if qualname in analyzer.overloads:
1599                         return analyzer.overloads.get(qualname)
1600                     elif qualname in analyzer.tagorder:
1601                         # the constructor is defined in the class, but not overrided.
1602                         return []
1603                 except PycodeError:
1604                     pass
1605 
1606         return []
1607 
1608     def add_directive_header(self, sig: str) -> None:
1609         sourcename = self.get_sourcename()
1610 
1611         if self.doc_as_attr:
1612             self.directivetype = 'attribute'
1613         super().add_directive_header(sig)
1614 
1615         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1616             self.add_line('   :final:', sourcename)
1617 
1618         # add inheritance info, if wanted
1619         if not self.doc_as_attr and self.options.show_inheritance:
1620             sourcename = self.get_sourcename()
1621             self.add_line('', sourcename)
1622 
1623             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):
1624                 # A subclass of generic types
1625                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>
1626                 bases = [restify(cls) for cls in self.object.__orig_bases__]
1627                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1628             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):
1629                 # A normal class
1630                 bases = [restify(cls) for cls in self.object.__bases__]
1631                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1632 
1633     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1634         members = get_class_members(self.object, self.objpath, self.get_attr)
1635         if not want_all:
1636             if not self.options.members:
1637                 return False, []  # type: ignore
1638             # specific members given
1639             selected = []
1640             for name in self.options.members:  # type: str
1641                 if name in members:
1642                     selected.append(members[name])
1643                 else:
1644                     logger.warning(__('missing attribute %s in object %s') %
1645                                    (name, self.fullname), type='autodoc')
1646             return False, selected
1647         elif self.options.inherited_members:
1648             return False, list(members.values())
1649         else:
1650             return False, [m for m in members.values() if m.class_ == self.object]
1651 
1652     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1653         if encoding is not None:
1654             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1655                           % self.__class__.__name__,
1656                           RemovedInSphinx40Warning, stacklevel=2)
1657         if self.doc_as_attr:
1658             # Don't show the docstring of the class when it is an alias.
1659             return None
1660 
1661         lines = getattr(self, '_new_docstrings', None)
1662         if lines is not None:
1663             return lines
1664 
1665         content = self.config.autoclass_content
1666 
1667         docstrings = []
1668         attrdocstring = self.get_attr(self.object, '__doc__', None)
1669         if attrdocstring:
1670             docstrings.append(attrdocstring)
1671 
1672         # for classes, what the "docstring" is can be controlled via a
1673         # config value; the default is only the class docstring
1674         if content in ('both', 'init'):
1675             __init__ = self.get_attr(self.object, '__init__', None)
1676             initdocstring = getdoc(__init__, self.get_attr,
1677                                    self.config.autodoc_inherit_docstrings,
1678                                    self.parent, self.object_name)
1679             # for new-style classes, no __init__ means default __init__
1680             if (initdocstring is not None and
1681                 (initdocstring == object.__init__.__doc__ or  # for pypy
1682                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1683                 initdocstring = None
1684             if not initdocstring:
1685                 # try __new__
1686                 __new__ = self.get_attr(self.object, '__new__', None)
1687                 initdocstring = getdoc(__new__, self.get_attr,
1688                                        self.config.autodoc_inherit_docstrings,
1689                                        self.parent, self.object_name)
1690                 # for new-style classes, no __new__ means default __new__
1691                 if (initdocstring is not None and
1692                     (initdocstring == object.__new__.__doc__ or  # for pypy
1693                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1694                     initdocstring = None
1695             if initdocstring:
1696                 if content == 'init':
1697                     docstrings = [initdocstring]
1698                 else:
1699                     docstrings.append(initdocstring)
1700 
1701         tab_width = self.directive.state.document.settings.tab_width
1702         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1703 
1704     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1705                     ) -> None:
1706         if self.doc_as_attr:
1707             try:
1708                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')
1709             except AttributeError:
1710                 pass  # Invalid class object is passed.
1711 
1712         super().add_content(more_content)
1713 
1714     def document_members(self, all_members: bool = False) -> None:
1715         if self.doc_as_attr:
1716             return
1717         super().document_members(all_members)
1718 
1719     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
1720                  check_module: bool = False, all_members: bool = False) -> None:
1721         # Do not pass real_modname and use the name from the __module__
1722         # attribute of the class.
1723         # If a class gets imported into the module real_modname
1724         # the analyzer won't find the source of the class, if
1725         # it looks in real_modname.
1726         return super().generate(more_content=more_content,
1727                                 check_module=check_module,
1728                                 all_members=all_members)
1729 
1730 
1731 class ExceptionDocumenter(ClassDocumenter):
1732     """
1733     Specialized ClassDocumenter subclass for exceptions.
1734     """
1735     objtype = 'exception'
1736     member_order = 10
1737 
1738     # needs a higher priority than ClassDocumenter
1739     priority = 10
1740 
1741     @classmethod
1742     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1743                             ) -> bool:
1744         return isinstance(member, type) and issubclass(member, BaseException)
1745 
1746 
1747 class DataDocumenterMixinBase:
1748     # define types of instance variables
1749     config = None  # type: Config
1750     env = None  # type: BuildEnvironment
1751     modname = None  # type: str
1752     parent = None  # type: Any
1753     object = None  # type: Any
1754     objpath = None  # type: List[str]
1755 
1756     def should_suppress_directive_header(self) -> bool:
1757         """Check directive header should be suppressed."""
1758         return False
1759 
1760     def should_suppress_value_header(self) -> bool:
1761         """Check :value: header should be suppressed."""
1762         return False
1763 
1764     def update_content(self, more_content: StringList) -> None:
1765         """Update docstring for the NewType object."""
1766         pass
1767 
1768 
1769 class GenericAliasMixin(DataDocumenterMixinBase):
1770     """
1771     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1772     supporting GenericAliases.
1773     """
1774 
1775     def should_suppress_directive_header(self) -> bool:
1776         return (inspect.isgenericalias(self.object) or
1777                 super().should_suppress_directive_header())
1778 
1779     def update_content(self, more_content: StringList) -> None:
1780         if inspect.isgenericalias(self.object):
1781             alias = stringify_typehint(self.object)
1782             more_content.append(_('alias of %s') % alias, '')
1783             more_content.append('', '')
1784 
1785         super().update_content(more_content)
1786 
1787 
1788 class NewTypeMixin(DataDocumenterMixinBase):
1789     """
1790     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1791     supporting NewTypes.
1792     """
1793 
1794     def should_suppress_directive_header(self) -> bool:
1795         return (inspect.isNewType(self.object) or
1796                 super().should_suppress_directive_header())
1797 
1798     def update_content(self, more_content: StringList) -> None:
1799         if inspect.isNewType(self.object):
1800             supertype = restify(self.object.__supertype__)
1801             more_content.append(_('alias of %s') % supertype, '')
1802             more_content.append('', '')
1803 
1804         super().update_content(more_content)
1805 
1806 
1807 class TypeVarMixin(DataDocumenterMixinBase):
1808     """
1809     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1810     supporting TypeVars.
1811     """
1812 
1813     def should_suppress_directive_header(self) -> bool:
1814         return (isinstance(self.object, TypeVar) or
1815                 super().should_suppress_directive_header())
1816 
1817     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1818         if ignore is not None:
1819             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1820                           % self.__class__.__name__,
1821                           RemovedInSphinx50Warning, stacklevel=2)
1822 
1823         if isinstance(self.object, TypeVar):
1824             if self.object.__doc__ != TypeVar.__doc__:
1825                 return super().get_doc()  # type: ignore
1826             else:
1827                 return []
1828         else:
1829             return super().get_doc()  # type: ignore
1830 
1831     def update_content(self, more_content: StringList) -> None:
1832         if isinstance(self.object, TypeVar):
1833             attrs = [repr(self.object.__name__)]
1834             for constraint in self.object.__constraints__:
1835                 attrs.append(stringify_typehint(constraint))
1836             if self.object.__covariant__:
1837                 attrs.append("covariant=True")
1838             if self.object.__contravariant__:
1839                 attrs.append("contravariant=True")
1840 
1841             more_content.append(_('alias of TypeVar(%s)') % ", ".join(attrs), '')
1842             more_content.append('', '')
1843 
1844         super().update_content(more_content)
1845 
1846 
1847 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):
1848     """
1849     Mixin for DataDocumenter to provide the feature for supporting uninitialized
1850     (type annotation only) global variables.
1851     """
1852 
1853     def import_object(self, raiseerror: bool = False) -> bool:
1854         try:
1855             return super().import_object(raiseerror=True)  # type: ignore
1856         except ImportError as exc:
1857             # annotation only instance variable (PEP-526)
1858             try:
1859                 with mock(self.config.autodoc_mock_imports):
1860                     parent = import_module(self.modname, self.config.autodoc_warningiserror)
1861                     annotations = get_type_hints(parent, None,
1862                                                  self.config.autodoc_type_aliases)
1863                     if self.objpath[-1] in annotations:
1864                         self.object = UNINITIALIZED_ATTR
1865                         self.parent = parent
1866                         return True
1867             except ImportError:
1868                 pass
1869 
1870             if raiseerror:
1871                 raise
1872             else:
1873                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1874                 self.env.note_reread()
1875                 return False
1876 
1877     def should_suppress_value_header(self) -> bool:
1878         return (self.object is UNINITIALIZED_ATTR or
1879                 super().should_suppress_value_header())
1880 
1881     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1882         if self.object is UNINITIALIZED_ATTR:
1883             return []
1884         else:
1885             return super().get_doc(encoding, ignore)  # type: ignore
1886 
1887 
1888 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
1889                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):
1890     """
1891     Specialized Documenter subclass for data items.
1892     """
1893     objtype = 'data'
1894     member_order = 40
1895     priority = -10
1896     option_spec = dict(ModuleLevelDocumenter.option_spec)
1897     option_spec["annotation"] = annotation_option
1898     option_spec["no-value"] = bool_option
1899 
1900     @classmethod
1901     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1902                             ) -> bool:
1903         return isinstance(parent, ModuleDocumenter) and isattr
1904 
1905     def update_annotations(self, parent: Any) -> None:
1906         """Update __annotations__ to support type_comment and so on."""
1907         annotations = dict(inspect.getannotations(parent))
1908         parent.__annotations__ = annotations
1909 
1910         try:
1911             analyzer = ModuleAnalyzer.for_module(self.modname)
1912             analyzer.analyze()
1913             for (classname, attrname), annotation in analyzer.annotations.items():
1914                 if classname == '' and attrname not in annotations:
1915                     annotations[attrname] = annotation
1916         except PycodeError:
1917             pass
1918 
1919     def import_object(self, raiseerror: bool = False) -> bool:
1920         ret = super().import_object(raiseerror)
1921         if self.parent:
1922             self.update_annotations(self.parent)
1923 
1924         return ret
1925 
1926     def should_suppress_value_header(self) -> bool:
1927         if super().should_suppress_value_header():
1928             return True
1929         else:
1930             doc = self.get_doc()
1931             metadata = extract_metadata('\n'.join(sum(doc, [])))
1932             if 'hide-value' in metadata:
1933                 return True
1934 
1935         return False
1936 
1937     def add_directive_header(self, sig: str) -> None:
1938         super().add_directive_header(sig)
1939         sourcename = self.get_sourcename()
1940         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
1941             pass
1942         elif self.options.annotation:
1943             self.add_line('   :annotation: %s' % self.options.annotation,
1944                           sourcename)
1945         else:
1946             # obtain annotation for this data
1947             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
1948             if self.objpath[-1] in annotations:
1949                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1950                 self.add_line('   :type: ' + objrepr, sourcename)
1951 
1952             try:
1953                 if self.options.no_value or self.should_suppress_value_header():
1954                     pass
1955                 else:
1956                     objrepr = object_description(self.object)
1957                     self.add_line('   :value: ' + objrepr, sourcename)
1958             except ValueError:
1959                 pass
1960 
1961     def document_members(self, all_members: bool = False) -> None:
1962         pass
1963 
1964     def get_real_modname(self) -> str:
1965         return self.get_attr(self.parent or self.object, '__module__', None) \
1966             or self.modname
1967 
1968     def get_module_comment(self, attrname: str) -> Optional[List[str]]:
1969         try:
1970             analyzer = ModuleAnalyzer.for_module(self.modname)
1971             analyzer.analyze()
1972             key = ('', attrname)
1973             if key in analyzer.attr_docs:
1974                 return list(analyzer.attr_docs[key])
1975         except PycodeError:
1976             pass
1977 
1978         return None
1979 
1980     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1981         # Check the variable has a docstring-comment
1982         comment = self.get_module_comment(self.objpath[-1])
1983         if comment:
1984             return [comment]
1985         else:
1986             return super().get_doc(encoding, ignore)
1987 
1988     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1989                     ) -> None:
1990         # Disable analyzing variable comment on Documenter.add_content() to control it on
1991         # DataDocumenter.add_content()
1992         self.analyzer = None
1993 
1994         if not more_content:
1995             more_content = StringList()
1996 
1997         self.update_content(more_content)
1998         super().add_content(more_content, no_docstring=no_docstring)
1999 
2000 
2001 class NewTypeDataDocumenter(DataDocumenter):
2002     """
2003     Specialized Documenter subclass for NewTypes.
2004 
2005     Note: This must be invoked before FunctionDocumenter because NewType is a kind of
2006     function object.
2007     """
2008 
2009     objtype = 'newtypedata'
2010     directivetype = 'data'
2011     priority = FunctionDocumenter.priority + 1
2012 
2013     @classmethod
2014     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2015                             ) -> bool:
2016         return inspect.isNewType(member) and isattr
2017 
2018 
2019 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
2020     """
2021     Specialized Documenter subclass for methods (normal, static and class).
2022     """
2023     objtype = 'method'
2024     directivetype = 'method'
2025     member_order = 50
2026     priority = 1  # must be more than FunctionDocumenter
2027 
2028     @classmethod
2029     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2030                             ) -> bool:
2031         return inspect.isroutine(member) and \
2032             not isinstance(parent, ModuleDocumenter)
2033 
2034     def import_object(self, raiseerror: bool = False) -> bool:
2035         ret = super().import_object(raiseerror)
2036         if not ret:
2037             return ret
2038 
2039         # to distinguish classmethod/staticmethod
2040         obj = self.parent.__dict__.get(self.object_name)
2041         if obj is None:
2042             obj = self.object
2043 
2044         if (inspect.isclassmethod(obj) or
2045                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
2046             # document class and static members before ordinary ones
2047             self.member_order = self.member_order - 1
2048 
2049         return ret
2050 
2051     def format_args(self, **kwargs: Any) -> str:
2052         if self.config.autodoc_typehints in ('none', 'description'):
2053             kwargs.setdefault('show_annotation', False)
2054 
2055         try:
2056             if self.object == object.__init__ and self.parent != object:
2057                 # Classes not having own __init__() method are shown as no arguments.
2058                 #
2059                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
2060                 #       But it makes users confused.
2061                 args = '()'
2062             else:
2063                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2064                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
2065                     sig = inspect.signature(self.object, bound_method=False,
2066                                             type_aliases=self.config.autodoc_type_aliases)
2067                 else:
2068                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
2069                     sig = inspect.signature(self.object, bound_method=True,
2070                                             type_aliases=self.config.autodoc_type_aliases)
2071                 args = stringify_signature(sig, **kwargs)
2072         except TypeError as exc:
2073             logger.warning(__("Failed to get a method signature for %s: %s"),
2074                            self.fullname, exc)
2075             return None
2076         except ValueError:
2077             args = ''
2078 
2079         if self.config.strip_signature_backslash:
2080             # escape backslashes for reST
2081             args = args.replace('\\', '\\\\')
2082         return args
2083 
2084     def add_directive_header(self, sig: str) -> None:
2085         super().add_directive_header(sig)
2086 
2087         sourcename = self.get_sourcename()
2088         obj = self.parent.__dict__.get(self.object_name, self.object)
2089         if inspect.isabstractmethod(obj):
2090             self.add_line('   :abstractmethod:', sourcename)
2091         if inspect.iscoroutinefunction(obj):
2092             self.add_line('   :async:', sourcename)
2093         if inspect.isclassmethod(obj):
2094             self.add_line('   :classmethod:', sourcename)
2095         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
2096             self.add_line('   :staticmethod:', sourcename)
2097         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
2098             self.add_line('   :final:', sourcename)
2099 
2100     def document_members(self, all_members: bool = False) -> None:
2101         pass
2102 
2103     def format_signature(self, **kwargs: Any) -> str:
2104         sigs = []
2105         if (self.analyzer and
2106                 '.'.join(self.objpath) in self.analyzer.overloads and
2107                 self.config.autodoc_typehints == 'signature'):
2108             # Use signatures for overloaded methods instead of the implementation method.
2109             overloaded = True
2110         else:
2111             overloaded = False
2112             sig = super().format_signature(**kwargs)
2113             sigs.append(sig)
2114 
2115         meth = self.parent.__dict__.get(self.objpath[-1])
2116         if inspect.is_singledispatch_method(meth):
2117             # append signature of singledispatch'ed functions
2118             for typ, func in meth.dispatcher.registry.items():
2119                 if typ is object:
2120                     pass  # default implementation. skipped.
2121                 else:
2122                     self.annotate_to_first_argument(func, typ)
2123 
2124                     documenter = MethodDocumenter(self.directive, '')
2125                     documenter.parent = self.parent
2126                     documenter.object = func
2127                     documenter.objpath = [None]
2128                     sigs.append(documenter.format_signature())
2129         if overloaded:
2130             if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2131                 actual = inspect.signature(self.object, bound_method=False,
2132                                            type_aliases=self.config.autodoc_type_aliases)
2133             else:
2134                 actual = inspect.signature(self.object, bound_method=True,
2135                                            type_aliases=self.config.autodoc_type_aliases)
2136 
2137             __globals__ = safe_getattr(self.object, '__globals__', {})
2138             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
2139                 overload = self.merge_default_value(actual, overload)
2140                 overload = evaluate_signature(overload, __globals__,
2141                                               self.config.autodoc_type_aliases)
2142 
2143                 if not inspect.isstaticmethod(self.object, cls=self.parent,
2144                                               name=self.object_name):
2145                     parameters = list(overload.parameters.values())
2146                     overload = overload.replace(parameters=parameters[1:])
2147                 sig = stringify_signature(overload, **kwargs)
2148                 sigs.append(sig)
2149 
2150         return "\n".join(sigs)
2151 
2152     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
2153         """Merge default values of actual implementation to the overload variants."""
2154         parameters = list(overload.parameters.values())
2155         for i, param in enumerate(parameters):
2156             actual_param = actual.parameters.get(param.name)
2157             if actual_param and param.default == '...':
2158                 parameters[i] = param.replace(default=actual_param.default)
2159 
2160         return overload.replace(parameters=parameters)
2161 
2162     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
2163         """Annotate type hint to the first argument of function if needed."""
2164         try:
2165             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
2166         except TypeError as exc:
2167             logger.warning(__("Failed to get a method signature for %s: %s"),
2168                            self.fullname, exc)
2169             return
2170         except ValueError:
2171             return
2172         if len(sig.parameters) == 1:
2173             return
2174 
2175         params = list(sig.parameters.values())
2176         if params[1].annotation is Parameter.empty:
2177             params[1] = params[1].replace(annotation=typ)
2178             try:
2179                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
2180             except TypeError:
2181                 # failed to update signature (ex. built-in or extension types)
2182                 return
2183 
2184 
2185 class NonDataDescriptorMixin(DataDocumenterMixinBase):
2186     """
2187     Mixin for AttributeDocumenter to provide the feature for supporting non
2188     data-descriptors.
2189 
2190     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring
2191               and :value: header will be suppressed unexpectedly.
2192     """
2193 
2194     def import_object(self, raiseerror: bool = False) -> bool:
2195         ret = super().import_object(raiseerror)  # type: ignore
2196         if ret and not inspect.isattributedescriptor(self.object):
2197             self.non_data_descriptor = True
2198         else:
2199             self.non_data_descriptor = False
2200 
2201         return ret
2202 
2203     def should_suppress_value_header(self) -> bool:
2204         return (not getattr(self, 'non_data_descriptor', False) or
2205                 super().should_suppress_directive_header())
2206 
2207     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2208         if getattr(self, 'non_data_descriptor', False):
2209             # the docstring of non datadescriptor is very probably the wrong thing
2210             # to display
2211             return None
2212         else:
2213             return super().get_doc(encoding, ignore)  # type: ignore
2214 
2215 
2216 class SlotsMixin(DataDocumenterMixinBase):
2217     """
2218     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.
2219     """
2220 
2221     def isslotsattribute(self) -> bool:
2222         """Check the subject is an attribute in __slots__."""
2223         try:
2224             __slots__ = inspect.getslots(self.parent)
2225             if __slots__ and self.objpath[-1] in __slots__:
2226                 return True
2227             else:
2228                 return False
2229         except (ValueError, TypeError):
2230             return False
2231 
2232     def import_object(self, raiseerror: bool = False) -> bool:
2233         ret = super().import_object(raiseerror)  # type: ignore
2234         if self.isslotsattribute():
2235             self.object = SLOTSATTR
2236 
2237         return ret
2238 
2239     def should_suppress_directive_header(self) -> bool:
2240         if self.object is SLOTSATTR:
2241             self._datadescriptor = True
2242             return True
2243         else:
2244             return super().should_suppress_directive_header()
2245 
2246     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2247         if self.object is SLOTSATTR:
2248             try:
2249                 __slots__ = inspect.getslots(self.parent)
2250                 if __slots__ and __slots__.get(self.objpath[-1]):
2251                     docstring = prepare_docstring(__slots__[self.objpath[-1]])
2252                     return [docstring]
2253                 else:
2254                     return []
2255             except ValueError as exc:
2256                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),
2257                                (self.parent.__qualname__, exc), type='autodoc')
2258                 return []
2259         else:
2260             return super().get_doc(encoding, ignore)  # type: ignore
2261 
2262 
2263 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):
2264     """
2265     Mixin for AttributeDocumenter to provide the feature for supporting runtime
2266     instance attributes (that are defined in __init__() methods with doc-comments).
2267 
2268     Example:
2269 
2270         class Foo:
2271             def __init__(self):
2272                 self.attr = None  #: This is a target of this mix-in.
2273     """
2274 
2275     RUNTIME_INSTANCE_ATTRIBUTE = object()
2276 
2277     def is_runtime_instance_attribute(self, parent: Any) -> bool:
2278         """Check the subject is an attribute defined in __init__()."""
2279         # An instance variable defined in __init__().
2280         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore
2281             return True
2282         else:
2283             return False
2284 
2285     def import_object(self, raiseerror: bool = False) -> bool:
2286         """Check the existence of runtime instance attribute when failed to import the
2287         attribute."""
2288         try:
2289             return super().import_object(raiseerror=True)  # type: ignore
2290         except ImportError as exc:
2291             try:
2292                 with mock(self.config.autodoc_mock_imports):
2293                     ret = import_object(self.modname, self.objpath[:-1], 'class',
2294                                         attrgetter=self.get_attr,  # type: ignore
2295                                         warningiserror=self.config.autodoc_warningiserror)
2296                     parent = ret[3]
2297                     if self.is_runtime_instance_attribute(parent):
2298                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE
2299                         self.parent = parent
2300                         return True
2301             except ImportError:
2302                 pass
2303 
2304             if raiseerror:
2305                 raise
2306             else:
2307                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2308                 self.env.note_reread()
2309                 return False
2310 
2311     def should_suppress_value_header(self) -> bool:
2312         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or
2313                 super().should_suppress_value_header())
2314 
2315 
2316 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):
2317     """
2318     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized
2319     instance attributes (PEP-526 styled, annotation only attributes).
2320 
2321     Example:
2322 
2323         class Foo:
2324             attr: int  #: This is a target of this mix-in.
2325     """
2326 
2327     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:
2328         """Check the subject is an annotation only attribute."""
2329         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)
2330         if self.objpath[-1] in annotations:
2331             return True
2332         else:
2333             return False
2334 
2335     def import_object(self, raiseerror: bool = False) -> bool:
2336         """Check the exisitence of uninitialized instance attribute when failed to import
2337         the attribute."""
2338         try:
2339             return super().import_object(raiseerror=True)  # type: ignore
2340         except ImportError as exc:
2341             try:
2342                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2343                                     attrgetter=self.get_attr,  # type: ignore
2344                                     warningiserror=self.config.autodoc_warningiserror)
2345                 parent = ret[3]
2346                 if self.is_uninitialized_instance_attribute(parent):
2347                     self.object = UNINITIALIZED_ATTR
2348                     self.parent = parent
2349                     return True
2350             except ImportError:
2351                 pass
2352 
2353             if raiseerror:
2354                 raise
2355             else:
2356                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2357                 self.env.note_reread()
2358                 return False
2359 
2360     def should_suppress_value_header(self) -> bool:
2361         return (self.object is UNINITIALIZED_ATTR or
2362                 super().should_suppress_value_header())
2363 
2364     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2365         if self.object is UNINITIALIZED_ATTR:
2366             return None
2367         else:
2368             return super().get_doc(encoding, ignore)  # type: ignore
2369 
2370 
2371 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore
2372                           TypeVarMixin, RuntimeInstanceAttributeMixin,
2373                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,
2374                           DocstringStripSignatureMixin, ClassLevelDocumenter):
2375     """
2376     Specialized Documenter subclass for attributes.
2377     """
2378     objtype = 'attribute'
2379     member_order = 60
2380     option_spec = dict(ModuleLevelDocumenter.option_spec)
2381     option_spec["annotation"] = annotation_option
2382     option_spec["no-value"] = bool_option
2383 
2384     # must be higher than the MethodDocumenter, else it will recognize
2385     # some non-data descriptors as methods
2386     priority = 10
2387 
2388     @staticmethod
2389     def is_function_or_method(obj: Any) -> bool:
2390         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
2391 
2392     @classmethod
2393     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2394                             ) -> bool:
2395         if inspect.isattributedescriptor(member):
2396             return True
2397         elif (not isinstance(parent, ModuleDocumenter) and
2398               not inspect.isroutine(member) and
2399               not isinstance(member, type)):
2400             return True
2401         else:
2402             return False
2403 
2404     def document_members(self, all_members: bool = False) -> None:
2405         pass
2406 
2407     def isinstanceattribute(self) -> bool:
2408         """Check the subject is an instance attribute."""
2409         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',
2410                       RemovedInSphinx50Warning)
2411         # uninitialized instance variable (PEP-526)
2412         with mock(self.config.autodoc_mock_imports):
2413             try:
2414                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2415                                     attrgetter=self.get_attr,
2416                                     warningiserror=self.config.autodoc_warningiserror)
2417                 self.parent = ret[3]
2418                 annotations = get_type_hints(self.parent, None,
2419                                              self.config.autodoc_type_aliases)
2420                 if self.objpath[-1] in annotations:
2421                     self.object = UNINITIALIZED_ATTR
2422                     return True
2423             except ImportError:
2424                 pass
2425 
2426         return False
2427 
2428     def update_annotations(self, parent: Any) -> None:
2429         """Update __annotations__ to support type_comment and so on."""
2430         try:
2431             annotations = dict(inspect.getannotations(parent))
2432             parent.__annotations__ = annotations
2433 
2434             for cls in inspect.getmro(parent):
2435                 try:
2436                     module = safe_getattr(cls, '__module__')
2437                     qualname = safe_getattr(cls, '__qualname__')
2438 
2439                     analyzer = ModuleAnalyzer.for_module(module)
2440                     analyzer.analyze()
2441                     for (classname, attrname), annotation in analyzer.annotations.items():
2442                         if classname == qualname and attrname not in annotations:
2443                             annotations[attrname] = annotation
2444                 except (AttributeError, PycodeError):
2445                     pass
2446         except TypeError:
2447             # Failed to set __annotations__ (built-in, extensions, etc.)
2448             pass
2449 
2450     def import_object(self, raiseerror: bool = False) -> bool:
2451         ret = super().import_object(raiseerror)
2452         if inspect.isenumattribute(self.object):
2453             self.object = self.object.value
2454         if self.parent:
2455             self.update_annotations(self.parent)
2456 
2457         return ret
2458 
2459     def get_real_modname(self) -> str:
2460         return self.get_attr(self.parent or self.object, '__module__', None) \
2461             or self.modname
2462 
2463     def should_suppress_value_header(self) -> bool:
2464         if super().should_suppress_value_header():
2465             return True
2466         else:
2467             doc = self.get_doc()
2468             if doc:
2469                 metadata = extract_metadata('\n'.join(sum(doc, [])))
2470                 if 'hide-value' in metadata:
2471                     return True
2472 
2473         return False
2474 
2475     def add_directive_header(self, sig: str) -> None:
2476         super().add_directive_header(sig)
2477         sourcename = self.get_sourcename()
2478         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
2479             pass
2480         elif self.options.annotation:
2481             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2482         else:
2483             # obtain type annotation for this attribute
2484             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
2485             if self.objpath[-1] in annotations:
2486                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2487                 self.add_line('   :type: ' + objrepr, sourcename)
2488 
2489             try:
2490                 if self.options.no_value or self.should_suppress_value_header():
2491                     pass
2492                 else:
2493                     objrepr = object_description(self.object)
2494                     self.add_line('   :value: ' + objrepr, sourcename)
2495             except ValueError:
2496                 pass
2497 
2498     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:
2499         for cls in inspect.getmro(parent):
2500             try:
2501                 module = safe_getattr(cls, '__module__')
2502                 qualname = safe_getattr(cls, '__qualname__')
2503 
2504                 analyzer = ModuleAnalyzer.for_module(module)
2505                 analyzer.analyze()
2506                 if qualname and self.objpath:
2507                     key = (qualname, attrname)
2508                     if key in analyzer.attr_docs:
2509                         return list(analyzer.attr_docs[key])
2510             except (AttributeError, PycodeError):
2511                 pass
2512 
2513         return None
2514 
2515     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2516         # Check the attribute has a docstring-comment
2517         comment = self.get_attribute_comment(self.parent, self.objpath[-1])
2518         if comment:
2519             return [comment]
2520 
2521         try:
2522             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2523             # a docstring from the value which descriptor returns unexpectedly.
2524             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2525             orig = self.config.autodoc_inherit_docstrings
2526             self.config.autodoc_inherit_docstrings = False  # type: ignore
2527             return super().get_doc(encoding, ignore)
2528         finally:
2529             self.config.autodoc_inherit_docstrings = orig  # type: ignore
2530 
2531     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
2532                     ) -> None:
2533         # Disable analyzing attribute comment on Documenter.add_content() to control it on
2534         # AttributeDocumenter.add_content()
2535         self.analyzer = None
2536 
2537         if more_content is None:
2538             more_content = StringList()
2539         self.update_content(more_content)
2540         super().add_content(more_content, no_docstring)
2541 
2542 
2543 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2544     """
2545     Specialized Documenter subclass for properties.
2546     """
2547     objtype = 'property'
2548     directivetype = 'method'
2549     member_order = 60
2550 
2551     # before AttributeDocumenter
2552     priority = AttributeDocumenter.priority + 1
2553 
2554     @classmethod
2555     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2556                             ) -> bool:
2557         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2558 
2559     def document_members(self, all_members: bool = False) -> None:
2560         pass
2561 
2562     def get_real_modname(self) -> str:
2563         return self.get_attr(self.parent or self.object, '__module__', None) \
2564             or self.modname
2565 
2566     def add_directive_header(self, sig: str) -> None:
2567         super().add_directive_header(sig)
2568         sourcename = self.get_sourcename()
2569         if inspect.isabstractmethod(self.object):
2570             self.add_line('   :abstractmethod:', sourcename)
2571         self.add_line('   :property:', sourcename)
2572 
2573 
2574 class NewTypeAttributeDocumenter(AttributeDocumenter):
2575     """
2576     Specialized Documenter subclass for NewTypes.
2577 
2578     Note: This must be invoked before MethodDocumenter because NewType is a kind of
2579     function object.
2580     """
2581 
2582     objtype = 'newvarattribute'
2583     directivetype = 'attribute'
2584     priority = MethodDocumenter.priority + 1
2585 
2586     @classmethod
2587     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2588                             ) -> bool:
2589         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)
2590 
2591 
2592 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2593     """Returns registered Documenter classes"""
2594     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2595     return app.registry.documenters
2596 
2597 
2598 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2599     """Alternative getattr() for types"""
2600     for typ, func in app.registry.autodoc_attrgettrs.items():
2601         if isinstance(obj, typ):
2602             return func(obj, name, *defargs)
2603 
2604     return safe_getattr(obj, name, *defargs)
2605 
2606 
2607 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2608     if config.autodoc_member_order == 'alphabetic':
2609         # RemovedInSphinx50Warning
2610         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2611                           'instead of "alphabetic". Please update your setting.'))
2612         config.autodoc_member_order = 'alphabetical'  # type: ignore
2613 
2614 
2615 # for compatibility
2616 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA
2617 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA
2618 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA
2619 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA
2620 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA
2621 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA
2622 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA
2623 
2624 
2625 def setup(app: Sphinx) -> Dict[str, Any]:
2626     app.add_autodocumenter(ModuleDocumenter)
2627     app.add_autodocumenter(ClassDocumenter)
2628     app.add_autodocumenter(ExceptionDocumenter)
2629     app.add_autodocumenter(DataDocumenter)
2630     app.add_autodocumenter(NewTypeDataDocumenter)
2631     app.add_autodocumenter(FunctionDocumenter)
2632     app.add_autodocumenter(DecoratorDocumenter)
2633     app.add_autodocumenter(MethodDocumenter)
2634     app.add_autodocumenter(AttributeDocumenter)
2635     app.add_autodocumenter(PropertyDocumenter)
2636     app.add_autodocumenter(NewTypeAttributeDocumenter)
2637 
2638     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2639     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2640                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2641     app.add_config_value('autodoc_default_options', {}, True)
2642     app.add_config_value('autodoc_docstring_signature', True, True)
2643     app.add_config_value('autodoc_mock_imports', [], True)
2644     app.add_config_value('autodoc_typehints', "signature", True,
2645                          ENUM("signature", "description", "none"))
2646     app.add_config_value('autodoc_type_aliases', {}, True)
2647     app.add_config_value('autodoc_warningiserror', True, True)
2648     app.add_config_value('autodoc_inherit_docstrings', True, True)
2649     app.add_event('autodoc-before-process-signature')
2650     app.add_event('autodoc-process-docstring')
2651     app.add_event('autodoc-process-signature')
2652     app.add_event('autodoc-skip-member')
2653 
2654     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2655 
2656     app.setup_extension('sphinx.ext.autodoc.type_comment')
2657     app.setup_extension('sphinx.ext.autodoc.typehints')
2658 
2659     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>The code within this file that processes inherited class members for documentation should be updated to ensure that members which are only annotated with type hints and potentially documented with special comment docstrings (`#: docstring`) are recognized as documented. This involves adjusting the logic that determines whether a member is documented to account not only for explicit docstrings but also for type annotations and inline comments considered as docstrings. The modification should retain all existing functionality, including the ability to recognize explicitly documented members, while extending the recognition to annotated only members. This fix should ensure compatibility with the expected Sphinx behavior, where inherited members that are annotated should be automatically documented without requiring the `:undoc-members:` option.</intended_behavior>]
2025-10-17 19:14:09.463 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import re
14 import warnings
15 from inspect import Parameter, Signature
16 from types import ModuleType
17 from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,
18                     TypeVar, Union)
19 
20 from docutils.statemachine import StringList
21 
22 import sphinx
23 from sphinx.application import Sphinx
24 from sphinx.config import ENUM, Config
25 from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,
26                                 RemovedInSphinx60Warning)
27 from sphinx.environment import BuildEnvironment
28 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,
29                                          import_object)
30 from sphinx.ext.autodoc.mock import ismock, mock, undecorate
31 from sphinx.locale import _, __
32 from sphinx.pycode import ModuleAnalyzer, PycodeError
33 from sphinx.util import inspect, logging
34 from sphinx.util.docstrings import extract_metadata, prepare_docstring
35 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,
36                                  stringify_signature)
37 from sphinx.util.typing import get_type_hints, restify
38 from sphinx.util.typing import stringify as stringify_typehint
39 
40 if False:
41     # For type annotation
42     from typing import Type  # NOQA # for python3.5.1
43 
44     from sphinx.ext.autodoc.directive import DocumenterBridge
45 
46 
47 logger = logging.getLogger(__name__)
48 
49 
50 # This type isn't exposed directly in any modules, but can be found
51 # here in most Python versions
52 MethodDescriptorType = type(type.__subclasses__)
53 
54 
55 #: extended signature RE: with explicit module name separated by ::
56 py_ext_sig_re = re.compile(
57     r'''^ ([\w.]+::)?            # explicit module name
58           ([\w.]+\.)?            # module and/or class name(s)
59           (\w+)  \s*             # thing name
60           (?: \((.*)\)           # optional: arguments
61            (?:\s* -> \s* (.*))?  #           return annotation
62           )? $                   # and nothing more
63           ''', re.VERBOSE)
64 special_member_re = re.compile(r'^__\S+__$')
65 
66 
67 def identity(x: Any) -> Any:
68     return x
69 
70 
71 class _All:
72     """A special value for :*-members: that matches to any member."""
73 
74     def __contains__(self, item: Any) -> bool:
75         return True
76 
77 
78 class _Empty:
79     """A special value for :exclude-members: that never matches to any member."""
80 
81     def __contains__(self, item: Any) -> bool:
82         return False
83 
84 
85 ALL = _All()
86 EMPTY = _Empty()
87 UNINITIALIZED_ATTR = object()
88 INSTANCEATTR = object()
89 SLOTSATTR = object()
90 
91 
92 def members_option(arg: Any) -> Union[object, List[str]]:
93     """Used to convert the :members: option to auto directives."""
94     if arg in (None, True):
95         return ALL
96     elif arg is False:
97         return None
98     else:
99         return [x.strip() for x in arg.split(',') if x.strip()]
100 
101 
102 def members_set_option(arg: Any) -> Union[object, Set[str]]:
103     """Used to convert the :members: option to auto directives."""
104     warnings.warn("members_set_option() is deprecated.",
105                   RemovedInSphinx50Warning, stacklevel=2)
106     if arg is None:
107         return ALL
108     return {x.strip() for x in arg.split(',') if x.strip()}
109 
110 
111 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
112     """Used to convert the :exclude-members: option."""
113     if arg in (None, True):
114         return EMPTY
115     return {x.strip() for x in arg.split(',') if x.strip()}
116 
117 
118 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
119     """Used to convert the :members: option to auto directives."""
120     if arg in (None, True):
121         return 'object'
122     else:
123         return arg
124 
125 
126 def member_order_option(arg: Any) -> Optional[str]:
127     """Used to convert the :members: option to auto directives."""
128     if arg in (None, True):
129         return None
130     elif arg in ('alphabetical', 'bysource', 'groupwise'):
131         return arg
132     else:
133         raise ValueError(__('invalid value for member-order option: %s') % arg)
134 
135 
136 SUPPRESS = object()
137 
138 
139 def annotation_option(arg: Any) -> Any:
140     if arg in (None, True):
141         # suppress showing the representation of the object
142         return SUPPRESS
143     else:
144         return arg
145 
146 
147 def bool_option(arg: Any) -> bool:
148     """Used to convert flag options to auto directives.  (Instead of
149     directives.flag(), which returns None).
150     """
151     return True
152 
153 
154 def merge_special_members_option(options: Dict) -> None:
155     """Merge :special-members: option to :members: option."""
156     warnings.warn("merge_special_members_option() is deprecated.",
157                   RemovedInSphinx50Warning, stacklevel=2)
158     if 'special-members' in options and options['special-members'] is not ALL:
159         if options.get('members') is ALL:
160             pass
161         elif options.get('members'):
162             for member in options['special-members']:
163                 if member not in options['members']:
164                     options['members'].append(member)
165         else:
166             options['members'] = options['special-members']
167 
168 
169 def merge_members_option(options: Dict) -> None:
170     """Merge :*-members: option to the :members: option."""
171     if options.get('members') is ALL:
172         # merging is not needed when members: ALL
173         return
174 
175     members = options.setdefault('members', [])
176     for key in {'private-members', 'special-members'}:
177         if key in options and options[key] not in (ALL, None):
178             for member in options[key]:
179                 if member not in members:
180                     members.append(member)
181 
182 
183 # Some useful event listener factories for autodoc-process-docstring.
184 
185 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
186     """Return a listener that removes the first *pre* and last *post*
187     lines of every docstring.  If *what* is a sequence of strings,
188     only docstrings of a type in *what* will be processed.
189 
190     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
191 
192        from sphinx.ext.autodoc import cut_lines
193        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
194 
195     This can (and should) be used in place of :confval:`automodule_skip_lines`.
196     """
197     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
198                 ) -> None:
199         if what and what_ not in what:
200             return
201         del lines[:pre]
202         if post:
203             # remove one trailing blank line.
204             if lines and not lines[-1]:
205                 lines.pop(-1)
206             del lines[-post:]
207         # make sure there is a blank line at the end
208         if lines and lines[-1]:
209             lines.append('')
210     return process
211 
212 
213 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
214             exclude: bool = False) -> Callable:
215     """Return a listener that either keeps, or if *exclude* is True excludes,
216     lines between lines that match the *marker* regular expression.  If no line
217     matches, the resulting docstring would be empty, so no change will be made
218     unless *keepempty* is true.
219 
220     If *what* is a sequence of strings, only docstrings of a type in *what* will
221     be processed.
222     """
223     marker_re = re.compile(marker)
224 
225     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
226                 ) -> None:
227         if what and what_ not in what:
228             return
229         deleted = 0
230         delete = not exclude
231         orig_lines = lines[:]
232         for i, line in enumerate(orig_lines):
233             if delete:
234                 lines.pop(i - deleted)
235                 deleted += 1
236             if marker_re.match(line):
237                 delete = not delete
238                 if delete:
239                     lines.pop(i - deleted)
240                     deleted += 1
241         if not lines and not keepempty:
242             lines[:] = orig_lines
243         # make sure there is a blank line at the end
244         if lines and lines[-1]:
245             lines.append('')
246     return process
247 
248 
249 # This class is used only in ``sphinx.ext.autodoc.directive``,
250 # But we define this class here to keep compatibility (see #4538)
251 class Options(dict):
252     """A dict/attribute hybrid that returns None on nonexisting keys."""
253     def __getattr__(self, name: str) -> Any:
254         try:
255             return self[name.replace('_', '-')]
256         except KeyError:
257             return None
258 
259 
260 class ObjectMember(tuple):
261     """A member of object.
262 
263     This is used for the result of `Documenter.get_object_members()` to
264     represent each member of the object.
265 
266     .. Note::
267 
268        An instance of this class behaves as a tuple of (name, object)
269        for compatibility to old Sphinx.  The behavior will be dropped
270        in the future.  Therefore extensions should not use the tuple
271        interface.
272     """
273 
274     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:
275         return super().__new__(cls, (name, obj))  # type: ignore
276 
277     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,
278                  class_: Any = None, skipped: bool = False) -> None:
279         self.__name__ = name
280         self.object = obj
281         self.docstring = docstring
282         self.skipped = skipped
283         self.class_ = class_
284 
285 
286 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]
287 
288 
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 if ismock(self.object):
426                     self.object = undecorate(self.object)
427                 return True
428             except ImportError as exc:
429                 if raiseerror:
430                     raise
431                 else:
432                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
433                     self.env.note_reread()
434                     return False
435 
436     def get_real_modname(self) -> str:
437         """Get the real module name of an object to document.
438 
439         It can differ from the name of the module through which the object was
440         imported.
441         """
442         return self.get_attr(self.object, '__module__', None) or self.modname
443 
444     def check_module(self) -> bool:
445         """Check if *self.object* is really defined in the module given by
446         *self.modname*.
447         """
448         if self.options.imported_members:
449             return True
450 
451         subject = inspect.unpartial(self.object)
452         modname = self.get_attr(subject, '__module__', None)
453         if modname and modname != self.modname:
454             return False
455         return True
456 
457     def format_args(self, **kwargs: Any) -> str:
458         """Format the argument signature of *self.object*.
459 
460         Should return None if the object does not have a signature.
461         """
462         return None
463 
464     def format_name(self) -> str:
465         """Format the name of *self.object*.
466 
467         This normally should be something that can be parsed by the generated
468         directive, but doesn't need to be (Sphinx will display it unparsed
469         then).
470         """
471         # normally the name doesn't contain the module (except for module
472         # directives of course)
473         return '.'.join(self.objpath) or self.modname
474 
475     def _call_format_args(self, **kwargs: Any) -> str:
476         if kwargs:
477             try:
478                 return self.format_args(**kwargs)
479             except TypeError:
480                 # avoid chaining exceptions, by putting nothing here
481                 pass
482 
483         # retry without arguments for old documenters
484         return self.format_args()
485 
486     def format_signature(self, **kwargs: Any) -> str:
487         """Format the signature (arguments and return annotation) of the object.
488 
489         Let the user process it via the ``autodoc-process-signature`` event.
490         """
491         if self.args is not None:
492             # signature given explicitly
493             args = "(%s)" % self.args
494             retann = self.retann
495         else:
496             # try to introspect the signature
497             try:
498                 retann = None
499                 args = self._call_format_args(**kwargs)
500                 if args:
501                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
502                     if matched:
503                         args = matched.group(1)
504                         retann = matched.group(2)
505             except Exception as exc:
506                 logger.warning(__('error while formatting arguments for %s: %s'),
507                                self.fullname, exc, type='autodoc')
508                 args = None
509 
510         result = self.env.events.emit_firstresult('autodoc-process-signature',
511                                                   self.objtype, self.fullname,
512                                                   self.object, self.options, args, retann)
513         if result:
514             args, retann = result
515 
516         if args is not None:
517             return args + ((' -> %s' % retann) if retann else '')
518         else:
519             return ''
520 
521     def add_directive_header(self, sig: str) -> None:
522         """Add the directive header and options to the generated content."""
523         domain = getattr(self, 'domain', 'py')
524         directive = getattr(self, 'directivetype', self.objtype)
525         name = self.format_name()
526         sourcename = self.get_sourcename()
527 
528         # one signature per line, indented by column
529         prefix = '.. %s:%s:: ' % (domain, directive)
530         for i, sig_line in enumerate(sig.split("\n")):
531             self.add_line('%s%s%s' % (prefix, name, sig_line),
532                           sourcename)
533             if i == 0:
534                 prefix = " " * len(prefix)
535 
536         if self.options.noindex:
537             self.add_line('   :noindex:', sourcename)
538         if self.objpath:
539             # Be explicit about the module, this is necessary since .. class::
540             # etc. don't support a prepended module name
541             self.add_line('   :module: %s' % self.modname, sourcename)
542 
543     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
544         """Decode and return lines of the docstring(s) for the object.
545 
546         When it returns None value, autodoc-process-docstring will not be called for this
547         object.
548         """
549         if encoding is not None:
550             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
551                           % self.__class__.__name__,
552                           RemovedInSphinx40Warning, stacklevel=2)
553         if ignore is not None:
554             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
555                           % self.__class__.__name__,
556                           RemovedInSphinx50Warning, stacklevel=2)
557         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
558                            self.parent, self.object_name)
559         if docstring:
560             tab_width = self.directive.state.document.settings.tab_width
561             return [prepare_docstring(docstring, ignore, tab_width)]
562         return []
563 
564     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
565         """Let the user process the docstrings before adding them."""
566         for docstringlines in docstrings:
567             if self.env.app:
568                 # let extensions preprocess docstrings
569                 self.env.app.emit('autodoc-process-docstring',
570                                   self.objtype, self.fullname, self.object,
571                                   self.options, docstringlines)
572 
573                 if docstringlines and docstringlines[-1] != '':
574                     # append a blank line to the end of the docstring
575                     docstringlines.append('')
576 
577             yield from docstringlines
578 
579     def get_sourcename(self) -> str:
580         if (getattr(self.object, '__module__', None) and
581                 getattr(self.object, '__qualname__', None)):
582             # Get the correct location of docstring from self.object
583             # to support inherited methods
584             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
585         else:
586             fullname = self.fullname
587 
588         if self.analyzer:
589             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
590         else:
591             return 'docstring of %s' % fullname
592 
593     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
594                     ) -> None:
595         """Add content from docstrings, attribute documentation and user."""
596         if no_docstring:
597             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
598                           % self.__class__.__name__,
599                           RemovedInSphinx50Warning, stacklevel=2)
600 
601         # set sourcename and add content from attribute documentation
602         sourcename = self.get_sourcename()
603         if self.analyzer:
604             attr_docs = self.analyzer.find_attr_docs()
605             if self.objpath:
606                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
607                 if key in attr_docs:
608                     no_docstring = True
609                     # make a copy of docstring for attributes to avoid cache
610                     # the change of autodoc-process-docstring event.
611                     docstrings = [list(attr_docs[key])]
612 
613                     for i, line in enumerate(self.process_doc(docstrings)):
614                         self.add_line(line, sourcename, i)
615 
616         # add content from docstrings
617         if not no_docstring:
618             docstrings = self.get_doc()
619             if docstrings is None:
620                 # Do not call autodoc-process-docstring on get_doc() returns None.
621                 pass
622             else:
623                 if not docstrings:
624                     # append at least a dummy docstring, so that the event
625                     # autodoc-process-docstring is fired and can add some
626                     # content if desired
627                     docstrings.append([])
628                 for i, line in enumerate(self.process_doc(docstrings)):
629                     self.add_line(line, sourcename, i)
630 
631         # add additional content (e.g. from document), if present
632         if more_content:
633             for line, src in zip(more_content.data, more_content.items):
634                 self.add_line(line, src[0], src[1])
635 
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]
663 
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret
813 
814     def document_members(self, all_members: bool = False) -> None:
815         """Generate reST for member documentation.
816 
817         If *all_members* is True, do all members, else those given by
818         *self.options.members*.
819         """
820         # set current namespace for finding members
821         self.env.temp_data['autodoc:module'] = self.modname
822         if self.objpath:
823             self.env.temp_data['autodoc:class'] = self.objpath[0]
824 
825         want_all = all_members or self.options.inherited_members or \
826             self.options.members is ALL
827         # find out which members are documentable
828         members_check_module, members = self.get_object_members(want_all)
829 
830         # document non-skipped members
831         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
832         for (mname, member, isattr) in self.filter_members(members, want_all):
833             classes = [cls for cls in self.documenters.values()
834                        if cls.can_document_member(member, mname, isattr, self)]
835             if not classes:
836                 # don't know how to document this member
837                 continue
838             # prefer the documenter with the highest priority
839             classes.sort(key=lambda cls: cls.priority)
840             # give explicitly separated module name, so that members
841             # of inner classes can be documented
842             full_mname = self.modname + '::' + \
843                 '.'.join(self.objpath + [mname])
844             documenter = classes[-1](self.directive, full_mname, self.indent)
845             memberdocumenters.append((documenter, isattr))
846 
847         member_order = self.options.member_order or self.config.autodoc_member_order
848         memberdocumenters = self.sort_members(memberdocumenters, member_order)
849 
850         for documenter, isattr in memberdocumenters:
851             documenter.generate(
852                 all_members=True, real_modname=self.real_modname,
853                 check_module=members_check_module and not isattr)
854 
855         # reset current objects
856         self.env.temp_data['autodoc:module'] = None
857         self.env.temp_data['autodoc:class'] = None
858 
859     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
860                      order: str) -> List[Tuple["Documenter", bool]]:
861         """Sort the given member list."""
862         if order == 'groupwise':
863             # sort by group; alphabetically within groups
864             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
865         elif order == 'bysource':
866             if self.analyzer:
867                 # sort by source order, by virtue of the module analyzer
868                 tagorder = self.analyzer.tagorder
869 
870                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
871                     fullname = entry[0].name.split('::')[1]
872                     return tagorder.get(fullname, len(tagorder))
873                 documenters.sort(key=keyfunc)
874             else:
875                 # Assume that member discovery order matches source order.
876                 # This is a reasonable assumption in Python 3.6 and up, where
877                 # module.__dict__ is insertion-ordered.
878                 pass
879         else:  # alphabetical
880             documenters.sort(key=lambda e: e[0].name)
881 
882         return documenters
883 
884     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
885                  check_module: bool = False, all_members: bool = False) -> None:
886         """Generate reST for the object given by *self.name*, and possibly for
887         its members.
888 
889         If *more_content* is given, include that content. If *real_modname* is
890         given, use that module name to find attribute docs. If *check_module* is
891         True, only generate if the object is defined in the module name it is
892         imported from. If *all_members* is True, document all members.
893         """
894         if not self.parse_name():
895             # need a module to import
896             logger.warning(
897                 __('don\'t know which module to import for autodocumenting '
898                    '%r (try placing a "module" or "currentmodule" directive '
899                    'in the document, or giving an explicit module name)') %
900                 self.name, type='autodoc')
901             return
902 
903         # now, import the module and get object to document
904         if not self.import_object():
905             return
906 
907         # If there is no real module defined, figure out which to use.
908         # The real module is used in the module analyzer to look up the module
909         # where the attribute documentation would actually be found in.
910         # This is used for situations where you have a module that collects the
911         # functions and classes of internal submodules.
912         guess_modname = self.get_real_modname()
913         self.real_modname = real_modname or guess_modname
914 
915         # try to also get a source code analyzer for attribute docs
916         try:
917             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
918             # parse right now, to get PycodeErrors on parsing (results will
919             # be cached anyway)
920             self.analyzer.find_attr_docs()
921         except PycodeError as exc:
922             logger.debug('[autodoc] module analyzer failed: %s', exc)
923             # no source file -- e.g. for builtin and C modules
924             self.analyzer = None
925             # at least add the module.__file__ as a dependency
926             if hasattr(self.module, '__file__') and self.module.__file__:
927                 self.directive.filename_set.add(self.module.__file__)
928         else:
929             self.directive.filename_set.add(self.analyzer.srcname)
930 
931         if self.real_modname != guess_modname:
932             # Add module to dependency list if target object is defined in other module.
933             try:
934                 analyzer = ModuleAnalyzer.for_module(guess_modname)
935                 self.directive.filename_set.add(analyzer.srcname)
936             except PycodeError:
937                 pass
938 
939         # check __module__ of object (for members not given explicitly)
940         if check_module:
941             if not self.check_module():
942                 return
943 
944         sourcename = self.get_sourcename()
945 
946         # make sure that the result starts with an empty line.  This is
947         # necessary for some situations where another directive preprocesses
948         # reST and no starting newline is present
949         self.add_line('', sourcename)
950 
951         # format the object's signature, if any
952         try:
953             sig = self.format_signature()
954         except Exception as exc:
955             logger.warning(__('error while formatting signature for %s: %s'),
956                            self.fullname, exc, type='autodoc')
957             return
958 
959         # generate the directive header and options, if applicable
960         self.add_directive_header(sig)
961         self.add_line('', sourcename)
962 
963         # e.g. the module directive doesn't have content
964         self.indent += self.content_indent
965 
966         # add all content (from docstrings, attribute docs etc.)
967         self.add_content(more_content)
968 
969         # document members, if possible
970         self.document_members(all_members)
971 
972 
973 class ModuleDocumenter(Documenter):
974     """
975     Specialized Documenter subclass for modules.
976     """
977     objtype = 'module'
978     content_indent = ''
979     titles_allowed = True
980 
981     option_spec = {
982         'members': members_option, 'undoc-members': bool_option,
983         'noindex': bool_option, 'inherited-members': inherited_members_option,
984         'show-inheritance': bool_option, 'synopsis': identity,
985         'platform': identity, 'deprecated': bool_option,
986         'member-order': member_order_option, 'exclude-members': exclude_members_option,
987         'private-members': members_option, 'special-members': members_option,
988         'imported-members': bool_option, 'ignore-module-all': bool_option
989     }  # type: Dict[str, Callable]
990 
991     def __init__(self, *args: Any) -> None:
992         super().__init__(*args)
993         merge_members_option(self.options)
994         self.__all__ = None  # type: Optional[Sequence[str]]
995 
996     @classmethod
997     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
998                             ) -> bool:
999         # don't document submodules automatically
1000         return False
1001 
1002     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1003                      ) -> Tuple[str, List[str]]:
1004         if modname is not None:
1005             logger.warning(__('"::" in automodule name doesn\'t make sense'),
1006                            type='autodoc')
1007         return (path or '') + base, []
1008 
1009     def parse_name(self) -> bool:
1010         ret = super().parse_name()
1011         if self.args or self.retann:
1012             logger.warning(__('signature arguments or return annotation '
1013                               'given for automodule %s') % self.fullname,
1014                            type='autodoc')
1015         return ret
1016 
1017     def import_object(self, raiseerror: bool = False) -> bool:
1018         ret = super().import_object(raiseerror)
1019 
1020         try:
1021             if not self.options.ignore_module_all:
1022                 self.__all__ = inspect.getall(self.object)
1023         except ValueError as exc:
1024             # invalid __all__ found.
1025             logger.warning(__('__all__ should be a list of strings, not %r '
1026                               '(in module %s) -- ignoring __all__') %
1027                            (exc.args[0], self.fullname), type='autodoc')
1028 
1029         return ret
1030 
1031     def add_directive_header(self, sig: str) -> None:
1032         Documenter.add_directive_header(self, sig)
1033 
1034         sourcename = self.get_sourcename()
1035 
1036         # add some module-specific options
1037         if self.options.synopsis:
1038             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
1039         if self.options.platform:
1040             self.add_line('   :platform: ' + self.options.platform, sourcename)
1041         if self.options.deprecated:
1042             self.add_line('   :deprecated:', sourcename)
1043 
1044     def get_module_members(self) -> Dict[str, ObjectMember]:
1045         """Get members of target module."""
1046         if self.analyzer:
1047             attr_docs = self.analyzer.attr_docs
1048         else:
1049             attr_docs = {}
1050 
1051         members = {}  # type: Dict[str, ObjectMember]
1052         for name in dir(self.object):
1053             try:
1054                 value = safe_getattr(self.object, name, None)
1055                 if ismock(value):
1056                     value = undecorate(value)
1057                 docstring = attr_docs.get(('', name), [])
1058                 members[name] = ObjectMember(name, value, docstring="\n".join(docstring))
1059             except AttributeError:
1060                 continue
1061 
1062         # annotation only member (ex. attr: int)
1063         for name in inspect.getannotations(self.object):
1064             if name not in members:
1065                 docstring = attr_docs.get(('', name), [])
1066                 members[name] = ObjectMember(name, INSTANCEATTR,
1067                                              docstring="\n".join(docstring))
1068 
1069         return members
1070 
1071     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1072         members = self.get_module_members()
1073         if want_all:
1074             if self.__all__ is None:
1075                 # for implicit module members, check __module__ to avoid
1076                 # documenting imported objects
1077                 return True, list(members.values())
1078             else:
1079                 for member in members.values():
1080                     if member.__name__ not in self.__all__:
1081                         member.skipped = True
1082 
1083                 return False, list(members.values())
1084         else:
1085             memberlist = self.options.members or []
1086             ret = []
1087             for name in memberlist:
1088                 if name in members:
1089                     ret.append(members[name])
1090                 else:
1091                     logger.warning(__('missing attribute mentioned in :members: option: '
1092                                       'module %s, attribute %s') %
1093                                    (safe_getattr(self.object, '__name__', '???'), name),
1094                                    type='autodoc')
1095             return False, ret
1096 
1097     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1098                      order: str) -> List[Tuple["Documenter", bool]]:
1099         if order == 'bysource' and self.__all__:
1100             # Sort alphabetically first (for members not listed on the __all__)
1101             documenters.sort(key=lambda e: e[0].name)
1102 
1103             # Sort by __all__
1104             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1105                 name = entry[0].name.split('::')[1]
1106                 if name in self.__all__:
1107                     return self.__all__.index(name)
1108                 else:
1109                     return len(self.__all__)
1110             documenters.sort(key=keyfunc)
1111 
1112             return documenters
1113         else:
1114             return super().sort_members(documenters, order)
1115 
1116 
1117 class ModuleLevelDocumenter(Documenter):
1118     """
1119     Specialized Documenter subclass for objects on module level (functions,
1120     classes, data/constants).
1121     """
1122     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1123                      ) -> Tuple[str, List[str]]:
1124         if modname is None:
1125             if path:
1126                 modname = path.rstrip('.')
1127             else:
1128                 # if documenting a toplevel object without explicit module,
1129                 # it can be contained in another auto directive ...
1130                 modname = self.env.temp_data.get('autodoc:module')
1131                 # ... or in the scope of a module directive
1132                 if not modname:
1133                     modname = self.env.ref_context.get('py:module')
1134                 # ... else, it stays None, which means invalid
1135         return modname, parents + [base]
1136 
1137 
1138 class ClassLevelDocumenter(Documenter):
1139     """
1140     Specialized Documenter subclass for objects on class level (methods,
1141     attributes).
1142     """
1143     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1144                      ) -> Tuple[str, List[str]]:
1145         if modname is None:
1146             if path:
1147                 mod_cls = path.rstrip('.')
1148             else:
1149                 mod_cls = None
1150                 # if documenting a class-level object without path,
1151                 # there must be a current class, either from a parent
1152                 # auto directive ...
1153                 mod_cls = self.env.temp_data.get('autodoc:class')
1154                 # ... or from a class directive
1155                 if mod_cls is None:
1156                     mod_cls = self.env.ref_context.get('py:class')
1157                 # ... if still None, there's no way to know
1158                 if mod_cls is None:
1159                     return None, []
1160             modname, sep, cls = mod_cls.rpartition('.')
1161             parents = [cls]
1162             # if the module name is still missing, get it like above
1163             if not modname:
1164                 modname = self.env.temp_data.get('autodoc:module')
1165             if not modname:
1166                 modname = self.env.ref_context.get('py:module')
1167             # ... else, it stays None, which means invalid
1168         return modname, parents + [base]
1169 
1170 
1171 class DocstringSignatureMixin:
1172     """
1173     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1174     feature of reading the signature from the docstring.
1175     """
1176     _new_docstrings = None  # type: List[List[str]]
1177     _signatures = None      # type: List[str]
1178 
1179     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1180         if encoding is not None:
1181             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1182                           "deprecated." % self.__class__.__name__,
1183                           RemovedInSphinx40Warning, stacklevel=2)
1184 
1185         # candidates of the object name
1186         valid_names = [self.objpath[-1]]  # type: ignore
1187         if isinstance(self, ClassDocumenter):
1188             valid_names.append('__init__')
1189             if hasattr(self.object, '__mro__'):
1190                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1191 
1192         docstrings = self.get_doc()
1193         if docstrings is None:
1194             return None, None
1195         self._new_docstrings = docstrings[:]
1196         self._signatures = []
1197         result = None
1198         for i, doclines in enumerate(docstrings):
1199             for j, line in enumerate(doclines):
1200                 if not line:
1201                     # no lines in docstring, no match
1202                     break
1203 
1204                 if line.endswith('\\'):
1205                     multiline = True
1206                     line = line.rstrip('\\').rstrip()
1207                 else:
1208                     multiline = False
1209 
1210                 # match first line of docstring against signature RE
1211                 match = py_ext_sig_re.match(line)
1212                 if not match:
1213                     continue
1214                 exmod, path, base, args, retann = match.groups()
1215 
1216                 # the base name must match ours
1217                 if base not in valid_names:
1218                     continue
1219 
1220                 # re-prepare docstring to ignore more leading indentation
1221                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1222                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1223                                                             tabsize=tab_width)
1224 
1225                 if result is None:
1226                     # first signature
1227                     result = args, retann
1228                 else:
1229                     # subsequent signatures
1230                     self._signatures.append("(%s) -> %s" % (args, retann))
1231 
1232                 if multiline:
1233                     # the signature have multiple signatures on docstring
1234                     continue
1235                 else:
1236                     # don't look any further
1237                     break
1238 
1239             if result:
1240                 # finish the loop when signature found
1241                 break
1242 
1243         return result
1244 
1245     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1246         if encoding is not None:
1247             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1248                           % self.__class__.__name__,
1249                           RemovedInSphinx40Warning, stacklevel=2)
1250         if self._new_docstrings is not None:
1251             return self._new_docstrings
1252         return super().get_doc(None, ignore)  # type: ignore
1253 
1254     def format_signature(self, **kwargs: Any) -> str:
1255         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1256             # only act if a signature is not explicitly given already, and if
1257             # the feature is enabled
1258             result = self._find_signature()
1259             if result is not None:
1260                 self.args, self.retann = result
1261         sig = super().format_signature(**kwargs)  # type: ignore
1262         if self._signatures:
1263             return "\n".join([sig] + self._signatures)
1264         else:
1265             return sig
1266 
1267 
1268 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1269     """
1270     Mixin for AttributeDocumenter to provide the
1271     feature of stripping any function signature from the docstring.
1272     """
1273     def format_signature(self, **kwargs: Any) -> str:
1274         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore
1275             # only act if a signature is not explicitly given already, and if
1276             # the feature is enabled
1277             result = self._find_signature()
1278             if result is not None:
1279                 # Discarding _args is a only difference with
1280                 # DocstringSignatureMixin.format_signature.
1281                 # Documenter.format_signature use self.args value to format.
1282                 _args, self.retann = result
1283         return super().format_signature(**kwargs)
1284 
1285 
1286 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1287     """
1288     Specialized Documenter subclass for functions.
1289     """
1290     objtype = 'function'
1291     member_order = 30
1292 
1293     @classmethod
1294     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1295                             ) -> bool:
1296         # supports functions, builtins and bound methods exported at the module level
1297         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1298                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1299 
1300     def format_args(self, **kwargs: Any) -> str:
1301         if self.config.autodoc_typehints in ('none', 'description'):
1302             kwargs.setdefault('show_annotation', False)
1303 
1304         try:
1305             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1306             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)
1307             args = stringify_signature(sig, **kwargs)
1308         except TypeError as exc:
1309             logger.warning(__("Failed to get a function signature for %s: %s"),
1310                            self.fullname, exc)
1311             return None
1312         except ValueError:
1313             args = ''
1314 
1315         if self.config.strip_signature_backslash:
1316             # escape backslashes for reST
1317             args = args.replace('\\', '\\\\')
1318         return args
1319 
1320     def document_members(self, all_members: bool = False) -> None:
1321         pass
1322 
1323     def add_directive_header(self, sig: str) -> None:
1324         sourcename = self.get_sourcename()
1325         super().add_directive_header(sig)
1326 
1327         if inspect.iscoroutinefunction(self.object):
1328             self.add_line('   :async:', sourcename)
1329 
1330     def format_signature(self, **kwargs: Any) -> str:
1331         sigs = []
1332         if (self.analyzer and
1333                 '.'.join(self.objpath) in self.analyzer.overloads and
1334                 self.config.autodoc_typehints == 'signature'):
1335             # Use signatures for overloaded functions instead of the implementation function.
1336             overloaded = True
1337         else:
1338             overloaded = False
1339             sig = super().format_signature(**kwargs)
1340             sigs.append(sig)
1341 
1342         if inspect.is_singledispatch_function(self.object):
1343             # append signature of singledispatch'ed functions
1344             for typ, func in self.object.registry.items():
1345                 if typ is object:
1346                     pass  # default implementation. skipped.
1347                 else:
1348                     self.annotate_to_first_argument(func, typ)
1349 
1350                     documenter = FunctionDocumenter(self.directive, '')
1351                     documenter.object = func
1352                     documenter.objpath = [None]
1353                     sigs.append(documenter.format_signature())
1354         if overloaded:
1355             actual = inspect.signature(self.object,
1356                                        type_aliases=self.config.autodoc_type_aliases)
1357             __globals__ = safe_getattr(self.object, '__globals__', {})
1358             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1359                 overload = self.merge_default_value(actual, overload)
1360                 overload = evaluate_signature(overload, __globals__,
1361                                               self.config.autodoc_type_aliases)
1362 
1363                 sig = stringify_signature(overload, **kwargs)
1364                 sigs.append(sig)
1365 
1366         return "\n".join(sigs)
1367 
1368     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
1369         """Merge default values of actual implementation to the overload variants."""
1370         parameters = list(overload.parameters.values())
1371         for i, param in enumerate(parameters):
1372             actual_param = actual.parameters.get(param.name)
1373             if actual_param and param.default == '...':
1374                 parameters[i] = param.replace(default=actual_param.default)
1375 
1376         return overload.replace(parameters=parameters)
1377 
1378     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1379         """Annotate type hint to the first argument of function if needed."""
1380         try:
1381             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
1382         except TypeError as exc:
1383             logger.warning(__("Failed to get a function signature for %s: %s"),
1384                            self.fullname, exc)
1385             return
1386         except ValueError:
1387             return
1388 
1389         if len(sig.parameters) == 0:
1390             return
1391 
1392         params = list(sig.parameters.values())
1393         if params[0].annotation is Parameter.empty:
1394             params[0] = params[0].replace(annotation=typ)
1395             try:
1396                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1397             except TypeError:
1398                 # failed to update signature (ex. built-in or extension types)
1399                 return
1400 
1401 
1402 class DecoratorDocumenter(FunctionDocumenter):
1403     """
1404     Specialized Documenter subclass for decorator functions.
1405     """
1406     objtype = 'decorator'
1407 
1408     # must be lower than FunctionDocumenter
1409     priority = -1
1410 
1411     def format_args(self, **kwargs: Any) -> Any:
1412         args = super().format_args(**kwargs)
1413         if ',' in args:
1414             return args
1415         else:
1416             return None
1417 
1418 
1419 # Types which have confusing metaclass signatures it would be best not to show.
1420 # These are listed by name, rather than storing the objects themselves, to avoid
1421 # needing to import the modules.
1422 _METACLASS_CALL_BLACKLIST = [
1423     'enum.EnumMeta.__call__',
1424 ]
1425 
1426 
1427 # Types whose __new__ signature is a pass-thru.
1428 _CLASS_NEW_BLACKLIST = [
1429     'typing.Generic.__new__',
1430 ]
1431 
1432 
1433 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1434     """
1435     Specialized Documenter subclass for classes.
1436     """
1437     objtype = 'class'
1438     member_order = 20
1439     option_spec = {
1440         'members': members_option, 'undoc-members': bool_option,
1441         'noindex': bool_option, 'inherited-members': inherited_members_option,
1442         'show-inheritance': bool_option, 'member-order': member_order_option,
1443         'exclude-members': exclude_members_option,
1444         'private-members': members_option, 'special-members': members_option,
1445     }  # type: Dict[str, Callable]
1446 
1447     _signature_class = None  # type: Any
1448     _signature_method_name = None  # type: str
1449 
1450     def __init__(self, *args: Any) -> None:
1451         super().__init__(*args)
1452         merge_members_option(self.options)
1453 
1454     @classmethod
1455     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1456                             ) -> bool:
1457         return isinstance(member, type)
1458 
1459     def import_object(self, raiseerror: bool = False) -> bool:
1460         ret = super().import_object(raiseerror)
1461         # if the class is documented under another name, document it
1462         # as data/attribute
1463         if ret:
1464             if hasattr(self.object, '__name__'):
1465                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1466             else:
1467                 self.doc_as_attr = True
1468         return ret
1469 
1470     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1471         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1472             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1473             if inspect.is_builtin_class_method(obj, attr):
1474                 return None
1475             attr = self.get_attr(obj, attr, None)
1476             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1477                 return None
1478             return attr
1479 
1480         # This sequence is copied from inspect._signature_from_callable.
1481         # ValueError means that no signature could be found, so we keep going.
1482 
1483         # First, we check the obj has a __signature__ attribute
1484         if (hasattr(self.object, '__signature__') and
1485                 isinstance(self.object.__signature__, Signature)):
1486             return None, None, self.object.__signature__
1487 
1488         # Next, let's see if it has an overloaded __call__ defined
1489         # in its metaclass
1490         call = get_user_defined_function_or_method(type(self.object), '__call__')
1491 
1492         if call is not None:
1493             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1494                 call = None
1495 
1496         if call is not None:
1497             self.env.app.emit('autodoc-before-process-signature', call, True)
1498             try:
1499                 sig = inspect.signature(call, bound_method=True,
1500                                         type_aliases=self.config.autodoc_type_aliases)
1501                 return type(self.object), '__call__', sig
1502             except ValueError:
1503                 pass
1504 
1505         # Now we check if the 'obj' class has a '__new__' method
1506         new = get_user_defined_function_or_method(self.object, '__new__')
1507 
1508         if new is not None:
1509             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1510                 new = None
1511 
1512         if new is not None:
1513             self.env.app.emit('autodoc-before-process-signature', new, True)
1514             try:
1515                 sig = inspect.signature(new, bound_method=True,
1516                                         type_aliases=self.config.autodoc_type_aliases)
1517                 return self.object, '__new__', sig
1518             except ValueError:
1519                 pass
1520 
1521         # Finally, we should have at least __init__ implemented
1522         init = get_user_defined_function_or_method(self.object, '__init__')
1523         if init is not None:
1524             self.env.app.emit('autodoc-before-process-signature', init, True)
1525             try:
1526                 sig = inspect.signature(init, bound_method=True,
1527                                         type_aliases=self.config.autodoc_type_aliases)
1528                 return self.object, '__init__', sig
1529             except ValueError:
1530                 pass
1531 
1532         # None of the attributes are user-defined, so fall back to let inspect
1533         # handle it.
1534         # We don't know the exact method that inspect.signature will read
1535         # the signature from, so just pass the object itself to our hook.
1536         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1537         try:
1538             sig = inspect.signature(self.object, bound_method=False,
1539                                     type_aliases=self.config.autodoc_type_aliases)
1540             return None, None, sig
1541         except ValueError:
1542             pass
1543 
1544         # Still no signature: happens e.g. for old-style classes
1545         # with __init__ in C and no `__text_signature__`.
1546         return None, None, None
1547 
1548     def format_args(self, **kwargs: Any) -> str:
1549         if self.config.autodoc_typehints in ('none', 'description'):
1550             kwargs.setdefault('show_annotation', False)
1551 
1552         try:
1553             self._signature_class, self._signature_method_name, sig = self._get_signature()
1554         except TypeError as exc:
1555             # __signature__ attribute contained junk
1556             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1557                            self.fullname, exc)
1558             return None
1559 
1560         if sig is None:
1561             return None
1562 
1563         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1564 
1565     def format_signature(self, **kwargs: Any) -> str:
1566         if self.doc_as_attr:
1567             return ''
1568 
1569         sig = super().format_signature()
1570         sigs = []
1571 
1572         overloads = self.get_overloaded_signatures()
1573         if overloads and self.config.autodoc_typehints == 'signature':
1574             # Use signatures for overloaded methods instead of the implementation method.
1575             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1576             __globals__ = safe_getattr(method, '__globals__', {})
1577             for overload in overloads:
1578                 overload = evaluate_signature(overload, __globals__,
1579                                               self.config.autodoc_type_aliases)
1580 
1581                 parameters = list(overload.parameters.values())
1582                 overload = overload.replace(parameters=parameters[1:],
1583                                             return_annotation=Parameter.empty)
1584                 sig = stringify_signature(overload, **kwargs)
1585                 sigs.append(sig)
1586         else:
1587             sigs.append(sig)
1588 
1589         return "\n".join(sigs)
1590 
1591     def get_overloaded_signatures(self) -> List[Signature]:
1592         if self._signature_class and self._signature_method_name:
1593             for cls in self._signature_class.__mro__:
1594                 try:
1595                     analyzer = ModuleAnalyzer.for_module(cls.__module__)
1596                     analyzer.analyze()
1597                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])
1598                     if qualname in analyzer.overloads:
1599                         return analyzer.overloads.get(qualname)
1600                     elif qualname in analyzer.tagorder:
1601                         # the constructor is defined in the class, but not overrided.
1602                         return []
1603                 except PycodeError:
1604                     pass
1605 
1606         return []
1607 
1608     def add_directive_header(self, sig: str) -> None:
1609         sourcename = self.get_sourcename()
1610 
1611         if self.doc_as_attr:
1612             self.directivetype = 'attribute'
1613         super().add_directive_header(sig)
1614 
1615         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1616             self.add_line('   :final:', sourcename)
1617 
1618         # add inheritance info, if wanted
1619         if not self.doc_as_attr and self.options.show_inheritance:
1620             sourcename = self.get_sourcename()
1621             self.add_line('', sourcename)
1622 
1623             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):
1624                 # A subclass of generic types
1625                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>
1626                 bases = [restify(cls) for cls in self.object.__orig_bases__]
1627                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1628             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):
1629                 # A normal class
1630                 bases = [restify(cls) for cls in self.object.__bases__]
1631                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)
1632 
1633     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
1634         members = get_class_members(self.object, self.objpath, self.get_attr)
1635         if not want_all:
1636             if not self.options.members:
1637                 return False, []  # type: ignore
1638             # specific members given
1639             selected = []
1640             for name in self.options.members:  # type: str
1641                 if name in members:
1642                     selected.append(members[name])
1643                 else:
1644                     logger.warning(__('missing attribute %s in object %s') %
1645                                    (name, self.fullname), type='autodoc')
1646             return False, selected
1647         elif self.options.inherited_members:
1648             return False, list(members.values())
1649         else:
1650             return False, [m for m in members.values() if m.class_ == self.object]
1651 
1652     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1653         if encoding is not None:
1654             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1655                           % self.__class__.__name__,
1656                           RemovedInSphinx40Warning, stacklevel=2)
1657         if self.doc_as_attr:
1658             # Don't show the docstring of the class when it is an alias.
1659             return None
1660 
1661         lines = getattr(self, '_new_docstrings', None)
1662         if lines is not None:
1663             return lines
1664 
1665         content = self.config.autoclass_content
1666 
1667         docstrings = []
1668         attrdocstring = self.get_attr(self.object, '__doc__', None)
1669         if attrdocstring:
1670             docstrings.append(attrdocstring)
1671 
1672         # for classes, what the "docstring" is can be controlled via a
1673         # config value; the default is only the class docstring
1674         if content in ('both', 'init'):
1675             __init__ = self.get_attr(self.object, '__init__', None)
1676             initdocstring = getdoc(__init__, self.get_attr,
1677                                    self.config.autodoc_inherit_docstrings,
1678                                    self.parent, self.object_name)
1679             # for new-style classes, no __init__ means default __init__
1680             if (initdocstring is not None and
1681                 (initdocstring == object.__init__.__doc__ or  # for pypy
1682                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1683                 initdocstring = None
1684             if not initdocstring:
1685                 # try __new__
1686                 __new__ = self.get_attr(self.object, '__new__', None)
1687                 initdocstring = getdoc(__new__, self.get_attr,
1688                                        self.config.autodoc_inherit_docstrings,
1689                                        self.parent, self.object_name)
1690                 # for new-style classes, no __new__ means default __new__
1691                 if (initdocstring is not None and
1692                     (initdocstring == object.__new__.__doc__ or  # for pypy
1693                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1694                     initdocstring = None
1695             if initdocstring:
1696                 if content == 'init':
1697                     docstrings = [initdocstring]
1698                 else:
1699                     docstrings.append(initdocstring)
1700 
1701         tab_width = self.directive.state.document.settings.tab_width
1702         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1703 
1704     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1705                     ) -> None:
1706         if self.doc_as_attr:
1707             try:
1708                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')
1709             except AttributeError:
1710                 pass  # Invalid class object is passed.
1711 
1712         super().add_content(more_content)
1713 
1714     def document_members(self, all_members: bool = False) -> None:
1715         if self.doc_as_attr:
1716             return
1717         super().document_members(all_members)
1718 
1719     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
1720                  check_module: bool = False, all_members: bool = False) -> None:
1721         # Do not pass real_modname and use the name from the __module__
1722         # attribute of the class.
1723         # If a class gets imported into the module real_modname
1724         # the analyzer won't find the source of the class, if
1725         # it looks in real_modname.
1726         return super().generate(more_content=more_content,
1727                                 check_module=check_module,
1728                                 all_members=all_members)
1729 
1730 
1731 class ExceptionDocumenter(ClassDocumenter):
1732     """
1733     Specialized ClassDocumenter subclass for exceptions.
1734     """
1735     objtype = 'exception'
1736     member_order = 10
1737 
1738     # needs a higher priority than ClassDocumenter
1739     priority = 10
1740 
1741     @classmethod
1742     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1743                             ) -> bool:
1744         return isinstance(member, type) and issubclass(member, BaseException)
1745 
1746 
1747 class DataDocumenterMixinBase:
1748     # define types of instance variables
1749     config = None  # type: Config
1750     env = None  # type: BuildEnvironment
1751     modname = None  # type: str
1752     parent = None  # type: Any
1753     object = None  # type: Any
1754     objpath = None  # type: List[str]
1755 
1756     def should_suppress_directive_header(self) -> bool:
1757         """Check directive header should be suppressed."""
1758         return False
1759 
1760     def should_suppress_value_header(self) -> bool:
1761         """Check :value: header should be suppressed."""
1762         return False
1763 
1764     def update_content(self, more_content: StringList) -> None:
1765         """Update docstring for the NewType object."""
1766         pass
1767 
1768 
1769 class GenericAliasMixin(DataDocumenterMixinBase):
1770     """
1771     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1772     supporting GenericAliases.
1773     """
1774 
1775     def should_suppress_directive_header(self) -> bool:
1776         return (inspect.isgenericalias(self.object) or
1777                 super().should_suppress_directive_header())
1778 
1779     def update_content(self, more_content: StringList) -> None:
1780         if inspect.isgenericalias(self.object):
1781             alias = stringify_typehint(self.object)
1782             more_content.append(_('alias of %s') % alias, '')
1783             more_content.append('', '')
1784 
1785         super().update_content(more_content)
1786 
1787 
1788 class NewTypeMixin(DataDocumenterMixinBase):
1789     """
1790     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1791     supporting NewTypes.
1792     """
1793 
1794     def should_suppress_directive_header(self) -> bool:
1795         return (inspect.isNewType(self.object) or
1796                 super().should_suppress_directive_header())
1797 
1798     def update_content(self, more_content: StringList) -> None:
1799         if inspect.isNewType(self.object):
1800             supertype = restify(self.object.__supertype__)
1801             more_content.append(_('alias of %s') % supertype, '')
1802             more_content.append('', '')
1803 
1804         super().update_content(more_content)
1805 
1806 
1807 class TypeVarMixin(DataDocumenterMixinBase):
1808     """
1809     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for
1810     supporting TypeVars.
1811     """
1812 
1813     def should_suppress_directive_header(self) -> bool:
1814         return (isinstance(self.object, TypeVar) or
1815                 super().should_suppress_directive_header())
1816 
1817     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1818         if ignore is not None:
1819             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1820                           % self.__class__.__name__,
1821                           RemovedInSphinx50Warning, stacklevel=2)
1822 
1823         if isinstance(self.object, TypeVar):
1824             if self.object.__doc__ != TypeVar.__doc__:
1825                 return super().get_doc()  # type: ignore
1826             else:
1827                 return []
1828         else:
1829             return super().get_doc()  # type: ignore
1830 
1831     def update_content(self, more_content: StringList) -> None:
1832         if isinstance(self.object, TypeVar):
1833             attrs = [repr(self.object.__name__)]
1834             for constraint in self.object.__constraints__:
1835                 attrs.append(stringify_typehint(constraint))
1836             if self.object.__covariant__:
1837                 attrs.append("covariant=True")
1838             if self.object.__contravariant__:
1839                 attrs.append("contravariant=True")
1840 
1841             more_content.append(_('alias of TypeVar(%s)') % ", ".join(attrs), '')
1842             more_content.append('', '')
1843 
1844         super().update_content(more_content)
1845 
1846 
1847 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):
1848     """
1849     Mixin for DataDocumenter to provide the feature for supporting uninitialized
1850     (type annotation only) global variables.
1851     """
1852 
1853     def import_object(self, raiseerror: bool = False) -> bool:
1854         try:
1855             return super().import_object(raiseerror=True)  # type: ignore
1856         except ImportError as exc:
1857             # annotation only instance variable (PEP-526)
1858             try:
1859                 with mock(self.config.autodoc_mock_imports):
1860                     parent = import_module(self.modname, self.config.autodoc_warningiserror)
1861                     annotations = get_type_hints(parent, None,
1862                                                  self.config.autodoc_type_aliases)
1863                     if self.objpath[-1] in annotations:
1864                         self.object = UNINITIALIZED_ATTR
1865                         self.parent = parent
1866                         return True
1867             except ImportError:
1868                 pass
1869 
1870             if raiseerror:
1871                 raise
1872             else:
1873                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
1874                 self.env.note_reread()
1875                 return False
1876 
1877     def should_suppress_value_header(self) -> bool:
1878         return (self.object is UNINITIALIZED_ATTR or
1879                 super().should_suppress_value_header())
1880 
1881     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
1882         if self.object is UNINITIALIZED_ATTR:
1883             return []
1884         else:
1885             return super().get_doc(encoding, ignore)  # type: ignore
1886 
1887 
1888 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,
1889                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):
1890     """
1891     Specialized Documenter subclass for data items.
1892     """
1893     objtype = 'data'
1894     member_order = 40
1895     priority = -10
1896     option_spec = dict(ModuleLevelDocumenter.option_spec)
1897     option_spec["annotation"] = annotation_option
1898     option_spec["no-value"] = bool_option
1899 
1900     @classmethod
1901     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1902                             ) -> bool:
1903         return isinstance(parent, ModuleDocumenter) and isattr
1904 
1905     def update_annotations(self, parent: Any) -> None:
1906         """Update __annotations__ to support type_comment and so on."""
1907         annotations = dict(inspect.getannotations(parent))
1908         parent.__annotations__ = annotations
1909 
1910         try:
1911             analyzer = ModuleAnalyzer.for_module(self.modname)
1912             analyzer.analyze()
1913             for (classname, attrname), annotation in analyzer.annotations.items():
1914                 if classname == '' and attrname not in annotations:
1915                     annotations[attrname] = annotation
1916         except PycodeError:
1917             pass
1918 
1919     def import_object(self, raiseerror: bool = False) -> bool:
1920         ret = super().import_object(raiseerror)
1921         if self.parent:
1922             self.update_annotations(self.parent)
1923 
1924         return ret
1925 
1926     def should_suppress_value_header(self) -> bool:
1927         if super().should_suppress_value_header():
1928             return True
1929         else:
1930             doc = self.get_doc()
1931             metadata = extract_metadata('\n'.join(sum(doc, [])))
1932             if 'hide-value' in metadata:
1933                 return True
1934 
1935         return False
1936 
1937     def add_directive_header(self, sig: str) -> None:
1938         super().add_directive_header(sig)
1939         sourcename = self.get_sourcename()
1940         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
1941             pass
1942         elif self.options.annotation:
1943             self.add_line('   :annotation: %s' % self.options.annotation,
1944                           sourcename)
1945         else:
1946             # obtain annotation for this data
1947             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
1948             if self.objpath[-1] in annotations:
1949                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1950                 self.add_line('   :type: ' + objrepr, sourcename)
1951 
1952             try:
1953                 if self.options.no_value or self.should_suppress_value_header():
1954                     pass
1955                 else:
1956                     objrepr = object_description(self.object)
1957                     self.add_line('   :value: ' + objrepr, sourcename)
1958             except ValueError:
1959                 pass
1960 
1961     def document_members(self, all_members: bool = False) -> None:
1962         pass
1963 
1964     def get_real_modname(self) -> str:
1965         return self.get_attr(self.parent or self.object, '__module__', None) \
1966             or self.modname
1967 
1968     def get_module_comment(self, attrname: str) -> Optional[List[str]]:
1969         try:
1970             analyzer = ModuleAnalyzer.for_module(self.modname)
1971             analyzer.analyze()
1972             key = ('', attrname)
1973             if key in analyzer.attr_docs:
1974                 return list(analyzer.attr_docs[key])
1975         except PycodeError:
1976             pass
1977 
1978         return None
1979 
1980     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1981         # Check the variable has a docstring-comment
1982         comment = self.get_module_comment(self.objpath[-1])
1983         if comment:
1984             return [comment]
1985         else:
1986             return super().get_doc(encoding, ignore)
1987 
1988     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
1989                     ) -> None:
1990         # Disable analyzing variable comment on Documenter.add_content() to control it on
1991         # DataDocumenter.add_content()
1992         self.analyzer = None
1993 
1994         if not more_content:
1995             more_content = StringList()
1996 
1997         self.update_content(more_content)
1998         super().add_content(more_content, no_docstring=no_docstring)
1999 
2000 
2001 class NewTypeDataDocumenter(DataDocumenter):
2002     """
2003     Specialized Documenter subclass for NewTypes.
2004 
2005     Note: This must be invoked before FunctionDocumenter because NewType is a kind of
2006     function object.
2007     """
2008 
2009     objtype = 'newtypedata'
2010     directivetype = 'data'
2011     priority = FunctionDocumenter.priority + 1
2012 
2013     @classmethod
2014     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2015                             ) -> bool:
2016         return inspect.isNewType(member) and isattr
2017 
2018 
2019 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
2020     """
2021     Specialized Documenter subclass for methods (normal, static and class).
2022     """
2023     objtype = 'method'
2024     directivetype = 'method'
2025     member_order = 50
2026     priority = 1  # must be more than FunctionDocumenter
2027 
2028     @classmethod
2029     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2030                             ) -> bool:
2031         return inspect.isroutine(member) and \
2032             not isinstance(parent, ModuleDocumenter)
2033 
2034     def import_object(self, raiseerror: bool = False) -> bool:
2035         ret = super().import_object(raiseerror)
2036         if not ret:
2037             return ret
2038 
2039         # to distinguish classmethod/staticmethod
2040         obj = self.parent.__dict__.get(self.object_name)
2041         if obj is None:
2042             obj = self.object
2043 
2044         if (inspect.isclassmethod(obj) or
2045                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
2046             # document class and static members before ordinary ones
2047             self.member_order = self.member_order - 1
2048 
2049         return ret
2050 
2051     def format_args(self, **kwargs: Any) -> str:
2052         if self.config.autodoc_typehints in ('none', 'description'):
2053             kwargs.setdefault('show_annotation', False)
2054 
2055         try:
2056             if self.object == object.__init__ and self.parent != object:
2057                 # Classes not having own __init__() method are shown as no arguments.
2058                 #
2059                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
2060                 #       But it makes users confused.
2061                 args = '()'
2062             else:
2063                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2064                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
2065                     sig = inspect.signature(self.object, bound_method=False,
2066                                             type_aliases=self.config.autodoc_type_aliases)
2067                 else:
2068                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
2069                     sig = inspect.signature(self.object, bound_method=True,
2070                                             type_aliases=self.config.autodoc_type_aliases)
2071                 args = stringify_signature(sig, **kwargs)
2072         except TypeError as exc:
2073             logger.warning(__("Failed to get a method signature for %s: %s"),
2074                            self.fullname, exc)
2075             return None
2076         except ValueError:
2077             args = ''
2078 
2079         if self.config.strip_signature_backslash:
2080             # escape backslashes for reST
2081             args = args.replace('\\', '\\\\')
2082         return args
2083 
2084     def add_directive_header(self, sig: str) -> None:
2085         super().add_directive_header(sig)
2086 
2087         sourcename = self.get_sourcename()
2088         obj = self.parent.__dict__.get(self.object_name, self.object)
2089         if inspect.isabstractmethod(obj):
2090             self.add_line('   :abstractmethod:', sourcename)
2091         if inspect.iscoroutinefunction(obj):
2092             self.add_line('   :async:', sourcename)
2093         if inspect.isclassmethod(obj):
2094             self.add_line('   :classmethod:', sourcename)
2095         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
2096             self.add_line('   :staticmethod:', sourcename)
2097         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
2098             self.add_line('   :final:', sourcename)
2099 
2100     def document_members(self, all_members: bool = False) -> None:
2101         pass
2102 
2103     def format_signature(self, **kwargs: Any) -> str:
2104         sigs = []
2105         if (self.analyzer and
2106                 '.'.join(self.objpath) in self.analyzer.overloads and
2107                 self.config.autodoc_typehints == 'signature'):
2108             # Use signatures for overloaded methods instead of the implementation method.
2109             overloaded = True
2110         else:
2111             overloaded = False
2112             sig = super().format_signature(**kwargs)
2113             sigs.append(sig)
2114 
2115         meth = self.parent.__dict__.get(self.objpath[-1])
2116         if inspect.is_singledispatch_method(meth):
2117             # append signature of singledispatch'ed functions
2118             for typ, func in meth.dispatcher.registry.items():
2119                 if typ is object:
2120                     pass  # default implementation. skipped.
2121                 else:
2122                     self.annotate_to_first_argument(func, typ)
2123 
2124                     documenter = MethodDocumenter(self.directive, '')
2125                     documenter.parent = self.parent
2126                     documenter.object = func
2127                     documenter.objpath = [None]
2128                     sigs.append(documenter.format_signature())
2129         if overloaded:
2130             if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
2131                 actual = inspect.signature(self.object, bound_method=False,
2132                                            type_aliases=self.config.autodoc_type_aliases)
2133             else:
2134                 actual = inspect.signature(self.object, bound_method=True,
2135                                            type_aliases=self.config.autodoc_type_aliases)
2136 
2137             __globals__ = safe_getattr(self.object, '__globals__', {})
2138             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
2139                 overload = self.merge_default_value(actual, overload)
2140                 overload = evaluate_signature(overload, __globals__,
2141                                               self.config.autodoc_type_aliases)
2142 
2143                 if not inspect.isstaticmethod(self.object, cls=self.parent,
2144                                               name=self.object_name):
2145                     parameters = list(overload.parameters.values())
2146                     overload = overload.replace(parameters=parameters[1:])
2147                 sig = stringify_signature(overload, **kwargs)
2148                 sigs.append(sig)
2149 
2150         return "\n".join(sigs)
2151 
2152     def merge_default_value(self, actual: Signature, overload: Signature) -> Signature:
2153         """Merge default values of actual implementation to the overload variants."""
2154         parameters = list(overload.parameters.values())
2155         for i, param in enumerate(parameters):
2156             actual_param = actual.parameters.get(param.name)
2157             if actual_param and param.default == '...':
2158                 parameters[i] = param.replace(default=actual_param.default)
2159 
2160         return overload.replace(parameters=parameters)
2161 
2162     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
2163         """Annotate type hint to the first argument of function if needed."""
2164         try:
2165             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)
2166         except TypeError as exc:
2167             logger.warning(__("Failed to get a method signature for %s: %s"),
2168                            self.fullname, exc)
2169             return
2170         except ValueError:
2171             return
2172         if len(sig.parameters) == 1:
2173             return
2174 
2175         params = list(sig.parameters.values())
2176         if params[1].annotation is Parameter.empty:
2177             params[1] = params[1].replace(annotation=typ)
2178             try:
2179                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
2180             except TypeError:
2181                 # failed to update signature (ex. built-in or extension types)
2182                 return
2183 
2184 
2185 class NonDataDescriptorMixin(DataDocumenterMixinBase):
2186     """
2187     Mixin for AttributeDocumenter to provide the feature for supporting non
2188     data-descriptors.
2189 
2190     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring
2191               and :value: header will be suppressed unexpectedly.
2192     """
2193 
2194     def import_object(self, raiseerror: bool = False) -> bool:
2195         ret = super().import_object(raiseerror)  # type: ignore
2196         if ret and not inspect.isattributedescriptor(self.object):
2197             self.non_data_descriptor = True
2198         else:
2199             self.non_data_descriptor = False
2200 
2201         return ret
2202 
2203     def should_suppress_value_header(self) -> bool:
2204         return (not getattr(self, 'non_data_descriptor', False) or
2205                 super().should_suppress_directive_header())
2206 
2207     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2208         if getattr(self, 'non_data_descriptor', False):
2209             # the docstring of non datadescriptor is very probably the wrong thing
2210             # to display
2211             return None
2212         else:
2213             return super().get_doc(encoding, ignore)  # type: ignore
2214 
2215 
2216 class SlotsMixin(DataDocumenterMixinBase):
2217     """
2218     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.
2219     """
2220 
2221     def isslotsattribute(self) -> bool:
2222         """Check the subject is an attribute in __slots__."""
2223         try:
2224             __slots__ = inspect.getslots(self.parent)
2225             if __slots__ and self.objpath[-1] in __slots__:
2226                 return True
2227             else:
2228                 return False
2229         except (ValueError, TypeError):
2230             return False
2231 
2232     def import_object(self, raiseerror: bool = False) -> bool:
2233         ret = super().import_object(raiseerror)  # type: ignore
2234         if self.isslotsattribute():
2235             self.object = SLOTSATTR
2236 
2237         return ret
2238 
2239     def should_suppress_directive_header(self) -> bool:
2240         if self.object is SLOTSATTR:
2241             self._datadescriptor = True
2242             return True
2243         else:
2244             return super().should_suppress_directive_header()
2245 
2246     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2247         if self.object is SLOTSATTR:
2248             try:
2249                 __slots__ = inspect.getslots(self.parent)
2250                 if __slots__ and __slots__.get(self.objpath[-1]):
2251                     docstring = prepare_docstring(__slots__[self.objpath[-1]])
2252                     return [docstring]
2253                 else:
2254                     return []
2255             except ValueError as exc:
2256                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),
2257                                (self.parent.__qualname__, exc), type='autodoc')
2258                 return []
2259         else:
2260             return super().get_doc(encoding, ignore)  # type: ignore
2261 
2262 
2263 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):
2264     """
2265     Mixin for AttributeDocumenter to provide the feature for supporting runtime
2266     instance attributes (that are defined in __init__() methods with doc-comments).
2267 
2268     Example:
2269 
2270         class Foo:
2271             def __init__(self):
2272                 self.attr = None  #: This is a target of this mix-in.
2273     """
2274 
2275     RUNTIME_INSTANCE_ATTRIBUTE = object()
2276 
2277     def is_runtime_instance_attribute(self, parent: Any) -> bool:
2278         """Check the subject is an attribute defined in __init__()."""
2279         # An instance variable defined in __init__().
2280         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore
2281             return True
2282         else:
2283             return False
2284 
2285     def import_object(self, raiseerror: bool = False) -> bool:
2286         """Check the existence of runtime instance attribute when failed to import the
2287         attribute."""
2288         try:
2289             return super().import_object(raiseerror=True)  # type: ignore
2290         except ImportError as exc:
2291             try:
2292                 with mock(self.config.autodoc_mock_imports):
2293                     ret = import_object(self.modname, self.objpath[:-1], 'class',
2294                                         attrgetter=self.get_attr,  # type: ignore
2295                                         warningiserror=self.config.autodoc_warningiserror)
2296                     parent = ret[3]
2297                     if self.is_runtime_instance_attribute(parent):
2298                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE
2299                         self.parent = parent
2300                         return True
2301             except ImportError:
2302                 pass
2303 
2304             if raiseerror:
2305                 raise
2306             else:
2307                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2308                 self.env.note_reread()
2309                 return False
2310 
2311     def should_suppress_value_header(self) -> bool:
2312         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or
2313                 super().should_suppress_value_header())
2314 
2315 
2316 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):
2317     """
2318     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized
2319     instance attributes (PEP-526 styled, annotation only attributes).
2320 
2321     Example:
2322 
2323         class Foo:
2324             attr: int  #: This is a target of this mix-in.
2325     """
2326 
2327     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:
2328         """Check the subject is an annotation only attribute."""
2329         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)
2330         if self.objpath[-1] in annotations:
2331             return True
2332         else:
2333             return False
2334 
2335     def import_object(self, raiseerror: bool = False) -> bool:
2336         """Check the exisitence of uninitialized instance attribute when failed to import
2337         the attribute."""
2338         try:
2339             return super().import_object(raiseerror=True)  # type: ignore
2340         except ImportError as exc:
2341             try:
2342                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2343                                     attrgetter=self.get_attr,  # type: ignore
2344                                     warningiserror=self.config.autodoc_warningiserror)
2345                 parent = ret[3]
2346                 if self.is_uninitialized_instance_attribute(parent):
2347                     self.object = UNINITIALIZED_ATTR
2348                     self.parent = parent
2349                     return True
2350             except ImportError:
2351                 pass
2352 
2353             if raiseerror:
2354                 raise
2355             else:
2356                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2357                 self.env.note_reread()
2358                 return False
2359 
2360     def should_suppress_value_header(self) -> bool:
2361         return (self.object is UNINITIALIZED_ATTR or
2362                 super().should_suppress_value_header())
2363 
2364     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2365         if self.object is UNINITIALIZED_ATTR:
2366             return None
2367         else:
2368             return super().get_doc(encoding, ignore)  # type: ignore
2369 
2370 
2371 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore
2372                           TypeVarMixin, RuntimeInstanceAttributeMixin,
2373                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,
2374                           DocstringStripSignatureMixin, ClassLevelDocumenter):
2375     """
2376     Specialized Documenter subclass for attributes.
2377     """
2378     objtype = 'attribute'
2379     member_order = 60
2380     option_spec = dict(ModuleLevelDocumenter.option_spec)
2381     option_spec["annotation"] = annotation_option
2382     option_spec["no-value"] = bool_option
2383 
2384     # must be higher than the MethodDocumenter, else it will recognize
2385     # some non-data descriptors as methods
2386     priority = 10
2387 
2388     @staticmethod
2389     def is_function_or_method(obj: Any) -> bool:
2390         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
2391 
2392     @classmethod
2393     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2394                             ) -> bool:
2395         if inspect.isattributedescriptor(member):
2396             return True
2397         elif (not isinstance(parent, ModuleDocumenter) and
2398               not inspect.isroutine(member) and
2399               not isinstance(member, type)):
2400             return True
2401         else:
2402             return False
2403 
2404     def document_members(self, all_members: bool = False) -> None:
2405         pass
2406 
2407     def isinstanceattribute(self) -> bool:
2408         """Check the subject is an instance attribute."""
2409         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',
2410                       RemovedInSphinx50Warning)
2411         # uninitialized instance variable (PEP-526)
2412         with mock(self.config.autodoc_mock_imports):
2413             try:
2414                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2415                                     attrgetter=self.get_attr,
2416                                     warningiserror=self.config.autodoc_warningiserror)
2417                 self.parent = ret[3]
2418                 annotations = get_type_hints(self.parent, None,
2419                                              self.config.autodoc_type_aliases)
2420                 if self.objpath[-1] in annotations:
2421                     self.object = UNINITIALIZED_ATTR
2422                     return True
2423             except ImportError:
2424                 pass
2425 
2426         return False
2427 
2428     def update_annotations(self, parent: Any) -> None:
2429         """Update __annotations__ to support type_comment and so on."""
2430         try:
2431             annotations = dict(inspect.getannotations(parent))
2432             parent.__annotations__ = annotations
2433 
2434             for cls in inspect.getmro(parent):
2435                 try:
2436                     module = safe_getattr(cls, '__module__')
2437                     qualname = safe_getattr(cls, '__qualname__')
2438 
2439                     analyzer = ModuleAnalyzer.for_module(module)
2440                     analyzer.analyze()
2441                     for (classname, attrname), annotation in analyzer.annotations.items():
2442                         if classname == qualname and attrname not in annotations:
2443                             annotations[attrname] = annotation
2444                 except (AttributeError, PycodeError):
2445                     pass
2446         except TypeError:
2447             # Failed to set __annotations__ (built-in, extensions, etc.)
2448             pass
2449 
2450     def import_object(self, raiseerror: bool = False) -> bool:
2451         ret = super().import_object(raiseerror)
2452         if inspect.isenumattribute(self.object):
2453             self.object = self.object.value
2454         if self.parent:
2455             self.update_annotations(self.parent)
2456 
2457         return ret
2458 
2459     def get_real_modname(self) -> str:
2460         return self.get_attr(self.parent or self.object, '__module__', None) \
2461             or self.modname
2462 
2463     def should_suppress_value_header(self) -> bool:
2464         if super().should_suppress_value_header():
2465             return True
2466         else:
2467             doc = self.get_doc()
2468             if doc:
2469                 metadata = extract_metadata('\n'.join(sum(doc, [])))
2470                 if 'hide-value' in metadata:
2471                     return True
2472 
2473         return False
2474 
2475     def add_directive_header(self, sig: str) -> None:
2476         super().add_directive_header(sig)
2477         sourcename = self.get_sourcename()
2478         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():
2479             pass
2480         elif self.options.annotation:
2481             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2482         else:
2483             # obtain type annotation for this attribute
2484             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)
2485             if self.objpath[-1] in annotations:
2486                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2487                 self.add_line('   :type: ' + objrepr, sourcename)
2488 
2489             try:
2490                 if self.options.no_value or self.should_suppress_value_header():
2491                     pass
2492                 else:
2493                     objrepr = object_description(self.object)
2494                     self.add_line('   :value: ' + objrepr, sourcename)
2495             except ValueError:
2496                 pass
2497 
2498     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:
2499         for cls in inspect.getmro(parent):
2500             try:
2501                 module = safe_getattr(cls, '__module__')
2502                 qualname = safe_getattr(cls, '__qualname__')
2503 
2504                 analyzer = ModuleAnalyzer.for_module(module)
2505                 analyzer.analyze()
2506                 if qualname and self.objpath:
2507                     key = (qualname, attrname)
2508                     if key in analyzer.attr_docs:
2509                         return list(analyzer.attr_docs[key])
2510             except (AttributeError, PycodeError):
2511                 pass
2512 
2513         return None
2514 
2515     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
2516         # Check the attribute has a docstring-comment
2517         comment = self.get_attribute_comment(self.parent, self.objpath[-1])
2518         if comment:
2519             return [comment]
2520 
2521         try:
2522             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2523             # a docstring from the value which descriptor returns unexpectedly.
2524             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2525             orig = self.config.autodoc_inherit_docstrings
2526             self.config.autodoc_inherit_docstrings = False  # type: ignore
2527             return super().get_doc(encoding, ignore)
2528         finally:
2529             self.config.autodoc_inherit_docstrings = orig  # type: ignore
2530 
2531     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
2532                     ) -> None:
2533         # Disable analyzing attribute comment on Documenter.add_content() to control it on
2534         # AttributeDocumenter.add_content()
2535         self.analyzer = None
2536 
2537         if more_content is None:
2538             more_content = StringList()
2539         self.update_content(more_content)
2540         super().add_content(more_content, no_docstring)
2541 
2542 
2543 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2544     """
2545     Specialized Documenter subclass for properties.
2546     """
2547     objtype = 'property'
2548     directivetype = 'method'
2549     member_order = 60
2550 
2551     # before AttributeDocumenter
2552     priority = AttributeDocumenter.priority + 1
2553 
2554     @classmethod
2555     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2556                             ) -> bool:
2557         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2558 
2559     def document_members(self, all_members: bool = False) -> None:
2560         pass
2561 
2562     def get_real_modname(self) -> str:
2563         return self.get_attr(self.parent or self.object, '__module__', None) \
2564             or self.modname
2565 
2566     def add_directive_header(self, sig: str) -> None:
2567         super().add_directive_header(sig)
2568         sourcename = self.get_sourcename()
2569         if inspect.isabstractmethod(self.object):
2570             self.add_line('   :abstractmethod:', sourcename)
2571         self.add_line('   :property:', sourcename)
2572 
2573 
2574 class NewTypeAttributeDocumenter(AttributeDocumenter):
2575     """
2576     Specialized Documenter subclass for NewTypes.
2577 
2578     Note: This must be invoked before MethodDocumenter because NewType is a kind of
2579     function object.
2580     """
2581 
2582     objtype = 'newvarattribute'
2583     directivetype = 'attribute'
2584     priority = MethodDocumenter.priority + 1
2585 
2586     @classmethod
2587     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2588                             ) -> bool:
2589         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)
2590 
2591 
2592 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2593     """Returns registered Documenter classes"""
2594     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2595     return app.registry.documenters
2596 
2597 
2598 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2599     """Alternative getattr() for types"""
2600     for typ, func in app.registry.autodoc_attrgettrs.items():
2601         if isinstance(obj, typ):
2602             return func(obj, name, *defargs)
2603 
2604     return safe_getattr(obj, name, *defargs)
2605 
2606 
2607 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2608     if config.autodoc_member_order == 'alphabetic':
2609         # RemovedInSphinx50Warning
2610         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2611                           'instead of "alphabetic". Please update your setting.'))
2612         config.autodoc_member_order = 'alphabetical'  # type: ignore
2613 
2614 
2615 # for compatibility
2616 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA
2617 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA
2618 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA
2619 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA
2620 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA
2621 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA
2622 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA
2623 
2624 
2625 def setup(app: Sphinx) -> Dict[str, Any]:
2626     app.add_autodocumenter(ModuleDocumenter)
2627     app.add_autodocumenter(ClassDocumenter)
2628     app.add_autodocumenter(ExceptionDocumenter)
2629     app.add_autodocumenter(DataDocumenter)
2630     app.add_autodocumenter(NewTypeDataDocumenter)
2631     app.add_autodocumenter(FunctionDocumenter)
2632     app.add_autodocumenter(DecoratorDocumenter)
2633     app.add_autodocumenter(MethodDocumenter)
2634     app.add_autodocumenter(AttributeDocumenter)
2635     app.add_autodocumenter(PropertyDocumenter)
2636     app.add_autodocumenter(NewTypeAttributeDocumenter)
2637 
2638     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2639     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2640                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2641     app.add_config_value('autodoc_default_options', {}, True)
2642     app.add_config_value('autodoc_docstring_signature', True, True)
2643     app.add_config_value('autodoc_mock_imports', [], True)
2644     app.add_config_value('autodoc_typehints', "signature", True,
2645                          ENUM("signature", "description", "none"))
2646     app.add_config_value('autodoc_type_aliases', {}, True)
2647     app.add_config_value('autodoc_warningiserror', True, True)
2648     app.add_config_value('autodoc_inherit_docstrings', True, True)
2649     app.add_event('autodoc-before-process-signature')
2650     app.add_event('autodoc-process-docstring')
2651     app.add_event('autodoc-process-signature')
2652     app.add_event('autodoc-skip-member')
2653 
2654     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2655 
2656     app.setup_extension('sphinx.ext.autodoc.type_comment')
2657     app.setup_extension('sphinx.ext.autodoc.typehints')
2658 
2659     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>The code within this file that processes inherited class members for documentation should be updated to ensure that members which are only annotated with type hints and potentially documented with special comment docstrings (`#: docstring`) are recognized as documented. This involves adjusting the logic that determines whether a member is documented to account not only for explicit docstrings but also for type annotations and inline comments considered as docstrings. The modification should retain all existing functionality, including the ability to recognize explicitly documented members, while extending the recognition to annotated only members. This fix should ensure compatibility with the expected Sphinx behavior, where inherited members that are annotated should be automatically documented without requiring the `:undoc-members:` option.</intended_behavior>]
2025-10-17 19:14:09.464 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 19:14:09.464 | INFO     | Search-only: skipping patch selection
2025-10-17 19:14:09.539 | INFO     | Task sphinx-doc__sphinx-8801 completed successfully.
2025-10-17 19:14:09.540 | INFO     | No patch generated. You can try running ACR again.
