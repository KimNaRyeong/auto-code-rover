2025-10-17 20:17:29.324 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 20:17:38.410 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=417, output_tokens=12, cost=0.004530
2025-10-17 20:17:48.765 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=597, output_tokens=429, cost=0.018840
2025-10-17 20:17:49.741 | INFO     | registered non reproducing test 0
2025-10-17 20:18:08.821 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1375, output_tokens=594, cost=0.031570
2025-10-17 20:18:09.785 | INFO     | registered non reproducing test 1
2025-10-17 20:18:25.519 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1511, output_tokens=636, cost=0.034190
2025-10-17 20:18:26.490 | INFO     | registered non reproducing test 2
2025-10-17 20:18:26.490 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-17 20:18:26.495 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:18:37.903 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=563, cost=0.024070
2025-10-17 20:18:37.914 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:18:39.621 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=917, output_tokens=40, cost=0.010370
2025-10-17 20:18:39.622 | DEBUG    | Extracted a valid json.
2025-10-17 20:18:39.622 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"MatrixSymbol\")", "search_code(\"lambdify\")", "search_code(\"np.linalg.inv\")"],
    "bug_locations": []
}
2025-10-17 20:18:41.252 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 20:18:41.253 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 20:19:00.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2829, output_tokens=742, cost=0.050550
2025-10-17 20:19:00.313 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 20:19:09.431 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3787, output_tokens=367, cost=0.048880
2025-10-17 20:19:09.439 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 20:19:14.215 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=721, output_tokens=133, cost=0.011200
2025-10-17 20:19:14.216 | DEBUG    | Extracted a valid json.
2025-10-17 20:19:14.216 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/utilities/lambdify.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that when `lambdify` is converting sympy expressions (in this case, matrix inversion) into numpy functions, it correctly handles sympy's symbolic matrices by generating numpy-compatible numeric matrices without triggering type or unsupported operation errors (e.g., 'bitwise_xor'). This may involve adding or refining a check or conversion step specifically for matrix inversion operations to ensure compatibility with numpy's expectations."
        }
    ]
}
2025-10-17 20:19:14.220 | DEBUG    | Bug location extracted successfully: [<file>sympy/utilities/lambdify.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 This module provides convenient functions to transform sympy expressions to
3 lambda functions which can be used to calculate numerical values very fast.
4 """
5 
6 from __future__ import print_function, division
7 
8 from functools import wraps
9 import inspect
10 import keyword
11 import re
12 import textwrap
13 import linecache
14 
15 from sympy.core.compatibility import (exec_, is_sequence, iterable,
16     NotIterable, string_types, range, builtins, integer_types, PY3)
17 from sympy.utilities.decorator import doctest_depends_on
18 
19 # These are the namespaces the lambda functions will use.
20 MATH = {}
21 MPMATH = {}
22 NUMPY = {}
23 SCIPY = {}
24 TENSORFLOW = {}
25 SYMPY = {}
26 NUMEXPR = {}
27 
28 # Default namespaces, letting us define translations that can't be defined
29 # by simple variable maps, like I => 1j
30 # These are separate from the names above because the above names are modified
31 # throughout this file, whereas these should remain unmodified.
32 MATH_DEFAULT = {}
33 MPMATH_DEFAULT = {}
34 NUMPY_DEFAULT = {"I": 1j}
35 SCIPY_DEFAULT = {"I": 1j}
36 TENSORFLOW_DEFAULT = {}
37 SYMPY_DEFAULT = {}
38 NUMEXPR_DEFAULT = {}
39 
40 # Mappings between sympy and other modules function names.
41 MATH_TRANSLATIONS = {
42     "ceiling": "ceil",
43     "E": "e",
44     "ln": "log",
45 }
46 
47 MPMATH_TRANSLATIONS = {
48     "Abs": "fabs",
49     "elliptic_k": "ellipk",
50     "elliptic_f": "ellipf",
51     "elliptic_e": "ellipe",
52     "elliptic_pi": "ellippi",
53     "ceiling": "ceil",
54     "chebyshevt": "chebyt",
55     "chebyshevu": "chebyu",
56     "E": "e",
57     "I": "j",
58     "ln": "log",
59     #"lowergamma":"lower_gamma",
60     "oo": "inf",
61     #"uppergamma":"upper_gamma",
62     "LambertW": "lambertw",
63     "MutableDenseMatrix": "matrix",
64     "ImmutableDenseMatrix": "matrix",
65     "conjugate": "conj",
66     "dirichlet_eta": "altzeta",
67     "Ei": "ei",
68     "Shi": "shi",
69     "Chi": "chi",
70     "Si": "si",
71     "Ci": "ci",
72     "RisingFactorial": "rf",
73     "FallingFactorial": "ff",
74 }
75 
76 NUMPY_TRANSLATIONS = {}
77 SCIPY_TRANSLATIONS = {}
78 
79 TENSORFLOW_TRANSLATIONS = {
80     "Abs": "abs",
81     "ceiling": "ceil",
82     "im": "imag",
83     "ln": "log",
84     "Mod": "mod",
85     "conjugate": "conj",
86     "re": "real",
87 }
88 
89 NUMEXPR_TRANSLATIONS = {}
90 
91 # Available modules:
92 MODULES = {
93     "math": (MATH, MATH_DEFAULT, MATH_TRANSLATIONS, ("from math import *",)),
94     "mpmath": (MPMATH, MPMATH_DEFAULT, MPMATH_TRANSLATIONS, ("from mpmath import *",)),
95     "numpy": (NUMPY, NUMPY_DEFAULT, NUMPY_TRANSLATIONS, ("import numpy; from numpy import *",)),
96     "scipy": (SCIPY, SCIPY_DEFAULT, SCIPY_TRANSLATIONS, ("import numpy; import scipy; from scipy import *; from scipy.special import *",)),
97     "tensorflow": (TENSORFLOW, TENSORFLOW_DEFAULT, TENSORFLOW_TRANSLATIONS, ("import_module('tensorflow')",)),
98     "sympy": (SYMPY, SYMPY_DEFAULT, {}, (
99         "from sympy.functions import *",
100         "from sympy.matrices import *",
101         "from sympy import Integral, pi, oo, nan, zoo, E, I",)),
102     "numexpr" : (NUMEXPR, NUMEXPR_DEFAULT, NUMEXPR_TRANSLATIONS,
103                  ("import_module('numexpr')", )),
104 }
105 
106 
107 def _import(module, reload="False"):
108     """
109     Creates a global translation dictionary for module.
110 
111     The argument module has to be one of the following strings: "math",
112     "mpmath", "numpy", "sympy", "tensorflow".
113     These dictionaries map names of python functions to their equivalent in
114     other modules.
115     """
116     from sympy.external import import_module
117     try:
118         namespace, namespace_default, translations, import_commands = MODULES[
119             module]
120     except KeyError:
121         raise NameError(
122             "'%s' module can't be used for lambdification" % module)
123 
124     # Clear namespace or exit
125     if namespace != namespace_default:
126         # The namespace was already generated, don't do it again if not forced.
127         if reload:
128             namespace.clear()
129             namespace.update(namespace_default)
130         else:
131             return
132 
133     for import_command in import_commands:
134         if import_command.startswith('import_module'):
135             module = eval(import_command)
136 
137             if module is not None:
138                 namespace.update(module.__dict__)
139                 continue
140         else:
141             try:
142                 exec_(import_command, {}, namespace)
143                 continue
144             except ImportError:
145                 pass
146 
147         raise ImportError(
148             "can't import '%s' with '%s' command" % (module, import_command))
149 
150     # Add translated names to namespace
151     for sympyname, translation in translations.items():
152         namespace[sympyname] = namespace[translation]
153 
154     # For computing the modulus of a sympy expression we use the builtin abs
155     # function, instead of the previously used fabs function for all
156     # translation modules. This is because the fabs function in the math
157     # module does not accept complex valued arguments. (see issue 9474). The
158     # only exception, where we don't use the builtin abs function is the
159     # mpmath translation module, because mpmath.fabs returns mpf objects in
160     # contrast to abs().
161     if 'Abs' not in namespace:
162         namespace['Abs'] = abs
163 
164 
165 # Used for dynamically generated filenames that are inserted into the
166 # linecache.
167 _lambdify_generated_counter = 1
168 
169 @doctest_depends_on(modules=('numpy'))
170 def lambdify(args, expr, modules=None, printer=None, use_imps=True,
171              dummify=False):
172     """
173     Returns an anonymous function for fast calculation of numerical values.
174 
175     If not specified differently by the user, ``modules`` defaults to
176     ``["numpy"]`` if NumPy is installed, and ``["math", "mpmath", "sympy"]``
177     if it isn't, that is, SymPy functions are replaced as far as possible by
178     either ``numpy`` functions if available, and Python's standard library
179     ``math``, or ``mpmath`` functions otherwise. To change this behavior, the
180     "modules" argument can be used. It accepts:
181 
182      - the strings "math", "mpmath", "numpy", "numexpr", "sympy", "tensorflow"
183      - any modules (e.g. math)
184      - dictionaries that map names of sympy functions to arbitrary functions
185      - lists that contain a mix of the arguments above, with higher priority
186        given to entries appearing first.
187 
188     .. warning::
189         Note that this function uses ``eval``, and thus shouldn't be used on
190         unsanitized input.
191 
192     Arguments in the provided expression that are not valid Python identifiers
193     are substitued with dummy symbols. This allows for applied functions
194     (e.g. f(t)) to be supplied as arguments. Call the function with
195     dummify=True to replace all arguments with dummy symbols (if `args` is
196     not a string) - for example, to ensure that the arguments do not
197     redefine any built-in names.
198 
199     For functions involving large array calculations, numexpr can provide a
200     significant speedup over numpy.  Please note that the available functions
201     for numexpr are more limited than numpy but can be expanded with
202     implemented_function and user defined subclasses of Function.  If specified,
203     numexpr may be the only option in modules. The official list of numexpr
204     functions can be found at:
205     https://github.com/pydata/numexpr#supported-functions
206 
207     In previous releases ``lambdify`` replaced ``Matrix`` with ``numpy.matrix``
208     by default. As of release 1.0 ``numpy.array`` is the default.
209     To get the old default behavior you must pass in ``[{'ImmutableDenseMatrix':
210     numpy.matrix}, 'numpy']`` to the ``modules`` kwarg.
211 
212     >>> from sympy import lambdify, Matrix
213     >>> from sympy.abc import x, y
214     >>> import numpy
215     >>> array2mat = [{'ImmutableDenseMatrix': numpy.matrix}, 'numpy']
216     >>> f = lambdify((x, y), Matrix([x, y]), modules=array2mat)
217     >>> f(1, 2)
218     matrix([[1],
219             [2]])
220 
221     Usage
222     =====
223 
224     (1) Use one of the provided modules:
225 
226         >>> from sympy import sin, tan, gamma
227         >>> from sympy.abc import x, y
228         >>> f = lambdify(x, sin(x), "math")
229 
230         Attention: Functions that are not in the math module will throw a name
231                    error when the function definition is evaluated! So this
232                    would be better:
233 
234         >>> f = lambdify(x, sin(x)*gamma(x), ("math", "mpmath", "sympy"))
235 
236     (2) Use some other module:
237 
238         >>> import numpy
239         >>> f = lambdify((x,y), tan(x*y), numpy)
240 
241         Attention: There are naming differences between numpy and sympy. So if
242                    you simply take the numpy module, e.g. sympy.atan will not be
243                    translated to numpy.arctan. Use the modified module instead
244                    by passing the string "numpy":
245 
246         >>> f = lambdify((x,y), tan(x*y), "numpy")
247         >>> f(1, 2)
248         -2.18503986326
249         >>> from numpy import array
250         >>> f(array([1, 2, 3]), array([2, 3, 5]))
251         [-2.18503986 -0.29100619 -0.8559934 ]
252 
253         In the above examples, the generated functions can accept scalar
254         values or numpy arrays as arguments.  However, in some cases
255         the generated function relies on the input being a numpy array:
256 
257         >>> from sympy import Piecewise
258         >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), "numpy")
259         >>> f(array([-1, 0, 1, 2]))
260         [-1.   0.   1.   0.5]
261         >>> f(0)
262         Traceback (most recent call last):
263             ...
264         ZeroDivisionError: division by zero
265 
266         In such cases, the input should be wrapped in a numpy array:
267         >>> float(f(array([0])))
268         0.0
269 
270         Or if numpy functionality is not required another module can be used:
271         >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), "math")
272         >>> f(0)
273         0
274 
275     (3) Use a dictionary defining custom functions:
276 
277         >>> def my_cool_function(x): return 'sin(%s) is cool' % x
278         >>> myfuncs = {"sin" : my_cool_function}
279         >>> f = lambdify(x, sin(x), myfuncs); f(1)
280         'sin(1) is cool'
281 
282     Examples
283     ========
284 
285     >>> from sympy.utilities.lambdify import implemented_function
286     >>> from sympy import sqrt, sin, Matrix
287     >>> from sympy import Function
288     >>> from sympy.abc import w, x, y, z
289 
290     >>> f = lambdify(x, x**2)
291     >>> f(2)
292     4
293     >>> f = lambdify((x, y, z), [z, y, x])
294     >>> f(1,2,3)
295     [3, 2, 1]
296     >>> f = lambdify(x, sqrt(x))
297     >>> f(4)
298     2.0
299     >>> f = lambdify((x, y), sin(x*y)**2)
300     >>> f(0, 5)
301     0.0
302     >>> row = lambdify((x, y), Matrix((x, x + y)).T, modules='sympy')
303     >>> row(1, 2)
304     Matrix([[1, 3]])
305 
306     Tuple arguments are handled and the lambdified function should
307     be called with the same type of arguments as were used to create
308     the function.:
309 
310     >>> f = lambdify((x, (y, z)), x + y)
311     >>> f(1, (2, 4))
312     3
313 
314     A more robust way of handling this is to always work with flattened
315     arguments:
316 
317     >>> from sympy.utilities.iterables import flatten
318     >>> args = w, (x, (y, z))
319     >>> vals = 1, (2, (3, 4))
320     >>> f = lambdify(flatten(args), w + x + y + z)
321     >>> f(*flatten(vals))
322     10
323 
324     Functions present in `expr` can also carry their own numerical
325     implementations, in a callable attached to the ``_imp_``
326     attribute.  Usually you attach this using the
327     ``implemented_function`` factory:
328 
329     >>> f = implemented_function(Function('f'), lambda x: x+1)
330     >>> func = lambdify(x, f(x))
331     >>> func(4)
332     5
333 
334     ``lambdify`` always prefers ``_imp_`` implementations to implementations
335     in other namespaces, unless the ``use_imps`` input parameter is False.
336 
337     Usage with Tensorflow module:
338 
339     >>> import tensorflow as tf
340     >>> f = Max(x, sin(x))
341     >>> func = lambdify(x, f, 'tensorflow')
342     >>> result = func(tf.constant(1.0))
343     >>> result # a tf.Tensor representing the result of the calculation
344     <tf.Tensor 'Maximum:0' shape=() dtype=float32>
345     >>> sess = tf.Session()
346     >>> sess.run(result) # compute result
347     1.0
348     >>> var = tf.Variable(1.0)
349     >>> sess.run(tf.global_variables_initializer())
350     >>> sess.run(func(var)) # also works for tf.Variable and tf.Placeholder
351     1.0
352     >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]]) # works with any shape tensor
353     >>> sess.run(func(tensor))
354     array([[ 1.,  2.],
355            [ 3.,  4.]], dtype=float32)
356 
357     """
358     from sympy.core.symbol import Symbol
359     from sympy.utilities.iterables import flatten
360 
361     # If the user hasn't specified any modules, use what is available.
362     module_provided = True
363     if modules is None:
364         module_provided = False
365 
366         try:
367             _import("scipy")
368         except ImportError:
369             try:
370                 _import("numpy")
371             except ImportError:
372                 # Use either numpy (if available) or python.math where possible.
373                 # XXX: This leads to different behaviour on different systems and
374                 #      might be the reason for irreproducible errors.
375                 modules = ["math", "mpmath", "sympy"]
376             else:
377                 modules = ["numpy"]
378         else:
379             modules = ["scipy", "numpy"]
380 
381     # Get the needed namespaces.
382     namespaces = []
383     # First find any function implementations
384     if use_imps:
385         namespaces.append(_imp_namespace(expr))
386     # Check for dict before iterating
387     if isinstance(modules, (dict, str)) or not hasattr(modules, '__iter__'):
388         namespaces.append(modules)
389     else:
390         # consistency check
391         if _module_present('numexpr', modules) and len(modules) > 1:
392             raise TypeError("numexpr must be the only item in 'modules'")
393         namespaces += list(modules)
394     # fill namespace with first having highest priority
395     namespace = {}
396     for m in namespaces[::-1]:
397         buf = _get_namespace(m)
398         namespace.update(buf)
399 
400     if hasattr(expr, "atoms"):
401         #Try if you can extract symbols from the expression.
402         #Move on if expr.atoms in not implemented.
403         syms = expr.atoms(Symbol)
404         for term in syms:
405             namespace.update({str(term): term})
406 
407     if printer is None:
408         if _module_present('mpmath', namespaces):
409             from sympy.printing.pycode import MpmathPrinter as Printer
410         elif _module_present('scipy', namespaces):
411             from sympy.printing.pycode import SciPyPrinter as Printer
412         elif _module_present('numpy', namespaces):
413             from sympy.printing.pycode import NumPyPrinter as Printer
414         elif _module_present('numexpr', namespaces):
415             from sympy.printing.lambdarepr import NumExprPrinter as Printer
416         elif _module_present('tensorflow', namespaces):
417             from sympy.printing.tensorflow import TensorflowPrinter as Printer
418         elif _module_present('sympy', namespaces):
419             from sympy.printing.pycode import SymPyPrinter as Printer
420         else:
421             from sympy.printing.pycode import PythonCodePrinter as Printer
422         user_functions = {}
423         for m in namespaces[::-1]:
424             if isinstance(m, dict):
425                 for k in m:
426                     user_functions[k] = k
427         printer = Printer({'fully_qualified_modules': False, 'inline': True,
428                            'allow_unknown_functions': True,
429                            'user_functions': user_functions})
430 
431     # Get the names of the args, for creating a docstring
432     if not iterable(args):
433         args = (args,)
434     names = []
435     # Grab the callers frame, for getting the names by inspection (if needed)
436     callers_local_vars = inspect.currentframe().f_back.f_locals.items()
437     for n, var in enumerate(args):
438         if hasattr(var, 'name'):
439             names.append(var.name)
440         else:
441             # It's an iterable. Try to get name by inspection of calling frame.
442             name_list = [var_name for var_name, var_val in callers_local_vars
443                     if var_val is var]
444             if len(name_list) == 1:
445                 names.append(name_list[0])
446             else:
447                 # Cannot infer name with certainty. arg_# will have to do.
448                 names.append('arg_' + str(n))
449 
450     imp_mod_lines = []
451     for mod, keys in (getattr(printer, 'module_imports', None) or {}).items():
452         for k in keys:
453             if k not in namespace:
454                 imp_mod_lines.append("from %s import %s" % (mod, k))
455     for ln in imp_mod_lines:
456         exec_(ln, {}, namespace)
457 
458     # Provide lambda expression with builtins, and compatible implementation of range
459     namespace.update({'builtins':builtins, 'range':range})
460 
461     # Create the function definition code and execute it
462 
463     funcname = '_lambdifygenerated'
464 
465     if _module_present('tensorflow', namespaces):
466         funcprinter = _TensorflowEvaluatorPrinter(printer, dummify)
467     else:
468         funcprinter = _EvaluatorPrinter(printer, dummify)
469 
470     funcstr = funcprinter.doprint(funcname, args, expr)
471 
472     funclocals = {}
473     global _lambdify_generated_counter
474     filename = '<lambdifygenerated-%s>' % _lambdify_generated_counter
475     _lambdify_generated_counter += 1
476     c = compile(funcstr, filename, 'exec')
477     exec_(c, namespace, funclocals)
478     # mtime has to be None or else linecache.checkcache will remove it
479     linecache.cache[filename] = (len(funcstr), None, funcstr.splitlines(True), filename)
480 
481     func = funclocals[funcname]
482 
483     # Apply the docstring
484     sig = "func({0})".format(", ".join(str(i) for i in names))
485     sig = textwrap.fill(sig, subsequent_indent=' '*8)
486     expr_str = str(expr)
487     if len(expr_str) > 78:
488         expr_str = textwrap.wrap(expr_str, 75)[0] + '...'
489     func.__doc__ = (
490         "Created with lambdify. Signature:\n\n"
491         "{sig}\n\n"
492         "Expression:\n\n"
493         "{expr}\n\n"
494         "Source code:\n\n"
495         "{src}\n\n"
496         "Imported modules:\n\n"
497         "{imp_mods}"
498         ).format(sig=sig, expr=expr_str, src=funcstr, imp_mods='\n'.join(imp_mod_lines))
499     return func
500 
501 def _module_present(modname, modlist):
502     if modname in modlist:
503         return True
504     for m in modlist:
505         if hasattr(m, '__name__') and m.__name__ == modname:
506             return True
507     return False
508 
509 
510 def _get_namespace(m):
511     """
512     This is used by _lambdify to parse its arguments.
513     """
514     if isinstance(m, string_types):
515         _import(m)
516         return MODULES[m][0]
517     elif isinstance(m, dict):
518         return m
519     elif hasattr(m, "__dict__"):
520         return m.__dict__
521     else:
522         raise TypeError("Argument must be either a string, dict or module but it is: %s" % m)
523 
524 def lambdastr(args, expr, printer=None, dummify=None):
525     """
526     Returns a string that can be evaluated to a lambda function.
527 
528     Examples
529     ========
530 
531     >>> from sympy.abc import x, y, z
532     >>> from sympy.utilities.lambdify import lambdastr
533     >>> lambdastr(x, x**2)
534     'lambda x: (x**2)'
535     >>> lambdastr((x,y,z), [z,y,x])
536     'lambda x,y,z: ([z, y, x])'
537 
538     Although tuples may not appear as arguments to lambda in Python 3,
539     lambdastr will create a lambda function that will unpack the original
540     arguments so that nested arguments can be handled:
541 
542     >>> lambdastr((x, (y, z)), x + y)
543     'lambda _0,_1: (lambda x,y,z: (x + y))(_0,_1[0],_1[1])'
544     """
545     # Transforming everything to strings.
546     from sympy.matrices import DeferredVector
547     from sympy import Dummy, sympify, Symbol, Function, flatten, Derivative, Basic
548 
549     if printer is not None:
550         if inspect.isfunction(printer):
551             lambdarepr = printer
552         else:
553             if inspect.isclass(printer):
554                 lambdarepr = lambda expr: printer().doprint(expr)
555             else:
556                 lambdarepr = lambda expr: printer.doprint(expr)
557     else:
558         #XXX: This has to be done here because of circular imports
559         from sympy.printing.lambdarepr import lambdarepr
560 
561     def sub_args(args, dummies_dict):
562         if isinstance(args, str):
563             return args
564         elif isinstance(args, DeferredVector):
565             return str(args)
566         elif iterable(args):
567             dummies = flatten([sub_args(a, dummies_dict) for a in args])
568             return ",".join(str(a) for a in dummies)
569         else:
570             # replace these with Dummy symbols
571             if isinstance(args, (Function, Symbol, Derivative)):
572                 dummies = Dummy()
573                 dummies_dict.update({args : dummies})
574                 return str(dummies)
575             else:
576                 return str(args)
577 
578     def sub_expr(expr, dummies_dict):
579         try:
580             expr = sympify(expr).xreplace(dummies_dict)
581         except Exception:
582             if isinstance(expr, DeferredVector):
583                 pass
584             elif isinstance(expr, dict):
585                 k = [sub_expr(sympify(a), dummies_dict) for a in expr.keys()]
586                 v = [sub_expr(sympify(a), dummies_dict) for a in expr.values()]
587                 expr = dict(zip(k, v))
588             elif isinstance(expr, tuple):
589                 expr = tuple(sub_expr(sympify(a), dummies_dict) for a in expr)
590             elif isinstance(expr, list):
591                 expr = [sub_expr(sympify(a), dummies_dict) for a in expr]
592         return expr
593 
594     # Transform args
595     def isiter(l):
596         return iterable(l, exclude=(str, DeferredVector, NotIterable))
597 
598     def flat_indexes(iterable):
599         n = 0
600 
601         for el in iterable:
602             if isiter(el):
603                 for ndeep in flat_indexes(el):
604                     yield (n,) + ndeep
605             else:
606                 yield (n,)
607 
608             n += 1
609 
610     if dummify is None:
611         dummify = any(isinstance(a, Basic) and
612             a.atoms(Function, Derivative) for a in (
613             args if isiter(args) else [args]))
614 
615     if isiter(args) and any(isiter(i) for i in args):
616         dum_args = [str(Dummy(str(i))) for i in range(len(args))]
617 
618         indexed_args = ','.join([
619             dum_args[ind[0]] + ''.join(["[%s]" % k for k in ind[1:]])
620                     for ind in flat_indexes(args)])
621 
622         lstr = lambdastr(flatten(args), expr, printer=printer, dummify=dummify)
623 
624         return 'lambda %s: (%s)(%s)' % (','.join(dum_args), lstr, indexed_args)
625 
626     dummies_dict = {}
627     if dummify:
628         args = sub_args(args, dummies_dict)
629     else:
630         if isinstance(args, str):
631             pass
632         elif iterable(args, exclude=DeferredVector):
633             args = ",".join(str(a) for a in args)
634 
635     # Transform expr
636     if dummify:
637         if isinstance(expr, str):
638             pass
639         else:
640             expr = sub_expr(expr, dummies_dict)
641     expr = lambdarepr(expr)
642     return "lambda %s: (%s)" % (args, expr)
643 
644 class _EvaluatorPrinter(object):
645     def __init__(self, printer=None, dummify=False):
646         self._dummify = dummify
647 
648         #XXX: This has to be done here because of circular imports
649         from sympy.printing.lambdarepr import LambdaPrinter
650 
651         if printer is None:
652             printer = LambdaPrinter()
653 
654         if inspect.isfunction(printer):
655             self._exprrepr = printer
656         else:
657             if inspect.isclass(printer):
658                 printer = printer()
659 
660             self._exprrepr = printer.doprint
661 
662             if hasattr(printer, '_print_Symbol'):
663                 symbolrepr = printer._print_Symbol
664 
665             if hasattr(printer, '_print_Dummy'):
666                 dummyrepr = printer._print_Dummy
667 
668         # Used to print the generated function arguments in a standard way
669         self._argrepr = LambdaPrinter().doprint
670 
671     def doprint(self, funcname, args, expr):
672         """Returns the function definition code as a string."""
673         from sympy import Dummy
674 
675         funcbody = []
676 
677         if not iterable(args):
678             args = [args]
679 
680         argstrs, expr = self._preprocess(args, expr)
681 
682         # Generate argument unpacking and final argument list
683         funcargs = []
684         unpackings = []
685 
686         for argstr in argstrs:
687             if iterable(argstr):
688                 funcargs.append(self._argrepr(Dummy()))
689                 unpackings.extend(self._print_unpacking(argstr, funcargs[-1]))
690             else:
691                 funcargs.append(argstr)
692 
693         funcsig = 'def {}({}):'.format(funcname, ', '.join(funcargs))
694 
695         # Wrap input arguments before unpacking
696         funcbody.extend(self._print_funcargwrapping(funcargs))
697 
698         funcbody.extend(unpackings)
699 
700         funcbody.append('return ({})'.format(self._exprrepr(expr)))
701 
702         funclines = [funcsig]
703         funclines.extend('    ' + line for line in funcbody)
704 
705         return '\n'.join(funclines) + '\n'
706 
707     if PY3:
708         @classmethod
709         def _is_safe_ident(cls, ident):
710             return isinstance(ident, str) and ident.isidentifier() \
711                     and not keyword.iskeyword(ident)
712     else:
713         _safe_ident_re = re.compile('^[a-zA-Z_][a-zA-Z0-9_]*$')
714 
715         @classmethod
716         def _is_safe_ident(cls, ident):
717             return isinstance(ident, str) and cls._safe_ident_re.match(ident) \
718                 and not (keyword.iskeyword(ident) or ident == 'None')
719 
720     def _preprocess(self, args, expr):
721         """Preprocess args, expr to replace arguments that do not map
722         to valid Python identifiers.
723 
724         Returns string form of args, and updated expr.
725         """
726         from sympy import Dummy, Function, flatten, Derivative, ordered, Basic
727         from sympy.matrices import DeferredVector
728 
729         # Args of type Dummy can cause name collisions with args
730         # of type Symbol.  Force dummify of everything in this
731         # situation.
732         dummify = self._dummify or any(
733             isinstance(arg, Dummy) for arg in flatten(args))
734 
735         argstrs = [None]*len(args)
736         for arg, i in reversed(list(ordered(zip(args, range(len(args)))))):
737             if iterable(arg):
738                 s, expr = self._preprocess(arg, expr)
739             elif isinstance(arg, DeferredVector):
740                 s = str(arg)
741             elif isinstance(arg, Basic) and arg.is_symbol:
742                 s = self._argrepr(arg)
743                 if dummify or not self._is_safe_ident(s):
744                     dummy = Dummy()
745                     s = self._argrepr(dummy)
746                     expr = self._subexpr(expr, {arg: dummy})
747             elif dummify or isinstance(arg, (Function, Derivative)):
748                 dummy = Dummy()
749                 s = self._argrepr(dummy)
750                 expr = self._subexpr(expr, {arg: dummy})
751             else:
752                 s = str(arg)
753             argstrs[i] = s
754         return argstrs, expr
755 
756     def _subexpr(self, expr, dummies_dict):
757         from sympy.matrices import DeferredVector
758         from sympy import sympify
759 
760         try:
761             expr = sympify(expr).xreplace(dummies_dict)
762         except AttributeError:
763             if isinstance(expr, DeferredVector):
764                 pass
765             elif isinstance(expr, dict):
766                 k = [self._subexpr(sympify(a), dummies_dict) for a in expr.keys()]
767                 v = [self._subexpr(sympify(a), dummies_dict) for a in expr.values()]
768                 expr = dict(zip(k, v))
769             elif isinstance(expr, tuple):
770                 expr = tuple(self._subexpr(sympify(a), dummies_dict) for a in expr)
771             elif isinstance(expr, list):
772                 expr = [self._subexpr(sympify(a), dummies_dict) for a in expr]
773         return expr
774 
775     def _print_funcargwrapping(self, args):
776         """Generate argument wrapping code.
777 
778         args is the argument list of the generated function (strings).
779 
780         Return value is a list of lines of code that will be inserted  at
781         the beginning of the function definition.
782         """
783         return []
784 
785     def _print_unpacking(self, unpackto, arg):
786         """Generate argument unpacking code.
787 
788         arg is the function argument to be unpacked (a string), and
789         unpackto is a list or nested lists of the variable names (strings) to
790         unpack to.
791         """
792         def unpack_lhs(lvalues):
793             return '[{}]'.format(', '.join(
794                 unpack_lhs(val) if iterable(val) else val for val in lvalues))
795 
796         return ['{} = {}'.format(unpack_lhs(unpackto), arg)]
797 
798 class _TensorflowEvaluatorPrinter(_EvaluatorPrinter):
799     def _print_unpacking(self, lvalues, rvalue):
800         """Generate argument unpacking code.
801 
802         This method is used when the input value is not interable,
803         but can be indexed (see issue #14655).
804         """
805         from sympy import flatten
806 
807         def flat_indexes(elems):
808             n = 0
809 
810             for el in elems:
811                 if iterable(el):
812                     for ndeep in flat_indexes(el):
813                         yield (n,) + ndeep
814                 else:
815                     yield (n,)
816 
817                 n += 1
818 
819         indexed = ', '.join('{}[{}]'.format(rvalue, ']['.join(map(str, ind)))
820                                 for ind in flat_indexes(lvalues))
821 
822         return ['[{}] = [{}]'.format(', '.join(flatten(lvalues)), indexed)]
823 
824 def _imp_namespace(expr, namespace=None):
825     """ Return namespace dict with function implementations
826 
827     We need to search for functions in anything that can be thrown at
828     us - that is - anything that could be passed as `expr`.  Examples
829     include sympy expressions, as well as tuples, lists and dicts that may
830     contain sympy expressions.
831 
832     Parameters
833     ----------
834     expr : object
835        Something passed to lambdify, that will generate valid code from
836        ``str(expr)``.
837     namespace : None or mapping
838        Namespace to fill.  None results in new empty dict
839 
840     Returns
841     -------
842     namespace : dict
843        dict with keys of implemented function names within `expr` and
844        corresponding values being the numerical implementation of
845        function
846 
847     Examples
848     ========
849 
850     >>> from sympy.abc import x
851     >>> from sympy.utilities.lambdify import implemented_function, _imp_namespace
852     >>> from sympy import Function
853     >>> f = implemented_function(Function('f'), lambda x: x+1)
854     >>> g = implemented_function(Function('g'), lambda x: x*10)
855     >>> namespace = _imp_namespace(f(g(x)))
856     >>> sorted(namespace.keys())
857     ['f', 'g']
858     """
859     # Delayed import to avoid circular imports
860     from sympy.core.function import FunctionClass
861     if namespace is None:
862         namespace = {}
863     # tuples, lists, dicts are valid expressions
864     if is_sequence(expr):
865         for arg in expr:
866             _imp_namespace(arg, namespace)
867         return namespace
868     elif isinstance(expr, dict):
869         for key, val in expr.items():
870             # functions can be in dictionary keys
871             _imp_namespace(key, namespace)
872             _imp_namespace(val, namespace)
873         return namespace
874     # sympy expressions may be Functions themselves
875     func = getattr(expr, 'func', None)
876     if isinstance(func, FunctionClass):
877         imp = getattr(func, '_imp_', None)
878         if imp is not None:
879             name = expr.func.__name__
880             if name in namespace and namespace[name] != imp:
881                 raise ValueError('We found more than one '
882                                  'implementation with name '
883                                  '"%s"' % name)
884             namespace[name] = imp
885     # and / or they may take Functions as arguments
886     if hasattr(expr, 'args'):
887         for arg in expr.args:
888             _imp_namespace(arg, namespace)
889     return namespace
890 
891 
892 def implemented_function(symfunc, implementation):
893     """ Add numerical ``implementation`` to function ``symfunc``.
894 
895     ``symfunc`` can be an ``UndefinedFunction`` instance, or a name string.
896     In the latter case we create an ``UndefinedFunction`` instance with that
897     name.
898 
899     Be aware that this is a quick workaround, not a general method to create
900     special symbolic functions. If you want to create a symbolic function to be
901     used by all the machinery of SymPy you should subclass the ``Function``
902     class.
903 
904     Parameters
905     ----------
906     symfunc : ``str`` or ``UndefinedFunction`` instance
907        If ``str``, then create new ``UndefinedFunction`` with this as
908        name.  If `symfunc` is an Undefined function, create a new function
909        with the same name and the implemented function attached.
910     implementation : callable
911        numerical implementation to be called by ``evalf()`` or ``lambdify``
912 
913     Returns
914     -------
915     afunc : sympy.FunctionClass instance
916        function with attached implementation
917 
918     Examples
919     ========
920 
921     >>> from sympy.abc import x
922     >>> from sympy.utilities.lambdify import lambdify, implemented_function
923     >>> from sympy import Function
924     >>> f = implemented_function('f', lambda x: x+1)
925     >>> lam_f = lambdify(x, f(x))
926     >>> lam_f(4)
927     5
928     """
929     # Delayed import to avoid circular imports
930     from sympy.core.function import UndefinedFunction
931     # if name, create function to hold implementation
932     _extra_kwargs = {}
933     if isinstance(symfunc, UndefinedFunction):
934         _extra_kwargs = symfunc._extra_kwargs
935         symfunc = symfunc.__name__
936     if isinstance(symfunc, string_types):
937         # Keyword arguments to UndefinedFunction are added as attributes to
938         # the created class.
939         symfunc = UndefinedFunction(symfunc, _imp_=staticmethod(implementation), **_extra_kwargs)
940     elif not isinstance(symfunc, UndefinedFunction):
941         raise ValueError('symfunc should be either a string or'
942                          ' an UndefinedFunction instance.')
943     return symfunc

</code><intended_behavior>Ensure that when `lambdify` is converting sympy expressions (in this case, matrix inversion) into numpy functions, it correctly handles sympy's symbolic matrices by generating numpy-compatible numeric matrices without triggering type or unsupported operation errors (e.g., 'bitwise_xor'). This may involve adding or refining a check or conversion step specifically for matrix inversion operations to ensure compatibility with numpy's expectations.</intended_behavior>]
2025-10-17 20:19:14.220 | INFO     | Search completed. Bug locations: [<file>sympy/utilities/lambdify.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 This module provides convenient functions to transform sympy expressions to
3 lambda functions which can be used to calculate numerical values very fast.
4 """
5 
6 from __future__ import print_function, division
7 
8 from functools import wraps
9 import inspect
10 import keyword
11 import re
12 import textwrap
13 import linecache
14 
15 from sympy.core.compatibility import (exec_, is_sequence, iterable,
16     NotIterable, string_types, range, builtins, integer_types, PY3)
17 from sympy.utilities.decorator import doctest_depends_on
18 
19 # These are the namespaces the lambda functions will use.
20 MATH = {}
21 MPMATH = {}
22 NUMPY = {}
23 SCIPY = {}
24 TENSORFLOW = {}
25 SYMPY = {}
26 NUMEXPR = {}
27 
28 # Default namespaces, letting us define translations that can't be defined
29 # by simple variable maps, like I => 1j
30 # These are separate from the names above because the above names are modified
31 # throughout this file, whereas these should remain unmodified.
32 MATH_DEFAULT = {}
33 MPMATH_DEFAULT = {}
34 NUMPY_DEFAULT = {"I": 1j}
35 SCIPY_DEFAULT = {"I": 1j}
36 TENSORFLOW_DEFAULT = {}
37 SYMPY_DEFAULT = {}
38 NUMEXPR_DEFAULT = {}
39 
40 # Mappings between sympy and other modules function names.
41 MATH_TRANSLATIONS = {
42     "ceiling": "ceil",
43     "E": "e",
44     "ln": "log",
45 }
46 
47 MPMATH_TRANSLATIONS = {
48     "Abs": "fabs",
49     "elliptic_k": "ellipk",
50     "elliptic_f": "ellipf",
51     "elliptic_e": "ellipe",
52     "elliptic_pi": "ellippi",
53     "ceiling": "ceil",
54     "chebyshevt": "chebyt",
55     "chebyshevu": "chebyu",
56     "E": "e",
57     "I": "j",
58     "ln": "log",
59     #"lowergamma":"lower_gamma",
60     "oo": "inf",
61     #"uppergamma":"upper_gamma",
62     "LambertW": "lambertw",
63     "MutableDenseMatrix": "matrix",
64     "ImmutableDenseMatrix": "matrix",
65     "conjugate": "conj",
66     "dirichlet_eta": "altzeta",
67     "Ei": "ei",
68     "Shi": "shi",
69     "Chi": "chi",
70     "Si": "si",
71     "Ci": "ci",
72     "RisingFactorial": "rf",
73     "FallingFactorial": "ff",
74 }
75 
76 NUMPY_TRANSLATIONS = {}
77 SCIPY_TRANSLATIONS = {}
78 
79 TENSORFLOW_TRANSLATIONS = {
80     "Abs": "abs",
81     "ceiling": "ceil",
82     "im": "imag",
83     "ln": "log",
84     "Mod": "mod",
85     "conjugate": "conj",
86     "re": "real",
87 }
88 
89 NUMEXPR_TRANSLATIONS = {}
90 
91 # Available modules:
92 MODULES = {
93     "math": (MATH, MATH_DEFAULT, MATH_TRANSLATIONS, ("from math import *",)),
94     "mpmath": (MPMATH, MPMATH_DEFAULT, MPMATH_TRANSLATIONS, ("from mpmath import *",)),
95     "numpy": (NUMPY, NUMPY_DEFAULT, NUMPY_TRANSLATIONS, ("import numpy; from numpy import *",)),
96     "scipy": (SCIPY, SCIPY_DEFAULT, SCIPY_TRANSLATIONS, ("import numpy; import scipy; from scipy import *; from scipy.special import *",)),
97     "tensorflow": (TENSORFLOW, TENSORFLOW_DEFAULT, TENSORFLOW_TRANSLATIONS, ("import_module('tensorflow')",)),
98     "sympy": (SYMPY, SYMPY_DEFAULT, {}, (
99         "from sympy.functions import *",
100         "from sympy.matrices import *",
101         "from sympy import Integral, pi, oo, nan, zoo, E, I",)),
102     "numexpr" : (NUMEXPR, NUMEXPR_DEFAULT, NUMEXPR_TRANSLATIONS,
103                  ("import_module('numexpr')", )),
104 }
105 
106 
107 def _import(module, reload="False"):
108     """
109     Creates a global translation dictionary for module.
110 
111     The argument module has to be one of the following strings: "math",
112     "mpmath", "numpy", "sympy", "tensorflow".
113     These dictionaries map names of python functions to their equivalent in
114     other modules.
115     """
116     from sympy.external import import_module
117     try:
118         namespace, namespace_default, translations, import_commands = MODULES[
119             module]
120     except KeyError:
121         raise NameError(
122             "'%s' module can't be used for lambdification" % module)
123 
124     # Clear namespace or exit
125     if namespace != namespace_default:
126         # The namespace was already generated, don't do it again if not forced.
127         if reload:
128             namespace.clear()
129             namespace.update(namespace_default)
130         else:
131             return
132 
133     for import_command in import_commands:
134         if import_command.startswith('import_module'):
135             module = eval(import_command)
136 
137             if module is not None:
138                 namespace.update(module.__dict__)
139                 continue
140         else:
141             try:
142                 exec_(import_command, {}, namespace)
143                 continue
144             except ImportError:
145                 pass
146 
147         raise ImportError(
148             "can't import '%s' with '%s' command" % (module, import_command))
149 
150     # Add translated names to namespace
151     for sympyname, translation in translations.items():
152         namespace[sympyname] = namespace[translation]
153 
154     # For computing the modulus of a sympy expression we use the builtin abs
155     # function, instead of the previously used fabs function for all
156     # translation modules. This is because the fabs function in the math
157     # module does not accept complex valued arguments. (see issue 9474). The
158     # only exception, where we don't use the builtin abs function is the
159     # mpmath translation module, because mpmath.fabs returns mpf objects in
160     # contrast to abs().
161     if 'Abs' not in namespace:
162         namespace['Abs'] = abs
163 
164 
165 # Used for dynamically generated filenames that are inserted into the
166 # linecache.
167 _lambdify_generated_counter = 1
168 
169 @doctest_depends_on(modules=('numpy'))
170 def lambdify(args, expr, modules=None, printer=None, use_imps=True,
171              dummify=False):
172     """
173     Returns an anonymous function for fast calculation of numerical values.
174 
175     If not specified differently by the user, ``modules`` defaults to
176     ``["numpy"]`` if NumPy is installed, and ``["math", "mpmath", "sympy"]``
177     if it isn't, that is, SymPy functions are replaced as far as possible by
178     either ``numpy`` functions if available, and Python's standard library
179     ``math``, or ``mpmath`` functions otherwise. To change this behavior, the
180     "modules" argument can be used. It accepts:
181 
182      - the strings "math", "mpmath", "numpy", "numexpr", "sympy", "tensorflow"
183      - any modules (e.g. math)
184      - dictionaries that map names of sympy functions to arbitrary functions
185      - lists that contain a mix of the arguments above, with higher priority
186        given to entries appearing first.
187 
188     .. warning::
189         Note that this function uses ``eval``, and thus shouldn't be used on
190         unsanitized input.
191 
192     Arguments in the provided expression that are not valid Python identifiers
193     are substitued with dummy symbols. This allows for applied functions
194     (e.g. f(t)) to be supplied as arguments. Call the function with
195     dummify=True to replace all arguments with dummy symbols (if `args` is
196     not a string) - for example, to ensure that the arguments do not
197     redefine any built-in names.
198 
199     For functions involving large array calculations, numexpr can provide a
200     significant speedup over numpy.  Please note that the available functions
201     for numexpr are more limited than numpy but can be expanded with
202     implemented_function and user defined subclasses of Function.  If specified,
203     numexpr may be the only option in modules. The official list of numexpr
204     functions can be found at:
205     https://github.com/pydata/numexpr#supported-functions
206 
207     In previous releases ``lambdify`` replaced ``Matrix`` with ``numpy.matrix``
208     by default. As of release 1.0 ``numpy.array`` is the default.
209     To get the old default behavior you must pass in ``[{'ImmutableDenseMatrix':
210     numpy.matrix}, 'numpy']`` to the ``modules`` kwarg.
211 
212     >>> from sympy import lambdify, Matrix
213     >>> from sympy.abc import x, y
214     >>> import numpy
215     >>> array2mat = [{'ImmutableDenseMatrix': numpy.matrix}, 'numpy']
216     >>> f = lambdify((x, y), Matrix([x, y]), modules=array2mat)
217     >>> f(1, 2)
218     matrix([[1],
219             [2]])
220 
221     Usage
222     =====
223 
224     (1) Use one of the provided modules:
225 
226         >>> from sympy import sin, tan, gamma
227         >>> from sympy.abc import x, y
228         >>> f = lambdify(x, sin(x), "math")
229 
230         Attention: Functions that are not in the math module will throw a name
231                    error when the function definition is evaluated! So this
232                    would be better:
233 
234         >>> f = lambdify(x, sin(x)*gamma(x), ("math", "mpmath", "sympy"))
235 
236     (2) Use some other module:
237 
238         >>> import numpy
239         >>> f = lambdify((x,y), tan(x*y), numpy)
240 
241         Attention: There are naming differences between numpy and sympy. So if
242                    you simply take the numpy module, e.g. sympy.atan will not be
243                    translated to numpy.arctan. Use the modified module instead
244                    by passing the string "numpy":
245 
246         >>> f = lambdify((x,y), tan(x*y), "numpy")
247         >>> f(1, 2)
248         -2.18503986326
249         >>> from numpy import array
250         >>> f(array([1, 2, 3]), array([2, 3, 5]))
251         [-2.18503986 -0.29100619 -0.8559934 ]
252 
253         In the above examples, the generated functions can accept scalar
254         values or numpy arrays as arguments.  However, in some cases
255         the generated function relies on the input being a numpy array:
256 
257         >>> from sympy import Piecewise
258         >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), "numpy")
259         >>> f(array([-1, 0, 1, 2]))
260         [-1.   0.   1.   0.5]
261         >>> f(0)
262         Traceback (most recent call last):
263             ...
264         ZeroDivisionError: division by zero
265 
266         In such cases, the input should be wrapped in a numpy array:
267         >>> float(f(array([0])))
268         0.0
269 
270         Or if numpy functionality is not required another module can be used:
271         >>> f = lambdify(x, Piecewise((x, x <= 1), (1/x, x > 1)), "math")
272         >>> f(0)
273         0
274 
275     (3) Use a dictionary defining custom functions:
276 
277         >>> def my_cool_function(x): return 'sin(%s) is cool' % x
278         >>> myfuncs = {"sin" : my_cool_function}
279         >>> f = lambdify(x, sin(x), myfuncs); f(1)
280         'sin(1) is cool'
281 
282     Examples
283     ========
284 
285     >>> from sympy.utilities.lambdify import implemented_function
286     >>> from sympy import sqrt, sin, Matrix
287     >>> from sympy import Function
288     >>> from sympy.abc import w, x, y, z
289 
290     >>> f = lambdify(x, x**2)
291     >>> f(2)
292     4
293     >>> f = lambdify((x, y, z), [z, y, x])
294     >>> f(1,2,3)
295     [3, 2, 1]
296     >>> f = lambdify(x, sqrt(x))
297     >>> f(4)
298     2.0
299     >>> f = lambdify((x, y), sin(x*y)**2)
300     >>> f(0, 5)
301     0.0
302     >>> row = lambdify((x, y), Matrix((x, x + y)).T, modules='sympy')
303     >>> row(1, 2)
304     Matrix([[1, 3]])
305 
306     Tuple arguments are handled and the lambdified function should
307     be called with the same type of arguments as were used to create
308     the function.:
309 
310     >>> f = lambdify((x, (y, z)), x + y)
311     >>> f(1, (2, 4))
312     3
313 
314     A more robust way of handling this is to always work with flattened
315     arguments:
316 
317     >>> from sympy.utilities.iterables import flatten
318     >>> args = w, (x, (y, z))
319     >>> vals = 1, (2, (3, 4))
320     >>> f = lambdify(flatten(args), w + x + y + z)
321     >>> f(*flatten(vals))
322     10
323 
324     Functions present in `expr` can also carry their own numerical
325     implementations, in a callable attached to the ``_imp_``
326     attribute.  Usually you attach this using the
327     ``implemented_function`` factory:
328 
329     >>> f = implemented_function(Function('f'), lambda x: x+1)
330     >>> func = lambdify(x, f(x))
331     >>> func(4)
332     5
333 
334     ``lambdify`` always prefers ``_imp_`` implementations to implementations
335     in other namespaces, unless the ``use_imps`` input parameter is False.
336 
337     Usage with Tensorflow module:
338 
339     >>> import tensorflow as tf
340     >>> f = Max(x, sin(x))
341     >>> func = lambdify(x, f, 'tensorflow')
342     >>> result = func(tf.constant(1.0))
343     >>> result # a tf.Tensor representing the result of the calculation
344     <tf.Tensor 'Maximum:0' shape=() dtype=float32>
345     >>> sess = tf.Session()
346     >>> sess.run(result) # compute result
347     1.0
348     >>> var = tf.Variable(1.0)
349     >>> sess.run(tf.global_variables_initializer())
350     >>> sess.run(func(var)) # also works for tf.Variable and tf.Placeholder
351     1.0
352     >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]]) # works with any shape tensor
353     >>> sess.run(func(tensor))
354     array([[ 1.,  2.],
355            [ 3.,  4.]], dtype=float32)
356 
357     """
358     from sympy.core.symbol import Symbol
359     from sympy.utilities.iterables import flatten
360 
361     # If the user hasn't specified any modules, use what is available.
362     module_provided = True
363     if modules is None:
364         module_provided = False
365 
366         try:
367             _import("scipy")
368         except ImportError:
369             try:
370                 _import("numpy")
371             except ImportError:
372                 # Use either numpy (if available) or python.math where possible.
373                 # XXX: This leads to different behaviour on different systems and
374                 #      might be the reason for irreproducible errors.
375                 modules = ["math", "mpmath", "sympy"]
376             else:
377                 modules = ["numpy"]
378         else:
379             modules = ["scipy", "numpy"]
380 
381     # Get the needed namespaces.
382     namespaces = []
383     # First find any function implementations
384     if use_imps:
385         namespaces.append(_imp_namespace(expr))
386     # Check for dict before iterating
387     if isinstance(modules, (dict, str)) or not hasattr(modules, '__iter__'):
388         namespaces.append(modules)
389     else:
390         # consistency check
391         if _module_present('numexpr', modules) and len(modules) > 1:
392             raise TypeError("numexpr must be the only item in 'modules'")
393         namespaces += list(modules)
394     # fill namespace with first having highest priority
395     namespace = {}
396     for m in namespaces[::-1]:
397         buf = _get_namespace(m)
398         namespace.update(buf)
399 
400     if hasattr(expr, "atoms"):
401         #Try if you can extract symbols from the expression.
402         #Move on if expr.atoms in not implemented.
403         syms = expr.atoms(Symbol)
404         for term in syms:
405             namespace.update({str(term): term})
406 
407     if printer is None:
408         if _module_present('mpmath', namespaces):
409             from sympy.printing.pycode import MpmathPrinter as Printer
410         elif _module_present('scipy', namespaces):
411             from sympy.printing.pycode import SciPyPrinter as Printer
412         elif _module_present('numpy', namespaces):
413             from sympy.printing.pycode import NumPyPrinter as Printer
414         elif _module_present('numexpr', namespaces):
415             from sympy.printing.lambdarepr import NumExprPrinter as Printer
416         elif _module_present('tensorflow', namespaces):
417             from sympy.printing.tensorflow import TensorflowPrinter as Printer
418         elif _module_present('sympy', namespaces):
419             from sympy.printing.pycode import SymPyPrinter as Printer
420         else:
421             from sympy.printing.pycode import PythonCodePrinter as Printer
422         user_functions = {}
423         for m in namespaces[::-1]:
424             if isinstance(m, dict):
425                 for k in m:
426                     user_functions[k] = k
427         printer = Printer({'fully_qualified_modules': False, 'inline': True,
428                            'allow_unknown_functions': True,
429                            'user_functions': user_functions})
430 
431     # Get the names of the args, for creating a docstring
432     if not iterable(args):
433         args = (args,)
434     names = []
435     # Grab the callers frame, for getting the names by inspection (if needed)
436     callers_local_vars = inspect.currentframe().f_back.f_locals.items()
437     for n, var in enumerate(args):
438         if hasattr(var, 'name'):
439             names.append(var.name)
440         else:
441             # It's an iterable. Try to get name by inspection of calling frame.
442             name_list = [var_name for var_name, var_val in callers_local_vars
443                     if var_val is var]
444             if len(name_list) == 1:
445                 names.append(name_list[0])
446             else:
447                 # Cannot infer name with certainty. arg_# will have to do.
448                 names.append('arg_' + str(n))
449 
450     imp_mod_lines = []
451     for mod, keys in (getattr(printer, 'module_imports', None) or {}).items():
452         for k in keys:
453             if k not in namespace:
454                 imp_mod_lines.append("from %s import %s" % (mod, k))
455     for ln in imp_mod_lines:
456         exec_(ln, {}, namespace)
457 
458     # Provide lambda expression with builtins, and compatible implementation of range
459     namespace.update({'builtins':builtins, 'range':range})
460 
461     # Create the function definition code and execute it
462 
463     funcname = '_lambdifygenerated'
464 
465     if _module_present('tensorflow', namespaces):
466         funcprinter = _TensorflowEvaluatorPrinter(printer, dummify)
467     else:
468         funcprinter = _EvaluatorPrinter(printer, dummify)
469 
470     funcstr = funcprinter.doprint(funcname, args, expr)
471 
472     funclocals = {}
473     global _lambdify_generated_counter
474     filename = '<lambdifygenerated-%s>' % _lambdify_generated_counter
475     _lambdify_generated_counter += 1
476     c = compile(funcstr, filename, 'exec')
477     exec_(c, namespace, funclocals)
478     # mtime has to be None or else linecache.checkcache will remove it
479     linecache.cache[filename] = (len(funcstr), None, funcstr.splitlines(True), filename)
480 
481     func = funclocals[funcname]
482 
483     # Apply the docstring
484     sig = "func({0})".format(", ".join(str(i) for i in names))
485     sig = textwrap.fill(sig, subsequent_indent=' '*8)
486     expr_str = str(expr)
487     if len(expr_str) > 78:
488         expr_str = textwrap.wrap(expr_str, 75)[0] + '...'
489     func.__doc__ = (
490         "Created with lambdify. Signature:\n\n"
491         "{sig}\n\n"
492         "Expression:\n\n"
493         "{expr}\n\n"
494         "Source code:\n\n"
495         "{src}\n\n"
496         "Imported modules:\n\n"
497         "{imp_mods}"
498         ).format(sig=sig, expr=expr_str, src=funcstr, imp_mods='\n'.join(imp_mod_lines))
499     return func
500 
501 def _module_present(modname, modlist):
502     if modname in modlist:
503         return True
504     for m in modlist:
505         if hasattr(m, '__name__') and m.__name__ == modname:
506             return True
507     return False
508 
509 
510 def _get_namespace(m):
511     """
512     This is used by _lambdify to parse its arguments.
513     """
514     if isinstance(m, string_types):
515         _import(m)
516         return MODULES[m][0]
517     elif isinstance(m, dict):
518         return m
519     elif hasattr(m, "__dict__"):
520         return m.__dict__
521     else:
522         raise TypeError("Argument must be either a string, dict or module but it is: %s" % m)
523 
524 def lambdastr(args, expr, printer=None, dummify=None):
525     """
526     Returns a string that can be evaluated to a lambda function.
527 
528     Examples
529     ========
530 
531     >>> from sympy.abc import x, y, z
532     >>> from sympy.utilities.lambdify import lambdastr
533     >>> lambdastr(x, x**2)
534     'lambda x: (x**2)'
535     >>> lambdastr((x,y,z), [z,y,x])
536     'lambda x,y,z: ([z, y, x])'
537 
538     Although tuples may not appear as arguments to lambda in Python 3,
539     lambdastr will create a lambda function that will unpack the original
540     arguments so that nested arguments can be handled:
541 
542     >>> lambdastr((x, (y, z)), x + y)
543     'lambda _0,_1: (lambda x,y,z: (x + y))(_0,_1[0],_1[1])'
544     """
545     # Transforming everything to strings.
546     from sympy.matrices import DeferredVector
547     from sympy import Dummy, sympify, Symbol, Function, flatten, Derivative, Basic
548 
549     if printer is not None:
550         if inspect.isfunction(printer):
551             lambdarepr = printer
552         else:
553             if inspect.isclass(printer):
554                 lambdarepr = lambda expr: printer().doprint(expr)
555             else:
556                 lambdarepr = lambda expr: printer.doprint(expr)
557     else:
558         #XXX: This has to be done here because of circular imports
559         from sympy.printing.lambdarepr import lambdarepr
560 
561     def sub_args(args, dummies_dict):
562         if isinstance(args, str):
563             return args
564         elif isinstance(args, DeferredVector):
565             return str(args)
566         elif iterable(args):
567             dummies = flatten([sub_args(a, dummies_dict) for a in args])
568             return ",".join(str(a) for a in dummies)
569         else:
570             # replace these with Dummy symbols
571             if isinstance(args, (Function, Symbol, Derivative)):
572                 dummies = Dummy()
573                 dummies_dict.update({args : dummies})
574                 return str(dummies)
575             else:
576                 return str(args)
577 
578     def sub_expr(expr, dummies_dict):
579         try:
580             expr = sympify(expr).xreplace(dummies_dict)
581         except Exception:
582             if isinstance(expr, DeferredVector):
583                 pass
584             elif isinstance(expr, dict):
585                 k = [sub_expr(sympify(a), dummies_dict) for a in expr.keys()]
586                 v = [sub_expr(sympify(a), dummies_dict) for a in expr.values()]
587                 expr = dict(zip(k, v))
588             elif isinstance(expr, tuple):
589                 expr = tuple(sub_expr(sympify(a), dummies_dict) for a in expr)
590             elif isinstance(expr, list):
591                 expr = [sub_expr(sympify(a), dummies_dict) for a in expr]
592         return expr
593 
594     # Transform args
595     def isiter(l):
596         return iterable(l, exclude=(str, DeferredVector, NotIterable))
597 
598     def flat_indexes(iterable):
599         n = 0
600 
601         for el in iterable:
602             if isiter(el):
603                 for ndeep in flat_indexes(el):
604                     yield (n,) + ndeep
605             else:
606                 yield (n,)
607 
608             n += 1
609 
610     if dummify is None:
611         dummify = any(isinstance(a, Basic) and
612             a.atoms(Function, Derivative) for a in (
613             args if isiter(args) else [args]))
614 
615     if isiter(args) and any(isiter(i) for i in args):
616         dum_args = [str(Dummy(str(i))) for i in range(len(args))]
617 
618         indexed_args = ','.join([
619             dum_args[ind[0]] + ''.join(["[%s]" % k for k in ind[1:]])
620                     for ind in flat_indexes(args)])
621 
622         lstr = lambdastr(flatten(args), expr, printer=printer, dummify=dummify)
623 
624         return 'lambda %s: (%s)(%s)' % (','.join(dum_args), lstr, indexed_args)
625 
626     dummies_dict = {}
627     if dummify:
628         args = sub_args(args, dummies_dict)
629     else:
630         if isinstance(args, str):
631             pass
632         elif iterable(args, exclude=DeferredVector):
633             args = ",".join(str(a) for a in args)
634 
635     # Transform expr
636     if dummify:
637         if isinstance(expr, str):
638             pass
639         else:
640             expr = sub_expr(expr, dummies_dict)
641     expr = lambdarepr(expr)
642     return "lambda %s: (%s)" % (args, expr)
643 
644 class _EvaluatorPrinter(object):
645     def __init__(self, printer=None, dummify=False):
646         self._dummify = dummify
647 
648         #XXX: This has to be done here because of circular imports
649         from sympy.printing.lambdarepr import LambdaPrinter
650 
651         if printer is None:
652             printer = LambdaPrinter()
653 
654         if inspect.isfunction(printer):
655             self._exprrepr = printer
656         else:
657             if inspect.isclass(printer):
658                 printer = printer()
659 
660             self._exprrepr = printer.doprint
661 
662             if hasattr(printer, '_print_Symbol'):
663                 symbolrepr = printer._print_Symbol
664 
665             if hasattr(printer, '_print_Dummy'):
666                 dummyrepr = printer._print_Dummy
667 
668         # Used to print the generated function arguments in a standard way
669         self._argrepr = LambdaPrinter().doprint
670 
671     def doprint(self, funcname, args, expr):
672         """Returns the function definition code as a string."""
673         from sympy import Dummy
674 
675         funcbody = []
676 
677         if not iterable(args):
678             args = [args]
679 
680         argstrs, expr = self._preprocess(args, expr)
681 
682         # Generate argument unpacking and final argument list
683         funcargs = []
684         unpackings = []
685 
686         for argstr in argstrs:
687             if iterable(argstr):
688                 funcargs.append(self._argrepr(Dummy()))
689                 unpackings.extend(self._print_unpacking(argstr, funcargs[-1]))
690             else:
691                 funcargs.append(argstr)
692 
693         funcsig = 'def {}({}):'.format(funcname, ', '.join(funcargs))
694 
695         # Wrap input arguments before unpacking
696         funcbody.extend(self._print_funcargwrapping(funcargs))
697 
698         funcbody.extend(unpackings)
699 
700         funcbody.append('return ({})'.format(self._exprrepr(expr)))
701 
702         funclines = [funcsig]
703         funclines.extend('    ' + line for line in funcbody)
704 
705         return '\n'.join(funclines) + '\n'
706 
707     if PY3:
708         @classmethod
709         def _is_safe_ident(cls, ident):
710             return isinstance(ident, str) and ident.isidentifier() \
711                     and not keyword.iskeyword(ident)
712     else:
713         _safe_ident_re = re.compile('^[a-zA-Z_][a-zA-Z0-9_]*$')
714 
715         @classmethod
716         def _is_safe_ident(cls, ident):
717             return isinstance(ident, str) and cls._safe_ident_re.match(ident) \
718                 and not (keyword.iskeyword(ident) or ident == 'None')
719 
720     def _preprocess(self, args, expr):
721         """Preprocess args, expr to replace arguments that do not map
722         to valid Python identifiers.
723 
724         Returns string form of args, and updated expr.
725         """
726         from sympy import Dummy, Function, flatten, Derivative, ordered, Basic
727         from sympy.matrices import DeferredVector
728 
729         # Args of type Dummy can cause name collisions with args
730         # of type Symbol.  Force dummify of everything in this
731         # situation.
732         dummify = self._dummify or any(
733             isinstance(arg, Dummy) for arg in flatten(args))
734 
735         argstrs = [None]*len(args)
736         for arg, i in reversed(list(ordered(zip(args, range(len(args)))))):
737             if iterable(arg):
738                 s, expr = self._preprocess(arg, expr)
739             elif isinstance(arg, DeferredVector):
740                 s = str(arg)
741             elif isinstance(arg, Basic) and arg.is_symbol:
742                 s = self._argrepr(arg)
743                 if dummify or not self._is_safe_ident(s):
744                     dummy = Dummy()
745                     s = self._argrepr(dummy)
746                     expr = self._subexpr(expr, {arg: dummy})
747             elif dummify or isinstance(arg, (Function, Derivative)):
748                 dummy = Dummy()
749                 s = self._argrepr(dummy)
750                 expr = self._subexpr(expr, {arg: dummy})
751             else:
752                 s = str(arg)
753             argstrs[i] = s
754         return argstrs, expr
755 
756     def _subexpr(self, expr, dummies_dict):
757         from sympy.matrices import DeferredVector
758         from sympy import sympify
759 
760         try:
761             expr = sympify(expr).xreplace(dummies_dict)
762         except AttributeError:
763             if isinstance(expr, DeferredVector):
764                 pass
765             elif isinstance(expr, dict):
766                 k = [self._subexpr(sympify(a), dummies_dict) for a in expr.keys()]
767                 v = [self._subexpr(sympify(a), dummies_dict) for a in expr.values()]
768                 expr = dict(zip(k, v))
769             elif isinstance(expr, tuple):
770                 expr = tuple(self._subexpr(sympify(a), dummies_dict) for a in expr)
771             elif isinstance(expr, list):
772                 expr = [self._subexpr(sympify(a), dummies_dict) for a in expr]
773         return expr
774 
775     def _print_funcargwrapping(self, args):
776         """Generate argument wrapping code.
777 
778         args is the argument list of the generated function (strings).
779 
780         Return value is a list of lines of code that will be inserted  at
781         the beginning of the function definition.
782         """
783         return []
784 
785     def _print_unpacking(self, unpackto, arg):
786         """Generate argument unpacking code.
787 
788         arg is the function argument to be unpacked (a string), and
789         unpackto is a list or nested lists of the variable names (strings) to
790         unpack to.
791         """
792         def unpack_lhs(lvalues):
793             return '[{}]'.format(', '.join(
794                 unpack_lhs(val) if iterable(val) else val for val in lvalues))
795 
796         return ['{} = {}'.format(unpack_lhs(unpackto), arg)]
797 
798 class _TensorflowEvaluatorPrinter(_EvaluatorPrinter):
799     def _print_unpacking(self, lvalues, rvalue):
800         """Generate argument unpacking code.
801 
802         This method is used when the input value is not interable,
803         but can be indexed (see issue #14655).
804         """
805         from sympy import flatten
806 
807         def flat_indexes(elems):
808             n = 0
809 
810             for el in elems:
811                 if iterable(el):
812                     for ndeep in flat_indexes(el):
813                         yield (n,) + ndeep
814                 else:
815                     yield (n,)
816 
817                 n += 1
818 
819         indexed = ', '.join('{}[{}]'.format(rvalue, ']['.join(map(str, ind)))
820                                 for ind in flat_indexes(lvalues))
821 
822         return ['[{}] = [{}]'.format(', '.join(flatten(lvalues)), indexed)]
823 
824 def _imp_namespace(expr, namespace=None):
825     """ Return namespace dict with function implementations
826 
827     We need to search for functions in anything that can be thrown at
828     us - that is - anything that could be passed as `expr`.  Examples
829     include sympy expressions, as well as tuples, lists and dicts that may
830     contain sympy expressions.
831 
832     Parameters
833     ----------
834     expr : object
835        Something passed to lambdify, that will generate valid code from
836        ``str(expr)``.
837     namespace : None or mapping
838        Namespace to fill.  None results in new empty dict
839 
840     Returns
841     -------
842     namespace : dict
843        dict with keys of implemented function names within `expr` and
844        corresponding values being the numerical implementation of
845        function
846 
847     Examples
848     ========
849 
850     >>> from sympy.abc import x
851     >>> from sympy.utilities.lambdify import implemented_function, _imp_namespace
852     >>> from sympy import Function
853     >>> f = implemented_function(Function('f'), lambda x: x+1)
854     >>> g = implemented_function(Function('g'), lambda x: x*10)
855     >>> namespace = _imp_namespace(f(g(x)))
856     >>> sorted(namespace.keys())
857     ['f', 'g']
858     """
859     # Delayed import to avoid circular imports
860     from sympy.core.function import FunctionClass
861     if namespace is None:
862         namespace = {}
863     # tuples, lists, dicts are valid expressions
864     if is_sequence(expr):
865         for arg in expr:
866             _imp_namespace(arg, namespace)
867         return namespace
868     elif isinstance(expr, dict):
869         for key, val in expr.items():
870             # functions can be in dictionary keys
871             _imp_namespace(key, namespace)
872             _imp_namespace(val, namespace)
873         return namespace
874     # sympy expressions may be Functions themselves
875     func = getattr(expr, 'func', None)
876     if isinstance(func, FunctionClass):
877         imp = getattr(func, '_imp_', None)
878         if imp is not None:
879             name = expr.func.__name__
880             if name in namespace and namespace[name] != imp:
881                 raise ValueError('We found more than one '
882                                  'implementation with name '
883                                  '"%s"' % name)
884             namespace[name] = imp
885     # and / or they may take Functions as arguments
886     if hasattr(expr, 'args'):
887         for arg in expr.args:
888             _imp_namespace(arg, namespace)
889     return namespace
890 
891 
892 def implemented_function(symfunc, implementation):
893     """ Add numerical ``implementation`` to function ``symfunc``.
894 
895     ``symfunc`` can be an ``UndefinedFunction`` instance, or a name string.
896     In the latter case we create an ``UndefinedFunction`` instance with that
897     name.
898 
899     Be aware that this is a quick workaround, not a general method to create
900     special symbolic functions. If you want to create a symbolic function to be
901     used by all the machinery of SymPy you should subclass the ``Function``
902     class.
903 
904     Parameters
905     ----------
906     symfunc : ``str`` or ``UndefinedFunction`` instance
907        If ``str``, then create new ``UndefinedFunction`` with this as
908        name.  If `symfunc` is an Undefined function, create a new function
909        with the same name and the implemented function attached.
910     implementation : callable
911        numerical implementation to be called by ``evalf()`` or ``lambdify``
912 
913     Returns
914     -------
915     afunc : sympy.FunctionClass instance
916        function with attached implementation
917 
918     Examples
919     ========
920 
921     >>> from sympy.abc import x
922     >>> from sympy.utilities.lambdify import lambdify, implemented_function
923     >>> from sympy import Function
924     >>> f = implemented_function('f', lambda x: x+1)
925     >>> lam_f = lambdify(x, f(x))
926     >>> lam_f(4)
927     5
928     """
929     # Delayed import to avoid circular imports
930     from sympy.core.function import UndefinedFunction
931     # if name, create function to hold implementation
932     _extra_kwargs = {}
933     if isinstance(symfunc, UndefinedFunction):
934         _extra_kwargs = symfunc._extra_kwargs
935         symfunc = symfunc.__name__
936     if isinstance(symfunc, string_types):
937         # Keyword arguments to UndefinedFunction are added as attributes to
938         # the created class.
939         symfunc = UndefinedFunction(symfunc, _imp_=staticmethod(implementation), **_extra_kwargs)
940     elif not isinstance(symfunc, UndefinedFunction):
941         raise ValueError('symfunc should be either a string or'
942                          ' an UndefinedFunction instance.')
943     return symfunc

</code><intended_behavior>Ensure that when `lambdify` is converting sympy expressions (in this case, matrix inversion) into numpy functions, it correctly handles sympy's symbolic matrices by generating numpy-compatible numeric matrices without triggering type or unsupported operation errors (e.g., 'bitwise_xor'). This may involve adding or refining a check or conversion step specifically for matrix inversion operations to ensure compatibility with numpy's expectations.</intended_behavior>]
2025-10-17 20:19:14.221 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 20:19:14.221 | INFO     | Search-only: skipping patch selection
2025-10-17 20:19:14.347 | INFO     | Task sympy__sympy-15586 completed successfully.
2025-10-17 20:19:14.348 | INFO     | No patch generated. You can try running ACR again.
