2025-10-17 14:36:22.754 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 14:36:26.850 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=349, output_tokens=12, cost=0.003850
2025-10-17 14:36:40.087 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=529, output_tokens=588, cost=0.022930
2025-10-17 14:36:41.590 | INFO     | registered non reproducing test 0
2025-10-17 14:36:58.140 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1395, output_tokens=659, cost=0.033720
2025-10-17 14:36:59.629 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:37:09.460 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=655, output_tokens=368, cost=0.017590
2025-10-17 14:37:09.468 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:37:12.745 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=74, cost=0.009440
2025-10-17 14:37:12.747 | DEBUG    | Extracted a valid json.
2025-10-17 14:37:12.747 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"constrained_layout\")",
        "search_method_in_class(\"set_title\", \"Axes\")",
        "search_code(\"wrap=True\")",
        "search_method_in_class(\"suptitle\", \"Figure\")",
        "search_code(\"get_window_extent\")"
    ],
    "bug_locations": []
}
2025-10-17 14:37:12.918 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:37:12.918 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:37:29.337 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2646, output_tokens=719, cost=0.048030
2025-10-17 14:37:29.344 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:37:37.930 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3581, output_tokens=352, cost=0.046370
2025-10-17 14:37:37.938 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:37:45.008 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=294, cost=0.015880
2025-10-17 14:37:45.009 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 14:37:45.009 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 14:37:52.063 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=294, cost=0.015880
2025-10-17 14:37:52.065 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 14:37:52.065 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 14:38:00.195 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=301, cost=0.016090
2025-10-17 14:38:00.196 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 14:38:00.196 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 14:38:08.143 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=301, cost=0.016090
2025-10-17 14:38:08.144 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 14:38:08.144 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 14:38:16.538 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=706, output_tokens=294, cost=0.015880
2025-10-17 14:38:16.539 | DEBUG    | Bug location not detailed enough. Each location must contain at least a class or a method or a file.. Will retry.
2025-10-17 14:38:16.540 | DEBUG    | Agent proxy return the following json: None
2025-10-17 14:38:16.540 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 14:38:16.541 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 14:38:16.541 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:38:18.489 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3960, output_tokens=26, cost=0.040380
2025-10-17 14:38:18.492 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:38:22.072 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=380, output_tokens=32, cost=0.004760
2025-10-17 14:38:22.073 | DEBUG    | Extracted a valid json.
2025-10-17 14:38:22.079 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"Figure\")", "search_method_in_class(\"layout\", \"Figure\")"],
    "bug_locations":[]
}
2025-10-17 14:38:22.118 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 14:38:22.119 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 14:38:39.486 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4946, output_tokens=588, cost=0.067100
2025-10-17 14:38:39.497 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 14:38:46.140 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5750, output_tokens=229, cost=0.064370
2025-10-17 14:38:46.146 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 14:38:52.506 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=583, output_tokens=205, cost=0.011980
2025-10-17 14:38:52.507 | DEBUG    | Extracted a valid json.
2025-10-17 14:38:52.507 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/figure.py",
            "class": "Figure",
            "method": "__init__",
            "intended_behavior": "Implementing a pre-rendering check that accurately measures the vertical space requirements of titles when wrap=True is specified."
        },
        {
            "file": "lib/matplotlib/figure.py",
            "class": "Figure",
            "method": "set_constrained_layout",
            "intended_behavior": "Adjusting the constrained layout calculations to incorporate dynamic measurements for wrapped text, ensuring sufficient space to prevent overlap or clipping."
        },
        {
            "file": "lib/matplotlib/figure.py",
            "class": "Figure",
            "method": "execute_constrained_layout",
            "intended_behavior": "Retaining the functionality of the constrained layout for all other elements, only adding the capability to dynamically adjust for wrapped text as described."
        }
    ]
}
2025-10-17 14:38:52.511 | DEBUG    | Found override of __init__ in FigureBase
2025-10-17 14:38:52.512 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x7ea0c4f22c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x7e9fd295fb00>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x7e9fd4b7b240>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x7e9fd295fb00>, <app.raw_tasks.RawSweTask object at 0x7e9fd295fb30>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x7e9fd4b7b2e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x7e9fd26e4b60>
    └ <function run_task_in_subprocess at 0x7e9fd4b7b4c0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x7e9fd26e4b60>
    │        │      └ <function run_raw_task at 0x7e9fd4b7b560>
    │        └ <function ProcessPoolExecutor.submit at 0x7ea0c4842020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x7ea0c4841da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x7ea0c4841ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x7ea0c4841f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x7ea0c4a04ea0>
    └ <ForkProcess name='ForkProcess-226' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-226' parent=307479 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x7ea0c4a760c0>)>
    │    │        └ <ForkProcess name='ForkProcess-226' parent=307479 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-226' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-226' parent=307479 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-226' parent=307479 started>
    │    └ <function Popen._launch at 0x7e9fd2ad4ea0>
    └ <multiprocessing.popen_fork.Popen object at 0x7e9fd314e960>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x7ea0c4a058a0>
           └ <ForkProcess name='ForkProcess-226' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x7ea0c4a04e00>
    └ <ForkProcess name='ForkProcess-226' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-226' parent=307479 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x7e9fd3864920>, <multiprocessing.queues.SimpleQueue object at 0x7e9fd2b901...
    │    │        └ <ForkProcess name='ForkProcess-226' parent=307479 started>
    │    └ <function _process_worker at 0x7ea0c48411c0>
    └ <ForkProcess name='ForkProcess-226' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x7e9fd4fdd670>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x7e9fd314c650>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x7e9fd4fdd670>
        │         └ <function run_raw_task at 0x7e9fd4b7b560>
        └ <concurrent.futures.process._CallItem object at 0x7e9fd4fdd670>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output3/matplotlib__matplotlib-25346_2025-10-17_14-36-22'
             │            │    └ <function RawSweTask.to_task at 0x7e9fd4b7a520>
             │            └ <app.raw_tasks.RawSweTask object at 0x7e9fd314c650>
             └ <function do_inference at 0x7e9fd4b7b740>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x7e9fd4bd5080>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x7e9fd5360ae0>
       │                 │         │            └ SweTask(task_id='matplotlib__matplotlib-25346', problem_statement='[Bug]: constrained layout with wrapped titles\n### Bug sum...
       │                 │         └ <app.manage.ProjectApiManager object at 0x7e9fd314fd10>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output3/matplotlib__matplotlib-25346_2025-10-17_14-36-22/output_0')
       └ <function _run_one_task at 0x7e9fd4bd6660>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x7e9fd4fea840>
                                  │           └ <app.search.search_manage.SearchManager object at 0x7e9fd314ff80>
                                  └ <app.manage.ProjectApiManager object at 0x7e9fd314fd10>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'lib/matplotlib/figure.py', 'class': 'Figure', 'method': '__init__', 'intended_behavior': 'Implementing a pre-render...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x7e9fd4fea7a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x7e9fd532bf50>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x7e9fd314ff80>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ '__init__'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__...
    │    │                      │   └ 'Figure'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__...
    │    └ <function SearchBackend._get_inherited_methods at 0x7e9fd4fea700>
    └ <app.search.search_backend.SearchBackend object at 0x7e9fd532bf50>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'FigureBase', 'method_name': '__init__'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x7e9fd4fe9e40>
                                  └ <app.search.search_backend.SearchBackend object at 0x7e9fd532bf50>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x7e9fd532bf50>, {'class_name': 'FigureBase', 'method_name': '__init__'})
           └ <function SearchBackend.search_method_in_class at 0x7e9fd4fe9da0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-17 14:38:52.530 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>__init__</method>
<code>
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()

</code><intended_behavior>Implementing a pre-rendering check that accurately measures the vertical space requirements of titles when wrap=True is specified.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>set_constrained_layout</method>
<code>
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True

</code><intended_behavior>Adjusting the constrained layout calculations to incorporate dynamic measurements for wrapped text, ensuring sufficient space to prevent overlap or clipping.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>execute_constrained_layout</method>
<code>
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)

</code><intended_behavior>Retaining the functionality of the constrained layout for all other elements, only adding the capability to dynamically adjust for wrapped text as described.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:38:52.530 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>__init__</method>
<code>
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()

</code><intended_behavior>Implementing a pre-rendering check that accurately measures the vertical space requirements of titles when wrap=True is specified.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>set_constrained_layout</method>
<code>
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True

</code><intended_behavior>Adjusting the constrained layout calculations to incorporate dynamic measurements for wrapped text, ensuring sufficient space to prevent overlap or clipping.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>execute_constrained_layout</method>
<code>
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)

</code><intended_behavior>Retaining the functionality of the constrained layout for all other elements, only adding the capability to dynamically adjust for wrapped text as described.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 14:38:52.531 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 14:38:52.531 | INFO     | Search-only: skipping patch selection
2025-10-17 14:38:52.677 | INFO     | Task matplotlib__matplotlib-25346 completed successfully.
2025-10-17 14:38:52.678 | INFO     | No patch generated. You can try running ACR again.
