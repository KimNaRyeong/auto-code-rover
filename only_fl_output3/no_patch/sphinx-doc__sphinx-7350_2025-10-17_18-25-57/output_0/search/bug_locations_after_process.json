[
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/ext/autodoc/__init__.py",
        "start": 413,
        "end": 426,
        "class_name": "Documenter",
        "method_name": "add_directive_header",
        "code": "413     def add_directive_header(self, sig: str) -> None:\n414         \"\"\"Add the directive header and options to the generated content.\"\"\"\n415         domain = getattr(self, 'domain', 'py')\n416         directive = getattr(self, 'directivetype', self.objtype)\n417         name = self.format_name()\n418         sourcename = self.get_sourcename()\n419         self.add_line('.. %s:%s:: %s%s' % (domain, directive, name, sig),\n420                       sourcename)\n421         if self.options.noindex:\n422             self.add_line('   :noindex:', sourcename)\n423         if self.objpath:\n424             # Be explicit about the module, this is necessary since .. class::\n425             # etc. don't support a prepended module name\n426             self.add_line('   :module: %s' % self.modname, sourcename)\n",
        "intended_behavior": "This method currently handles `:noindex:` for general directives. Given the issue with `Attributes:` being ignored by the `:noindex:` option, it suggests that `Documenter` or similar classes responsible for processing docstring directives into reStructuredText might need to be adjusted or extended to ensure `Attributes:` directives within Napoleon-parsed docstrings respect the `:noindex:` option. Specifically, when processing `Attributes:` directives, the presence of the `:noindex:` option should prevent these attributes from being added to the index."
    },
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/ext/autodoc/__init__.py",
        "start": 203,
        "end": 766,
        "class_name": "Documenter",
        "method_name": null,
        "code": "203 class Documenter:\n204     \"\"\"\n205     A Documenter knows how to autodocument a single object type.  When\n206     registered with the AutoDirective, it will be used to document objects\n207     of that type when needed by autodoc.\n208 \n209     Its *objtype* attribute selects what auto directive it is assigned to\n210     (the directive name is 'auto' + objtype), and what directive it generates\n211     by default, though that can be overridden by an attribute called\n212     *directivetype*.\n213 \n214     A Documenter has an *option_spec* that works like a docutils directive's;\n215     in fact, it will be used to parse an auto directive's options that matches\n216     the documenter.\n217     \"\"\"\n218     #: name by which the directive is called (auto...) and the default\n219     #: generated directive name\n220     objtype = 'object'\n221     #: indentation by which to indent the directive content\n222     content_indent = '   '\n223     #: priority if multiple documenters return True from can_document_member\n224     priority = 0\n225     #: order if autodoc_member_order is set to 'groupwise'\n226     member_order = 0\n227     #: true if the generated content may contain titles\n228     titles_allowed = False\n229 \n230     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n231 \n232     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n233         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n234         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n235 \n236     @classmethod\n237     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n238                             ) -> bool:\n239         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n240         raise NotImplementedError('must be implemented in subclasses')\n241 \n242     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n243         self.directive = directive\n244         self.env = directive.env    # type: BuildEnvironment\n245         self.options = directive.genopt\n246         self.name = name\n247         self.indent = indent\n248         # the module and object path within the module, and the fully\n249         # qualified name (all set after resolve_name succeeds)\n250         self.modname = None         # type: str\n251         self.module = None          # type: ModuleType\n252         self.objpath = None         # type: List[str]\n253         self.fullname = None        # type: str\n254         # extra signature items (arguments and return annotation,\n255         # also set after resolve_name succeeds)\n256         self.args = None            # type: str\n257         self.retann = None          # type: str\n258         # the object to document (set after import_object succeeds)\n259         self.object = None          # type: Any\n260         self.object_name = None     # type: str\n261         # the parent/owner of the object to document\n262         self.parent = None          # type: Any\n263         # the module analyzer to get at attribute docs, or None\n264         self.analyzer = None        # type: ModuleAnalyzer\n265 \n266     @property\n267     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n268         \"\"\"Returns registered Documenter classes\"\"\"\n269         return self.env.app.registry.documenters\n270 \n271     def add_line(self, line: str, source: str, *lineno: int) -> None:\n272         \"\"\"Append one line of generated reST to the output.\"\"\"\n273         self.directive.result.append(self.indent + line, source, *lineno)\n274 \n275     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n276                      ) -> Tuple[str, List[str]]:\n277         \"\"\"Resolve the module and name of the object to document given by the\n278         arguments and the current module/class.\n279 \n280         Must return a pair of the module name and a chain of attributes; for\n281         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n282         ``zipfile.ZipFile.open`` method.\n283         \"\"\"\n284         raise NotImplementedError('must be implemented in subclasses')\n285 \n286     def parse_name(self) -> bool:\n287         \"\"\"Determine what module to import and what attribute to document.\n288 \n289         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n290         *self.args* and *self.retann* if parsing and resolving was successful.\n291         \"\"\"\n292         # first, parse the definition -- auto directives for classes and\n293         # functions can contain a signature which is then used instead of\n294         # an autogenerated one\n295         try:\n296             explicit_modname, path, base, args, retann = \\\n297                 py_ext_sig_re.match(self.name).groups()\n298         except AttributeError:\n299             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n300                            type='autodoc')\n301             return False\n302 \n303         # support explicit module and class name separation via ::\n304         if explicit_modname is not None:\n305             modname = explicit_modname[:-2]\n306             parents = path.rstrip('.').split('.') if path else []\n307         else:\n308             modname = None\n309             parents = []\n310 \n311         self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n312 \n313         if not self.modname:\n314             return False\n315 \n316         self.args = args\n317         self.retann = retann\n318         self.fullname = (self.modname or '') + \\\n319                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n320         return True\n321 \n322     def import_object(self) -> bool:\n323         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n324         it as *self.object*.\n325 \n326         Returns True if successful, False if an error occurred.\n327         \"\"\"\n328         with mock(self.env.config.autodoc_mock_imports):\n329             try:\n330                 ret = import_object(self.modname, self.objpath, self.objtype,\n331                                     attrgetter=self.get_attr,\n332                                     warningiserror=self.env.config.autodoc_warningiserror)\n333                 self.module, self.parent, self.object_name, self.object = ret\n334                 return True\n335             except ImportError as exc:\n336                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n337                 self.env.note_reread()\n338                 return False\n339 \n340     def get_real_modname(self) -> str:\n341         \"\"\"Get the real module name of an object to document.\n342 \n343         It can differ from the name of the module through which the object was\n344         imported.\n345         \"\"\"\n346         return self.get_attr(self.object, '__module__', None) or self.modname\n347 \n348     def check_module(self) -> bool:\n349         \"\"\"Check if *self.object* is really defined in the module given by\n350         *self.modname*.\n351         \"\"\"\n352         if self.options.imported_members:\n353             return True\n354 \n355         subject = inspect.unpartial(self.object)\n356         modname = self.get_attr(subject, '__module__', None)\n357         if modname and modname != self.modname:\n358             return False\n359         return True\n360 \n361     def format_args(self, **kwargs: Any) -> str:\n362         \"\"\"Format the argument signature of *self.object*.\n363 \n364         Should return None if the object does not have a signature.\n365         \"\"\"\n366         return None\n367 \n368     def format_name(self) -> str:\n369         \"\"\"Format the name of *self.object*.\n370 \n371         This normally should be something that can be parsed by the generated\n372         directive, but doesn't need to be (Sphinx will display it unparsed\n373         then).\n374         \"\"\"\n375         # normally the name doesn't contain the module (except for module\n376         # directives of course)\n377         return '.'.join(self.objpath) or self.modname\n378 \n379     def format_signature(self, **kwargs: Any) -> str:\n380         \"\"\"Format the signature (arguments and return annotation) of the object.\n381 \n382         Let the user process it via the ``autodoc-process-signature`` event.\n383         \"\"\"\n384         if self.args is not None:\n385             # signature given explicitly\n386             args = \"(%s)\" % self.args\n387         else:\n388             # try to introspect the signature\n389             try:\n390                 try:\n391                     args = self.format_args(**kwargs)\n392                 except TypeError:\n393                     # retry without arguments for old documenters\n394                     args = self.format_args()\n395             except Exception as err:\n396                 logger.warning(__('error while formatting arguments for %s: %s') %\n397                                (self.fullname, err), type='autodoc')\n398                 args = None\n399 \n400         retann = self.retann\n401 \n402         result = self.env.events.emit_firstresult('autodoc-process-signature',\n403                                                   self.objtype, self.fullname,\n404                                                   self.object, self.options, args, retann)\n405         if result:\n406             args, retann = result\n407 \n408         if args is not None:\n409             return args + ((' -> %s' % retann) if retann else '')\n410         else:\n411             return ''\n412 \n413     def add_directive_header(self, sig: str) -> None:\n414         \"\"\"Add the directive header and options to the generated content.\"\"\"\n415         domain = getattr(self, 'domain', 'py')\n416         directive = getattr(self, 'directivetype', self.objtype)\n417         name = self.format_name()\n418         sourcename = self.get_sourcename()\n419         self.add_line('.. %s:%s:: %s%s' % (domain, directive, name, sig),\n420                       sourcename)\n421         if self.options.noindex:\n422             self.add_line('   :noindex:', sourcename)\n423         if self.objpath:\n424             # Be explicit about the module, this is necessary since .. class::\n425             # etc. don't support a prepended module name\n426             self.add_line('   :module: %s' % self.modname, sourcename)\n427 \n428     def get_doc(self, encoding: str = None, ignore: int = 1) -> List[List[str]]:\n429         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n430         if encoding is not None:\n431             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n432                           % self.__class__.__name__,\n433                           RemovedInSphinx40Warning)\n434         docstring = getdoc(self.object, self.get_attr,\n435                            self.env.config.autodoc_inherit_docstrings)\n436         if docstring:\n437             tab_width = self.directive.state.document.settings.tab_width\n438             return [prepare_docstring(docstring, ignore, tab_width)]\n439         return []\n440 \n441     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n442         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n443         for docstringlines in docstrings:\n444             if self.env.app:\n445                 # let extensions preprocess docstrings\n446                 self.env.app.emit('autodoc-process-docstring',\n447                                   self.objtype, self.fullname, self.object,\n448                                   self.options, docstringlines)\n449             yield from docstringlines\n450 \n451     def get_sourcename(self) -> str:\n452         if self.analyzer:\n453             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)\n454         return 'docstring of %s' % self.fullname\n455 \n456     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n457         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n458         # set sourcename and add content from attribute documentation\n459         sourcename = self.get_sourcename()\n460         if self.analyzer:\n461             attr_docs = self.analyzer.find_attr_docs()\n462             if self.objpath:\n463                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n464                 if key in attr_docs:\n465                     no_docstring = True\n466                     docstrings = [attr_docs[key]]\n467                     for i, line in enumerate(self.process_doc(docstrings)):\n468                         self.add_line(line, sourcename, i)\n469 \n470         # add content from docstrings\n471         if not no_docstring:\n472             docstrings = self.get_doc()\n473             if not docstrings:\n474                 # append at least a dummy docstring, so that the event\n475                 # autodoc-process-docstring is fired and can add some\n476                 # content if desired\n477                 docstrings.append([])\n478             for i, line in enumerate(self.process_doc(docstrings)):\n479                 self.add_line(line, sourcename, i)\n480 \n481         # add additional content (e.g. from document), if present\n482         if more_content:\n483             for line, src in zip(more_content.data, more_content.items):\n484                 self.add_line(line, src[0], src[1])\n485 \n486     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n487         \"\"\"Return `(members_check_module, members)` where `members` is a\n488         list of `(membername, member)` pairs of the members of *self.object*.\n489 \n490         If *want_all* is True, return all members.  Else, only return those\n491         members given by *self.options.members* (which may also be none).\n492         \"\"\"\n493         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n494         if not want_all:\n495             if not self.options.members:\n496                 return False, []\n497             # specific members given\n498             selected = []\n499             for name in self.options.members:\n500                 if name in members:\n501                     selected.append((name, members[name].value))\n502                 else:\n503                     logger.warning(__('missing attribute %s in object %s') %\n504                                    (name, self.fullname), type='autodoc')\n505             return False, sorted(selected)\n506         elif self.options.inherited_members:\n507             return False, sorted((m.name, m.value) for m in members.values())\n508         else:\n509             return False, sorted((m.name, m.value) for m in members.values()\n510                                  if m.directly_defined)\n511 \n512     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n513                        ) -> List[Tuple[str, Any, bool]]:\n514         \"\"\"Filter the given member list.\n515 \n516         Members are skipped if\n517 \n518         - they are private (except if given explicitly or the private-members\n519           option is set)\n520         - they are special methods (except if given explicitly or the\n521           special-members option is set)\n522         - they are undocumented (except if the undoc-members option is set)\n523 \n524         The user can override the skipping decision by connecting to the\n525         ``autodoc-skip-member`` event.\n526         \"\"\"\n527         def is_filtered_inherited_member(name: str) -> bool:\n528             if inspect.isclass(self.object):\n529                 for cls in self.object.__mro__:\n530                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n531                         # given member is a member of specified *super class*\n532                         return True\n533                     elif name in cls.__dict__:\n534                         return False\n535 \n536             return False\n537 \n538         ret = []\n539 \n540         # search for members in source code too\n541         namespace = '.'.join(self.objpath)  # will be empty for modules\n542 \n543         if self.analyzer:\n544             attr_docs = self.analyzer.find_attr_docs()\n545         else:\n546             attr_docs = {}\n547 \n548         # process members and determine which to skip\n549         for (membername, member) in members:\n550             # if isattr is True, the member is documented as an attribute\n551             if member is INSTANCEATTR:\n552                 isattr = True\n553             else:\n554                 isattr = False\n555 \n556             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings)\n557 \n558             # if the member __doc__ is the same as self's __doc__, it's just\n559             # inherited and therefore not the member's doc\n560             cls = self.get_attr(member, '__class__', None)\n561             if cls:\n562                 cls_doc = self.get_attr(cls, '__doc__', None)\n563                 if cls_doc == doc:\n564                     doc = None\n565             has_doc = bool(doc)\n566 \n567             metadata = extract_metadata(doc)\n568             if 'private' in metadata:\n569                 # consider a member private if docstring has \"private\" metadata\n570                 isprivate = True\n571             else:\n572                 isprivate = membername.startswith('_')\n573 \n574             keep = False\n575             if want_all and membername.startswith('__') and \\\n576                     membername.endswith('__') and len(membername) > 4:\n577                 # special __methods__\n578                 if self.options.special_members is ALL:\n579                     if membername == '__doc__':\n580                         keep = False\n581                     elif is_filtered_inherited_member(membername):\n582                         keep = False\n583                     else:\n584                         keep = has_doc or self.options.undoc_members\n585                 elif self.options.special_members:\n586                     if membername in self.options.special_members:\n587                         keep = has_doc or self.options.undoc_members\n588             elif (namespace, membername) in attr_docs:\n589                 if want_all and isprivate:\n590                     # ignore members whose name starts with _ by default\n591                     keep = self.options.private_members\n592                 else:\n593                     # keep documented attributes\n594                     keep = True\n595                 isattr = True\n596             elif want_all and isprivate:\n597                 # ignore members whose name starts with _ by default\n598                 keep = self.options.private_members and \\\n599                     (has_doc or self.options.undoc_members)\n600             else:\n601                 if self.options.members is ALL and is_filtered_inherited_member(membername):\n602                     keep = False\n603                 else:\n604                     # ignore undocumented members if :undoc-members: is not given\n605                     keep = has_doc or self.options.undoc_members\n606 \n607             # give the user a chance to decide whether this member\n608             # should be skipped\n609             if self.env.app:\n610                 # let extensions preprocess docstrings\n611                 try:\n612                     skip_user = self.env.app.emit_firstresult(\n613                         'autodoc-skip-member', self.objtype, membername, member,\n614                         not keep, self.options)\n615                     if skip_user is not None:\n616                         keep = not skip_user\n617                 except Exception as exc:\n618                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n619                                       'the following exception was raised:\\n%s'),\n620                                    member, exc, type='autodoc')\n621                     keep = False\n622 \n623             if keep:\n624                 ret.append((membername, member, isattr))\n625 \n626         return ret\n627 \n628     def document_members(self, all_members: bool = False) -> None:\n629         \"\"\"Generate reST for member documentation.\n630 \n631         If *all_members* is True, do all members, else those given by\n632         *self.options.members*.\n633         \"\"\"\n634         # set current namespace for finding members\n635         self.env.temp_data['autodoc:module'] = self.modname\n636         if self.objpath:\n637             self.env.temp_data['autodoc:class'] = self.objpath[0]\n638 \n639         want_all = all_members or self.options.inherited_members or \\\n640             self.options.members is ALL\n641         # find out which members are documentable\n642         members_check_module, members = self.get_object_members(want_all)\n643 \n644         # remove members given by exclude-members\n645         if self.options.exclude_members:\n646             members = [\n647                 (membername, member) for (membername, member) in members\n648                 if (\n649                     self.options.exclude_members is ALL or\n650                     membername not in self.options.exclude_members\n651                 )\n652             ]\n653 \n654         # document non-skipped members\n655         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n656         for (mname, member, isattr) in self.filter_members(members, want_all):\n657             classes = [cls for cls in self.documenters.values()\n658                        if cls.can_document_member(member, mname, isattr, self)]\n659             if not classes:\n660                 # don't know how to document this member\n661                 continue\n662             # prefer the documenter with the highest priority\n663             classes.sort(key=lambda cls: cls.priority)\n664             # give explicitly separated module name, so that members\n665             # of inner classes can be documented\n666             full_mname = self.modname + '::' + \\\n667                 '.'.join(self.objpath + [mname])\n668             documenter = classes[-1](self.directive, full_mname, self.indent)\n669             memberdocumenters.append((documenter, isattr))\n670         member_order = self.options.member_order or \\\n671             self.env.config.autodoc_member_order\n672         if member_order == 'groupwise':\n673             # sort by group; relies on stable sort to keep items in the\n674             # same group sorted alphabetically\n675             memberdocumenters.sort(key=lambda e: e[0].member_order)\n676         elif member_order == 'bysource' and self.analyzer:\n677             # sort by source order, by virtue of the module analyzer\n678             tagorder = self.analyzer.tagorder\n679 \n680             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n681                 fullname = entry[0].name.split('::')[1]\n682                 return tagorder.get(fullname, len(tagorder))\n683             memberdocumenters.sort(key=keyfunc)\n684 \n685         for documenter, isattr in memberdocumenters:\n686             documenter.generate(\n687                 all_members=True, real_modname=self.real_modname,\n688                 check_module=members_check_module and not isattr)\n689 \n690         # reset current objects\n691         self.env.temp_data['autodoc:module'] = None\n692         self.env.temp_data['autodoc:class'] = None\n693 \n694     def generate(self, more_content: Any = None, real_modname: str = None,\n695                  check_module: bool = False, all_members: bool = False) -> None:\n696         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n697         its members.\n698 \n699         If *more_content* is given, include that content. If *real_modname* is\n700         given, use that module name to find attribute docs. If *check_module* is\n701         True, only generate if the object is defined in the module name it is\n702         imported from. If *all_members* is True, document all members.\n703         \"\"\"\n704         if not self.parse_name():\n705             # need a module to import\n706             logger.warning(\n707                 __('don\\'t know which module to import for autodocumenting '\n708                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n709                    'in the document, or giving an explicit module name)') %\n710                 self.name, type='autodoc')\n711             return\n712 \n713         # now, import the module and get object to document\n714         if not self.import_object():\n715             return\n716 \n717         # If there is no real module defined, figure out which to use.\n718         # The real module is used in the module analyzer to look up the module\n719         # where the attribute documentation would actually be found in.\n720         # This is used for situations where you have a module that collects the\n721         # functions and classes of internal submodules.\n722         self.real_modname = real_modname or self.get_real_modname()  # type: str\n723 \n724         # try to also get a source code analyzer for attribute docs\n725         try:\n726             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n727             # parse right now, to get PycodeErrors on parsing (results will\n728             # be cached anyway)\n729             self.analyzer.find_attr_docs()\n730         except PycodeError as err:\n731             logger.debug('[autodoc] module analyzer failed: %s', err)\n732             # no source file -- e.g. for builtin and C modules\n733             self.analyzer = None\n734             # at least add the module.__file__ as a dependency\n735             if hasattr(self.module, '__file__') and self.module.__file__:\n736                 self.directive.filename_set.add(self.module.__file__)\n737         else:\n738             self.directive.filename_set.add(self.analyzer.srcname)\n739 \n740         # check __module__ of object (for members not given explicitly)\n741         if check_module:\n742             if not self.check_module():\n743                 return\n744 \n745         sourcename = self.get_sourcename()\n746 \n747         # make sure that the result starts with an empty line.  This is\n748         # necessary for some situations where another directive preprocesses\n749         # reST and no starting newline is present\n750         self.add_line('', sourcename)\n751 \n752         # format the object's signature, if any\n753         sig = self.format_signature()\n754 \n755         # generate the directive header and options, if applicable\n756         self.add_directive_header(sig)\n757         self.add_line('', sourcename)\n758 \n759         # e.g. the module directive doesn't have content\n760         self.indent += self.content_indent\n761 \n762         # add all content (from docstrings, attribute docs etc.)\n763         self.add_content(more_content)\n764 \n765         # document members, if possible\n766         self.document_members(all_members)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]