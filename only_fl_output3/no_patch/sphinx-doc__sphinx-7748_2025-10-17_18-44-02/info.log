2025-10-17 18:44:02.822 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 18:44:07.276 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=171, output_tokens=12, cost=0.002070
2025-10-17 18:44:07.284 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 18:44:07.288 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:44:11.886 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=480, output_tokens=163, cost=0.009690
2025-10-17 18:44:11.890 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:44:13.676 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=517, output_tokens=48, cost=0.006610
2025-10-17 18:44:13.678 | INFO     | Refactored invocation argument parsing gives different result on 'search_code(\'"""\')': old result is [''], new result  is ['"""']
2025-10-17 18:44:13.679 | DEBUG    | Extracted a valid json.
2025-10-17 18:44:13.679 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"autodoc_docstring_signature\")",
        "search_code(\"overloaded methods\")",
        "search_code('\"\"\"')"
    ],
    "bug_locations": []
}
2025-10-17 18:44:13.692 | INFO     | Refactored invocation argument parsing gives different result on 'search_code(\'"""\')': old result is [''], new result  is ['"""']
2025-10-17 18:46:13.693 | ERROR    | 'Timed Out'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x7ea0c4f22c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x7e9fd295fb00>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x7e9fd4b7b240>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x7e9fd295fb00>, <app.raw_tasks.RawSweTask object at 0x7e9fd295fb30>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x7e9fd4b7b2e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x7e9fd26e87a0>
    └ <function run_task_in_subprocess at 0x7e9fd4b7b4c0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x7e9fd26e87a0>
    │        │      └ <function run_raw_task at 0x7e9fd4b7b560>
    │        └ <function ProcessPoolExecutor.submit at 0x7ea0c4842020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x7ea0c4841da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x7ea0c4841ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x7ea0c4841f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x7e9fd5a2e120>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x7ea0c4a04ea0>
    └ <ForkProcess name='ForkProcess-387' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-387' parent=307479 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x7ea0c4a760c0>)>
    │    │        └ <ForkProcess name='ForkProcess-387' parent=307479 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-387' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-387' parent=307479 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-387' parent=307479 started>
    │    └ <function Popen._launch at 0x7e9fd2ad4ea0>
    └ <multiprocessing.popen_fork.Popen object at 0x7e9fd314f680>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x7ea0c4a058a0>
           └ <ForkProcess name='ForkProcess-387' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x7ea0c4a04e00>
    └ <ForkProcess name='ForkProcess-387' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-387' parent=307479 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x7e9fd2b904d0>, <multiprocessing.queues.SimpleQueue object at 0x7e9fd2b931...
    │    │        └ <ForkProcess name='ForkProcess-387' parent=307479 started>
    │    └ <function _process_worker at 0x7ea0c48411c0>
    └ <ForkProcess name='ForkProcess-387' parent=307479 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x7e9fd4fdd670>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x7e9fd314de20>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x7e9fd4fdd670>
        │         └ <function run_raw_task at 0x7e9fd4b7b560>
        └ <concurrent.futures.process._CallItem object at 0x7e9fd4fdd670>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output3/sphinx-doc__sphinx-7748_2025-10-17_18-44-02'
             │            │    └ <function RawSweTask.to_task at 0x7e9fd4b7a520>
             │            └ <app.raw_tasks.RawSweTask object at 0x7e9fd314de20>
             └ <function do_inference at 0x7e9fd4b7b740>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x7e9fd4bd5080>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x7e9fd5360ae0>
       │                 │         │            └ SweTask(task_id='sphinx-doc__sphinx-7748', problem_statement='autodoc_docstring_signature with overloaded methods\nWhen using...
       │                 │         └ <app.manage.ProjectApiManager object at 0x7e9fd532bf50>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output3/sphinx-doc__sphinx-7748_2025-10-17_18-44-02/output_0')
       └ <function _run_one_task at 0x7e9fd4bd6660>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x7e9fd4fea840>
                                  │           └ <app.search.search_manage.SearchManager object at 0x7e9fd60cb170>
                                  └ <app.manage.ProjectApiManager object at 0x7e9fd532bf50>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 178, in search_iterative
    result_str, _, call_ok = function(**kwargs)
    │           │            │          └ {'code_str': ''}
    │           │            └ <bound method SearchBackend.search_code of <app.search.search_backend.SearchBackend object at 0x7e9fd38640b0>>
    │           └ []
    └ 'Could not find code overloaded methods in the codebase.'

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {'code_str': ''}
           │     └ (<app.search.search_backend.SearchBackend object at 0x7e9fd38640b0>,)
           └ <function SearchBackend.search_code at 0x7e9fd4fea200>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/site-packages/timeout_decorator/timeout_decorator.py", line 82, in new_function
    return function(*args, **kwargs)
           │         │       └ {'code_str': ''}
           │         └ (<app.search.search_backend.SearchBackend object at 0x7e9fd38640b0>,)
           └ <function SearchBackend.search_code at 0x7e9fd4fea0c0>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 501, in search_code
    class_name, func_name = self._file_line_to_class_and_func(
    │                       │    └ <function SearchBackend._file_line_to_class_and_func at 0x7e9fd4fe9440>
    │                       └ <app.search.search_backend.SearchBackend object at 0x7e9fd38640b0>
    └ 'LaTeXTranslator'

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 136, in _file_line_to_class_and_func
    for file_name, (start, end) in func_info:
        │           │      │       └ [('/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/io.py', LineRange(...
        │           │      └ 65
        │           └ 58
        └ '/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/io.py'

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/site-packages/timeout_decorator/timeout_decorator.py", line 69, in handler
    _raise_exception(timeout_exception, exception_message)
    │                │                  └ None
    │                └ <class 'timeout_decorator.timeout_decorator.TimeoutError'>
    └ <function _raise_exception at 0x7e9fd4fe8a40>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/site-packages/timeout_decorator/timeout_decorator.py", line 45, in _raise_exception
    raise exception()
          └ <class 'timeout_decorator.timeout_decorator.TimeoutError'>

timeout_decorator.timeout_decorator.TimeoutError: 'Timed Out'
2025-10-17 18:46:13.704 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 18:46:13.704 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 18:46:24.631 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=815, output_tokens=486, cost=0.022730
2025-10-17 18:46:24.639 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:46:26.986 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1517, output_tokens=38, cost=0.016310
2025-10-17 18:46:26.989 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:46:29.194 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=392, output_tokens=59, cost=0.005690
2025-10-17 18:46:29.196 | DEBUG    | Extracted a valid json.
2025-10-17 18:46:29.196 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"SWIG\")",
        "search_code(\"docstring generation\")",
        "search_method(\"parse_docstring\")",
        "search_code_in_file(\"def\", \"*.i\")"
    ],
    "bug_locations": []
}
2025-10-17 18:46:29.222 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 18:46:29.223 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 18:46:45.265 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1754, output_tokens=539, cost=0.033710
2025-10-17 18:46:45.275 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:46:49.132 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2509, output_tokens=132, cost=0.029050
2025-10-17 18:46:49.136 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:46:52.261 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=14, cost=0.005280
2025-10-17 18:46:52.262 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 18:46:52.262 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-17 18:46:53.466 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=14, cost=0.005280
2025-10-17 18:46:53.467 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 18:46:53.467 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-17 18:46:56.286 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=14, cost=0.005280
2025-10-17 18:46:56.287 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 18:46:56.287 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-17 18:46:57.398 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=14, cost=0.005280
2025-10-17 18:46:57.399 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 18:46:57.404 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-17 18:47:00.166 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=14, cost=0.005280
2025-10-17 18:47:00.167 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-17 18:47:00.167 | DEBUG    | Agent proxy return the following json: None
2025-10-17 18:47:00.168 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-17 18:47:00.169 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-17 18:47:00.169 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:47:08.337 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2668, output_tokens=348, cost=0.037120
2025-10-17 18:47:08.344 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:47:10.904 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=702, output_tokens=47, cost=0.008430
2025-10-17 18:47:10.906 | DEBUG    | Extracted a valid json.
2025-10-17 18:47:10.906 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"def parse_docstring\")",
        "search_code(\"def get_signature\")",
        "search_code(\"def wrap_method\")"
    ],
    "bug_locations": []
}
2025-10-17 18:47:10.952 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 18:47:10.953 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 18:47:22.443 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3240, output_tokens=500, cost=0.047400
2025-10-17 18:47:22.455 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:47:33.775 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3956, output_tokens=506, cost=0.054740
2025-10-17 18:47:33.785 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:47:42.138 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=860, output_tokens=329, cost=0.018470
2025-10-17 18:47:42.139 | DEBUG    | Extracted a valid json.
2025-10-17 18:47:42.140 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class_in_file(\"class_name\", \"sphinx/domains/python.py\")",
        "search_method_in_class(\"get_signature\", \"class_name\")",
        "search_class_in_file(\"class_name\", \"sphinx/directives/__init__.py\")",
        "search_method_in_class(\"get_signature\", \"class_name\")"
    ],
    "bug_locations": [
        {
            "file": "sphinx/domains/python.py",
            "class": "",
            "method": "get_signature",
            "intended_behavior": "The `get_signature` method should be enhanced to identify methods that are overloaded. Instead of returning a single signature for a method, it should return a list of signatures when multiple overloaded versions of a method are detected. This list should then be processed so that the docstrings generated by Sphinx for such methods include all the overloaded signatures, accurately reflecting the functionality available in the C++ code being wrapped."
        },
        {
            "file": "sphinx/directives/__init__.py",
            "class": "",
            "method": "get_signature",
            "intended_behavior": "This occurrence of `get_signature` should be reviewed to ensure it aligns with the adjustments made in `python.py`. If it serves a similar purpose (processing of signatures for documentation purposes), then it should also be adapted to handle method overloads by collecting and processing all signatures. The exact changes depend on how this method contributes to documentation generation—whether it directly generates docstrings or prepares signature data for other parts of the system."
        }
    ]
}
2025-10-17 18:47:42.148 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 18:47:42.148 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 18:47:59.116 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4688, output_tokens=656, cost=0.066560
2025-10-17 18:47:59.128 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 18:48:06.209 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5560, output_tokens=295, cost=0.064450
2025-10-17 18:48:06.214 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 18:48:10.992 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=649, output_tokens=145, cost=0.010840
2025-10-17 18:48:10.993 | DEBUG    | Extracted a valid json.
2025-10-17 18:48:10.994 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/domains/python.py",
            "class": "",
            "method": "get_signature",
            "intended_behavior": "Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately."
        },
        {
            "file": "sphinx/directives/__init__.py",
            "class": "",
            "method": "get_signature",
            "intended_behavior": "Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately."
        }
    ]
}
2025-10-17 18:48:11.001 | DEBUG    | Bug location extracted successfully: [<file>sphinx/domains/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains.python
3     ~~~~~~~~~~~~~~~~~~~~~
4 
5     The Python domain.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import builtins
12 import inspect
13 import re
14 import typing
15 import warnings
16 from inspect import Parameter
17 from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Tuple
18 from typing import cast
19 
20 from docutils import nodes
21 from docutils.nodes import Element, Node
22 from docutils.parsers.rst import directives
23 
24 from sphinx import addnodes
25 from sphinx.addnodes import pending_xref, desc_signature
26 from sphinx.application import Sphinx
27 from sphinx.builders import Builder
28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
29 from sphinx.directives import ObjectDescription
30 from sphinx.domains import Domain, ObjType, Index, IndexEntry
31 from sphinx.environment import BuildEnvironment
32 from sphinx.locale import _, __
33 from sphinx.pycode.ast import ast, parse as ast_parse
34 from sphinx.roles import XRefRole
35 from sphinx.util import logging
36 from sphinx.util.docfields import Field, GroupedField, TypedField
37 from sphinx.util.docutils import SphinxDirective
38 from sphinx.util.inspect import signature_from_str
39 from sphinx.util.nodes import make_id, make_refnode
40 from sphinx.util.typing import TextlikeNode
41 
42 if False:
43     # For type annotation
44     from typing import Type  # for python3.5.1
45 
46 
47 logger = logging.getLogger(__name__)
48 
49 
50 # REs for Python signatures
51 py_sig_re = re.compile(
52     r'''^ ([\w.]*\.)?            # class name(s)
53           (\w+)  \s*             # thing name
54           (?: \(\s*(.*)\s*\)     # optional: arguments
55            (?:\s* -> \s* (.*))?  #           return annotation
56           )? $                   # and nothing more
57           ''', re.VERBOSE)
58 
59 
60 pairindextypes = {
61     'module':    _('module'),
62     'keyword':   _('keyword'),
63     'operator':  _('operator'),
64     'object':    _('object'),
65     'exception': _('exception'),
66     'statement': _('statement'),
67     'builtin':   _('built-in function'),
68 }
69 
70 ObjectEntry = NamedTuple('ObjectEntry', [('docname', str),
71                                          ('node_id', str),
72                                          ('objtype', str)])
73 ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),
74                                          ('node_id', str),
75                                          ('synopsis', str),
76                                          ('platform', str),
77                                          ('deprecated', bool)])
78 
79 
80 def type_to_xref(text: str) -> addnodes.pending_xref:
81     """Convert a type string to a cross reference node."""
82     if text == 'None':
83         reftype = 'obj'
84     else:
85         reftype = 'class'
86 
87     return pending_xref('', nodes.Text(text),
88                         refdomain='py', reftype=reftype, reftarget=text)
89 
90 
91 def _parse_annotation(annotation: str) -> List[Node]:
92     """Parse type annotation."""
93     def unparse(node: ast.AST) -> List[Node]:
94         if isinstance(node, ast.Attribute):
95             return [nodes.Text("%s.%s" % (unparse(node.value)[0], node.attr))]
96         elif isinstance(node, ast.Expr):
97             return unparse(node.value)
98         elif isinstance(node, ast.Index):
99             return unparse(node.value)
100         elif isinstance(node, ast.List):
101             result = [addnodes.desc_sig_punctuation('', '[')]  # type: List[Node]
102             for elem in node.elts:
103                 result.extend(unparse(elem))
104                 result.append(addnodes.desc_sig_punctuation('', ', '))
105             result.pop()
106             result.append(addnodes.desc_sig_punctuation('', ']'))
107             return result
108         elif isinstance(node, ast.Module):
109             return sum((unparse(e) for e in node.body), [])
110         elif isinstance(node, ast.Name):
111             return [nodes.Text(node.id)]
112         elif isinstance(node, ast.Subscript):
113             result = unparse(node.value)
114             result.append(addnodes.desc_sig_punctuation('', '['))
115             result.extend(unparse(node.slice))
116             result.append(addnodes.desc_sig_punctuation('', ']'))
117             return result
118         elif isinstance(node, ast.Tuple):
119             if node.elts:
120                 result = []
121                 for elem in node.elts:
122                     result.extend(unparse(elem))
123                     result.append(addnodes.desc_sig_punctuation('', ', '))
124                 result.pop()
125             else:
126                 result = [addnodes.desc_sig_punctuation('', '('),
127                           addnodes.desc_sig_punctuation('', ')')]
128 
129             return result
130         else:
131             raise SyntaxError  # unsupported syntax
132 
133     try:
134         tree = ast_parse(annotation)
135         result = unparse(tree)
136         for i, node in enumerate(result):
137             if isinstance(node, nodes.Text):
138                 result[i] = type_to_xref(str(node))
139         return result
140     except SyntaxError:
141         return [type_to_xref(annotation)]
142 
143 
144 def _parse_arglist(arglist: str) -> addnodes.desc_parameterlist:
145     """Parse a list of arguments using AST parser"""
146     params = addnodes.desc_parameterlist(arglist)
147     sig = signature_from_str('(%s)' % arglist)
148     last_kind = None
149     for param in sig.parameters.values():
150         if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:
151             # PEP-570: Separator for Positional Only Parameter: /
152             params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))
153         if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,
154                                                               param.POSITIONAL_ONLY,
155                                                               None):
156             # PEP-3102: Separator for Keyword Only Parameter: *
157             params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '*'))
158 
159         node = addnodes.desc_parameter()
160         if param.kind == param.VAR_POSITIONAL:
161             node += addnodes.desc_sig_operator('', '*')
162             node += addnodes.desc_sig_name('', param.name)
163         elif param.kind == param.VAR_KEYWORD:
164             node += addnodes.desc_sig_operator('', '**')
165             node += addnodes.desc_sig_name('', param.name)
166         else:
167             node += addnodes.desc_sig_name('', param.name)
168 
169         if param.annotation is not param.empty:
170             children = _parse_annotation(param.annotation)
171             node += addnodes.desc_sig_punctuation('', ':')
172             node += nodes.Text(' ')
173             node += addnodes.desc_sig_name('', '', *children)  # type: ignore
174         if param.default is not param.empty:
175             if param.annotation is not param.empty:
176                 node += nodes.Text(' ')
177                 node += addnodes.desc_sig_operator('', '=')
178                 node += nodes.Text(' ')
179             else:
180                 node += addnodes.desc_sig_operator('', '=')
181             node += nodes.inline('', param.default, classes=['default_value'],
182                                  support_smartquotes=False)
183 
184         params += node
185         last_kind = param.kind
186 
187     if last_kind == Parameter.POSITIONAL_ONLY:
188         # PEP-570: Separator for Positional Only Parameter: /
189         params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))
190 
191     return params
192 
193 
194 def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:
195     """"Parse" a list of arguments separated by commas.
196 
197     Arguments can have "optional" annotations given by enclosing them in
198     brackets.  Currently, this will split at any comma, even if it's inside a
199     string literal (e.g. default argument value).
200     """
201     paramlist = addnodes.desc_parameterlist()
202     stack = [paramlist]  # type: List[Element]
203     try:
204         for argument in arglist.split(','):
205             argument = argument.strip()
206             ends_open = ends_close = 0
207             while argument.startswith('['):
208                 stack.append(addnodes.desc_optional())
209                 stack[-2] += stack[-1]
210                 argument = argument[1:].strip()
211             while argument.startswith(']'):
212                 stack.pop()
213                 argument = argument[1:].strip()
214             while argument.endswith(']') and not argument.endswith('[]'):
215                 ends_close += 1
216                 argument = argument[:-1].strip()
217             while argument.endswith('['):
218                 ends_open += 1
219                 argument = argument[:-1].strip()
220             if argument:
221                 stack[-1] += addnodes.desc_parameter(argument, argument)
222             while ends_open:
223                 stack.append(addnodes.desc_optional())
224                 stack[-2] += stack[-1]
225                 ends_open -= 1
226             while ends_close:
227                 stack.pop()
228                 ends_close -= 1
229         if len(stack) != 1:
230             raise IndexError
231     except IndexError:
232         # if there are too few or too many elements on the stack, just give up
233         # and treat the whole argument list as one argument, discarding the
234         # already partially populated paramlist node
235         paramlist = addnodes.desc_parameterlist()
236         paramlist += addnodes.desc_parameter(arglist, arglist)
237         signode += paramlist
238     else:
239         signode += paramlist
240 
241 
242 # This override allows our inline type specifiers to behave like :class: link
243 # when it comes to handling "." and "~" prefixes.
244 class PyXrefMixin:
245     def make_xref(self, rolename: str, domain: str, target: str,
246                   innernode: "Type[TextlikeNode]" = nodes.emphasis,
247                   contnode: Node = None, env: BuildEnvironment = None) -> Node:
248         result = super().make_xref(rolename, domain, target,  # type: ignore
249                                    innernode, contnode, env)
250         result['refspecific'] = True
251         if target.startswith(('.', '~')):
252             prefix, result['reftarget'] = target[0], target[1:]
253             if prefix == '.':
254                 text = target[1:]
255             elif prefix == '~':
256                 text = target.split('.')[-1]
257             for node in result.traverse(nodes.Text):
258                 node.parent[node.parent.index(node)] = nodes.Text(text)
259                 break
260         return result
261 
262     def make_xrefs(self, rolename: str, domain: str, target: str,
263                    innernode: "Type[TextlikeNode]" = nodes.emphasis,
264                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:
265         delims = r'(\s*[\[\]\(\),](?:\s*or\s)?\s*|\s+or\s+)'
266         delims_re = re.compile(delims)
267         sub_targets = re.split(delims, target)
268 
269         split_contnode = bool(contnode and contnode.astext() == target)
270 
271         results = []
272         for sub_target in filter(None, sub_targets):
273             if split_contnode:
274                 contnode = nodes.Text(sub_target)
275 
276             if delims_re.match(sub_target):
277                 results.append(contnode or innernode(sub_target, sub_target))
278             else:
279                 results.append(self.make_xref(rolename, domain, sub_target,
280                                               innernode, contnode, env))
281 
282         return results
283 
284 
285 class PyField(PyXrefMixin, Field):
286     def make_xref(self, rolename: str, domain: str, target: str,
287                   innernode: "Type[TextlikeNode]" = nodes.emphasis,
288                   contnode: Node = None, env: BuildEnvironment = None) -> Node:
289         if rolename == 'class' and target == 'None':
290             # None is not a type, so use obj role instead.
291             rolename = 'obj'
292 
293         return super().make_xref(rolename, domain, target, innernode, contnode, env)
294 
295 
296 class PyGroupedField(PyXrefMixin, GroupedField):
297     pass
298 
299 
300 class PyTypedField(PyXrefMixin, TypedField):
301     def make_xref(self, rolename: str, domain: str, target: str,
302                   innernode: "Type[TextlikeNode]" = nodes.emphasis,
303                   contnode: Node = None, env: BuildEnvironment = None) -> Node:
304         if rolename == 'class' and target == 'None':
305             # None is not a type, so use obj role instead.
306             rolename = 'obj'
307 
308         return super().make_xref(rolename, domain, target, innernode, contnode, env)
309 
310 
311 class PyObject(ObjectDescription):
312     """
313     Description of a general Python object.
314 
315     :cvar allow_nesting: Class is an object that allows for nested namespaces
316     :vartype allow_nesting: bool
317     """
318     option_spec = {
319         'noindex': directives.flag,
320         'module': directives.unchanged,
321         'annotation': directives.unchanged,
322     }
323 
324     doc_field_types = [
325         PyTypedField('parameter', label=_('Parameters'),
326                      names=('param', 'parameter', 'arg', 'argument',
327                             'keyword', 'kwarg', 'kwparam'),
328                      typerolename='class', typenames=('paramtype', 'type'),
329                      can_collapse=True),
330         PyTypedField('variable', label=_('Variables'), rolename='obj',
331                      names=('var', 'ivar', 'cvar'),
332                      typerolename='class', typenames=('vartype',),
333                      can_collapse=True),
334         PyGroupedField('exceptions', label=_('Raises'), rolename='exc',
335                        names=('raises', 'raise', 'exception', 'except'),
336                        can_collapse=True),
337         Field('returnvalue', label=_('Returns'), has_arg=False,
338               names=('returns', 'return')),
339         PyField('returntype', label=_('Return type'), has_arg=False,
340                 names=('rtype',), bodyrolename='class'),
341     ]
342 
343     allow_nesting = False
344 
345     def get_signature_prefix(self, sig: str) -> str:
346         """May return a prefix to put before the object name in the
347         signature.
348         """
349         return ''
350 
351     def needs_arglist(self) -> bool:
352         """May return true if an empty argument list is to be generated even if
353         the document contains none.
354         """
355         return False
356 
357     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
358         """Transform a Python signature into RST nodes.
359 
360         Return (fully qualified name of the thing, classname if any).
361 
362         If inside a class, the current class name is handled intelligently:
363         * it is stripped from the displayed name if present
364         * it is added to the full name (return value) if not present
365         """
366         m = py_sig_re.match(sig)
367         if m is None:
368             raise ValueError
369         prefix, name, arglist, retann = m.groups()
370 
371         # determine module and class name (if applicable), as well as full name
372         modname = self.options.get('module', self.env.ref_context.get('py:module'))
373         classname = self.env.ref_context.get('py:class')
374         if classname:
375             add_module = False
376             if prefix and (prefix == classname or
377                            prefix.startswith(classname + ".")):
378                 fullname = prefix + name
379                 # class name is given again in the signature
380                 prefix = prefix[len(classname):].lstrip('.')
381             elif prefix:
382                 # class name is given in the signature, but different
383                 # (shouldn't happen)
384                 fullname = classname + '.' + prefix + name
385             else:
386                 # class name is not given in the signature
387                 fullname = classname + '.' + name
388         else:
389             add_module = True
390             if prefix:
391                 classname = prefix.rstrip('.')
392                 fullname = prefix + name
393             else:
394                 classname = ''
395                 fullname = name
396 
397         signode['module'] = modname
398         signode['class'] = classname
399         signode['fullname'] = fullname
400 
401         sig_prefix = self.get_signature_prefix(sig)
402         if sig_prefix:
403             signode += addnodes.desc_annotation(sig_prefix, sig_prefix)
404 
405         if prefix:
406             signode += addnodes.desc_addname(prefix, prefix)
407         elif add_module and self.env.config.add_module_names:
408             if modname and modname != 'exceptions':
409                 # exceptions are a special case, since they are documented in the
410                 # 'exceptions' module.
411                 nodetext = modname + '.'
412                 signode += addnodes.desc_addname(nodetext, nodetext)
413 
414         signode += addnodes.desc_name(name, name)
415         if arglist:
416             try:
417                 signode += _parse_arglist(arglist)
418             except SyntaxError:
419                 # fallback to parse arglist original parser.
420                 # it supports to represent optional arguments (ex. "func(foo [, bar])")
421                 _pseudo_parse_arglist(signode, arglist)
422             except NotImplementedError as exc:
423                 logger.warning("could not parse arglist (%r): %s", arglist, exc,
424                                location=signode)
425                 _pseudo_parse_arglist(signode, arglist)
426         else:
427             if self.needs_arglist():
428                 # for callables, add an empty parameter list
429                 signode += addnodes.desc_parameterlist()
430 
431         if retann:
432             children = _parse_annotation(retann)
433             signode += addnodes.desc_returns(retann, '', *children)
434 
435         anno = self.options.get('annotation')
436         if anno:
437             signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)
438 
439         return fullname, prefix
440 
441     def get_index_text(self, modname: str, name: Tuple[str, str]) -> str:
442         """Return the text for the index entry of the object."""
443         raise NotImplementedError('must be implemented in subclasses')
444 
445     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,
446                              signode: desc_signature) -> None:
447         modname = self.options.get('module', self.env.ref_context.get('py:module'))
448         fullname = (modname + '.' if modname else '') + name_cls[0]
449         node_id = make_id(self.env, self.state.document, '', fullname)
450         signode['ids'].append(node_id)
451 
452         # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)
453         # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)
454         if node_id != fullname and fullname not in self.state.document.ids:
455             signode['ids'].append(fullname)
456 
457         self.state.document.note_explicit_target(signode)
458 
459         domain = cast(PythonDomain, self.env.get_domain('py'))
460         domain.note_object(fullname, self.objtype, node_id, location=signode)
461 
462         indextext = self.get_index_text(modname, name_cls)
463         if indextext:
464             self.indexnode['entries'].append(('single', indextext, node_id, '', None))
465 
466     def before_content(self) -> None:
467         """Handle object nesting before content
468 
469         :py:class:`PyObject` represents Python language constructs. For
470         constructs that are nestable, such as a Python classes, this method will
471         build up a stack of the nesting heirarchy so that it can be later
472         de-nested correctly, in :py:meth:`after_content`.
473 
474         For constructs that aren't nestable, the stack is bypassed, and instead
475         only the most recent object is tracked. This object prefix name will be
476         removed with :py:meth:`after_content`.
477         """
478         prefix = None
479         if self.names:
480             # fullname and name_prefix come from the `handle_signature` method.
481             # fullname represents the full object name that is constructed using
482             # object nesting and explicit prefixes. `name_prefix` is the
483             # explicit prefix given in a signature
484             (fullname, name_prefix) = self.names[-1]
485             if self.allow_nesting:
486                 prefix = fullname
487             elif name_prefix:
488                 prefix = name_prefix.strip('.')
489         if prefix:
490             self.env.ref_context['py:class'] = prefix
491             if self.allow_nesting:
492                 classes = self.env.ref_context.setdefault('py:classes', [])
493                 classes.append(prefix)
494         if 'module' in self.options:
495             modules = self.env.ref_context.setdefault('py:modules', [])
496             modules.append(self.env.ref_context.get('py:module'))
497             self.env.ref_context['py:module'] = self.options['module']
498 
499     def after_content(self) -> None:
500         """Handle object de-nesting after content
501 
502         If this class is a nestable object, removing the last nested class prefix
503         ends further nesting in the object.
504 
505         If this class is not a nestable object, the list of classes should not
506         be altered as we didn't affect the nesting levels in
507         :py:meth:`before_content`.
508         """
509         classes = self.env.ref_context.setdefault('py:classes', [])
510         if self.allow_nesting:
511             try:
512                 classes.pop()
513             except IndexError:
514                 pass
515         self.env.ref_context['py:class'] = (classes[-1] if len(classes) > 0
516                                             else None)
517         if 'module' in self.options:
518             modules = self.env.ref_context.setdefault('py:modules', [])
519             if modules:
520                 self.env.ref_context['py:module'] = modules.pop()
521             else:
522                 self.env.ref_context.pop('py:module')
523 
524 
525 class PyModulelevel(PyObject):
526     """
527     Description of an object on module level (functions, data).
528     """
529 
530     def run(self) -> List[Node]:
531         for cls in self.__class__.__mro__:
532             if cls.__name__ != 'DirectiveAdapter':
533                 warnings.warn('PyModulelevel is deprecated. '
534                               'Please check the implementation of %s' % cls,
535                               RemovedInSphinx40Warning, stacklevel=2)
536                 break
537         else:
538             warnings.warn('PyModulelevel is deprecated',
539                           RemovedInSphinx40Warning, stacklevel=2)
540 
541         return super().run()
542 
543     def needs_arglist(self) -> bool:
544         return self.objtype == 'function'
545 
546     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
547         if self.objtype == 'function':
548             if not modname:
549                 return _('%s() (built-in function)') % name_cls[0]
550             return _('%s() (in module %s)') % (name_cls[0], modname)
551         elif self.objtype == 'data':
552             if not modname:
553                 return _('%s (built-in variable)') % name_cls[0]
554             return _('%s (in module %s)') % (name_cls[0], modname)
555         else:
556             return ''
557 
558 
559 class PyFunction(PyObject):
560     """Description of a function."""
561 
562     option_spec = PyObject.option_spec.copy()
563     option_spec.update({
564         'async': directives.flag,
565     })
566 
567     def get_signature_prefix(self, sig: str) -> str:
568         if 'async' in self.options:
569             return 'async '
570         else:
571             return ''
572 
573     def needs_arglist(self) -> bool:
574         return True
575 
576     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,
577                              signode: desc_signature) -> None:
578         super().add_target_and_index(name_cls, sig, signode)
579         modname = self.options.get('module', self.env.ref_context.get('py:module'))
580         node_id = signode['ids'][0]
581 
582         name, cls = name_cls
583         if modname:
584             text = _('%s() (in module %s)') % (name, modname)
585             self.indexnode['entries'].append(('single', text, node_id, '', None))
586         else:
587             text = '%s; %s()' % (pairindextypes['builtin'], name)
588             self.indexnode['entries'].append(('pair', text, node_id, '', None))
589 
590     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
591         # add index in own add_target_and_index() instead.
592         return None
593 
594 
595 class PyDecoratorFunction(PyFunction):
596     """Description of a decorator."""
597 
598     def run(self) -> List[Node]:
599         # a decorator function is a function after all
600         self.name = 'py:function'
601         return super().run()
602 
603     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
604         ret = super().handle_signature(sig, signode)
605         signode.insert(0, addnodes.desc_addname('@', '@'))
606         return ret
607 
608     def needs_arglist(self) -> bool:
609         return False
610 
611 
612 class PyVariable(PyObject):
613     """Description of a variable."""
614 
615     option_spec = PyObject.option_spec.copy()
616     option_spec.update({
617         'type': directives.unchanged,
618         'value': directives.unchanged,
619     })
620 
621     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
622         fullname, prefix = super().handle_signature(sig, signode)
623 
624         typ = self.options.get('type')
625         if typ:
626             signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))
627 
628         value = self.options.get('value')
629         if value:
630             signode += addnodes.desc_annotation(value, ' = ' + value)
631 
632         return fullname, prefix
633 
634     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
635         name, cls = name_cls
636         if modname:
637             return _('%s (in module %s)') % (name, modname)
638         else:
639             return _('%s (built-in variable)') % name
640 
641 
642 class PyClasslike(PyObject):
643     """
644     Description of a class-like object (classes, interfaces, exceptions).
645     """
646 
647     option_spec = PyObject.option_spec.copy()
648     option_spec.update({
649         'final': directives.flag,
650     })
651 
652     allow_nesting = True
653 
654     def get_signature_prefix(self, sig: str) -> str:
655         if 'final' in self.options:
656             return 'final %s ' % self.objtype
657         else:
658             return '%s ' % self.objtype
659 
660     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
661         if self.objtype == 'class':
662             if not modname:
663                 return _('%s (built-in class)') % name_cls[0]
664             return _('%s (class in %s)') % (name_cls[0], modname)
665         elif self.objtype == 'exception':
666             return name_cls[0]
667         else:
668             return ''
669 
670 
671 class PyClassmember(PyObject):
672     """
673     Description of a class member (methods, attributes).
674     """
675 
676     def run(self) -> List[Node]:
677         for cls in self.__class__.__mro__:
678             if cls.__name__ != 'DirectiveAdapter':
679                 warnings.warn('PyClassmember is deprecated. '
680                               'Please check the implementation of %s' % cls,
681                               RemovedInSphinx40Warning, stacklevel=2)
682                 break
683         else:
684             warnings.warn('PyClassmember is deprecated',
685                           RemovedInSphinx40Warning, stacklevel=2)
686 
687         return super().run()
688 
689     def needs_arglist(self) -> bool:
690         return self.objtype.endswith('method')
691 
692     def get_signature_prefix(self, sig: str) -> str:
693         if self.objtype == 'staticmethod':
694             return 'static '
695         elif self.objtype == 'classmethod':
696             return 'classmethod '
697         return ''
698 
699     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
700         name, cls = name_cls
701         add_modules = self.env.config.add_module_names
702         if self.objtype == 'method':
703             try:
704                 clsname, methname = name.rsplit('.', 1)
705             except ValueError:
706                 if modname:
707                     return _('%s() (in module %s)') % (name, modname)
708                 else:
709                     return '%s()' % name
710             if modname and add_modules:
711                 return _('%s() (%s.%s method)') % (methname, modname, clsname)
712             else:
713                 return _('%s() (%s method)') % (methname, clsname)
714         elif self.objtype == 'staticmethod':
715             try:
716                 clsname, methname = name.rsplit('.', 1)
717             except ValueError:
718                 if modname:
719                     return _('%s() (in module %s)') % (name, modname)
720                 else:
721                     return '%s()' % name
722             if modname and add_modules:
723                 return _('%s() (%s.%s static method)') % (methname, modname,
724                                                           clsname)
725             else:
726                 return _('%s() (%s static method)') % (methname, clsname)
727         elif self.objtype == 'classmethod':
728             try:
729                 clsname, methname = name.rsplit('.', 1)
730             except ValueError:
731                 if modname:
732                     return _('%s() (in module %s)') % (name, modname)
733                 else:
734                     return '%s()' % name
735             if modname:
736                 return _('%s() (%s.%s class method)') % (methname, modname,
737                                                          clsname)
738             else:
739                 return _('%s() (%s class method)') % (methname, clsname)
740         elif self.objtype == 'attribute':
741             try:
742                 clsname, attrname = name.rsplit('.', 1)
743             except ValueError:
744                 if modname:
745                     return _('%s (in module %s)') % (name, modname)
746                 else:
747                     return name
748             if modname and add_modules:
749                 return _('%s (%s.%s attribute)') % (attrname, modname, clsname)
750             else:
751                 return _('%s (%s attribute)') % (attrname, clsname)
752         else:
753             return ''
754 
755 
756 class PyMethod(PyObject):
757     """Description of a method."""
758 
759     option_spec = PyObject.option_spec.copy()
760     option_spec.update({
761         'abstractmethod': directives.flag,
762         'async': directives.flag,
763         'classmethod': directives.flag,
764         'final': directives.flag,
765         'property': directives.flag,
766         'staticmethod': directives.flag,
767     })
768 
769     def needs_arglist(self) -> bool:
770         if 'property' in self.options:
771             return False
772         else:
773             return True
774 
775     def get_signature_prefix(self, sig: str) -> str:
776         prefix = []
777         if 'final' in self.options:
778             prefix.append('final')
779         if 'abstractmethod' in self.options:
780             prefix.append('abstract')
781         if 'async' in self.options:
782             prefix.append('async')
783         if 'classmethod' in self.options:
784             prefix.append('classmethod')
785         if 'property' in self.options:
786             prefix.append('property')
787         if 'staticmethod' in self.options:
788             prefix.append('static')
789 
790         if prefix:
791             return ' '.join(prefix) + ' '
792         else:
793             return ''
794 
795     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
796         name, cls = name_cls
797         try:
798             clsname, methname = name.rsplit('.', 1)
799             if modname and self.env.config.add_module_names:
800                 clsname = '.'.join([modname, clsname])
801         except ValueError:
802             if modname:
803                 return _('%s() (in module %s)') % (name, modname)
804             else:
805                 return '%s()' % name
806 
807         if 'classmethod' in self.options:
808             return _('%s() (%s class method)') % (methname, clsname)
809         elif 'property' in self.options:
810             return _('%s() (%s property)') % (methname, clsname)
811         elif 'staticmethod' in self.options:
812             return _('%s() (%s static method)') % (methname, clsname)
813         else:
814             return _('%s() (%s method)') % (methname, clsname)
815 
816 
817 class PyClassMethod(PyMethod):
818     """Description of a classmethod."""
819 
820     option_spec = PyObject.option_spec.copy()
821 
822     def run(self) -> List[Node]:
823         self.name = 'py:method'
824         self.options['classmethod'] = True
825 
826         return super().run()
827 
828 
829 class PyStaticMethod(PyMethod):
830     """Description of a staticmethod."""
831 
832     option_spec = PyObject.option_spec.copy()
833 
834     def run(self) -> List[Node]:
835         self.name = 'py:method'
836         self.options['staticmethod'] = True
837 
838         return super().run()
839 
840 
841 class PyDecoratorMethod(PyMethod):
842     """Description of a decoratormethod."""
843 
844     def run(self) -> List[Node]:
845         self.name = 'py:method'
846         return super().run()
847 
848     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
849         ret = super().handle_signature(sig, signode)
850         signode.insert(0, addnodes.desc_addname('@', '@'))
851         return ret
852 
853     def needs_arglist(self) -> bool:
854         return False
855 
856 
857 class PyAttribute(PyObject):
858     """Description of an attribute."""
859 
860     option_spec = PyObject.option_spec.copy()
861     option_spec.update({
862         'type': directives.unchanged,
863         'value': directives.unchanged,
864     })
865 
866     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
867         fullname, prefix = super().handle_signature(sig, signode)
868 
869         typ = self.options.get('type')
870         if typ:
871             signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))
872 
873         value = self.options.get('value')
874         if value:
875             signode += addnodes.desc_annotation(value, ' = ' + value)
876 
877         return fullname, prefix
878 
879     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
880         name, cls = name_cls
881         try:
882             clsname, attrname = name.rsplit('.', 1)
883             if modname and self.env.config.add_module_names:
884                 clsname = '.'.join([modname, clsname])
885         except ValueError:
886             if modname:
887                 return _('%s (in module %s)') % (name, modname)
888             else:
889                 return name
890 
891         return _('%s (%s attribute)') % (attrname, clsname)
892 
893 
894 class PyDecoratorMixin:
895     """
896     Mixin for decorator directives.
897     """
898     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
899         for cls in self.__class__.__mro__:
900             if cls.__name__ != 'DirectiveAdapter':
901                 warnings.warn('PyDecoratorMixin is deprecated. '
902                               'Please check the implementation of %s' % cls,
903                               RemovedInSphinx50Warning, stacklevel=2)
904                 break
905         else:
906             warnings.warn('PyDecoratorMixin is deprecated',
907                           RemovedInSphinx50Warning, stacklevel=2)
908 
909         ret = super().handle_signature(sig, signode)  # type: ignore
910         signode.insert(0, addnodes.desc_addname('@', '@'))
911         return ret
912 
913     def needs_arglist(self) -> bool:
914         return False
915 
916 
917 class PyModule(SphinxDirective):
918     """
919     Directive to mark description of a new module.
920     """
921 
922     has_content = False
923     required_arguments = 1
924     optional_arguments = 0
925     final_argument_whitespace = False
926     option_spec = {
927         'platform': lambda x: x,
928         'synopsis': lambda x: x,
929         'noindex': directives.flag,
930         'deprecated': directives.flag,
931     }
932 
933     def run(self) -> List[Node]:
934         domain = cast(PythonDomain, self.env.get_domain('py'))
935 
936         modname = self.arguments[0].strip()
937         noindex = 'noindex' in self.options
938         self.env.ref_context['py:module'] = modname
939         ret = []  # type: List[Node]
940         if not noindex:
941             # note module to the domain
942             node_id = make_id(self.env, self.state.document, 'module', modname)
943             target = nodes.target('', '', ids=[node_id], ismod=True)
944             self.set_source_info(target)
945 
946             # Assign old styled node_id not to break old hyperlinks (if possible)
947             # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)
948             old_node_id = self.make_old_id(modname)
949             if node_id != old_node_id and old_node_id not in self.state.document.ids:
950                 target['ids'].append(old_node_id)
951 
952             self.state.document.note_explicit_target(target)
953 
954             domain.note_module(modname,
955                                node_id,
956                                self.options.get('synopsis', ''),
957                                self.options.get('platform', ''),
958                                'deprecated' in self.options)
959             domain.note_object(modname, 'module', node_id, location=target)
960 
961             # the platform and synopsis aren't printed; in fact, they are only
962             # used in the modindex currently
963             ret.append(target)
964             indextext = '%s; %s' % (pairindextypes['module'], modname)
965             inode = addnodes.index(entries=[('pair', indextext, node_id, '', None)])
966             ret.append(inode)
967         return ret
968 
969     def make_old_id(self, name: str) -> str:
970         """Generate old styled node_id.
971 
972         Old styled node_id is incompatible with docutils' node_id.
973         It can contain dots and hyphens.
974 
975         .. note:: Old styled node_id was mainly used until Sphinx-3.0.
976         """
977         return 'module-%s' % name
978 
979 
980 class PyCurrentModule(SphinxDirective):
981     """
982     This directive is just to tell Sphinx that we're documenting
983     stuff in module foo, but links to module foo won't lead here.
984     """
985 
986     has_content = False
987     required_arguments = 1
988     optional_arguments = 0
989     final_argument_whitespace = False
990     option_spec = {}  # type: Dict
991 
992     def run(self) -> List[Node]:
993         modname = self.arguments[0].strip()
994         if modname == 'None':
995             self.env.ref_context.pop('py:module', None)
996         else:
997             self.env.ref_context['py:module'] = modname
998         return []
999 
1000 
1001 class PyXRefRole(XRefRole):
1002     def process_link(self, env: BuildEnvironment, refnode: Element,
1003                      has_explicit_title: bool, title: str, target: str) -> Tuple[str, str]:
1004         refnode['py:module'] = env.ref_context.get('py:module')
1005         refnode['py:class'] = env.ref_context.get('py:class')
1006         if not has_explicit_title:
1007             title = title.lstrip('.')    # only has a meaning for the target
1008             target = target.lstrip('~')  # only has a meaning for the title
1009             # if the first character is a tilde, don't display the module/class
1010             # parts of the contents
1011             if title[0:1] == '~':
1012                 title = title[1:]
1013                 dot = title.rfind('.')
1014                 if dot != -1:
1015                     title = title[dot + 1:]
1016         # if the first character is a dot, search more specific namespaces first
1017         # else search builtins first
1018         if target[0:1] == '.':
1019             target = target[1:]
1020             refnode['refspecific'] = True
1021         return title, target
1022 
1023 
1024 def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:
1025     """Filter ``:meta:`` field from its docstring."""
1026     if domain != 'py':
1027         return
1028 
1029     for node in content:
1030         if isinstance(node, nodes.field_list):
1031             fields = cast(List[nodes.field], node)
1032             for field in fields:
1033                 field_name = cast(nodes.field_body, field[0]).astext().strip()
1034                 if field_name == 'meta' or field_name.startswith('meta '):
1035                     node.remove(field)
1036                     break
1037 
1038 
1039 class PythonModuleIndex(Index):
1040     """
1041     Index subclass to provide the Python module index.
1042     """
1043 
1044     name = 'modindex'
1045     localname = _('Python Module Index')
1046     shortname = _('modules')
1047 
1048     def generate(self, docnames: Iterable[str] = None
1049                  ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:
1050         content = {}  # type: Dict[str, List[IndexEntry]]
1051         # list of prefixes to ignore
1052         ignores = None  # type: List[str]
1053         ignores = self.domain.env.config['modindex_common_prefix']  # type: ignore
1054         ignores = sorted(ignores, key=len, reverse=True)
1055         # list of all modules, sorted by module name
1056         modules = sorted(self.domain.data['modules'].items(),
1057                          key=lambda x: x[0].lower())
1058         # sort out collapsable modules
1059         prev_modname = ''
1060         num_toplevels = 0
1061         for modname, (docname, node_id, synopsis, platforms, deprecated) in modules:
1062             if docnames and docname not in docnames:
1063                 continue
1064 
1065             for ignore in ignores:
1066                 if modname.startswith(ignore):
1067                     modname = modname[len(ignore):]
1068                     stripped = ignore
1069                     break
1070             else:
1071                 stripped = ''
1072 
1073             # we stripped the whole module name?
1074             if not modname:
1075                 modname, stripped = stripped, ''
1076 
1077             entries = content.setdefault(modname[0].lower(), [])
1078 
1079             package = modname.split('.')[0]
1080             if package != modname:
1081                 # it's a submodule
1082                 if prev_modname == package:
1083                     # first submodule - make parent a group head
1084                     if entries:
1085                         last = entries[-1]
1086                         entries[-1] = IndexEntry(last[0], 1, last[2], last[3],
1087                                                  last[4], last[5], last[6])
1088                 elif not prev_modname.startswith(package):
1089                     # submodule without parent in list, add dummy entry
1090                     entries.append(IndexEntry(stripped + package, 1, '', '', '', '', ''))
1091                 subtype = 2
1092             else:
1093                 num_toplevels += 1
1094                 subtype = 0
1095 
1096             qualifier = _('Deprecated') if deprecated else ''
1097             entries.append(IndexEntry(stripped + modname, subtype, docname,
1098                                       node_id, platforms, qualifier, synopsis))
1099             prev_modname = modname
1100 
1101         # apply heuristics when to collapse modindex at page load:
1102         # only collapse if number of toplevel modules is larger than
1103         # number of submodules
1104         collapse = len(modules) - num_toplevels < num_toplevels
1105 
1106         # sort by first letter
1107         sorted_content = sorted(content.items())
1108 
1109         return sorted_content, collapse
1110 
1111 
1112 class PythonDomain(Domain):
1113     """Python language domain."""
1114     name = 'py'
1115     label = 'Python'
1116     object_types = {
1117         'function':     ObjType(_('function'),      'func', 'obj'),
1118         'data':         ObjType(_('data'),          'data', 'obj'),
1119         'class':        ObjType(_('class'),         'class', 'exc', 'obj'),
1120         'exception':    ObjType(_('exception'),     'exc', 'class', 'obj'),
1121         'method':       ObjType(_('method'),        'meth', 'obj'),
1122         'classmethod':  ObjType(_('class method'),  'meth', 'obj'),
1123         'staticmethod': ObjType(_('static method'), 'meth', 'obj'),
1124         'attribute':    ObjType(_('attribute'),     'attr', 'obj'),
1125         'module':       ObjType(_('module'),        'mod', 'obj'),
1126     }  # type: Dict[str, ObjType]
1127 
1128     directives = {
1129         'function':        PyFunction,
1130         'data':            PyVariable,
1131         'class':           PyClasslike,
1132         'exception':       PyClasslike,
1133         'method':          PyMethod,
1134         'classmethod':     PyClassMethod,
1135         'staticmethod':    PyStaticMethod,
1136         'attribute':       PyAttribute,
1137         'module':          PyModule,
1138         'currentmodule':   PyCurrentModule,
1139         'decorator':       PyDecoratorFunction,
1140         'decoratormethod': PyDecoratorMethod,
1141     }
1142     roles = {
1143         'data':  PyXRefRole(),
1144         'exc':   PyXRefRole(),
1145         'func':  PyXRefRole(fix_parens=True),
1146         'class': PyXRefRole(),
1147         'const': PyXRefRole(),
1148         'attr':  PyXRefRole(),
1149         'meth':  PyXRefRole(fix_parens=True),
1150         'mod':   PyXRefRole(),
1151         'obj':   PyXRefRole(),
1152     }
1153     initial_data = {
1154         'objects': {},  # fullname -> docname, objtype
1155         'modules': {},  # modname -> docname, synopsis, platform, deprecated
1156     }  # type: Dict[str, Dict[str, Tuple[Any]]]
1157     indices = [
1158         PythonModuleIndex,
1159     ]
1160 
1161     @property
1162     def objects(self) -> Dict[str, ObjectEntry]:
1163         return self.data.setdefault('objects', {})  # fullname -> ObjectEntry
1164 
1165     def note_object(self, name: str, objtype: str, node_id: str, location: Any = None) -> None:
1166         """Note a python object for cross reference.
1167 
1168         .. versionadded:: 2.1
1169         """
1170         if name in self.objects:
1171             other = self.objects[name]
1172             logger.warning(__('duplicate object description of %s, '
1173                               'other instance in %s, use :noindex: for one of them'),
1174                            name, other.docname, location=location)
1175         self.objects[name] = ObjectEntry(self.env.docname, node_id, objtype)
1176 
1177     @property
1178     def modules(self) -> Dict[str, ModuleEntry]:
1179         return self.data.setdefault('modules', {})  # modname -> ModuleEntry
1180 
1181     def note_module(self, name: str, node_id: str, synopsis: str,
1182                     platform: str, deprecated: bool) -> None:
1183         """Note a python module for cross reference.
1184 
1185         .. versionadded:: 2.1
1186         """
1187         self.modules[name] = ModuleEntry(self.env.docname, node_id,
1188                                          synopsis, platform, deprecated)
1189 
1190     def clear_doc(self, docname: str) -> None:
1191         for fullname, obj in list(self.objects.items()):
1192             if obj.docname == docname:
1193                 del self.objects[fullname]
1194         for modname, mod in list(self.modules.items()):
1195             if mod.docname == docname:
1196                 del self.modules[modname]
1197 
1198     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
1199         # XXX check duplicates?
1200         for fullname, obj in otherdata['objects'].items():
1201             if obj.docname in docnames:
1202                 self.objects[fullname] = obj
1203         for modname, mod in otherdata['modules'].items():
1204             if mod.docname in docnames:
1205                 self.modules[modname] = mod
1206 
1207     def find_obj(self, env: BuildEnvironment, modname: str, classname: str,
1208                  name: str, type: str, searchmode: int = 0
1209                  ) -> List[Tuple[str, ObjectEntry]]:
1210         """Find a Python object for "name", perhaps using the given module
1211         and/or classname.  Returns a list of (name, object entry) tuples.
1212         """
1213         # skip parens
1214         if name[-2:] == '()':
1215             name = name[:-2]
1216 
1217         if not name:
1218             return []
1219 
1220         matches = []  # type: List[Tuple[str, ObjectEntry]]
1221 
1222         newname = None
1223         if searchmode == 1:
1224             if type is None:
1225                 objtypes = list(self.object_types)
1226             else:
1227                 objtypes = self.objtypes_for_role(type)
1228             if objtypes is not None:
1229                 if modname and classname:
1230                     fullname = modname + '.' + classname + '.' + name
1231                     if fullname in self.objects and self.objects[fullname].objtype in objtypes:
1232                         newname = fullname
1233                 if not newname:
1234                     if modname and modname + '.' + name in self.objects and \
1235                        self.objects[modname + '.' + name].objtype in objtypes:
1236                         newname = modname + '.' + name
1237                     elif name in self.objects and self.objects[name].objtype in objtypes:
1238                         newname = name
1239                     else:
1240                         # "fuzzy" searching mode
1241                         searchname = '.' + name
1242                         matches = [(oname, self.objects[oname]) for oname in self.objects
1243                                    if oname.endswith(searchname) and
1244                                    self.objects[oname].objtype in objtypes]
1245         else:
1246             # NOTE: searching for exact match, object type is not considered
1247             if name in self.objects:
1248                 newname = name
1249             elif type == 'mod':
1250                 # only exact matches allowed for modules
1251                 return []
1252             elif classname and classname + '.' + name in self.objects:
1253                 newname = classname + '.' + name
1254             elif modname and modname + '.' + name in self.objects:
1255                 newname = modname + '.' + name
1256             elif modname and classname and \
1257                     modname + '.' + classname + '.' + name in self.objects:
1258                 newname = modname + '.' + classname + '.' + name
1259         if newname is not None:
1260             matches.append((newname, self.objects[newname]))
1261         return matches
1262 
1263     def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,
1264                      type: str, target: str, node: pending_xref, contnode: Element
1265                      ) -> Element:
1266         modname = node.get('py:module')
1267         clsname = node.get('py:class')
1268         searchmode = 1 if node.hasattr('refspecific') else 0
1269         matches = self.find_obj(env, modname, clsname, target,
1270                                 type, searchmode)
1271 
1272         if not matches and type == 'attr':
1273             # fallback to meth (for property)
1274             matches = self.find_obj(env, modname, clsname, target, 'meth', searchmode)
1275 
1276         if not matches:
1277             return None
1278         elif len(matches) > 1:
1279             logger.warning(__('more than one target found for cross-reference %r: %s'),
1280                            target, ', '.join(match[0] for match in matches),
1281                            type='ref', subtype='python', location=node)
1282         name, obj = matches[0]
1283 
1284         if obj[2] == 'module':
1285             return self._make_module_refnode(builder, fromdocname, name, contnode)
1286         else:
1287             return make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name)
1288 
1289     def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,
1290                          target: str, node: pending_xref, contnode: Element
1291                          ) -> List[Tuple[str, Element]]:
1292         modname = node.get('py:module')
1293         clsname = node.get('py:class')
1294         results = []  # type: List[Tuple[str, Element]]
1295 
1296         # always search in "refspecific" mode with the :any: role
1297         matches = self.find_obj(env, modname, clsname, target, None, 1)
1298         for name, obj in matches:
1299             if obj[2] == 'module':
1300                 results.append(('py:mod',
1301                                 self._make_module_refnode(builder, fromdocname,
1302                                                           name, contnode)))
1303             else:
1304                 results.append(('py:' + self.role_for_objtype(obj[2]),
1305                                 make_refnode(builder, fromdocname, obj[0], obj[1],
1306                                              contnode, name)))
1307         return results
1308 
1309     def _make_module_refnode(self, builder: Builder, fromdocname: str, name: str,
1310                              contnode: Node) -> Element:
1311         # get additional info for modules
1312         module = self.modules[name]
1313         title = name
1314         if module.synopsis:
1315             title += ': ' + module.synopsis
1316         if module.deprecated:
1317             title += _(' (deprecated)')
1318         if module.platform:
1319             title += ' (' + module.platform + ')'
1320         return make_refnode(builder, fromdocname, module.docname, module.node_id,
1321                             contnode, title)
1322 
1323     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:
1324         for modname, mod in self.modules.items():
1325             yield (modname, modname, 'module', mod.docname, mod.node_id, 0)
1326         for refname, obj in self.objects.items():
1327             if obj.objtype != 'module':  # modules are already handled
1328                 yield (refname, refname, obj.objtype, obj.docname, obj.node_id, 1)
1329 
1330     def get_full_qualified_name(self, node: Element) -> str:
1331         modname = node.get('py:module')
1332         clsname = node.get('py:class')
1333         target = node.get('reftarget')
1334         if target is None:
1335             return None
1336         else:
1337             return '.'.join(filter(None, [modname, clsname, target]))
1338 
1339 
1340 def builtin_resolver(app: Sphinx, env: BuildEnvironment,
1341                      node: pending_xref, contnode: Element) -> Element:
1342     """Do not emit nitpicky warnings for built-in types."""
1343     def istyping(s: str) -> bool:
1344         if s.startswith('typing.'):
1345             s = s.split('.', 1)[1]
1346 
1347         return s in typing.__all__  # type: ignore
1348 
1349     if node.get('refdomain') != 'py':
1350         return None
1351     elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':
1352         return contnode
1353     elif node.get('reftype') in ('class', 'exc'):
1354         reftarget = node.get('reftarget')
1355         if inspect.isclass(getattr(builtins, reftarget, None)):
1356             # built-in class
1357             return contnode
1358         elif istyping(reftarget):
1359             # typing class
1360             return contnode
1361 
1362     return None
1363 
1364 
1365 def setup(app: Sphinx) -> Dict[str, Any]:
1366     app.setup_extension('sphinx.directives')
1367 
1368     app.add_domain(PythonDomain)
1369     app.connect('object-description-transform', filter_meta_fields)
1370     app.connect('missing-reference', builtin_resolver, priority=900)
1371 
1372     return {
1373         'version': 'builtin',
1374         'env_version': 2,
1375         'parallel_read_safe': True,
1376         'parallel_write_safe': True,
1377     }

</code><intended_behavior>Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately.</intended_behavior>, <file>sphinx/directives/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.directives
3     ~~~~~~~~~~~~~~~~~
4 
5     Handlers for additional ReST directives.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 from typing import Any, Dict, List, Tuple
13 from typing import cast
14 
15 from docutils import nodes
16 from docutils.nodes import Node
17 from docutils.parsers.rst import directives, roles
18 
19 from sphinx import addnodes
20 from sphinx.addnodes import desc_signature
21 from sphinx.deprecation import (
22     RemovedInSphinx40Warning, RemovedInSphinx50Warning, deprecated_alias
23 )
24 from sphinx.util import docutils
25 from sphinx.util.docfields import DocFieldTransformer, Field, TypedField
26 from sphinx.util.docutils import SphinxDirective
27 from sphinx.util.typing import DirectiveOption
28 
29 if False:
30     # For type annotation
31     from sphinx.application import Sphinx
32 
33 
34 # RE to strip backslash escapes
35 nl_escape_re = re.compile(r'\\\n')
36 strip_backslash_re = re.compile(r'\\(.)')
37 
38 
39 def optional_int(argument: str) -> int:
40     """
41     Check for an integer argument or None value; raise ``ValueError`` if not.
42     """
43     if argument is None:
44         return None
45     else:
46         value = int(argument)
47         if value < 0:
48             raise ValueError('negative value; must be positive or zero')
49         return value
50 
51 
52 class ObjectDescription(SphinxDirective):
53     """
54     Directive to describe a class, function or similar object.  Not used
55     directly, but subclassed (in domain-specific directives) to add custom
56     behavior.
57     """
58 
59     has_content = True
60     required_arguments = 1
61     optional_arguments = 0
62     final_argument_whitespace = True
63     option_spec = {
64         'noindex': directives.flag,
65     }  # type: Dict[str, DirectiveOption]
66 
67     # types of doc fields that this directive handles, see sphinx.util.docfields
68     doc_field_types = []    # type: List[Field]
69     domain = None           # type: str
70     objtype = None          # type: str
71     indexnode = None        # type: addnodes.index
72 
73     # Warning: this might be removed in future version. Don't touch this from extensions.
74     _doc_field_type_map = {}  # type: Dict[str, Tuple[Field, bool]]
75 
76     def get_field_type_map(self) -> Dict[str, Tuple[Field, bool]]:
77         if self._doc_field_type_map == {}:
78             self._doc_field_type_map = {}
79             for field in self.doc_field_types:
80                 for name in field.names:
81                     self._doc_field_type_map[name] = (field, False)
82 
83                 if field.is_typed:
84                     typed_field = cast(TypedField, field)
85                     for name in typed_field.typenames:
86                         self._doc_field_type_map[name] = (field, True)
87 
88         return self._doc_field_type_map
89 
90     def get_signatures(self) -> List[str]:
91         """
92         Retrieve the signatures to document from the directive arguments.  By
93         default, signatures are given as arguments, one per line.
94         """
95         lines = nl_escape_re.sub('', self.arguments[0]).split('\n')
96         if self.config.strip_signature_backslash:
97             # remove backslashes to support (dummy) escapes; helps Vim highlighting
98             return [strip_backslash_re.sub(r'\1', line.strip()) for line in lines]
99         else:
100             return [line.strip() for line in lines]
101 
102     def handle_signature(self, sig: str, signode: desc_signature) -> Any:
103         """
104         Parse the signature *sig* into individual nodes and append them to
105         *signode*. If ValueError is raised, parsing is aborted and the whole
106         *sig* is put into a single desc_name node.
107 
108         The return value should be a value that identifies the object.  It is
109         passed to :meth:`add_target_and_index()` unchanged, and otherwise only
110         used to skip duplicates.
111         """
112         raise ValueError
113 
114     def add_target_and_index(self, name: Any, sig: str, signode: desc_signature) -> None:
115         """
116         Add cross-reference IDs and entries to self.indexnode, if applicable.
117 
118         *name* is whatever :meth:`handle_signature()` returned.
119         """
120         return  # do nothing by default
121 
122     def before_content(self) -> None:
123         """
124         Called before parsing content. Used to set information about the current
125         directive context on the build environment.
126         """
127         pass
128 
129     def transform_content(self, contentnode: addnodes.desc_content) -> None:
130         """
131         Called after creating the content through nested parsing,
132         but before the ``object-description-transform`` event is emitted,
133         and before the info-fields are transformed.
134         Can be used to manipulate the content.
135         """
136         pass
137 
138     def after_content(self) -> None:
139         """
140         Called after parsing content. Used to reset information about the
141         current directive context on the build environment.
142         """
143         pass
144 
145     def run(self) -> List[Node]:
146         """
147         Main directive entry function, called by docutils upon encountering the
148         directive.
149 
150         This directive is meant to be quite easily subclassable, so it delegates
151         to several additional methods.  What it does:
152 
153         * find out if called as a domain-specific directive, set self.domain
154         * create a `desc` node to fit all description inside
155         * parse standard options, currently `noindex`
156         * create an index node if needed as self.indexnode
157         * parse all given signatures (as returned by self.get_signatures())
158           using self.handle_signature(), which should either return a name
159           or raise ValueError
160         * add index entries using self.add_target_and_index()
161         * parse the content and handle doc fields in it
162         """
163         if ':' in self.name:
164             self.domain, self.objtype = self.name.split(':', 1)
165         else:
166             self.domain, self.objtype = '', self.name
167         self.indexnode = addnodes.index(entries=[])
168 
169         node = addnodes.desc()
170         node.document = self.state.document
171         node['domain'] = self.domain
172         # 'desctype' is a backwards compatible attribute
173         node['objtype'] = node['desctype'] = self.objtype
174         node['noindex'] = noindex = ('noindex' in self.options)
175         if self.domain:
176             node['classes'].append(self.domain)
177 
178         self.names = []  # type: List[Any]
179         signatures = self.get_signatures()
180         for i, sig in enumerate(signatures):
181             # add a signature node for each signature in the current unit
182             # and add a reference target for it
183             signode = addnodes.desc_signature(sig, '')
184             self.set_source_info(signode)
185             node.append(signode)
186             try:
187                 # name can also be a tuple, e.g. (classname, objname);
188                 # this is strictly domain-specific (i.e. no assumptions may
189                 # be made in this base class)
190                 name = self.handle_signature(sig, signode)
191             except ValueError:
192                 # signature parsing failed
193                 signode.clear()
194                 signode += addnodes.desc_name(sig, sig)
195                 continue  # we don't want an index entry here
196             if name not in self.names:
197                 self.names.append(name)
198                 if not noindex:
199                     # only add target and index entry if this is the first
200                     # description of the object with this name in this desc block
201                     self.add_target_and_index(name, sig, signode)
202 
203         contentnode = addnodes.desc_content()
204         node.append(contentnode)
205         if self.names:
206             # needed for association of version{added,changed} directives
207             self.env.temp_data['object'] = self.names[0]
208         self.before_content()
209         self.state.nested_parse(self.content, self.content_offset, contentnode)
210         self.transform_content(contentnode)
211         self.env.app.emit('object-description-transform',
212                           self.domain, self.objtype, contentnode)
213         DocFieldTransformer(self).transform_all(contentnode)
214         self.env.temp_data['object'] = None
215         self.after_content()
216         return [self.indexnode, node]
217 
218 
219 class DefaultRole(SphinxDirective):
220     """
221     Set the default interpreted text role.  Overridden from docutils.
222     """
223 
224     optional_arguments = 1
225     final_argument_whitespace = False
226 
227     def run(self) -> List[Node]:
228         if not self.arguments:
229             docutils.unregister_role('')
230             return []
231         role_name = self.arguments[0]
232         role, messages = roles.role(role_name, self.state_machine.language,
233                                     self.lineno, self.state.reporter)
234         if role:
235             docutils.register_role('', role)
236             self.env.temp_data['default_role'] = role_name
237         else:
238             literal_block = nodes.literal_block(self.block_text, self.block_text)
239             reporter = self.state.reporter
240             error = reporter.error('Unknown interpreted text role "%s".' % role_name,
241                                    literal_block, line=self.lineno)
242             messages += [error]
243 
244         return cast(List[nodes.Node], messages)
245 
246 
247 class DefaultDomain(SphinxDirective):
248     """
249     Directive to (re-)set the default domain for this source file.
250     """
251 
252     has_content = False
253     required_arguments = 1
254     optional_arguments = 0
255     final_argument_whitespace = False
256     option_spec = {}  # type: Dict
257 
258     def run(self) -> List[Node]:
259         domain_name = self.arguments[0].lower()
260         # if domain_name not in env.domains:
261         #     # try searching by label
262         #     for domain in env.domains.values():
263         #         if domain.label.lower() == domain_name:
264         #             domain_name = domain.name
265         #             break
266         self.env.temp_data['default_domain'] = self.env.domains.get(domain_name)
267         return []
268 
269 from sphinx.directives.code import (  # noqa
270     Highlight, CodeBlock, LiteralInclude
271 )
272 from sphinx.directives.other import (  # noqa
273     TocTree, Author, VersionChange, SeeAlso,
274     TabularColumns, Centered, Acks, HList, Only, Include, Class
275 )
276 from sphinx.directives.patches import (  # noqa
277     Figure, Meta
278 )
279 from sphinx.domains.index import IndexDirective  # noqa
280 
281 deprecated_alias('sphinx.directives',
282                  {
283                      'Highlight': Highlight,
284                      'CodeBlock': CodeBlock,
285                      'LiteralInclude': LiteralInclude,
286                      'TocTree': TocTree,
287                      'Author': Author,
288                      'Index': IndexDirective,
289                      'VersionChange': VersionChange,
290                      'SeeAlso': SeeAlso,
291                      'TabularColumns': TabularColumns,
292                      'Centered': Centered,
293                      'Acks': Acks,
294                      'HList': HList,
295                      'Only': Only,
296                      'Include': Include,
297                      'Class': Class,
298                      'Figure': Figure,
299                      'Meta': Meta,
300                  },
301                  RemovedInSphinx40Warning)
302 
303 deprecated_alias('sphinx.directives',
304                  {
305                      'DescDirective': ObjectDescription,
306                  },
307                  RemovedInSphinx50Warning)
308 
309 
310 def setup(app: "Sphinx") -> Dict[str, Any]:
311     app.add_config_value("strip_signature_backslash", False, 'env')
312     directives.register_directive('default-role', DefaultRole)
313     directives.register_directive('default-domain', DefaultDomain)
314     directives.register_directive('describe', ObjectDescription)
315     # new, more consistent, name
316     directives.register_directive('object', ObjectDescription)
317 
318     app.add_event('object-description-transform')
319 
320     return {
321         'version': 'builtin',
322         'parallel_read_safe': True,
323         'parallel_write_safe': True,
324     }

</code><intended_behavior>Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately.</intended_behavior>]
2025-10-17 18:48:11.001 | INFO     | Search completed. Bug locations: [<file>sphinx/domains/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.domains.python
3     ~~~~~~~~~~~~~~~~~~~~~
4 
5     The Python domain.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import builtins
12 import inspect
13 import re
14 import typing
15 import warnings
16 from inspect import Parameter
17 from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Tuple
18 from typing import cast
19 
20 from docutils import nodes
21 from docutils.nodes import Element, Node
22 from docutils.parsers.rst import directives
23 
24 from sphinx import addnodes
25 from sphinx.addnodes import pending_xref, desc_signature
26 from sphinx.application import Sphinx
27 from sphinx.builders import Builder
28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
29 from sphinx.directives import ObjectDescription
30 from sphinx.domains import Domain, ObjType, Index, IndexEntry
31 from sphinx.environment import BuildEnvironment
32 from sphinx.locale import _, __
33 from sphinx.pycode.ast import ast, parse as ast_parse
34 from sphinx.roles import XRefRole
35 from sphinx.util import logging
36 from sphinx.util.docfields import Field, GroupedField, TypedField
37 from sphinx.util.docutils import SphinxDirective
38 from sphinx.util.inspect import signature_from_str
39 from sphinx.util.nodes import make_id, make_refnode
40 from sphinx.util.typing import TextlikeNode
41 
42 if False:
43     # For type annotation
44     from typing import Type  # for python3.5.1
45 
46 
47 logger = logging.getLogger(__name__)
48 
49 
50 # REs for Python signatures
51 py_sig_re = re.compile(
52     r'''^ ([\w.]*\.)?            # class name(s)
53           (\w+)  \s*             # thing name
54           (?: \(\s*(.*)\s*\)     # optional: arguments
55            (?:\s* -> \s* (.*))?  #           return annotation
56           )? $                   # and nothing more
57           ''', re.VERBOSE)
58 
59 
60 pairindextypes = {
61     'module':    _('module'),
62     'keyword':   _('keyword'),
63     'operator':  _('operator'),
64     'object':    _('object'),
65     'exception': _('exception'),
66     'statement': _('statement'),
67     'builtin':   _('built-in function'),
68 }
69 
70 ObjectEntry = NamedTuple('ObjectEntry', [('docname', str),
71                                          ('node_id', str),
72                                          ('objtype', str)])
73 ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),
74                                          ('node_id', str),
75                                          ('synopsis', str),
76                                          ('platform', str),
77                                          ('deprecated', bool)])
78 
79 
80 def type_to_xref(text: str) -> addnodes.pending_xref:
81     """Convert a type string to a cross reference node."""
82     if text == 'None':
83         reftype = 'obj'
84     else:
85         reftype = 'class'
86 
87     return pending_xref('', nodes.Text(text),
88                         refdomain='py', reftype=reftype, reftarget=text)
89 
90 
91 def _parse_annotation(annotation: str) -> List[Node]:
92     """Parse type annotation."""
93     def unparse(node: ast.AST) -> List[Node]:
94         if isinstance(node, ast.Attribute):
95             return [nodes.Text("%s.%s" % (unparse(node.value)[0], node.attr))]
96         elif isinstance(node, ast.Expr):
97             return unparse(node.value)
98         elif isinstance(node, ast.Index):
99             return unparse(node.value)
100         elif isinstance(node, ast.List):
101             result = [addnodes.desc_sig_punctuation('', '[')]  # type: List[Node]
102             for elem in node.elts:
103                 result.extend(unparse(elem))
104                 result.append(addnodes.desc_sig_punctuation('', ', '))
105             result.pop()
106             result.append(addnodes.desc_sig_punctuation('', ']'))
107             return result
108         elif isinstance(node, ast.Module):
109             return sum((unparse(e) for e in node.body), [])
110         elif isinstance(node, ast.Name):
111             return [nodes.Text(node.id)]
112         elif isinstance(node, ast.Subscript):
113             result = unparse(node.value)
114             result.append(addnodes.desc_sig_punctuation('', '['))
115             result.extend(unparse(node.slice))
116             result.append(addnodes.desc_sig_punctuation('', ']'))
117             return result
118         elif isinstance(node, ast.Tuple):
119             if node.elts:
120                 result = []
121                 for elem in node.elts:
122                     result.extend(unparse(elem))
123                     result.append(addnodes.desc_sig_punctuation('', ', '))
124                 result.pop()
125             else:
126                 result = [addnodes.desc_sig_punctuation('', '('),
127                           addnodes.desc_sig_punctuation('', ')')]
128 
129             return result
130         else:
131             raise SyntaxError  # unsupported syntax
132 
133     try:
134         tree = ast_parse(annotation)
135         result = unparse(tree)
136         for i, node in enumerate(result):
137             if isinstance(node, nodes.Text):
138                 result[i] = type_to_xref(str(node))
139         return result
140     except SyntaxError:
141         return [type_to_xref(annotation)]
142 
143 
144 def _parse_arglist(arglist: str) -> addnodes.desc_parameterlist:
145     """Parse a list of arguments using AST parser"""
146     params = addnodes.desc_parameterlist(arglist)
147     sig = signature_from_str('(%s)' % arglist)
148     last_kind = None
149     for param in sig.parameters.values():
150         if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:
151             # PEP-570: Separator for Positional Only Parameter: /
152             params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))
153         if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,
154                                                               param.POSITIONAL_ONLY,
155                                                               None):
156             # PEP-3102: Separator for Keyword Only Parameter: *
157             params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '*'))
158 
159         node = addnodes.desc_parameter()
160         if param.kind == param.VAR_POSITIONAL:
161             node += addnodes.desc_sig_operator('', '*')
162             node += addnodes.desc_sig_name('', param.name)
163         elif param.kind == param.VAR_KEYWORD:
164             node += addnodes.desc_sig_operator('', '**')
165             node += addnodes.desc_sig_name('', param.name)
166         else:
167             node += addnodes.desc_sig_name('', param.name)
168 
169         if param.annotation is not param.empty:
170             children = _parse_annotation(param.annotation)
171             node += addnodes.desc_sig_punctuation('', ':')
172             node += nodes.Text(' ')
173             node += addnodes.desc_sig_name('', '', *children)  # type: ignore
174         if param.default is not param.empty:
175             if param.annotation is not param.empty:
176                 node += nodes.Text(' ')
177                 node += addnodes.desc_sig_operator('', '=')
178                 node += nodes.Text(' ')
179             else:
180                 node += addnodes.desc_sig_operator('', '=')
181             node += nodes.inline('', param.default, classes=['default_value'],
182                                  support_smartquotes=False)
183 
184         params += node
185         last_kind = param.kind
186 
187     if last_kind == Parameter.POSITIONAL_ONLY:
188         # PEP-570: Separator for Positional Only Parameter: /
189         params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))
190 
191     return params
192 
193 
194 def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:
195     """"Parse" a list of arguments separated by commas.
196 
197     Arguments can have "optional" annotations given by enclosing them in
198     brackets.  Currently, this will split at any comma, even if it's inside a
199     string literal (e.g. default argument value).
200     """
201     paramlist = addnodes.desc_parameterlist()
202     stack = [paramlist]  # type: List[Element]
203     try:
204         for argument in arglist.split(','):
205             argument = argument.strip()
206             ends_open = ends_close = 0
207             while argument.startswith('['):
208                 stack.append(addnodes.desc_optional())
209                 stack[-2] += stack[-1]
210                 argument = argument[1:].strip()
211             while argument.startswith(']'):
212                 stack.pop()
213                 argument = argument[1:].strip()
214             while argument.endswith(']') and not argument.endswith('[]'):
215                 ends_close += 1
216                 argument = argument[:-1].strip()
217             while argument.endswith('['):
218                 ends_open += 1
219                 argument = argument[:-1].strip()
220             if argument:
221                 stack[-1] += addnodes.desc_parameter(argument, argument)
222             while ends_open:
223                 stack.append(addnodes.desc_optional())
224                 stack[-2] += stack[-1]
225                 ends_open -= 1
226             while ends_close:
227                 stack.pop()
228                 ends_close -= 1
229         if len(stack) != 1:
230             raise IndexError
231     except IndexError:
232         # if there are too few or too many elements on the stack, just give up
233         # and treat the whole argument list as one argument, discarding the
234         # already partially populated paramlist node
235         paramlist = addnodes.desc_parameterlist()
236         paramlist += addnodes.desc_parameter(arglist, arglist)
237         signode += paramlist
238     else:
239         signode += paramlist
240 
241 
242 # This override allows our inline type specifiers to behave like :class: link
243 # when it comes to handling "." and "~" prefixes.
244 class PyXrefMixin:
245     def make_xref(self, rolename: str, domain: str, target: str,
246                   innernode: "Type[TextlikeNode]" = nodes.emphasis,
247                   contnode: Node = None, env: BuildEnvironment = None) -> Node:
248         result = super().make_xref(rolename, domain, target,  # type: ignore
249                                    innernode, contnode, env)
250         result['refspecific'] = True
251         if target.startswith(('.', '~')):
252             prefix, result['reftarget'] = target[0], target[1:]
253             if prefix == '.':
254                 text = target[1:]
255             elif prefix == '~':
256                 text = target.split('.')[-1]
257             for node in result.traverse(nodes.Text):
258                 node.parent[node.parent.index(node)] = nodes.Text(text)
259                 break
260         return result
261 
262     def make_xrefs(self, rolename: str, domain: str, target: str,
263                    innernode: "Type[TextlikeNode]" = nodes.emphasis,
264                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:
265         delims = r'(\s*[\[\]\(\),](?:\s*or\s)?\s*|\s+or\s+)'
266         delims_re = re.compile(delims)
267         sub_targets = re.split(delims, target)
268 
269         split_contnode = bool(contnode and contnode.astext() == target)
270 
271         results = []
272         for sub_target in filter(None, sub_targets):
273             if split_contnode:
274                 contnode = nodes.Text(sub_target)
275 
276             if delims_re.match(sub_target):
277                 results.append(contnode or innernode(sub_target, sub_target))
278             else:
279                 results.append(self.make_xref(rolename, domain, sub_target,
280                                               innernode, contnode, env))
281 
282         return results
283 
284 
285 class PyField(PyXrefMixin, Field):
286     def make_xref(self, rolename: str, domain: str, target: str,
287                   innernode: "Type[TextlikeNode]" = nodes.emphasis,
288                   contnode: Node = None, env: BuildEnvironment = None) -> Node:
289         if rolename == 'class' and target == 'None':
290             # None is not a type, so use obj role instead.
291             rolename = 'obj'
292 
293         return super().make_xref(rolename, domain, target, innernode, contnode, env)
294 
295 
296 class PyGroupedField(PyXrefMixin, GroupedField):
297     pass
298 
299 
300 class PyTypedField(PyXrefMixin, TypedField):
301     def make_xref(self, rolename: str, domain: str, target: str,
302                   innernode: "Type[TextlikeNode]" = nodes.emphasis,
303                   contnode: Node = None, env: BuildEnvironment = None) -> Node:
304         if rolename == 'class' and target == 'None':
305             # None is not a type, so use obj role instead.
306             rolename = 'obj'
307 
308         return super().make_xref(rolename, domain, target, innernode, contnode, env)
309 
310 
311 class PyObject(ObjectDescription):
312     """
313     Description of a general Python object.
314 
315     :cvar allow_nesting: Class is an object that allows for nested namespaces
316     :vartype allow_nesting: bool
317     """
318     option_spec = {
319         'noindex': directives.flag,
320         'module': directives.unchanged,
321         'annotation': directives.unchanged,
322     }
323 
324     doc_field_types = [
325         PyTypedField('parameter', label=_('Parameters'),
326                      names=('param', 'parameter', 'arg', 'argument',
327                             'keyword', 'kwarg', 'kwparam'),
328                      typerolename='class', typenames=('paramtype', 'type'),
329                      can_collapse=True),
330         PyTypedField('variable', label=_('Variables'), rolename='obj',
331                      names=('var', 'ivar', 'cvar'),
332                      typerolename='class', typenames=('vartype',),
333                      can_collapse=True),
334         PyGroupedField('exceptions', label=_('Raises'), rolename='exc',
335                        names=('raises', 'raise', 'exception', 'except'),
336                        can_collapse=True),
337         Field('returnvalue', label=_('Returns'), has_arg=False,
338               names=('returns', 'return')),
339         PyField('returntype', label=_('Return type'), has_arg=False,
340                 names=('rtype',), bodyrolename='class'),
341     ]
342 
343     allow_nesting = False
344 
345     def get_signature_prefix(self, sig: str) -> str:
346         """May return a prefix to put before the object name in the
347         signature.
348         """
349         return ''
350 
351     def needs_arglist(self) -> bool:
352         """May return true if an empty argument list is to be generated even if
353         the document contains none.
354         """
355         return False
356 
357     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
358         """Transform a Python signature into RST nodes.
359 
360         Return (fully qualified name of the thing, classname if any).
361 
362         If inside a class, the current class name is handled intelligently:
363         * it is stripped from the displayed name if present
364         * it is added to the full name (return value) if not present
365         """
366         m = py_sig_re.match(sig)
367         if m is None:
368             raise ValueError
369         prefix, name, arglist, retann = m.groups()
370 
371         # determine module and class name (if applicable), as well as full name
372         modname = self.options.get('module', self.env.ref_context.get('py:module'))
373         classname = self.env.ref_context.get('py:class')
374         if classname:
375             add_module = False
376             if prefix and (prefix == classname or
377                            prefix.startswith(classname + ".")):
378                 fullname = prefix + name
379                 # class name is given again in the signature
380                 prefix = prefix[len(classname):].lstrip('.')
381             elif prefix:
382                 # class name is given in the signature, but different
383                 # (shouldn't happen)
384                 fullname = classname + '.' + prefix + name
385             else:
386                 # class name is not given in the signature
387                 fullname = classname + '.' + name
388         else:
389             add_module = True
390             if prefix:
391                 classname = prefix.rstrip('.')
392                 fullname = prefix + name
393             else:
394                 classname = ''
395                 fullname = name
396 
397         signode['module'] = modname
398         signode['class'] = classname
399         signode['fullname'] = fullname
400 
401         sig_prefix = self.get_signature_prefix(sig)
402         if sig_prefix:
403             signode += addnodes.desc_annotation(sig_prefix, sig_prefix)
404 
405         if prefix:
406             signode += addnodes.desc_addname(prefix, prefix)
407         elif add_module and self.env.config.add_module_names:
408             if modname and modname != 'exceptions':
409                 # exceptions are a special case, since they are documented in the
410                 # 'exceptions' module.
411                 nodetext = modname + '.'
412                 signode += addnodes.desc_addname(nodetext, nodetext)
413 
414         signode += addnodes.desc_name(name, name)
415         if arglist:
416             try:
417                 signode += _parse_arglist(arglist)
418             except SyntaxError:
419                 # fallback to parse arglist original parser.
420                 # it supports to represent optional arguments (ex. "func(foo [, bar])")
421                 _pseudo_parse_arglist(signode, arglist)
422             except NotImplementedError as exc:
423                 logger.warning("could not parse arglist (%r): %s", arglist, exc,
424                                location=signode)
425                 _pseudo_parse_arglist(signode, arglist)
426         else:
427             if self.needs_arglist():
428                 # for callables, add an empty parameter list
429                 signode += addnodes.desc_parameterlist()
430 
431         if retann:
432             children = _parse_annotation(retann)
433             signode += addnodes.desc_returns(retann, '', *children)
434 
435         anno = self.options.get('annotation')
436         if anno:
437             signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)
438 
439         return fullname, prefix
440 
441     def get_index_text(self, modname: str, name: Tuple[str, str]) -> str:
442         """Return the text for the index entry of the object."""
443         raise NotImplementedError('must be implemented in subclasses')
444 
445     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,
446                              signode: desc_signature) -> None:
447         modname = self.options.get('module', self.env.ref_context.get('py:module'))
448         fullname = (modname + '.' if modname else '') + name_cls[0]
449         node_id = make_id(self.env, self.state.document, '', fullname)
450         signode['ids'].append(node_id)
451 
452         # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)
453         # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)
454         if node_id != fullname and fullname not in self.state.document.ids:
455             signode['ids'].append(fullname)
456 
457         self.state.document.note_explicit_target(signode)
458 
459         domain = cast(PythonDomain, self.env.get_domain('py'))
460         domain.note_object(fullname, self.objtype, node_id, location=signode)
461 
462         indextext = self.get_index_text(modname, name_cls)
463         if indextext:
464             self.indexnode['entries'].append(('single', indextext, node_id, '', None))
465 
466     def before_content(self) -> None:
467         """Handle object nesting before content
468 
469         :py:class:`PyObject` represents Python language constructs. For
470         constructs that are nestable, such as a Python classes, this method will
471         build up a stack of the nesting heirarchy so that it can be later
472         de-nested correctly, in :py:meth:`after_content`.
473 
474         For constructs that aren't nestable, the stack is bypassed, and instead
475         only the most recent object is tracked. This object prefix name will be
476         removed with :py:meth:`after_content`.
477         """
478         prefix = None
479         if self.names:
480             # fullname and name_prefix come from the `handle_signature` method.
481             # fullname represents the full object name that is constructed using
482             # object nesting and explicit prefixes. `name_prefix` is the
483             # explicit prefix given in a signature
484             (fullname, name_prefix) = self.names[-1]
485             if self.allow_nesting:
486                 prefix = fullname
487             elif name_prefix:
488                 prefix = name_prefix.strip('.')
489         if prefix:
490             self.env.ref_context['py:class'] = prefix
491             if self.allow_nesting:
492                 classes = self.env.ref_context.setdefault('py:classes', [])
493                 classes.append(prefix)
494         if 'module' in self.options:
495             modules = self.env.ref_context.setdefault('py:modules', [])
496             modules.append(self.env.ref_context.get('py:module'))
497             self.env.ref_context['py:module'] = self.options['module']
498 
499     def after_content(self) -> None:
500         """Handle object de-nesting after content
501 
502         If this class is a nestable object, removing the last nested class prefix
503         ends further nesting in the object.
504 
505         If this class is not a nestable object, the list of classes should not
506         be altered as we didn't affect the nesting levels in
507         :py:meth:`before_content`.
508         """
509         classes = self.env.ref_context.setdefault('py:classes', [])
510         if self.allow_nesting:
511             try:
512                 classes.pop()
513             except IndexError:
514                 pass
515         self.env.ref_context['py:class'] = (classes[-1] if len(classes) > 0
516                                             else None)
517         if 'module' in self.options:
518             modules = self.env.ref_context.setdefault('py:modules', [])
519             if modules:
520                 self.env.ref_context['py:module'] = modules.pop()
521             else:
522                 self.env.ref_context.pop('py:module')
523 
524 
525 class PyModulelevel(PyObject):
526     """
527     Description of an object on module level (functions, data).
528     """
529 
530     def run(self) -> List[Node]:
531         for cls in self.__class__.__mro__:
532             if cls.__name__ != 'DirectiveAdapter':
533                 warnings.warn('PyModulelevel is deprecated. '
534                               'Please check the implementation of %s' % cls,
535                               RemovedInSphinx40Warning, stacklevel=2)
536                 break
537         else:
538             warnings.warn('PyModulelevel is deprecated',
539                           RemovedInSphinx40Warning, stacklevel=2)
540 
541         return super().run()
542 
543     def needs_arglist(self) -> bool:
544         return self.objtype == 'function'
545 
546     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
547         if self.objtype == 'function':
548             if not modname:
549                 return _('%s() (built-in function)') % name_cls[0]
550             return _('%s() (in module %s)') % (name_cls[0], modname)
551         elif self.objtype == 'data':
552             if not modname:
553                 return _('%s (built-in variable)') % name_cls[0]
554             return _('%s (in module %s)') % (name_cls[0], modname)
555         else:
556             return ''
557 
558 
559 class PyFunction(PyObject):
560     """Description of a function."""
561 
562     option_spec = PyObject.option_spec.copy()
563     option_spec.update({
564         'async': directives.flag,
565     })
566 
567     def get_signature_prefix(self, sig: str) -> str:
568         if 'async' in self.options:
569             return 'async '
570         else:
571             return ''
572 
573     def needs_arglist(self) -> bool:
574         return True
575 
576     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,
577                              signode: desc_signature) -> None:
578         super().add_target_and_index(name_cls, sig, signode)
579         modname = self.options.get('module', self.env.ref_context.get('py:module'))
580         node_id = signode['ids'][0]
581 
582         name, cls = name_cls
583         if modname:
584             text = _('%s() (in module %s)') % (name, modname)
585             self.indexnode['entries'].append(('single', text, node_id, '', None))
586         else:
587             text = '%s; %s()' % (pairindextypes['builtin'], name)
588             self.indexnode['entries'].append(('pair', text, node_id, '', None))
589 
590     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
591         # add index in own add_target_and_index() instead.
592         return None
593 
594 
595 class PyDecoratorFunction(PyFunction):
596     """Description of a decorator."""
597 
598     def run(self) -> List[Node]:
599         # a decorator function is a function after all
600         self.name = 'py:function'
601         return super().run()
602 
603     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
604         ret = super().handle_signature(sig, signode)
605         signode.insert(0, addnodes.desc_addname('@', '@'))
606         return ret
607 
608     def needs_arglist(self) -> bool:
609         return False
610 
611 
612 class PyVariable(PyObject):
613     """Description of a variable."""
614 
615     option_spec = PyObject.option_spec.copy()
616     option_spec.update({
617         'type': directives.unchanged,
618         'value': directives.unchanged,
619     })
620 
621     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
622         fullname, prefix = super().handle_signature(sig, signode)
623 
624         typ = self.options.get('type')
625         if typ:
626             signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))
627 
628         value = self.options.get('value')
629         if value:
630             signode += addnodes.desc_annotation(value, ' = ' + value)
631 
632         return fullname, prefix
633 
634     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
635         name, cls = name_cls
636         if modname:
637             return _('%s (in module %s)') % (name, modname)
638         else:
639             return _('%s (built-in variable)') % name
640 
641 
642 class PyClasslike(PyObject):
643     """
644     Description of a class-like object (classes, interfaces, exceptions).
645     """
646 
647     option_spec = PyObject.option_spec.copy()
648     option_spec.update({
649         'final': directives.flag,
650     })
651 
652     allow_nesting = True
653 
654     def get_signature_prefix(self, sig: str) -> str:
655         if 'final' in self.options:
656             return 'final %s ' % self.objtype
657         else:
658             return '%s ' % self.objtype
659 
660     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
661         if self.objtype == 'class':
662             if not modname:
663                 return _('%s (built-in class)') % name_cls[0]
664             return _('%s (class in %s)') % (name_cls[0], modname)
665         elif self.objtype == 'exception':
666             return name_cls[0]
667         else:
668             return ''
669 
670 
671 class PyClassmember(PyObject):
672     """
673     Description of a class member (methods, attributes).
674     """
675 
676     def run(self) -> List[Node]:
677         for cls in self.__class__.__mro__:
678             if cls.__name__ != 'DirectiveAdapter':
679                 warnings.warn('PyClassmember is deprecated. '
680                               'Please check the implementation of %s' % cls,
681                               RemovedInSphinx40Warning, stacklevel=2)
682                 break
683         else:
684             warnings.warn('PyClassmember is deprecated',
685                           RemovedInSphinx40Warning, stacklevel=2)
686 
687         return super().run()
688 
689     def needs_arglist(self) -> bool:
690         return self.objtype.endswith('method')
691 
692     def get_signature_prefix(self, sig: str) -> str:
693         if self.objtype == 'staticmethod':
694             return 'static '
695         elif self.objtype == 'classmethod':
696             return 'classmethod '
697         return ''
698 
699     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
700         name, cls = name_cls
701         add_modules = self.env.config.add_module_names
702         if self.objtype == 'method':
703             try:
704                 clsname, methname = name.rsplit('.', 1)
705             except ValueError:
706                 if modname:
707                     return _('%s() (in module %s)') % (name, modname)
708                 else:
709                     return '%s()' % name
710             if modname and add_modules:
711                 return _('%s() (%s.%s method)') % (methname, modname, clsname)
712             else:
713                 return _('%s() (%s method)') % (methname, clsname)
714         elif self.objtype == 'staticmethod':
715             try:
716                 clsname, methname = name.rsplit('.', 1)
717             except ValueError:
718                 if modname:
719                     return _('%s() (in module %s)') % (name, modname)
720                 else:
721                     return '%s()' % name
722             if modname and add_modules:
723                 return _('%s() (%s.%s static method)') % (methname, modname,
724                                                           clsname)
725             else:
726                 return _('%s() (%s static method)') % (methname, clsname)
727         elif self.objtype == 'classmethod':
728             try:
729                 clsname, methname = name.rsplit('.', 1)
730             except ValueError:
731                 if modname:
732                     return _('%s() (in module %s)') % (name, modname)
733                 else:
734                     return '%s()' % name
735             if modname:
736                 return _('%s() (%s.%s class method)') % (methname, modname,
737                                                          clsname)
738             else:
739                 return _('%s() (%s class method)') % (methname, clsname)
740         elif self.objtype == 'attribute':
741             try:
742                 clsname, attrname = name.rsplit('.', 1)
743             except ValueError:
744                 if modname:
745                     return _('%s (in module %s)') % (name, modname)
746                 else:
747                     return name
748             if modname and add_modules:
749                 return _('%s (%s.%s attribute)') % (attrname, modname, clsname)
750             else:
751                 return _('%s (%s attribute)') % (attrname, clsname)
752         else:
753             return ''
754 
755 
756 class PyMethod(PyObject):
757     """Description of a method."""
758 
759     option_spec = PyObject.option_spec.copy()
760     option_spec.update({
761         'abstractmethod': directives.flag,
762         'async': directives.flag,
763         'classmethod': directives.flag,
764         'final': directives.flag,
765         'property': directives.flag,
766         'staticmethod': directives.flag,
767     })
768 
769     def needs_arglist(self) -> bool:
770         if 'property' in self.options:
771             return False
772         else:
773             return True
774 
775     def get_signature_prefix(self, sig: str) -> str:
776         prefix = []
777         if 'final' in self.options:
778             prefix.append('final')
779         if 'abstractmethod' in self.options:
780             prefix.append('abstract')
781         if 'async' in self.options:
782             prefix.append('async')
783         if 'classmethod' in self.options:
784             prefix.append('classmethod')
785         if 'property' in self.options:
786             prefix.append('property')
787         if 'staticmethod' in self.options:
788             prefix.append('static')
789 
790         if prefix:
791             return ' '.join(prefix) + ' '
792         else:
793             return ''
794 
795     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
796         name, cls = name_cls
797         try:
798             clsname, methname = name.rsplit('.', 1)
799             if modname and self.env.config.add_module_names:
800                 clsname = '.'.join([modname, clsname])
801         except ValueError:
802             if modname:
803                 return _('%s() (in module %s)') % (name, modname)
804             else:
805                 return '%s()' % name
806 
807         if 'classmethod' in self.options:
808             return _('%s() (%s class method)') % (methname, clsname)
809         elif 'property' in self.options:
810             return _('%s() (%s property)') % (methname, clsname)
811         elif 'staticmethod' in self.options:
812             return _('%s() (%s static method)') % (methname, clsname)
813         else:
814             return _('%s() (%s method)') % (methname, clsname)
815 
816 
817 class PyClassMethod(PyMethod):
818     """Description of a classmethod."""
819 
820     option_spec = PyObject.option_spec.copy()
821 
822     def run(self) -> List[Node]:
823         self.name = 'py:method'
824         self.options['classmethod'] = True
825 
826         return super().run()
827 
828 
829 class PyStaticMethod(PyMethod):
830     """Description of a staticmethod."""
831 
832     option_spec = PyObject.option_spec.copy()
833 
834     def run(self) -> List[Node]:
835         self.name = 'py:method'
836         self.options['staticmethod'] = True
837 
838         return super().run()
839 
840 
841 class PyDecoratorMethod(PyMethod):
842     """Description of a decoratormethod."""
843 
844     def run(self) -> List[Node]:
845         self.name = 'py:method'
846         return super().run()
847 
848     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
849         ret = super().handle_signature(sig, signode)
850         signode.insert(0, addnodes.desc_addname('@', '@'))
851         return ret
852 
853     def needs_arglist(self) -> bool:
854         return False
855 
856 
857 class PyAttribute(PyObject):
858     """Description of an attribute."""
859 
860     option_spec = PyObject.option_spec.copy()
861     option_spec.update({
862         'type': directives.unchanged,
863         'value': directives.unchanged,
864     })
865 
866     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
867         fullname, prefix = super().handle_signature(sig, signode)
868 
869         typ = self.options.get('type')
870         if typ:
871             signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))
872 
873         value = self.options.get('value')
874         if value:
875             signode += addnodes.desc_annotation(value, ' = ' + value)
876 
877         return fullname, prefix
878 
879     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:
880         name, cls = name_cls
881         try:
882             clsname, attrname = name.rsplit('.', 1)
883             if modname and self.env.config.add_module_names:
884                 clsname = '.'.join([modname, clsname])
885         except ValueError:
886             if modname:
887                 return _('%s (in module %s)') % (name, modname)
888             else:
889                 return name
890 
891         return _('%s (%s attribute)') % (attrname, clsname)
892 
893 
894 class PyDecoratorMixin:
895     """
896     Mixin for decorator directives.
897     """
898     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:
899         for cls in self.__class__.__mro__:
900             if cls.__name__ != 'DirectiveAdapter':
901                 warnings.warn('PyDecoratorMixin is deprecated. '
902                               'Please check the implementation of %s' % cls,
903                               RemovedInSphinx50Warning, stacklevel=2)
904                 break
905         else:
906             warnings.warn('PyDecoratorMixin is deprecated',
907                           RemovedInSphinx50Warning, stacklevel=2)
908 
909         ret = super().handle_signature(sig, signode)  # type: ignore
910         signode.insert(0, addnodes.desc_addname('@', '@'))
911         return ret
912 
913     def needs_arglist(self) -> bool:
914         return False
915 
916 
917 class PyModule(SphinxDirective):
918     """
919     Directive to mark description of a new module.
920     """
921 
922     has_content = False
923     required_arguments = 1
924     optional_arguments = 0
925     final_argument_whitespace = False
926     option_spec = {
927         'platform': lambda x: x,
928         'synopsis': lambda x: x,
929         'noindex': directives.flag,
930         'deprecated': directives.flag,
931     }
932 
933     def run(self) -> List[Node]:
934         domain = cast(PythonDomain, self.env.get_domain('py'))
935 
936         modname = self.arguments[0].strip()
937         noindex = 'noindex' in self.options
938         self.env.ref_context['py:module'] = modname
939         ret = []  # type: List[Node]
940         if not noindex:
941             # note module to the domain
942             node_id = make_id(self.env, self.state.document, 'module', modname)
943             target = nodes.target('', '', ids=[node_id], ismod=True)
944             self.set_source_info(target)
945 
946             # Assign old styled node_id not to break old hyperlinks (if possible)
947             # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)
948             old_node_id = self.make_old_id(modname)
949             if node_id != old_node_id and old_node_id not in self.state.document.ids:
950                 target['ids'].append(old_node_id)
951 
952             self.state.document.note_explicit_target(target)
953 
954             domain.note_module(modname,
955                                node_id,
956                                self.options.get('synopsis', ''),
957                                self.options.get('platform', ''),
958                                'deprecated' in self.options)
959             domain.note_object(modname, 'module', node_id, location=target)
960 
961             # the platform and synopsis aren't printed; in fact, they are only
962             # used in the modindex currently
963             ret.append(target)
964             indextext = '%s; %s' % (pairindextypes['module'], modname)
965             inode = addnodes.index(entries=[('pair', indextext, node_id, '', None)])
966             ret.append(inode)
967         return ret
968 
969     def make_old_id(self, name: str) -> str:
970         """Generate old styled node_id.
971 
972         Old styled node_id is incompatible with docutils' node_id.
973         It can contain dots and hyphens.
974 
975         .. note:: Old styled node_id was mainly used until Sphinx-3.0.
976         """
977         return 'module-%s' % name
978 
979 
980 class PyCurrentModule(SphinxDirective):
981     """
982     This directive is just to tell Sphinx that we're documenting
983     stuff in module foo, but links to module foo won't lead here.
984     """
985 
986     has_content = False
987     required_arguments = 1
988     optional_arguments = 0
989     final_argument_whitespace = False
990     option_spec = {}  # type: Dict
991 
992     def run(self) -> List[Node]:
993         modname = self.arguments[0].strip()
994         if modname == 'None':
995             self.env.ref_context.pop('py:module', None)
996         else:
997             self.env.ref_context['py:module'] = modname
998         return []
999 
1000 
1001 class PyXRefRole(XRefRole):
1002     def process_link(self, env: BuildEnvironment, refnode: Element,
1003                      has_explicit_title: bool, title: str, target: str) -> Tuple[str, str]:
1004         refnode['py:module'] = env.ref_context.get('py:module')
1005         refnode['py:class'] = env.ref_context.get('py:class')
1006         if not has_explicit_title:
1007             title = title.lstrip('.')    # only has a meaning for the target
1008             target = target.lstrip('~')  # only has a meaning for the title
1009             # if the first character is a tilde, don't display the module/class
1010             # parts of the contents
1011             if title[0:1] == '~':
1012                 title = title[1:]
1013                 dot = title.rfind('.')
1014                 if dot != -1:
1015                     title = title[dot + 1:]
1016         # if the first character is a dot, search more specific namespaces first
1017         # else search builtins first
1018         if target[0:1] == '.':
1019             target = target[1:]
1020             refnode['refspecific'] = True
1021         return title, target
1022 
1023 
1024 def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:
1025     """Filter ``:meta:`` field from its docstring."""
1026     if domain != 'py':
1027         return
1028 
1029     for node in content:
1030         if isinstance(node, nodes.field_list):
1031             fields = cast(List[nodes.field], node)
1032             for field in fields:
1033                 field_name = cast(nodes.field_body, field[0]).astext().strip()
1034                 if field_name == 'meta' or field_name.startswith('meta '):
1035                     node.remove(field)
1036                     break
1037 
1038 
1039 class PythonModuleIndex(Index):
1040     """
1041     Index subclass to provide the Python module index.
1042     """
1043 
1044     name = 'modindex'
1045     localname = _('Python Module Index')
1046     shortname = _('modules')
1047 
1048     def generate(self, docnames: Iterable[str] = None
1049                  ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:
1050         content = {}  # type: Dict[str, List[IndexEntry]]
1051         # list of prefixes to ignore
1052         ignores = None  # type: List[str]
1053         ignores = self.domain.env.config['modindex_common_prefix']  # type: ignore
1054         ignores = sorted(ignores, key=len, reverse=True)
1055         # list of all modules, sorted by module name
1056         modules = sorted(self.domain.data['modules'].items(),
1057                          key=lambda x: x[0].lower())
1058         # sort out collapsable modules
1059         prev_modname = ''
1060         num_toplevels = 0
1061         for modname, (docname, node_id, synopsis, platforms, deprecated) in modules:
1062             if docnames and docname not in docnames:
1063                 continue
1064 
1065             for ignore in ignores:
1066                 if modname.startswith(ignore):
1067                     modname = modname[len(ignore):]
1068                     stripped = ignore
1069                     break
1070             else:
1071                 stripped = ''
1072 
1073             # we stripped the whole module name?
1074             if not modname:
1075                 modname, stripped = stripped, ''
1076 
1077             entries = content.setdefault(modname[0].lower(), [])
1078 
1079             package = modname.split('.')[0]
1080             if package != modname:
1081                 # it's a submodule
1082                 if prev_modname == package:
1083                     # first submodule - make parent a group head
1084                     if entries:
1085                         last = entries[-1]
1086                         entries[-1] = IndexEntry(last[0], 1, last[2], last[3],
1087                                                  last[4], last[5], last[6])
1088                 elif not prev_modname.startswith(package):
1089                     # submodule without parent in list, add dummy entry
1090                     entries.append(IndexEntry(stripped + package, 1, '', '', '', '', ''))
1091                 subtype = 2
1092             else:
1093                 num_toplevels += 1
1094                 subtype = 0
1095 
1096             qualifier = _('Deprecated') if deprecated else ''
1097             entries.append(IndexEntry(stripped + modname, subtype, docname,
1098                                       node_id, platforms, qualifier, synopsis))
1099             prev_modname = modname
1100 
1101         # apply heuristics when to collapse modindex at page load:
1102         # only collapse if number of toplevel modules is larger than
1103         # number of submodules
1104         collapse = len(modules) - num_toplevels < num_toplevels
1105 
1106         # sort by first letter
1107         sorted_content = sorted(content.items())
1108 
1109         return sorted_content, collapse
1110 
1111 
1112 class PythonDomain(Domain):
1113     """Python language domain."""
1114     name = 'py'
1115     label = 'Python'
1116     object_types = {
1117         'function':     ObjType(_('function'),      'func', 'obj'),
1118         'data':         ObjType(_('data'),          'data', 'obj'),
1119         'class':        ObjType(_('class'),         'class', 'exc', 'obj'),
1120         'exception':    ObjType(_('exception'),     'exc', 'class', 'obj'),
1121         'method':       ObjType(_('method'),        'meth', 'obj'),
1122         'classmethod':  ObjType(_('class method'),  'meth', 'obj'),
1123         'staticmethod': ObjType(_('static method'), 'meth', 'obj'),
1124         'attribute':    ObjType(_('attribute'),     'attr', 'obj'),
1125         'module':       ObjType(_('module'),        'mod', 'obj'),
1126     }  # type: Dict[str, ObjType]
1127 
1128     directives = {
1129         'function':        PyFunction,
1130         'data':            PyVariable,
1131         'class':           PyClasslike,
1132         'exception':       PyClasslike,
1133         'method':          PyMethod,
1134         'classmethod':     PyClassMethod,
1135         'staticmethod':    PyStaticMethod,
1136         'attribute':       PyAttribute,
1137         'module':          PyModule,
1138         'currentmodule':   PyCurrentModule,
1139         'decorator':       PyDecoratorFunction,
1140         'decoratormethod': PyDecoratorMethod,
1141     }
1142     roles = {
1143         'data':  PyXRefRole(),
1144         'exc':   PyXRefRole(),
1145         'func':  PyXRefRole(fix_parens=True),
1146         'class': PyXRefRole(),
1147         'const': PyXRefRole(),
1148         'attr':  PyXRefRole(),
1149         'meth':  PyXRefRole(fix_parens=True),
1150         'mod':   PyXRefRole(),
1151         'obj':   PyXRefRole(),
1152     }
1153     initial_data = {
1154         'objects': {},  # fullname -> docname, objtype
1155         'modules': {},  # modname -> docname, synopsis, platform, deprecated
1156     }  # type: Dict[str, Dict[str, Tuple[Any]]]
1157     indices = [
1158         PythonModuleIndex,
1159     ]
1160 
1161     @property
1162     def objects(self) -> Dict[str, ObjectEntry]:
1163         return self.data.setdefault('objects', {})  # fullname -> ObjectEntry
1164 
1165     def note_object(self, name: str, objtype: str, node_id: str, location: Any = None) -> None:
1166         """Note a python object for cross reference.
1167 
1168         .. versionadded:: 2.1
1169         """
1170         if name in self.objects:
1171             other = self.objects[name]
1172             logger.warning(__('duplicate object description of %s, '
1173                               'other instance in %s, use :noindex: for one of them'),
1174                            name, other.docname, location=location)
1175         self.objects[name] = ObjectEntry(self.env.docname, node_id, objtype)
1176 
1177     @property
1178     def modules(self) -> Dict[str, ModuleEntry]:
1179         return self.data.setdefault('modules', {})  # modname -> ModuleEntry
1180 
1181     def note_module(self, name: str, node_id: str, synopsis: str,
1182                     platform: str, deprecated: bool) -> None:
1183         """Note a python module for cross reference.
1184 
1185         .. versionadded:: 2.1
1186         """
1187         self.modules[name] = ModuleEntry(self.env.docname, node_id,
1188                                          synopsis, platform, deprecated)
1189 
1190     def clear_doc(self, docname: str) -> None:
1191         for fullname, obj in list(self.objects.items()):
1192             if obj.docname == docname:
1193                 del self.objects[fullname]
1194         for modname, mod in list(self.modules.items()):
1195             if mod.docname == docname:
1196                 del self.modules[modname]
1197 
1198     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:
1199         # XXX check duplicates?
1200         for fullname, obj in otherdata['objects'].items():
1201             if obj.docname in docnames:
1202                 self.objects[fullname] = obj
1203         for modname, mod in otherdata['modules'].items():
1204             if mod.docname in docnames:
1205                 self.modules[modname] = mod
1206 
1207     def find_obj(self, env: BuildEnvironment, modname: str, classname: str,
1208                  name: str, type: str, searchmode: int = 0
1209                  ) -> List[Tuple[str, ObjectEntry]]:
1210         """Find a Python object for "name", perhaps using the given module
1211         and/or classname.  Returns a list of (name, object entry) tuples.
1212         """
1213         # skip parens
1214         if name[-2:] == '()':
1215             name = name[:-2]
1216 
1217         if not name:
1218             return []
1219 
1220         matches = []  # type: List[Tuple[str, ObjectEntry]]
1221 
1222         newname = None
1223         if searchmode == 1:
1224             if type is None:
1225                 objtypes = list(self.object_types)
1226             else:
1227                 objtypes = self.objtypes_for_role(type)
1228             if objtypes is not None:
1229                 if modname and classname:
1230                     fullname = modname + '.' + classname + '.' + name
1231                     if fullname in self.objects and self.objects[fullname].objtype in objtypes:
1232                         newname = fullname
1233                 if not newname:
1234                     if modname and modname + '.' + name in self.objects and \
1235                        self.objects[modname + '.' + name].objtype in objtypes:
1236                         newname = modname + '.' + name
1237                     elif name in self.objects and self.objects[name].objtype in objtypes:
1238                         newname = name
1239                     else:
1240                         # "fuzzy" searching mode
1241                         searchname = '.' + name
1242                         matches = [(oname, self.objects[oname]) for oname in self.objects
1243                                    if oname.endswith(searchname) and
1244                                    self.objects[oname].objtype in objtypes]
1245         else:
1246             # NOTE: searching for exact match, object type is not considered
1247             if name in self.objects:
1248                 newname = name
1249             elif type == 'mod':
1250                 # only exact matches allowed for modules
1251                 return []
1252             elif classname and classname + '.' + name in self.objects:
1253                 newname = classname + '.' + name
1254             elif modname and modname + '.' + name in self.objects:
1255                 newname = modname + '.' + name
1256             elif modname and classname and \
1257                     modname + '.' + classname + '.' + name in self.objects:
1258                 newname = modname + '.' + classname + '.' + name
1259         if newname is not None:
1260             matches.append((newname, self.objects[newname]))
1261         return matches
1262 
1263     def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,
1264                      type: str, target: str, node: pending_xref, contnode: Element
1265                      ) -> Element:
1266         modname = node.get('py:module')
1267         clsname = node.get('py:class')
1268         searchmode = 1 if node.hasattr('refspecific') else 0
1269         matches = self.find_obj(env, modname, clsname, target,
1270                                 type, searchmode)
1271 
1272         if not matches and type == 'attr':
1273             # fallback to meth (for property)
1274             matches = self.find_obj(env, modname, clsname, target, 'meth', searchmode)
1275 
1276         if not matches:
1277             return None
1278         elif len(matches) > 1:
1279             logger.warning(__('more than one target found for cross-reference %r: %s'),
1280                            target, ', '.join(match[0] for match in matches),
1281                            type='ref', subtype='python', location=node)
1282         name, obj = matches[0]
1283 
1284         if obj[2] == 'module':
1285             return self._make_module_refnode(builder, fromdocname, name, contnode)
1286         else:
1287             return make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name)
1288 
1289     def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,
1290                          target: str, node: pending_xref, contnode: Element
1291                          ) -> List[Tuple[str, Element]]:
1292         modname = node.get('py:module')
1293         clsname = node.get('py:class')
1294         results = []  # type: List[Tuple[str, Element]]
1295 
1296         # always search in "refspecific" mode with the :any: role
1297         matches = self.find_obj(env, modname, clsname, target, None, 1)
1298         for name, obj in matches:
1299             if obj[2] == 'module':
1300                 results.append(('py:mod',
1301                                 self._make_module_refnode(builder, fromdocname,
1302                                                           name, contnode)))
1303             else:
1304                 results.append(('py:' + self.role_for_objtype(obj[2]),
1305                                 make_refnode(builder, fromdocname, obj[0], obj[1],
1306                                              contnode, name)))
1307         return results
1308 
1309     def _make_module_refnode(self, builder: Builder, fromdocname: str, name: str,
1310                              contnode: Node) -> Element:
1311         # get additional info for modules
1312         module = self.modules[name]
1313         title = name
1314         if module.synopsis:
1315             title += ': ' + module.synopsis
1316         if module.deprecated:
1317             title += _(' (deprecated)')
1318         if module.platform:
1319             title += ' (' + module.platform + ')'
1320         return make_refnode(builder, fromdocname, module.docname, module.node_id,
1321                             contnode, title)
1322 
1323     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:
1324         for modname, mod in self.modules.items():
1325             yield (modname, modname, 'module', mod.docname, mod.node_id, 0)
1326         for refname, obj in self.objects.items():
1327             if obj.objtype != 'module':  # modules are already handled
1328                 yield (refname, refname, obj.objtype, obj.docname, obj.node_id, 1)
1329 
1330     def get_full_qualified_name(self, node: Element) -> str:
1331         modname = node.get('py:module')
1332         clsname = node.get('py:class')
1333         target = node.get('reftarget')
1334         if target is None:
1335             return None
1336         else:
1337             return '.'.join(filter(None, [modname, clsname, target]))
1338 
1339 
1340 def builtin_resolver(app: Sphinx, env: BuildEnvironment,
1341                      node: pending_xref, contnode: Element) -> Element:
1342     """Do not emit nitpicky warnings for built-in types."""
1343     def istyping(s: str) -> bool:
1344         if s.startswith('typing.'):
1345             s = s.split('.', 1)[1]
1346 
1347         return s in typing.__all__  # type: ignore
1348 
1349     if node.get('refdomain') != 'py':
1350         return None
1351     elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':
1352         return contnode
1353     elif node.get('reftype') in ('class', 'exc'):
1354         reftarget = node.get('reftarget')
1355         if inspect.isclass(getattr(builtins, reftarget, None)):
1356             # built-in class
1357             return contnode
1358         elif istyping(reftarget):
1359             # typing class
1360             return contnode
1361 
1362     return None
1363 
1364 
1365 def setup(app: Sphinx) -> Dict[str, Any]:
1366     app.setup_extension('sphinx.directives')
1367 
1368     app.add_domain(PythonDomain)
1369     app.connect('object-description-transform', filter_meta_fields)
1370     app.connect('missing-reference', builtin_resolver, priority=900)
1371 
1372     return {
1373         'version': 'builtin',
1374         'env_version': 2,
1375         'parallel_read_safe': True,
1376         'parallel_write_safe': True,
1377     }

</code><intended_behavior>Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately.</intended_behavior>, <file>sphinx/directives/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.directives
3     ~~~~~~~~~~~~~~~~~
4 
5     Handlers for additional ReST directives.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 from typing import Any, Dict, List, Tuple
13 from typing import cast
14 
15 from docutils import nodes
16 from docutils.nodes import Node
17 from docutils.parsers.rst import directives, roles
18 
19 from sphinx import addnodes
20 from sphinx.addnodes import desc_signature
21 from sphinx.deprecation import (
22     RemovedInSphinx40Warning, RemovedInSphinx50Warning, deprecated_alias
23 )
24 from sphinx.util import docutils
25 from sphinx.util.docfields import DocFieldTransformer, Field, TypedField
26 from sphinx.util.docutils import SphinxDirective
27 from sphinx.util.typing import DirectiveOption
28 
29 if False:
30     # For type annotation
31     from sphinx.application import Sphinx
32 
33 
34 # RE to strip backslash escapes
35 nl_escape_re = re.compile(r'\\\n')
36 strip_backslash_re = re.compile(r'\\(.)')
37 
38 
39 def optional_int(argument: str) -> int:
40     """
41     Check for an integer argument or None value; raise ``ValueError`` if not.
42     """
43     if argument is None:
44         return None
45     else:
46         value = int(argument)
47         if value < 0:
48             raise ValueError('negative value; must be positive or zero')
49         return value
50 
51 
52 class ObjectDescription(SphinxDirective):
53     """
54     Directive to describe a class, function or similar object.  Not used
55     directly, but subclassed (in domain-specific directives) to add custom
56     behavior.
57     """
58 
59     has_content = True
60     required_arguments = 1
61     optional_arguments = 0
62     final_argument_whitespace = True
63     option_spec = {
64         'noindex': directives.flag,
65     }  # type: Dict[str, DirectiveOption]
66 
67     # types of doc fields that this directive handles, see sphinx.util.docfields
68     doc_field_types = []    # type: List[Field]
69     domain = None           # type: str
70     objtype = None          # type: str
71     indexnode = None        # type: addnodes.index
72 
73     # Warning: this might be removed in future version. Don't touch this from extensions.
74     _doc_field_type_map = {}  # type: Dict[str, Tuple[Field, bool]]
75 
76     def get_field_type_map(self) -> Dict[str, Tuple[Field, bool]]:
77         if self._doc_field_type_map == {}:
78             self._doc_field_type_map = {}
79             for field in self.doc_field_types:
80                 for name in field.names:
81                     self._doc_field_type_map[name] = (field, False)
82 
83                 if field.is_typed:
84                     typed_field = cast(TypedField, field)
85                     for name in typed_field.typenames:
86                         self._doc_field_type_map[name] = (field, True)
87 
88         return self._doc_field_type_map
89 
90     def get_signatures(self) -> List[str]:
91         """
92         Retrieve the signatures to document from the directive arguments.  By
93         default, signatures are given as arguments, one per line.
94         """
95         lines = nl_escape_re.sub('', self.arguments[0]).split('\n')
96         if self.config.strip_signature_backslash:
97             # remove backslashes to support (dummy) escapes; helps Vim highlighting
98             return [strip_backslash_re.sub(r'\1', line.strip()) for line in lines]
99         else:
100             return [line.strip() for line in lines]
101 
102     def handle_signature(self, sig: str, signode: desc_signature) -> Any:
103         """
104         Parse the signature *sig* into individual nodes and append them to
105         *signode*. If ValueError is raised, parsing is aborted and the whole
106         *sig* is put into a single desc_name node.
107 
108         The return value should be a value that identifies the object.  It is
109         passed to :meth:`add_target_and_index()` unchanged, and otherwise only
110         used to skip duplicates.
111         """
112         raise ValueError
113 
114     def add_target_and_index(self, name: Any, sig: str, signode: desc_signature) -> None:
115         """
116         Add cross-reference IDs and entries to self.indexnode, if applicable.
117 
118         *name* is whatever :meth:`handle_signature()` returned.
119         """
120         return  # do nothing by default
121 
122     def before_content(self) -> None:
123         """
124         Called before parsing content. Used to set information about the current
125         directive context on the build environment.
126         """
127         pass
128 
129     def transform_content(self, contentnode: addnodes.desc_content) -> None:
130         """
131         Called after creating the content through nested parsing,
132         but before the ``object-description-transform`` event is emitted,
133         and before the info-fields are transformed.
134         Can be used to manipulate the content.
135         """
136         pass
137 
138     def after_content(self) -> None:
139         """
140         Called after parsing content. Used to reset information about the
141         current directive context on the build environment.
142         """
143         pass
144 
145     def run(self) -> List[Node]:
146         """
147         Main directive entry function, called by docutils upon encountering the
148         directive.
149 
150         This directive is meant to be quite easily subclassable, so it delegates
151         to several additional methods.  What it does:
152 
153         * find out if called as a domain-specific directive, set self.domain
154         * create a `desc` node to fit all description inside
155         * parse standard options, currently `noindex`
156         * create an index node if needed as self.indexnode
157         * parse all given signatures (as returned by self.get_signatures())
158           using self.handle_signature(), which should either return a name
159           or raise ValueError
160         * add index entries using self.add_target_and_index()
161         * parse the content and handle doc fields in it
162         """
163         if ':' in self.name:
164             self.domain, self.objtype = self.name.split(':', 1)
165         else:
166             self.domain, self.objtype = '', self.name
167         self.indexnode = addnodes.index(entries=[])
168 
169         node = addnodes.desc()
170         node.document = self.state.document
171         node['domain'] = self.domain
172         # 'desctype' is a backwards compatible attribute
173         node['objtype'] = node['desctype'] = self.objtype
174         node['noindex'] = noindex = ('noindex' in self.options)
175         if self.domain:
176             node['classes'].append(self.domain)
177 
178         self.names = []  # type: List[Any]
179         signatures = self.get_signatures()
180         for i, sig in enumerate(signatures):
181             # add a signature node for each signature in the current unit
182             # and add a reference target for it
183             signode = addnodes.desc_signature(sig, '')
184             self.set_source_info(signode)
185             node.append(signode)
186             try:
187                 # name can also be a tuple, e.g. (classname, objname);
188                 # this is strictly domain-specific (i.e. no assumptions may
189                 # be made in this base class)
190                 name = self.handle_signature(sig, signode)
191             except ValueError:
192                 # signature parsing failed
193                 signode.clear()
194                 signode += addnodes.desc_name(sig, sig)
195                 continue  # we don't want an index entry here
196             if name not in self.names:
197                 self.names.append(name)
198                 if not noindex:
199                     # only add target and index entry if this is the first
200                     # description of the object with this name in this desc block
201                     self.add_target_and_index(name, sig, signode)
202 
203         contentnode = addnodes.desc_content()
204         node.append(contentnode)
205         if self.names:
206             # needed for association of version{added,changed} directives
207             self.env.temp_data['object'] = self.names[0]
208         self.before_content()
209         self.state.nested_parse(self.content, self.content_offset, contentnode)
210         self.transform_content(contentnode)
211         self.env.app.emit('object-description-transform',
212                           self.domain, self.objtype, contentnode)
213         DocFieldTransformer(self).transform_all(contentnode)
214         self.env.temp_data['object'] = None
215         self.after_content()
216         return [self.indexnode, node]
217 
218 
219 class DefaultRole(SphinxDirective):
220     """
221     Set the default interpreted text role.  Overridden from docutils.
222     """
223 
224     optional_arguments = 1
225     final_argument_whitespace = False
226 
227     def run(self) -> List[Node]:
228         if not self.arguments:
229             docutils.unregister_role('')
230             return []
231         role_name = self.arguments[0]
232         role, messages = roles.role(role_name, self.state_machine.language,
233                                     self.lineno, self.state.reporter)
234         if role:
235             docutils.register_role('', role)
236             self.env.temp_data['default_role'] = role_name
237         else:
238             literal_block = nodes.literal_block(self.block_text, self.block_text)
239             reporter = self.state.reporter
240             error = reporter.error('Unknown interpreted text role "%s".' % role_name,
241                                    literal_block, line=self.lineno)
242             messages += [error]
243 
244         return cast(List[nodes.Node], messages)
245 
246 
247 class DefaultDomain(SphinxDirective):
248     """
249     Directive to (re-)set the default domain for this source file.
250     """
251 
252     has_content = False
253     required_arguments = 1
254     optional_arguments = 0
255     final_argument_whitespace = False
256     option_spec = {}  # type: Dict
257 
258     def run(self) -> List[Node]:
259         domain_name = self.arguments[0].lower()
260         # if domain_name not in env.domains:
261         #     # try searching by label
262         #     for domain in env.domains.values():
263         #         if domain.label.lower() == domain_name:
264         #             domain_name = domain.name
265         #             break
266         self.env.temp_data['default_domain'] = self.env.domains.get(domain_name)
267         return []
268 
269 from sphinx.directives.code import (  # noqa
270     Highlight, CodeBlock, LiteralInclude
271 )
272 from sphinx.directives.other import (  # noqa
273     TocTree, Author, VersionChange, SeeAlso,
274     TabularColumns, Centered, Acks, HList, Only, Include, Class
275 )
276 from sphinx.directives.patches import (  # noqa
277     Figure, Meta
278 )
279 from sphinx.domains.index import IndexDirective  # noqa
280 
281 deprecated_alias('sphinx.directives',
282                  {
283                      'Highlight': Highlight,
284                      'CodeBlock': CodeBlock,
285                      'LiteralInclude': LiteralInclude,
286                      'TocTree': TocTree,
287                      'Author': Author,
288                      'Index': IndexDirective,
289                      'VersionChange': VersionChange,
290                      'SeeAlso': SeeAlso,
291                      'TabularColumns': TabularColumns,
292                      'Centered': Centered,
293                      'Acks': Acks,
294                      'HList': HList,
295                      'Only': Only,
296                      'Include': Include,
297                      'Class': Class,
298                      'Figure': Figure,
299                      'Meta': Meta,
300                  },
301                  RemovedInSphinx40Warning)
302 
303 deprecated_alias('sphinx.directives',
304                  {
305                      'DescDirective': ObjectDescription,
306                  },
307                  RemovedInSphinx50Warning)
308 
309 
310 def setup(app: "Sphinx") -> Dict[str, Any]:
311     app.add_config_value("strip_signature_backslash", False, 'env')
312     directives.register_directive('default-role', DefaultRole)
313     directives.register_directive('default-domain', DefaultDomain)
314     directives.register_directive('describe', ObjectDescription)
315     # new, more consistent, name
316     directives.register_directive('object', ObjectDescription)
317 
318     app.add_event('object-description-transform')
319 
320     return {
321         'version': 'builtin',
322         'parallel_read_safe': True,
323         'parallel_write_safe': True,
324     }

</code><intended_behavior>Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately.</intended_behavior>]
2025-10-17 18:48:11.001 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 18:48:11.002 | INFO     | Search-only: skipping patch selection
2025-10-17 18:48:11.082 | INFO     | Task sphinx-doc__sphinx-7748 completed successfully.
2025-10-17 18:48:11.083 | INFO     | No patch generated. You can try running ACR again.
