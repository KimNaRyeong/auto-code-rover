[
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/domains/python.py",
        "start": 1,
        "end": 1377,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.domains.python\n3     ~~~~~~~~~~~~~~~~~~~~~\n4 \n5     The Python domain.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import builtins\n12 import inspect\n13 import re\n14 import typing\n15 import warnings\n16 from inspect import Parameter\n17 from typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Tuple\n18 from typing import cast\n19 \n20 from docutils import nodes\n21 from docutils.nodes import Element, Node\n22 from docutils.parsers.rst import directives\n23 \n24 from sphinx import addnodes\n25 from sphinx.addnodes import pending_xref, desc_signature\n26 from sphinx.application import Sphinx\n27 from sphinx.builders import Builder\n28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n29 from sphinx.directives import ObjectDescription\n30 from sphinx.domains import Domain, ObjType, Index, IndexEntry\n31 from sphinx.environment import BuildEnvironment\n32 from sphinx.locale import _, __\n33 from sphinx.pycode.ast import ast, parse as ast_parse\n34 from sphinx.roles import XRefRole\n35 from sphinx.util import logging\n36 from sphinx.util.docfields import Field, GroupedField, TypedField\n37 from sphinx.util.docutils import SphinxDirective\n38 from sphinx.util.inspect import signature_from_str\n39 from sphinx.util.nodes import make_id, make_refnode\n40 from sphinx.util.typing import TextlikeNode\n41 \n42 if False:\n43     # For type annotation\n44     from typing import Type  # for python3.5.1\n45 \n46 \n47 logger = logging.getLogger(__name__)\n48 \n49 \n50 # REs for Python signatures\n51 py_sig_re = re.compile(\n52     r'''^ ([\\w.]*\\.)?            # class name(s)\n53           (\\w+)  \\s*             # thing name\n54           (?: \\(\\s*(.*)\\s*\\)     # optional: arguments\n55            (?:\\s* -> \\s* (.*))?  #           return annotation\n56           )? $                   # and nothing more\n57           ''', re.VERBOSE)\n58 \n59 \n60 pairindextypes = {\n61     'module':    _('module'),\n62     'keyword':   _('keyword'),\n63     'operator':  _('operator'),\n64     'object':    _('object'),\n65     'exception': _('exception'),\n66     'statement': _('statement'),\n67     'builtin':   _('built-in function'),\n68 }\n69 \n70 ObjectEntry = NamedTuple('ObjectEntry', [('docname', str),\n71                                          ('node_id', str),\n72                                          ('objtype', str)])\n73 ModuleEntry = NamedTuple('ModuleEntry', [('docname', str),\n74                                          ('node_id', str),\n75                                          ('synopsis', str),\n76                                          ('platform', str),\n77                                          ('deprecated', bool)])\n78 \n79 \n80 def type_to_xref(text: str) -> addnodes.pending_xref:\n81     \"\"\"Convert a type string to a cross reference node.\"\"\"\n82     if text == 'None':\n83         reftype = 'obj'\n84     else:\n85         reftype = 'class'\n86 \n87     return pending_xref('', nodes.Text(text),\n88                         refdomain='py', reftype=reftype, reftarget=text)\n89 \n90 \n91 def _parse_annotation(annotation: str) -> List[Node]:\n92     \"\"\"Parse type annotation.\"\"\"\n93     def unparse(node: ast.AST) -> List[Node]:\n94         if isinstance(node, ast.Attribute):\n95             return [nodes.Text(\"%s.%s\" % (unparse(node.value)[0], node.attr))]\n96         elif isinstance(node, ast.Expr):\n97             return unparse(node.value)\n98         elif isinstance(node, ast.Index):\n99             return unparse(node.value)\n100         elif isinstance(node, ast.List):\n101             result = [addnodes.desc_sig_punctuation('', '[')]  # type: List[Node]\n102             for elem in node.elts:\n103                 result.extend(unparse(elem))\n104                 result.append(addnodes.desc_sig_punctuation('', ', '))\n105             result.pop()\n106             result.append(addnodes.desc_sig_punctuation('', ']'))\n107             return result\n108         elif isinstance(node, ast.Module):\n109             return sum((unparse(e) for e in node.body), [])\n110         elif isinstance(node, ast.Name):\n111             return [nodes.Text(node.id)]\n112         elif isinstance(node, ast.Subscript):\n113             result = unparse(node.value)\n114             result.append(addnodes.desc_sig_punctuation('', '['))\n115             result.extend(unparse(node.slice))\n116             result.append(addnodes.desc_sig_punctuation('', ']'))\n117             return result\n118         elif isinstance(node, ast.Tuple):\n119             if node.elts:\n120                 result = []\n121                 for elem in node.elts:\n122                     result.extend(unparse(elem))\n123                     result.append(addnodes.desc_sig_punctuation('', ', '))\n124                 result.pop()\n125             else:\n126                 result = [addnodes.desc_sig_punctuation('', '('),\n127                           addnodes.desc_sig_punctuation('', ')')]\n128 \n129             return result\n130         else:\n131             raise SyntaxError  # unsupported syntax\n132 \n133     try:\n134         tree = ast_parse(annotation)\n135         result = unparse(tree)\n136         for i, node in enumerate(result):\n137             if isinstance(node, nodes.Text):\n138                 result[i] = type_to_xref(str(node))\n139         return result\n140     except SyntaxError:\n141         return [type_to_xref(annotation)]\n142 \n143 \n144 def _parse_arglist(arglist: str) -> addnodes.desc_parameterlist:\n145     \"\"\"Parse a list of arguments using AST parser\"\"\"\n146     params = addnodes.desc_parameterlist(arglist)\n147     sig = signature_from_str('(%s)' % arglist)\n148     last_kind = None\n149     for param in sig.parameters.values():\n150         if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n151             # PEP-570: Separator for Positional Only Parameter: /\n152             params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n153         if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n154                                                               param.POSITIONAL_ONLY,\n155                                                               None):\n156             # PEP-3102: Separator for Keyword Only Parameter: *\n157             params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '*'))\n158 \n159         node = addnodes.desc_parameter()\n160         if param.kind == param.VAR_POSITIONAL:\n161             node += addnodes.desc_sig_operator('', '*')\n162             node += addnodes.desc_sig_name('', param.name)\n163         elif param.kind == param.VAR_KEYWORD:\n164             node += addnodes.desc_sig_operator('', '**')\n165             node += addnodes.desc_sig_name('', param.name)\n166         else:\n167             node += addnodes.desc_sig_name('', param.name)\n168 \n169         if param.annotation is not param.empty:\n170             children = _parse_annotation(param.annotation)\n171             node += addnodes.desc_sig_punctuation('', ':')\n172             node += nodes.Text(' ')\n173             node += addnodes.desc_sig_name('', '', *children)  # type: ignore\n174         if param.default is not param.empty:\n175             if param.annotation is not param.empty:\n176                 node += nodes.Text(' ')\n177                 node += addnodes.desc_sig_operator('', '=')\n178                 node += nodes.Text(' ')\n179             else:\n180                 node += addnodes.desc_sig_operator('', '=')\n181             node += nodes.inline('', param.default, classes=['default_value'],\n182                                  support_smartquotes=False)\n183 \n184         params += node\n185         last_kind = param.kind\n186 \n187     if last_kind == Parameter.POSITIONAL_ONLY:\n188         # PEP-570: Separator for Positional Only Parameter: /\n189         params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n190 \n191     return params\n192 \n193 \n194 def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\n195     \"\"\"\"Parse\" a list of arguments separated by commas.\n196 \n197     Arguments can have \"optional\" annotations given by enclosing them in\n198     brackets.  Currently, this will split at any comma, even if it's inside a\n199     string literal (e.g. default argument value).\n200     \"\"\"\n201     paramlist = addnodes.desc_parameterlist()\n202     stack = [paramlist]  # type: List[Element]\n203     try:\n204         for argument in arglist.split(','):\n205             argument = argument.strip()\n206             ends_open = ends_close = 0\n207             while argument.startswith('['):\n208                 stack.append(addnodes.desc_optional())\n209                 stack[-2] += stack[-1]\n210                 argument = argument[1:].strip()\n211             while argument.startswith(']'):\n212                 stack.pop()\n213                 argument = argument[1:].strip()\n214             while argument.endswith(']') and not argument.endswith('[]'):\n215                 ends_close += 1\n216                 argument = argument[:-1].strip()\n217             while argument.endswith('['):\n218                 ends_open += 1\n219                 argument = argument[:-1].strip()\n220             if argument:\n221                 stack[-1] += addnodes.desc_parameter(argument, argument)\n222             while ends_open:\n223                 stack.append(addnodes.desc_optional())\n224                 stack[-2] += stack[-1]\n225                 ends_open -= 1\n226             while ends_close:\n227                 stack.pop()\n228                 ends_close -= 1\n229         if len(stack) != 1:\n230             raise IndexError\n231     except IndexError:\n232         # if there are too few or too many elements on the stack, just give up\n233         # and treat the whole argument list as one argument, discarding the\n234         # already partially populated paramlist node\n235         paramlist = addnodes.desc_parameterlist()\n236         paramlist += addnodes.desc_parameter(arglist, arglist)\n237         signode += paramlist\n238     else:\n239         signode += paramlist\n240 \n241 \n242 # This override allows our inline type specifiers to behave like :class: link\n243 # when it comes to handling \".\" and \"~\" prefixes.\n244 class PyXrefMixin:\n245     def make_xref(self, rolename: str, domain: str, target: str,\n246                   innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n247                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n248         result = super().make_xref(rolename, domain, target,  # type: ignore\n249                                    innernode, contnode, env)\n250         result['refspecific'] = True\n251         if target.startswith(('.', '~')):\n252             prefix, result['reftarget'] = target[0], target[1:]\n253             if prefix == '.':\n254                 text = target[1:]\n255             elif prefix == '~':\n256                 text = target.split('.')[-1]\n257             for node in result.traverse(nodes.Text):\n258                 node.parent[node.parent.index(node)] = nodes.Text(text)\n259                 break\n260         return result\n261 \n262     def make_xrefs(self, rolename: str, domain: str, target: str,\n263                    innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n264                    contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n265         delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+)'\n266         delims_re = re.compile(delims)\n267         sub_targets = re.split(delims, target)\n268 \n269         split_contnode = bool(contnode and contnode.astext() == target)\n270 \n271         results = []\n272         for sub_target in filter(None, sub_targets):\n273             if split_contnode:\n274                 contnode = nodes.Text(sub_target)\n275 \n276             if delims_re.match(sub_target):\n277                 results.append(contnode or innernode(sub_target, sub_target))\n278             else:\n279                 results.append(self.make_xref(rolename, domain, sub_target,\n280                                               innernode, contnode, env))\n281 \n282         return results\n283 \n284 \n285 class PyField(PyXrefMixin, Field):\n286     def make_xref(self, rolename: str, domain: str, target: str,\n287                   innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n288                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n289         if rolename == 'class' and target == 'None':\n290             # None is not a type, so use obj role instead.\n291             rolename = 'obj'\n292 \n293         return super().make_xref(rolename, domain, target, innernode, contnode, env)\n294 \n295 \n296 class PyGroupedField(PyXrefMixin, GroupedField):\n297     pass\n298 \n299 \n300 class PyTypedField(PyXrefMixin, TypedField):\n301     def make_xref(self, rolename: str, domain: str, target: str,\n302                   innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n303                   contnode: Node = None, env: BuildEnvironment = None) -> Node:\n304         if rolename == 'class' and target == 'None':\n305             # None is not a type, so use obj role instead.\n306             rolename = 'obj'\n307 \n308         return super().make_xref(rolename, domain, target, innernode, contnode, env)\n309 \n310 \n311 class PyObject(ObjectDescription):\n312     \"\"\"\n313     Description of a general Python object.\n314 \n315     :cvar allow_nesting: Class is an object that allows for nested namespaces\n316     :vartype allow_nesting: bool\n317     \"\"\"\n318     option_spec = {\n319         'noindex': directives.flag,\n320         'module': directives.unchanged,\n321         'annotation': directives.unchanged,\n322     }\n323 \n324     doc_field_types = [\n325         PyTypedField('parameter', label=_('Parameters'),\n326                      names=('param', 'parameter', 'arg', 'argument',\n327                             'keyword', 'kwarg', 'kwparam'),\n328                      typerolename='class', typenames=('paramtype', 'type'),\n329                      can_collapse=True),\n330         PyTypedField('variable', label=_('Variables'), rolename='obj',\n331                      names=('var', 'ivar', 'cvar'),\n332                      typerolename='class', typenames=('vartype',),\n333                      can_collapse=True),\n334         PyGroupedField('exceptions', label=_('Raises'), rolename='exc',\n335                        names=('raises', 'raise', 'exception', 'except'),\n336                        can_collapse=True),\n337         Field('returnvalue', label=_('Returns'), has_arg=False,\n338               names=('returns', 'return')),\n339         PyField('returntype', label=_('Return type'), has_arg=False,\n340                 names=('rtype',), bodyrolename='class'),\n341     ]\n342 \n343     allow_nesting = False\n344 \n345     def get_signature_prefix(self, sig: str) -> str:\n346         \"\"\"May return a prefix to put before the object name in the\n347         signature.\n348         \"\"\"\n349         return ''\n350 \n351     def needs_arglist(self) -> bool:\n352         \"\"\"May return true if an empty argument list is to be generated even if\n353         the document contains none.\n354         \"\"\"\n355         return False\n356 \n357     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n358         \"\"\"Transform a Python signature into RST nodes.\n359 \n360         Return (fully qualified name of the thing, classname if any).\n361 \n362         If inside a class, the current class name is handled intelligently:\n363         * it is stripped from the displayed name if present\n364         * it is added to the full name (return value) if not present\n365         \"\"\"\n366         m = py_sig_re.match(sig)\n367         if m is None:\n368             raise ValueError\n369         prefix, name, arglist, retann = m.groups()\n370 \n371         # determine module and class name (if applicable), as well as full name\n372         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n373         classname = self.env.ref_context.get('py:class')\n374         if classname:\n375             add_module = False\n376             if prefix and (prefix == classname or\n377                            prefix.startswith(classname + \".\")):\n378                 fullname = prefix + name\n379                 # class name is given again in the signature\n380                 prefix = prefix[len(classname):].lstrip('.')\n381             elif prefix:\n382                 # class name is given in the signature, but different\n383                 # (shouldn't happen)\n384                 fullname = classname + '.' + prefix + name\n385             else:\n386                 # class name is not given in the signature\n387                 fullname = classname + '.' + name\n388         else:\n389             add_module = True\n390             if prefix:\n391                 classname = prefix.rstrip('.')\n392                 fullname = prefix + name\n393             else:\n394                 classname = ''\n395                 fullname = name\n396 \n397         signode['module'] = modname\n398         signode['class'] = classname\n399         signode['fullname'] = fullname\n400 \n401         sig_prefix = self.get_signature_prefix(sig)\n402         if sig_prefix:\n403             signode += addnodes.desc_annotation(sig_prefix, sig_prefix)\n404 \n405         if prefix:\n406             signode += addnodes.desc_addname(prefix, prefix)\n407         elif add_module and self.env.config.add_module_names:\n408             if modname and modname != 'exceptions':\n409                 # exceptions are a special case, since they are documented in the\n410                 # 'exceptions' module.\n411                 nodetext = modname + '.'\n412                 signode += addnodes.desc_addname(nodetext, nodetext)\n413 \n414         signode += addnodes.desc_name(name, name)\n415         if arglist:\n416             try:\n417                 signode += _parse_arglist(arglist)\n418             except SyntaxError:\n419                 # fallback to parse arglist original parser.\n420                 # it supports to represent optional arguments (ex. \"func(foo [, bar])\")\n421                 _pseudo_parse_arglist(signode, arglist)\n422             except NotImplementedError as exc:\n423                 logger.warning(\"could not parse arglist (%r): %s\", arglist, exc,\n424                                location=signode)\n425                 _pseudo_parse_arglist(signode, arglist)\n426         else:\n427             if self.needs_arglist():\n428                 # for callables, add an empty parameter list\n429                 signode += addnodes.desc_parameterlist()\n430 \n431         if retann:\n432             children = _parse_annotation(retann)\n433             signode += addnodes.desc_returns(retann, '', *children)\n434 \n435         anno = self.options.get('annotation')\n436         if anno:\n437             signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)\n438 \n439         return fullname, prefix\n440 \n441     def get_index_text(self, modname: str, name: Tuple[str, str]) -> str:\n442         \"\"\"Return the text for the index entry of the object.\"\"\"\n443         raise NotImplementedError('must be implemented in subclasses')\n444 \n445     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n446                              signode: desc_signature) -> None:\n447         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n448         fullname = (modname + '.' if modname else '') + name_cls[0]\n449         node_id = make_id(self.env, self.state.document, '', fullname)\n450         signode['ids'].append(node_id)\n451 \n452         # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)\n453         # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n454         if node_id != fullname and fullname not in self.state.document.ids:\n455             signode['ids'].append(fullname)\n456 \n457         self.state.document.note_explicit_target(signode)\n458 \n459         domain = cast(PythonDomain, self.env.get_domain('py'))\n460         domain.note_object(fullname, self.objtype, node_id, location=signode)\n461 \n462         indextext = self.get_index_text(modname, name_cls)\n463         if indextext:\n464             self.indexnode['entries'].append(('single', indextext, node_id, '', None))\n465 \n466     def before_content(self) -> None:\n467         \"\"\"Handle object nesting before content\n468 \n469         :py:class:`PyObject` represents Python language constructs. For\n470         constructs that are nestable, such as a Python classes, this method will\n471         build up a stack of the nesting heirarchy so that it can be later\n472         de-nested correctly, in :py:meth:`after_content`.\n473 \n474         For constructs that aren't nestable, the stack is bypassed, and instead\n475         only the most recent object is tracked. This object prefix name will be\n476         removed with :py:meth:`after_content`.\n477         \"\"\"\n478         prefix = None\n479         if self.names:\n480             # fullname and name_prefix come from the `handle_signature` method.\n481             # fullname represents the full object name that is constructed using\n482             # object nesting and explicit prefixes. `name_prefix` is the\n483             # explicit prefix given in a signature\n484             (fullname, name_prefix) = self.names[-1]\n485             if self.allow_nesting:\n486                 prefix = fullname\n487             elif name_prefix:\n488                 prefix = name_prefix.strip('.')\n489         if prefix:\n490             self.env.ref_context['py:class'] = prefix\n491             if self.allow_nesting:\n492                 classes = self.env.ref_context.setdefault('py:classes', [])\n493                 classes.append(prefix)\n494         if 'module' in self.options:\n495             modules = self.env.ref_context.setdefault('py:modules', [])\n496             modules.append(self.env.ref_context.get('py:module'))\n497             self.env.ref_context['py:module'] = self.options['module']\n498 \n499     def after_content(self) -> None:\n500         \"\"\"Handle object de-nesting after content\n501 \n502         If this class is a nestable object, removing the last nested class prefix\n503         ends further nesting in the object.\n504 \n505         If this class is not a nestable object, the list of classes should not\n506         be altered as we didn't affect the nesting levels in\n507         :py:meth:`before_content`.\n508         \"\"\"\n509         classes = self.env.ref_context.setdefault('py:classes', [])\n510         if self.allow_nesting:\n511             try:\n512                 classes.pop()\n513             except IndexError:\n514                 pass\n515         self.env.ref_context['py:class'] = (classes[-1] if len(classes) > 0\n516                                             else None)\n517         if 'module' in self.options:\n518             modules = self.env.ref_context.setdefault('py:modules', [])\n519             if modules:\n520                 self.env.ref_context['py:module'] = modules.pop()\n521             else:\n522                 self.env.ref_context.pop('py:module')\n523 \n524 \n525 class PyModulelevel(PyObject):\n526     \"\"\"\n527     Description of an object on module level (functions, data).\n528     \"\"\"\n529 \n530     def run(self) -> List[Node]:\n531         for cls in self.__class__.__mro__:\n532             if cls.__name__ != 'DirectiveAdapter':\n533                 warnings.warn('PyModulelevel is deprecated. '\n534                               'Please check the implementation of %s' % cls,\n535                               RemovedInSphinx40Warning, stacklevel=2)\n536                 break\n537         else:\n538             warnings.warn('PyModulelevel is deprecated',\n539                           RemovedInSphinx40Warning, stacklevel=2)\n540 \n541         return super().run()\n542 \n543     def needs_arglist(self) -> bool:\n544         return self.objtype == 'function'\n545 \n546     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n547         if self.objtype == 'function':\n548             if not modname:\n549                 return _('%s() (built-in function)') % name_cls[0]\n550             return _('%s() (in module %s)') % (name_cls[0], modname)\n551         elif self.objtype == 'data':\n552             if not modname:\n553                 return _('%s (built-in variable)') % name_cls[0]\n554             return _('%s (in module %s)') % (name_cls[0], modname)\n555         else:\n556             return ''\n557 \n558 \n559 class PyFunction(PyObject):\n560     \"\"\"Description of a function.\"\"\"\n561 \n562     option_spec = PyObject.option_spec.copy()\n563     option_spec.update({\n564         'async': directives.flag,\n565     })\n566 \n567     def get_signature_prefix(self, sig: str) -> str:\n568         if 'async' in self.options:\n569             return 'async '\n570         else:\n571             return ''\n572 \n573     def needs_arglist(self) -> bool:\n574         return True\n575 \n576     def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n577                              signode: desc_signature) -> None:\n578         super().add_target_and_index(name_cls, sig, signode)\n579         modname = self.options.get('module', self.env.ref_context.get('py:module'))\n580         node_id = signode['ids'][0]\n581 \n582         name, cls = name_cls\n583         if modname:\n584             text = _('%s() (in module %s)') % (name, modname)\n585             self.indexnode['entries'].append(('single', text, node_id, '', None))\n586         else:\n587             text = '%s; %s()' % (pairindextypes['builtin'], name)\n588             self.indexnode['entries'].append(('pair', text, node_id, '', None))\n589 \n590     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n591         # add index in own add_target_and_index() instead.\n592         return None\n593 \n594 \n595 class PyDecoratorFunction(PyFunction):\n596     \"\"\"Description of a decorator.\"\"\"\n597 \n598     def run(self) -> List[Node]:\n599         # a decorator function is a function after all\n600         self.name = 'py:function'\n601         return super().run()\n602 \n603     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n604         ret = super().handle_signature(sig, signode)\n605         signode.insert(0, addnodes.desc_addname('@', '@'))\n606         return ret\n607 \n608     def needs_arglist(self) -> bool:\n609         return False\n610 \n611 \n612 class PyVariable(PyObject):\n613     \"\"\"Description of a variable.\"\"\"\n614 \n615     option_spec = PyObject.option_spec.copy()\n616     option_spec.update({\n617         'type': directives.unchanged,\n618         'value': directives.unchanged,\n619     })\n620 \n621     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n622         fullname, prefix = super().handle_signature(sig, signode)\n623 \n624         typ = self.options.get('type')\n625         if typ:\n626             signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))\n627 \n628         value = self.options.get('value')\n629         if value:\n630             signode += addnodes.desc_annotation(value, ' = ' + value)\n631 \n632         return fullname, prefix\n633 \n634     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n635         name, cls = name_cls\n636         if modname:\n637             return _('%s (in module %s)') % (name, modname)\n638         else:\n639             return _('%s (built-in variable)') % name\n640 \n641 \n642 class PyClasslike(PyObject):\n643     \"\"\"\n644     Description of a class-like object (classes, interfaces, exceptions).\n645     \"\"\"\n646 \n647     option_spec = PyObject.option_spec.copy()\n648     option_spec.update({\n649         'final': directives.flag,\n650     })\n651 \n652     allow_nesting = True\n653 \n654     def get_signature_prefix(self, sig: str) -> str:\n655         if 'final' in self.options:\n656             return 'final %s ' % self.objtype\n657         else:\n658             return '%s ' % self.objtype\n659 \n660     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n661         if self.objtype == 'class':\n662             if not modname:\n663                 return _('%s (built-in class)') % name_cls[0]\n664             return _('%s (class in %s)') % (name_cls[0], modname)\n665         elif self.objtype == 'exception':\n666             return name_cls[0]\n667         else:\n668             return ''\n669 \n670 \n671 class PyClassmember(PyObject):\n672     \"\"\"\n673     Description of a class member (methods, attributes).\n674     \"\"\"\n675 \n676     def run(self) -> List[Node]:\n677         for cls in self.__class__.__mro__:\n678             if cls.__name__ != 'DirectiveAdapter':\n679                 warnings.warn('PyClassmember is deprecated. '\n680                               'Please check the implementation of %s' % cls,\n681                               RemovedInSphinx40Warning, stacklevel=2)\n682                 break\n683         else:\n684             warnings.warn('PyClassmember is deprecated',\n685                           RemovedInSphinx40Warning, stacklevel=2)\n686 \n687         return super().run()\n688 \n689     def needs_arglist(self) -> bool:\n690         return self.objtype.endswith('method')\n691 \n692     def get_signature_prefix(self, sig: str) -> str:\n693         if self.objtype == 'staticmethod':\n694             return 'static '\n695         elif self.objtype == 'classmethod':\n696             return 'classmethod '\n697         return ''\n698 \n699     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n700         name, cls = name_cls\n701         add_modules = self.env.config.add_module_names\n702         if self.objtype == 'method':\n703             try:\n704                 clsname, methname = name.rsplit('.', 1)\n705             except ValueError:\n706                 if modname:\n707                     return _('%s() (in module %s)') % (name, modname)\n708                 else:\n709                     return '%s()' % name\n710             if modname and add_modules:\n711                 return _('%s() (%s.%s method)') % (methname, modname, clsname)\n712             else:\n713                 return _('%s() (%s method)') % (methname, clsname)\n714         elif self.objtype == 'staticmethod':\n715             try:\n716                 clsname, methname = name.rsplit('.', 1)\n717             except ValueError:\n718                 if modname:\n719                     return _('%s() (in module %s)') % (name, modname)\n720                 else:\n721                     return '%s()' % name\n722             if modname and add_modules:\n723                 return _('%s() (%s.%s static method)') % (methname, modname,\n724                                                           clsname)\n725             else:\n726                 return _('%s() (%s static method)') % (methname, clsname)\n727         elif self.objtype == 'classmethod':\n728             try:\n729                 clsname, methname = name.rsplit('.', 1)\n730             except ValueError:\n731                 if modname:\n732                     return _('%s() (in module %s)') % (name, modname)\n733                 else:\n734                     return '%s()' % name\n735             if modname:\n736                 return _('%s() (%s.%s class method)') % (methname, modname,\n737                                                          clsname)\n738             else:\n739                 return _('%s() (%s class method)') % (methname, clsname)\n740         elif self.objtype == 'attribute':\n741             try:\n742                 clsname, attrname = name.rsplit('.', 1)\n743             except ValueError:\n744                 if modname:\n745                     return _('%s (in module %s)') % (name, modname)\n746                 else:\n747                     return name\n748             if modname and add_modules:\n749                 return _('%s (%s.%s attribute)') % (attrname, modname, clsname)\n750             else:\n751                 return _('%s (%s attribute)') % (attrname, clsname)\n752         else:\n753             return ''\n754 \n755 \n756 class PyMethod(PyObject):\n757     \"\"\"Description of a method.\"\"\"\n758 \n759     option_spec = PyObject.option_spec.copy()\n760     option_spec.update({\n761         'abstractmethod': directives.flag,\n762         'async': directives.flag,\n763         'classmethod': directives.flag,\n764         'final': directives.flag,\n765         'property': directives.flag,\n766         'staticmethod': directives.flag,\n767     })\n768 \n769     def needs_arglist(self) -> bool:\n770         if 'property' in self.options:\n771             return False\n772         else:\n773             return True\n774 \n775     def get_signature_prefix(self, sig: str) -> str:\n776         prefix = []\n777         if 'final' in self.options:\n778             prefix.append('final')\n779         if 'abstractmethod' in self.options:\n780             prefix.append('abstract')\n781         if 'async' in self.options:\n782             prefix.append('async')\n783         if 'classmethod' in self.options:\n784             prefix.append('classmethod')\n785         if 'property' in self.options:\n786             prefix.append('property')\n787         if 'staticmethod' in self.options:\n788             prefix.append('static')\n789 \n790         if prefix:\n791             return ' '.join(prefix) + ' '\n792         else:\n793             return ''\n794 \n795     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n796         name, cls = name_cls\n797         try:\n798             clsname, methname = name.rsplit('.', 1)\n799             if modname and self.env.config.add_module_names:\n800                 clsname = '.'.join([modname, clsname])\n801         except ValueError:\n802             if modname:\n803                 return _('%s() (in module %s)') % (name, modname)\n804             else:\n805                 return '%s()' % name\n806 \n807         if 'classmethod' in self.options:\n808             return _('%s() (%s class method)') % (methname, clsname)\n809         elif 'property' in self.options:\n810             return _('%s() (%s property)') % (methname, clsname)\n811         elif 'staticmethod' in self.options:\n812             return _('%s() (%s static method)') % (methname, clsname)\n813         else:\n814             return _('%s() (%s method)') % (methname, clsname)\n815 \n816 \n817 class PyClassMethod(PyMethod):\n818     \"\"\"Description of a classmethod.\"\"\"\n819 \n820     option_spec = PyObject.option_spec.copy()\n821 \n822     def run(self) -> List[Node]:\n823         self.name = 'py:method'\n824         self.options['classmethod'] = True\n825 \n826         return super().run()\n827 \n828 \n829 class PyStaticMethod(PyMethod):\n830     \"\"\"Description of a staticmethod.\"\"\"\n831 \n832     option_spec = PyObject.option_spec.copy()\n833 \n834     def run(self) -> List[Node]:\n835         self.name = 'py:method'\n836         self.options['staticmethod'] = True\n837 \n838         return super().run()\n839 \n840 \n841 class PyDecoratorMethod(PyMethod):\n842     \"\"\"Description of a decoratormethod.\"\"\"\n843 \n844     def run(self) -> List[Node]:\n845         self.name = 'py:method'\n846         return super().run()\n847 \n848     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n849         ret = super().handle_signature(sig, signode)\n850         signode.insert(0, addnodes.desc_addname('@', '@'))\n851         return ret\n852 \n853     def needs_arglist(self) -> bool:\n854         return False\n855 \n856 \n857 class PyAttribute(PyObject):\n858     \"\"\"Description of an attribute.\"\"\"\n859 \n860     option_spec = PyObject.option_spec.copy()\n861     option_spec.update({\n862         'type': directives.unchanged,\n863         'value': directives.unchanged,\n864     })\n865 \n866     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n867         fullname, prefix = super().handle_signature(sig, signode)\n868 \n869         typ = self.options.get('type')\n870         if typ:\n871             signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), type_to_xref(typ))\n872 \n873         value = self.options.get('value')\n874         if value:\n875             signode += addnodes.desc_annotation(value, ' = ' + value)\n876 \n877         return fullname, prefix\n878 \n879     def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n880         name, cls = name_cls\n881         try:\n882             clsname, attrname = name.rsplit('.', 1)\n883             if modname and self.env.config.add_module_names:\n884                 clsname = '.'.join([modname, clsname])\n885         except ValueError:\n886             if modname:\n887                 return _('%s (in module %s)') % (name, modname)\n888             else:\n889                 return name\n890 \n891         return _('%s (%s attribute)') % (attrname, clsname)\n892 \n893 \n894 class PyDecoratorMixin:\n895     \"\"\"\n896     Mixin for decorator directives.\n897     \"\"\"\n898     def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n899         for cls in self.__class__.__mro__:\n900             if cls.__name__ != 'DirectiveAdapter':\n901                 warnings.warn('PyDecoratorMixin is deprecated. '\n902                               'Please check the implementation of %s' % cls,\n903                               RemovedInSphinx50Warning, stacklevel=2)\n904                 break\n905         else:\n906             warnings.warn('PyDecoratorMixin is deprecated',\n907                           RemovedInSphinx50Warning, stacklevel=2)\n908 \n909         ret = super().handle_signature(sig, signode)  # type: ignore\n910         signode.insert(0, addnodes.desc_addname('@', '@'))\n911         return ret\n912 \n913     def needs_arglist(self) -> bool:\n914         return False\n915 \n916 \n917 class PyModule(SphinxDirective):\n918     \"\"\"\n919     Directive to mark description of a new module.\n920     \"\"\"\n921 \n922     has_content = False\n923     required_arguments = 1\n924     optional_arguments = 0\n925     final_argument_whitespace = False\n926     option_spec = {\n927         'platform': lambda x: x,\n928         'synopsis': lambda x: x,\n929         'noindex': directives.flag,\n930         'deprecated': directives.flag,\n931     }\n932 \n933     def run(self) -> List[Node]:\n934         domain = cast(PythonDomain, self.env.get_domain('py'))\n935 \n936         modname = self.arguments[0].strip()\n937         noindex = 'noindex' in self.options\n938         self.env.ref_context['py:module'] = modname\n939         ret = []  # type: List[Node]\n940         if not noindex:\n941             # note module to the domain\n942             node_id = make_id(self.env, self.state.document, 'module', modname)\n943             target = nodes.target('', '', ids=[node_id], ismod=True)\n944             self.set_source_info(target)\n945 \n946             # Assign old styled node_id not to break old hyperlinks (if possible)\n947             # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n948             old_node_id = self.make_old_id(modname)\n949             if node_id != old_node_id and old_node_id not in self.state.document.ids:\n950                 target['ids'].append(old_node_id)\n951 \n952             self.state.document.note_explicit_target(target)\n953 \n954             domain.note_module(modname,\n955                                node_id,\n956                                self.options.get('synopsis', ''),\n957                                self.options.get('platform', ''),\n958                                'deprecated' in self.options)\n959             domain.note_object(modname, 'module', node_id, location=target)\n960 \n961             # the platform and synopsis aren't printed; in fact, they are only\n962             # used in the modindex currently\n963             ret.append(target)\n964             indextext = '%s; %s' % (pairindextypes['module'], modname)\n965             inode = addnodes.index(entries=[('pair', indextext, node_id, '', None)])\n966             ret.append(inode)\n967         return ret\n968 \n969     def make_old_id(self, name: str) -> str:\n970         \"\"\"Generate old styled node_id.\n971 \n972         Old styled node_id is incompatible with docutils' node_id.\n973         It can contain dots and hyphens.\n974 \n975         .. note:: Old styled node_id was mainly used until Sphinx-3.0.\n976         \"\"\"\n977         return 'module-%s' % name\n978 \n979 \n980 class PyCurrentModule(SphinxDirective):\n981     \"\"\"\n982     This directive is just to tell Sphinx that we're documenting\n983     stuff in module foo, but links to module foo won't lead here.\n984     \"\"\"\n985 \n986     has_content = False\n987     required_arguments = 1\n988     optional_arguments = 0\n989     final_argument_whitespace = False\n990     option_spec = {}  # type: Dict\n991 \n992     def run(self) -> List[Node]:\n993         modname = self.arguments[0].strip()\n994         if modname == 'None':\n995             self.env.ref_context.pop('py:module', None)\n996         else:\n997             self.env.ref_context['py:module'] = modname\n998         return []\n999 \n1000 \n1001 class PyXRefRole(XRefRole):\n1002     def process_link(self, env: BuildEnvironment, refnode: Element,\n1003                      has_explicit_title: bool, title: str, target: str) -> Tuple[str, str]:\n1004         refnode['py:module'] = env.ref_context.get('py:module')\n1005         refnode['py:class'] = env.ref_context.get('py:class')\n1006         if not has_explicit_title:\n1007             title = title.lstrip('.')    # only has a meaning for the target\n1008             target = target.lstrip('~')  # only has a meaning for the title\n1009             # if the first character is a tilde, don't display the module/class\n1010             # parts of the contents\n1011             if title[0:1] == '~':\n1012                 title = title[1:]\n1013                 dot = title.rfind('.')\n1014                 if dot != -1:\n1015                     title = title[dot + 1:]\n1016         # if the first character is a dot, search more specific namespaces first\n1017         # else search builtins first\n1018         if target[0:1] == '.':\n1019             target = target[1:]\n1020             refnode['refspecific'] = True\n1021         return title, target\n1022 \n1023 \n1024 def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:\n1025     \"\"\"Filter ``:meta:`` field from its docstring.\"\"\"\n1026     if domain != 'py':\n1027         return\n1028 \n1029     for node in content:\n1030         if isinstance(node, nodes.field_list):\n1031             fields = cast(List[nodes.field], node)\n1032             for field in fields:\n1033                 field_name = cast(nodes.field_body, field[0]).astext().strip()\n1034                 if field_name == 'meta' or field_name.startswith('meta '):\n1035                     node.remove(field)\n1036                     break\n1037 \n1038 \n1039 class PythonModuleIndex(Index):\n1040     \"\"\"\n1041     Index subclass to provide the Python module index.\n1042     \"\"\"\n1043 \n1044     name = 'modindex'\n1045     localname = _('Python Module Index')\n1046     shortname = _('modules')\n1047 \n1048     def generate(self, docnames: Iterable[str] = None\n1049                  ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:\n1050         content = {}  # type: Dict[str, List[IndexEntry]]\n1051         # list of prefixes to ignore\n1052         ignores = None  # type: List[str]\n1053         ignores = self.domain.env.config['modindex_common_prefix']  # type: ignore\n1054         ignores = sorted(ignores, key=len, reverse=True)\n1055         # list of all modules, sorted by module name\n1056         modules = sorted(self.domain.data['modules'].items(),\n1057                          key=lambda x: x[0].lower())\n1058         # sort out collapsable modules\n1059         prev_modname = ''\n1060         num_toplevels = 0\n1061         for modname, (docname, node_id, synopsis, platforms, deprecated) in modules:\n1062             if docnames and docname not in docnames:\n1063                 continue\n1064 \n1065             for ignore in ignores:\n1066                 if modname.startswith(ignore):\n1067                     modname = modname[len(ignore):]\n1068                     stripped = ignore\n1069                     break\n1070             else:\n1071                 stripped = ''\n1072 \n1073             # we stripped the whole module name?\n1074             if not modname:\n1075                 modname, stripped = stripped, ''\n1076 \n1077             entries = content.setdefault(modname[0].lower(), [])\n1078 \n1079             package = modname.split('.')[0]\n1080             if package != modname:\n1081                 # it's a submodule\n1082                 if prev_modname == package:\n1083                     # first submodule - make parent a group head\n1084                     if entries:\n1085                         last = entries[-1]\n1086                         entries[-1] = IndexEntry(last[0], 1, last[2], last[3],\n1087                                                  last[4], last[5], last[6])\n1088                 elif not prev_modname.startswith(package):\n1089                     # submodule without parent in list, add dummy entry\n1090                     entries.append(IndexEntry(stripped + package, 1, '', '', '', '', ''))\n1091                 subtype = 2\n1092             else:\n1093                 num_toplevels += 1\n1094                 subtype = 0\n1095 \n1096             qualifier = _('Deprecated') if deprecated else ''\n1097             entries.append(IndexEntry(stripped + modname, subtype, docname,\n1098                                       node_id, platforms, qualifier, synopsis))\n1099             prev_modname = modname\n1100 \n1101         # apply heuristics when to collapse modindex at page load:\n1102         # only collapse if number of toplevel modules is larger than\n1103         # number of submodules\n1104         collapse = len(modules) - num_toplevels < num_toplevels\n1105 \n1106         # sort by first letter\n1107         sorted_content = sorted(content.items())\n1108 \n1109         return sorted_content, collapse\n1110 \n1111 \n1112 class PythonDomain(Domain):\n1113     \"\"\"Python language domain.\"\"\"\n1114     name = 'py'\n1115     label = 'Python'\n1116     object_types = {\n1117         'function':     ObjType(_('function'),      'func', 'obj'),\n1118         'data':         ObjType(_('data'),          'data', 'obj'),\n1119         'class':        ObjType(_('class'),         'class', 'exc', 'obj'),\n1120         'exception':    ObjType(_('exception'),     'exc', 'class', 'obj'),\n1121         'method':       ObjType(_('method'),        'meth', 'obj'),\n1122         'classmethod':  ObjType(_('class method'),  'meth', 'obj'),\n1123         'staticmethod': ObjType(_('static method'), 'meth', 'obj'),\n1124         'attribute':    ObjType(_('attribute'),     'attr', 'obj'),\n1125         'module':       ObjType(_('module'),        'mod', 'obj'),\n1126     }  # type: Dict[str, ObjType]\n1127 \n1128     directives = {\n1129         'function':        PyFunction,\n1130         'data':            PyVariable,\n1131         'class':           PyClasslike,\n1132         'exception':       PyClasslike,\n1133         'method':          PyMethod,\n1134         'classmethod':     PyClassMethod,\n1135         'staticmethod':    PyStaticMethod,\n1136         'attribute':       PyAttribute,\n1137         'module':          PyModule,\n1138         'currentmodule':   PyCurrentModule,\n1139         'decorator':       PyDecoratorFunction,\n1140         'decoratormethod': PyDecoratorMethod,\n1141     }\n1142     roles = {\n1143         'data':  PyXRefRole(),\n1144         'exc':   PyXRefRole(),\n1145         'func':  PyXRefRole(fix_parens=True),\n1146         'class': PyXRefRole(),\n1147         'const': PyXRefRole(),\n1148         'attr':  PyXRefRole(),\n1149         'meth':  PyXRefRole(fix_parens=True),\n1150         'mod':   PyXRefRole(),\n1151         'obj':   PyXRefRole(),\n1152     }\n1153     initial_data = {\n1154         'objects': {},  # fullname -> docname, objtype\n1155         'modules': {},  # modname -> docname, synopsis, platform, deprecated\n1156     }  # type: Dict[str, Dict[str, Tuple[Any]]]\n1157     indices = [\n1158         PythonModuleIndex,\n1159     ]\n1160 \n1161     @property\n1162     def objects(self) -> Dict[str, ObjectEntry]:\n1163         return self.data.setdefault('objects', {})  # fullname -> ObjectEntry\n1164 \n1165     def note_object(self, name: str, objtype: str, node_id: str, location: Any = None) -> None:\n1166         \"\"\"Note a python object for cross reference.\n1167 \n1168         .. versionadded:: 2.1\n1169         \"\"\"\n1170         if name in self.objects:\n1171             other = self.objects[name]\n1172             logger.warning(__('duplicate object description of %s, '\n1173                               'other instance in %s, use :noindex: for one of them'),\n1174                            name, other.docname, location=location)\n1175         self.objects[name] = ObjectEntry(self.env.docname, node_id, objtype)\n1176 \n1177     @property\n1178     def modules(self) -> Dict[str, ModuleEntry]:\n1179         return self.data.setdefault('modules', {})  # modname -> ModuleEntry\n1180 \n1181     def note_module(self, name: str, node_id: str, synopsis: str,\n1182                     platform: str, deprecated: bool) -> None:\n1183         \"\"\"Note a python module for cross reference.\n1184 \n1185         .. versionadded:: 2.1\n1186         \"\"\"\n1187         self.modules[name] = ModuleEntry(self.env.docname, node_id,\n1188                                          synopsis, platform, deprecated)\n1189 \n1190     def clear_doc(self, docname: str) -> None:\n1191         for fullname, obj in list(self.objects.items()):\n1192             if obj.docname == docname:\n1193                 del self.objects[fullname]\n1194         for modname, mod in list(self.modules.items()):\n1195             if mod.docname == docname:\n1196                 del self.modules[modname]\n1197 \n1198     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:\n1199         # XXX check duplicates?\n1200         for fullname, obj in otherdata['objects'].items():\n1201             if obj.docname in docnames:\n1202                 self.objects[fullname] = obj\n1203         for modname, mod in otherdata['modules'].items():\n1204             if mod.docname in docnames:\n1205                 self.modules[modname] = mod\n1206 \n1207     def find_obj(self, env: BuildEnvironment, modname: str, classname: str,\n1208                  name: str, type: str, searchmode: int = 0\n1209                  ) -> List[Tuple[str, ObjectEntry]]:\n1210         \"\"\"Find a Python object for \"name\", perhaps using the given module\n1211         and/or classname.  Returns a list of (name, object entry) tuples.\n1212         \"\"\"\n1213         # skip parens\n1214         if name[-2:] == '()':\n1215             name = name[:-2]\n1216 \n1217         if not name:\n1218             return []\n1219 \n1220         matches = []  # type: List[Tuple[str, ObjectEntry]]\n1221 \n1222         newname = None\n1223         if searchmode == 1:\n1224             if type is None:\n1225                 objtypes = list(self.object_types)\n1226             else:\n1227                 objtypes = self.objtypes_for_role(type)\n1228             if objtypes is not None:\n1229                 if modname and classname:\n1230                     fullname = modname + '.' + classname + '.' + name\n1231                     if fullname in self.objects and self.objects[fullname].objtype in objtypes:\n1232                         newname = fullname\n1233                 if not newname:\n1234                     if modname and modname + '.' + name in self.objects and \\\n1235                        self.objects[modname + '.' + name].objtype in objtypes:\n1236                         newname = modname + '.' + name\n1237                     elif name in self.objects and self.objects[name].objtype in objtypes:\n1238                         newname = name\n1239                     else:\n1240                         # \"fuzzy\" searching mode\n1241                         searchname = '.' + name\n1242                         matches = [(oname, self.objects[oname]) for oname in self.objects\n1243                                    if oname.endswith(searchname) and\n1244                                    self.objects[oname].objtype in objtypes]\n1245         else:\n1246             # NOTE: searching for exact match, object type is not considered\n1247             if name in self.objects:\n1248                 newname = name\n1249             elif type == 'mod':\n1250                 # only exact matches allowed for modules\n1251                 return []\n1252             elif classname and classname + '.' + name in self.objects:\n1253                 newname = classname + '.' + name\n1254             elif modname and modname + '.' + name in self.objects:\n1255                 newname = modname + '.' + name\n1256             elif modname and classname and \\\n1257                     modname + '.' + classname + '.' + name in self.objects:\n1258                 newname = modname + '.' + classname + '.' + name\n1259         if newname is not None:\n1260             matches.append((newname, self.objects[newname]))\n1261         return matches\n1262 \n1263     def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n1264                      type: str, target: str, node: pending_xref, contnode: Element\n1265                      ) -> Element:\n1266         modname = node.get('py:module')\n1267         clsname = node.get('py:class')\n1268         searchmode = 1 if node.hasattr('refspecific') else 0\n1269         matches = self.find_obj(env, modname, clsname, target,\n1270                                 type, searchmode)\n1271 \n1272         if not matches and type == 'attr':\n1273             # fallback to meth (for property)\n1274             matches = self.find_obj(env, modname, clsname, target, 'meth', searchmode)\n1275 \n1276         if not matches:\n1277             return None\n1278         elif len(matches) > 1:\n1279             logger.warning(__('more than one target found for cross-reference %r: %s'),\n1280                            target, ', '.join(match[0] for match in matches),\n1281                            type='ref', subtype='python', location=node)\n1282         name, obj = matches[0]\n1283 \n1284         if obj[2] == 'module':\n1285             return self._make_module_refnode(builder, fromdocname, name, contnode)\n1286         else:\n1287             return make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name)\n1288 \n1289     def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n1290                          target: str, node: pending_xref, contnode: Element\n1291                          ) -> List[Tuple[str, Element]]:\n1292         modname = node.get('py:module')\n1293         clsname = node.get('py:class')\n1294         results = []  # type: List[Tuple[str, Element]]\n1295 \n1296         # always search in \"refspecific\" mode with the :any: role\n1297         matches = self.find_obj(env, modname, clsname, target, None, 1)\n1298         for name, obj in matches:\n1299             if obj[2] == 'module':\n1300                 results.append(('py:mod',\n1301                                 self._make_module_refnode(builder, fromdocname,\n1302                                                           name, contnode)))\n1303             else:\n1304                 results.append(('py:' + self.role_for_objtype(obj[2]),\n1305                                 make_refnode(builder, fromdocname, obj[0], obj[1],\n1306                                              contnode, name)))\n1307         return results\n1308 \n1309     def _make_module_refnode(self, builder: Builder, fromdocname: str, name: str,\n1310                              contnode: Node) -> Element:\n1311         # get additional info for modules\n1312         module = self.modules[name]\n1313         title = name\n1314         if module.synopsis:\n1315             title += ': ' + module.synopsis\n1316         if module.deprecated:\n1317             title += _(' (deprecated)')\n1318         if module.platform:\n1319             title += ' (' + module.platform + ')'\n1320         return make_refnode(builder, fromdocname, module.docname, module.node_id,\n1321                             contnode, title)\n1322 \n1323     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:\n1324         for modname, mod in self.modules.items():\n1325             yield (modname, modname, 'module', mod.docname, mod.node_id, 0)\n1326         for refname, obj in self.objects.items():\n1327             if obj.objtype != 'module':  # modules are already handled\n1328                 yield (refname, refname, obj.objtype, obj.docname, obj.node_id, 1)\n1329 \n1330     def get_full_qualified_name(self, node: Element) -> str:\n1331         modname = node.get('py:module')\n1332         clsname = node.get('py:class')\n1333         target = node.get('reftarget')\n1334         if target is None:\n1335             return None\n1336         else:\n1337             return '.'.join(filter(None, [modname, clsname, target]))\n1338 \n1339 \n1340 def builtin_resolver(app: Sphinx, env: BuildEnvironment,\n1341                      node: pending_xref, contnode: Element) -> Element:\n1342     \"\"\"Do not emit nitpicky warnings for built-in types.\"\"\"\n1343     def istyping(s: str) -> bool:\n1344         if s.startswith('typing.'):\n1345             s = s.split('.', 1)[1]\n1346 \n1347         return s in typing.__all__  # type: ignore\n1348 \n1349     if node.get('refdomain') != 'py':\n1350         return None\n1351     elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':\n1352         return contnode\n1353     elif node.get('reftype') in ('class', 'exc'):\n1354         reftarget = node.get('reftarget')\n1355         if inspect.isclass(getattr(builtins, reftarget, None)):\n1356             # built-in class\n1357             return contnode\n1358         elif istyping(reftarget):\n1359             # typing class\n1360             return contnode\n1361 \n1362     return None\n1363 \n1364 \n1365 def setup(app: Sphinx) -> Dict[str, Any]:\n1366     app.setup_extension('sphinx.directives')\n1367 \n1368     app.add_domain(PythonDomain)\n1369     app.connect('object-description-transform', filter_meta_fields)\n1370     app.connect('missing-reference', builtin_resolver, priority=900)\n1371 \n1372     return {\n1373         'version': 'builtin',\n1374         'env_version': 2,\n1375         'parallel_read_safe': True,\n1376         'parallel_write_safe': True,\n1377     }\n",
        "intended_behavior": "Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately."
    },
    {
        "rel_file_path": "sphinx/directives/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.1/sphinx/directives/__init__.py",
        "start": 1,
        "end": 324,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.directives\n3     ~~~~~~~~~~~~~~~~~\n4 \n5     Handlers for additional ReST directives.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 from typing import Any, Dict, List, Tuple\n13 from typing import cast\n14 \n15 from docutils import nodes\n16 from docutils.nodes import Node\n17 from docutils.parsers.rst import directives, roles\n18 \n19 from sphinx import addnodes\n20 from sphinx.addnodes import desc_signature\n21 from sphinx.deprecation import (\n22     RemovedInSphinx40Warning, RemovedInSphinx50Warning, deprecated_alias\n23 )\n24 from sphinx.util import docutils\n25 from sphinx.util.docfields import DocFieldTransformer, Field, TypedField\n26 from sphinx.util.docutils import SphinxDirective\n27 from sphinx.util.typing import DirectiveOption\n28 \n29 if False:\n30     # For type annotation\n31     from sphinx.application import Sphinx\n32 \n33 \n34 # RE to strip backslash escapes\n35 nl_escape_re = re.compile(r'\\\\\\n')\n36 strip_backslash_re = re.compile(r'\\\\(.)')\n37 \n38 \n39 def optional_int(argument: str) -> int:\n40     \"\"\"\n41     Check for an integer argument or None value; raise ``ValueError`` if not.\n42     \"\"\"\n43     if argument is None:\n44         return None\n45     else:\n46         value = int(argument)\n47         if value < 0:\n48             raise ValueError('negative value; must be positive or zero')\n49         return value\n50 \n51 \n52 class ObjectDescription(SphinxDirective):\n53     \"\"\"\n54     Directive to describe a class, function or similar object.  Not used\n55     directly, but subclassed (in domain-specific directives) to add custom\n56     behavior.\n57     \"\"\"\n58 \n59     has_content = True\n60     required_arguments = 1\n61     optional_arguments = 0\n62     final_argument_whitespace = True\n63     option_spec = {\n64         'noindex': directives.flag,\n65     }  # type: Dict[str, DirectiveOption]\n66 \n67     # types of doc fields that this directive handles, see sphinx.util.docfields\n68     doc_field_types = []    # type: List[Field]\n69     domain = None           # type: str\n70     objtype = None          # type: str\n71     indexnode = None        # type: addnodes.index\n72 \n73     # Warning: this might be removed in future version. Don't touch this from extensions.\n74     _doc_field_type_map = {}  # type: Dict[str, Tuple[Field, bool]]\n75 \n76     def get_field_type_map(self) -> Dict[str, Tuple[Field, bool]]:\n77         if self._doc_field_type_map == {}:\n78             self._doc_field_type_map = {}\n79             for field in self.doc_field_types:\n80                 for name in field.names:\n81                     self._doc_field_type_map[name] = (field, False)\n82 \n83                 if field.is_typed:\n84                     typed_field = cast(TypedField, field)\n85                     for name in typed_field.typenames:\n86                         self._doc_field_type_map[name] = (field, True)\n87 \n88         return self._doc_field_type_map\n89 \n90     def get_signatures(self) -> List[str]:\n91         \"\"\"\n92         Retrieve the signatures to document from the directive arguments.  By\n93         default, signatures are given as arguments, one per line.\n94         \"\"\"\n95         lines = nl_escape_re.sub('', self.arguments[0]).split('\\n')\n96         if self.config.strip_signature_backslash:\n97             # remove backslashes to support (dummy) escapes; helps Vim highlighting\n98             return [strip_backslash_re.sub(r'\\1', line.strip()) for line in lines]\n99         else:\n100             return [line.strip() for line in lines]\n101 \n102     def handle_signature(self, sig: str, signode: desc_signature) -> Any:\n103         \"\"\"\n104         Parse the signature *sig* into individual nodes and append them to\n105         *signode*. If ValueError is raised, parsing is aborted and the whole\n106         *sig* is put into a single desc_name node.\n107 \n108         The return value should be a value that identifies the object.  It is\n109         passed to :meth:`add_target_and_index()` unchanged, and otherwise only\n110         used to skip duplicates.\n111         \"\"\"\n112         raise ValueError\n113 \n114     def add_target_and_index(self, name: Any, sig: str, signode: desc_signature) -> None:\n115         \"\"\"\n116         Add cross-reference IDs and entries to self.indexnode, if applicable.\n117 \n118         *name* is whatever :meth:`handle_signature()` returned.\n119         \"\"\"\n120         return  # do nothing by default\n121 \n122     def before_content(self) -> None:\n123         \"\"\"\n124         Called before parsing content. Used to set information about the current\n125         directive context on the build environment.\n126         \"\"\"\n127         pass\n128 \n129     def transform_content(self, contentnode: addnodes.desc_content) -> None:\n130         \"\"\"\n131         Called after creating the content through nested parsing,\n132         but before the ``object-description-transform`` event is emitted,\n133         and before the info-fields are transformed.\n134         Can be used to manipulate the content.\n135         \"\"\"\n136         pass\n137 \n138     def after_content(self) -> None:\n139         \"\"\"\n140         Called after parsing content. Used to reset information about the\n141         current directive context on the build environment.\n142         \"\"\"\n143         pass\n144 \n145     def run(self) -> List[Node]:\n146         \"\"\"\n147         Main directive entry function, called by docutils upon encountering the\n148         directive.\n149 \n150         This directive is meant to be quite easily subclassable, so it delegates\n151         to several additional methods.  What it does:\n152 \n153         * find out if called as a domain-specific directive, set self.domain\n154         * create a `desc` node to fit all description inside\n155         * parse standard options, currently `noindex`\n156         * create an index node if needed as self.indexnode\n157         * parse all given signatures (as returned by self.get_signatures())\n158           using self.handle_signature(), which should either return a name\n159           or raise ValueError\n160         * add index entries using self.add_target_and_index()\n161         * parse the content and handle doc fields in it\n162         \"\"\"\n163         if ':' in self.name:\n164             self.domain, self.objtype = self.name.split(':', 1)\n165         else:\n166             self.domain, self.objtype = '', self.name\n167         self.indexnode = addnodes.index(entries=[])\n168 \n169         node = addnodes.desc()\n170         node.document = self.state.document\n171         node['domain'] = self.domain\n172         # 'desctype' is a backwards compatible attribute\n173         node['objtype'] = node['desctype'] = self.objtype\n174         node['noindex'] = noindex = ('noindex' in self.options)\n175         if self.domain:\n176             node['classes'].append(self.domain)\n177 \n178         self.names = []  # type: List[Any]\n179         signatures = self.get_signatures()\n180         for i, sig in enumerate(signatures):\n181             # add a signature node for each signature in the current unit\n182             # and add a reference target for it\n183             signode = addnodes.desc_signature(sig, '')\n184             self.set_source_info(signode)\n185             node.append(signode)\n186             try:\n187                 # name can also be a tuple, e.g. (classname, objname);\n188                 # this is strictly domain-specific (i.e. no assumptions may\n189                 # be made in this base class)\n190                 name = self.handle_signature(sig, signode)\n191             except ValueError:\n192                 # signature parsing failed\n193                 signode.clear()\n194                 signode += addnodes.desc_name(sig, sig)\n195                 continue  # we don't want an index entry here\n196             if name not in self.names:\n197                 self.names.append(name)\n198                 if not noindex:\n199                     # only add target and index entry if this is the first\n200                     # description of the object with this name in this desc block\n201                     self.add_target_and_index(name, sig, signode)\n202 \n203         contentnode = addnodes.desc_content()\n204         node.append(contentnode)\n205         if self.names:\n206             # needed for association of version{added,changed} directives\n207             self.env.temp_data['object'] = self.names[0]\n208         self.before_content()\n209         self.state.nested_parse(self.content, self.content_offset, contentnode)\n210         self.transform_content(contentnode)\n211         self.env.app.emit('object-description-transform',\n212                           self.domain, self.objtype, contentnode)\n213         DocFieldTransformer(self).transform_all(contentnode)\n214         self.env.temp_data['object'] = None\n215         self.after_content()\n216         return [self.indexnode, node]\n217 \n218 \n219 class DefaultRole(SphinxDirective):\n220     \"\"\"\n221     Set the default interpreted text role.  Overridden from docutils.\n222     \"\"\"\n223 \n224     optional_arguments = 1\n225     final_argument_whitespace = False\n226 \n227     def run(self) -> List[Node]:\n228         if not self.arguments:\n229             docutils.unregister_role('')\n230             return []\n231         role_name = self.arguments[0]\n232         role, messages = roles.role(role_name, self.state_machine.language,\n233                                     self.lineno, self.state.reporter)\n234         if role:\n235             docutils.register_role('', role)\n236             self.env.temp_data['default_role'] = role_name\n237         else:\n238             literal_block = nodes.literal_block(self.block_text, self.block_text)\n239             reporter = self.state.reporter\n240             error = reporter.error('Unknown interpreted text role \"%s\".' % role_name,\n241                                    literal_block, line=self.lineno)\n242             messages += [error]\n243 \n244         return cast(List[nodes.Node], messages)\n245 \n246 \n247 class DefaultDomain(SphinxDirective):\n248     \"\"\"\n249     Directive to (re-)set the default domain for this source file.\n250     \"\"\"\n251 \n252     has_content = False\n253     required_arguments = 1\n254     optional_arguments = 0\n255     final_argument_whitespace = False\n256     option_spec = {}  # type: Dict\n257 \n258     def run(self) -> List[Node]:\n259         domain_name = self.arguments[0].lower()\n260         # if domain_name not in env.domains:\n261         #     # try searching by label\n262         #     for domain in env.domains.values():\n263         #         if domain.label.lower() == domain_name:\n264         #             domain_name = domain.name\n265         #             break\n266         self.env.temp_data['default_domain'] = self.env.domains.get(domain_name)\n267         return []\n268 \n269 from sphinx.directives.code import (  # noqa\n270     Highlight, CodeBlock, LiteralInclude\n271 )\n272 from sphinx.directives.other import (  # noqa\n273     TocTree, Author, VersionChange, SeeAlso,\n274     TabularColumns, Centered, Acks, HList, Only, Include, Class\n275 )\n276 from sphinx.directives.patches import (  # noqa\n277     Figure, Meta\n278 )\n279 from sphinx.domains.index import IndexDirective  # noqa\n280 \n281 deprecated_alias('sphinx.directives',\n282                  {\n283                      'Highlight': Highlight,\n284                      'CodeBlock': CodeBlock,\n285                      'LiteralInclude': LiteralInclude,\n286                      'TocTree': TocTree,\n287                      'Author': Author,\n288                      'Index': IndexDirective,\n289                      'VersionChange': VersionChange,\n290                      'SeeAlso': SeeAlso,\n291                      'TabularColumns': TabularColumns,\n292                      'Centered': Centered,\n293                      'Acks': Acks,\n294                      'HList': HList,\n295                      'Only': Only,\n296                      'Include': Include,\n297                      'Class': Class,\n298                      'Figure': Figure,\n299                      'Meta': Meta,\n300                  },\n301                  RemovedInSphinx40Warning)\n302 \n303 deprecated_alias('sphinx.directives',\n304                  {\n305                      'DescDirective': ObjectDescription,\n306                  },\n307                  RemovedInSphinx50Warning)\n308 \n309 \n310 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n311     app.add_config_value(\"strip_signature_backslash\", False, 'env')\n312     directives.register_directive('default-role', DefaultRole)\n313     directives.register_directive('default-domain', DefaultDomain)\n314     directives.register_directive('describe', ObjectDescription)\n315     # new, more consistent, name\n316     directives.register_directive('object', ObjectDescription)\n317 \n318     app.add_event('object-description-transform')\n319 \n320     return {\n321         'version': 'builtin',\n322         'parallel_read_safe': True,\n323         'parallel_write_safe': True,\n324     }\n",
        "intended_behavior": "Manually inspect the file to identify where `get_signature` functions are defined and how they can be modified to document overloaded methods adequately."
    }
]