[
    {
        "rel_file_path": "sympy/polys/domains/domain.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.11/sympy/polys/domains/domain.py",
        "start": 865,
        "end": 868,
        "class_name": "Domain",
        "method_name": "frac_field",
        "code": "865     def frac_field(self, *symbols, order=lex):\n866         \"\"\"Returns a fraction field, i.e. `K(X)`. \"\"\"\n867         from sympy.polys.domains.fractionfield import FractionField\n868         return FractionField(self, symbols, order)\n",
        "intended_behavior": "The `frac_field` method should ensure that when creating a fraction field, elements that are algebraically derived from the symbols (like `1/x`) are properly recognized and included within the field. To resolve the issue, the implementation may need to include additional logic to handle and recognize inverse elements or more complex algebraic expressions as belonging to the field. This may involve adjusting how elements are checked for membership or extending the method's capability to interpret and incorporate such elements into the fraction field construct. The existing functionality, which facilitates the construction of fraction fields with specified symbols and order, must be preserved while enhancing the method to recognize elements like `1/x` as being part of `K(X)`."
    },
    {
        "rel_file_path": "sympy/polys/domains/domain.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.11/sympy/polys/domains/domain.py",
        "start": 19,
        "end": 1301,
        "class_name": "Domain",
        "method_name": null,
        "code": "19 class Domain:\n20     \"\"\"Superclass for all domains in the polys domains system.\n21 \n22     See :ref:`polys-domainsintro` for an introductory explanation of the\n23     domains system.\n24 \n25     The :py:class:`~.Domain` class is an abstract base class for all of the\n26     concrete domain types. There are many different :py:class:`~.Domain`\n27     subclasses each of which has an associated ``dtype`` which is a class\n28     representing the elements of the domain. The coefficients of a\n29     :py:class:`~.Poly` are elements of a domain which must be a subclass of\n30     :py:class:`~.Domain`.\n31 \n32     Examples\n33     ========\n34 \n35     The most common example domains are the integers :ref:`ZZ` and the\n36     rationals :ref:`QQ`.\n37 \n38     >>> from sympy import Poly, symbols, Domain\n39     >>> x, y = symbols('x, y')\n40     >>> p = Poly(x**2 + y)\n41     >>> p\n42     Poly(x**2 + y, x, y, domain='ZZ')\n43     >>> p.domain\n44     ZZ\n45     >>> isinstance(p.domain, Domain)\n46     True\n47     >>> Poly(x**2 + y/2)\n48     Poly(x**2 + 1/2*y, x, y, domain='QQ')\n49 \n50     The domains can be used directly in which case the domain object e.g.\n51     (:ref:`ZZ` or :ref:`QQ`) can be used as a constructor for elements of\n52     ``dtype``.\n53 \n54     >>> from sympy import ZZ, QQ\n55     >>> ZZ(2)\n56     2\n57     >>> ZZ.dtype  # doctest: +SKIP\n58     <class 'int'>\n59     >>> type(ZZ(2))  # doctest: +SKIP\n60     <class 'int'>\n61     >>> QQ(1, 2)\n62     1/2\n63     >>> type(QQ(1, 2))  # doctest: +SKIP\n64     <class 'sympy.polys.domains.pythonrational.PythonRational'>\n65 \n66     The corresponding domain elements can be used with the arithmetic\n67     operations ``+,-,*,**`` and depending on the domain some combination of\n68     ``/,//,%`` might be usable. For example in :ref:`ZZ` both ``//`` (floor\n69     division) and ``%`` (modulo division) can be used but ``/`` (true\n70     division) cannot. Since :ref:`QQ` is a :py:class:`~.Field` its elements\n71     can be used with ``/`` but ``//`` and ``%`` should not be used. Some\n72     domains have a :py:meth:`~.Domain.gcd` method.\n73 \n74     >>> ZZ(2) + ZZ(3)\n75     5\n76     >>> ZZ(5) // ZZ(2)\n77     2\n78     >>> ZZ(5) % ZZ(2)\n79     1\n80     >>> QQ(1, 2) / QQ(2, 3)\n81     3/4\n82     >>> ZZ.gcd(ZZ(4), ZZ(2))\n83     2\n84     >>> QQ.gcd(QQ(2,7), QQ(5,3))\n85     1/21\n86     >>> ZZ.is_Field\n87     False\n88     >>> QQ.is_Field\n89     True\n90 \n91     There are also many other domains including:\n92 \n93         1. :ref:`GF(p)` for finite fields of prime order.\n94         2. :ref:`RR` for real (floating point) numbers.\n95         3. :ref:`CC` for complex (floating point) numbers.\n96         4. :ref:`QQ(a)` for algebraic number fields.\n97         5. :ref:`K[x]` for polynomial rings.\n98         6. :ref:`K(x)` for rational function fields.\n99         7. :ref:`EX` for arbitrary expressions.\n100 \n101     Each domain is represented by a domain object and also an implementation\n102     class (``dtype``) for the elements of the domain. For example the\n103     :ref:`K[x]` domains are represented by a domain object which is an\n104     instance of :py:class:`~.PolynomialRing` and the elements are always\n105     instances of :py:class:`~.PolyElement`. The implementation class\n106     represents particular types of mathematical expressions in a way that is\n107     more efficient than a normal SymPy expression which is of type\n108     :py:class:`~.Expr`. The domain methods :py:meth:`~.Domain.from_sympy` and\n109     :py:meth:`~.Domain.to_sympy` are used to convert from :py:class:`~.Expr`\n110     to a domain element and vice versa.\n111 \n112     >>> from sympy import Symbol, ZZ, Expr\n113     >>> x = Symbol('x')\n114     >>> K = ZZ[x]           # polynomial ring domain\n115     >>> K\n116     ZZ[x]\n117     >>> type(K)             # class of the domain\n118     <class 'sympy.polys.domains.polynomialring.PolynomialRing'>\n119     >>> K.dtype             # class of the elements\n120     <class 'sympy.polys.rings.PolyElement'>\n121     >>> p_expr = x**2 + 1   # Expr\n122     >>> p_expr\n123     x**2 + 1\n124     >>> type(p_expr)\n125     <class 'sympy.core.add.Add'>\n126     >>> isinstance(p_expr, Expr)\n127     True\n128     >>> p_domain = K.from_sympy(p_expr)\n129     >>> p_domain            # domain element\n130     x**2 + 1\n131     >>> type(p_domain)\n132     <class 'sympy.polys.rings.PolyElement'>\n133     >>> K.to_sympy(p_domain) == p_expr\n134     True\n135 \n136     The :py:meth:`~.Domain.convert_from` method is used to convert domain\n137     elements from one domain to another.\n138 \n139     >>> from sympy import ZZ, QQ\n140     >>> ez = ZZ(2)\n141     >>> eq = QQ.convert_from(ez, ZZ)\n142     >>> type(ez)  # doctest: +SKIP\n143     <class 'int'>\n144     >>> type(eq)  # doctest: +SKIP\n145     <class 'sympy.polys.domains.pythonrational.PythonRational'>\n146 \n147     Elements from different domains should not be mixed in arithmetic or other\n148     operations: they should be converted to a common domain first.  The domain\n149     method :py:meth:`~.Domain.unify` is used to find a domain that can\n150     represent all the elements of two given domains.\n151 \n152     >>> from sympy import ZZ, QQ, symbols\n153     >>> x, y = symbols('x, y')\n154     >>> ZZ.unify(QQ)\n155     QQ\n156     >>> ZZ[x].unify(QQ)\n157     QQ[x]\n158     >>> ZZ[x].unify(QQ[y])\n159     QQ[x,y]\n160 \n161     If a domain is a :py:class:`~.Ring` then is might have an associated\n162     :py:class:`~.Field` and vice versa. The :py:meth:`~.Domain.get_field` and\n163     :py:meth:`~.Domain.get_ring` methods will find or create the associated\n164     domain.\n165 \n166     >>> from sympy import ZZ, QQ, Symbol\n167     >>> x = Symbol('x')\n168     >>> ZZ.has_assoc_Field\n169     True\n170     >>> ZZ.get_field()\n171     QQ\n172     >>> QQ.has_assoc_Ring\n173     True\n174     >>> QQ.get_ring()\n175     ZZ\n176     >>> K = QQ[x]\n177     >>> K\n178     QQ[x]\n179     >>> K.get_field()\n180     QQ(x)\n181 \n182     See also\n183     ========\n184 \n185     DomainElement: abstract base class for domain elements\n186     construct_domain: construct a minimal domain for some expressions\n187 \n188     \"\"\"\n189 \n190     dtype = None        # type: Optional[Type]\n191     \"\"\"The type (class) of the elements of this :py:class:`~.Domain`:\n192 \n193     >>> from sympy import ZZ, QQ, Symbol\n194     >>> ZZ.dtype\n195     <class 'int'>\n196     >>> z = ZZ(2)\n197     >>> z\n198     2\n199     >>> type(z)\n200     <class 'int'>\n201     >>> type(z) == ZZ.dtype\n202     True\n203 \n204     Every domain has an associated **dtype** (\"datatype\") which is the\n205     class of the associated domain elements.\n206 \n207     See also\n208     ========\n209 \n210     of_type\n211     \"\"\"\n212 \n213     zero = None         # type: Optional[Any]\n214     \"\"\"The zero element of the :py:class:`~.Domain`:\n215 \n216     >>> from sympy import QQ\n217     >>> QQ.zero\n218     0\n219     >>> QQ.of_type(QQ.zero)\n220     True\n221 \n222     See also\n223     ========\n224 \n225     of_type\n226     one\n227     \"\"\"\n228 \n229     one = None          # type: Optional[Any]\n230     \"\"\"The one element of the :py:class:`~.Domain`:\n231 \n232     >>> from sympy import QQ\n233     >>> QQ.one\n234     1\n235     >>> QQ.of_type(QQ.one)\n236     True\n237 \n238     See also\n239     ========\n240 \n241     of_type\n242     zero\n243     \"\"\"\n244 \n245     is_Ring = False\n246     \"\"\"Boolean flag indicating if the domain is a :py:class:`~.Ring`.\n247 \n248     >>> from sympy import ZZ\n249     >>> ZZ.is_Ring\n250     True\n251 \n252     Basically every :py:class:`~.Domain` represents a ring so this flag is\n253     not that useful.\n254 \n255     See also\n256     ========\n257 \n258     is_PID\n259     is_Field\n260     get_ring\n261     has_assoc_Ring\n262     \"\"\"\n263 \n264     is_Field = False\n265     \"\"\"Boolean flag indicating if the domain is a :py:class:`~.Field`.\n266 \n267     >>> from sympy import ZZ, QQ\n268     >>> ZZ.is_Field\n269     False\n270     >>> QQ.is_Field\n271     True\n272 \n273     See also\n274     ========\n275 \n276     is_PID\n277     is_Ring\n278     get_field\n279     has_assoc_Field\n280     \"\"\"\n281 \n282     has_assoc_Ring = False\n283     \"\"\"Boolean flag indicating if the domain has an associated\n284     :py:class:`~.Ring`.\n285 \n286     >>> from sympy import QQ\n287     >>> QQ.has_assoc_Ring\n288     True\n289     >>> QQ.get_ring()\n290     ZZ\n291 \n292     See also\n293     ========\n294 \n295     is_Field\n296     get_ring\n297     \"\"\"\n298 \n299     has_assoc_Field = False\n300     \"\"\"Boolean flag indicating if the domain has an associated\n301     :py:class:`~.Field`.\n302 \n303     >>> from sympy import ZZ\n304     >>> ZZ.has_assoc_Field\n305     True\n306     >>> ZZ.get_field()\n307     QQ\n308 \n309     See also\n310     ========\n311 \n312     is_Field\n313     get_field\n314     \"\"\"\n315 \n316     is_FiniteField = is_FF = False\n317     is_IntegerRing = is_ZZ = False\n318     is_RationalField = is_QQ = False\n319     is_GaussianRing = is_ZZ_I = False\n320     is_GaussianField = is_QQ_I = False\n321     is_RealField = is_RR = False\n322     is_ComplexField = is_CC = False\n323     is_AlgebraicField = is_Algebraic = False\n324     is_PolynomialRing = is_Poly = False\n325     is_FractionField = is_Frac = False\n326     is_SymbolicDomain = is_EX = False\n327     is_SymbolicRawDomain = is_EXRAW = False\n328     is_FiniteExtension = False\n329 \n330     is_Exact = True\n331     is_Numerical = False\n332 \n333     is_Simple = False\n334     is_Composite = False\n335 \n336     is_PID = False\n337     \"\"\"Boolean flag indicating if the domain is a `principal ideal domain`_.\n338 \n339     >>> from sympy import ZZ\n340     >>> ZZ.has_assoc_Field\n341     True\n342     >>> ZZ.get_field()\n343     QQ\n344 \n345     .. _principal ideal domain: https://en.wikipedia.org/wiki/Principal_ideal_domain\n346 \n347     See also\n348     ========\n349 \n350     is_Field\n351     get_field\n352     \"\"\"\n353 \n354     has_CharacteristicZero = False\n355 \n356     rep = None  # type: Optional[str]\n357     alias = None  # type: Optional[str]\n358 \n359     def __init__(self):\n360         raise NotImplementedError\n361 \n362     def __str__(self):\n363         return self.rep\n364 \n365     def __repr__(self):\n366         return str(self)\n367 \n368     def __hash__(self):\n369         return hash((self.__class__.__name__, self.dtype))\n370 \n371     def new(self, *args):\n372         return self.dtype(*args)\n373 \n374     @property\n375     def tp(self):\n376         \"\"\"Alias for :py:attr:`~.Domain.dtype`\"\"\"\n377         return self.dtype\n378 \n379     def __call__(self, *args):\n380         \"\"\"Construct an element of ``self`` domain from ``args``. \"\"\"\n381         return self.new(*args)\n382 \n383     def normal(self, *args):\n384         return self.dtype(*args)\n385 \n386     def convert_from(self, element, base):\n387         \"\"\"Convert ``element`` to ``self.dtype`` given the base domain. \"\"\"\n388         if base.alias is not None:\n389             method = \"from_\" + base.alias\n390         else:\n391             method = \"from_\" + base.__class__.__name__\n392 \n393         _convert = getattr(self, method)\n394 \n395         if _convert is not None:\n396             result = _convert(element, base)\n397 \n398             if result is not None:\n399                 return result\n400 \n401         raise CoercionFailed(\"Cannot convert %s of type %s from %s to %s\" % (element, type(element), base, self))\n402 \n403     def convert(self, element, base=None):\n404         \"\"\"Convert ``element`` to ``self.dtype``. \"\"\"\n405 \n406         if base is not None:\n407             if _not_a_coeff(element):\n408                 raise CoercionFailed('%s is not in any domain' % element)\n409             return self.convert_from(element, base)\n410 \n411         if self.of_type(element):\n412             return element\n413 \n414         if _not_a_coeff(element):\n415             raise CoercionFailed('%s is not in any domain' % element)\n416 \n417         from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n418 \n419         if ZZ.of_type(element):\n420             return self.convert_from(element, ZZ)\n421 \n422         if isinstance(element, int):\n423             return self.convert_from(ZZ(element), ZZ)\n424 \n425         if HAS_GMPY:\n426             integers = ZZ\n427             if isinstance(element, integers.tp):\n428                 return self.convert_from(element, integers)\n429 \n430             rationals = QQ\n431             if isinstance(element, rationals.tp):\n432                 return self.convert_from(element, rationals)\n433 \n434         if isinstance(element, float):\n435             parent = RealField(tol=False)\n436             return self.convert_from(parent(element), parent)\n437 \n438         if isinstance(element, complex):\n439             parent = ComplexField(tol=False)\n440             return self.convert_from(parent(element), parent)\n441 \n442         if isinstance(element, DomainElement):\n443             return self.convert_from(element, element.parent())\n444 \n445         # TODO: implement this in from_ methods\n446         if self.is_Numerical and getattr(element, 'is_ground', False):\n447             return self.convert(element.LC())\n448 \n449         if isinstance(element, Basic):\n450             try:\n451                 return self.from_sympy(element)\n452             except (TypeError, ValueError):\n453                 pass\n454         else: # TODO: remove this branch\n455             if not is_sequence(element):\n456                 try:\n457                     element = sympify(element, strict=True)\n458                     if isinstance(element, Basic):\n459                         return self.from_sympy(element)\n460                 except (TypeError, ValueError):\n461                     pass\n462 \n463         raise CoercionFailed(\"Cannot convert %s of type %s to %s\" % (element, type(element), self))\n464 \n465     def of_type(self, element):\n466         \"\"\"Check if ``a`` is of type ``dtype``. \"\"\"\n467         return isinstance(element, self.tp) # XXX: this isn't correct, e.g. PolyElement\n468 \n469     def __contains__(self, a):\n470         \"\"\"Check if ``a`` belongs to this domain. \"\"\"\n471         try:\n472             if _not_a_coeff(a):\n473                 raise CoercionFailed\n474             self.convert(a)  # this might raise, too\n475         except CoercionFailed:\n476             return False\n477 \n478         return True\n479 \n480     def to_sympy(self, a):\n481         \"\"\"Convert domain element *a* to a SymPy expression (Expr).\n482 \n483         Explanation\n484         ===========\n485 \n486         Convert a :py:class:`~.Domain` element *a* to :py:class:`~.Expr`. Most\n487         public SymPy functions work with objects of type :py:class:`~.Expr`.\n488         The elements of a :py:class:`~.Domain` have a different internal\n489         representation. It is not possible to mix domain elements with\n490         :py:class:`~.Expr` so each domain has :py:meth:`~.Domain.to_sympy` and\n491         :py:meth:`~.Domain.from_sympy` methods to convert its domain elements\n492         to and from :py:class:`~.Expr`.\n493 \n494         Parameters\n495         ==========\n496 \n497         a: domain element\n498             An element of this :py:class:`~.Domain`.\n499 \n500         Returns\n501         =======\n502 \n503         expr: Expr\n504             A normal SymPy expression of type :py:class:`~.Expr`.\n505 \n506         Examples\n507         ========\n508 \n509         Construct an element of the :ref:`QQ` domain and then convert it to\n510         :py:class:`~.Expr`.\n511 \n512         >>> from sympy import QQ, Expr\n513         >>> q_domain = QQ(2)\n514         >>> q_domain\n515         2\n516         >>> q_expr = QQ.to_sympy(q_domain)\n517         >>> q_expr\n518         2\n519 \n520         Although the printed forms look similar these objects are not of the\n521         same type.\n522 \n523         >>> isinstance(q_domain, Expr)\n524         False\n525         >>> isinstance(q_expr, Expr)\n526         True\n527 \n528         Construct an element of :ref:`K[x]` and convert to\n529         :py:class:`~.Expr`.\n530 \n531         >>> from sympy import Symbol\n532         >>> x = Symbol('x')\n533         >>> K = QQ[x]\n534         >>> x_domain = K.gens[0]  # generator x as a domain element\n535         >>> p_domain = x_domain**2/3 + 1\n536         >>> p_domain\n537         1/3*x**2 + 1\n538         >>> p_expr = K.to_sympy(p_domain)\n539         >>> p_expr\n540         x**2/3 + 1\n541 \n542         The :py:meth:`~.Domain.from_sympy` method is used for the opposite\n543         conversion from a normal SymPy expression to a domain element.\n544 \n545         >>> p_domain == p_expr\n546         False\n547         >>> K.from_sympy(p_expr) == p_domain\n548         True\n549         >>> K.to_sympy(p_domain) == p_expr\n550         True\n551         >>> K.from_sympy(K.to_sympy(p_domain)) == p_domain\n552         True\n553         >>> K.to_sympy(K.from_sympy(p_expr)) == p_expr\n554         True\n555 \n556         The :py:meth:`~.Domain.from_sympy` method makes it easier to construct\n557         domain elements interactively.\n558 \n559         >>> from sympy import Symbol\n560         >>> x = Symbol('x')\n561         >>> K = QQ[x]\n562         >>> K.from_sympy(x**2/3 + 1)\n563         1/3*x**2 + 1\n564 \n565         See also\n566         ========\n567 \n568         from_sympy\n569         convert_from\n570         \"\"\"\n571         raise NotImplementedError\n572 \n573     def from_sympy(self, a):\n574         \"\"\"Convert a SymPy expression to an element of this domain.\n575 \n576         Explanation\n577         ===========\n578 \n579         See :py:meth:`~.Domain.to_sympy` for explanation and examples.\n580 \n581         Parameters\n582         ==========\n583 \n584         expr: Expr\n585             A normal SymPy expression of type :py:class:`~.Expr`.\n586 \n587         Returns\n588         =======\n589 \n590         a: domain element\n591             An element of this :py:class:`~.Domain`.\n592 \n593         See also\n594         ========\n595 \n596         to_sympy\n597         convert_from\n598         \"\"\"\n599         raise NotImplementedError\n600 \n601     def sum(self, args):\n602         return sum(args)\n603 \n604     def from_FF(K1, a, K0):\n605         \"\"\"Convert ``ModularInteger(int)`` to ``dtype``. \"\"\"\n606         return None\n607 \n608     def from_FF_python(K1, a, K0):\n609         \"\"\"Convert ``ModularInteger(int)`` to ``dtype``. \"\"\"\n610         return None\n611 \n612     def from_ZZ_python(K1, a, K0):\n613         \"\"\"Convert a Python ``int`` object to ``dtype``. \"\"\"\n614         return None\n615 \n616     def from_QQ_python(K1, a, K0):\n617         \"\"\"Convert a Python ``Fraction`` object to ``dtype``. \"\"\"\n618         return None\n619 \n620     def from_FF_gmpy(K1, a, K0):\n621         \"\"\"Convert ``ModularInteger(mpz)`` to ``dtype``. \"\"\"\n622         return None\n623 \n624     def from_ZZ_gmpy(K1, a, K0):\n625         \"\"\"Convert a GMPY ``mpz`` object to ``dtype``. \"\"\"\n626         return None\n627 \n628     def from_QQ_gmpy(K1, a, K0):\n629         \"\"\"Convert a GMPY ``mpq`` object to ``dtype``. \"\"\"\n630         return None\n631 \n632     def from_RealField(K1, a, K0):\n633         \"\"\"Convert a real element object to ``dtype``. \"\"\"\n634         return None\n635 \n636     def from_ComplexField(K1, a, K0):\n637         \"\"\"Convert a complex element to ``dtype``. \"\"\"\n638         return None\n639 \n640     def from_AlgebraicField(K1, a, K0):\n641         \"\"\"Convert an algebraic number to ``dtype``. \"\"\"\n642         return None\n643 \n644     def from_PolynomialRing(K1, a, K0):\n645         \"\"\"Convert a polynomial to ``dtype``. \"\"\"\n646         if a.is_ground:\n647             return K1.convert(a.LC, K0.dom)\n648 \n649     def from_FractionField(K1, a, K0):\n650         \"\"\"Convert a rational function to ``dtype``. \"\"\"\n651         return None\n652 \n653     def from_MonogenicFiniteExtension(K1, a, K0):\n654         \"\"\"Convert an ``ExtensionElement`` to ``dtype``. \"\"\"\n655         return K1.convert_from(a.rep, K0.ring)\n656 \n657     def from_ExpressionDomain(K1, a, K0):\n658         \"\"\"Convert a ``EX`` object to ``dtype``. \"\"\"\n659         return K1.from_sympy(a.ex)\n660 \n661     def from_ExpressionRawDomain(K1, a, K0):\n662         \"\"\"Convert a ``EX`` object to ``dtype``. \"\"\"\n663         return K1.from_sympy(a)\n664 \n665     def from_GlobalPolynomialRing(K1, a, K0):\n666         \"\"\"Convert a polynomial to ``dtype``. \"\"\"\n667         if a.degree() <= 0:\n668             return K1.convert(a.LC(), K0.dom)\n669 \n670     def from_GeneralizedPolynomialRing(K1, a, K0):\n671         return K1.from_FractionField(a, K0)\n672 \n673     def unify_with_symbols(K0, K1, symbols):\n674         if (K0.is_Composite and (set(K0.symbols) & set(symbols))) or (K1.is_Composite and (set(K1.symbols) & set(symbols))):\n675             raise UnificationFailed(\"Cannot unify %s with %s, given %s generators\" % (K0, K1, tuple(symbols)))\n676 \n677         return K0.unify(K1)\n678 \n679     def unify(K0, K1, symbols=None):\n680         \"\"\"\n681         Construct a minimal domain that contains elements of ``K0`` and ``K1``.\n682 \n683         Known domains (from smallest to largest):\n684 \n685         - ``GF(p)``\n686         - ``ZZ``\n687         - ``QQ``\n688         - ``RR(prec, tol)``\n689         - ``CC(prec, tol)``\n690         - ``ALG(a, b, c)``\n691         - ``K[x, y, z]``\n692         - ``K(x, y, z)``\n693         - ``EX``\n694 \n695         \"\"\"\n696         if symbols is not None:\n697             return K0.unify_with_symbols(K1, symbols)\n698 \n699         if K0 == K1:\n700             return K0\n701 \n702         if K0.is_EXRAW:\n703             return K0\n704         if K1.is_EXRAW:\n705             return K1\n706 \n707         if K0.is_EX:\n708             return K0\n709         if K1.is_EX:\n710             return K1\n711 \n712         if K0.is_FiniteExtension or K1.is_FiniteExtension:\n713             if K1.is_FiniteExtension:\n714                 K0, K1 = K1, K0\n715             if K1.is_FiniteExtension:\n716                 # Unifying two extensions.\n717                 # Try to ensure that K0.unify(K1) == K1.unify(K0)\n718                 if list(ordered([K0.modulus, K1.modulus]))[1] == K0.modulus:\n719                     K0, K1 = K1, K0\n720                 return K1.set_domain(K0)\n721             else:\n722                 # Drop the generator from other and unify with the base domain\n723                 K1 = K1.drop(K0.symbol)\n724                 K1 = K0.domain.unify(K1)\n725                 return K0.set_domain(K1)\n726 \n727         if K0.is_Composite or K1.is_Composite:\n728             K0_ground = K0.dom if K0.is_Composite else K0\n729             K1_ground = K1.dom if K1.is_Composite else K1\n730 \n731             K0_symbols = K0.symbols if K0.is_Composite else ()\n732             K1_symbols = K1.symbols if K1.is_Composite else ()\n733 \n734             domain = K0_ground.unify(K1_ground)\n735             symbols = _unify_gens(K0_symbols, K1_symbols)\n736             order = K0.order if K0.is_Composite else K1.order\n737 \n738             if ((K0.is_FractionField and K1.is_PolynomialRing or\n739                  K1.is_FractionField and K0.is_PolynomialRing) and\n740                  (not K0_ground.is_Field or not K1_ground.is_Field) and domain.is_Field\n741                  and domain.has_assoc_Ring):\n742                 domain = domain.get_ring()\n743 \n744             if K0.is_Composite and (not K1.is_Composite or K0.is_FractionField or K1.is_PolynomialRing):\n745                 cls = K0.__class__\n746             else:\n747                 cls = K1.__class__\n748 \n749             from sympy.polys.domains.old_polynomialring import GlobalPolynomialRing\n750             if cls == GlobalPolynomialRing:\n751                 return cls(domain, symbols)\n752 \n753             return cls(domain, symbols, order)\n754 \n755         def mkinexact(cls, K0, K1):\n756             prec = max(K0.precision, K1.precision)\n757             tol = max(K0.tolerance, K1.tolerance)\n758             return cls(prec=prec, tol=tol)\n759 \n760         if K1.is_ComplexField:\n761             K0, K1 = K1, K0\n762         if K0.is_ComplexField:\n763             if K1.is_ComplexField or K1.is_RealField:\n764                 return mkinexact(K0.__class__, K0, K1)\n765             else:\n766                 return K0\n767 \n768         if K1.is_RealField:\n769             K0, K1 = K1, K0\n770         if K0.is_RealField:\n771             if K1.is_RealField:\n772                 return mkinexact(K0.__class__, K0, K1)\n773             elif K1.is_GaussianRing or K1.is_GaussianField:\n774                 from sympy.polys.domains.complexfield import ComplexField\n775                 return ComplexField(prec=K0.precision, tol=K0.tolerance)\n776             else:\n777                 return K0\n778 \n779         if K1.is_AlgebraicField:\n780             K0, K1 = K1, K0\n781         if K0.is_AlgebraicField:\n782             if K1.is_GaussianRing:\n783                 K1 = K1.get_field()\n784             if K1.is_GaussianField:\n785                 K1 = K1.as_AlgebraicField()\n786             if K1.is_AlgebraicField:\n787                 return K0.__class__(K0.dom.unify(K1.dom), *_unify_gens(K0.orig_ext, K1.orig_ext))\n788             else:\n789                 return K0\n790 \n791         if K0.is_GaussianField:\n792             return K0\n793         if K1.is_GaussianField:\n794             return K1\n795 \n796         if K0.is_GaussianRing:\n797             if K1.is_RationalField:\n798                 K0 = K0.get_field()\n799             return K0\n800         if K1.is_GaussianRing:\n801             if K0.is_RationalField:\n802                 K1 = K1.get_field()\n803             return K1\n804 \n805         if K0.is_RationalField:\n806             return K0\n807         if K1.is_RationalField:\n808             return K1\n809 \n810         if K0.is_IntegerRing:\n811             return K0\n812         if K1.is_IntegerRing:\n813             return K1\n814 \n815         if K0.is_FiniteField and K1.is_FiniteField:\n816             return K0.__class__(max(K0.mod, K1.mod, key=default_sort_key))\n817 \n818         from sympy.polys.domains import EX\n819         return EX\n820 \n821     def __eq__(self, other):\n822         \"\"\"Returns ``True`` if two domains are equivalent. \"\"\"\n823         return isinstance(other, Domain) and self.dtype == other.dtype\n824 \n825     def __ne__(self, other):\n826         \"\"\"Returns ``False`` if two domains are equivalent. \"\"\"\n827         return not self == other\n828 \n829     def map(self, seq):\n830         \"\"\"Rersively apply ``self`` to all elements of ``seq``. \"\"\"\n831         result = []\n832 \n833         for elt in seq:\n834             if isinstance(elt, list):\n835                 result.append(self.map(elt))\n836             else:\n837                 result.append(self(elt))\n838 \n839         return result\n840 \n841     def get_ring(self):\n842         \"\"\"Returns a ring associated with ``self``. \"\"\"\n843         raise DomainError('there is no ring associated with %s' % self)\n844 \n845     def get_field(self):\n846         \"\"\"Returns a field associated with ``self``. \"\"\"\n847         raise DomainError('there is no field associated with %s' % self)\n848 \n849     def get_exact(self):\n850         \"\"\"Returns an exact domain associated with ``self``. \"\"\"\n851         return self\n852 \n853     def __getitem__(self, symbols):\n854         \"\"\"The mathematical way to make a polynomial ring. \"\"\"\n855         if hasattr(symbols, '__iter__'):\n856             return self.poly_ring(*symbols)\n857         else:\n858             return self.poly_ring(symbols)\n859 \n860     def poly_ring(self, *symbols, order=lex):\n861         \"\"\"Returns a polynomial ring, i.e. `K[X]`. \"\"\"\n862         from sympy.polys.domains.polynomialring import PolynomialRing\n863         return PolynomialRing(self, symbols, order)\n864 \n865     def frac_field(self, *symbols, order=lex):\n866         \"\"\"Returns a fraction field, i.e. `K(X)`. \"\"\"\n867         from sympy.polys.domains.fractionfield import FractionField\n868         return FractionField(self, symbols, order)\n869 \n870     def old_poly_ring(self, *symbols, **kwargs):\n871         \"\"\"Returns a polynomial ring, i.e. `K[X]`. \"\"\"\n872         from sympy.polys.domains.old_polynomialring import PolynomialRing\n873         return PolynomialRing(self, *symbols, **kwargs)\n874 \n875     def old_frac_field(self, *symbols, **kwargs):\n876         \"\"\"Returns a fraction field, i.e. `K(X)`. \"\"\"\n877         from sympy.polys.domains.old_fractionfield import FractionField\n878         return FractionField(self, *symbols, **kwargs)\n879 \n880     def algebraic_field(self, *extension):\n881         r\"\"\"Returns an algebraic field, i.e. `K(\\alpha, \\ldots)`. \"\"\"\n882         raise DomainError(\"Cannot create algebraic field over %s\" % self)\n883 \n884     def alg_field_from_poly(self, poly, alias=None, root_index=-1):\n885         r\"\"\"\n886         Convenience method to construct an algebraic extension on a root of a\n887         polynomial, chosen by root index.\n888 \n889         Parameters\n890         ==========\n891 \n892         poly : :py:class:`~.Poly`\n893             The polynomial whose root generates the extension.\n894         alias : str, optional (default=None)\n895             Symbol name for the generator of the extension.\n896             E.g. \"alpha\" or \"theta\".\n897         root_index : int, optional (default=-1)\n898             Specifies which root of the polynomial is desired. The ordering is\n899             as defined by the :py:class:`~.ComplexRootOf` class. The default of\n900             ``-1`` selects the most natural choice in the common cases of\n901             quadratic and cyclotomic fields (the square root on the positive\n902             real or imaginary axis, resp. $\\mathrm{e}^{2\\pi i/n}$).\n903 \n904         Examples\n905         ========\n906 \n907         >>> from sympy import QQ, Poly\n908         >>> from sympy.abc import x\n909         >>> f = Poly(x**2 - 2)\n910         >>> K = QQ.alg_field_from_poly(f)\n911         >>> K.ext.minpoly == f\n912         True\n913         >>> g = Poly(8*x**3 - 6*x - 1)\n914         >>> L = QQ.alg_field_from_poly(g, \"alpha\")\n915         >>> L.ext.minpoly == g\n916         True\n917         >>> L.to_sympy(L([1, 1, 1]))\n918         alpha**2 + alpha + 1\n919 \n920         \"\"\"\n921         from sympy.polys.rootoftools import CRootOf\n922         root = CRootOf(poly, root_index)\n923         alpha = AlgebraicNumber(root, alias=alias)\n924         return self.algebraic_field(alpha)\n925 \n926     def cyclotomic_field(self, n, ss=False, alias=\"zeta\", gen=None, root_index=-1):\n927         r\"\"\"\n928         Convenience method to construct a cyclotomic field.\n929 \n930         Parameters\n931         ==========\n932 \n933         n : int\n934             Construct the nth cyclotomic field.\n935         ss : boolean, optional (default=False)\n936             If True, append *n* as a subscript on the alias string.\n937         alias : str, optional (default=\"zeta\")\n938             Symbol name for the generator.\n939         gen : :py:class:`~.Symbol`, optional (default=None)\n940             Desired variable for the cyclotomic polynomial that defines the\n941             field. If ``None``, a dummy variable will be used.\n942         root_index : int, optional (default=-1)\n943             Specifies which root of the polynomial is desired. The ordering is\n944             as defined by the :py:class:`~.ComplexRootOf` class. The default of\n945             ``-1`` selects the root $\\mathrm{e}^{2\\pi i/n}$.\n946 \n947         Examples\n948         ========\n949 \n950         >>> from sympy import QQ, latex\n951         >>> K = QQ.cyclotomic_field(5)\n952         >>> K.to_sympy(K([-1, 1]))\n953         1 - zeta\n954         >>> L = QQ.cyclotomic_field(7, True)\n955         >>> a = L.to_sympy(L([-1, 1]))\n956         >>> print(a)\n957         1 - zeta7\n958         >>> print(latex(a))\n959         1 - \\zeta_{7}\n960 \n961         \"\"\"\n962         from sympy.polys.specialpolys import cyclotomic_poly\n963         if ss:\n964             alias += str(n)\n965         return self.alg_field_from_poly(cyclotomic_poly(n, gen), alias=alias,\n966                                         root_index=root_index)\n967 \n968     def inject(self, *symbols):\n969         \"\"\"Inject generators into this domain. \"\"\"\n970         raise NotImplementedError\n971 \n972     def drop(self, *symbols):\n973         \"\"\"Drop generators from this domain. \"\"\"\n974         if self.is_Simple:\n975             return self\n976         raise NotImplementedError  # pragma: no cover\n977 \n978     def is_zero(self, a):\n979         \"\"\"Returns True if ``a`` is zero. \"\"\"\n980         return not a\n981 \n982     def is_one(self, a):\n983         \"\"\"Returns True if ``a`` is one. \"\"\"\n984         return a == self.one\n985 \n986     def is_positive(self, a):\n987         \"\"\"Returns True if ``a`` is positive. \"\"\"\n988         return a > 0\n989 \n990     def is_negative(self, a):\n991         \"\"\"Returns True if ``a`` is negative. \"\"\"\n992         return a < 0\n993 \n994     def is_nonpositive(self, a):\n995         \"\"\"Returns True if ``a`` is non-positive. \"\"\"\n996         return a <= 0\n997 \n998     def is_nonnegative(self, a):\n999         \"\"\"Returns True if ``a`` is non-negative. \"\"\"\n1000         return a >= 0\n1001 \n1002     def canonical_unit(self, a):\n1003         if self.is_negative(a):\n1004             return -self.one\n1005         else:\n1006             return self.one\n1007 \n1008     def abs(self, a):\n1009         \"\"\"Absolute value of ``a``, implies ``__abs__``. \"\"\"\n1010         return abs(a)\n1011 \n1012     def neg(self, a):\n1013         \"\"\"Returns ``a`` negated, implies ``__neg__``. \"\"\"\n1014         return -a\n1015 \n1016     def pos(self, a):\n1017         \"\"\"Returns ``a`` positive, implies ``__pos__``. \"\"\"\n1018         return +a\n1019 \n1020     def add(self, a, b):\n1021         \"\"\"Sum of ``a`` and ``b``, implies ``__add__``.  \"\"\"\n1022         return a + b\n1023 \n1024     def sub(self, a, b):\n1025         \"\"\"Difference of ``a`` and ``b``, implies ``__sub__``.  \"\"\"\n1026         return a - b\n1027 \n1028     def mul(self, a, b):\n1029         \"\"\"Product of ``a`` and ``b``, implies ``__mul__``.  \"\"\"\n1030         return a * b\n1031 \n1032     def pow(self, a, b):\n1033         \"\"\"Raise ``a`` to power ``b``, implies ``__pow__``.  \"\"\"\n1034         return a ** b\n1035 \n1036     def exquo(self, a, b):\n1037         \"\"\"Exact quotient of *a* and *b*. Analogue of ``a / b``.\n1038 \n1039         Explanation\n1040         ===========\n1041 \n1042         This is essentially the same as ``a / b`` except that an error will be\n1043         raised if the division is inexact (if there is any remainder) and the\n1044         result will always be a domain element. When working in a\n1045         :py:class:`~.Domain` that is not a :py:class:`~.Field` (e.g. :ref:`ZZ`\n1046         or :ref:`K[x]`) ``exquo`` should be used instead of ``/``.\n1047 \n1048         The key invariant is that if ``q = K.exquo(a, b)`` (and ``exquo`` does\n1049         not raise an exception) then ``a == b*q``.\n1050 \n1051         Examples\n1052         ========\n1053 \n1054         We can use ``K.exquo`` instead of ``/`` for exact division.\n1055 \n1056         >>> from sympy import ZZ\n1057         >>> ZZ.exquo(ZZ(4), ZZ(2))\n1058         2\n1059         >>> ZZ.exquo(ZZ(5), ZZ(2))\n1060         Traceback (most recent call last):\n1061             ...\n1062         ExactQuotientFailed: 2 does not divide 5 in ZZ\n1063 \n1064         Over a :py:class:`~.Field` such as :ref:`QQ`, division (with nonzero\n1065         divisor) is always exact so in that case ``/`` can be used instead of\n1066         :py:meth:`~.Domain.exquo`.\n1067 \n1068         >>> from sympy import QQ\n1069         >>> QQ.exquo(QQ(5), QQ(2))\n1070         5/2\n1071         >>> QQ(5) / QQ(2)\n1072         5/2\n1073 \n1074         Parameters\n1075         ==========\n1076 \n1077         a: domain element\n1078             The dividend\n1079         b: domain element\n1080             The divisor\n1081 \n1082         Returns\n1083         =======\n1084 \n1085         q: domain element\n1086             The exact quotient\n1087 \n1088         Raises\n1089         ======\n1090 \n1091         ExactQuotientFailed: if exact division is not possible.\n1092         ZeroDivisionError: when the divisor is zero.\n1093 \n1094         See also\n1095         ========\n1096 \n1097         quo: Analogue of ``a // b``\n1098         rem: Analogue of ``a % b``\n1099         div: Analogue of ``divmod(a, b)``\n1100 \n1101         Notes\n1102         =====\n1103 \n1104         Since the default :py:attr:`~.Domain.dtype` for :ref:`ZZ` is ``int``\n1105         (or ``mpz``) division as ``a / b`` should not be used as it would give\n1106         a ``float``.\n1107 \n1108         >>> ZZ(4) / ZZ(2)\n1109         2.0\n1110         >>> ZZ(5) / ZZ(2)\n1111         2.5\n1112 \n1113         Using ``/`` with :ref:`ZZ` will lead to incorrect results so\n1114         :py:meth:`~.Domain.exquo` should be used instead.\n1115 \n1116         \"\"\"\n1117         raise NotImplementedError\n1118 \n1119     def quo(self, a, b):\n1120         \"\"\"Quotient of *a* and *b*. Analogue of ``a // b``.\n1121 \n1122         ``K.quo(a, b)`` is equivalent to ``K.div(a, b)[0]``. See\n1123         :py:meth:`~.Domain.div` for more explanation.\n1124 \n1125         See also\n1126         ========\n1127 \n1128         rem: Analogue of ``a % b``\n1129         div: Analogue of ``divmod(a, b)``\n1130         exquo: Analogue of ``a / b``\n1131         \"\"\"\n1132         raise NotImplementedError\n1133 \n1134     def rem(self, a, b):\n1135         \"\"\"Modulo division of *a* and *b*. Analogue of ``a % b``.\n1136 \n1137         ``K.rem(a, b)`` is equivalent to ``K.div(a, b)[1]``. See\n1138         :py:meth:`~.Domain.div` for more explanation.\n1139 \n1140         See also\n1141         ========\n1142 \n1143         quo: Analogue of ``a // b``\n1144         div: Analogue of ``divmod(a, b)``\n1145         exquo: Analogue of ``a / b``\n1146         \"\"\"\n1147         raise NotImplementedError\n1148 \n1149     def div(self, a, b):\n1150         \"\"\"Quotient and remainder for *a* and *b*. Analogue of ``divmod(a, b)``\n1151 \n1152         Explanation\n1153         ===========\n1154 \n1155         This is essentially the same as ``divmod(a, b)`` except that is more\n1156         consistent when working over some :py:class:`~.Field` domains such as\n1157         :ref:`QQ`. When working over an arbitrary :py:class:`~.Domain` the\n1158         :py:meth:`~.Domain.div` method should be used instead of ``divmod``.\n1159 \n1160         The key invariant is that if ``q, r = K.div(a, b)`` then\n1161         ``a == b*q + r``.\n1162 \n1163         The result of ``K.div(a, b)`` is the same as the tuple\n1164         ``(K.quo(a, b), K.rem(a, b))`` except that if both quotient and\n1165         remainder are needed then it is more efficient to use\n1166         :py:meth:`~.Domain.div`.\n1167 \n1168         Examples\n1169         ========\n1170 \n1171         We can use ``K.div`` instead of ``divmod`` for floor division and\n1172         remainder.\n1173 \n1174         >>> from sympy import ZZ, QQ\n1175         >>> ZZ.div(ZZ(5), ZZ(2))\n1176         (2, 1)\n1177 \n1178         If ``K`` is a :py:class:`~.Field` then the division is always exact\n1179         with a remainder of :py:attr:`~.Domain.zero`.\n1180 \n1181         >>> QQ.div(QQ(5), QQ(2))\n1182         (5/2, 0)\n1183 \n1184         Parameters\n1185         ==========\n1186 \n1187         a: domain element\n1188             The dividend\n1189         b: domain element\n1190             The divisor\n1191 \n1192         Returns\n1193         =======\n1194 \n1195         (q, r): tuple of domain elements\n1196             The quotient and remainder\n1197 \n1198         Raises\n1199         ======\n1200 \n1201         ZeroDivisionError: when the divisor is zero.\n1202 \n1203         See also\n1204         ========\n1205 \n1206         quo: Analogue of ``a // b``\n1207         rem: Analogue of ``a % b``\n1208         exquo: Analogue of ``a / b``\n1209 \n1210         Notes\n1211         =====\n1212 \n1213         If ``gmpy`` is installed then the ``gmpy.mpq`` type will be used as\n1214         the :py:attr:`~.Domain.dtype` for :ref:`QQ`. The ``gmpy.mpq`` type\n1215         defines ``divmod`` in a way that is undesirable so\n1216         :py:meth:`~.Domain.div` should be used instead of ``divmod``.\n1217 \n1218         >>> a = QQ(1)\n1219         >>> b = QQ(3, 2)\n1220         >>> a               # doctest: +SKIP\n1221         mpq(1,1)\n1222         >>> b               # doctest: +SKIP\n1223         mpq(3,2)\n1224         >>> divmod(a, b)    # doctest: +SKIP\n1225         (mpz(0), mpq(1,1))\n1226         >>> QQ.div(a, b)    # doctest: +SKIP\n1227         (mpq(2,3), mpq(0,1))\n1228 \n1229         Using ``//`` or ``%`` with :ref:`QQ` will lead to incorrect results so\n1230         :py:meth:`~.Domain.div` should be used instead.\n1231 \n1232         \"\"\"\n1233         raise NotImplementedError\n1234 \n1235     def invert(self, a, b):\n1236         \"\"\"Returns inversion of ``a mod b``, implies something. \"\"\"\n1237         raise NotImplementedError\n1238 \n1239     def revert(self, a):\n1240         \"\"\"Returns ``a**(-1)`` if possible. \"\"\"\n1241         raise NotImplementedError\n1242 \n1243     def numer(self, a):\n1244         \"\"\"Returns numerator of ``a``. \"\"\"\n1245         raise NotImplementedError\n1246 \n1247     def denom(self, a):\n1248         \"\"\"Returns denominator of ``a``. \"\"\"\n1249         raise NotImplementedError\n1250 \n1251     def half_gcdex(self, a, b):\n1252         \"\"\"Half extended GCD of ``a`` and ``b``. \"\"\"\n1253         s, t, h = self.gcdex(a, b)\n1254         return s, h\n1255 \n1256     def gcdex(self, a, b):\n1257         \"\"\"Extended GCD of ``a`` and ``b``. \"\"\"\n1258         raise NotImplementedError\n1259 \n1260     def cofactors(self, a, b):\n1261         \"\"\"Returns GCD and cofactors of ``a`` and ``b``. \"\"\"\n1262         gcd = self.gcd(a, b)\n1263         cfa = self.quo(a, gcd)\n1264         cfb = self.quo(b, gcd)\n1265         return gcd, cfa, cfb\n1266 \n1267     def gcd(self, a, b):\n1268         \"\"\"Returns GCD of ``a`` and ``b``. \"\"\"\n1269         raise NotImplementedError\n1270 \n1271     def lcm(self, a, b):\n1272         \"\"\"Returns LCM of ``a`` and ``b``. \"\"\"\n1273         raise NotImplementedError\n1274 \n1275     def log(self, a, b):\n1276         \"\"\"Returns b-base logarithm of ``a``. \"\"\"\n1277         raise NotImplementedError\n1278 \n1279     def sqrt(self, a):\n1280         \"\"\"Returns square root of ``a``. \"\"\"\n1281         raise NotImplementedError\n1282 \n1283     def evalf(self, a, prec=None, **options):\n1284         \"\"\"Returns numerical approximation of ``a``. \"\"\"\n1285         return self.to_sympy(a).evalf(prec, **options)\n1286 \n1287     n = evalf\n1288 \n1289     def real(self, a):\n1290         return a\n1291 \n1292     def imag(self, a):\n1293         return self.zero\n1294 \n1295     def almosteq(self, a, b, tolerance=None):\n1296         \"\"\"Check if ``a`` and ``b`` are almost equal. \"\"\"\n1297         return a == b\n1298 \n1299     def characteristic(self):\n1300         \"\"\"Return the characteristic of this domain. \"\"\"\n1301         raise NotImplementedError('characteristic()')\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]