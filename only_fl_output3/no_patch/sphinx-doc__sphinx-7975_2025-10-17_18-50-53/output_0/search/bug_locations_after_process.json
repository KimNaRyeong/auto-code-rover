[
    {
        "rel_file_path": "sphinx/theming.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/theming.py",
        "start": 1,
        "end": 250,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.theming\n3     ~~~~~~~~~~~~~~\n4 \n5     Theming support for HTML builders.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import configparser\n12 import os\n13 import shutil\n14 import tempfile\n15 from os import path\n16 from typing import Any, Dict, List\n17 from zipfile import ZipFile\n18 \n19 import pkg_resources\n20 \n21 from sphinx import package_dir\n22 from sphinx.errors import ThemeError\n23 from sphinx.locale import __\n24 from sphinx.util import logging\n25 from sphinx.util.osutil import ensuredir\n26 \n27 if False:\n28     # For type annotation\n29     from sphinx.application import Sphinx\n30 \n31 \n32 logger = logging.getLogger(__name__)\n33 \n34 NODEFAULT = object()\n35 THEMECONF = 'theme.conf'\n36 \n37 \n38 def extract_zip(filename: str, targetdir: str) -> None:\n39     \"\"\"Extract zip file to target directory.\"\"\"\n40     ensuredir(targetdir)\n41 \n42     with ZipFile(filename) as archive:\n43         for name in archive.namelist():\n44             if name.endswith('/'):\n45                 continue\n46             entry = path.join(targetdir, name)\n47             ensuredir(path.dirname(entry))\n48             with open(path.join(entry), 'wb') as fp:\n49                 fp.write(archive.read(name))\n50 \n51 \n52 class Theme:\n53     \"\"\"A Theme is a set of HTML templates and configurations.\n54 \n55     This class supports both theme directory and theme archive (zipped theme).\"\"\"\n56 \n57     def __init__(self, name: str, theme_path: str, factory: \"HTMLThemeFactory\") -> None:\n58         self.name = name\n59         self.base = None\n60         self.rootdir = None\n61 \n62         if path.isdir(theme_path):\n63             # already a directory, do nothing\n64             self.rootdir = None\n65             self.themedir = theme_path\n66         else:\n67             # extract the theme to a temp directory\n68             self.rootdir = tempfile.mkdtemp('sxt')\n69             self.themedir = path.join(self.rootdir, name)\n70             extract_zip(theme_path, self.themedir)\n71 \n72         self.config = configparser.RawConfigParser()\n73         self.config.read(path.join(self.themedir, THEMECONF))\n74 \n75         try:\n76             inherit = self.config.get('theme', 'inherit')\n77         except configparser.NoSectionError as exc:\n78             raise ThemeError(__('theme %r doesn\\'t have \"theme\" setting') % name) from exc\n79         except configparser.NoOptionError as exc:\n80             raise ThemeError(__('theme %r doesn\\'t have \"inherit\" setting') % name) from exc\n81 \n82         if inherit != 'none':\n83             try:\n84                 self.base = factory.create(inherit)\n85             except ThemeError as exc:\n86                 raise ThemeError(__('no theme named %r found, inherited by %r') %\n87                                  (inherit, name)) from exc\n88 \n89     def get_theme_dirs(self) -> List[str]:\n90         \"\"\"Return a list of theme directories, beginning with this theme's,\n91         then the base theme's, then that one's base theme's, etc.\n92         \"\"\"\n93         if self.base is None:\n94             return [self.themedir]\n95         else:\n96             return [self.themedir] + self.base.get_theme_dirs()\n97 \n98     def get_config(self, section: str, name: str, default: Any = NODEFAULT) -> Any:\n99         \"\"\"Return the value for a theme configuration setting, searching the\n100         base theme chain.\n101         \"\"\"\n102         try:\n103             return self.config.get(section, name)\n104         except (configparser.NoOptionError, configparser.NoSectionError) as exc:\n105             if self.base:\n106                 return self.base.get_config(section, name, default)\n107 \n108             if default is NODEFAULT:\n109                 raise ThemeError(__('setting %s.%s occurs in none of the '\n110                                     'searched theme configs') % (section, name)) from exc\n111             else:\n112                 return default\n113 \n114     def get_options(self, overrides: Dict[str, Any] = {}) -> Dict[str, Any]:\n115         \"\"\"Return a dictionary of theme options and their values.\"\"\"\n116         if self.base:\n117             options = self.base.get_options()\n118         else:\n119             options = {}\n120 \n121         try:\n122             options.update(self.config.items('options'))\n123         except configparser.NoSectionError:\n124             pass\n125 \n126         for option, value in overrides.items():\n127             if option not in options:\n128                 logger.warning(__('unsupported theme option %r given') % option)\n129             else:\n130                 options[option] = value\n131 \n132         return options\n133 \n134     def cleanup(self) -> None:\n135         \"\"\"Remove temporary directories.\"\"\"\n136         if self.rootdir:\n137             try:\n138                 shutil.rmtree(self.rootdir)\n139             except Exception:\n140                 pass\n141         if self.base:\n142             self.base.cleanup()\n143 \n144 \n145 def is_archived_theme(filename: str) -> bool:\n146     \"\"\"Check the specified file is an archived theme file or not.\"\"\"\n147     try:\n148         with ZipFile(filename) as f:\n149             return THEMECONF in f.namelist()\n150     except Exception:\n151         return False\n152 \n153 \n154 class HTMLThemeFactory:\n155     \"\"\"A factory class for HTML Themes.\"\"\"\n156 \n157     def __init__(self, app: \"Sphinx\") -> None:\n158         self.app = app\n159         self.themes = app.html_themes\n160         self.load_builtin_themes()\n161         if getattr(app.config, 'html_theme_path', None):\n162             self.load_additional_themes(app.config.html_theme_path)\n163 \n164     def load_builtin_themes(self) -> None:\n165         \"\"\"Load built-in themes.\"\"\"\n166         themes = self.find_themes(path.join(package_dir, 'themes'))\n167         for name, theme in themes.items():\n168             self.themes[name] = theme\n169 \n170     def load_additional_themes(self, theme_paths: str) -> None:\n171         \"\"\"Load additional themes placed at specified directories.\"\"\"\n172         for theme_path in theme_paths:\n173             abs_theme_path = path.abspath(path.join(self.app.confdir, theme_path))\n174             themes = self.find_themes(abs_theme_path)\n175             for name, theme in themes.items():\n176                 self.themes[name] = theme\n177 \n178     def load_extra_theme(self, name: str) -> None:\n179         \"\"\"Try to load a theme having specifed name.\"\"\"\n180         if name == 'alabaster':\n181             self.load_alabaster_theme()\n182         elif name == 'sphinx_rtd_theme':\n183             self.load_sphinx_rtd_theme()\n184         else:\n185             self.load_external_theme(name)\n186 \n187     def load_alabaster_theme(self) -> None:\n188         \"\"\"Load alabaster theme.\"\"\"\n189         import alabaster\n190         self.themes['alabaster'] = path.join(alabaster.get_path(), 'alabaster')\n191 \n192     def load_sphinx_rtd_theme(self) -> None:\n193         \"\"\"Load sphinx_rtd_theme theme (if exists).\"\"\"\n194         try:\n195             import sphinx_rtd_theme\n196             theme_path = sphinx_rtd_theme.get_html_theme_path()\n197             self.themes['sphinx_rtd_theme'] = path.join(theme_path, 'sphinx_rtd_theme')\n198         except ImportError:\n199             pass\n200 \n201     def load_external_theme(self, name: str) -> None:\n202         \"\"\"Try to load a theme using entry_points.\n203 \n204         Sphinx refers to ``sphinx_themes`` entry_points.\n205         \"\"\"\n206         # look up for new styled entry_points at first\n207         entry_points = pkg_resources.iter_entry_points('sphinx.html_themes', name)\n208         try:\n209             entry_point = next(entry_points)\n210             self.app.registry.load_extension(self.app, entry_point.module_name)\n211             return\n212         except StopIteration:\n213             pass\n214 \n215     def find_themes(self, theme_path: str) -> Dict[str, str]:\n216         \"\"\"Search themes from specified directory.\"\"\"\n217         themes = {}  # type: Dict[str, str]\n218         if not path.isdir(theme_path):\n219             return themes\n220 \n221         for entry in os.listdir(theme_path):\n222             pathname = path.join(theme_path, entry)\n223             if path.isfile(pathname) and entry.lower().endswith('.zip'):\n224                 if is_archived_theme(pathname):\n225                     name = entry[:-4]\n226                     themes[name] = pathname\n227                 else:\n228                     logger.warning(__('file %r on theme path is not a valid '\n229                                       'zipfile or contains no theme'), entry)\n230             else:\n231                 if path.isfile(path.join(pathname, THEMECONF)):\n232                     themes[entry] = pathname\n233 \n234         return themes\n235 \n236     def create(self, name: str) -> Theme:\n237         \"\"\"Create an instance of theme.\"\"\"\n238         if name not in self.themes:\n239             self.load_extra_theme(name)\n240 \n241         if name not in self.themes:\n242             if name == 'sphinx_rtd_theme':\n243                 raise ThemeError(__('sphinx_rtd_theme is no longer a hard dependency '\n244                                     'since version 1.4.0. Please install it manually.'\n245                                     '(pip install sphinx_rtd_theme)'))\n246             else:\n247                 raise ThemeError(__('no theme named %r found '\n248                                     '(missing theme.conf?)') % name)\n249 \n250         return Theme(name, self.themes[name], factory=self)\n",
        "intended_behavior": "This file should ensure that the theming logic correctly groups all symbol-leading index entries under a single 'Symbols' section. If the logic for identifying or categorizing symbols is spread out or inconsistently applied, it should be unified or corrected to consistently recognize symbol-led entries as such, irrespective of the specific symbols used. This correction will ensure all symbol-leading entries are sorted into one 'Symbols' section, addressing the current splitting issue."
    }
]