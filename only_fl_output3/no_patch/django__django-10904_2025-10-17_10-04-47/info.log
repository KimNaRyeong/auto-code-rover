2025-10-17 10:04:47.785 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 10:04:50.643 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=344, output_tokens=12, cost=0.003800
2025-10-17 10:04:50.644 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 10:04:50.648 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:04:58.133 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=653, output_tokens=262, cost=0.014390
2025-10-17 10:04:58.140 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:05:02.533 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=616, output_tokens=80, cost=0.008560
2025-10-17 10:05:02.534 | DEBUG    | Extracted a valid json.
2025-10-17 10:05:02.534 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"IOError\")",
        "search_code(\"EnvironmentError\")",
        "search_code(\"WindowsError\")",
        "search_code(\"mmap.error\")",
        "search_code(\"socket.error\")",
        "search_code(\"select.error\")",
        "search_code(\"SMTPException\")"
    ],
    "bug_locations": []
}
2025-10-17 10:05:02.667 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 10:05:02.667 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 10:05:19.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1946, output_tokens=815, cost=0.043910
2025-10-17 10:05:19.250 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 10:05:29.876 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2977, output_tokens=427, cost=0.042580
2025-10-17 10:05:29.884 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 10:05:41.212 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=781, output_tokens=424, cost=0.020530
2025-10-17 10:05:41.213 | DEBUG    | Extracted a valid json.
2025-10-17 10:05:41.213 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/contrib/gis/geos/libgeos.py",
            "class": "",
            "method": "",
            "intended_behavior": "Replace `EnvironmentError` with `OSError` in the exception catch. The intended behavior remains to handle exceptions during the configuration of GEOS library paths, ensuring the application can manage and report configuration or file access issues without change."
        },
        {
            "file": "django/contrib/gis/gdal/libgdal.py",
            "class": "",
            "method": "",
            "intended_behavior": "Replace `EnvironmentError` with `OSError` when attempting to load GDAL library paths from settings. It aims to maintain the functionality of catching errors related to the GDAL library configuration, improving the code's consistency with modern Python standards."
        },
        {
            "file": "django/core/mail/backends/smtp.py",
            "class": "EmailBackend",
            "method": "open",
            "intended_behavior": "Simplify the except block to catch `OSError` instead of `(smtplib.SMTPException, socket.error)`. This preserves the error handling for SMTP connection issues, with the added benefit of a cleaner, more Pythonic approach aligning with newer Python versions."
        },
        {
            "file": "django/core/mail/backends/smtp.py",
            "class": "EmailBackend",
            "method": "close",
            "intended_behavior": "Catch `OSError` in place of `smtplib.SMTPException`. Keeps the defensive programming against SMTP disconnection issues intact while simplifying the codebase."
        },
        {
            "file": "django/core/mail/backends/smtp.py",
            "class": "EmailBackend",
            "method": "_send",
            "intended_behavior": "Update to catch `OSError` for a broader range of errors during email sending operations. Maintains the fail-silently logic upon SMTP communication failures."
        }
    ]
}
2025-10-17 10:05:41.226 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/gis/geos/libgeos.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2  This module houses the ctypes initialization procedures, as well
3  as the notice and error handler function callbacks (get called
4  when an error occurs in GEOS).
5 
6  This module also houses GEOS Pointer utilities, including
7  get_pointer_arr(), and GEOM_PTR.
8 """
9 import logging
10 import os
11 from ctypes import CDLL, CFUNCTYPE, POINTER, Structure, c_char_p
12 from ctypes.util import find_library
13 
14 from django.core.exceptions import ImproperlyConfigured
15 from django.utils.functional import SimpleLazyObject, cached_property
16 from django.utils.version import get_version_tuple
17 
18 logger = logging.getLogger('django.contrib.gis')
19 
20 
21 def load_geos():
22     # Custom library path set?
23     try:
24         from django.conf import settings
25         lib_path = settings.GEOS_LIBRARY_PATH
26     except (AttributeError, EnvironmentError,
27             ImportError, ImproperlyConfigured):
28         lib_path = None
29 
30     # Setting the appropriate names for the GEOS-C library.
31     if lib_path:
32         lib_names = None
33     elif os.name == 'nt':
34         # Windows NT libraries
35         lib_names = ['geos_c', 'libgeos_c-1']
36     elif os.name == 'posix':
37         # *NIX libraries
38         lib_names = ['geos_c', 'GEOS']
39     else:
40         raise ImportError('Unsupported OS "%s"' % os.name)
41 
42     # Using the ctypes `find_library` utility to find the path to the GEOS
43     # shared library.  This is better than manually specifying each library name
44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).
45     if lib_names:
46         for lib_name in lib_names:
47             lib_path = find_library(lib_name)
48             if lib_path is not None:
49                 break
50 
51     # No GEOS library could be found.
52     if lib_path is None:
53         raise ImportError(
54             'Could not find the GEOS library (tried "%s"). '
55             'Try setting GEOS_LIBRARY_PATH in your settings.' %
56             '", "'.join(lib_names)
57         )
58     # Getting the GEOS C library.  The C interface (CDLL) is used for
59     # both *NIX and Windows.
60     # See the GEOS C API source code for more details on the library function calls:
61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html
62     _lgeos = CDLL(lib_path)
63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r
64     # routines.  These functions aren't actually called until they are
65     # attached to a GEOS context handle -- this actually occurs in
66     # geos/prototypes/threadsafe.py.
67     _lgeos.initGEOS_r.restype = CONTEXT_PTR
68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]
69     # Set restype for compatibility across 32 and 64-bit platforms.
70     _lgeos.GEOSversion.restype = c_char_p
71     return _lgeos
72 
73 
74 # The notice and error handler C function callback definitions.
75 # Supposed to mimic the GEOS message handler (C below):
76 #  typedef void (*GEOSMessageHandler)(const char *fmt, ...);
77 NOTICEFUNC = CFUNCTYPE(None, c_char_p, c_char_p)
78 
79 
80 def notice_h(fmt, lst):
81     fmt, lst = fmt.decode(), lst.decode()
82     try:
83         warn_msg = fmt % lst
84     except TypeError:
85         warn_msg = fmt
86     logger.warning('GEOS_NOTICE: %s\n', warn_msg)
87 
88 
89 notice_h = NOTICEFUNC(notice_h)
90 
91 ERRORFUNC = CFUNCTYPE(None, c_char_p, c_char_p)
92 
93 
94 def error_h(fmt, lst):
95     fmt, lst = fmt.decode(), lst.decode()
96     try:
97         err_msg = fmt % lst
98     except TypeError:
99         err_msg = fmt
100     logger.error('GEOS_ERROR: %s\n', err_msg)
101 
102 
103 error_h = ERRORFUNC(error_h)
104 
105 # #### GEOS Geometry C data structures, and utility functions. ####
106 
107 
108 # Opaque GEOS geometry structures, used for GEOM_PTR and CS_PTR
109 class GEOSGeom_t(Structure):
110     pass
111 
112 
113 class GEOSPrepGeom_t(Structure):
114     pass
115 
116 
117 class GEOSCoordSeq_t(Structure):
118     pass
119 
120 
121 class GEOSContextHandle_t(Structure):
122     pass
123 
124 
125 # Pointers to opaque GEOS geometry structures.
126 GEOM_PTR = POINTER(GEOSGeom_t)
127 PREPGEOM_PTR = POINTER(GEOSPrepGeom_t)
128 CS_PTR = POINTER(GEOSCoordSeq_t)
129 CONTEXT_PTR = POINTER(GEOSContextHandle_t)
130 
131 
132 lgeos = SimpleLazyObject(load_geos)
133 
134 
135 class GEOSFuncFactory:
136     """
137     Lazy loading of GEOS functions.
138     """
139     argtypes = None
140     restype = None
141     errcheck = None
142 
143     def __init__(self, func_name, *args, restype=None, errcheck=None, argtypes=None, **kwargs):
144         self.func_name = func_name
145         if restype is not None:
146             self.restype = restype
147         if errcheck is not None:
148             self.errcheck = errcheck
149         if argtypes is not None:
150             self.argtypes = argtypes
151         self.args = args
152         self.kwargs = kwargs
153 
154     def __call__(self, *args, **kwargs):
155         return self.func(*args, **kwargs)
156 
157     @cached_property
158     def func(self):
159         from django.contrib.gis.geos.prototypes.threadsafe import GEOSFunc
160         func = GEOSFunc(self.func_name)
161         func.argtypes = self.argtypes or []
162         func.restype = self.restype
163         if self.errcheck:
164             func.errcheck = self.errcheck
165         return func
166 
167 
168 def geos_version():
169     """Return the string version of the GEOS library."""
170     return lgeos.GEOSversion()
171 
172 
173 def geos_version_tuple():
174     """Return the GEOS version as a tuple (major, minor, subminor)."""
175     return get_version_tuple(geos_version().decode())

</code><intended_behavior>Replace `EnvironmentError` with `OSError` in the exception catch. The intended behavior remains to handle exceptions during the configuration of GEOS library paths, ensuring the application can manage and report configuration or file access issues without change.</intended_behavior>, <file>django/contrib/gis/gdal/libgdal.py</file>
<class>None</class>
<method>None</method>
<code>
1 import logging
2 import os
3 import re
4 from ctypes import CDLL, CFUNCTYPE, c_char_p, c_int
5 from ctypes.util import find_library
6 
7 from django.contrib.gis.gdal.error import GDALException
8 from django.core.exceptions import ImproperlyConfigured
9 
10 logger = logging.getLogger('django.contrib.gis')
11 
12 # Custom library path set?
13 try:
14     from django.conf import settings
15     lib_path = settings.GDAL_LIBRARY_PATH
16 except (AttributeError, EnvironmentError,
17         ImportError, ImproperlyConfigured):
18     lib_path = None
19 
20 if lib_path:
21     lib_names = None
22 elif os.name == 'nt':
23     # Windows NT shared libraries
24     lib_names = ['gdal203', 'gdal202', 'gdal201', 'gdal20', 'gdal111']
25 elif os.name == 'posix':
26     # *NIX library names.
27     lib_names = ['gdal', 'GDAL', 'gdal2.3.0', 'gdal2.2.0', 'gdal2.1.0', 'gdal2.0.0', 'gdal1.11.0']
28 else:
29     raise ImproperlyConfigured('GDAL is unsupported on OS "%s".' % os.name)
30 
31 # Using the ctypes `find_library` utility  to find the
32 # path to the GDAL library from the list of library names.
33 if lib_names:
34     for lib_name in lib_names:
35         lib_path = find_library(lib_name)
36         if lib_path is not None:
37             break
38 
39 if lib_path is None:
40     raise ImproperlyConfigured(
41         'Could not find the GDAL library (tried "%s"). Is GDAL installed? '
42         'If it is, try setting GDAL_LIBRARY_PATH in your settings.'
43         % '", "'.join(lib_names)
44     )
45 
46 # This loads the GDAL/OGR C library
47 lgdal = CDLL(lib_path)
48 
49 # On Windows, the GDAL binaries have some OSR routines exported with
50 # STDCALL, while others are not.  Thus, the library will also need to
51 # be loaded up as WinDLL for said OSR functions that require the
52 # different calling convention.
53 if os.name == 'nt':
54     from ctypes import WinDLL
55     lwingdal = WinDLL(lib_path)
56 
57 
58 def std_call(func):
59     """
60     Return the correct STDCALL function for certain OSR routines on Win32
61     platforms.
62     """
63     if os.name == 'nt':
64         return lwingdal[func]
65     else:
66         return lgdal[func]
67 
68 
69 # #### Version-information functions. ####
70 
71 # Return GDAL library version information with the given key.
72 _version_info = std_call('GDALVersionInfo')
73 _version_info.argtypes = [c_char_p]
74 _version_info.restype = c_char_p
75 
76 
77 def gdal_version():
78     "Return only the GDAL version number information."
79     return _version_info(b'RELEASE_NAME')
80 
81 
82 def gdal_full_version():
83     "Return the full GDAL version information."
84     return _version_info('')
85 
86 
87 version_regex = re.compile(r'^(?P<major>\d+)\.(?P<minor>\d+)(\.(?P<subminor>\d+))?')
88 
89 
90 def gdal_version_info():
91     ver = gdal_version().decode()
92     m = version_regex.match(ver)
93     if not m:
94         raise GDALException('Could not parse GDAL version string "%s"' % ver)
95     return {key: m.group(key) for key in ('major', 'minor', 'subminor')}
96 
97 
98 _verinfo = gdal_version_info()
99 GDAL_MAJOR_VERSION = int(_verinfo['major'])
100 GDAL_MINOR_VERSION = int(_verinfo['minor'])
101 GDAL_SUBMINOR_VERSION = _verinfo['subminor'] and int(_verinfo['subminor'])
102 GDAL_VERSION = (GDAL_MAJOR_VERSION, GDAL_MINOR_VERSION, GDAL_SUBMINOR_VERSION)
103 del _verinfo
104 
105 # Set library error handling so as errors are logged
106 CPLErrorHandler = CFUNCTYPE(None, c_int, c_int, c_char_p)
107 
108 
109 def err_handler(error_class, error_number, message):
110     logger.error('GDAL_ERROR %d: %s', error_number, message)
111 
112 
113 err_handler = CPLErrorHandler(err_handler)
114 
115 
116 def function(name, args, restype):
117     func = std_call(name)
118     func.argtypes = args
119     func.restype = restype
120     return func
121 
122 
123 set_error_handler = function('CPLSetErrorHandler', [CPLErrorHandler], CPLErrorHandler)
124 set_error_handler(err_handler)

</code><intended_behavior>Replace `EnvironmentError` with `OSError` when attempting to load GDAL library paths from settings. It aims to maintain the functionality of catching errors related to the GDAL library configuration, improving the code's consistency with modern Python standards.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise

</code><intended_behavior>Simplify the except block to catch `OSError` instead of `(smtplib.SMTPException, socket.error)`. This preserves the error handling for SMTP connection issues, with the added benefit of a cleaner, more Pythonic approach aligning with newer Python versions.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False

</code><intended_behavior>Simplify the except block to catch `OSError` instead of `(smtplib.SMTPException, socket.error)`. This preserves the error handling for SMTP connection issues, with the added benefit of a cleaner, more Pythonic approach aligning with newer Python versions.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(ConsoleEmailBackend):
14     def __init__(self, *args, file_path=None, **kwargs):
15         self._fname = None
16         if file_path is not None:
17             self.file_path = file_path
18         else:
19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)
20         # Make sure self.file_path is a string.
21         if not isinstance(self.file_path, str):
22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)
23         self.file_path = os.path.abspath(self.file_path)
24         # Make sure that self.file_path is a directory if it exists.
25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):
26             raise ImproperlyConfigured(
27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path
28             )
29         # Try to create it, if it not exists.
30         elif not os.path.exists(self.file_path):
31             try:
32                 os.makedirs(self.file_path)
33             except OSError as err:
34                 raise ImproperlyConfigured(
35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)
36                 )
37         # Make sure that self.file_path is writable.
38         if not os.access(self.file_path, os.W_OK):
39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)
40         # Finally, call super().
41         # Since we're using the console-based backend as a base,
42         # force the stream to be None, so we don't default to stdout
43         kwargs['stream'] = None
44         super().__init__(*args, **kwargs)
45 
46     def write_message(self, message):
47         self.stream.write(message.message().as_bytes() + b'\n')
48         self.stream.write(b'-' * 79)
49         self.stream.write(b'\n')
50 
51     def _get_filename(self):
52         """Return a unique file name."""
53         if self._fname is None:
54             timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
55             fname = "%s-%s.log" % (timestamp, abs(id(self)))
56             self._fname = os.path.join(self.file_path, fname)
57         return self._fname
58 
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False
64 
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>close</method>
<code>
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None

</code><intended_behavior>Catch `OSError` in place of `smtplib.SMTPException`. Keeps the defensive programming against SMTP disconnection issues intact while simplifying the codebase.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>close</method>
<code>
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>Catch `OSError` in place of `smtplib.SMTPException`. Keeps the defensive programming against SMTP disconnection issues intact while simplifying the codebase.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(ConsoleEmailBackend):
14     def __init__(self, *args, file_path=None, **kwargs):
15         self._fname = None
16         if file_path is not None:
17             self.file_path = file_path
18         else:
19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)
20         # Make sure self.file_path is a string.
21         if not isinstance(self.file_path, str):
22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)
23         self.file_path = os.path.abspath(self.file_path)
24         # Make sure that self.file_path is a directory if it exists.
25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):
26             raise ImproperlyConfigured(
27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path
28             )
29         # Try to create it, if it not exists.
30         elif not os.path.exists(self.file_path):
31             try:
32                 os.makedirs(self.file_path)
33             except OSError as err:
34                 raise ImproperlyConfigured(
35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)
36                 )
37         # Make sure that self.file_path is writable.
38         if not os.access(self.file_path, os.W_OK):
39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)
40         # Finally, call super().
41         # Since we're using the console-based backend as a base,
42         # force the stream to be None, so we don't default to stdout
43         kwargs['stream'] = None
44         super().__init__(*args, **kwargs)
45 
46     def write_message(self, message):
47         self.stream.write(message.message().as_bytes() + b'\n')
48         self.stream.write(b'-' * 79)
49         self.stream.write(b'\n')
50 
51     def _get_filename(self):
52         """Return a unique file name."""
53         if self._fname is None:
54             timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
55             fname = "%s-%s.log" % (timestamp, abs(id(self)))
56             self._fname = os.path.join(self.file_path, fname)
57         return self._fname
58 
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False
64 
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>_send</method>
<code>
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>Update to catch `OSError` for a broader range of errors during email sending operations. Maintains the fail-silently logic upon SMTP communication failures.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 10:05:41.227 | INFO     | Search completed. Bug locations: [<file>django/contrib/gis/geos/libgeos.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2  This module houses the ctypes initialization procedures, as well
3  as the notice and error handler function callbacks (get called
4  when an error occurs in GEOS).
5 
6  This module also houses GEOS Pointer utilities, including
7  get_pointer_arr(), and GEOM_PTR.
8 """
9 import logging
10 import os
11 from ctypes import CDLL, CFUNCTYPE, POINTER, Structure, c_char_p
12 from ctypes.util import find_library
13 
14 from django.core.exceptions import ImproperlyConfigured
15 from django.utils.functional import SimpleLazyObject, cached_property
16 from django.utils.version import get_version_tuple
17 
18 logger = logging.getLogger('django.contrib.gis')
19 
20 
21 def load_geos():
22     # Custom library path set?
23     try:
24         from django.conf import settings
25         lib_path = settings.GEOS_LIBRARY_PATH
26     except (AttributeError, EnvironmentError,
27             ImportError, ImproperlyConfigured):
28         lib_path = None
29 
30     # Setting the appropriate names for the GEOS-C library.
31     if lib_path:
32         lib_names = None
33     elif os.name == 'nt':
34         # Windows NT libraries
35         lib_names = ['geos_c', 'libgeos_c-1']
36     elif os.name == 'posix':
37         # *NIX libraries
38         lib_names = ['geos_c', 'GEOS']
39     else:
40         raise ImportError('Unsupported OS "%s"' % os.name)
41 
42     # Using the ctypes `find_library` utility to find the path to the GEOS
43     # shared library.  This is better than manually specifying each library name
44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).
45     if lib_names:
46         for lib_name in lib_names:
47             lib_path = find_library(lib_name)
48             if lib_path is not None:
49                 break
50 
51     # No GEOS library could be found.
52     if lib_path is None:
53         raise ImportError(
54             'Could not find the GEOS library (tried "%s"). '
55             'Try setting GEOS_LIBRARY_PATH in your settings.' %
56             '", "'.join(lib_names)
57         )
58     # Getting the GEOS C library.  The C interface (CDLL) is used for
59     # both *NIX and Windows.
60     # See the GEOS C API source code for more details on the library function calls:
61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html
62     _lgeos = CDLL(lib_path)
63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r
64     # routines.  These functions aren't actually called until they are
65     # attached to a GEOS context handle -- this actually occurs in
66     # geos/prototypes/threadsafe.py.
67     _lgeos.initGEOS_r.restype = CONTEXT_PTR
68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]
69     # Set restype for compatibility across 32 and 64-bit platforms.
70     _lgeos.GEOSversion.restype = c_char_p
71     return _lgeos
72 
73 
74 # The notice and error handler C function callback definitions.
75 # Supposed to mimic the GEOS message handler (C below):
76 #  typedef void (*GEOSMessageHandler)(const char *fmt, ...);
77 NOTICEFUNC = CFUNCTYPE(None, c_char_p, c_char_p)
78 
79 
80 def notice_h(fmt, lst):
81     fmt, lst = fmt.decode(), lst.decode()
82     try:
83         warn_msg = fmt % lst
84     except TypeError:
85         warn_msg = fmt
86     logger.warning('GEOS_NOTICE: %s\n', warn_msg)
87 
88 
89 notice_h = NOTICEFUNC(notice_h)
90 
91 ERRORFUNC = CFUNCTYPE(None, c_char_p, c_char_p)
92 
93 
94 def error_h(fmt, lst):
95     fmt, lst = fmt.decode(), lst.decode()
96     try:
97         err_msg = fmt % lst
98     except TypeError:
99         err_msg = fmt
100     logger.error('GEOS_ERROR: %s\n', err_msg)
101 
102 
103 error_h = ERRORFUNC(error_h)
104 
105 # #### GEOS Geometry C data structures, and utility functions. ####
106 
107 
108 # Opaque GEOS geometry structures, used for GEOM_PTR and CS_PTR
109 class GEOSGeom_t(Structure):
110     pass
111 
112 
113 class GEOSPrepGeom_t(Structure):
114     pass
115 
116 
117 class GEOSCoordSeq_t(Structure):
118     pass
119 
120 
121 class GEOSContextHandle_t(Structure):
122     pass
123 
124 
125 # Pointers to opaque GEOS geometry structures.
126 GEOM_PTR = POINTER(GEOSGeom_t)
127 PREPGEOM_PTR = POINTER(GEOSPrepGeom_t)
128 CS_PTR = POINTER(GEOSCoordSeq_t)
129 CONTEXT_PTR = POINTER(GEOSContextHandle_t)
130 
131 
132 lgeos = SimpleLazyObject(load_geos)
133 
134 
135 class GEOSFuncFactory:
136     """
137     Lazy loading of GEOS functions.
138     """
139     argtypes = None
140     restype = None
141     errcheck = None
142 
143     def __init__(self, func_name, *args, restype=None, errcheck=None, argtypes=None, **kwargs):
144         self.func_name = func_name
145         if restype is not None:
146             self.restype = restype
147         if errcheck is not None:
148             self.errcheck = errcheck
149         if argtypes is not None:
150             self.argtypes = argtypes
151         self.args = args
152         self.kwargs = kwargs
153 
154     def __call__(self, *args, **kwargs):
155         return self.func(*args, **kwargs)
156 
157     @cached_property
158     def func(self):
159         from django.contrib.gis.geos.prototypes.threadsafe import GEOSFunc
160         func = GEOSFunc(self.func_name)
161         func.argtypes = self.argtypes or []
162         func.restype = self.restype
163         if self.errcheck:
164             func.errcheck = self.errcheck
165         return func
166 
167 
168 def geos_version():
169     """Return the string version of the GEOS library."""
170     return lgeos.GEOSversion()
171 
172 
173 def geos_version_tuple():
174     """Return the GEOS version as a tuple (major, minor, subminor)."""
175     return get_version_tuple(geos_version().decode())

</code><intended_behavior>Replace `EnvironmentError` with `OSError` in the exception catch. The intended behavior remains to handle exceptions during the configuration of GEOS library paths, ensuring the application can manage and report configuration or file access issues without change.</intended_behavior>, <file>django/contrib/gis/gdal/libgdal.py</file>
<class>None</class>
<method>None</method>
<code>
1 import logging
2 import os
3 import re
4 from ctypes import CDLL, CFUNCTYPE, c_char_p, c_int
5 from ctypes.util import find_library
6 
7 from django.contrib.gis.gdal.error import GDALException
8 from django.core.exceptions import ImproperlyConfigured
9 
10 logger = logging.getLogger('django.contrib.gis')
11 
12 # Custom library path set?
13 try:
14     from django.conf import settings
15     lib_path = settings.GDAL_LIBRARY_PATH
16 except (AttributeError, EnvironmentError,
17         ImportError, ImproperlyConfigured):
18     lib_path = None
19 
20 if lib_path:
21     lib_names = None
22 elif os.name == 'nt':
23     # Windows NT shared libraries
24     lib_names = ['gdal203', 'gdal202', 'gdal201', 'gdal20', 'gdal111']
25 elif os.name == 'posix':
26     # *NIX library names.
27     lib_names = ['gdal', 'GDAL', 'gdal2.3.0', 'gdal2.2.0', 'gdal2.1.0', 'gdal2.0.0', 'gdal1.11.0']
28 else:
29     raise ImproperlyConfigured('GDAL is unsupported on OS "%s".' % os.name)
30 
31 # Using the ctypes `find_library` utility  to find the
32 # path to the GDAL library from the list of library names.
33 if lib_names:
34     for lib_name in lib_names:
35         lib_path = find_library(lib_name)
36         if lib_path is not None:
37             break
38 
39 if lib_path is None:
40     raise ImproperlyConfigured(
41         'Could not find the GDAL library (tried "%s"). Is GDAL installed? '
42         'If it is, try setting GDAL_LIBRARY_PATH in your settings.'
43         % '", "'.join(lib_names)
44     )
45 
46 # This loads the GDAL/OGR C library
47 lgdal = CDLL(lib_path)
48 
49 # On Windows, the GDAL binaries have some OSR routines exported with
50 # STDCALL, while others are not.  Thus, the library will also need to
51 # be loaded up as WinDLL for said OSR functions that require the
52 # different calling convention.
53 if os.name == 'nt':
54     from ctypes import WinDLL
55     lwingdal = WinDLL(lib_path)
56 
57 
58 def std_call(func):
59     """
60     Return the correct STDCALL function for certain OSR routines on Win32
61     platforms.
62     """
63     if os.name == 'nt':
64         return lwingdal[func]
65     else:
66         return lgdal[func]
67 
68 
69 # #### Version-information functions. ####
70 
71 # Return GDAL library version information with the given key.
72 _version_info = std_call('GDALVersionInfo')
73 _version_info.argtypes = [c_char_p]
74 _version_info.restype = c_char_p
75 
76 
77 def gdal_version():
78     "Return only the GDAL version number information."
79     return _version_info(b'RELEASE_NAME')
80 
81 
82 def gdal_full_version():
83     "Return the full GDAL version information."
84     return _version_info('')
85 
86 
87 version_regex = re.compile(r'^(?P<major>\d+)\.(?P<minor>\d+)(\.(?P<subminor>\d+))?')
88 
89 
90 def gdal_version_info():
91     ver = gdal_version().decode()
92     m = version_regex.match(ver)
93     if not m:
94         raise GDALException('Could not parse GDAL version string "%s"' % ver)
95     return {key: m.group(key) for key in ('major', 'minor', 'subminor')}
96 
97 
98 _verinfo = gdal_version_info()
99 GDAL_MAJOR_VERSION = int(_verinfo['major'])
100 GDAL_MINOR_VERSION = int(_verinfo['minor'])
101 GDAL_SUBMINOR_VERSION = _verinfo['subminor'] and int(_verinfo['subminor'])
102 GDAL_VERSION = (GDAL_MAJOR_VERSION, GDAL_MINOR_VERSION, GDAL_SUBMINOR_VERSION)
103 del _verinfo
104 
105 # Set library error handling so as errors are logged
106 CPLErrorHandler = CFUNCTYPE(None, c_int, c_int, c_char_p)
107 
108 
109 def err_handler(error_class, error_number, message):
110     logger.error('GDAL_ERROR %d: %s', error_number, message)
111 
112 
113 err_handler = CPLErrorHandler(err_handler)
114 
115 
116 def function(name, args, restype):
117     func = std_call(name)
118     func.argtypes = args
119     func.restype = restype
120     return func
121 
122 
123 set_error_handler = function('CPLSetErrorHandler', [CPLErrorHandler], CPLErrorHandler)
124 set_error_handler(err_handler)

</code><intended_behavior>Replace `EnvironmentError` with `OSError` when attempting to load GDAL library paths from settings. It aims to maintain the functionality of catching errors related to the GDAL library configuration, improving the code's consistency with modern Python standards.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise

</code><intended_behavior>Simplify the except block to catch `OSError` instead of `(smtplib.SMTPException, socket.error)`. This preserves the error handling for SMTP connection issues, with the added benefit of a cleaner, more Pythonic approach aligning with newer Python versions.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>open</method>
<code>
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False

</code><intended_behavior>Simplify the except block to catch `OSError` instead of `(smtplib.SMTPException, socket.error)`. This preserves the error handling for SMTP connection issues, with the added benefit of a cleaner, more Pythonic approach aligning with newer Python versions.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(ConsoleEmailBackend):
14     def __init__(self, *args, file_path=None, **kwargs):
15         self._fname = None
16         if file_path is not None:
17             self.file_path = file_path
18         else:
19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)
20         # Make sure self.file_path is a string.
21         if not isinstance(self.file_path, str):
22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)
23         self.file_path = os.path.abspath(self.file_path)
24         # Make sure that self.file_path is a directory if it exists.
25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):
26             raise ImproperlyConfigured(
27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path
28             )
29         # Try to create it, if it not exists.
30         elif not os.path.exists(self.file_path):
31             try:
32                 os.makedirs(self.file_path)
33             except OSError as err:
34                 raise ImproperlyConfigured(
35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)
36                 )
37         # Make sure that self.file_path is writable.
38         if not os.access(self.file_path, os.W_OK):
39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)
40         # Finally, call super().
41         # Since we're using the console-based backend as a base,
42         # force the stream to be None, so we don't default to stdout
43         kwargs['stream'] = None
44         super().__init__(*args, **kwargs)
45 
46     def write_message(self, message):
47         self.stream.write(message.message().as_bytes() + b'\n')
48         self.stream.write(b'-' * 79)
49         self.stream.write(b'\n')
50 
51     def _get_filename(self):
52         """Return a unique file name."""
53         if self._fname is None:
54             timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
55             fname = "%s-%s.log" % (timestamp, abs(id(self)))
56             self._fname = os.path.join(self.file_path, fname)
57         return self._fname
58 
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False
64 
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>close</method>
<code>
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None

</code><intended_behavior>Catch `OSError` in place of `smtplib.SMTPException`. Keeps the defensive programming against SMTP disconnection issues intact while simplifying the codebase.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>close</method>
<code>
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>Catch `OSError` in place of `smtplib.SMTPException`. Keeps the defensive programming against SMTP disconnection issues intact while simplifying the codebase.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/filebased.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(ConsoleEmailBackend):
14     def __init__(self, *args, file_path=None, **kwargs):
15         self._fname = None
16         if file_path is not None:
17             self.file_path = file_path
18         else:
19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)
20         # Make sure self.file_path is a string.
21         if not isinstance(self.file_path, str):
22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)
23         self.file_path = os.path.abspath(self.file_path)
24         # Make sure that self.file_path is a directory if it exists.
25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):
26             raise ImproperlyConfigured(
27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path
28             )
29         # Try to create it, if it not exists.
30         elif not os.path.exists(self.file_path):
31             try:
32                 os.makedirs(self.file_path)
33             except OSError as err:
34                 raise ImproperlyConfigured(
35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)
36                 )
37         # Make sure that self.file_path is writable.
38         if not os.access(self.file_path, os.W_OK):
39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)
40         # Finally, call super().
41         # Since we're using the console-based backend as a base,
42         # force the stream to be None, so we don't default to stdout
43         kwargs['stream'] = None
44         super().__init__(*args, **kwargs)
45 
46     def write_message(self, message):
47         self.stream.write(message.message().as_bytes() + b'\n')
48         self.stream.write(b'-' * 79)
49         self.stream.write(b'\n')
50 
51     def _get_filename(self):
52         """Return a unique file name."""
53         if self._fname is None:
54             timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
55             fname = "%s-%s.log" % (timestamp, abs(id(self)))
56             self._fname = os.path.join(self.file_path, fname)
57         return self._fname
58 
59     def open(self):
60         if self.stream is None:
61             self.stream = open(self._get_filename(), 'ab')
62             return True
63         return False
64 
65     def close(self):
66         try:
67             if self.stream is not None:
68                 self.stream.close()
69         finally:
70             self.stream = None

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>_send</method>
<code>
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>Update to catch `OSError` for a broader range of errors during email sending operations. Maintains the fail-silently logic upon SMTP communication failures.</intended_behavior>, <file>django/core/mail/backends/smtp.py</file>
<class>EmailBackend</class>
<method>None</method>
<code>
13 class EmailBackend(BaseEmailBackend):
14     """
15     A wrapper that manages the SMTP network connection.
16     """
17     def __init__(self, host=None, port=None, username=None, password=None,
18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,
19                  ssl_keyfile=None, ssl_certfile=None,
20                  **kwargs):
21         super().__init__(fail_silently=fail_silently)
22         self.host = host or settings.EMAIL_HOST
23         self.port = port or settings.EMAIL_PORT
24         self.username = settings.EMAIL_HOST_USER if username is None else username
25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password
26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls
27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl
28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout
29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile
30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile
31         if self.use_ssl and self.use_tls:
32             raise ValueError(
33                 "EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set "
34                 "one of those settings to True.")
35         self.connection = None
36         self._lock = threading.RLock()
37 
38     @property
39     def connection_class(self):
40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP
41 
42     def open(self):
43         """
44         Ensure an open connection to the email server. Return whether or not a
45         new connection was required (True or False) or None if an exception
46         passed silently.
47         """
48         if self.connection:
49             # Nothing to do if the connection is already open.
50             return False
51 
52         # If local_hostname is not specified, socket.getfqdn() gets used.
53         # For performance, we use the cached FQDN for local_hostname.
54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}
55         if self.timeout is not None:
56             connection_params['timeout'] = self.timeout
57         if self.use_ssl:
58             connection_params.update({
59                 'keyfile': self.ssl_keyfile,
60                 'certfile': self.ssl_certfile,
61             })
62         try:
63             self.connection = self.connection_class(self.host, self.port, **connection_params)
64 
65             # TLS/SSL are mutually exclusive, so only attempt TLS over
66             # non-secure connections.
67             if not self.use_ssl and self.use_tls:
68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)
69             if self.username and self.password:
70                 self.connection.login(self.username, self.password)
71             return True
72         except (smtplib.SMTPException, socket.error):
73             if not self.fail_silently:
74                 raise
75 
76     def close(self):
77         """Close the connection to the email server."""
78         if self.connection is None:
79             return
80         try:
81             try:
82                 self.connection.quit()
83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):
84                 # This happens when calling quit() on a TLS connection
85                 # sometimes, or when the connection was already disconnected
86                 # by the server.
87                 self.connection.close()
88             except smtplib.SMTPException:
89                 if self.fail_silently:
90                     return
91                 raise
92         finally:
93             self.connection = None
94 
95     def send_messages(self, email_messages):
96         """
97         Send one or more EmailMessage objects and return the number of email
98         messages sent.
99         """
100         if not email_messages:
101             return 0
102         with self._lock:
103             new_conn_created = self.open()
104             if not self.connection or new_conn_created is None:
105                 # We failed silently on open().
106                 # Trying to send would be pointless.
107                 return 0
108             num_sent = 0
109             for message in email_messages:
110                 sent = self._send(message)
111                 if sent:
112                     num_sent += 1
113             if new_conn_created:
114                 self.close()
115         return num_sent
116 
117     def _send(self, email_message):
118         """A helper method that does the actual sending."""
119         if not email_message.recipients():
120             return False
121         encoding = email_message.encoding or settings.DEFAULT_CHARSET
122         from_email = sanitize_address(email_message.from_email, encoding)
123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]
124         message = email_message.message()
125         try:
126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\r\n'))
127         except smtplib.SMTPException:
128             if not self.fail_silently:
129                 raise
130             return False
131         return True

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-17 10:05:41.227 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 10:05:41.227 | INFO     | Search-only: skipping patch selection
2025-10-17 10:05:41.381 | INFO     | Task django__django-10904 completed successfully.
2025-10-17 10:05:41.382 | INFO     | No patch generated. You can try running ACR again.
