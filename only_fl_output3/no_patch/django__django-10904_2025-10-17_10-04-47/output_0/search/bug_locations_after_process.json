[
    {
        "rel_file_path": "django/contrib/gis/geos/libgeos.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/contrib/gis/geos/libgeos.py",
        "start": 1,
        "end": 175,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2  This module houses the ctypes initialization procedures, as well\n3  as the notice and error handler function callbacks (get called\n4  when an error occurs in GEOS).\n5 \n6  This module also houses GEOS Pointer utilities, including\n7  get_pointer_arr(), and GEOM_PTR.\n8 \"\"\"\n9 import logging\n10 import os\n11 from ctypes import CDLL, CFUNCTYPE, POINTER, Structure, c_char_p\n12 from ctypes.util import find_library\n13 \n14 from django.core.exceptions import ImproperlyConfigured\n15 from django.utils.functional import SimpleLazyObject, cached_property\n16 from django.utils.version import get_version_tuple\n17 \n18 logger = logging.getLogger('django.contrib.gis')\n19 \n20 \n21 def load_geos():\n22     # Custom library path set?\n23     try:\n24         from django.conf import settings\n25         lib_path = settings.GEOS_LIBRARY_PATH\n26     except (AttributeError, EnvironmentError,\n27             ImportError, ImproperlyConfigured):\n28         lib_path = None\n29 \n30     # Setting the appropriate names for the GEOS-C library.\n31     if lib_path:\n32         lib_names = None\n33     elif os.name == 'nt':\n34         # Windows NT libraries\n35         lib_names = ['geos_c', 'libgeos_c-1']\n36     elif os.name == 'posix':\n37         # *NIX libraries\n38         lib_names = ['geos_c', 'GEOS']\n39     else:\n40         raise ImportError('Unsupported OS \"%s\"' % os.name)\n41 \n42     # Using the ctypes `find_library` utility to find the path to the GEOS\n43     # shared library.  This is better than manually specifying each library name\n44     # and extension (e.g., libgeos_c.[so|so.1|dylib].).\n45     if lib_names:\n46         for lib_name in lib_names:\n47             lib_path = find_library(lib_name)\n48             if lib_path is not None:\n49                 break\n50 \n51     # No GEOS library could be found.\n52     if lib_path is None:\n53         raise ImportError(\n54             'Could not find the GEOS library (tried \"%s\"). '\n55             'Try setting GEOS_LIBRARY_PATH in your settings.' %\n56             '\", \"'.join(lib_names)\n57         )\n58     # Getting the GEOS C library.  The C interface (CDLL) is used for\n59     # both *NIX and Windows.\n60     # See the GEOS C API source code for more details on the library function calls:\n61     #  http://geos.refractions.net/ro/doxygen_docs/html/geos__c_8h-source.html\n62     _lgeos = CDLL(lib_path)\n63     # Here we set up the prototypes for the initGEOS_r and finishGEOS_r\n64     # routines.  These functions aren't actually called until they are\n65     # attached to a GEOS context handle -- this actually occurs in\n66     # geos/prototypes/threadsafe.py.\n67     _lgeos.initGEOS_r.restype = CONTEXT_PTR\n68     _lgeos.finishGEOS_r.argtypes = [CONTEXT_PTR]\n69     # Set restype for compatibility across 32 and 64-bit platforms.\n70     _lgeos.GEOSversion.restype = c_char_p\n71     return _lgeos\n72 \n73 \n74 # The notice and error handler C function callback definitions.\n75 # Supposed to mimic the GEOS message handler (C below):\n76 #  typedef void (*GEOSMessageHandler)(const char *fmt, ...);\n77 NOTICEFUNC = CFUNCTYPE(None, c_char_p, c_char_p)\n78 \n79 \n80 def notice_h(fmt, lst):\n81     fmt, lst = fmt.decode(), lst.decode()\n82     try:\n83         warn_msg = fmt % lst\n84     except TypeError:\n85         warn_msg = fmt\n86     logger.warning('GEOS_NOTICE: %s\\n', warn_msg)\n87 \n88 \n89 notice_h = NOTICEFUNC(notice_h)\n90 \n91 ERRORFUNC = CFUNCTYPE(None, c_char_p, c_char_p)\n92 \n93 \n94 def error_h(fmt, lst):\n95     fmt, lst = fmt.decode(), lst.decode()\n96     try:\n97         err_msg = fmt % lst\n98     except TypeError:\n99         err_msg = fmt\n100     logger.error('GEOS_ERROR: %s\\n', err_msg)\n101 \n102 \n103 error_h = ERRORFUNC(error_h)\n104 \n105 # #### GEOS Geometry C data structures, and utility functions. ####\n106 \n107 \n108 # Opaque GEOS geometry structures, used for GEOM_PTR and CS_PTR\n109 class GEOSGeom_t(Structure):\n110     pass\n111 \n112 \n113 class GEOSPrepGeom_t(Structure):\n114     pass\n115 \n116 \n117 class GEOSCoordSeq_t(Structure):\n118     pass\n119 \n120 \n121 class GEOSContextHandle_t(Structure):\n122     pass\n123 \n124 \n125 # Pointers to opaque GEOS geometry structures.\n126 GEOM_PTR = POINTER(GEOSGeom_t)\n127 PREPGEOM_PTR = POINTER(GEOSPrepGeom_t)\n128 CS_PTR = POINTER(GEOSCoordSeq_t)\n129 CONTEXT_PTR = POINTER(GEOSContextHandle_t)\n130 \n131 \n132 lgeos = SimpleLazyObject(load_geos)\n133 \n134 \n135 class GEOSFuncFactory:\n136     \"\"\"\n137     Lazy loading of GEOS functions.\n138     \"\"\"\n139     argtypes = None\n140     restype = None\n141     errcheck = None\n142 \n143     def __init__(self, func_name, *args, restype=None, errcheck=None, argtypes=None, **kwargs):\n144         self.func_name = func_name\n145         if restype is not None:\n146             self.restype = restype\n147         if errcheck is not None:\n148             self.errcheck = errcheck\n149         if argtypes is not None:\n150             self.argtypes = argtypes\n151         self.args = args\n152         self.kwargs = kwargs\n153 \n154     def __call__(self, *args, **kwargs):\n155         return self.func(*args, **kwargs)\n156 \n157     @cached_property\n158     def func(self):\n159         from django.contrib.gis.geos.prototypes.threadsafe import GEOSFunc\n160         func = GEOSFunc(self.func_name)\n161         func.argtypes = self.argtypes or []\n162         func.restype = self.restype\n163         if self.errcheck:\n164             func.errcheck = self.errcheck\n165         return func\n166 \n167 \n168 def geos_version():\n169     \"\"\"Return the string version of the GEOS library.\"\"\"\n170     return lgeos.GEOSversion()\n171 \n172 \n173 def geos_version_tuple():\n174     \"\"\"Return the GEOS version as a tuple (major, minor, subminor).\"\"\"\n175     return get_version_tuple(geos_version().decode())\n",
        "intended_behavior": "Replace `EnvironmentError` with `OSError` in the exception catch. The intended behavior remains to handle exceptions during the configuration of GEOS library paths, ensuring the application can manage and report configuration or file access issues without change."
    },
    {
        "rel_file_path": "django/contrib/gis/gdal/libgdal.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/contrib/gis/gdal/libgdal.py",
        "start": 1,
        "end": 124,
        "class_name": null,
        "method_name": null,
        "code": "1 import logging\n2 import os\n3 import re\n4 from ctypes import CDLL, CFUNCTYPE, c_char_p, c_int\n5 from ctypes.util import find_library\n6 \n7 from django.contrib.gis.gdal.error import GDALException\n8 from django.core.exceptions import ImproperlyConfigured\n9 \n10 logger = logging.getLogger('django.contrib.gis')\n11 \n12 # Custom library path set?\n13 try:\n14     from django.conf import settings\n15     lib_path = settings.GDAL_LIBRARY_PATH\n16 except (AttributeError, EnvironmentError,\n17         ImportError, ImproperlyConfigured):\n18     lib_path = None\n19 \n20 if lib_path:\n21     lib_names = None\n22 elif os.name == 'nt':\n23     # Windows NT shared libraries\n24     lib_names = ['gdal203', 'gdal202', 'gdal201', 'gdal20', 'gdal111']\n25 elif os.name == 'posix':\n26     # *NIX library names.\n27     lib_names = ['gdal', 'GDAL', 'gdal2.3.0', 'gdal2.2.0', 'gdal2.1.0', 'gdal2.0.0', 'gdal1.11.0']\n28 else:\n29     raise ImproperlyConfigured('GDAL is unsupported on OS \"%s\".' % os.name)\n30 \n31 # Using the ctypes `find_library` utility  to find the\n32 # path to the GDAL library from the list of library names.\n33 if lib_names:\n34     for lib_name in lib_names:\n35         lib_path = find_library(lib_name)\n36         if lib_path is not None:\n37             break\n38 \n39 if lib_path is None:\n40     raise ImproperlyConfigured(\n41         'Could not find the GDAL library (tried \"%s\"). Is GDAL installed? '\n42         'If it is, try setting GDAL_LIBRARY_PATH in your settings.'\n43         % '\", \"'.join(lib_names)\n44     )\n45 \n46 # This loads the GDAL/OGR C library\n47 lgdal = CDLL(lib_path)\n48 \n49 # On Windows, the GDAL binaries have some OSR routines exported with\n50 # STDCALL, while others are not.  Thus, the library will also need to\n51 # be loaded up as WinDLL for said OSR functions that require the\n52 # different calling convention.\n53 if os.name == 'nt':\n54     from ctypes import WinDLL\n55     lwingdal = WinDLL(lib_path)\n56 \n57 \n58 def std_call(func):\n59     \"\"\"\n60     Return the correct STDCALL function for certain OSR routines on Win32\n61     platforms.\n62     \"\"\"\n63     if os.name == 'nt':\n64         return lwingdal[func]\n65     else:\n66         return lgdal[func]\n67 \n68 \n69 # #### Version-information functions. ####\n70 \n71 # Return GDAL library version information with the given key.\n72 _version_info = std_call('GDALVersionInfo')\n73 _version_info.argtypes = [c_char_p]\n74 _version_info.restype = c_char_p\n75 \n76 \n77 def gdal_version():\n78     \"Return only the GDAL version number information.\"\n79     return _version_info(b'RELEASE_NAME')\n80 \n81 \n82 def gdal_full_version():\n83     \"Return the full GDAL version information.\"\n84     return _version_info('')\n85 \n86 \n87 version_regex = re.compile(r'^(?P<major>\\d+)\\.(?P<minor>\\d+)(\\.(?P<subminor>\\d+))?')\n88 \n89 \n90 def gdal_version_info():\n91     ver = gdal_version().decode()\n92     m = version_regex.match(ver)\n93     if not m:\n94         raise GDALException('Could not parse GDAL version string \"%s\"' % ver)\n95     return {key: m.group(key) for key in ('major', 'minor', 'subminor')}\n96 \n97 \n98 _verinfo = gdal_version_info()\n99 GDAL_MAJOR_VERSION = int(_verinfo['major'])\n100 GDAL_MINOR_VERSION = int(_verinfo['minor'])\n101 GDAL_SUBMINOR_VERSION = _verinfo['subminor'] and int(_verinfo['subminor'])\n102 GDAL_VERSION = (GDAL_MAJOR_VERSION, GDAL_MINOR_VERSION, GDAL_SUBMINOR_VERSION)\n103 del _verinfo\n104 \n105 # Set library error handling so as errors are logged\n106 CPLErrorHandler = CFUNCTYPE(None, c_int, c_int, c_char_p)\n107 \n108 \n109 def err_handler(error_class, error_number, message):\n110     logger.error('GDAL_ERROR %d: %s', error_number, message)\n111 \n112 \n113 err_handler = CPLErrorHandler(err_handler)\n114 \n115 \n116 def function(name, args, restype):\n117     func = std_call(name)\n118     func.argtypes = args\n119     func.restype = restype\n120     return func\n121 \n122 \n123 set_error_handler = function('CPLSetErrorHandler', [CPLErrorHandler], CPLErrorHandler)\n124 set_error_handler(err_handler)\n",
        "intended_behavior": "Replace `EnvironmentError` with `OSError` when attempting to load GDAL library paths from settings. It aims to maintain the functionality of catching errors related to the GDAL library configuration, improving the code's consistency with modern Python standards."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 42,
        "end": 74,
        "class_name": "EmailBackend",
        "method_name": "open",
        "code": "42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n",
        "intended_behavior": "Simplify the except block to catch `OSError` instead of `(smtplib.SMTPException, socket.error)`. This preserves the error handling for SMTP connection issues, with the added benefit of a cleaner, more Pythonic approach aligning with newer Python versions."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 59,
        "end": 63,
        "class_name": "EmailBackend",
        "method_name": "open",
        "code": "59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n",
        "intended_behavior": "Simplify the except block to catch `OSError` instead of `(smtplib.SMTPException, socket.error)`. This preserves the error handling for SMTP connection issues, with the added benefit of a cleaner, more Pythonic approach aligning with newer Python versions."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 13,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(BaseEmailBackend):\n14     \"\"\"\n15     A wrapper that manages the SMTP network connection.\n16     \"\"\"\n17     def __init__(self, host=None, port=None, username=None, password=None,\n18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,\n19                  ssl_keyfile=None, ssl_certfile=None,\n20                  **kwargs):\n21         super().__init__(fail_silently=fail_silently)\n22         self.host = host or settings.EMAIL_HOST\n23         self.port = port or settings.EMAIL_PORT\n24         self.username = settings.EMAIL_HOST_USER if username is None else username\n25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password\n26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls\n27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl\n28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout\n29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile\n30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile\n31         if self.use_ssl and self.use_tls:\n32             raise ValueError(\n33                 \"EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set \"\n34                 \"one of those settings to True.\")\n35         self.connection = None\n36         self._lock = threading.RLock()\n37 \n38     @property\n39     def connection_class(self):\n40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP\n41 \n42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n75 \n76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n94 \n95     def send_messages(self, email_messages):\n96         \"\"\"\n97         Send one or more EmailMessage objects and return the number of email\n98         messages sent.\n99         \"\"\"\n100         if not email_messages:\n101             return 0\n102         with self._lock:\n103             new_conn_created = self.open()\n104             if not self.connection or new_conn_created is None:\n105                 # We failed silently on open().\n106                 # Trying to send would be pointless.\n107                 return 0\n108             num_sent = 0\n109             for message in email_messages:\n110                 sent = self._send(message)\n111                 if sent:\n112                     num_sent += 1\n113             if new_conn_created:\n114                 self.close()\n115         return num_sent\n116 \n117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 13,
        "end": 70,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(ConsoleEmailBackend):\n14     def __init__(self, *args, file_path=None, **kwargs):\n15         self._fname = None\n16         if file_path is not None:\n17             self.file_path = file_path\n18         else:\n19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)\n20         # Make sure self.file_path is a string.\n21         if not isinstance(self.file_path, str):\n22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)\n23         self.file_path = os.path.abspath(self.file_path)\n24         # Make sure that self.file_path is a directory if it exists.\n25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):\n26             raise ImproperlyConfigured(\n27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path\n28             )\n29         # Try to create it, if it not exists.\n30         elif not os.path.exists(self.file_path):\n31             try:\n32                 os.makedirs(self.file_path)\n33             except OSError as err:\n34                 raise ImproperlyConfigured(\n35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)\n36                 )\n37         # Make sure that self.file_path is writable.\n38         if not os.access(self.file_path, os.W_OK):\n39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)\n40         # Finally, call super().\n41         # Since we're using the console-based backend as a base,\n42         # force the stream to be None, so we don't default to stdout\n43         kwargs['stream'] = None\n44         super().__init__(*args, **kwargs)\n45 \n46     def write_message(self, message):\n47         self.stream.write(message.message().as_bytes() + b'\\n')\n48         self.stream.write(b'-' * 79)\n49         self.stream.write(b'\\n')\n50 \n51     def _get_filename(self):\n52         \"\"\"Return a unique file name.\"\"\"\n53         if self._fname is None:\n54             timestamp = datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n55             fname = \"%s-%s.log\" % (timestamp, abs(id(self)))\n56             self._fname = os.path.join(self.file_path, fname)\n57         return self._fname\n58 \n59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n64 \n65     def close(self):\n66         try:\n67             if self.stream is not None:\n68                 self.stream.close()\n69         finally:\n70             self.stream = None\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 76,
        "end": 93,
        "class_name": "EmailBackend",
        "method_name": "close",
        "code": "76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n",
        "intended_behavior": "Catch `OSError` in place of `smtplib.SMTPException`. Keeps the defensive programming against SMTP disconnection issues intact while simplifying the codebase."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 65,
        "end": 70,
        "class_name": "EmailBackend",
        "method_name": "close",
        "code": "65     def close(self):\n66         try:\n67             if self.stream is not None:\n68                 self.stream.close()\n69         finally:\n70             self.stream = None\n",
        "intended_behavior": "Catch `OSError` in place of `smtplib.SMTPException`. Keeps the defensive programming against SMTP disconnection issues intact while simplifying the codebase."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 13,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(BaseEmailBackend):\n14     \"\"\"\n15     A wrapper that manages the SMTP network connection.\n16     \"\"\"\n17     def __init__(self, host=None, port=None, username=None, password=None,\n18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,\n19                  ssl_keyfile=None, ssl_certfile=None,\n20                  **kwargs):\n21         super().__init__(fail_silently=fail_silently)\n22         self.host = host or settings.EMAIL_HOST\n23         self.port = port or settings.EMAIL_PORT\n24         self.username = settings.EMAIL_HOST_USER if username is None else username\n25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password\n26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls\n27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl\n28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout\n29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile\n30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile\n31         if self.use_ssl and self.use_tls:\n32             raise ValueError(\n33                 \"EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set \"\n34                 \"one of those settings to True.\")\n35         self.connection = None\n36         self._lock = threading.RLock()\n37 \n38     @property\n39     def connection_class(self):\n40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP\n41 \n42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n75 \n76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n94 \n95     def send_messages(self, email_messages):\n96         \"\"\"\n97         Send one or more EmailMessage objects and return the number of email\n98         messages sent.\n99         \"\"\"\n100         if not email_messages:\n101             return 0\n102         with self._lock:\n103             new_conn_created = self.open()\n104             if not self.connection or new_conn_created is None:\n105                 # We failed silently on open().\n106                 # Trying to send would be pointless.\n107                 return 0\n108             num_sent = 0\n109             for message in email_messages:\n110                 sent = self._send(message)\n111                 if sent:\n112                     num_sent += 1\n113             if new_conn_created:\n114                 self.close()\n115         return num_sent\n116 \n117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/filebased.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/filebased.py",
        "start": 13,
        "end": 70,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(ConsoleEmailBackend):\n14     def __init__(self, *args, file_path=None, **kwargs):\n15         self._fname = None\n16         if file_path is not None:\n17             self.file_path = file_path\n18         else:\n19             self.file_path = getattr(settings, 'EMAIL_FILE_PATH', None)\n20         # Make sure self.file_path is a string.\n21         if not isinstance(self.file_path, str):\n22             raise ImproperlyConfigured('Path for saving emails is invalid: %r' % self.file_path)\n23         self.file_path = os.path.abspath(self.file_path)\n24         # Make sure that self.file_path is a directory if it exists.\n25         if os.path.exists(self.file_path) and not os.path.isdir(self.file_path):\n26             raise ImproperlyConfigured(\n27                 'Path for saving email messages exists, but is not a directory: %s' % self.file_path\n28             )\n29         # Try to create it, if it not exists.\n30         elif not os.path.exists(self.file_path):\n31             try:\n32                 os.makedirs(self.file_path)\n33             except OSError as err:\n34                 raise ImproperlyConfigured(\n35                     'Could not create directory for saving email messages: %s (%s)' % (self.file_path, err)\n36                 )\n37         # Make sure that self.file_path is writable.\n38         if not os.access(self.file_path, os.W_OK):\n39             raise ImproperlyConfigured('Could not write to directory: %s' % self.file_path)\n40         # Finally, call super().\n41         # Since we're using the console-based backend as a base,\n42         # force the stream to be None, so we don't default to stdout\n43         kwargs['stream'] = None\n44         super().__init__(*args, **kwargs)\n45 \n46     def write_message(self, message):\n47         self.stream.write(message.message().as_bytes() + b'\\n')\n48         self.stream.write(b'-' * 79)\n49         self.stream.write(b'\\n')\n50 \n51     def _get_filename(self):\n52         \"\"\"Return a unique file name.\"\"\"\n53         if self._fname is None:\n54             timestamp = datetime.datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n55             fname = \"%s-%s.log\" % (timestamp, abs(id(self)))\n56             self._fname = os.path.join(self.file_path, fname)\n57         return self._fname\n58 \n59     def open(self):\n60         if self.stream is None:\n61             self.stream = open(self._get_filename(), 'ab')\n62             return True\n63         return False\n64 \n65     def close(self):\n66         try:\n67             if self.stream is not None:\n68                 self.stream.close()\n69         finally:\n70             self.stream = None\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 117,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": "_send",
        "code": "117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "Update to catch `OSError` for a broader range of errors during email sending operations. Maintains the fail-silently logic upon SMTP communication failures."
    },
    {
        "rel_file_path": "django/core/mail/backends/smtp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/mail/backends/smtp.py",
        "start": 13,
        "end": 131,
        "class_name": "EmailBackend",
        "method_name": null,
        "code": "13 class EmailBackend(BaseEmailBackend):\n14     \"\"\"\n15     A wrapper that manages the SMTP network connection.\n16     \"\"\"\n17     def __init__(self, host=None, port=None, username=None, password=None,\n18                  use_tls=None, fail_silently=False, use_ssl=None, timeout=None,\n19                  ssl_keyfile=None, ssl_certfile=None,\n20                  **kwargs):\n21         super().__init__(fail_silently=fail_silently)\n22         self.host = host or settings.EMAIL_HOST\n23         self.port = port or settings.EMAIL_PORT\n24         self.username = settings.EMAIL_HOST_USER if username is None else username\n25         self.password = settings.EMAIL_HOST_PASSWORD if password is None else password\n26         self.use_tls = settings.EMAIL_USE_TLS if use_tls is None else use_tls\n27         self.use_ssl = settings.EMAIL_USE_SSL if use_ssl is None else use_ssl\n28         self.timeout = settings.EMAIL_TIMEOUT if timeout is None else timeout\n29         self.ssl_keyfile = settings.EMAIL_SSL_KEYFILE if ssl_keyfile is None else ssl_keyfile\n30         self.ssl_certfile = settings.EMAIL_SSL_CERTFILE if ssl_certfile is None else ssl_certfile\n31         if self.use_ssl and self.use_tls:\n32             raise ValueError(\n33                 \"EMAIL_USE_TLS/EMAIL_USE_SSL are mutually exclusive, so only set \"\n34                 \"one of those settings to True.\")\n35         self.connection = None\n36         self._lock = threading.RLock()\n37 \n38     @property\n39     def connection_class(self):\n40         return smtplib.SMTP_SSL if self.use_ssl else smtplib.SMTP\n41 \n42     def open(self):\n43         \"\"\"\n44         Ensure an open connection to the email server. Return whether or not a\n45         new connection was required (True or False) or None if an exception\n46         passed silently.\n47         \"\"\"\n48         if self.connection:\n49             # Nothing to do if the connection is already open.\n50             return False\n51 \n52         # If local_hostname is not specified, socket.getfqdn() gets used.\n53         # For performance, we use the cached FQDN for local_hostname.\n54         connection_params = {'local_hostname': DNS_NAME.get_fqdn()}\n55         if self.timeout is not None:\n56             connection_params['timeout'] = self.timeout\n57         if self.use_ssl:\n58             connection_params.update({\n59                 'keyfile': self.ssl_keyfile,\n60                 'certfile': self.ssl_certfile,\n61             })\n62         try:\n63             self.connection = self.connection_class(self.host, self.port, **connection_params)\n64 \n65             # TLS/SSL are mutually exclusive, so only attempt TLS over\n66             # non-secure connections.\n67             if not self.use_ssl and self.use_tls:\n68                 self.connection.starttls(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile)\n69             if self.username and self.password:\n70                 self.connection.login(self.username, self.password)\n71             return True\n72         except (smtplib.SMTPException, socket.error):\n73             if not self.fail_silently:\n74                 raise\n75 \n76     def close(self):\n77         \"\"\"Close the connection to the email server.\"\"\"\n78         if self.connection is None:\n79             return\n80         try:\n81             try:\n82                 self.connection.quit()\n83             except (ssl.SSLError, smtplib.SMTPServerDisconnected):\n84                 # This happens when calling quit() on a TLS connection\n85                 # sometimes, or when the connection was already disconnected\n86                 # by the server.\n87                 self.connection.close()\n88             except smtplib.SMTPException:\n89                 if self.fail_silently:\n90                     return\n91                 raise\n92         finally:\n93             self.connection = None\n94 \n95     def send_messages(self, email_messages):\n96         \"\"\"\n97         Send one or more EmailMessage objects and return the number of email\n98         messages sent.\n99         \"\"\"\n100         if not email_messages:\n101             return 0\n102         with self._lock:\n103             new_conn_created = self.open()\n104             if not self.connection or new_conn_created is None:\n105                 # We failed silently on open().\n106                 # Trying to send would be pointless.\n107                 return 0\n108             num_sent = 0\n109             for message in email_messages:\n110                 sent = self._send(message)\n111                 if sent:\n112                     num_sent += 1\n113             if new_conn_created:\n114                 self.close()\n115         return num_sent\n116 \n117     def _send(self, email_message):\n118         \"\"\"A helper method that does the actual sending.\"\"\"\n119         if not email_message.recipients():\n120             return False\n121         encoding = email_message.encoding or settings.DEFAULT_CHARSET\n122         from_email = sanitize_address(email_message.from_email, encoding)\n123         recipients = [sanitize_address(addr, encoding) for addr in email_message.recipients()]\n124         message = email_message.message()\n125         try:\n126             self.connection.sendmail(from_email, recipients, message.as_bytes(linesep='\\r\\n'))\n127         except smtplib.SMTPException:\n128             if not self.fail_silently:\n129                 raise\n130             return False\n131         return True\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]