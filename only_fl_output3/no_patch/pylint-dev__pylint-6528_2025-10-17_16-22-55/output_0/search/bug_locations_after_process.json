[
    {
        "rel_file_path": "pylint/config/option_manager_mixin.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/config/option_manager_mixin.py",
        "start": 1,
        "end": 348,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 # pylint: disable=duplicate-code\n6 \n7 from __future__ import annotations\n8 \n9 import collections\n10 import configparser\n11 import contextlib\n12 import copy\n13 import optparse  # pylint: disable=deprecated-module\n14 import os\n15 import sys\n16 import warnings\n17 from pathlib import Path\n18 from typing import Any, TextIO\n19 \n20 from pylint import utils\n21 from pylint.config.option import Option\n22 from pylint.config.option_parser import OptionParser\n23 from pylint.typing import OptionDict\n24 \n25 if sys.version_info >= (3, 11):\n26     import tomllib\n27 else:\n28     import tomli as tomllib\n29 \n30 \n31 def _expand_default(self, option):\n32     \"\"\"Patch OptionParser.expand_default with custom behaviour.\n33 \n34     This will handle defaults to avoid overriding values in the\n35     configuration file.\n36     \"\"\"\n37     if self.parser is None or not self.default_tag:\n38         return option.help\n39     optname = option._long_opts[0][2:]\n40     try:\n41         provider = self.parser.options_manager._all_options[optname]\n42     except KeyError:\n43         value = None\n44     else:\n45         optdict = provider.get_option_def(optname)\n46         optname = provider.option_attrname(optname, optdict)\n47         value = getattr(provider.config, optname, optdict)\n48         value = utils._format_option_value(optdict, value)\n49     if value is optparse.NO_DEFAULT or not value:\n50         value = self.NO_DEFAULT_VALUE\n51     return option.help.replace(self.default_tag, str(value))\n52 \n53 \n54 @contextlib.contextmanager\n55 def _patch_optparse():\n56     # pylint: disable = redefined-variable-type\n57     orig_default = optparse.HelpFormatter\n58     try:\n59         optparse.HelpFormatter.expand_default = _expand_default\n60         yield\n61     finally:\n62         optparse.HelpFormatter.expand_default = orig_default\n63 \n64 \n65 class OptionsManagerMixIn:\n66     \"\"\"Handle configuration from both a configuration file and command line options.\"\"\"\n67 \n68     def __init__(self, usage):\n69         # TODO: 3.0: Remove deprecated class\n70         warnings.warn(\n71             \"OptionsManagerMixIn has been deprecated and will be removed in pylint 3.0\",\n72             DeprecationWarning,\n73         )\n74         self.reset_parsers(usage)\n75         # list of registered options providers\n76         self.options_providers = []\n77         # dictionary associating option name to checker\n78         self._all_options = collections.OrderedDict()\n79         self._short_options = {}\n80         self._nocallback_options = {}\n81         self._mygroups = {}\n82         # verbosity\n83         self._maxlevel = 0\n84 \n85     def reset_parsers(self, usage=\"\"):\n86         # configuration file parser\n87         self.cfgfile_parser = configparser.ConfigParser(\n88             inline_comment_prefixes=(\"#\", \";\")\n89         )\n90         # command line parser\n91         self.cmdline_parser = OptionParser(Option, usage=usage)\n92         self.cmdline_parser.options_manager = self\n93         self._optik_option_attrs = set(self.cmdline_parser.option_class.ATTRS)\n94 \n95     def register_options_provider(self, provider, own_group=True):\n96         \"\"\"Register an options provider.\"\"\"\n97         self.options_providers.append(provider)\n98         non_group_spec_options = [\n99             option for option in provider.options if \"group\" not in option[1]\n100         ]\n101         groups = getattr(provider, \"option_groups\", ())\n102         if own_group and non_group_spec_options:\n103             self.add_option_group(\n104                 provider.name.upper(),\n105                 provider.__doc__,\n106                 non_group_spec_options,\n107                 provider,\n108             )\n109         else:\n110             for opt, optdict in non_group_spec_options:\n111                 self.add_optik_option(provider, self.cmdline_parser, opt, optdict)\n112         for gname, gdoc in groups:\n113             gname = gname.upper()\n114             goptions = [\n115                 option\n116                 for option in provider.options\n117                 if option[1].get(\"group\", \"\").upper() == gname\n118             ]\n119             self.add_option_group(gname, gdoc, goptions, provider)\n120 \n121     def add_option_group(self, group_name, _, options, provider):\n122         # add option group to the command line parser\n123         if group_name in self._mygroups:\n124             group = self._mygroups[group_name]\n125         else:\n126             group = optparse.OptionGroup(\n127                 self.cmdline_parser, title=group_name.capitalize()\n128             )\n129             self.cmdline_parser.add_option_group(group)\n130             self._mygroups[group_name] = group\n131             # add section to the config file\n132             if (\n133                 group_name != \"DEFAULT\"\n134                 and group_name not in self.cfgfile_parser._sections\n135             ):\n136                 self.cfgfile_parser.add_section(group_name)\n137         # add provider's specific options\n138         for opt, optdict in options:\n139             if not isinstance(optdict.get(\"action\", \"store\"), str):\n140                 optdict[\"action\"] = \"callback\"\n141             self.add_optik_option(provider, group, opt, optdict)\n142 \n143     def add_optik_option(self, provider, optikcontainer, opt, optdict):\n144         args, optdict = self.optik_option(provider, opt, optdict)\n145         option = optikcontainer.add_option(*args, **optdict)\n146         self._all_options[opt] = provider\n147         self._maxlevel = max(self._maxlevel, option.level or 0)\n148 \n149     def optik_option(self, provider, opt, optdict):\n150         \"\"\"Get our personal option definition and return a suitable form for\n151         use with optik/optparse.\n152         \"\"\"\n153         optdict = copy.copy(optdict)\n154         if \"action\" in optdict:\n155             self._nocallback_options[provider] = opt\n156         else:\n157             optdict[\"action\"] = \"callback\"\n158             optdict[\"callback\"] = self.cb_set_provider_option\n159         # default is handled here and *must not* be given to optik if you\n160         # want the whole machinery to work\n161         if \"default\" in optdict:\n162             if (\n163                 \"help\" in optdict\n164                 and optdict.get(\"default\") is not None\n165                 and optdict[\"action\"] not in (\"store_true\", \"store_false\")\n166             ):\n167                 optdict[\"help\"] += \" [current: %default]\"\n168             del optdict[\"default\"]\n169         args = [\"--\" + str(opt)]\n170         if \"short\" in optdict:\n171             self._short_options[optdict[\"short\"]] = opt\n172             args.append(\"-\" + optdict[\"short\"])\n173             del optdict[\"short\"]\n174         # cleanup option definition dict before giving it to optik\n175         for key in list(optdict.keys()):\n176             if key not in self._optik_option_attrs:\n177                 optdict.pop(key)\n178         return args, optdict\n179 \n180     def cb_set_provider_option(self, option, opt, value, parser):\n181         \"\"\"Optik callback for option setting.\"\"\"\n182         if opt.startswith(\"--\"):\n183             # remove -- on long option\n184             opt = opt[2:]\n185         else:\n186             # short option, get its long equivalent\n187             opt = self._short_options[opt[1:]]\n188         # trick since we can't set action='store_true' on options\n189         if value is None:\n190             value = 1\n191         self.global_set_option(opt, value)\n192 \n193     def global_set_option(self, opt, value):\n194         \"\"\"Set option on the correct option provider.\"\"\"\n195         self._all_options[opt].set_option(opt, value)\n196 \n197     def generate_config(\n198         self, stream: TextIO | None = None, skipsections: tuple[str, ...] = ()\n199     ) -> None:\n200         \"\"\"Write a configuration file according to the current configuration\n201         into the given stream or stdout.\n202         \"\"\"\n203         options_by_section: dict[str, list[tuple[str, OptionDict, Any]]] = {}\n204         sections = []\n205         for provider in self.options_providers:\n206             for section, options in provider.options_by_section():\n207                 if section is None:\n208                     section = provider.name\n209                 if section in skipsections:\n210                     continue\n211                 options = [\n212                     (n, d, v)\n213                     for (n, d, v) in options\n214                     if d.get(\"type\") is not None and not d.get(\"deprecated\")\n215                 ]\n216                 if not options:\n217                     continue\n218                 if section not in sections:\n219                     sections.append(section)\n220                 all_options = options_by_section.setdefault(section, [])\n221                 all_options += options\n222         stream = stream or sys.stdout\n223         printed = False\n224         for section in sections:\n225             if printed:\n226                 print(\"\\n\", file=stream)\n227             utils.format_section(\n228                 stream, section.upper(), sorted(options_by_section[section])\n229             )\n230             printed = True\n231 \n232     def load_provider_defaults(self):\n233         \"\"\"Initialize configuration using default values.\"\"\"\n234         for provider in self.options_providers:\n235             provider.load_defaults()\n236 \n237     def read_config_file(\n238         self, config_file: Path | None = None, verbose: bool = False\n239     ) -> None:\n240         \"\"\"Read the configuration file but do not load it (i.e. dispatching\n241         values to each option's provider).\n242         \"\"\"\n243         if config_file:\n244             config_file = Path(os.path.expandvars(config_file)).expanduser()\n245             if not config_file.exists():\n246                 raise OSError(f\"The config file {str(config_file)} doesn't exist!\")\n247 \n248             parser = self.cfgfile_parser\n249             if config_file.suffix == \".toml\":\n250                 try:\n251                     self._parse_toml(config_file, parser)\n252                 except tomllib.TOMLDecodeError:\n253                     pass\n254             else:\n255                 # Use this encoding in order to strip the BOM marker, if any.\n256                 with open(config_file, encoding=\"utf_8_sig\") as fp:\n257                     parser.read_file(fp)\n258                 # normalize each section's title\n259                 for sect, values in list(parser._sections.items()):\n260                     if sect.startswith(\"pylint.\"):\n261                         sect = sect[len(\"pylint.\") :]\n262                     if not sect.isupper() and values:\n263                         parser._sections[sect.upper()] = values\n264 \n265         if not verbose:\n266             return\n267         if config_file and config_file.exists():\n268             msg = f\"Using config file '{config_file}'\"\n269         else:\n270             msg = \"No config file found, using default configuration\"\n271         print(msg, file=sys.stderr)\n272 \n273     def _parse_toml(self, config_file: Path, parser: configparser.ConfigParser) -> None:\n274         \"\"\"Parse and handle errors of a toml configuration file.\"\"\"\n275         with open(config_file, mode=\"rb\") as fp:\n276             content = tomllib.load(fp)\n277         try:\n278             sections_values = content[\"tool\"][\"pylint\"]\n279         except KeyError:\n280             return\n281         for section, values in sections_values.items():\n282             section_name = section.upper()\n283             # TOML has rich types, convert values to\n284             # strings as ConfigParser expects.\n285             if not isinstance(values, dict):\n286                 # This class is a mixin: add_message comes from the `PyLinter` class\n287                 self.add_message(  # type: ignore[attr-defined]\n288                     \"bad-configuration-section\", line=0, args=(section, values)\n289                 )\n290                 continue\n291             for option, value in values.items():\n292                 if isinstance(value, bool):\n293                     values[option] = \"yes\" if value else \"no\"\n294                 elif isinstance(value, list):\n295                     values[option] = \",\".join(value)\n296                 else:\n297                     values[option] = str(value)\n298             for option, value in values.items():\n299                 try:\n300                     parser.set(section_name, option, value=value)\n301                 except configparser.NoSectionError:\n302                     parser.add_section(section_name)\n303                     parser.set(section_name, option, value=value)\n304 \n305     def load_config_file(self):\n306         \"\"\"Dispatch values previously read from a configuration file to each\n307         option's provider.\n308         \"\"\"\n309         parser = self.cfgfile_parser\n310         for section in parser.sections():\n311             for option, value in parser.items(section):\n312                 try:\n313                     self.global_set_option(option, value)\n314                 except (KeyError, optparse.OptionError):\n315                     continue\n316 \n317     def load_configuration(self, **kwargs):\n318         \"\"\"Override configuration according to given parameters.\"\"\"\n319         return self.load_configuration_from_config(kwargs)\n320 \n321     def load_configuration_from_config(self, config):\n322         for opt, opt_value in config.items():\n323             opt = opt.replace(\"_\", \"-\")\n324             provider = self._all_options[opt]\n325             provider.set_option(opt, opt_value)\n326 \n327     def load_command_line_configuration(self, args=None) -> list[str]:\n328         \"\"\"Override configuration according to command line parameters.\n329 \n330         return additional arguments\n331         \"\"\"\n332         with _patch_optparse():\n333             args = sys.argv[1:] if args is None else list(args)\n334             (options, args) = self.cmdline_parser.parse_args(args=args)\n335             for provider in self._nocallback_options:\n336                 config = provider.config\n337                 for attr in config.__dict__.keys():\n338                     value = getattr(options, attr, None)\n339                     if value is None:\n340                         continue\n341                     setattr(config, attr, value)\n342             return args\n343 \n344     def help(self, level=0):\n345         \"\"\"Return the usage string for available options.\"\"\"\n346         self.cmdline_parser.formatter.output_level = level\n347         with _patch_optparse():\n348             return self.cmdline_parser.format_help()\n",
        "intended_behavior": "Ensure that all configurations related to ignore settings (`--ignore`, `--ignore-paths`, `--ignore-patterns`) are correctly loaded and processed."
    },
    {
        "rel_file_path": "pylint/lint/pylinter.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pylint-dev__pylint/setup_pylint-dev__pylint__2.14/pylint/lint/pylinter.py",
        "start": 1,
        "end": 1188,
        "class_name": null,
        "method_name": null,
        "code": "1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n4 \n5 from __future__ import annotations\n6 \n7 import collections\n8 import contextlib\n9 import functools\n10 import os\n11 import sys\n12 import tokenize\n13 import traceback\n14 import warnings\n15 from collections import defaultdict\n16 from collections.abc import Callable, Iterable, Iterator, Sequence\n17 from io import TextIOWrapper\n18 from typing import Any\n19 \n20 import astroid\n21 from astroid import AstroidError, nodes\n22 \n23 from pylint import checkers, exceptions, interfaces, reporters\n24 from pylint.checkers.base_checker import BaseChecker\n25 from pylint.config.arguments_manager import _ArgumentsManager\n26 from pylint.constants import (\n27     MAIN_CHECKER_NAME,\n28     MSG_TYPES,\n29     MSG_TYPES_STATUS,\n30     WarningScope,\n31 )\n32 from pylint.lint.base_options import _make_linter_options\n33 from pylint.lint.caching import load_results, save_results\n34 from pylint.lint.expand_modules import expand_modules\n35 from pylint.lint.message_state_handler import _MessageStateHandler\n36 from pylint.lint.parallel import check_parallel\n37 from pylint.lint.report_functions import (\n38     report_messages_by_module_stats,\n39     report_messages_stats,\n40     report_total_messages_stats,\n41 )\n42 from pylint.lint.utils import (\n43     fix_import_path,\n44     get_fatal_error_message,\n45     prepare_crash_report,\n46 )\n47 from pylint.message import Message, MessageDefinition, MessageDefinitionStore\n48 from pylint.reporters.base_reporter import BaseReporter\n49 from pylint.reporters.text import TextReporter\n50 from pylint.reporters.ureports import nodes as report_nodes\n51 from pylint.typing import (\n52     FileItem,\n53     ManagedMessage,\n54     MessageDefinitionTuple,\n55     MessageLocationTuple,\n56     ModuleDescriptionDict,\n57     Options,\n58 )\n59 from pylint.utils import ASTWalker, FileState, LinterStats, utils\n60 \n61 if sys.version_info >= (3, 8):\n62     from typing import Protocol\n63 else:\n64     from typing_extensions import Protocol\n65 \n66 \n67 MANAGER = astroid.MANAGER\n68 \n69 \n70 class GetAstProtocol(Protocol):\n71     def __call__(\n72         self, filepath: str, modname: str, data: str | None = None\n73     ) -> nodes.Module:\n74         ...\n75 \n76 \n77 def _read_stdin() -> str:\n78     # See https://github.com/python/typeshed/pull/5623 for rationale behind assertion\n79     assert isinstance(sys.stdin, TextIOWrapper)\n80     sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding=\"utf-8\")\n81     return sys.stdin.read()\n82 \n83 \n84 def _load_reporter_by_class(reporter_class: str) -> type[BaseReporter]:\n85     qname = reporter_class\n86     module_part = astroid.modutils.get_module_part(qname)\n87     module = astroid.modutils.load_module_from_name(module_part)\n88     class_name = qname.split(\".\")[-1]\n89     klass = getattr(module, class_name)\n90     assert issubclass(klass, BaseReporter), f\"{klass} is not a BaseReporter\"\n91     return klass\n92 \n93 \n94 # Python Linter class #########################################################\n95 \n96 # pylint: disable-next=consider-using-namedtuple-or-dataclass\n97 MSGS: dict[str, MessageDefinitionTuple] = {\n98     \"F0001\": (\n99         \"%s\",\n100         \"fatal\",\n101         \"Used when an error occurred preventing the analysis of a \\\n102               module (unable to find it for instance).\",\n103         {\"scope\": WarningScope.LINE},\n104     ),\n105     \"F0002\": (\n106         \"%s: %s\",\n107         \"astroid-error\",\n108         \"Used when an unexpected error occurred while building the \"\n109         \"Astroid  representation. This is usually accompanied by a \"\n110         \"traceback. Please report such errors !\",\n111         {\"scope\": WarningScope.LINE},\n112     ),\n113     \"F0010\": (\n114         \"error while code parsing: %s\",\n115         \"parse-error\",\n116         \"Used when an exception occurred while building the Astroid \"\n117         \"representation which could be handled by astroid.\",\n118         {\"scope\": WarningScope.LINE},\n119     ),\n120     \"F0011\": (\n121         \"error while parsing the configuration: %s\",\n122         \"config-parse-error\",\n123         \"Used when an exception occurred while parsing a pylint configuration file.\",\n124         {\"scope\": WarningScope.LINE},\n125     ),\n126     \"I0001\": (\n127         \"Unable to run raw checkers on built-in module %s\",\n128         \"raw-checker-failed\",\n129         \"Used to inform that a built-in module has not been checked \"\n130         \"using the raw checkers.\",\n131         {\"scope\": WarningScope.LINE},\n132     ),\n133     \"I0010\": (\n134         \"Unable to consider inline option %r\",\n135         \"bad-inline-option\",\n136         \"Used when an inline option is either badly formatted or can't \"\n137         \"be used inside modules.\",\n138         {\"scope\": WarningScope.LINE},\n139     ),\n140     \"I0011\": (\n141         \"Locally disabling %s (%s)\",\n142         \"locally-disabled\",\n143         \"Used when an inline option disables a message or a messages category.\",\n144         {\"scope\": WarningScope.LINE},\n145     ),\n146     \"I0013\": (\n147         \"Ignoring entire file\",\n148         \"file-ignored\",\n149         \"Used to inform that the file will not be checked\",\n150         {\"scope\": WarningScope.LINE},\n151     ),\n152     \"I0020\": (\n153         \"Suppressed %s (from line %d)\",\n154         \"suppressed-message\",\n155         \"A message was triggered on a line, but suppressed explicitly \"\n156         \"by a disable= comment in the file. This message is not \"\n157         \"generated for messages that are ignored due to configuration \"\n158         \"settings.\",\n159         {\"scope\": WarningScope.LINE},\n160     ),\n161     \"I0021\": (\n162         \"Useless suppression of %s\",\n163         \"useless-suppression\",\n164         \"Reported when a message is explicitly disabled for a line or \"\n165         \"a block of code, but never triggered.\",\n166         {\"scope\": WarningScope.LINE},\n167     ),\n168     \"I0022\": (\n169         'Pragma \"%s\" is deprecated, use \"%s\" instead',\n170         \"deprecated-pragma\",\n171         \"Some inline pylint options have been renamed or reworked, \"\n172         \"only the most recent form should be used. \"\n173         \"NOTE:skip-all is only available with pylint >= 0.26\",\n174         {\n175             \"old_names\": [(\"I0014\", \"deprecated-disable-all\")],\n176             \"scope\": WarningScope.LINE,\n177         },\n178     ),\n179     \"E0001\": (\n180         \"%s\",\n181         \"syntax-error\",\n182         \"Used when a syntax error is raised for a module.\",\n183         {\"scope\": WarningScope.LINE},\n184     ),\n185     \"E0011\": (\n186         \"Unrecognized file option %r\",\n187         \"unrecognized-inline-option\",\n188         \"Used when an unknown inline option is encountered.\",\n189         {\"scope\": WarningScope.LINE},\n190     ),\n191     \"E0012\": (\n192         \"Bad option value for %s\",\n193         \"bad-option-value\",\n194         \"Used when a bad value for an inline option is encountered.\",\n195         {\"scope\": WarningScope.LINE},\n196     ),\n197     \"E0013\": (\n198         \"Plugin '%s' is impossible to load, is it installed ? ('%s')\",\n199         \"bad-plugin-value\",\n200         \"Used when a bad value is used in 'load-plugins'.\",\n201         {\"scope\": WarningScope.LINE},\n202     ),\n203     \"E0014\": (\n204         \"Out-of-place setting encountered in top level configuration-section '%s' : '%s'\",\n205         \"bad-configuration-section\",\n206         \"Used when we detect a setting in the top level of a toml configuration that shouldn't be there.\",\n207         {\"scope\": WarningScope.LINE},\n208     ),\n209     \"E0015\": (\n210         \"Unrecognized option found: %s\",\n211         \"unrecognized-option\",\n212         \"Used when we detect an option that we do not recognize.\",\n213         {\"scope\": WarningScope.LINE},\n214     ),\n215 }\n216 \n217 \n218 # pylint: disable=too-many-instance-attributes,too-many-public-methods\n219 class PyLinter(\n220     _ArgumentsManager,\n221     _MessageStateHandler,\n222     reporters.ReportsHandlerMixIn,\n223     checkers.BaseChecker,\n224 ):\n225     \"\"\"Lint Python modules using external checkers.\n226 \n227     This is the main checker controlling the other ones and the reports\n228     generation. It is itself both a raw checker and an astroid checker in order\n229     to:\n230     * handle message activation / deactivation at the module level\n231     * handle some basic but necessary stats' data (number of classes, methods...)\n232 \n233     IDE plugin developers: you may have to call\n234     `astroid.builder.MANAGER.astroid_cache.clear()` across runs if you want\n235     to ensure the latest code version is actually checked.\n236 \n237     This class needs to support pickling for parallel linting to work. The exception\n238     is reporter member; see check_parallel function for more details.\n239     \"\"\"\n240 \n241     name = MAIN_CHECKER_NAME\n242     msgs = MSGS\n243     # Will be used like this : datetime.now().strftime(crash_file_path)\n244     crash_file_path: str = \"pylint-crash-%Y-%m-%d-%H.txt\"\n245 \n246     option_groups_descs = {\n247         \"Messages control\": \"Options controlling analysis messages\",\n248         \"Reports\": \"Options related to output formatting and reporting\",\n249     }\n250 \n251     def __init__(\n252         self,\n253         options: Options = (),\n254         reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,\n255         option_groups: tuple[tuple[str, str], ...] = (),\n256         # TODO: Deprecate passing the pylintrc parameter\n257         pylintrc: str | None = None,  # pylint: disable=unused-argument\n258     ) -> None:\n259         _ArgumentsManager.__init__(self, prog=\"pylint\")\n260         _MessageStateHandler.__init__(self, self)\n261 \n262         # Some stuff has to be done before initialization of other ancestors...\n263         # messages store / checkers / reporter / astroid manager\n264 \n265         # Attributes for reporters\n266         self.reporter: reporters.BaseReporter | reporters.MultiReporter\n267         if reporter:\n268             self.set_reporter(reporter)\n269         else:\n270             self.set_reporter(TextReporter())\n271         self._reporters: dict[str, type[reporters.BaseReporter]] = {}\n272         \"\"\"Dictionary of possible but non-initialized reporters.\"\"\"\n273 \n274         # Attributes for checkers and plugins\n275         self._checkers: defaultdict[\n276             str, list[checkers.BaseChecker]\n277         ] = collections.defaultdict(list)\n278         \"\"\"Dictionary of registered and initialized checkers.\"\"\"\n279         self._dynamic_plugins: set[str] = set()\n280         \"\"\"Set of loaded plugin names.\"\"\"\n281 \n282         # Attributes related to registering messages and their handling\n283         self.msgs_store = MessageDefinitionStore()\n284         self.msg_status = 0\n285         self._by_id_managed_msgs: list[ManagedMessage] = []\n286 \n287         # Attributes related to visiting files\n288         self.file_state = FileState(\"\", self.msgs_store, is_base_filestate=True)\n289         self.current_name: str | None = None\n290         self.current_file: str | None = None\n291         self._ignore_file = False\n292 \n293         # Attributes related to stats\n294         self.stats = LinterStats()\n295 \n296         # Attributes related to (command-line) options and their parsing\n297         self.options: Options = options + _make_linter_options(self)\n298         for opt_group in option_groups:\n299             self.option_groups_descs[opt_group[0]] = opt_group[1]\n300         self._option_groups: tuple[tuple[str, str], ...] = option_groups + (\n301             (\"Messages control\", \"Options controlling analysis messages\"),\n302             (\"Reports\", \"Options related to output formatting and reporting\"),\n303         )\n304         self.fail_on_symbols: list[str] = []\n305         \"\"\"List of message symbols on which pylint should fail, set by --fail-on.\"\"\"\n306         self._error_mode = False\n307 \n308         reporters.ReportsHandlerMixIn.__init__(self)\n309         checkers.BaseChecker.__init__(self, self)\n310         # provided reports\n311         self.reports = (\n312             (\"RP0001\", \"Messages by category\", report_total_messages_stats),\n313             (\n314                 \"RP0002\",\n315                 \"% errors / warnings by module\",\n316                 report_messages_by_module_stats,\n317             ),\n318             (\"RP0003\", \"Messages\", report_messages_stats),\n319         )\n320         self.register_checker(self)\n321 \n322     @property\n323     def option_groups(self) -> tuple[tuple[str, str], ...]:\n324         # TODO: 3.0: Remove deprecated attribute\n325         warnings.warn(\n326             \"The option_groups attribute has been deprecated and will be removed in pylint 3.0\",\n327             DeprecationWarning,\n328         )\n329         return self._option_groups\n330 \n331     @option_groups.setter\n332     def option_groups(self, value: tuple[tuple[str, str], ...]) -> None:\n333         warnings.warn(\n334             \"The option_groups attribute has been deprecated and will be removed in pylint 3.0\",\n335             DeprecationWarning,\n336         )\n337         self._option_groups = value\n338 \n339     def load_default_plugins(self) -> None:\n340         checkers.initialize(self)\n341         reporters.initialize(self)\n342 \n343     def load_plugin_modules(self, modnames: list[str]) -> None:\n344         \"\"\"Check a list pylint plugins modules, load and register them.\"\"\"\n345         for modname in modnames:\n346             if modname in self._dynamic_plugins:\n347                 continue\n348             self._dynamic_plugins.add(modname)\n349             try:\n350                 module = astroid.modutils.load_module_from_name(modname)\n351                 module.register(self)\n352             except ModuleNotFoundError:\n353                 pass\n354 \n355     def load_plugin_configuration(self) -> None:\n356         \"\"\"Call the configuration hook for plugins.\n357 \n358         This walks through the list of plugins, grabs the \"load_configuration\"\n359         hook, if exposed, and calls it to allow plugins to configure specific\n360         settings.\n361         \"\"\"\n362         for modname in self._dynamic_plugins:\n363             try:\n364                 module = astroid.modutils.load_module_from_name(modname)\n365                 if hasattr(module, \"load_configuration\"):\n366                     module.load_configuration(self)\n367             except ModuleNotFoundError as e:\n368                 self.add_message(\"bad-plugin-value\", args=(modname, e), line=0)\n369 \n370     def _load_reporters(self, reporter_names: str) -> None:\n371         \"\"\"Load the reporters if they are available on _reporters.\"\"\"\n372         if not self._reporters:\n373             return\n374         sub_reporters = []\n375         output_files = []\n376         with contextlib.ExitStack() as stack:\n377             for reporter_name in reporter_names.split(\",\"):\n378                 reporter_name, *reporter_output = reporter_name.split(\":\", 1)\n379 \n380                 reporter = self._load_reporter_by_name(reporter_name)\n381                 sub_reporters.append(reporter)\n382                 if reporter_output:\n383                     output_file = stack.enter_context(\n384                         open(reporter_output[0], \"w\", encoding=\"utf-8\")\n385                     )\n386                     reporter.out = output_file\n387                     output_files.append(output_file)\n388 \n389             # Extend the lifetime of all opened output files\n390             close_output_files = stack.pop_all().close\n391 \n392         if len(sub_reporters) > 1 or output_files:\n393             self.set_reporter(\n394                 reporters.MultiReporter(\n395                     sub_reporters,\n396                     close_output_files,\n397                 )\n398             )\n399         else:\n400             self.set_reporter(sub_reporters[0])\n401 \n402     def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:\n403         name = reporter_name.lower()\n404         if name in self._reporters:\n405             return self._reporters[name]()\n406 \n407         try:\n408             reporter_class = _load_reporter_by_class(reporter_name)\n409         except (ImportError, AttributeError, AssertionError) as e:\n410             raise exceptions.InvalidReporterError(name) from e\n411         else:\n412             return reporter_class()\n413 \n414     def set_reporter(\n415         self, reporter: reporters.BaseReporter | reporters.MultiReporter\n416     ) -> None:\n417         \"\"\"Set the reporter used to display messages and reports.\"\"\"\n418         self.reporter = reporter\n419         reporter.linter = self\n420 \n421     def register_reporter(self, reporter_class: type[reporters.BaseReporter]) -> None:\n422         \"\"\"Registers a reporter class on the _reporters attribute.\"\"\"\n423         self._reporters[reporter_class.name] = reporter_class\n424 \n425     def report_order(self) -> list[BaseChecker]:\n426         reports = sorted(self._reports, key=lambda x: getattr(x, \"name\", \"\"))\n427         try:\n428             # Remove the current reporter and add it\n429             # at the end of the list.\n430             reports.pop(reports.index(self))\n431         except ValueError:\n432             pass\n433         else:\n434             reports.append(self)\n435         return reports\n436 \n437     # checkers manipulation methods ############################################\n438 \n439     def register_checker(self, checker: checkers.BaseChecker) -> None:\n440         \"\"\"This method auto registers the checker.\"\"\"\n441         self._checkers[checker.name].append(checker)\n442         for r_id, r_title, r_cb in checker.reports:\n443             self.register_report(r_id, r_title, r_cb, checker)\n444         if hasattr(checker, \"msgs\"):\n445             self.msgs_store.register_messages_from_checker(checker)\n446         # Register the checker, but disable all of its messages.\n447         if not getattr(checker, \"enabled\", True):\n448             self.disable(checker.name)\n449 \n450     def enable_fail_on_messages(self) -> None:\n451         \"\"\"Enable 'fail on' msgs.\n452 \n453         Convert values in config.fail_on (which might be msg category, msg id,\n454         or symbol) to specific msgs, then enable and flag them for later.\n455         \"\"\"\n456         fail_on_vals = self.config.fail_on\n457         if not fail_on_vals:\n458             return\n459 \n460         fail_on_cats = set()\n461         fail_on_msgs = set()\n462         for val in fail_on_vals:\n463             # If value is a category, add category, else add message\n464             if val in MSG_TYPES:\n465                 fail_on_cats.add(val)\n466             else:\n467                 fail_on_msgs.add(val)\n468 \n469         # For every message in every checker, if cat or msg flagged, enable check\n470         for all_checkers in self._checkers.values():\n471             for checker in all_checkers:\n472                 for msg in checker.messages:\n473                     if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:\n474                         # message id/symbol matched, enable and flag it\n475                         self.enable(msg.msgid)\n476                         self.fail_on_symbols.append(msg.symbol)\n477                     elif msg.msgid[0] in fail_on_cats:\n478                         # message starts with a category value, flag (but do not enable) it\n479                         self.fail_on_symbols.append(msg.symbol)\n480 \n481     def any_fail_on_issues(self) -> bool:\n482         return any(x in self.fail_on_symbols for x in self.stats.by_msg.keys())\n483 \n484     def disable_reporters(self) -> None:\n485         \"\"\"Disable all reporters.\"\"\"\n486         for _reporters in self._reports.values():\n487             for report_id, _, _ in _reporters:\n488                 self.disable_report(report_id)\n489 \n490     def _parse_error_mode(self) -> None:\n491         \"\"\"Parse the current state of the error mode.\n492 \n493         Error mode: enable only errors; no reports, no persistent.\n494         \"\"\"\n495         if not self._error_mode:\n496             return\n497 \n498         self.disable_noerror_messages()\n499         self.disable(\"miscellaneous\")\n500         self.set_option(\"reports\", False)\n501         self.set_option(\"persistent\", False)\n502         self.set_option(\"score\", False)\n503 \n504     # code checking methods ###################################################\n505 \n506     def get_checkers(self) -> list[BaseChecker]:\n507         \"\"\"Return all available checkers as an ordered list.\"\"\"\n508         return sorted(c for _checkers in self._checkers.values() for c in _checkers)\n509 \n510     def get_checker_names(self) -> list[str]:\n511         \"\"\"Get all the checker names that this linter knows about.\"\"\"\n512         return sorted(\n513             {\n514                 checker.name\n515                 for checker in self.get_checkers()\n516                 if checker.name != MAIN_CHECKER_NAME\n517             }\n518         )\n519 \n520     def prepare_checkers(self) -> list[BaseChecker]:\n521         \"\"\"Return checkers needed for activated messages and reports.\"\"\"\n522         if not self.config.reports:\n523             self.disable_reporters()\n524         # get needed checkers\n525         needed_checkers: list[BaseChecker] = [self]\n526         for checker in self.get_checkers()[1:]:\n527             messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}\n528             if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):\n529                 needed_checkers.append(checker)\n530         return needed_checkers\n531 \n532     # pylint: disable=unused-argument\n533     @staticmethod\n534     def should_analyze_file(modname: str, path: str, is_argument: bool = False) -> bool:\n535         \"\"\"Returns whether a module should be checked.\n536 \n537         This implementation returns True for all python source file, indicating\n538         that all files should be linted.\n539 \n540         Subclasses may override this method to indicate that modules satisfying\n541         certain conditions should not be linted.\n542 \n543         :param str modname: The name of the module to be checked.\n544         :param str path: The full path to the source code of the module.\n545         :param bool is_argument: Whether the file is an argument to pylint or not.\n546                                  Files which respect this property are always\n547                                  checked, since the user requested it explicitly.\n548         :returns: True if the module should be checked.\n549         \"\"\"\n550         if is_argument:\n551             return True\n552         return path.endswith(\".py\")\n553 \n554     # pylint: enable=unused-argument\n555 \n556     def initialize(self) -> None:\n557         \"\"\"Initialize linter for linting.\n558 \n559         This method is called before any linting is done.\n560         \"\"\"\n561         # initialize msgs_state now that all messages have been registered into\n562         # the store\n563         for msg in self.msgs_store.messages:\n564             if not msg.may_be_emitted():\n565                 self._msgs_state[msg.msgid] = False\n566 \n567     @staticmethod\n568     def _discover_files(files_or_modules: Sequence[str]) -> Iterator[str]:\n569         \"\"\"Discover python modules and packages in sub-directory.\n570 \n571         Returns iterator of paths to discovered modules and packages.\n572         \"\"\"\n573         for something in files_or_modules:\n574             if os.path.isdir(something) and not os.path.isfile(\n575                 os.path.join(something, \"__init__.py\")\n576             ):\n577                 skip_subtrees: list[str] = []\n578                 for root, _, files in os.walk(something):\n579                     if any(root.startswith(s) for s in skip_subtrees):\n580                         # Skip subtree of already discovered package.\n581                         continue\n582                     if \"__init__.py\" in files:\n583                         skip_subtrees.append(root)\n584                         yield root\n585                     else:\n586                         yield from (\n587                             os.path.join(root, file)\n588                             for file in files\n589                             if file.endswith(\".py\")\n590                         )\n591             else:\n592                 yield something\n593 \n594     def check(self, files_or_modules: Sequence[str] | str) -> None:\n595         \"\"\"Main checking entry: check a list of files or modules from their name.\n596 \n597         files_or_modules is either a string or list of strings presenting modules to check.\n598         \"\"\"\n599         self.initialize()\n600         if not isinstance(files_or_modules, (list, tuple)):\n601             # TODO: 3.0: Remove deprecated typing and update docstring\n602             warnings.warn(\n603                 \"In pylint 3.0, the checkers check function will only accept sequence of string\",\n604                 DeprecationWarning,\n605             )\n606             files_or_modules = (files_or_modules,)  # type: ignore[assignment]\n607         if self.config.recursive:\n608             files_or_modules = tuple(self._discover_files(files_or_modules))\n609         if self.config.from_stdin:\n610             if len(files_or_modules) != 1:\n611                 raise exceptions.InvalidArgsError(\n612                     \"Missing filename required for --from-stdin\"\n613                 )\n614 \n615             filepath = files_or_modules[0]\n616             with fix_import_path(files_or_modules):\n617                 self._check_files(\n618                     functools.partial(self.get_ast, data=_read_stdin()),\n619                     [self._get_file_descr_from_stdin(filepath)],\n620                 )\n621         elif self.config.jobs == 1:\n622             with fix_import_path(files_or_modules):\n623                 self._check_files(\n624                     self.get_ast, self._iterate_file_descrs(files_or_modules)\n625                 )\n626         else:\n627             check_parallel(\n628                 self,\n629                 self.config.jobs,\n630                 self._iterate_file_descrs(files_or_modules),\n631                 files_or_modules,\n632             )\n633 \n634     def check_single_file(self, name: str, filepath: str, modname: str) -> None:\n635         warnings.warn(\n636             \"In pylint 3.0, the checkers check_single_file function will be removed. \"\n637             \"Use check_single_file_item instead.\",\n638             DeprecationWarning,\n639         )\n640         self.check_single_file_item(FileItem(name, filepath, modname))\n641 \n642     def check_single_file_item(self, file: FileItem) -> None:\n643         \"\"\"Check single file item.\n644 \n645         The arguments are the same that are documented in _check_files\n646 \n647         initialize() should be called before calling this method\n648         \"\"\"\n649         with self._astroid_module_checker() as check_astroid_module:\n650             self._check_file(self.get_ast, check_astroid_module, file)\n651 \n652     def _check_files(\n653         self,\n654         get_ast: GetAstProtocol,\n655         file_descrs: Iterable[FileItem],\n656     ) -> None:\n657         \"\"\"Check all files from file_descrs.\"\"\"\n658         with self._astroid_module_checker() as check_astroid_module:\n659             for file in file_descrs:\n660                 try:\n661                     self._check_file(get_ast, check_astroid_module, file)\n662                 except Exception as ex:  # pylint: disable=broad-except\n663                     template_path = prepare_crash_report(\n664                         ex, file.filepath, self.crash_file_path\n665                     )\n666                     msg = get_fatal_error_message(file.filepath, template_path)\n667                     if isinstance(ex, AstroidError):\n668                         symbol = \"astroid-error\"\n669                         self.add_message(symbol, args=(file.filepath, msg))\n670                     else:\n671                         symbol = \"fatal\"\n672                         self.add_message(symbol, args=msg)\n673 \n674     def _check_file(\n675         self,\n676         get_ast: GetAstProtocol,\n677         check_astroid_module: Callable[[nodes.Module], bool | None],\n678         file: FileItem,\n679     ) -> None:\n680         \"\"\"Check a file using the passed utility functions (get_ast and check_astroid_module).\n681 \n682         :param callable get_ast: callable returning AST from defined file taking the following arguments\n683         - filepath: path to the file to check\n684         - name: Python module name\n685         :param callable check_astroid_module: callable checking an AST taking the following arguments\n686         - ast: AST of the module\n687         :param FileItem file: data about the file\n688         \"\"\"\n689         self.set_current_module(file.name, file.filepath)\n690         # get the module representation\n691         ast_node = get_ast(file.filepath, file.name)\n692         if ast_node is None:\n693             return\n694 \n695         self._ignore_file = False\n696 \n697         self.file_state = FileState(file.modpath, self.msgs_store, ast_node)\n698         # fix the current file (if the source file was not available or\n699         # if it's actually a c extension)\n700         self.current_file = ast_node.file\n701         check_astroid_module(ast_node)\n702         # warn about spurious inline messages handling\n703         spurious_messages = self.file_state.iter_spurious_suppression_messages(\n704             self.msgs_store\n705         )\n706         for msgid, line, args in spurious_messages:\n707             self.add_message(msgid, line, None, args)\n708 \n709     @staticmethod\n710     def _get_file_descr_from_stdin(filepath: str) -> FileItem:\n711         \"\"\"Return file description (tuple of module name, file path, base name) from given file path.\n712 \n713         This method is used for creating suitable file description for _check_files when the\n714         source is standard input.\n715         \"\"\"\n716         try:\n717             # Note that this function does not really perform an\n718             # __import__ but may raise an ImportError exception, which\n719             # we want to catch here.\n720             modname = \".\".join(astroid.modutils.modpath_from_file(filepath))\n721         except ImportError:\n722             modname = os.path.splitext(os.path.basename(filepath))[0]\n723 \n724         return FileItem(modname, filepath, filepath)\n725 \n726     def _iterate_file_descrs(\n727         self, files_or_modules: Sequence[str]\n728     ) -> Iterator[FileItem]:\n729         \"\"\"Return generator yielding file descriptions (tuples of module name, file path, base name).\n730 \n731         The returned generator yield one item for each Python module that should be linted.\n732         \"\"\"\n733         for descr in self._expand_files(files_or_modules):\n734             name, filepath, is_arg = descr[\"name\"], descr[\"path\"], descr[\"isarg\"]\n735             if self.should_analyze_file(name, filepath, is_argument=is_arg):\n736                 yield FileItem(name, filepath, descr[\"basename\"])\n737 \n738     def _expand_files(self, modules: Sequence[str]) -> list[ModuleDescriptionDict]:\n739         \"\"\"Get modules and errors from a list of modules and handle errors.\"\"\"\n740         result, errors = expand_modules(\n741             modules,\n742             self.config.ignore,\n743             self.config.ignore_patterns,\n744             self._ignore_paths,\n745         )\n746         for error in errors:\n747             message = modname = error[\"mod\"]\n748             key = error[\"key\"]\n749             self.set_current_module(modname)\n750             if key == \"fatal\":\n751                 message = str(error[\"ex\"]).replace(os.getcwd() + os.sep, \"\")\n752             self.add_message(key, args=message)\n753         return result\n754 \n755     def set_current_module(\n756         self, modname: str | None, filepath: str | None = None\n757     ) -> None:\n758         \"\"\"Set the name of the currently analyzed module and\n759         init statistics for it.\n760         \"\"\"\n761         if not modname and filepath is None:\n762             return\n763         self.reporter.on_set_current_module(modname or \"\", filepath)\n764         if modname is None:\n765             # TODO: 3.0: Remove all modname or \"\"'s in this method\n766             warnings.warn(\n767                 (\n768                     \"In pylint 3.0 modname should be a string so that it can be used to \"\n769                     \"correctly set the current_name attribute of the linter instance. \"\n770                     \"If unknown it should be initialized as an empty string.\"\n771                 ),\n772                 DeprecationWarning,\n773             )\n774         self.current_name = modname\n775         self.current_file = filepath or modname\n776         self.stats.init_single_module(modname or \"\")\n777 \n778     @contextlib.contextmanager\n779     def _astroid_module_checker(\n780         self,\n781     ) -> Iterator[Callable[[nodes.Module], bool | None]]:\n782         \"\"\"Context manager for checking ASTs.\n783 \n784         The value in the context is callable accepting AST as its only argument.\n785         \"\"\"\n786         walker = ASTWalker(self)\n787         _checkers = self.prepare_checkers()\n788         tokencheckers = [\n789             c\n790             for c in _checkers\n791             if isinstance(c, checkers.BaseTokenChecker) and c is not self\n792         ]\n793         # TODO: 3.0: Remove deprecated for-loop\n794         for c in _checkers:\n795             with warnings.catch_warnings():\n796                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n797                 if (\n798                     interfaces.implements(c, interfaces.ITokenChecker)\n799                     and c not in tokencheckers\n800                     and c is not self\n801                 ):\n802                     tokencheckers.append(c)  # type: ignore[arg-type]  # pragma: no cover\n803                     warnings.warn(  # pragma: no cover\n804                         \"Checkers should subclass BaseTokenChecker \"\n805                         \"instead of using the __implements__ mechanism. Use of __implements__ \"\n806                         \"will no longer be supported in pylint 3.0\",\n807                         DeprecationWarning,\n808                     )\n809         rawcheckers = [\n810             c for c in _checkers if isinstance(c, checkers.BaseRawFileChecker)\n811         ]\n812         # TODO: 3.0: Remove deprecated if-statement\n813         for c in _checkers:\n814             with warnings.catch_warnings():\n815                 warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n816                 if (\n817                     interfaces.implements(c, interfaces.IRawChecker)\n818                     and c not in rawcheckers\n819                 ):\n820                     rawcheckers.append(c)  # type: ignore[arg-type] # pragma: no cover\n821                     warnings.warn(  # pragma: no cover\n822                         \"Checkers should subclass BaseRawFileChecker \"\n823                         \"instead of using the __implements__ mechanism. Use of __implements__ \"\n824                         \"will no longer be supported in pylint 3.0\",\n825                         DeprecationWarning,\n826                     )\n827         # notify global begin\n828         for checker in _checkers:\n829             checker.open()\n830             walker.add_checker(checker)\n831 \n832         yield functools.partial(\n833             self.check_astroid_module,\n834             walker=walker,\n835             tokencheckers=tokencheckers,\n836             rawcheckers=rawcheckers,\n837         )\n838 \n839         # notify global end\n840         self.stats.statement = walker.nbstatements\n841         for checker in reversed(_checkers):\n842             checker.close()\n843 \n844     def get_ast(\n845         self, filepath: str, modname: str, data: str | None = None\n846     ) -> nodes.Module:\n847         \"\"\"Return an ast(roid) representation of a module or a string.\n848 \n849         :param str filepath: path to checked file.\n850         :param str modname: The name of the module to be checked.\n851         :param str data: optional contents of the checked file.\n852         :returns: the AST\n853         :rtype: astroid.nodes.Module\n854         :raises AstroidBuildingError: Whenever we encounter an unexpected exception\n855         \"\"\"\n856         try:\n857             if data is None:\n858                 return MANAGER.ast_from_file(filepath, modname, source=True)\n859             return astroid.builder.AstroidBuilder(MANAGER).string_build(\n860                 data, modname, filepath\n861             )\n862         except astroid.AstroidSyntaxError as ex:\n863             # pylint: disable=no-member\n864             self.add_message(\n865                 \"syntax-error\",\n866                 line=getattr(ex.error, \"lineno\", 0),\n867                 col_offset=getattr(ex.error, \"offset\", None),\n868                 args=str(ex.error),\n869             )\n870         except astroid.AstroidBuildingError as ex:\n871             self.add_message(\"parse-error\", args=ex)\n872         except Exception as ex:\n873             traceback.print_exc()\n874             # We raise BuildingError here as this is essentially an astroid issue\n875             # Creating an issue template and adding the 'astroid-error' message is handled\n876             # by caller: _check_files\n877             raise astroid.AstroidBuildingError(\n878                 \"Building error when trying to create ast representation of module '{modname}'\",\n879                 modname=modname,\n880             ) from ex\n881         return None\n882 \n883     def check_astroid_module(\n884         self,\n885         ast_node: nodes.Module,\n886         walker: ASTWalker,\n887         rawcheckers: list[checkers.BaseRawFileChecker],\n888         tokencheckers: list[checkers.BaseTokenChecker],\n889     ) -> bool | None:\n890         \"\"\"Check a module from its astroid representation.\n891 \n892         For return value see _check_astroid_module\n893         \"\"\"\n894         before_check_statements = walker.nbstatements\n895 \n896         retval = self._check_astroid_module(\n897             ast_node, walker, rawcheckers, tokencheckers\n898         )\n899 \n900         # TODO: 3.0: Remove unnecessary assertion\n901         assert self.current_name\n902 \n903         self.stats.by_module[self.current_name][\"statement\"] = (\n904             walker.nbstatements - before_check_statements\n905         )\n906 \n907         return retval\n908 \n909     def _check_astroid_module(\n910         self,\n911         node: nodes.Module,\n912         walker: ASTWalker,\n913         rawcheckers: list[checkers.BaseRawFileChecker],\n914         tokencheckers: list[checkers.BaseTokenChecker],\n915     ) -> bool | None:\n916         \"\"\"Check given AST node with given walker and checkers.\n917 \n918         :param astroid.nodes.Module node: AST node of the module to check\n919         :param pylint.utils.ast_walker.ASTWalker walker: AST walker\n920         :param list rawcheckers: List of token checkers to use\n921         :param list tokencheckers: List of raw checkers to use\n922 \n923         :returns: True if the module was checked, False if ignored,\n924             None if the module contents could not be parsed\n925         \"\"\"\n926         try:\n927             tokens = utils.tokenize_module(node)\n928         except tokenize.TokenError as ex:\n929             self.add_message(\"syntax-error\", line=ex.args[1][0], args=ex.args[0])\n930             return None\n931 \n932         if not node.pure_python:\n933             self.add_message(\"raw-checker-failed\", args=node.name)\n934         else:\n935             # assert astroid.file.endswith('.py')\n936             # Parse module/block level option pragma's\n937             self.process_tokens(tokens)\n938             if self._ignore_file:\n939                 return False\n940             # walk ast to collect line numbers\n941             self.file_state.collect_block_lines(self.msgs_store, node)\n942             # run raw and tokens checkers\n943             for raw_checker in rawcheckers:\n944                 raw_checker.process_module(node)\n945             for token_checker in tokencheckers:\n946                 token_checker.process_tokens(tokens)\n947         # generate events to astroid checkers\n948         walker.walk(node)\n949         return True\n950 \n951     def open(self) -> None:\n952         \"\"\"Initialize counters.\"\"\"\n953         self.stats = LinterStats()\n954         MANAGER.always_load_extensions = self.config.unsafe_load_any_extension\n955         MANAGER.max_inferable_values = self.config.limit_inference_results\n956         MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)\n957         if self.config.extension_pkg_whitelist:\n958             MANAGER.extension_package_whitelist.update(\n959                 self.config.extension_pkg_whitelist\n960             )\n961         self.stats.reset_message_count()\n962         self._ignore_paths = self.linter.config.ignore_paths\n963 \n964     def generate_reports(self) -> int | None:\n965         \"\"\"Close the whole package /module, it's time to make reports !\n966 \n967         if persistent run, pickle results for later comparison\n968         \"\"\"\n969         # Display whatever messages are left on the reporter.\n970         self.reporter.display_messages(report_nodes.Section())\n971 \n972         # TODO: 3.0: Remove second half of if-statement\n973         if (\n974             not self.file_state._is_base_filestate\n975             and self.file_state.base_name is not None\n976         ):\n977             # load previous results if any\n978             previous_stats = load_results(self.file_state.base_name)\n979             self.reporter.on_close(self.stats, previous_stats)\n980             if self.config.reports:\n981                 sect = self.make_reports(self.stats, previous_stats)\n982             else:\n983                 sect = report_nodes.Section()\n984 \n985             if self.config.reports:\n986                 self.reporter.display_reports(sect)\n987             score_value = self._report_evaluation()\n988             # save results if persistent run\n989             if self.config.persistent:\n990                 save_results(self.stats, self.file_state.base_name)\n991         else:\n992             self.reporter.on_close(self.stats, LinterStats())\n993             score_value = None\n994         return score_value\n995 \n996     def _report_evaluation(self) -> int | None:\n997         \"\"\"Make the global evaluation report.\"\"\"\n998         # check with at least check 1 statements (usually 0 when there is a\n999         # syntax error preventing pylint from further processing)\n1000         note = None\n1001         # TODO: 3.0: Remove assertion\n1002         assert self.file_state.base_name is not None\n1003         previous_stats = load_results(self.file_state.base_name)\n1004         if self.stats.statement == 0:\n1005             return note\n1006 \n1007         # get a global note for the code\n1008         evaluation = self.config.evaluation\n1009         try:\n1010             stats_dict = {\n1011                 \"fatal\": self.stats.fatal,\n1012                 \"error\": self.stats.error,\n1013                 \"warning\": self.stats.warning,\n1014                 \"refactor\": self.stats.refactor,\n1015                 \"convention\": self.stats.convention,\n1016                 \"statement\": self.stats.statement,\n1017                 \"info\": self.stats.info,\n1018             }\n1019             note = eval(evaluation, {}, stats_dict)  # pylint: disable=eval-used\n1020         except Exception as ex:  # pylint: disable=broad-except\n1021             msg = f\"An exception occurred while rating: {ex}\"\n1022         else:\n1023             self.stats.global_note = note\n1024             msg = f\"Your code has been rated at {note:.2f}/10\"\n1025             if previous_stats:\n1026                 pnote = previous_stats.global_note\n1027                 if pnote is not None:\n1028                     msg += f\" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})\"\n1029 \n1030         if self.config.score:\n1031             sect = report_nodes.EvaluationSection(msg)\n1032             self.reporter.display_reports(sect)\n1033         return note\n1034 \n1035     def _add_one_message(\n1036         self,\n1037         message_definition: MessageDefinition,\n1038         line: int | None,\n1039         node: nodes.NodeNG | None,\n1040         args: Any | None,\n1041         confidence: interfaces.Confidence | None,\n1042         col_offset: int | None,\n1043         end_lineno: int | None,\n1044         end_col_offset: int | None,\n1045     ) -> None:\n1046         \"\"\"After various checks have passed a single Message is\n1047         passed to the reporter and added to stats.\n1048         \"\"\"\n1049         message_definition.check_message_definition(line, node)\n1050 \n1051         # Look up \"location\" data of node if not yet supplied\n1052         if node:\n1053             if node.position:\n1054                 if not line:\n1055                     line = node.position.lineno\n1056                 if not col_offset:\n1057                     col_offset = node.position.col_offset\n1058                 if not end_lineno:\n1059                     end_lineno = node.position.end_lineno\n1060                 if not end_col_offset:\n1061                     end_col_offset = node.position.end_col_offset\n1062             else:\n1063                 if not line:\n1064                     line = node.fromlineno\n1065                 if not col_offset:\n1066                     col_offset = node.col_offset\n1067                 if not end_lineno:\n1068                     end_lineno = node.end_lineno\n1069                 if not end_col_offset:\n1070                     end_col_offset = node.end_col_offset\n1071 \n1072         # should this message be displayed\n1073         if not self.is_message_enabled(message_definition.msgid, line, confidence):\n1074             self.file_state.handle_ignored_message(\n1075                 self._get_message_state_scope(\n1076                     message_definition.msgid, line, confidence\n1077                 ),\n1078                 message_definition.msgid,\n1079                 line,\n1080             )\n1081             return\n1082 \n1083         # update stats\n1084         msg_cat = MSG_TYPES[message_definition.msgid[0]]\n1085         self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]\n1086         self.stats.increase_single_message_count(msg_cat, 1)\n1087         self.stats.increase_single_module_message_count(\n1088             self.current_name,  # type: ignore[arg-type] # Should be removable after https://github.com/PyCQA/pylint/pull/5580\n1089             msg_cat,\n1090             1,\n1091         )\n1092         try:\n1093             self.stats.by_msg[message_definition.symbol] += 1\n1094         except KeyError:\n1095             self.stats.by_msg[message_definition.symbol] = 1\n1096         # Interpolate arguments into message string\n1097         msg = message_definition.msg\n1098         if args is not None:\n1099             msg %= args\n1100         # get module and object\n1101         if node is None:\n1102             module, obj = self.current_name, \"\"\n1103             abspath = self.current_file\n1104         else:\n1105             module, obj = utils.get_module_and_frameid(node)\n1106             abspath = node.root().file\n1107         if abspath is not None:\n1108             path = abspath.replace(self.reporter.path_strip_prefix, \"\", 1)\n1109         else:\n1110             path = \"configuration\"\n1111         # add the message\n1112         self.reporter.handle_message(\n1113             Message(\n1114                 message_definition.msgid,\n1115                 message_definition.symbol,\n1116                 MessageLocationTuple(\n1117                     abspath or \"\",\n1118                     path,\n1119                     module or \"\",\n1120                     obj,\n1121                     line or 1,\n1122                     col_offset or 0,\n1123                     end_lineno,\n1124                     end_col_offset,\n1125                 ),\n1126                 msg,\n1127                 confidence,\n1128             )\n1129         )\n1130 \n1131     def add_message(\n1132         self,\n1133         msgid: str,\n1134         line: int | None = None,\n1135         node: nodes.NodeNG | None = None,\n1136         args: Any | None = None,\n1137         confidence: interfaces.Confidence | None = None,\n1138         col_offset: int | None = None,\n1139         end_lineno: int | None = None,\n1140         end_col_offset: int | None = None,\n1141     ) -> None:\n1142         \"\"\"Adds a message given by ID or name.\n1143 \n1144         If provided, the message string is expanded using args.\n1145 \n1146         AST checkers must provide the node argument (but may optionally\n1147         provide line if the line number is different), raw and token checkers\n1148         must provide the line argument.\n1149         \"\"\"\n1150         if confidence is None:\n1151             confidence = interfaces.UNDEFINED\n1152         message_definitions = self.msgs_store.get_message_definitions(msgid)\n1153         for message_definition in message_definitions:\n1154             self._add_one_message(\n1155                 message_definition,\n1156                 line,\n1157                 node,\n1158                 args,\n1159                 confidence,\n1160                 col_offset,\n1161                 end_lineno,\n1162                 end_col_offset,\n1163             )\n1164 \n1165     def add_ignored_message(\n1166         self,\n1167         msgid: str,\n1168         line: int,\n1169         node: nodes.NodeNG | None = None,\n1170         confidence: interfaces.Confidence | None = interfaces.UNDEFINED,\n1171     ) -> None:\n1172         \"\"\"Prepares a message to be added to the ignored message storage.\n1173 \n1174         Some checks return early in special cases and never reach add_message(),\n1175         even though they would normally issue a message.\n1176         This creates false positives for useless-suppression.\n1177         This function avoids this by adding those message to the ignored msgs attribute\n1178         \"\"\"\n1179         message_definitions = self.msgs_store.get_message_definitions(msgid)\n1180         for message_definition in message_definitions:\n1181             message_definition.check_message_definition(line, node)\n1182             self.file_state.handle_ignored_message(\n1183                 self._get_message_state_scope(\n1184                     message_definition.msgid, line, confidence\n1185                 ),\n1186                 message_definition.msgid,\n1187                 line,\n1188             )\n",
        "intended_behavior": "Ensure that any specified ignore patterns or paths are reliably captured and applied."
    }
]