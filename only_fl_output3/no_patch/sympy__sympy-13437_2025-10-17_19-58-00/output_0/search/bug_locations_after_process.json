[
    {
        "rel_file_path": "sympy/functions/combinatorial/numbers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1/sympy/functions/combinatorial/numbers.py",
        "start": 1,
        "end": 1651,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 This module implements some special functions that commonly appear in\n3 combinatorial contexts (e.g. in power series); in particular,\n4 sequences of rational numbers such as Bernoulli and Fibonacci numbers.\n5 \n6 Factorials, binomial coefficients and related functions are located in\n7 the separate 'factorials' module.\n8 \"\"\"\n9 \n10 from __future__ import print_function, division\n11 \n12 from sympy.core import S, Symbol, Rational, Integer, Add, Dummy\n13 from sympy.core.compatibility import as_int, SYMPY_INTS, range\n14 from sympy.core.cache import cacheit\n15 from sympy.core.function import Function, expand_mul\n16 from sympy.core.numbers import E, pi\n17 from sympy.core.relational import LessThan, StrictGreaterThan\n18 from sympy.functions.combinatorial.factorials import binomial, factorial\n19 from sympy.functions.elementary.exponential import log\n20 from sympy.functions.elementary.integers import floor\n21 from sympy.functions.elementary.trigonometric import sin, cos, cot\n22 from sympy.functions.elementary.miscellaneous import sqrt\n23 from sympy.utilities.memoization import recurrence_memo\n24 \n25 from mpmath import bernfrac, workprec\n26 from mpmath.libmp import ifib as _ifib\n27 \n28 \n29 def _product(a, b):\n30     p = 1\n31     for k in range(a, b + 1):\n32         p *= k\n33     return p\n34 \n35 \n36 \n37 # Dummy symbol used for computing polynomial sequences\n38 _sym = Symbol('x')\n39 _symbols = Function('x')\n40 \n41 \n42 #----------------------------------------------------------------------------#\n43 #                                                                            #\n44 #                           Fibonacci numbers                                #\n45 #                                                                            #\n46 #----------------------------------------------------------------------------#\n47 \n48 class fibonacci(Function):\n49     r\"\"\"\n50     Fibonacci numbers / Fibonacci polynomials\n51 \n52     The Fibonacci numbers are the integer sequence defined by the\n53     initial terms F_0 = 0, F_1 = 1 and the two-term recurrence\n54     relation F_n = F_{n-1} + F_{n-2}.  This definition\n55     extended to arbitrary real and complex arguments using\n56     the formula\n57 \n58     .. math :: F_z = \\frac{\\phi^z - \\cos(\\pi z) \\phi^{-z}}{\\sqrt 5}\n59 \n60     The Fibonacci polynomials are defined by F_1(x) = 1,\n61     F_2(x) = x, and F_n(x) = x*F_{n-1}(x) + F_{n-2}(x) for n > 2.\n62     For all positive integers n, F_n(1) = F_n.\n63 \n64     * fibonacci(n) gives the nth Fibonacci number, F_n\n65     * fibonacci(n, x) gives the nth Fibonacci polynomial in x, F_n(x)\n66 \n67     Examples\n68     ========\n69 \n70     >>> from sympy import fibonacci, Symbol\n71 \n72     >>> [fibonacci(x) for x in range(11)]\n73     [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n74     >>> fibonacci(5, Symbol('t'))\n75     t**4 + 3*t**2 + 1\n76 \n77     References\n78     ==========\n79 \n80     .. [1] http://en.wikipedia.org/wiki/Fibonacci_number\n81     .. [2] http://mathworld.wolfram.com/FibonacciNumber.html\n82 \n83     See Also\n84     ========\n85 \n86     bell, bernoulli, catalan, euler, harmonic, lucas\n87     \"\"\"\n88 \n89     @staticmethod\n90     def _fib(n):\n91         return _ifib(n)\n92 \n93     @staticmethod\n94     @recurrence_memo([None, S.One, _sym])\n95     def _fibpoly(n, prev):\n96         return (prev[-2] + _sym*prev[-1]).expand()\n97 \n98     @classmethod\n99     def eval(cls, n, sym=None):\n100         if n is S.Infinity:\n101             return S.Infinity\n102 \n103         if n.is_Integer:\n104             n = int(n)\n105             if n < 0:\n106                 return S.NegativeOne**(n + 1) * fibonacci(-n)\n107             if sym is None:\n108                 return Integer(cls._fib(n))\n109             else:\n110                 if n < 1:\n111                     raise ValueError(\"Fibonacci polynomials are defined \"\n112                        \"only for positive integer indices.\")\n113                 return cls._fibpoly(n).subs(_sym, sym)\n114 \n115     def _eval_rewrite_as_sqrt(self, n):\n116         return 2**(-n)*sqrt(5)*((1 + sqrt(5))**n - (-sqrt(5) + 1)**n) / 5\n117 \n118     def _eval_rewrite_as_GoldenRatio(self,n):\n119         return (S.GoldenRatio**n - 1/(-S.GoldenRatio)**n)/(2*S.GoldenRatio-1)\n120 \n121 \n122 class lucas(Function):\n123     \"\"\"\n124     Lucas numbers\n125 \n126     Lucas numbers satisfy a recurrence relation similar to that of\n127     the Fibonacci sequence, in which each term is the sum of the\n128     preceding two. They are generated by choosing the initial\n129     values L_0 = 2 and L_1 = 1.\n130 \n131     * lucas(n) gives the nth Lucas number\n132 \n133     Examples\n134     ========\n135 \n136     >>> from sympy import lucas\n137 \n138     >>> [lucas(x) for x in range(11)]\n139     [2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123]\n140 \n141     References\n142     ==========\n143 \n144     .. [1] http://en.wikipedia.org/wiki/Lucas_number\n145     .. [2] http://mathworld.wolfram.com/LucasNumber.html\n146 \n147     See Also\n148     ========\n149 \n150     bell, bernoulli, catalan, euler, fibonacci, harmonic\n151     \"\"\"\n152 \n153     @classmethod\n154     def eval(cls, n):\n155         if n is S.Infinity:\n156             return S.Infinity\n157 \n158         if n.is_Integer:\n159             return fibonacci(n + 1) + fibonacci(n - 1)\n160 \n161     def _eval_rewrite_as_sqrt(self, n):\n162         return 2**(-n)*((1 + sqrt(5))**n + (-sqrt(5) + 1)**n)\n163 \n164 #----------------------------------------------------------------------------#\n165 #                                                                            #\n166 #                           Bernoulli numbers                                #\n167 #                                                                            #\n168 #----------------------------------------------------------------------------#\n169 \n170 \n171 class bernoulli(Function):\n172     r\"\"\"\n173     Bernoulli numbers / Bernoulli polynomials\n174 \n175     The Bernoulli numbers are a sequence of rational numbers\n176     defined by B_0 = 1 and the recursive relation (n > 0)::\n177 \n178                 n\n179                ___\n180               \\      / n + 1 \\\n181           0 =  )     |       | * B .\n182               /___   \\   k   /    k\n183               k = 0\n184 \n185     They are also commonly defined by their exponential generating\n186     function, which is x/(exp(x) - 1). For odd indices > 1, the\n187     Bernoulli numbers are zero.\n188 \n189     The Bernoulli polynomials satisfy the analogous formula::\n190 \n191                     n\n192                    ___\n193                   \\      / n \\         n-k\n194           B (x) =  )     |   | * B  * x   .\n195            n      /___   \\ k /    k\n196                   k = 0\n197 \n198     Bernoulli numbers and Bernoulli polynomials are related as\n199     B_n(0) = B_n.\n200 \n201     We compute Bernoulli numbers using Ramanujan's formula::\n202 \n203                                    / n + 3 \\\n204           B   =  (A(n) - S(n))  /  |       |\n205            n                       \\   n   /\n206 \n207     where A(n) = (n+3)/3 when n = 0 or 2 (mod 6), A(n) = -(n+3)/6\n208     when n = 4 (mod 6), and::\n209 \n210                  [n/6]\n211                   ___\n212                  \\      /  n + 3  \\\n213           S(n) =  )     |         | * B\n214                  /___   \\ n - 6*k /    n-6*k\n215                  k = 1\n216 \n217     This formula is similar to the sum given in the definition, but\n218     cuts 2/3 of the terms. For Bernoulli polynomials, we use the\n219     formula in the definition.\n220 \n221     * bernoulli(n) gives the nth Bernoulli number, B_n\n222     * bernoulli(n, x) gives the nth Bernoulli polynomial in x, B_n(x)\n223 \n224     Examples\n225     ========\n226 \n227     >>> from sympy import bernoulli\n228 \n229     >>> [bernoulli(n) for n in range(11)]\n230     [1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]\n231     >>> bernoulli(1000001)\n232     0\n233 \n234     References\n235     ==========\n236 \n237     .. [1] http://en.wikipedia.org/wiki/Bernoulli_number\n238     .. [2] http://en.wikipedia.org/wiki/Bernoulli_polynomial\n239     .. [3] http://mathworld.wolfram.com/BernoulliNumber.html\n240     .. [4] http://mathworld.wolfram.com/BernoulliPolynomial.html\n241 \n242     See Also\n243     ========\n244 \n245     bell, catalan, euler, fibonacci, harmonic, lucas\n246     \"\"\"\n247 \n248     # Calculates B_n for positive even n\n249     @staticmethod\n250     def _calc_bernoulli(n):\n251         s = 0\n252         a = int(binomial(n + 3, n - 6))\n253         for j in range(1, n//6 + 1):\n254             s += a * bernoulli(n - 6*j)\n255             # Avoid computing each binomial coefficient from scratch\n256             a *= _product(n - 6 - 6*j + 1, n - 6*j)\n257             a //= _product(6*j + 4, 6*j + 9)\n258         if n % 6 == 4:\n259             s = -Rational(n + 3, 6) - s\n260         else:\n261             s = Rational(n + 3, 3) - s\n262         return s / binomial(n + 3, n)\n263 \n264     # We implement a specialized memoization scheme to handle each\n265     # case modulo 6 separately\n266     _cache = {0: S.One, 2: Rational(1, 6), 4: Rational(-1, 30)}\n267     _highest = {0: 0, 2: 2, 4: 4}\n268 \n269     @classmethod\n270     def eval(cls, n, sym=None):\n271         if n.is_Number:\n272             if n.is_Integer and n.is_nonnegative:\n273                 if n is S.Zero:\n274                     return S.One\n275                 elif n is S.One:\n276                     if sym is None:\n277                         return -S.Half\n278                     else:\n279                         return sym - S.Half\n280                 # Bernoulli numbers\n281                 elif sym is None:\n282                     if n.is_odd:\n283                         return S.Zero\n284                     n = int(n)\n285                     # Use mpmath for enormous Bernoulli numbers\n286                     if n > 500:\n287                         p, q = bernfrac(n)\n288                         return Rational(int(p), int(q))\n289                     case = n % 6\n290                     highest_cached = cls._highest[case]\n291                     if n <= highest_cached:\n292                         return cls._cache[n]\n293                     # To avoid excessive recursion when, say, bernoulli(1000) is\n294                     # requested, calculate and cache the entire sequence ... B_988,\n295                     # B_994, B_1000 in increasing order\n296                     for i in range(highest_cached + 6, n + 6, 6):\n297                         b = cls._calc_bernoulli(i)\n298                         cls._cache[i] = b\n299                         cls._highest[case] = i\n300                     return b\n301                 # Bernoulli polynomials\n302                 else:\n303                     n, result = int(n), []\n304                     for k in range(n + 1):\n305                         result.append(binomial(n, k)*cls(k)*sym**(n - k))\n306                     return Add(*result)\n307             else:\n308                 raise ValueError(\"Bernoulli numbers are defined only\"\n309                                  \" for nonnegative integer indices.\")\n310 \n311         if sym is None:\n312             if n.is_odd and (n - 1).is_positive:\n313                 return S.Zero\n314 \n315 \n316 #----------------------------------------------------------------------------#\n317 #                                                                            #\n318 #                             Bell numbers                                   #\n319 #                                                                            #\n320 #----------------------------------------------------------------------------#\n321 \n322 class bell(Function):\n323     r\"\"\"\n324     Bell numbers / Bell polynomials\n325 \n326     The Bell numbers satisfy `B_0 = 1` and\n327 \n328     .. math:: B_n = \\sum_{k=0}^{n-1} \\binom{n-1}{k} B_k.\n329 \n330     They are also given by:\n331 \n332     .. math:: B_n = \\frac{1}{e} \\sum_{k=0}^{\\infty} \\frac{k^n}{k!}.\n333 \n334     The Bell polynomials are given by `B_0(x) = 1` and\n335 \n336     .. math:: B_n(x) = x \\sum_{k=1}^{n-1} \\binom{n-1}{k-1} B_{k-1}(x).\n337 \n338     The second kind of Bell polynomials (are sometimes called \"partial\" Bell\n339     polynomials or incomplete Bell polynomials) are defined as\n340 \n341     .. math:: B_{n,k}(x_1, x_2,\\dotsc x_{n-k+1}) =\n342             \\sum_{j_1+j_2+j_2+\\dotsb=k \\atop j_1+2j_2+3j_2+\\dotsb=n}\n343                 \\frac{n!}{j_1!j_2!\\dotsb j_{n-k+1}!}\n344                 \\left(\\frac{x_1}{1!} \\right)^{j_1}\n345                 \\left(\\frac{x_2}{2!} \\right)^{j_2} \\dotsb\n346                 \\left(\\frac{x_{n-k+1}}{(n-k+1)!} \\right) ^{j_{n-k+1}}.\n347 \n348     * bell(n) gives the `n^{th}` Bell number, `B_n`.\n349     * bell(n, x) gives the `n^{th}` Bell polynomial, `B_n(x)`.\n350     * bell(n, k, (x1, x2, ...)) gives Bell polynomials of the second kind,\n351       `B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1})`.\n352 \n353     Notes\n354     =====\n355 \n356     Not to be confused with Bernoulli numbers and Bernoulli polynomials,\n357     which use the same notation.\n358 \n359     Examples\n360     ========\n361 \n362     >>> from sympy import bell, Symbol, symbols\n363 \n364     >>> [bell(n) for n in range(11)]\n365     [1, 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 115975]\n366     >>> bell(30)\n367     846749014511809332450147\n368     >>> bell(4, Symbol('t'))\n369     t**4 + 6*t**3 + 7*t**2 + t\n370     >>> bell(6, 2, symbols('x:6')[1:])\n371     6*x1*x5 + 15*x2*x4 + 10*x3**2\n372 \n373     References\n374     ==========\n375 \n376     .. [1] http://en.wikipedia.org/wiki/Bell_number\n377     .. [2] http://mathworld.wolfram.com/BellNumber.html\n378     .. [3] http://mathworld.wolfram.com/BellPolynomial.html\n379 \n380     See Also\n381     ========\n382 \n383     bernoulli, catalan, euler, fibonacci, harmonic, lucas\n384     \"\"\"\n385 \n386     @staticmethod\n387     @recurrence_memo([1, 1])\n388     def _bell(n, prev):\n389         s = 1\n390         a = 1\n391         for k in range(1, n):\n392             a = a * (n - k) // k\n393             s += a * prev[k]\n394         return s\n395 \n396     @staticmethod\n397     @recurrence_memo([S.One, _sym])\n398     def _bell_poly(n, prev):\n399         s = 1\n400         a = 1\n401         for k in range(2, n + 1):\n402             a = a * (n - k + 1) // (k - 1)\n403             s += a * prev[k - 1]\n404         return expand_mul(_sym * s)\n405 \n406     @staticmethod\n407     def _bell_incomplete_poly(n, k, symbols):\n408         r\"\"\"\n409         The second kind of Bell polynomials (incomplete Bell polynomials).\n410 \n411         Calculated by recurrence formula:\n412 \n413         .. math:: B_{n,k}(x_1, x_2, \\dotsc, x_{n-k+1}) =\n414                 \\sum_{m=1}^{n-k+1}\n415                 \\x_m \\binom{n-1}{m-1} B_{n-m,k-1}(x_1, x_2, \\dotsc, x_{n-m-k})\n416 \n417         where\n418             B_{0,0} = 1;\n419             B_{n,0} = 0; for n>=1\n420             B_{0,k} = 0; for k>=1\n421 \n422         \"\"\"\n423         if (n == 0) and (k == 0):\n424             return S.One\n425         elif (n == 0) or (k == 0):\n426             return S.Zero\n427         s = S.Zero\n428         a = S.One\n429         for m in range(1, n - k + 2):\n430             s += a * bell._bell_incomplete_poly(\n431                 n - m, k - 1, symbols) * symbols[m - 1]\n432             a = a * (n - m) / m\n433         return expand_mul(s)\n434 \n435     @classmethod\n436     def eval(cls, n, k_sym=None, symbols=None):\n437         if n.is_Integer and n.is_nonnegative:\n438             if k_sym is None:\n439                 return Integer(cls._bell(int(n)))\n440             elif symbols is None:\n441                 return cls._bell_poly(int(n)).subs(_sym, k_sym)\n442             else:\n443                 r = cls._bell_incomplete_poly(int(n), int(k_sym), symbols)\n444                 return r\n445 \n446     def _eval_rewrite_as_Sum(self, n, k_sym=None, symbols=None):\n447         from sympy import Sum\n448         if (k_sym is not None) or (symbols is not None):\n449             return self\n450 \n451         # Dobinski's formula\n452         if not n.is_nonnegative:\n453             return self\n454         k = Dummy('k', integer=True, nonnegative=True)\n455         return 1 / E * Sum(k**n / factorial(k), (k, 0, S.Infinity))\n456 \n457 #----------------------------------------------------------------------------#\n458 #                                                                            #\n459 #                           Harmonic numbers                                 #\n460 #                                                                            #\n461 #----------------------------------------------------------------------------#\n462 \n463 \n464 class harmonic(Function):\n465     r\"\"\"\n466     Harmonic numbers\n467 \n468     The nth harmonic number is given by `\\operatorname{H}_{n} =\n469     1 + \\frac{1}{2} + \\frac{1}{3} + \\ldots + \\frac{1}{n}`.\n470 \n471     More generally:\n472 \n473     .. math:: \\operatorname{H}_{n,m} = \\sum_{k=1}^{n} \\frac{1}{k^m}\n474 \n475     As `n \\rightarrow \\infty`, `\\operatorname{H}_{n,m} \\rightarrow \\zeta(m)`,\n476     the Riemann zeta function.\n477 \n478     * ``harmonic(n)`` gives the nth harmonic number, `\\operatorname{H}_n`\n479 \n480     * ``harmonic(n, m)`` gives the nth generalized harmonic number\n481       of order `m`, `\\operatorname{H}_{n,m}`, where\n482       ``harmonic(n) == harmonic(n, 1)``\n483 \n484     Examples\n485     ========\n486 \n487     >>> from sympy import harmonic, oo\n488 \n489     >>> [harmonic(n) for n in range(6)]\n490     [0, 1, 3/2, 11/6, 25/12, 137/60]\n491     >>> [harmonic(n, 2) for n in range(6)]\n492     [0, 1, 5/4, 49/36, 205/144, 5269/3600]\n493     >>> harmonic(oo, 2)\n494     pi**2/6\n495 \n496     >>> from sympy import Symbol, Sum\n497     >>> n = Symbol(\"n\")\n498 \n499     >>> harmonic(n).rewrite(Sum)\n500     Sum(1/_k, (_k, 1, n))\n501 \n502     We can evaluate harmonic numbers for all integral and positive\n503     rational arguments:\n504 \n505     >>> from sympy import S, expand_func, simplify\n506     >>> harmonic(8)\n507     761/280\n508     >>> harmonic(11)\n509     83711/27720\n510 \n511     >>> H = harmonic(1/S(3))\n512     >>> H\n513     harmonic(1/3)\n514     >>> He = expand_func(H)\n515     >>> He\n516     -log(6) - sqrt(3)*pi/6 + 2*Sum(log(sin(_k*pi/3))*cos(2*_k*pi/3), (_k, 1, 1))\n517                            + 3*Sum(1/(3*_k + 1), (_k, 0, 0))\n518     >>> He.doit()\n519     -log(6) - sqrt(3)*pi/6 - log(sqrt(3)/2) + 3\n520     >>> H = harmonic(25/S(7))\n521     >>> He = simplify(expand_func(H).doit())\n522     >>> He\n523     log(sin(pi/7)**(-2*cos(pi/7))*sin(2*pi/7)**(2*cos(16*pi/7))*cos(pi/14)**(-2*sin(pi/14))/14)\n524     + pi*tan(pi/14)/2 + 30247/9900\n525     >>> He.n(40)\n526     1.983697455232980674869851942390639915940\n527     >>> harmonic(25/S(7)).n(40)\n528     1.983697455232980674869851942390639915940\n529 \n530     We can rewrite harmonic numbers in terms of polygamma functions:\n531 \n532     >>> from sympy import digamma, polygamma\n533     >>> m = Symbol(\"m\")\n534 \n535     >>> harmonic(n).rewrite(digamma)\n536     polygamma(0, n + 1) + EulerGamma\n537 \n538     >>> harmonic(n).rewrite(polygamma)\n539     polygamma(0, n + 1) + EulerGamma\n540 \n541     >>> harmonic(n,3).rewrite(polygamma)\n542     polygamma(2, n + 1)/2 - polygamma(2, 1)/2\n543 \n544     >>> harmonic(n,m).rewrite(polygamma)\n545     (-1)**m*(polygamma(m - 1, 1) - polygamma(m - 1, n + 1))/factorial(m - 1)\n546 \n547     Integer offsets in the argument can be pulled out:\n548 \n549     >>> from sympy import expand_func\n550 \n551     >>> expand_func(harmonic(n+4))\n552     harmonic(n) + 1/(n + 4) + 1/(n + 3) + 1/(n + 2) + 1/(n + 1)\n553 \n554     >>> expand_func(harmonic(n-4))\n555     harmonic(n) - 1/(n - 1) - 1/(n - 2) - 1/(n - 3) - 1/n\n556 \n557     Some limits can be computed as well:\n558 \n559     >>> from sympy import limit, oo\n560 \n561     >>> limit(harmonic(n), n, oo)\n562     oo\n563 \n564     >>> limit(harmonic(n, 2), n, oo)\n565     pi**2/6\n566 \n567     >>> limit(harmonic(n, 3), n, oo)\n568     -polygamma(2, 1)/2\n569 \n570     However we can not compute the general relation yet:\n571 \n572     >>> limit(harmonic(n, m), n, oo)\n573     harmonic(oo, m)\n574 \n575     which equals ``zeta(m)`` for ``m > 1``.\n576 \n577     References\n578     ==========\n579 \n580     .. [1] http://en.wikipedia.org/wiki/Harmonic_number\n581     .. [2] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber/\n582     .. [3] http://functions.wolfram.com/GammaBetaErf/HarmonicNumber2/\n583 \n584     See Also\n585     ========\n586 \n587     bell, bernoulli, catalan, euler, fibonacci, lucas\n588     \"\"\"\n589 \n590     # Generate one memoized Harmonic number-generating function for each\n591     # order and store it in a dictionary\n592     _functions = {}\n593 \n594     @classmethod\n595     def eval(cls, n, m=None):\n596         from sympy import zeta\n597         if m is S.One:\n598             return cls(n)\n599         if m is None:\n600             m = S.One\n601 \n602         if m.is_zero:\n603             return n\n604 \n605         if n is S.Infinity and m.is_Number:\n606             # TODO: Fix for symbolic values of m\n607             if m.is_negative:\n608                 return S.NaN\n609             elif LessThan(m, S.One):\n610                 return S.Infinity\n611             elif StrictGreaterThan(m, S.One):\n612                 return zeta(m)\n613             else:\n614                 return cls\n615 \n616         if n.is_Integer and n.is_nonnegative and m.is_Integer:\n617             if n == 0:\n618                 return S.Zero\n619             if not m in cls._functions:\n620                 @recurrence_memo([0])\n621                 def f(n, prev):\n622                     return prev[-1] + S.One / n**m\n623                 cls._functions[m] = f\n624             return cls._functions[m](int(n))\n625 \n626     def _eval_rewrite_as_polygamma(self, n, m=1):\n627         from sympy.functions.special.gamma_functions import polygamma\n628         return S.NegativeOne**m/factorial(m - 1) * (polygamma(m - 1, 1) - polygamma(m - 1, n + 1))\n629 \n630     def _eval_rewrite_as_digamma(self, n, m=1):\n631         from sympy.functions.special.gamma_functions import polygamma\n632         return self.rewrite(polygamma)\n633 \n634     def _eval_rewrite_as_trigamma(self, n, m=1):\n635         from sympy.functions.special.gamma_functions import polygamma\n636         return self.rewrite(polygamma)\n637 \n638     def _eval_rewrite_as_Sum(self, n, m=None):\n639         from sympy import Sum\n640         k = Dummy(\"k\", integer=True)\n641         if m is None:\n642             m = S.One\n643         return Sum(k**(-m), (k, 1, n))\n644 \n645     def _eval_expand_func(self, **hints):\n646         from sympy import Sum\n647         n = self.args[0]\n648         m = self.args[1] if len(self.args) == 2 else 1\n649 \n650         if m == S.One:\n651             if n.is_Add:\n652                 off = n.args[0]\n653                 nnew = n - off\n654                 if off.is_Integer and off.is_positive:\n655                     result = [S.One/(nnew + i) for i in range(off, 0, -1)] + [harmonic(nnew)]\n656                     return Add(*result)\n657                 elif off.is_Integer and off.is_negative:\n658                     result = [-S.One/(nnew + i) for i in range(0, off, -1)] + [harmonic(nnew)]\n659                     return Add(*result)\n660 \n661             if n.is_Rational:\n662                 # Expansions for harmonic numbers at general rational arguments (u + p/q)\n663                 # Split n as u + p/q with p < q\n664                 p, q = n.as_numer_denom()\n665                 u = p // q\n666                 p = p - u * q\n667                 if u.is_nonnegative and p.is_positive and q.is_positive and p < q:\n668                     k = Dummy(\"k\")\n669                     t1 = q * Sum(1 / (q * k + p), (k, 0, u))\n670                     t2 = 2 * Sum(cos((2 * pi * p * k) / S(q)) *\n671                                    log(sin((pi * k) / S(q))),\n672                                    (k, 1, floor((q - 1) / S(2))))\n673                     t3 = (pi / 2) * cot((pi * p) / q) + log(2 * q)\n674                     return t1 + t2 - t3\n675 \n676         return self\n677 \n678     def _eval_rewrite_as_tractable(self, n, m=1):\n679         from sympy import polygamma\n680         return self.rewrite(polygamma).rewrite(\"tractable\", deep=True)\n681 \n682     def _eval_evalf(self, prec):\n683         from sympy import polygamma\n684         if all(i.is_number for i in self.args):\n685             return self.rewrite(polygamma)._eval_evalf(prec)\n686 \n687 \n688 #----------------------------------------------------------------------------#\n689 #                                                                            #\n690 #                           Euler numbers                                    #\n691 #                                                                            #\n692 #----------------------------------------------------------------------------#\n693 \n694 \n695 class euler(Function):\n696     r\"\"\"\n697     Euler numbers / Euler polynomials\n698 \n699     The Euler numbers are given by::\n700 \n701                   2*n+1   k\n702                    ___   ___            j          2*n+1\n703                   \\     \\     / k \\ (-1)  * (k-2*j)\n704           E   = I  )     )    |   | --------------------\n705            2n     /___  /___  \\ j /      k    k\n706                   k = 1 j = 0           2  * I  * k\n707 \n708           E     = 0\n709            2n+1\n710 \n711     Euler numbers and Euler polynomials are related by\n712 \n713     .. math:: E_n = 2^n E_n\\left(\\frac{1}{2}\\right).\n714 \n715     We compute symbolic Euler polynomials using [5]\n716 \n717     .. math:: E_n(x) = \\sum_{k=0}^n \\binom{n}{k} \\frac{E_k}{2^k}\n718                        \\left(x - \\frac{1}{2}\\right)^{n-k}.\n719 \n720     However, numerical evaluation of the Euler polynomial is computed\n721     more efficiently (and more accurately) using the mpmath library.\n722 \n723     * euler(n) gives the n-th Euler number, `E_n`.\n724     * euler(n, x) gives the n-th Euler polynomial, `E_n(x)`.\n725 \n726     Examples\n727     ========\n728 \n729     >>> from sympy import Symbol, S\n730     >>> from sympy.functions import euler\n731     >>> [euler(n) for n in range(10)]\n732     [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0]\n733     >>> n = Symbol(\"n\")\n734     >>> euler(n+2*n)\n735     euler(3*n)\n736 \n737     >>> x = Symbol(\"x\")\n738     >>> euler(n, x)\n739     euler(n, x)\n740 \n741     >>> euler(0, x)\n742     1\n743     >>> euler(1, x)\n744     x - 1/2\n745     >>> euler(2, x)\n746     x**2 - x\n747     >>> euler(3, x)\n748     x**3 - 3*x**2/2 + 1/4\n749     >>> euler(4, x)\n750     x**4 - 2*x**3 + x\n751 \n752     >>> euler(12, S.Half)\n753     2702765/4096\n754     >>> euler(12)\n755     2702765\n756 \n757     References\n758     ==========\n759 \n760     .. [1] http://en.wikipedia.org/wiki/Euler_numbers\n761     .. [2] http://mathworld.wolfram.com/EulerNumber.html\n762     .. [3] http://en.wikipedia.org/wiki/Alternating_permutation\n763     .. [4] http://mathworld.wolfram.com/AlternatingPermutation.html\n764     .. [5] http://dlmf.nist.gov/24.2#ii\n765 \n766     See Also\n767     ========\n768 \n769     bell, bernoulli, catalan, fibonacci, harmonic, lucas\n770     \"\"\"\n771 \n772     @classmethod\n773     def eval(cls, m, sym=None):\n774         if m.is_Number:\n775             if m.is_Integer and m.is_nonnegative:\n776                 # Euler numbers\n777                 if sym is None:\n778                     if m.is_odd:\n779                         return S.Zero\n780                     from mpmath import mp\n781                     m = m._to_mpmath(mp.prec)\n782                     res = mp.eulernum(m, exact=True)\n783                     return Integer(res)\n784                 # Euler polynomial\n785                 else:\n786                     from sympy.core.evalf import pure_complex\n787                     reim = pure_complex(sym, or_real=True)\n788                     # Evaluate polynomial numerically using mpmath\n789                     if reim and all(a.is_Float or a.is_Integer for a in reim) \\\n790                             and any(a.is_Float for a in reim):\n791                         from mpmath import mp\n792                         from sympy import Expr\n793                         m = int(m)\n794                         # XXX ComplexFloat (#12192) would be nice here, above\n795                         prec = min([a._prec for a in reim if a.is_Float])\n796                         with workprec(prec):\n797                             res = mp.eulerpoly(m, sym)\n798                         return Expr._from_mpmath(res, prec)\n799                     # Construct polynomial symbolically from definition\n800                     m, result = int(m), []\n801                     for k in range(m + 1):\n802                         result.append(binomial(m, k)*cls(k)/(2**k)*(sym - S.Half)**(m - k))\n803                     return Add(*result).expand()\n804             else:\n805                 raise ValueError(\"Euler numbers are defined only\"\n806                                  \" for nonnegative integer indices.\")\n807         if sym is None:\n808             if m.is_odd and m.is_positive:\n809                 return S.Zero\n810 \n811     def _eval_rewrite_as_Sum(self, n, x=None):\n812         from sympy import Sum\n813         if x is None and n.is_even:\n814             k = Dummy(\"k\", integer=True)\n815             j = Dummy(\"j\", integer=True)\n816             n = n / 2\n817             Em = (S.ImaginaryUnit * Sum(Sum(binomial(k, j) * ((-1)**j * (k - 2*j)**(2*n + 1)) /\n818                   (2**k*S.ImaginaryUnit**k * k), (j, 0, k)), (k, 1, 2*n + 1)))\n819             return Em\n820         if x:\n821             k = Dummy(\"k\", integer=True)\n822             return Sum(binomial(n, k)*euler(k)/2**k*(x-S.Half)**(n-k), (k, 0, n))\n823 \n824     def _eval_evalf(self, prec):\n825         m, x = (self.args[0], None) if len(self.args) == 1 else self.args\n826 \n827         if x is None and m.is_Integer and m.is_nonnegative:\n828             from mpmath import mp\n829             from sympy import Expr\n830             m = m._to_mpmath(prec)\n831             with workprec(prec):\n832                 res = mp.eulernum(m)\n833             return Expr._from_mpmath(res, prec)\n834         if x and x.is_number and m.is_Integer and m.is_nonnegative:\n835             from mpmath import mp\n836             from sympy import Expr\n837             m = int(m)\n838             x = x._to_mpmath(prec)\n839             with workprec(prec):\n840                 res = mp.eulerpoly(m, x)\n841             return Expr._from_mpmath(res, prec)\n842 \n843 #----------------------------------------------------------------------------#\n844 #                                                                            #\n845 #                           Catalan numbers                                  #\n846 #                                                                            #\n847 #----------------------------------------------------------------------------#\n848 \n849 \n850 class catalan(Function):\n851     r\"\"\"\n852     Catalan numbers\n853 \n854     The n-th catalan number is given by::\n855 \n856                  1   / 2*n \\\n857           C  = ----- |     |\n858            n   n + 1 \\  n  /\n859 \n860     * catalan(n) gives the n-th Catalan number, C_n\n861 \n862     Examples\n863     ========\n864 \n865     >>> from sympy import (Symbol, binomial, gamma, hyper, polygamma,\n866     ...             catalan, diff, combsimp, Rational, I)\n867 \n868     >>> [ catalan(i) for i in range(1,10) ]\n869     [1, 2, 5, 14, 42, 132, 429, 1430, 4862]\n870 \n871     >>> n = Symbol(\"n\", integer=True)\n872 \n873     >>> catalan(n)\n874     catalan(n)\n875 \n876     Catalan numbers can be transformed into several other, identical\n877     expressions involving other mathematical functions\n878 \n879     >>> catalan(n).rewrite(binomial)\n880     binomial(2*n, n)/(n + 1)\n881 \n882     >>> catalan(n).rewrite(gamma)\n883     4**n*gamma(n + 1/2)/(sqrt(pi)*gamma(n + 2))\n884 \n885     >>> catalan(n).rewrite(hyper)\n886     hyper((-n + 1, -n), (2,), 1)\n887 \n888     For some non-integer values of n we can get closed form\n889     expressions by rewriting in terms of gamma functions:\n890 \n891     >>> catalan(Rational(1,2)).rewrite(gamma)\n892     8/(3*pi)\n893 \n894     We can differentiate the Catalan numbers C(n) interpreted as a\n895     continuous real funtion in n:\n896 \n897     >>> diff(catalan(n), n)\n898     (polygamma(0, n + 1/2) - polygamma(0, n + 2) + log(4))*catalan(n)\n899 \n900     As a more advanced example consider the following ratio\n901     between consecutive numbers:\n902 \n903     >>> combsimp((catalan(n + 1)/catalan(n)).rewrite(binomial))\n904     2*(2*n + 1)/(n + 2)\n905 \n906     The Catalan numbers can be generalized to complex numbers:\n907 \n908     >>> catalan(I).rewrite(gamma)\n909     4**I*gamma(1/2 + I)/(sqrt(pi)*gamma(2 + I))\n910 \n911     and evaluated with arbitrary precision:\n912 \n913     >>> catalan(I).evalf(20)\n914     0.39764993382373624267 - 0.020884341620842555705*I\n915 \n916     References\n917     ==========\n918 \n919     .. [1] http://en.wikipedia.org/wiki/Catalan_number\n920     .. [2] http://mathworld.wolfram.com/CatalanNumber.html\n921     .. [3] http://functions.wolfram.com/GammaBetaErf/CatalanNumber/\n922     .. [4] http://geometer.org/mathcircles/catalan.pdf\n923 \n924     See Also\n925     ========\n926 \n927     bell, bernoulli, euler, fibonacci, harmonic, lucas\n928     sympy.functions.combinatorial.factorials.binomial\n929     \"\"\"\n930 \n931     @classmethod\n932     def eval(cls, n):\n933         from sympy import gamma\n934         if (n.is_Integer and n.is_nonnegative) or \\\n935            (n.is_noninteger and n.is_negative):\n936             return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))\n937 \n938         if (n.is_integer and n.is_negative):\n939             if (n + 1).is_negative:\n940                 return S.Zero\n941             if (n + 1).is_zero:\n942                 return -S.Half\n943 \n944     def fdiff(self, argindex=1):\n945         from sympy import polygamma, log\n946         n = self.args[0]\n947         return catalan(n)*(polygamma(0, n + Rational(1, 2)) - polygamma(0, n + 2) + log(4))\n948 \n949     def _eval_rewrite_as_binomial(self, n):\n950         return binomial(2*n, n)/(n + 1)\n951 \n952     def _eval_rewrite_as_factorial(self, n):\n953         return factorial(2*n) / (factorial(n+1) * factorial(n))\n954 \n955     def _eval_rewrite_as_gamma(self, n):\n956         from sympy import gamma\n957         # The gamma function allows to generalize Catalan numbers to complex n\n958         return 4**n*gamma(n + S.Half)/(gamma(S.Half)*gamma(n + 2))\n959 \n960     def _eval_rewrite_as_hyper(self, n):\n961         from sympy import hyper\n962         return hyper([1 - n, -n], [2], 1)\n963 \n964     def _eval_rewrite_as_Product(self, n):\n965         from sympy import Product\n966         if not (n.is_integer and n.is_nonnegative):\n967             return self\n968         k = Dummy('k', integer=True, positive=True)\n969         return Product((n + k) / k, (k, 2, n))\n970 \n971     def _eval_evalf(self, prec):\n972         from sympy import gamma\n973         if self.args[0].is_number:\n974             return self.rewrite(gamma)._eval_evalf(prec)\n975 \n976 \n977 #----------------------------------------------------------------------------#\n978 #                                                                            #\n979 #                           Genocchi numbers                                 #\n980 #                                                                            #\n981 #----------------------------------------------------------------------------#\n982 \n983 \n984 class genocchi(Function):\n985     r\"\"\"\n986     Genocchi numbers\n987 \n988     The Genocchi numbers are a sequence of integers G_n that satisfy the\n989     relation::\n990 \n991                            oo\n992                          ____\n993                          \\   `\n994                  2*t      \\         n\n995                 ------ =   \\   G_n*t\n996                  t         /   ------\n997                 e  + 1    /      n!\n998                          /___,\n999                          n = 1\n1000 \n1001     Examples\n1002     ========\n1003 \n1004     >>> from sympy import Symbol\n1005     >>> from sympy.functions import genocchi\n1006     >>> [genocchi(n) for n in range(1, 9)]\n1007     [1, -1, 0, 1, 0, -3, 0, 17]\n1008     >>> n = Symbol('n', integer=True, positive=True)\n1009     >>> genocchi(2 * n + 1)\n1010     0\n1011 \n1012     References\n1013     ==========\n1014 \n1015     .. [1] https://en.wikipedia.org/wiki/Genocchi_number\n1016     .. [2] http://mathworld.wolfram.com/GenocchiNumber.html\n1017 \n1018     See Also\n1019     ========\n1020 \n1021     bell, bernoulli, catalan, euler, fibonacci, harmonic, lucas\n1022     \"\"\"\n1023 \n1024     @classmethod\n1025     def eval(cls, n):\n1026         if n.is_Number:\n1027             if (not n.is_Integer) or n.is_nonpositive:\n1028                 raise ValueError(\"Genocchi numbers are defined only for \" +\n1029                                  \"positive integers\")\n1030             return 2 * (1 - S(2) ** n) * bernoulli(n)\n1031 \n1032         if n.is_odd and (n - 1).is_positive:\n1033             return S.Zero\n1034 \n1035         if (n - 1).is_zero:\n1036             return S.One\n1037 \n1038     def _eval_rewrite_as_bernoulli(self, n):\n1039         if n.is_integer and n.is_nonnegative:\n1040             return (1 - S(2) ** n) * bernoulli(n) * 2\n1041 \n1042     def _eval_is_integer(self):\n1043         if self.args[0].is_integer and self.args[0].is_positive:\n1044             return True\n1045 \n1046     def _eval_is_negative(self):\n1047         n = self.args[0]\n1048         if n.is_integer and n.is_positive:\n1049             if n.is_odd:\n1050                 return False\n1051             return (n / 2).is_odd\n1052 \n1053     def _eval_is_positive(self):\n1054         n = self.args[0]\n1055         if n.is_integer and n.is_positive:\n1056             if n.is_odd:\n1057                 return fuzzy_not((n - 1).is_positive)\n1058             return (n / 2).is_even\n1059 \n1060     def _eval_is_even(self):\n1061         n = self.args[0]\n1062         if n.is_integer and n.is_positive:\n1063             if n.is_even:\n1064                 return False\n1065             return (n - 1).is_positive\n1066 \n1067     def _eval_is_odd(self):\n1068         n = self.args[0]\n1069         if n.is_integer and n.is_positive:\n1070             if n.is_even:\n1071                 return True\n1072             return fuzzy_not((n - 1).is_positive)\n1073 \n1074     def _eval_is_prime(self):\n1075         n = self.args[0]\n1076         # only G_6 = -3 and G_8 = 17 are prime,\n1077         # but SymPy does not consider negatives as prime\n1078         # so only n=8 is tested\n1079         return (n - 8).is_zero\n1080 \n1081 \n1082 #######################################################################\n1083 ###\n1084 ### Functions for enumerating partitions, permutations and combinations\n1085 ###\n1086 #######################################################################\n1087 \n1088 \n1089 class _MultisetHistogram(tuple):\n1090     pass\n1091 \n1092 \n1093 _N = -1\n1094 _ITEMS = -2\n1095 _M = slice(None, _ITEMS)\n1096 \n1097 \n1098 def _multiset_histogram(n):\n1099     \"\"\"Return tuple used in permutation and combination counting. Input\n1100     is a dictionary giving items with counts as values or a sequence of\n1101     items (which need not be sorted).\n1102 \n1103     The data is stored in a class deriving from tuple so it is easily\n1104     recognized and so it can be converted easily to a list.\n1105     \"\"\"\n1106     if type(n) is dict:  # item: count\n1107         if not all(isinstance(v, int) and v >= 0 for v in n.values()):\n1108             raise ValueError\n1109         tot = sum(n.values())\n1110         items = sum(1 for k in n if n[k] > 0)\n1111         return _MultisetHistogram([n[k] for k in n if n[k] > 0] + [items, tot])\n1112     else:\n1113         n = list(n)\n1114         s = set(n)\n1115         if len(s) == len(n):\n1116             n = [1]*len(n)\n1117             n.extend([len(n), len(n)])\n1118             return _MultisetHistogram(n)\n1119         m = dict(zip(s, range(len(s))))\n1120         d = dict(zip(range(len(s)), [0]*len(s)))\n1121         for i in n:\n1122             d[m[i]] += 1\n1123         return _multiset_histogram(d)\n1124 \n1125 \n1126 def nP(n, k=None, replacement=False):\n1127     \"\"\"Return the number of permutations of ``n`` items taken ``k`` at a time.\n1128 \n1129     Possible values for ``n``::\n1130         integer - set of length ``n``\n1131         sequence - converted to a multiset internally\n1132         multiset - {element: multiplicity}\n1133 \n1134     If ``k`` is None then the total of all permutations of length 0\n1135     through the number of items represented by ``n`` will be returned.\n1136 \n1137     If ``replacement`` is True then a given item can appear more than once\n1138     in the ``k`` items. (For example, for 'ab' permutations of 2 would\n1139     include 'aa', 'ab', 'ba' and 'bb'.) The multiplicity of elements in\n1140     ``n`` is ignored when ``replacement`` is True but the total number\n1141     of elements is considered since no element can appear more times than\n1142     the number of elements in ``n``.\n1143 \n1144     Examples\n1145     ========\n1146 \n1147     >>> from sympy.functions.combinatorial.numbers import nP\n1148     >>> from sympy.utilities.iterables import multiset_permutations, multiset\n1149     >>> nP(3, 2)\n1150     6\n1151     >>> nP('abc', 2) == nP(multiset('abc'), 2) == 6\n1152     True\n1153     >>> nP('aab', 2)\n1154     3\n1155     >>> nP([1, 2, 2], 2)\n1156     3\n1157     >>> [nP(3, i) for i in range(4)]\n1158     [1, 3, 6, 6]\n1159     >>> nP(3) == sum(_)\n1160     True\n1161 \n1162     When ``replacement`` is True, each item can have multiplicity\n1163     equal to the length represented by ``n``:\n1164 \n1165     >>> nP('aabc', replacement=True)\n1166     121\n1167     >>> [len(list(multiset_permutations('aaaabbbbcccc', i))) for i in range(5)]\n1168     [1, 3, 9, 27, 81]\n1169     >>> sum(_)\n1170     121\n1171 \n1172     References\n1173     ==========\n1174 \n1175     .. [1] http://en.wikipedia.org/wiki/Permutation\n1176 \n1177     See Also\n1178     ========\n1179     sympy.utilities.iterables.multiset_permutations\n1180 \n1181     \"\"\"\n1182     try:\n1183         n = as_int(n)\n1184     except ValueError:\n1185         return Integer(_nP(_multiset_histogram(n), k, replacement))\n1186     return Integer(_nP(n, k, replacement))\n1187 \n1188 \n1189 @cacheit\n1190 def _nP(n, k=None, replacement=False):\n1191     from sympy.functions.combinatorial.factorials import factorial\n1192     from sympy.core.mul import prod\n1193 \n1194     if k == 0:\n1195         return 1\n1196     if isinstance(n, SYMPY_INTS):  # n different items\n1197         # assert n >= 0\n1198         if k is None:\n1199             return sum(_nP(n, i, replacement) for i in range(n + 1))\n1200         elif replacement:\n1201             return n**k\n1202         elif k > n:\n1203             return 0\n1204         elif k == n:\n1205             return factorial(k)\n1206         elif k == 1:\n1207             return n\n1208         else:\n1209             # assert k >= 0\n1210             return _product(n - k + 1, n)\n1211     elif isinstance(n, _MultisetHistogram):\n1212         if k is None:\n1213             return sum(_nP(n, i, replacement) for i in range(n[_N] + 1))\n1214         elif replacement:\n1215             return n[_ITEMS]**k\n1216         elif k == n[_N]:\n1217             return factorial(k)/prod([factorial(i) for i in n[_M] if i > 1])\n1218         elif k > n[_N]:\n1219             return 0\n1220         elif k == 1:\n1221             return n[_ITEMS]\n1222         else:\n1223             # assert k >= 0\n1224             tot = 0\n1225             n = list(n)\n1226             for i in range(len(n[_M])):\n1227                 if not n[i]:\n1228                     continue\n1229                 n[_N] -= 1\n1230                 if n[i] == 1:\n1231                     n[i] = 0\n1232                     n[_ITEMS] -= 1\n1233                     tot += _nP(_MultisetHistogram(n), k - 1)\n1234                     n[_ITEMS] += 1\n1235                     n[i] = 1\n1236                 else:\n1237                     n[i] -= 1\n1238                     tot += _nP(_MultisetHistogram(n), k - 1)\n1239                     n[i] += 1\n1240                 n[_N] += 1\n1241             return tot\n1242 \n1243 \n1244 @cacheit\n1245 def _AOP_product(n):\n1246     \"\"\"for n = (m1, m2, .., mk) return the coefficients of the polynomial,\n1247     prod(sum(x**i for i in range(nj + 1)) for nj in n); i.e. the coefficients\n1248     of the product of AOPs (all-one polynomials) or order given in n.  The\n1249     resulting coefficient corresponding to x**r is the number of r-length\n1250     combinations of sum(n) elements with multiplicities given in n.\n1251     The coefficients are given as a default dictionary (so if a query is made\n1252     for a key that is not present, 0 will be returned).\n1253 \n1254     Examples\n1255     ========\n1256 \n1257     >>> from sympy.functions.combinatorial.numbers import _AOP_product\n1258     >>> from sympy.abc import x\n1259     >>> n = (2, 2, 3)  # e.g. aabbccc\n1260     >>> prod = ((x**2 + x + 1)*(x**2 + x + 1)*(x**3 + x**2 + x + 1)).expand()\n1261     >>> c = _AOP_product(n); dict(c)\n1262     {0: 1, 1: 3, 2: 6, 3: 8, 4: 8, 5: 6, 6: 3, 7: 1}\n1263     >>> [c[i] for i in range(8)] == [prod.coeff(x, i) for i in range(8)]\n1264     True\n1265 \n1266     The generating poly used here is the same as that listed in\n1267     http://tinyurl.com/cep849r, but in a refactored form.\n1268 \n1269     \"\"\"\n1270     from collections import defaultdict\n1271 \n1272     n = list(n)\n1273     ord = sum(n)\n1274     need = (ord + 2)//2\n1275     rv = [1]*(n.pop() + 1)\n1276     rv.extend([0]*(need - len(rv)))\n1277     rv = rv[:need]\n1278     while n:\n1279         ni = n.pop()\n1280         N = ni + 1\n1281         was = rv[:]\n1282         for i in range(1, min(N, len(rv))):\n1283             rv[i] += rv[i - 1]\n1284         for i in range(N, need):\n1285             rv[i] += rv[i - 1] - was[i - N]\n1286     rev = list(reversed(rv))\n1287     if ord % 2:\n1288         rv = rv + rev\n1289     else:\n1290         rv[-1:] = rev\n1291     d = defaultdict(int)\n1292     for i in range(len(rv)):\n1293         d[i] = rv[i]\n1294     return d\n1295 \n1296 \n1297 def nC(n, k=None, replacement=False):\n1298     \"\"\"Return the number of combinations of ``n`` items taken ``k`` at a time.\n1299 \n1300     Possible values for ``n``::\n1301         integer - set of length ``n``\n1302         sequence - converted to a multiset internally\n1303         multiset - {element: multiplicity}\n1304 \n1305     If ``k`` is None then the total of all combinations of length 0\n1306     through the number of items represented in ``n`` will be returned.\n1307 \n1308     If ``replacement`` is True then a given item can appear more than once\n1309     in the ``k`` items. (For example, for 'ab' sets of 2 would include 'aa',\n1310     'ab', and 'bb'.) The multiplicity of elements in ``n`` is ignored when\n1311     ``replacement`` is True but the total number of elements is considered\n1312     since no element can appear more times than the number of elements in\n1313     ``n``.\n1314 \n1315     Examples\n1316     ========\n1317 \n1318     >>> from sympy.functions.combinatorial.numbers import nC\n1319     >>> from sympy.utilities.iterables import multiset_combinations\n1320     >>> nC(3, 2)\n1321     3\n1322     >>> nC('abc', 2)\n1323     3\n1324     >>> nC('aab', 2)\n1325     2\n1326 \n1327     When ``replacement`` is True, each item can have multiplicity\n1328     equal to the length represented by ``n``:\n1329 \n1330     >>> nC('aabc', replacement=True)\n1331     35\n1332     >>> [len(list(multiset_combinations('aaaabbbbcccc', i))) for i in range(5)]\n1333     [1, 3, 6, 10, 15]\n1334     >>> sum(_)\n1335     35\n1336 \n1337     If there are ``k`` items with multiplicities ``m_1, m_2, ..., m_k``\n1338     then the total of all combinations of length 0 hrough ``k`` is the\n1339     product, ``(m_1 + 1)*(m_2 + 1)*...*(m_k + 1)``. When the multiplicity\n1340     of each item is 1 (i.e., k unique items) then there are 2**k\n1341     combinations. For example, if there are 4 unique items, the total number\n1342     of combinations is 16:\n1343 \n1344     >>> sum(nC(4, i) for i in range(5))\n1345     16\n1346 \n1347     References\n1348     ==========\n1349 \n1350     .. [1] http://en.wikipedia.org/wiki/Combination\n1351     .. [2] http://tinyurl.com/cep849r\n1352 \n1353     See Also\n1354     ========\n1355     sympy.utilities.iterables.multiset_combinations\n1356     \"\"\"\n1357     from sympy.functions.combinatorial.factorials import binomial\n1358     from sympy.core.mul import prod\n1359 \n1360     if isinstance(n, SYMPY_INTS):\n1361         if k is None:\n1362             if not replacement:\n1363                 return 2**n\n1364             return sum(nC(n, i, replacement) for i in range(n + 1))\n1365         if k < 0:\n1366             raise ValueError(\"k cannot be negative\")\n1367         if replacement:\n1368             return binomial(n + k - 1, k)\n1369         return binomial(n, k)\n1370     if isinstance(n, _MultisetHistogram):\n1371         N = n[_N]\n1372         if k is None:\n1373             if not replacement:\n1374                 return prod(m + 1 for m in n[_M])\n1375             return sum(nC(n, i, replacement) for i in range(N + 1))\n1376         elif replacement:\n1377             return nC(n[_ITEMS], k, replacement)\n1378         # assert k >= 0\n1379         elif k in (1, N - 1):\n1380             return n[_ITEMS]\n1381         elif k in (0, N):\n1382             return 1\n1383         return _AOP_product(tuple(n[_M]))[k]\n1384     else:\n1385         return nC(_multiset_histogram(n), k, replacement)\n1386 \n1387 \n1388 @cacheit\n1389 def _stirling1(n, k):\n1390     if n == k == 0:\n1391         return S.One\n1392     if 0 in (n, k):\n1393         return S.Zero\n1394     n1 = n - 1\n1395 \n1396     # some special values\n1397     if n == k:\n1398         return S.One\n1399     elif k == 1:\n1400         return factorial(n1)\n1401     elif k == n1:\n1402         return binomial(n, 2)\n1403     elif k == n - 2:\n1404         return (3*n - 1)*binomial(n, 3)/4\n1405     elif k == n - 3:\n1406         return binomial(n, 2)*binomial(n, 4)\n1407 \n1408     # general recurrence\n1409     return n1*_stirling1(n1, k) + _stirling1(n1, k - 1)\n1410 \n1411 \n1412 @cacheit\n1413 def _stirling2(n, k):\n1414     if n == k == 0:\n1415         return S.One\n1416     if 0 in (n, k):\n1417         return S.Zero\n1418     n1 = n - 1\n1419 \n1420     # some special values\n1421     if k == n1:\n1422         return binomial(n, 2)\n1423     elif k == 2:\n1424         return 2**n1 - 1\n1425 \n1426     # general recurrence\n1427     return k*_stirling2(n1, k) + _stirling2(n1, k - 1)\n1428 \n1429 \n1430 def stirling(n, k, d=None, kind=2, signed=False):\n1431     \"\"\"Return Stirling number S(n, k) of the first or second (default) kind.\n1432 \n1433     The sum of all Stirling numbers of the second kind for k = 1\n1434     through n is bell(n). The recurrence relationship for these numbers\n1435     is::\n1436 \n1437     {0}       {n}   {0}      {n + 1}     {n}   {  n  }\n1438     { } = 1;  { } = { } = 0; {     } = j*{ } + {     }\n1439     {0}       {0}   {k}      {  k  }     {k}   {k - 1}\n1440 \n1441     where ``j`` is::\n1442         ``n`` for Stirling numbers of the first kind\n1443         ``-n`` for signed Stirling numbers of the first kind\n1444         ``k`` for Stirling numbers of the second kind\n1445 \n1446     The first kind of Stirling number counts the number of permutations of\n1447     ``n`` distinct items that have ``k`` cycles; the second kind counts the\n1448     ways in which ``n`` distinct items can be partitioned into ``k`` parts.\n1449     If ``d`` is given, the \"reduced Stirling number of the second kind\" is\n1450     returned: ``S^{d}(n, k) = S(n - d + 1, k - d + 1)`` with ``n >= k >= d``.\n1451     (This counts the ways to partition ``n`` consecutive integers into\n1452     ``k`` groups with no pairwise difference less than ``d``. See example\n1453     below.)\n1454 \n1455     To obtain the signed Stirling numbers of the first kind, use keyword\n1456     ``signed=True``. Using this keyword automatically sets ``kind`` to 1.\n1457 \n1458     Examples\n1459     ========\n1460 \n1461     >>> from sympy.functions.combinatorial.numbers import stirling, bell\n1462     >>> from sympy.combinatorics import Permutation\n1463     >>> from sympy.utilities.iterables import multiset_partitions, permutations\n1464 \n1465     First kind (unsigned by default):\n1466 \n1467     >>> [stirling(6, i, kind=1) for i in range(7)]\n1468     [0, 120, 274, 225, 85, 15, 1]\n1469     >>> perms = list(permutations(range(4)))\n1470     >>> [sum(Permutation(p).cycles == i for p in perms) for i in range(5)]\n1471     [0, 6, 11, 6, 1]\n1472     >>> [stirling(4, i, kind=1) for i in range(5)]\n1473     [0, 6, 11, 6, 1]\n1474 \n1475     First kind (signed):\n1476 \n1477     >>> [stirling(4, i, signed=True) for i in range(5)]\n1478     [0, -6, 11, -6, 1]\n1479 \n1480     Second kind:\n1481 \n1482     >>> [stirling(10, i) for i in range(12)]\n1483     [0, 1, 511, 9330, 34105, 42525, 22827, 5880, 750, 45, 1, 0]\n1484     >>> sum(_) == bell(10)\n1485     True\n1486     >>> len(list(multiset_partitions(range(4), 2))) == stirling(4, 2)\n1487     True\n1488 \n1489     Reduced second kind:\n1490 \n1491     >>> from sympy import subsets, oo\n1492     >>> def delta(p):\n1493     ...    if len(p) == 1:\n1494     ...        return oo\n1495     ...    return min(abs(i[0] - i[1]) for i in subsets(p, 2))\n1496     >>> parts = multiset_partitions(range(5), 3)\n1497     >>> d = 2\n1498     >>> sum(1 for p in parts if all(delta(i) >= d for i in p))\n1499     7\n1500     >>> stirling(5, 3, 2)\n1501     7\n1502 \n1503     References\n1504     ==========\n1505 \n1506     .. [1] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind\n1507     .. [2] http://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n1508 \n1509     See Also\n1510     ========\n1511     sympy.utilities.iterables.multiset_partitions\n1512 \n1513     \"\"\"\n1514     # TODO: make this a class like bell()\n1515 \n1516     n = as_int(n)\n1517     k = as_int(k)\n1518     if n < 0:\n1519         raise ValueError('n must be nonnegative')\n1520     if k > n:\n1521         return S.Zero\n1522     if d:\n1523         # assert k >= d\n1524         # kind is ignored -- only kind=2 is supported\n1525         return _stirling2(n - d + 1, k - d + 1)\n1526     elif signed:\n1527         # kind is ignored -- only kind=1 is supported\n1528         return (-1)**(n - k)*_stirling1(n, k)\n1529 \n1530     if kind == 1:\n1531         return _stirling1(n, k)\n1532     elif kind == 2:\n1533         return _stirling2(n, k)\n1534     else:\n1535         raise ValueError('kind must be 1 or 2, not %s' % k)\n1536 \n1537 \n1538 @cacheit\n1539 def _nT(n, k):\n1540     \"\"\"Return the partitions of ``n`` items into ``k`` parts. This\n1541     is used by ``nT`` for the case when ``n`` is an integer.\"\"\"\n1542     if k == 0:\n1543         return 1 if k == n else 0\n1544     return sum(_nT(n - k, j) for j in range(min(k, n - k) + 1))\n1545 \n1546 \n1547 def nT(n, k=None):\n1548     \"\"\"Return the number of ``k``-sized partitions of ``n`` items.\n1549 \n1550     Possible values for ``n``::\n1551         integer - ``n`` identical items\n1552         sequence - converted to a multiset internally\n1553         multiset - {element: multiplicity}\n1554 \n1555     Note: the convention for ``nT`` is different than that of ``nC`` and\n1556     ``nP`` in that\n1557     here an integer indicates ``n`` *identical* items instead of a set of\n1558     length ``n``; this is in keeping with the ``partitions`` function which\n1559     treats its integer-``n`` input like a list of ``n`` 1s. One can use\n1560     ``range(n)`` for ``n`` to indicate ``n`` distinct items.\n1561 \n1562     If ``k`` is None then the total number of ways to partition the elements\n1563     represented in ``n`` will be returned.\n1564 \n1565     Examples\n1566     ========\n1567 \n1568     >>> from sympy.functions.combinatorial.numbers import nT\n1569 \n1570     Partitions of the given multiset:\n1571 \n1572     >>> [nT('aabbc', i) for i in range(1, 7)]\n1573     [1, 8, 11, 5, 1, 0]\n1574     >>> nT('aabbc') == sum(_)\n1575     True\n1576 \n1577     >>> [nT(\"mississippi\", i) for i in range(1, 12)]\n1578     [1, 74, 609, 1521, 1768, 1224, 579, 197, 50, 9, 1]\n1579 \n1580     Partitions when all items are identical:\n1581 \n1582     >>> [nT(5, i) for i in range(1, 6)]\n1583     [1, 2, 2, 1, 1]\n1584     >>> nT('1'*5) == sum(_)\n1585     True\n1586 \n1587     When all items are different:\n1588 \n1589     >>> [nT(range(5), i) for i in range(1, 6)]\n1590     [1, 15, 25, 10, 1]\n1591     >>> nT(range(5)) == sum(_)\n1592     True\n1593 \n1594     References\n1595     ==========\n1596 \n1597     .. [1] http://undergraduate.csse.uwa.edu.au/units/CITS7209/partition.pdf\n1598 \n1599     See Also\n1600     ========\n1601     sympy.utilities.iterables.partitions\n1602     sympy.utilities.iterables.multiset_partitions\n1603 \n1604     \"\"\"\n1605     from sympy.utilities.enumerative import MultisetPartitionTraverser\n1606 \n1607     if isinstance(n, SYMPY_INTS):\n1608         # assert n >= 0\n1609         # all the same\n1610         if k is None:\n1611             return sum(_nT(n, k) for k in range(1, n + 1))\n1612         return _nT(n, k)\n1613     if not isinstance(n, _MultisetHistogram):\n1614         try:\n1615             # if n contains hashable items there is some\n1616             # quick handling that can be done\n1617             u = len(set(n))\n1618             if u == 1:\n1619                 return nT(len(n), k)\n1620             elif u == len(n):\n1621                 n = range(u)\n1622             raise TypeError\n1623         except TypeError:\n1624             n = _multiset_histogram(n)\n1625     N = n[_N]\n1626     if k is None and N == 1:\n1627         return 1\n1628     if k in (1, N):\n1629         return 1\n1630     if k == 2 or N == 2 and k is None:\n1631         m, r = divmod(N, 2)\n1632         rv = sum(nC(n, i) for i in range(1, m + 1))\n1633         if not r:\n1634             rv -= nC(n, m)//2\n1635         if k is None:\n1636             rv += 1  # for k == 1\n1637         return rv\n1638     if N == n[_ITEMS]:\n1639         # all distinct\n1640         if k is None:\n1641             return bell(N)\n1642         return stirling(N, k)\n1643     m = MultisetPartitionTraverser()\n1644     if k is None:\n1645         return m.count_partitions(n[_M])\n1646     # MultisetPartitionTraverser does not have a range-limited count\n1647     # method, so need to enumerate and count\n1648     tot = 0\n1649     for discard in m.enum_range(n[_M], k-1, k):\n1650         tot += 1\n1651     return tot\n",
        "intended_behavior": "This file, likely containing the implementation or significant interactions with the Bell numbers, needs to ensure that `bell(n).limit(n, oo)` evaluates correctly to infinity (`oo`). The intended behavior involves adjusting the Bell number implementation or its limit evaluation logic so that it accurately represents the mathematical property of the Bell numbers as their argument approaches infinity. This may involve adding a special case for the limit operation when applied to Bell numbers to return `oo`, ensuring compatibility with the mathematical definition of Bell numbers growing without bound. Adjustments must preserve the existing functionalities for Bell numbers, including their evaluations for finite values of `n` and other operations that may involve them."
    }
]