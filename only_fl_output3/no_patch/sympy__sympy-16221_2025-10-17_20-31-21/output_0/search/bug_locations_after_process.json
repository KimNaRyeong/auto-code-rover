[
    {
        "rel_file_path": "sympy/printing/printer.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/printing/printer.py",
        "start": 195,
        "end": 300,
        "class_name": "Printer",
        "method_name": null,
        "code": "195 class Printer(object):\n196     \"\"\" Generic printer\n197 \n198     Its job is to provide infrastructure for implementing new printers easily.\n199 \n200     If you want to define your custom Printer or your custom printing method\n201     for your custom class then see the example above: printer_example_ .\n202     \"\"\"\n203 \n204     _global_settings = {}\n205 \n206     _default_settings = {}\n207 \n208     emptyPrinter = str\n209     printmethod = None\n210 \n211     def __init__(self, settings=None):\n212         self._str = str\n213 \n214         self._settings = self._default_settings.copy()\n215         self._context = dict()  # mutable during printing\n216 \n217         for key, val in self._global_settings.items():\n218             if key in self._default_settings:\n219                 self._settings[key] = val\n220 \n221         if settings is not None:\n222             self._settings.update(settings)\n223 \n224             if len(self._settings) > len(self._default_settings):\n225                 for key in self._settings:\n226                     if key not in self._default_settings:\n227                         raise TypeError(\"Unknown setting '%s'.\" % key)\n228 \n229         # _print_level is the number of times self._print() was recursively\n230         # called. See StrPrinter._print_Float() for an example of usage\n231         self._print_level = 0\n232 \n233     @classmethod\n234     def set_global_settings(cls, **settings):\n235         \"\"\"Set system-wide printing settings. \"\"\"\n236         for key, val in settings.items():\n237             if val is not None:\n238                 cls._global_settings[key] = val\n239 \n240     @property\n241     def order(self):\n242         if 'order' in self._settings:\n243             return self._settings['order']\n244         else:\n245             raise AttributeError(\"No order defined.\")\n246 \n247     def doprint(self, expr):\n248         \"\"\"Returns printer's representation for expr (as a string)\"\"\"\n249         return self._str(self._print(expr))\n250 \n251     def _print(self, expr, **kwargs):\n252         \"\"\"Internal dispatcher\n253 \n254         Tries the following concepts to print an expression:\n255             1. Let the object print itself if it knows how.\n256             2. Take the best fitting method defined in the printer.\n257             3. As fall-back use the emptyPrinter method for the printer.\n258         \"\"\"\n259         self._print_level += 1\n260         try:\n261             # If the printer defines a name for a printing method\n262             # (Printer.printmethod) and the object knows for itself how it\n263             # should be printed, use that method.\n264             if (self.printmethod and hasattr(expr, self.printmethod)\n265                     and not isinstance(expr, BasicMeta)):\n266                 return getattr(expr, self.printmethod)(self, **kwargs)\n267 \n268             # See if the class of expr is known, or if one of its super\n269             # classes is known, and use that print function\n270             # Exception: ignore the subclasses of Undefined, so that, e.g.,\n271             # Function('gamma') does not get dispatched to _print_gamma\n272             classes = type(expr).__mro__\n273             if AppliedUndef in classes:\n274                 classes = classes[classes.index(AppliedUndef):]\n275             if UndefinedFunction in classes:\n276                 classes = classes[classes.index(UndefinedFunction):]\n277             # Another exception: if someone subclasses a known function, e.g.,\n278             # gamma, and changes the name, then ignore _print_gamma\n279             if Function in classes:\n280                 i = classes.index(Function)\n281                 classes = tuple(c for c in classes[:i] if \\\n282                     c.__name__ == classes[0].__name__ or \\\n283                     c.__name__.endswith(\"Base\")) + classes[i:]\n284             for cls in classes:\n285                 printmethod = '_print_' + cls.__name__\n286                 if hasattr(self, printmethod):\n287                     return getattr(self, printmethod)(expr, **kwargs)\n288             # Unknown object, fall back to the emptyPrinter.\n289             return self.emptyPrinter(expr)\n290         finally:\n291             self._print_level -= 1\n292 \n293     def _as_ordered_terms(self, expr, order=None):\n294         \"\"\"A compatibility function for ordering terms in Add. \"\"\"\n295         order = order or self.order\n296 \n297         if order == 'old':\n298             return sorted(Add.make_args(expr), key=cmp_to_key(Basic._compare_pretty))\n299         else:\n300             return expr.as_ordered_terms(order=order)\n",
        "intended_behavior": "The `Printer` class should be enhanced to support the formatting and printing of matrices and arrays, specifically for Mathematica outputs. This enhancement could involve adding a new method or modifying an existing one (e.g., `_print` method if it exists) to detect and process Mathematica matrix and array structures. Identify when an expression represents a matrix or array. Utilize or extend Mathematica's notation for matrices and arrays to ensure they are printed in a recognizable and usable format within Mathematica. Preserve existing functionality for other types of expressions or data structures, ensuring that the introduction of matrix and array support does not interfere with the current capabilities of the `Printer` class."
    }
]