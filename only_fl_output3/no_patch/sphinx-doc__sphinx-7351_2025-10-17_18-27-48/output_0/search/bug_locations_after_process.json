[
    {
        "rel_file_path": "sphinx/config.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/config.py",
        "start": 81,
        "end": 307,
        "class_name": "Config",
        "method_name": null,
        "code": "81 class Config:\n82     \"\"\"Configuration file abstraction.\n83 \n84     The config object makes the values of all config values available as\n85     attributes.\n86 \n87     It is exposed via the :py:attr:`sphinx.application.Application.config` and\n88     :py:attr:`sphinx.environment.Environment.config` attributes. For example,\n89     to get the value of :confval:`language`, use either ``app.config.language``\n90     or ``env.config.language``.\n91     \"\"\"\n92 \n93     # the values are: (default, what needs to be rebuilt if changed)\n94 \n95     # If you add a value here, don't forget to include it in the\n96     # quickstart.py file template as well as in the docs!\n97 \n98     config_values = {\n99         # general options\n100         'project': ('Python', 'env', []),\n101         'author': ('unknown', 'env', []),\n102         'copyright': ('', 'html', []),\n103         'version': ('', 'env', []),\n104         'release': ('', 'env', []),\n105         'today': ('', 'env', []),\n106         # the real default is locale-dependent\n107         'today_fmt': (None, 'env', [str]),\n108 \n109         'language': (None, 'env', [str]),\n110         'locale_dirs': (['locales'], 'env', []),\n111         'figure_language_filename': ('{root}.{language}{ext}', 'env', [str]),\n112 \n113         'master_doc': ('index', 'env', []),\n114         'source_suffix': ({'.rst': 'restructuredtext'}, 'env', Any),\n115         'source_encoding': ('utf-8-sig', 'env', []),\n116         'source_parsers': ({}, 'env', []),\n117         'exclude_patterns': ([], 'env', []),\n118         'default_role': (None, 'env', [str]),\n119         'add_function_parentheses': (True, 'env', []),\n120         'add_module_names': (True, 'env', []),\n121         'trim_footnote_reference_space': (False, 'env', []),\n122         'show_authors': (False, 'env', []),\n123         'pygments_style': (None, 'html', [str]),\n124         'highlight_language': ('default', 'env', []),\n125         'highlight_options': ({}, 'env', []),\n126         'templates_path': ([], 'html', []),\n127         'template_bridge': (None, 'html', [str]),\n128         'keep_warnings': (False, 'env', []),\n129         'suppress_warnings': ([], 'env', []),\n130         'modindex_common_prefix': ([], 'html', []),\n131         'rst_epilog': (None, 'env', [str]),\n132         'rst_prolog': (None, 'env', [str]),\n133         'trim_doctest_flags': (True, 'env', []),\n134         'primary_domain': ('py', 'env', [NoneType]),   # type: ignore\n135         'needs_sphinx': (None, None, [str]),\n136         'needs_extensions': ({}, None, []),\n137         'manpages_url': (None, 'env', []),\n138         'nitpicky': (False, None, []),\n139         'nitpick_ignore': ([], None, []),\n140         'numfig': (False, 'env', []),\n141         'numfig_secnum_depth': (1, 'env', []),\n142         'numfig_format': ({}, 'env', []),  # will be initialized in init_numfig_format()\n143 \n144         'math_number_all': (False, 'env', []),\n145         'math_eqref_format': (None, 'env', [str]),\n146         'math_numfig': (True, 'env', []),\n147         'tls_verify': (True, 'env', []),\n148         'tls_cacerts': (None, 'env', []),\n149         'user_agent': (None, 'env', [str]),\n150         'smartquotes': (True, 'env', []),\n151         'smartquotes_action': ('qDe', 'env', []),\n152         'smartquotes_excludes': ({'languages': ['ja'],\n153                                   'builders': ['man', 'text']},\n154                                  'env', []),\n155     }  # type: Dict[str, Tuple]\n156 \n157     def __init__(self, config: Dict[str, Any] = {}, overrides: Dict[str, Any] = {}) -> None:\n158         self.overrides = dict(overrides)\n159         self.values = Config.config_values.copy()\n160         self._raw_config = config\n161         self.setup = config.get('setup', None)  # type: Callable\n162 \n163         if 'extensions' in self.overrides:\n164             if isinstance(self.overrides['extensions'], str):\n165                 config['extensions'] = self.overrides.pop('extensions').split(',')\n166             else:\n167                 config['extensions'] = self.overrides.pop('extensions')\n168         self.extensions = config.get('extensions', [])  # type: List[str]\n169 \n170     @classmethod\n171     def read(cls, confdir: str, overrides: Dict = None, tags: Tags = None) -> \"Config\":\n172         \"\"\"Create a Config object from configuration file.\"\"\"\n173         filename = path.join(confdir, CONFIG_FILENAME)\n174         namespace = eval_config_file(filename, tags)\n175         return cls(namespace, overrides or {})\n176 \n177     def convert_overrides(self, name: str, value: Any) -> Any:\n178         if not isinstance(value, str):\n179             return value\n180         else:\n181             defvalue = self.values[name][0]\n182             if self.values[name][2] == Any:\n183                 return value\n184             elif type(defvalue) is bool or self.values[name][2] == [bool]:\n185                 if value == '0':\n186                     # given falsy string from command line option\n187                     return False\n188                 else:\n189                     return bool(value)\n190             elif isinstance(defvalue, dict):\n191                 raise ValueError(__('cannot override dictionary config setting %r, '\n192                                     'ignoring (use %r to set individual elements)') %\n193                                  (name, name + '.key=value'))\n194             elif isinstance(defvalue, list):\n195                 return value.split(',')\n196             elif isinstance(defvalue, int):\n197                 try:\n198                     return int(value)\n199                 except ValueError:\n200                     raise ValueError(__('invalid number %r for config value %r, ignoring') %\n201                                      (value, name))\n202             elif hasattr(defvalue, '__call__'):\n203                 return value\n204             elif defvalue is not None and not isinstance(defvalue, str):\n205                 raise ValueError(__('cannot override config setting %r with unsupported '\n206                                     'type, ignoring') % name)\n207             else:\n208                 return value\n209 \n210     def pre_init_values(self) -> None:\n211         \"\"\"\n212         Initialize some limited config variables before initialize i18n and loading extensions\n213         \"\"\"\n214         variables = ['needs_sphinx', 'suppress_warnings', 'language', 'locale_dirs']\n215         for name in variables:\n216             try:\n217                 if name in self.overrides:\n218                     self.__dict__[name] = self.convert_overrides(name, self.overrides[name])\n219                 elif name in self._raw_config:\n220                     self.__dict__[name] = self._raw_config[name]\n221             except ValueError as exc:\n222                 logger.warning(\"%s\", exc)\n223 \n224     def init_values(self) -> None:\n225         config = self._raw_config\n226         for valname, value in self.overrides.items():\n227             try:\n228                 if '.' in valname:\n229                     realvalname, key = valname.split('.', 1)\n230                     config.setdefault(realvalname, {})[key] = value\n231                     continue\n232                 elif valname not in self.values:\n233                     logger.warning(__('unknown config value %r in override, ignoring'),\n234                                    valname)\n235                     continue\n236                 if isinstance(value, str):\n237                     config[valname] = self.convert_overrides(valname, value)\n238                 else:\n239                     config[valname] = value\n240             except ValueError as exc:\n241                 logger.warning(\"%s\", exc)\n242         for name in config:\n243             if name in self.values:\n244                 self.__dict__[name] = config[name]\n245 \n246     def __getattr__(self, name: str) -> Any:\n247         if name.startswith('_'):\n248             raise AttributeError(name)\n249         if name not in self.values:\n250             raise AttributeError(__('No such config value: %s') % name)\n251         default = self.values[name][0]\n252         if hasattr(default, '__call__'):\n253             return default(self)\n254         return default\n255 \n256     def __getitem__(self, name: str) -> str:\n257         return getattr(self, name)\n258 \n259     def __setitem__(self, name: str, value: Any) -> None:\n260         setattr(self, name, value)\n261 \n262     def __delitem__(self, name: str) -> None:\n263         delattr(self, name)\n264 \n265     def __contains__(self, name: str) -> bool:\n266         return name in self.values\n267 \n268     def __iter__(self) -> Generator[ConfigValue, None, None]:\n269         for name, value in self.values.items():\n270             yield ConfigValue(name, getattr(self, name), value[1])\n271 \n272     def add(self, name: str, default: Any, rebuild: Union[bool, str], types: Any) -> None:\n273         if name in self.values:\n274             raise ExtensionError(__('Config value %r already present') % name)\n275         else:\n276             self.values[name] = (default, rebuild, types)\n277 \n278     def filter(self, rebuild: Union[str, List[str]]) -> Iterator[ConfigValue]:\n279         if isinstance(rebuild, str):\n280             rebuild = [rebuild]\n281         return (value for value in self if value.rebuild in rebuild)\n282 \n283     def __getstate__(self) -> Dict:\n284         \"\"\"Obtains serializable data for pickling.\"\"\"\n285         # remove potentially pickling-problematic values from config\n286         __dict__ = {}\n287         for key, value in self.__dict__.items():\n288             if key.startswith('_') or not is_serializable(value):\n289                 pass\n290             else:\n291                 __dict__[key] = value\n292 \n293         # create a picklable copy of values list\n294         __dict__['values'] = {}\n295         for key, value in self.values.items():\n296             real_value = getattr(self, key)\n297             if not is_serializable(real_value):\n298                 # omit unserializable value\n299                 real_value = None\n300 \n301             # types column is also omitted\n302             __dict__['values'][key] = (real_value, value[1], None)\n303 \n304         return __dict__\n305 \n306     def __setstate__(self, state: Dict) -> None:\n307         self.__dict__.update(state)\n",
        "intended_behavior": "Introduce a new configuration option, possibly named `file_extension_priority`, which allows users to specify the order of priority for file extensions. This would enable Sphinx to resolve conflicts where multiple files share the same basename but have different extensions. The configuration system would use this information to determine which file to prioritize during the build process. If this option is not set, Sphinx could maintain its current behavior or emit a warning indicating the conflict and suggesting the use of the new configuration option for resolution."
    },
    {
        "rel_file_path": "sphinx/environment/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.0/sphinx/environment/__init__.py",
        "start": 85,
        "end": 658,
        "class_name": "BuildEnvironment",
        "method_name": null,
        "code": "85 class BuildEnvironment:\n86     \"\"\"\n87     The environment in which the ReST files are translated.\n88     Stores an inventory of cross-file targets and provides doctree\n89     transformations to resolve links to them.\n90     \"\"\"\n91 \n92     domains = None  # type: Dict[str, Domain]\n93 \n94     # --------- ENVIRONMENT INITIALIZATION -------------------------------------\n95 \n96     def __init__(self, app: \"Sphinx\" = None):\n97         self.app = None                  # type: Sphinx\n98         self.doctreedir = None           # type: str\n99         self.srcdir = None               # type: str\n100         self.config = None               # type: Config\n101         self.config_status = None        # type: int\n102         self.config_status_extra = None  # type: str\n103         self.events = None               # type: EventManager\n104         self.project = None              # type: Project\n105         self.version = None              # type: Dict[str, str]\n106 \n107         # the method of doctree versioning; see set_versioning_method\n108         self.versioning_condition = None  # type: Union[bool, Callable]\n109         self.versioning_compare = None  # type: bool\n110 \n111         # all the registered domains, set by the application\n112         self.domains = {}\n113 \n114         # the docutils settings for building\n115         self.settings = default_settings.copy()\n116         self.settings['env'] = self\n117 \n118         # All \"docnames\" here are /-separated and relative and exclude\n119         # the source suffix.\n120 \n121         self.all_docs = {}          # type: Dict[str, float]\n122                                     # docname -> mtime at the time of reading\n123                                     # contains all read docnames\n124         self.dependencies = defaultdict(set)    # type: Dict[str, Set[str]]\n125                                     # docname -> set of dependent file\n126                                     # names, relative to documentation root\n127         self.included = defaultdict(set)        # type: Dict[str, Set[str]]\n128                                     # docname -> set of included file\n129                                     # docnames included from other documents\n130         self.reread_always = set()  # type: Set[str]\n131                                     # docnames to re-read unconditionally on\n132                                     # next build\n133 \n134         # File metadata\n135         self.metadata = defaultdict(dict)       # type: Dict[str, Dict[str, Any]]\n136                                                 # docname -> dict of metadata items\n137 \n138         # TOC inventory\n139         self.titles = {}            # type: Dict[str, nodes.title]\n140                                     # docname -> title node\n141         self.longtitles = {}        # type: Dict[str, nodes.title]\n142                                     # docname -> title node; only different if\n143                                     # set differently with title directive\n144         self.tocs = {}              # type: Dict[str, nodes.bullet_list]\n145                                     # docname -> table of contents nodetree\n146         self.toc_num_entries = {}   # type: Dict[str, int]\n147                                     # docname -> number of real entries\n148 \n149         # used to determine when to show the TOC\n150         # in a sidebar (don't show if it's only one item)\n151         self.toc_secnumbers = {}    # type: Dict[str, Dict[str, Tuple[int, ...]]]\n152                                     # docname -> dict of sectionid -> number\n153         self.toc_fignumbers = {}    # type: Dict[str, Dict[str, Dict[str, Tuple[int, ...]]]]\n154                                     # docname -> dict of figtype ->\n155                                     # dict of figureid -> number\n156 \n157         self.toctree_includes = {}  # type: Dict[str, List[str]]\n158                                     # docname -> list of toctree includefiles\n159         self.files_to_rebuild = {}  # type: Dict[str, Set[str]]\n160                                     # docname -> set of files\n161                                     # (containing its TOCs) to rebuild too\n162         self.glob_toctrees = set()  # type: Set[str]\n163                                     # docnames that have :glob: toctrees\n164         self.numbered_toctrees = set()  # type: Set[str]\n165                                         # docnames that have :numbered: toctrees\n166 \n167         # domain-specific inventories, here to be pickled\n168         self.domaindata = {}        # type: Dict[str, Dict]\n169                                     # domainname -> domain-specific dict\n170 \n171         # these map absolute path -> (docnames, unique filename)\n172         self.images = FilenameUniqDict()    # type: FilenameUniqDict\n173         self.dlfiles = DownloadFiles()      # type: DownloadFiles\n174                                             # filename -> (set of docnames, destination)\n175 \n176         # the original URI for images\n177         self.original_image_uri = {}  # type: Dict[str, str]\n178 \n179         # temporary data storage while reading a document\n180         self.temp_data = {}         # type: Dict[str, Any]\n181         # context for cross-references (e.g. current module or class)\n182         # this is similar to temp_data, but will for example be copied to\n183         # attributes of \"any\" cross references\n184         self.ref_context = {}       # type: Dict[str, Any]\n185 \n186         # set up environment\n187         if app:\n188             self.setup(app)\n189 \n190     def __getstate__(self) -> Dict:\n191         \"\"\"Obtains serializable data for pickling.\"\"\"\n192         __dict__ = self.__dict__.copy()\n193         __dict__.update(app=None, domains={}, events=None)  # clear unpickable attributes\n194         return __dict__\n195 \n196     def __setstate__(self, state: Dict) -> None:\n197         self.__dict__.update(state)\n198 \n199     def setup(self, app: \"Sphinx\") -> None:\n200         \"\"\"Set up BuildEnvironment object.\"\"\"\n201         if self.version and self.version != app.registry.get_envversion(app):\n202             raise BuildEnvironmentError(__('build environment version not current'))\n203         elif self.srcdir and self.srcdir != app.srcdir:\n204             raise BuildEnvironmentError(__('source directory has changed'))\n205 \n206         if self.project:\n207             app.project.restore(self.project)\n208 \n209         self.app = app\n210         self.doctreedir = app.doctreedir\n211         self.events = app.events\n212         self.srcdir = app.srcdir\n213         self.project = app.project\n214         self.version = app.registry.get_envversion(app)\n215 \n216         # initialize domains\n217         self.domains = {}\n218         for domain in app.registry.create_domains(self):\n219             self.domains[domain.name] = domain\n220 \n221         # setup domains (must do after all initialization)\n222         for domain in self.domains.values():\n223             domain.setup()\n224 \n225         # initialize config\n226         self._update_config(app.config)\n227 \n228         # initialie settings\n229         self._update_settings(app.config)\n230 \n231     def _update_config(self, config: Config) -> None:\n232         \"\"\"Update configurations by new one.\"\"\"\n233         self.config_status = CONFIG_OK\n234         self.config_status_extra = ''\n235         if self.config is None:\n236             self.config_status = CONFIG_NEW\n237         elif self.config.extensions != config.extensions:\n238             self.config_status = CONFIG_EXTENSIONS_CHANGED\n239             extensions = sorted(\n240                 set(self.config.extensions) ^ set(config.extensions))\n241             if len(extensions) == 1:\n242                 extension = extensions[0]\n243             else:\n244                 extension = '%d' % (len(extensions),)\n245             self.config_status_extra = ' (%r)' % (extension,)\n246         else:\n247             # check if a config value was changed that affects how\n248             # doctrees are read\n249             for item in config.filter('env'):\n250                 if self.config[item.name] != item.value:\n251                     self.config_status = CONFIG_CHANGED\n252                     self.config_status_extra = ' (%r)' % (item.name,)\n253                     break\n254 \n255         self.config = config\n256 \n257     def _update_settings(self, config: Config) -> None:\n258         \"\"\"Update settings by new config.\"\"\"\n259         self.settings['input_encoding'] = config.source_encoding\n260         self.settings['trim_footnote_reference_space'] = config.trim_footnote_reference_space\n261         self.settings['language_code'] = config.language or 'en'\n262 \n263         # Allow to disable by 3rd party extension (workaround)\n264         self.settings.setdefault('smart_quotes', True)\n265 \n266     def set_versioning_method(self, method: Union[str, Callable], compare: bool) -> None:\n267         \"\"\"This sets the doctree versioning method for this environment.\n268 \n269         Versioning methods are a builder property; only builders with the same\n270         versioning method can share the same doctree directory.  Therefore, we\n271         raise an exception if the user tries to use an environment with an\n272         incompatible versioning method.\n273         \"\"\"\n274         condition = None  # type: Union[bool, Callable]\n275         if callable(method):\n276             condition = method\n277         else:\n278             if method not in versioning_conditions:\n279                 raise ValueError('invalid versioning method: %r' % method)\n280             condition = versioning_conditions[method]\n281 \n282         if self.versioning_condition not in (None, condition):\n283             raise SphinxError(__('This environment is incompatible with the '\n284                                  'selected builder, please choose another '\n285                                  'doctree directory.'))\n286         self.versioning_condition = condition\n287         self.versioning_compare = compare\n288 \n289     def clear_doc(self, docname: str) -> None:\n290         \"\"\"Remove all traces of a source file in the inventory.\"\"\"\n291         if docname in self.all_docs:\n292             self.all_docs.pop(docname, None)\n293             self.included.pop(docname, None)\n294             self.reread_always.discard(docname)\n295 \n296         for domain in self.domains.values():\n297             domain.clear_doc(docname)\n298 \n299     def merge_info_from(self, docnames: List[str], other: \"BuildEnvironment\",\n300                         app: \"Sphinx\") -> None:\n301         \"\"\"Merge global information gathered about *docnames* while reading them\n302         from the *other* environment.\n303 \n304         This possibly comes from a parallel build process.\n305         \"\"\"\n306         docnames = set(docnames)  # type: ignore\n307         for docname in docnames:\n308             self.all_docs[docname] = other.all_docs[docname]\n309             self.included[docname] = other.included[docname]\n310             if docname in other.reread_always:\n311                 self.reread_always.add(docname)\n312 \n313         for domainname, domain in self.domains.items():\n314             domain.merge_domaindata(docnames, other.domaindata[domainname])\n315         self.events.emit('env-merge-info', self, docnames, other)\n316 \n317     def path2doc(self, filename: str) -> str:\n318         \"\"\"Return the docname for the filename if the file is document.\n319 \n320         *filename* should be absolute or relative to the source directory.\n321         \"\"\"\n322         return self.project.path2doc(filename)\n323 \n324     def doc2path(self, docname: str, base: Union[bool, str] = True, suffix: str = None) -> str:\n325         \"\"\"Return the filename for the document name.\n326 \n327         If *base* is True, return absolute path under self.srcdir.\n328         If *base* is None, return relative path to self.srcdir.\n329         If *base* is a path string, return absolute path under that.\n330         If *suffix* is not None, add it instead of config.source_suffix.\n331         \"\"\"\n332         if suffix:\n333             warnings.warn('The suffix argument for doc2path() is deprecated.',\n334                           RemovedInSphinx40Warning)\n335         if base not in (True, False, None):\n336             warnings.warn('The string style base argument for doc2path() is deprecated.',\n337                           RemovedInSphinx40Warning)\n338 \n339         pathname = self.project.doc2path(docname, base is True)\n340         if suffix:\n341             filename, _ = path.splitext(pathname)\n342             pathname = filename + suffix\n343         if base and base is not True:\n344             pathname = path.join(base, pathname)  # type: ignore\n345         return pathname\n346 \n347     def relfn2path(self, filename: str, docname: str = None) -> Tuple[str, str]:\n348         \"\"\"Return paths to a file referenced from a document, relative to\n349         documentation root and absolute.\n350 \n351         In the input \"filename\", absolute filenames are taken as relative to the\n352         source dir, while relative filenames are relative to the dir of the\n353         containing document.\n354         \"\"\"\n355         if filename.startswith('/') or filename.startswith(os.sep):\n356             rel_fn = filename[1:]\n357         else:\n358             docdir = path.dirname(self.doc2path(docname or self.docname,\n359                                                 base=None))\n360             rel_fn = path.join(docdir, filename)\n361         # the path.abspath() might seem redundant, but otherwise artifacts\n362         # such as \"..\" will remain in the path\n363         return rel_fn, path.abspath(path.join(self.srcdir, rel_fn))\n364 \n365     @property\n366     def found_docs(self) -> Set[str]:\n367         \"\"\"contains all existing docnames.\"\"\"\n368         return self.project.docnames\n369 \n370     def find_files(self, config: Config, builder: \"Builder\") -> None:\n371         \"\"\"Find all source files in the source dir and put them in\n372         self.found_docs.\n373         \"\"\"\n374         try:\n375             exclude_paths = (self.config.exclude_patterns +\n376                              self.config.templates_path +\n377                              builder.get_asset_paths())\n378             self.project.discover(exclude_paths)\n379 \n380             # Current implementation is applying translated messages in the reading\n381             # phase.Therefore, in order to apply the updated message catalog, it is\n382             # necessary to re-process from the reading phase. Here, if dependency\n383             # is set for the doc source and the mo file, it is processed again from\n384             # the reading phase when mo is updated. In the future, we would like to\n385             # move i18n process into the writing phase, and remove these lines.\n386             if builder.use_message_catalog:\n387                 # add catalog mo file dependency\n388                 repo = CatalogRepository(self.srcdir, self.config.locale_dirs,\n389                                          self.config.language, self.config.source_encoding)\n390                 for docname in self.found_docs:\n391                     domain = docname_to_domain(docname, self.config.gettext_compact)\n392                     for catalog in repo.catalogs:\n393                         if catalog.domain == domain:\n394                             self.dependencies[docname].add(catalog.mo_path)\n395         except OSError as exc:\n396             raise DocumentError(__('Failed to scan documents in %s: %r') % (self.srcdir, exc))\n397 \n398     def get_outdated_files(self, config_changed: bool) -> Tuple[Set[str], Set[str], Set[str]]:\n399         \"\"\"Return (added, changed, removed) sets.\"\"\"\n400         # clear all files no longer present\n401         removed = set(self.all_docs) - self.found_docs\n402 \n403         added = set()  # type: Set[str]\n404         changed = set()  # type: Set[str]\n405 \n406         if config_changed:\n407             # config values affect e.g. substitutions\n408             added = self.found_docs\n409         else:\n410             for docname in self.found_docs:\n411                 if docname not in self.all_docs:\n412                     added.add(docname)\n413                     continue\n414                 # if the doctree file is not there, rebuild\n415                 filename = path.join(self.doctreedir, docname + '.doctree')\n416                 if not path.isfile(filename):\n417                     changed.add(docname)\n418                     continue\n419                 # check the \"reread always\" list\n420                 if docname in self.reread_always:\n421                     changed.add(docname)\n422                     continue\n423                 # check the mtime of the document\n424                 mtime = self.all_docs[docname]\n425                 newmtime = path.getmtime(self.doc2path(docname))\n426                 if newmtime > mtime:\n427                     changed.add(docname)\n428                     continue\n429                 # finally, check the mtime of dependencies\n430                 for dep in self.dependencies[docname]:\n431                     try:\n432                         # this will do the right thing when dep is absolute too\n433                         deppath = path.join(self.srcdir, dep)\n434                         if not path.isfile(deppath):\n435                             changed.add(docname)\n436                             break\n437                         depmtime = path.getmtime(deppath)\n438                         if depmtime > mtime:\n439                             changed.add(docname)\n440                             break\n441                     except OSError:\n442                         # give it another chance\n443                         changed.add(docname)\n444                         break\n445 \n446         return added, changed, removed\n447 \n448     def check_dependents(self, app: \"Sphinx\", already: Set[str]) -> Generator[str, None, None]:\n449         to_rewrite = []  # type: List[str]\n450         for docnames in self.events.emit('env-get-updated', self):\n451             to_rewrite.extend(docnames)\n452         for docname in set(to_rewrite):\n453             if docname not in already:\n454                 yield docname\n455 \n456     # --------- SINGLE FILE READING --------------------------------------------\n457 \n458     def prepare_settings(self, docname: str) -> None:\n459         \"\"\"Prepare to set up environment for reading.\"\"\"\n460         self.temp_data['docname'] = docname\n461         # defaults to the global default, but can be re-set in a document\n462         self.temp_data['default_role'] = self.config.default_role\n463         self.temp_data['default_domain'] = \\\n464             self.domains.get(self.config.primary_domain)\n465 \n466     # utilities to use while reading a document\n467 \n468     @property\n469     def docname(self) -> str:\n470         \"\"\"Returns the docname of the document currently being parsed.\"\"\"\n471         return self.temp_data['docname']\n472 \n473     def new_serialno(self, category: str = '') -> int:\n474         \"\"\"Return a serial number, e.g. for index entry targets.\n475 \n476         The number is guaranteed to be unique in the current document.\n477         \"\"\"\n478         key = category + 'serialno'\n479         cur = self.temp_data.get(key, 0)\n480         self.temp_data[key] = cur + 1\n481         return cur\n482 \n483     def note_dependency(self, filename: str) -> None:\n484         \"\"\"Add *filename* as a dependency of the current document.\n485 \n486         This means that the document will be rebuilt if this file changes.\n487 \n488         *filename* should be absolute or relative to the source directory.\n489         \"\"\"\n490         self.dependencies[self.docname].add(filename)\n491 \n492     def note_included(self, filename: str) -> None:\n493         \"\"\"Add *filename* as a included from other document.\n494 \n495         This means the document is not orphaned.\n496 \n497         *filename* should be absolute or relative to the source directory.\n498         \"\"\"\n499         self.included[self.docname].add(self.path2doc(filename))\n500 \n501     def note_reread(self) -> None:\n502         \"\"\"Add the current document to the list of documents that will\n503         automatically be re-read at the next build.\n504         \"\"\"\n505         self.reread_always.add(self.docname)\n506 \n507     def get_domain(self, domainname: str) -> Domain:\n508         \"\"\"Return the domain instance with the specified name.\n509 \n510         Raises an ExtensionError if the domain is not registered.\n511         \"\"\"\n512         try:\n513             return self.domains[domainname]\n514         except KeyError:\n515             raise ExtensionError(__('Domain %r is not registered') % domainname)\n516 \n517     # --------- RESOLVING REFERENCES AND TOCTREES ------------------------------\n518 \n519     def get_doctree(self, docname: str) -> nodes.document:\n520         \"\"\"Read the doctree for a file from the pickle and return it.\"\"\"\n521         filename = path.join(self.doctreedir, docname + '.doctree')\n522         with open(filename, 'rb') as f:\n523             doctree = pickle.load(f)\n524         doctree.settings.env = self\n525         doctree.reporter = LoggingReporter(self.doc2path(docname))\n526         return doctree\n527 \n528     def get_and_resolve_doctree(self, docname: str, builder: \"Builder\",\n529                                 doctree: nodes.document = None, prune_toctrees: bool = True,\n530                                 includehidden: bool = False) -> nodes.document:\n531         \"\"\"Read the doctree from the pickle, resolve cross-references and\n532         toctrees and return it.\n533         \"\"\"\n534         if doctree is None:\n535             doctree = self.get_doctree(docname)\n536 \n537         # resolve all pending cross-references\n538         self.apply_post_transforms(doctree, docname)\n539 \n540         # now, resolve all toctree nodes\n541         for toctreenode in doctree.traverse(addnodes.toctree):\n542             result = TocTree(self).resolve(docname, builder, toctreenode,\n543                                            prune=prune_toctrees,\n544                                            includehidden=includehidden)\n545             if result is None:\n546                 toctreenode.replace_self([])\n547             else:\n548                 toctreenode.replace_self(result)\n549 \n550         return doctree\n551 \n552     def resolve_toctree(self, docname: str, builder: \"Builder\", toctree: addnodes.toctree,\n553                         prune: bool = True, maxdepth: int = 0, titles_only: bool = False,\n554                         collapse: bool = False, includehidden: bool = False) -> Node:\n555         \"\"\"Resolve a *toctree* node into individual bullet lists with titles\n556         as items, returning None (if no containing titles are found) or\n557         a new node.\n558 \n559         If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,\n560         to the value of the *maxdepth* option on the *toctree* node.\n561         If *titles_only* is True, only toplevel document titles will be in the\n562         resulting tree.\n563         If *collapse* is True, all branches not containing docname will\n564         be collapsed.\n565         \"\"\"\n566         return TocTree(self).resolve(docname, builder, toctree, prune,\n567                                      maxdepth, titles_only, collapse,\n568                                      includehidden)\n569 \n570     def resolve_references(self, doctree: nodes.document, fromdocname: str,\n571                            builder: \"Builder\") -> None:\n572         self.apply_post_transforms(doctree, fromdocname)\n573 \n574     def apply_post_transforms(self, doctree: nodes.document, docname: str) -> None:\n575         \"\"\"Apply all post-transforms.\"\"\"\n576         try:\n577             # set env.docname during applying post-transforms\n578             backup = copy(self.temp_data)\n579             self.temp_data['docname'] = docname\n580 \n581             transformer = SphinxTransformer(doctree)\n582             transformer.set_environment(self)\n583             transformer.add_transforms(self.app.registry.get_post_transforms())\n584             transformer.apply_transforms()\n585         finally:\n586             self.temp_data = backup\n587 \n588         # allow custom references to be resolved\n589         self.events.emit('doctree-resolved', doctree, docname)\n590 \n591     def collect_relations(self) -> Dict[str, List[str]]:\n592         traversed = set()\n593 \n594         def traverse_toctree(parent: str, docname: str) -> Iterator[Tuple[str, str]]:\n595             if parent == docname:\n596                 logger.warning(__('self referenced toctree found. Ignored.'), location=docname)\n597                 return\n598 \n599             # traverse toctree by pre-order\n600             yield parent, docname\n601             traversed.add(docname)\n602 \n603             for child in (self.toctree_includes.get(docname) or []):\n604                 for subparent, subdocname in traverse_toctree(docname, child):\n605                     if subdocname not in traversed:\n606                         yield subparent, subdocname\n607                         traversed.add(subdocname)\n608 \n609         relations = {}\n610         docnames = traverse_toctree(None, self.config.master_doc)\n611         prevdoc = None\n612         parent, docname = next(docnames)\n613         for nextparent, nextdoc in docnames:\n614             relations[docname] = [parent, prevdoc, nextdoc]\n615             prevdoc = docname\n616             docname = nextdoc\n617             parent = nextparent\n618 \n619         relations[docname] = [parent, prevdoc, None]\n620 \n621         return relations\n622 \n623     def check_consistency(self) -> None:\n624         \"\"\"Do consistency checks.\"\"\"\n625         included = set().union(*self.included.values())  # type: ignore\n626         for docname in sorted(self.all_docs):\n627             if docname not in self.files_to_rebuild:\n628                 if docname == self.config.master_doc:\n629                     # the master file is not included anywhere ;)\n630                     continue\n631                 if docname in included:\n632                     # the document is included from other documents\n633                     continue\n634                 if 'orphan' in self.metadata[docname]:\n635                     continue\n636                 logger.warning(__('document isn\\'t included in any toctree'),\n637                                location=docname)\n638 \n639         # call check-consistency for all extensions\n640         for domain in self.domains.values():\n641             domain.check_consistency()\n642         self.events.emit('env-check-consistency', self)\n643 \n644     @property\n645     def indexentries(self) -> Dict[str, List[Tuple[str, str, str, str, str]]]:\n646         warnings.warn('env.indexentries() is deprecated. Please use IndexDomain instead.',\n647                       RemovedInSphinx40Warning, stacklevel=2)\n648         from sphinx.domains.index import IndexDomain\n649         domain = cast(IndexDomain, self.get_domain('index'))\n650         return domain.entries\n651 \n652     @indexentries.setter\n653     def indexentries(self, entries: Dict[str, List[Tuple[str, str, str, str, str]]]) -> None:\n654         warnings.warn('env.indexentries() is deprecated. Please use IndexDomain instead.',\n655                       RemovedInSphinx40Warning, stacklevel=2)\n656         from sphinx.domains.index import IndexDomain\n657         domain = cast(IndexDomain, self.get_domain('index'))\n658         domain.data['entries'] = entries\n",
        "intended_behavior": "Modify the document collection/processing logic to consult the `file_extension_priority` configuration when encountering files with the same basename but differing extensions. This logic should then prioritize or select files based on the user-defined order in the configuration. If conflicts arise and no preference is defined, it should either follow a default priority order or, if feasible, log a warning to inform users of the unspecified conflict, encouraging them to define their preference via the new configuration option."
    }
]