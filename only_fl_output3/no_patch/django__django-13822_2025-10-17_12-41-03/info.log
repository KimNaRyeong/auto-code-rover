2025-10-17 12:41:03.535 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 12:41:08.168 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=236, output_tokens=12, cost=0.002720
2025-10-17 12:41:29.056 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=416, output_tokens=733, cost=0.026150
2025-10-17 12:41:30.319 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:41:40.319 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=541, output_tokens=415, cost=0.017860
2025-10-17 12:41:40.328 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:41:42.311 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=769, output_tokens=54, cost=0.009310
2025-10-17 12:41:42.313 | DEBUG    | Extracted a valid json.
2025-10-17 12:41:42.313 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"ManyToManyField\")",
        "search_class(\"AddField\")",
        "search_class(\"CreateModel\")",
        "search_code(\"fields.E305\")"
    ],
    "bug_locations": []
}
2025-10-17 12:41:42.384 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 12:41:42.384 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 12:42:00.663 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1954, output_tokens=830, cost=0.044440
2025-10-17 12:42:00.680 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 12:42:11.364 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3000, output_tokens=432, cost=0.042960
2025-10-17 12:42:11.373 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 12:42:18.952 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=786, output_tokens=352, cost=0.018420
2025-10-17 12:42:18.953 | DEBUG    | Extracted a valid json.
2025-10-17 12:42:18.953 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/db/models/fields/related.py",
            "class": "RelatedField",
            "method": "_check_clashes",
            "intended_behavior": "The `_check_clashes` method should be updated to correctly interpret `related_name='+'` as indicating that no reverse relationship should be created, and thus no clash could occur in this configuration. The method's logic for checking field name clashes should explicitly handle cases where `related_name='+'`, bypassing the error `fields.E305` under these specific circumstances. This adjustment would prevent raising unnecessary errors for models with the same name in different apps when they are correctly using `related_name='+'` to avoid reverse relationship conflicts."
        },
        {
            "file": "django/db/models/fields/related.py",
            "class": "ManyToManyField",
            "method": "",
            "intended_behavior": "Although the history of this issue does not pinpoint a specific method within `ManyToManyField` as problematic, ensuring that the `ManyToManyField` and its related methods (like `contribute_to_class`, `deconstruct`, `_get_m2m_db_table`) understand and respect the special handling required for `related_name='+'` is important. The `ManyToManyField` class should ensure that when `related_name='+'` is used, it signals clearly to all methods involved in migration processing and schema generation that reverse relation checks and conflict checks should be adjusted accordingly. This may not require a direct code change in a specific method but ensuring that the handling of `related_name='+'` is consistent across all relevant methods in this class."
        }
    ]
}
2025-10-17 12:42:18.963 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/fields/related.py</file>
<class>RelatedField</class>
<method>_check_clashes</method>
<code>
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors

</code><intended_behavior>The `_check_clashes` method should be updated to correctly interpret `related_name='+'` as indicating that no reverse relationship should be created, and thus no clash could occur in this configuration. The method's logic for checking field name clashes should explicitly handle cases where `related_name='+'`, bypassing the error `fields.E305` under these specific circumstances. This adjustment would prevent raising unnecessary errors for models with the same name in different apps when they are correctly using `related_name='+'` to avoid reverse relationship conflicts.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>RelatedField</class>
<method>None</method>
<code>
83 class RelatedField(FieldCacheMixin, Field):
84     """Base class that all relational fields inherit from."""
85 
86     # Field flags
87     one_to_many = False
88     one_to_one = False
89     many_to_many = False
90     many_to_one = False
91 
92     @cached_property
93     def related_model(self):
94         # Can't cache this property until all the models are loaded.
95         apps.check_models_ready()
96         return self.remote_field.model
97 
98     def check(self, **kwargs):
99         return [
100             *super().check(**kwargs),
101             *self._check_related_name_is_valid(),
102             *self._check_related_query_name_is_valid(),
103             *self._check_relation_model_exists(),
104             *self._check_referencing_to_swapped_model(),
105             *self._check_clashes(),
106         ]
107 
108     def _check_related_name_is_valid(self):
109         import keyword
110         related_name = self.remote_field.related_name
111         if related_name is None:
112             return []
113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()
114         if not (is_valid_id or related_name.endswith('+')):
115             return [
116                 checks.Error(
117                     "The name '%s' is invalid related_name for field %s.%s" %
118                     (self.remote_field.related_name, self.model._meta.object_name,
119                      self.name),
120                     hint="Related name must be a valid Python identifier or end with a '+'",
121                     obj=self,
122                     id='fields.E306',
123                 )
124             ]
125         return []
126 
127     def _check_related_query_name_is_valid(self):
128         if self.remote_field.is_hidden():
129             return []
130         rel_query_name = self.related_query_name()
131         errors = []
132         if rel_query_name.endswith('_'):
133             errors.append(
134                 checks.Error(
135                     "Reverse query name '%s' must not end with an underscore."
136                     % rel_query_name,
137                     hint=("Add or change a related_name or related_query_name "
138                           "argument for this field."),
139                     obj=self,
140                     id='fields.E308',
141                 )
142             )
143         if LOOKUP_SEP in rel_query_name:
144             errors.append(
145                 checks.Error(
146                     "Reverse query name '%s' must not contain '%s'."
147                     % (rel_query_name, LOOKUP_SEP),
148                     hint=("Add or change a related_name or related_query_name "
149                           "argument for this field."),
150                     obj=self,
151                     id='fields.E309',
152                 )
153             )
154         return errors
155 
156     def _check_relation_model_exists(self):
157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
158         rel_is_string = isinstance(self.remote_field.model, str)
159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name
160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):
161             return [
162                 checks.Error(
163                     "Field defines a relation with model '%s', which is either "
164                     "not installed, or is abstract." % model_name,
165                     obj=self,
166                     id='fields.E300',
167                 )
168             ]
169         return []
170 
171     def _check_referencing_to_swapped_model(self):
172         if (self.remote_field.model not in self.opts.apps.get_models() and
173                 not isinstance(self.remote_field.model, str) and
174                 self.remote_field.model._meta.swapped):
175             return [
176                 checks.Error(
177                     "Field defines a relation with the model '%s', which has "
178                     "been swapped out." % self.remote_field.model._meta.label,
179                     hint="Update the relation to point at 'settings.%s'." % self.remote_field.model._meta.swappable,
180                     obj=self,
181                     id='fields.E301',
182                 )
183             ]
184         return []
185 
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors
283 
284     def db_type(self, connection):
285         # By default related field will not have a column as it relates to
286         # columns from another table.
287         return None
288 
289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
290 
291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
292 
293         self.opts = cls._meta
294 
295         if not cls._meta.abstract:
296             if self.remote_field.related_name:
297                 related_name = self.remote_field.related_name
298             else:
299                 related_name = self.opts.default_related_name
300             if related_name:
301                 related_name = related_name % {
302                     'class': cls.__name__.lower(),
303                     'model_name': cls._meta.model_name.lower(),
304                     'app_label': cls._meta.app_label.lower()
305                 }
306                 self.remote_field.related_name = related_name
307 
308             if self.remote_field.related_query_name:
309                 related_query_name = self.remote_field.related_query_name % {
310                     'class': cls.__name__.lower(),
311                     'app_label': cls._meta.app_label.lower(),
312                 }
313                 self.remote_field.related_query_name = related_query_name
314 
315             def resolve_related_class(model, related, field):
316                 field.remote_field.model = related
317                 field.do_related_class(related, model)
318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)
319 
320     def deconstruct(self):
321         name, path, args, kwargs = super().deconstruct()
322         if self.remote_field.limit_choices_to:
323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to
324         if self.remote_field.related_name is not None:
325             kwargs['related_name'] = self.remote_field.related_name
326         if self.remote_field.related_query_name is not None:
327             kwargs['related_query_name'] = self.remote_field.related_query_name
328         return name, path, args, kwargs
329 
330     def get_forward_related_filter(self, obj):
331         """
332         Return the keyword arguments that when supplied to
333         self.model.object.filter(), would select all instances related through
334         this field to the remote obj. This is used to build the querysets
335         returned by related descriptors. obj is an instance of
336         self.related_field.model.
337         """
338         return {
339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)
340             for _, rh_field in self.related_fields
341         }
342 
343     def get_reverse_related_filter(self, obj):
344         """
345         Complement to get_forward_related_filter(). Return the keyword
346         arguments that when passed to self.related_field.model.object.filter()
347         select all instances of self.related_field.model related through
348         this field to obj. obj is an instance of self.model.
349         """
350         base_filter = {
351             rh_field.attname: getattr(obj, lh_field.attname)
352             for lh_field, rh_field in self.related_fields
353         }
354         descriptor_filter = self.get_extra_descriptor_filter(obj)
355         base_q = Q(**base_filter)
356         if isinstance(descriptor_filter, dict):
357             return base_q & Q(**descriptor_filter)
358         elif descriptor_filter:
359             return base_q & descriptor_filter
360         return base_q
361 
362     @property
363     def swappable_setting(self):
364         """
365         Get the setting that this is powered from for swapping, or None
366         if it's not swapped in / marked with swappable=False.
367         """
368         if self.swappable:
369             # Work out string form of "to"
370             if isinstance(self.remote_field.model, str):
371                 to_string = self.remote_field.model
372             else:
373                 to_string = self.remote_field.model._meta.label
374             return apps.get_swappable_settings_name(to_string)
375         return None
376 
377     def set_attributes_from_rel(self):
378         self.name = (
379             self.name or
380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)
381         )
382         if self.verbose_name is None:
383             self.verbose_name = self.remote_field.model._meta.verbose_name
384         self.remote_field.set_field_name()
385 
386     def do_related_class(self, other, cls):
387         self.set_attributes_from_rel()
388         self.contribute_to_related_class(other, self.remote_field)
389 
390     def get_limit_choices_to(self):
391         """
392         Return ``limit_choices_to`` for this model field.
393 
394         If it is a callable, it will be invoked and the result will be
395         returned.
396         """
397         if callable(self.remote_field.limit_choices_to):
398             return self.remote_field.limit_choices_to()
399         return self.remote_field.limit_choices_to
400 
401     def formfield(self, **kwargs):
402         """
403         Pass ``limit_choices_to`` to the field being constructed.
404 
405         Only passes it if there is a type that supports related fields.
406         This is a similar strategy used to pass the ``queryset`` to the field
407         being constructed.
408         """
409         defaults = {}
410         if hasattr(self.remote_field, 'get_related_field'):
411             # If this is a callable, do not invoke it here. Just pass
412             # it in the defaults for when the form class will later be
413             # instantiated.
414             limit_choices_to = self.remote_field.limit_choices_to
415             defaults.update({
416                 'limit_choices_to': limit_choices_to,
417             })
418         defaults.update(kwargs)
419         return super().formfield(**defaults)
420 
421     def related_query_name(self):
422         """
423         Define the name that can be used to identify this related object in a
424         table-spanning query.
425         """
426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name
427 
428     @property
429     def target_field(self):
430         """
431         When filtering against this relation, return the field on the remote
432         model against which the filtering should happen.
433         """
434         target_fields = self.get_path_info()[-1].target_fields
435         if len(target_fields) > 1:
436             raise exceptions.FieldError(
437                 "The relation has multiple target fields, but only single target field was asked for")
438         return target_fields[0]
439 
440     def get_cache_name(self):
441         return self.name

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ManyToManyField("%s", through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ManyToManyField("%s", through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = self.remote_field.model._meta.label
1483         if getattr(self.remote_field, 'through', None) is not None:
1484             if isinstance(self.remote_field.through, str):
1485                 kwargs['through'] = self.remote_field.through
1486             elif not self.remote_field.through._meta.auto_created:
1487                 kwargs['through'] = self.remote_field.through._meta.label
1488         # If swappable is True, then see if we're actually pointing to the target
1489         # of a swap.
1490         swappable_setting = self.swappable_setting
1491         if swappable_setting is not None:
1492             # If it's already a settings reference, error.
1493             if hasattr(kwargs['to'], "setting_name"):
1494                 if kwargs['to'].setting_name != swappable_setting:
1495                     raise ValueError(
1496                         "Cannot deconstruct a ManyToManyField pointing to a "
1497                         "model that is swapped in place of more than one model "
1498                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1499                     )
1500 
1501             kwargs['to'] = SettingsReference(
1502                 kwargs['to'],
1503                 swappable_setting,
1504             )
1505         return name, path, args, kwargs
1506 
1507     def _get_path_info(self, direct=False, filtered_relation=None):
1508         """Called by both direct and indirect m2m traversal."""
1509         int_model = self.remote_field.through
1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1512         if direct:
1513             join1infos = linkfield1.get_reverse_path_info()
1514             join2infos = linkfield2.get_path_info(filtered_relation)
1515         else:
1516             join1infos = linkfield2.get_reverse_path_info()
1517             join2infos = linkfield1.get_path_info(filtered_relation)
1518 
1519         # Get join infos between the last model of join 1 and the first model
1520         # of join 2. Assume the only reason these may differ is due to model
1521         # inheritance.
1522         join1_final = join1infos[-1].to_opts
1523         join2_initial = join2infos[0].from_opts
1524         if join1_final is join2_initial:
1525             intermediate_infos = []
1526         elif issubclass(join1_final.model, join2_initial.model):
1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1528         else:
1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1530 
1531         return [*join1infos, *intermediate_infos, *join2infos]
1532 
1533     def get_path_info(self, filtered_relation=None):
1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1535 
1536     def get_reverse_path_info(self, filtered_relation=None):
1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1538 
1539     def _get_m2m_db_table(self, opts):
1540         """
1541         Function that can be curried to provide the m2m table name for this
1542         relation.
1543         """
1544         if self.remote_field.through is not None:
1545             return self.remote_field.through._meta.db_table
1546         elif self.db_table:
1547             return self.db_table
1548         else:
1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1551 
1552     def _get_m2m_attr(self, related, attr):
1553         """
1554         Function that can be curried to provide the source accessor or DB
1555         column name for the m2m table.
1556         """
1557         cache_attr = '_m2m_%s_cache' % attr
1558         if hasattr(self, cache_attr):
1559             return getattr(self, cache_attr)
1560         if self.remote_field.through_fields is not None:
1561             link_field_name = self.remote_field.through_fields[0]
1562         else:
1563             link_field_name = None
1564         for f in self.remote_field.through._meta.fields:
1565             if (f.is_relation and f.remote_field.model == related.related_model and
1566                     (link_field_name is None or link_field_name == f.name)):
1567                 setattr(self, cache_attr, getattr(f, attr))
1568                 return getattr(self, cache_attr)
1569 
1570     def _get_m2m_reverse_attr(self, related, attr):
1571         """
1572         Function that can be curried to provide the related accessor or DB
1573         column name for the m2m table.
1574         """
1575         cache_attr = '_m2m_reverse_%s_cache' % attr
1576         if hasattr(self, cache_attr):
1577             return getattr(self, cache_attr)
1578         found = False
1579         if self.remote_field.through_fields is not None:
1580             link_field_name = self.remote_field.through_fields[1]
1581         else:
1582             link_field_name = None
1583         for f in self.remote_field.through._meta.fields:
1584             if f.is_relation and f.remote_field.model == related.model:
1585                 if link_field_name is None and related.related_model == related.model:
1586                     # If this is an m2m-intermediate to self,
1587                     # the first foreign key you find will be
1588                     # the source column. Keep searching for
1589                     # the second foreign key.
1590                     if found:
1591                         setattr(self, cache_attr, getattr(f, attr))
1592                         break
1593                     else:
1594                         found = True
1595                 elif link_field_name is None or link_field_name == f.name:
1596                     setattr(self, cache_attr, getattr(f, attr))
1597                     break
1598         return getattr(self, cache_attr)
1599 
1600     def contribute_to_class(self, cls, name, **kwargs):
1601         # To support multiple relations to self, it's useful to have a non-None
1602         # related name on symmetrical relations for internal reasons. The
1603         # concept doesn't make a lot of sense externally ("you want me to
1604         # specify *what* on my non-reversible relation?!"), so we set it up
1605         # automatically. The funky name reduces the chance of an accidental
1606         # clash.
1607         if self.remote_field.symmetrical and (
1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1609             self.remote_field.model == cls._meta.object_name
1610         ):
1611             self.remote_field.related_name = "%s_rel_+" % name
1612         elif self.remote_field.is_hidden():
1613             # If the backwards relation is disabled, replace the original
1614             # related_name with one generated from the m2m field name. Django
1615             # still uses backwards relations internally and we need to avoid
1616             # clashes between multiple m2m fields with related_name == '+'.
1617             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1618 
1619         super().contribute_to_class(cls, name, **kwargs)
1620 
1621         # The intermediate m2m model is not auto created if:
1622         #  1) There is a manually specified intermediate, or
1623         #  2) The class owning the m2m field is abstract.
1624         #  3) The class owning the m2m field has been swapped out.
1625         if not cls._meta.abstract:
1626             if self.remote_field.through:
1627                 def resolve_through_model(_, model, field):
1628                     field.remote_field.through = model
1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1630             elif not cls._meta.swapped:
1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1632 
1633         # Add the descriptor for the m2m relation.
1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1635 
1636         # Set up the accessor for the m2m table name for the relation.
1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1638 
1639     def contribute_to_related_class(self, cls, related):
1640         # Internal M2Ms (i.e., those with a related name ending with '+')
1641         # and swapped models don't get a related descriptor.
1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1644 
1645         # Set up the accessors for the column names on the m2m table.
1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1648 
1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1651 
1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1656 
1657     def set_attributes_from_rel(self):
1658         pass
1659 
1660     def value_from_object(self, obj):
1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1662 
1663     def save_form_data(self, instance, data):
1664         getattr(instance, self.attname).set(data)
1665 
1666     def formfield(self, *, using=None, **kwargs):
1667         defaults = {
1668             'form_class': forms.ModelMultipleChoiceField,
1669             'queryset': self.remote_field.model._default_manager.using(using),
1670             **kwargs,
1671         }
1672         # If initial is passed in, it's a list of related objects, but the
1673         # MultipleChoiceField takes a list of IDs.
1674         if defaults.get('initial') is not None:
1675             initial = defaults['initial']
1676             if callable(initial):
1677                 initial = initial()
1678             defaults['initial'] = [i.pk for i in initial]
1679         return super().formfield(**defaults)
1680 
1681     def db_check(self, connection):
1682         return None
1683 
1684     def db_type(self, connection):
1685         # A ManyToManyField is not represented by a single column,
1686         # so return None.
1687         return None
1688 
1689     def db_parameters(self, connection):
1690         return {"type": None, "check": None}

</code><intended_behavior>Although the history of this issue does not pinpoint a specific method within `ManyToManyField` as problematic, ensuring that the `ManyToManyField` and its related methods (like `contribute_to_class`, `deconstruct`, `_get_m2m_db_table`) understand and respect the special handling required for `related_name='+'` is important. The `ManyToManyField` class should ensure that when `related_name='+'` is used, it signals clearly to all methods involved in migration processing and schema generation that reverse relation checks and conflict checks should be adjusted accordingly. This may not require a direct code change in a specific method but ensuring that the handling of `related_name='+'` is consistent across all relevant methods in this class.</intended_behavior>]
2025-10-17 12:42:18.963 | INFO     | Search completed. Bug locations: [<file>django/db/models/fields/related.py</file>
<class>RelatedField</class>
<method>_check_clashes</method>
<code>
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors

</code><intended_behavior>The `_check_clashes` method should be updated to correctly interpret `related_name='+'` as indicating that no reverse relationship should be created, and thus no clash could occur in this configuration. The method's logic for checking field name clashes should explicitly handle cases where `related_name='+'`, bypassing the error `fields.E305` under these specific circumstances. This adjustment would prevent raising unnecessary errors for models with the same name in different apps when they are correctly using `related_name='+'` to avoid reverse relationship conflicts.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>RelatedField</class>
<method>None</method>
<code>
83 class RelatedField(FieldCacheMixin, Field):
84     """Base class that all relational fields inherit from."""
85 
86     # Field flags
87     one_to_many = False
88     one_to_one = False
89     many_to_many = False
90     many_to_one = False
91 
92     @cached_property
93     def related_model(self):
94         # Can't cache this property until all the models are loaded.
95         apps.check_models_ready()
96         return self.remote_field.model
97 
98     def check(self, **kwargs):
99         return [
100             *super().check(**kwargs),
101             *self._check_related_name_is_valid(),
102             *self._check_related_query_name_is_valid(),
103             *self._check_relation_model_exists(),
104             *self._check_referencing_to_swapped_model(),
105             *self._check_clashes(),
106         ]
107 
108     def _check_related_name_is_valid(self):
109         import keyword
110         related_name = self.remote_field.related_name
111         if related_name is None:
112             return []
113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()
114         if not (is_valid_id or related_name.endswith('+')):
115             return [
116                 checks.Error(
117                     "The name '%s' is invalid related_name for field %s.%s" %
118                     (self.remote_field.related_name, self.model._meta.object_name,
119                      self.name),
120                     hint="Related name must be a valid Python identifier or end with a '+'",
121                     obj=self,
122                     id='fields.E306',
123                 )
124             ]
125         return []
126 
127     def _check_related_query_name_is_valid(self):
128         if self.remote_field.is_hidden():
129             return []
130         rel_query_name = self.related_query_name()
131         errors = []
132         if rel_query_name.endswith('_'):
133             errors.append(
134                 checks.Error(
135                     "Reverse query name '%s' must not end with an underscore."
136                     % rel_query_name,
137                     hint=("Add or change a related_name or related_query_name "
138                           "argument for this field."),
139                     obj=self,
140                     id='fields.E308',
141                 )
142             )
143         if LOOKUP_SEP in rel_query_name:
144             errors.append(
145                 checks.Error(
146                     "Reverse query name '%s' must not contain '%s'."
147                     % (rel_query_name, LOOKUP_SEP),
148                     hint=("Add or change a related_name or related_query_name "
149                           "argument for this field."),
150                     obj=self,
151                     id='fields.E309',
152                 )
153             )
154         return errors
155 
156     def _check_relation_model_exists(self):
157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
158         rel_is_string = isinstance(self.remote_field.model, str)
159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name
160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):
161             return [
162                 checks.Error(
163                     "Field defines a relation with model '%s', which is either "
164                     "not installed, or is abstract." % model_name,
165                     obj=self,
166                     id='fields.E300',
167                 )
168             ]
169         return []
170 
171     def _check_referencing_to_swapped_model(self):
172         if (self.remote_field.model not in self.opts.apps.get_models() and
173                 not isinstance(self.remote_field.model, str) and
174                 self.remote_field.model._meta.swapped):
175             return [
176                 checks.Error(
177                     "Field defines a relation with the model '%s', which has "
178                     "been swapped out." % self.remote_field.model._meta.label,
179                     hint="Update the relation to point at 'settings.%s'." % self.remote_field.model._meta.swappable,
180                     obj=self,
181                     id='fields.E301',
182                 )
183             ]
184         return []
185 
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors
283 
284     def db_type(self, connection):
285         # By default related field will not have a column as it relates to
286         # columns from another table.
287         return None
288 
289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
290 
291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
292 
293         self.opts = cls._meta
294 
295         if not cls._meta.abstract:
296             if self.remote_field.related_name:
297                 related_name = self.remote_field.related_name
298             else:
299                 related_name = self.opts.default_related_name
300             if related_name:
301                 related_name = related_name % {
302                     'class': cls.__name__.lower(),
303                     'model_name': cls._meta.model_name.lower(),
304                     'app_label': cls._meta.app_label.lower()
305                 }
306                 self.remote_field.related_name = related_name
307 
308             if self.remote_field.related_query_name:
309                 related_query_name = self.remote_field.related_query_name % {
310                     'class': cls.__name__.lower(),
311                     'app_label': cls._meta.app_label.lower(),
312                 }
313                 self.remote_field.related_query_name = related_query_name
314 
315             def resolve_related_class(model, related, field):
316                 field.remote_field.model = related
317                 field.do_related_class(related, model)
318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)
319 
320     def deconstruct(self):
321         name, path, args, kwargs = super().deconstruct()
322         if self.remote_field.limit_choices_to:
323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to
324         if self.remote_field.related_name is not None:
325             kwargs['related_name'] = self.remote_field.related_name
326         if self.remote_field.related_query_name is not None:
327             kwargs['related_query_name'] = self.remote_field.related_query_name
328         return name, path, args, kwargs
329 
330     def get_forward_related_filter(self, obj):
331         """
332         Return the keyword arguments that when supplied to
333         self.model.object.filter(), would select all instances related through
334         this field to the remote obj. This is used to build the querysets
335         returned by related descriptors. obj is an instance of
336         self.related_field.model.
337         """
338         return {
339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)
340             for _, rh_field in self.related_fields
341         }
342 
343     def get_reverse_related_filter(self, obj):
344         """
345         Complement to get_forward_related_filter(). Return the keyword
346         arguments that when passed to self.related_field.model.object.filter()
347         select all instances of self.related_field.model related through
348         this field to obj. obj is an instance of self.model.
349         """
350         base_filter = {
351             rh_field.attname: getattr(obj, lh_field.attname)
352             for lh_field, rh_field in self.related_fields
353         }
354         descriptor_filter = self.get_extra_descriptor_filter(obj)
355         base_q = Q(**base_filter)
356         if isinstance(descriptor_filter, dict):
357             return base_q & Q(**descriptor_filter)
358         elif descriptor_filter:
359             return base_q & descriptor_filter
360         return base_q
361 
362     @property
363     def swappable_setting(self):
364         """
365         Get the setting that this is powered from for swapping, or None
366         if it's not swapped in / marked with swappable=False.
367         """
368         if self.swappable:
369             # Work out string form of "to"
370             if isinstance(self.remote_field.model, str):
371                 to_string = self.remote_field.model
372             else:
373                 to_string = self.remote_field.model._meta.label
374             return apps.get_swappable_settings_name(to_string)
375         return None
376 
377     def set_attributes_from_rel(self):
378         self.name = (
379             self.name or
380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)
381         )
382         if self.verbose_name is None:
383             self.verbose_name = self.remote_field.model._meta.verbose_name
384         self.remote_field.set_field_name()
385 
386     def do_related_class(self, other, cls):
387         self.set_attributes_from_rel()
388         self.contribute_to_related_class(other, self.remote_field)
389 
390     def get_limit_choices_to(self):
391         """
392         Return ``limit_choices_to`` for this model field.
393 
394         If it is a callable, it will be invoked and the result will be
395         returned.
396         """
397         if callable(self.remote_field.limit_choices_to):
398             return self.remote_field.limit_choices_to()
399         return self.remote_field.limit_choices_to
400 
401     def formfield(self, **kwargs):
402         """
403         Pass ``limit_choices_to`` to the field being constructed.
404 
405         Only passes it if there is a type that supports related fields.
406         This is a similar strategy used to pass the ``queryset`` to the field
407         being constructed.
408         """
409         defaults = {}
410         if hasattr(self.remote_field, 'get_related_field'):
411             # If this is a callable, do not invoke it here. Just pass
412             # it in the defaults for when the form class will later be
413             # instantiated.
414             limit_choices_to = self.remote_field.limit_choices_to
415             defaults.update({
416                 'limit_choices_to': limit_choices_to,
417             })
418         defaults.update(kwargs)
419         return super().formfield(**defaults)
420 
421     def related_query_name(self):
422         """
423         Define the name that can be used to identify this related object in a
424         table-spanning query.
425         """
426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name
427 
428     @property
429     def target_field(self):
430         """
431         When filtering against this relation, return the field on the remote
432         model against which the filtering should happen.
433         """
434         target_fields = self.get_path_info()[-1].target_fields
435         if len(target_fields) > 1:
436             raise exceptions.FieldError(
437                 "The relation has multiple target fields, but only single target field was asked for")
438         return target_fields[0]
439 
440     def get_cache_name(self):
441         return self.name

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>ManyToManyField</class>
<method>None</method>
<code>
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ManyToManyField("%s", through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ManyToManyField("%s", through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = self.remote_field.model._meta.label
1483         if getattr(self.remote_field, 'through', None) is not None:
1484             if isinstance(self.remote_field.through, str):
1485                 kwargs['through'] = self.remote_field.through
1486             elif not self.remote_field.through._meta.auto_created:
1487                 kwargs['through'] = self.remote_field.through._meta.label
1488         # If swappable is True, then see if we're actually pointing to the target
1489         # of a swap.
1490         swappable_setting = self.swappable_setting
1491         if swappable_setting is not None:
1492             # If it's already a settings reference, error.
1493             if hasattr(kwargs['to'], "setting_name"):
1494                 if kwargs['to'].setting_name != swappable_setting:
1495                     raise ValueError(
1496                         "Cannot deconstruct a ManyToManyField pointing to a "
1497                         "model that is swapped in place of more than one model "
1498                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1499                     )
1500 
1501             kwargs['to'] = SettingsReference(
1502                 kwargs['to'],
1503                 swappable_setting,
1504             )
1505         return name, path, args, kwargs
1506 
1507     def _get_path_info(self, direct=False, filtered_relation=None):
1508         """Called by both direct and indirect m2m traversal."""
1509         int_model = self.remote_field.through
1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1512         if direct:
1513             join1infos = linkfield1.get_reverse_path_info()
1514             join2infos = linkfield2.get_path_info(filtered_relation)
1515         else:
1516             join1infos = linkfield2.get_reverse_path_info()
1517             join2infos = linkfield1.get_path_info(filtered_relation)
1518 
1519         # Get join infos between the last model of join 1 and the first model
1520         # of join 2. Assume the only reason these may differ is due to model
1521         # inheritance.
1522         join1_final = join1infos[-1].to_opts
1523         join2_initial = join2infos[0].from_opts
1524         if join1_final is join2_initial:
1525             intermediate_infos = []
1526         elif issubclass(join1_final.model, join2_initial.model):
1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1528         else:
1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1530 
1531         return [*join1infos, *intermediate_infos, *join2infos]
1532 
1533     def get_path_info(self, filtered_relation=None):
1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1535 
1536     def get_reverse_path_info(self, filtered_relation=None):
1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1538 
1539     def _get_m2m_db_table(self, opts):
1540         """
1541         Function that can be curried to provide the m2m table name for this
1542         relation.
1543         """
1544         if self.remote_field.through is not None:
1545             return self.remote_field.through._meta.db_table
1546         elif self.db_table:
1547             return self.db_table
1548         else:
1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1551 
1552     def _get_m2m_attr(self, related, attr):
1553         """
1554         Function that can be curried to provide the source accessor or DB
1555         column name for the m2m table.
1556         """
1557         cache_attr = '_m2m_%s_cache' % attr
1558         if hasattr(self, cache_attr):
1559             return getattr(self, cache_attr)
1560         if self.remote_field.through_fields is not None:
1561             link_field_name = self.remote_field.through_fields[0]
1562         else:
1563             link_field_name = None
1564         for f in self.remote_field.through._meta.fields:
1565             if (f.is_relation and f.remote_field.model == related.related_model and
1566                     (link_field_name is None or link_field_name == f.name)):
1567                 setattr(self, cache_attr, getattr(f, attr))
1568                 return getattr(self, cache_attr)
1569 
1570     def _get_m2m_reverse_attr(self, related, attr):
1571         """
1572         Function that can be curried to provide the related accessor or DB
1573         column name for the m2m table.
1574         """
1575         cache_attr = '_m2m_reverse_%s_cache' % attr
1576         if hasattr(self, cache_attr):
1577             return getattr(self, cache_attr)
1578         found = False
1579         if self.remote_field.through_fields is not None:
1580             link_field_name = self.remote_field.through_fields[1]
1581         else:
1582             link_field_name = None
1583         for f in self.remote_field.through._meta.fields:
1584             if f.is_relation and f.remote_field.model == related.model:
1585                 if link_field_name is None and related.related_model == related.model:
1586                     # If this is an m2m-intermediate to self,
1587                     # the first foreign key you find will be
1588                     # the source column. Keep searching for
1589                     # the second foreign key.
1590                     if found:
1591                         setattr(self, cache_attr, getattr(f, attr))
1592                         break
1593                     else:
1594                         found = True
1595                 elif link_field_name is None or link_field_name == f.name:
1596                     setattr(self, cache_attr, getattr(f, attr))
1597                     break
1598         return getattr(self, cache_attr)
1599 
1600     def contribute_to_class(self, cls, name, **kwargs):
1601         # To support multiple relations to self, it's useful to have a non-None
1602         # related name on symmetrical relations for internal reasons. The
1603         # concept doesn't make a lot of sense externally ("you want me to
1604         # specify *what* on my non-reversible relation?!"), so we set it up
1605         # automatically. The funky name reduces the chance of an accidental
1606         # clash.
1607         if self.remote_field.symmetrical and (
1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1609             self.remote_field.model == cls._meta.object_name
1610         ):
1611             self.remote_field.related_name = "%s_rel_+" % name
1612         elif self.remote_field.is_hidden():
1613             # If the backwards relation is disabled, replace the original
1614             # related_name with one generated from the m2m field name. Django
1615             # still uses backwards relations internally and we need to avoid
1616             # clashes between multiple m2m fields with related_name == '+'.
1617             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1618 
1619         super().contribute_to_class(cls, name, **kwargs)
1620 
1621         # The intermediate m2m model is not auto created if:
1622         #  1) There is a manually specified intermediate, or
1623         #  2) The class owning the m2m field is abstract.
1624         #  3) The class owning the m2m field has been swapped out.
1625         if not cls._meta.abstract:
1626             if self.remote_field.through:
1627                 def resolve_through_model(_, model, field):
1628                     field.remote_field.through = model
1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1630             elif not cls._meta.swapped:
1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1632 
1633         # Add the descriptor for the m2m relation.
1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1635 
1636         # Set up the accessor for the m2m table name for the relation.
1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1638 
1639     def contribute_to_related_class(self, cls, related):
1640         # Internal M2Ms (i.e., those with a related name ending with '+')
1641         # and swapped models don't get a related descriptor.
1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1644 
1645         # Set up the accessors for the column names on the m2m table.
1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1648 
1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1651 
1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1656 
1657     def set_attributes_from_rel(self):
1658         pass
1659 
1660     def value_from_object(self, obj):
1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1662 
1663     def save_form_data(self, instance, data):
1664         getattr(instance, self.attname).set(data)
1665 
1666     def formfield(self, *, using=None, **kwargs):
1667         defaults = {
1668             'form_class': forms.ModelMultipleChoiceField,
1669             'queryset': self.remote_field.model._default_manager.using(using),
1670             **kwargs,
1671         }
1672         # If initial is passed in, it's a list of related objects, but the
1673         # MultipleChoiceField takes a list of IDs.
1674         if defaults.get('initial') is not None:
1675             initial = defaults['initial']
1676             if callable(initial):
1677                 initial = initial()
1678             defaults['initial'] = [i.pk for i in initial]
1679         return super().formfield(**defaults)
1680 
1681     def db_check(self, connection):
1682         return None
1683 
1684     def db_type(self, connection):
1685         # A ManyToManyField is not represented by a single column,
1686         # so return None.
1687         return None
1688 
1689     def db_parameters(self, connection):
1690         return {"type": None, "check": None}

</code><intended_behavior>Although the history of this issue does not pinpoint a specific method within `ManyToManyField` as problematic, ensuring that the `ManyToManyField` and its related methods (like `contribute_to_class`, `deconstruct`, `_get_m2m_db_table`) understand and respect the special handling required for `related_name='+'` is important. The `ManyToManyField` class should ensure that when `related_name='+'` is used, it signals clearly to all methods involved in migration processing and schema generation that reverse relation checks and conflict checks should be adjusted accordingly. This may not require a direct code change in a specific method but ensuring that the handling of `related_name='+'` is consistent across all relevant methods in this class.</intended_behavior>]
2025-10-17 12:42:18.964 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 12:42:18.964 | INFO     | Search-only: skipping patch selection
2025-10-17 12:42:19.101 | INFO     | Task django__django-13822 completed successfully.
2025-10-17 12:42:19.102 | INFO     | No patch generated. You can try running ACR again.
