[
    {
        "rel_file_path": "requests/sessions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.3/requests/sessions.py",
        "start": 534,
        "end": 606,
        "class_name": "Session",
        "method_name": "send",
        "code": "534     def send(self, request, **kwargs):\n535         \"\"\"Send a given PreparedRequest.\"\"\"\n536         # Set defaults that the hooks can utilize to ensure they always have\n537         # the correct parameters to reproduce the previous request.\n538         kwargs.setdefault('stream', self.stream)\n539         kwargs.setdefault('verify', self.verify)\n540         kwargs.setdefault('cert', self.cert)\n541         kwargs.setdefault('proxies', self.proxies)\n542 \n543         # It's possible that users might accidentally send a Request object.\n544         # Guard against that specific failure case.\n545         if not isinstance(request, PreparedRequest):\n546             raise ValueError('You can only send PreparedRequests.')\n547 \n548         while request.url in self.redirect_cache:\n549             request.url = self.redirect_cache.get(request.url)\n550 \n551         # Set up variables needed for resolve_redirects and dispatching of hooks\n552         allow_redirects = kwargs.pop('allow_redirects', True)\n553         stream = kwargs.get('stream')\n554         timeout = kwargs.get('timeout')\n555         verify = kwargs.get('verify')\n556         cert = kwargs.get('cert')\n557         proxies = kwargs.get('proxies')\n558         hooks = request.hooks\n559 \n560         # Get the appropriate adapter to use\n561         adapter = self.get_adapter(url=request.url)\n562 \n563         # Start time (approximately) of the request\n564         start = datetime.utcnow()\n565 \n566         # Send the request\n567         r = adapter.send(request, **kwargs)\n568 \n569         # Total elapsed time of the request (approximately)\n570         r.elapsed = datetime.utcnow() - start\n571 \n572         # Response manipulation hooks\n573         r = dispatch_hook('response', hooks, r, **kwargs)\n574 \n575         # Persist cookies\n576         if r.history:\n577 \n578             # If the hooks create history then we want those cookies too\n579             for resp in r.history:\n580                 extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n581 \n582         extract_cookies_to_jar(self.cookies, request, r.raw)\n583 \n584         # Redirect resolving generator.\n585         gen = self.resolve_redirects(r, request,\n586             stream=stream,\n587             timeout=timeout,\n588             verify=verify,\n589             cert=cert,\n590             proxies=proxies)\n591 \n592         # Resolve redirects if allowed.\n593         history = [resp for resp in gen] if allow_redirects else []\n594 \n595         # Shuffle things around if there's history.\n596         if history:\n597             # Insert the first (original) request at the start\n598             history.insert(0, r)\n599             # Get the last request made\n600             r = history.pop()\n601             r.history = history\n602 \n603         if not stream:\n604             r.content\n605 \n606         return r\n",
        "intended_behavior": "In the `send` method of the `Session` class, all instances of `socket.timeout` should be caught and re-raised as `requests.exceptions.Timeout`. This ensures that any timeout-related exceptions, regardless of their origin within the underlying network stack or `socket` library, are consistently handled as part of the `requests` library's public API. This change preserves the existing functionality by maintaining the method's overall behavior and purpose, which is to send a prepared request and return the response. The key improvement here is enhancing the robustness and predictability of exception handling related to timeouts. Specifically, adding a try-except block around the areas where `socket.timeout` might be raised (such as reading from or writing to a socket) and re-raising it as `requests.exceptions.Timeout` would achieve the intended behavior."
    },
    {
        "rel_file_path": "requests/sessions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.3/requests/sessions.py",
        "start": 253,
        "end": 639,
        "class_name": "Session",
        "method_name": null,
        "code": "253 class Session(SessionRedirectMixin):\n254     \"\"\"A Requests session.\n255 \n256     Provides cookie persistence, connection-pooling, and configuration.\n257 \n258     Basic Usage::\n259 \n260       >>> import requests\n261       >>> s = requests.Session()\n262       >>> s.get('http://httpbin.org/get')\n263       200\n264     \"\"\"\n265 \n266     __attrs__ = [\n267         'headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks',\n268         'params', 'verify', 'cert', 'prefetch', 'adapters', 'stream',\n269         'trust_env', 'max_redirects', 'redirect_cache']\n270 \n271     def __init__(self):\n272 \n273         #: A case-insensitive dictionary of headers to be sent on each\n274         #: :class:`Request <Request>` sent from this\n275         #: :class:`Session <Session>`.\n276         self.headers = default_headers()\n277 \n278         #: Default Authentication tuple or object to attach to\n279         #: :class:`Request <Request>`.\n280         self.auth = None\n281 \n282         #: Dictionary mapping protocol to the URL of the proxy (e.g.\n283         #: {'http': 'foo.bar:3128'}) to be used on each\n284         #: :class:`Request <Request>`.\n285         self.proxies = {}\n286 \n287         #: Event-handling hooks.\n288         self.hooks = default_hooks()\n289 \n290         #: Dictionary of querystring data to attach to each\n291         #: :class:`Request <Request>`. The dictionary values may be lists for\n292         #: representing multivalued query parameters.\n293         self.params = {}\n294 \n295         #: Stream response content default.\n296         self.stream = False\n297 \n298         #: SSL Verification default.\n299         self.verify = True\n300 \n301         #: SSL certificate default.\n302         self.cert = None\n303 \n304         #: Maximum number of redirects allowed. If the request exceeds this\n305         #: limit, a :class:`TooManyRedirects` exception is raised.\n306         self.max_redirects = DEFAULT_REDIRECT_LIMIT\n307 \n308         #: Should we trust the environment?\n309         self.trust_env = True\n310 \n311         #: A CookieJar containing all currently outstanding cookies set on this\n312         #: session. By default it is a\n313         #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but\n314         #: may be any other ``cookielib.CookieJar`` compatible object.\n315         self.cookies = cookiejar_from_dict({})\n316 \n317         # Default connection adapters.\n318         self.adapters = OrderedDict()\n319         self.mount('https://', HTTPAdapter())\n320         self.mount('http://', HTTPAdapter())\n321 \n322         self.redirect_cache = {}\n323 \n324     def __enter__(self):\n325         return self\n326 \n327     def __exit__(self, *args):\n328         self.close()\n329 \n330     def prepare_request(self, request):\n331         \"\"\"Constructs a :class:`PreparedRequest <PreparedRequest>` for\n332         transmission and returns it. The :class:`PreparedRequest` has settings\n333         merged from the :class:`Request <Request>` instance and those of the\n334         :class:`Session`.\n335 \n336         :param request: :class:`Request` instance to prepare with this\n337             session's settings.\n338         \"\"\"\n339         cookies = request.cookies or {}\n340 \n341         # Bootstrap CookieJar.\n342         if not isinstance(cookies, cookielib.CookieJar):\n343             cookies = cookiejar_from_dict(cookies)\n344 \n345         # Merge with session cookies\n346         merged_cookies = merge_cookies(\n347             merge_cookies(RequestsCookieJar(), self.cookies), cookies)\n348 \n349 \n350         # Set environment's basic authentication if not explicitly set.\n351         auth = request.auth\n352         if self.trust_env and not auth and not self.auth:\n353             auth = get_netrc_auth(request.url)\n354 \n355         p = PreparedRequest()\n356         p.prepare(\n357             method=request.method.upper(),\n358             url=request.url,\n359             files=request.files,\n360             data=request.data,\n361             headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict),\n362             params=merge_setting(request.params, self.params),\n363             auth=merge_setting(auth, self.auth),\n364             cookies=merged_cookies,\n365             hooks=merge_hooks(request.hooks, self.hooks),\n366         )\n367         return p\n368 \n369     def request(self, method, url,\n370         params=None,\n371         data=None,\n372         headers=None,\n373         cookies=None,\n374         files=None,\n375         auth=None,\n376         timeout=None,\n377         allow_redirects=True,\n378         proxies=None,\n379         hooks=None,\n380         stream=None,\n381         verify=None,\n382         cert=None):\n383         \"\"\"Constructs a :class:`Request <Request>`, prepares it and sends it.\n384         Returns :class:`Response <Response>` object.\n385 \n386         :param method: method for the new :class:`Request` object.\n387         :param url: URL for the new :class:`Request` object.\n388         :param params: (optional) Dictionary or bytes to be sent in the query\n389             string for the :class:`Request`.\n390         :param data: (optional) Dictionary or bytes to send in the body of the\n391             :class:`Request`.\n392         :param headers: (optional) Dictionary of HTTP Headers to send with the\n393             :class:`Request`.\n394         :param cookies: (optional) Dict or CookieJar object to send with the\n395             :class:`Request`.\n396         :param files: (optional) Dictionary of 'filename': file-like-objects\n397             for multipart encoding upload.\n398         :param auth: (optional) Auth tuple or callable to enable\n399             Basic/Digest/Custom HTTP Auth.\n400         :param timeout: (optional) Float describing the timeout of the\n401             request in seconds.\n402         :param allow_redirects: (optional) Boolean. Set to True by default.\n403         :param proxies: (optional) Dictionary mapping protocol to the URL of\n404             the proxy.\n405         :param stream: (optional) whether to immediately download the response\n406             content. Defaults to ``False``.\n407         :param verify: (optional) if ``True``, the SSL cert will be verified.\n408             A CA_BUNDLE path can also be provided.\n409         :param cert: (optional) if String, path to ssl client cert file (.pem).\n410             If Tuple, ('cert', 'key') pair.\n411         \"\"\"\n412 \n413         method = builtin_str(method)\n414 \n415         # Create the Request.\n416         req = Request(\n417             method = method.upper(),\n418             url = url,\n419             headers = headers,\n420             files = files,\n421             data = data or {},\n422             params = params or {},\n423             auth = auth,\n424             cookies = cookies,\n425             hooks = hooks,\n426         )\n427         prep = self.prepare_request(req)\n428 \n429         proxies = proxies or {}\n430 \n431         # Gather clues from the surrounding environment.\n432         if self.trust_env:\n433             # Set environment's proxies.\n434             env_proxies = get_environ_proxies(url) or {}\n435             for (k, v) in env_proxies.items():\n436                 proxies.setdefault(k, v)\n437 \n438             # Look for configuration.\n439             if verify is True or verify is None:\n440                 verify = os.environ.get('REQUESTS_CA_BUNDLE')\n441 \n442             # Curl compatibility.\n443             if verify is True or verify is None:\n444                 verify = os.environ.get('CURL_CA_BUNDLE')\n445 \n446         # Merge all the kwargs.\n447         proxies = merge_setting(proxies, self.proxies)\n448         stream = merge_setting(stream, self.stream)\n449         verify = merge_setting(verify, self.verify)\n450         cert = merge_setting(cert, self.cert)\n451 \n452         # Send the request.\n453         send_kwargs = {\n454             'stream': stream,\n455             'timeout': timeout,\n456             'verify': verify,\n457             'cert': cert,\n458             'proxies': proxies,\n459             'allow_redirects': allow_redirects,\n460         }\n461         resp = self.send(prep, **send_kwargs)\n462 \n463         return resp\n464 \n465     def get(self, url, **kwargs):\n466         \"\"\"Sends a GET request. Returns :class:`Response` object.\n467 \n468         :param url: URL for the new :class:`Request` object.\n469         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n470         \"\"\"\n471 \n472         kwargs.setdefault('allow_redirects', True)\n473         return self.request('GET', url, **kwargs)\n474 \n475     def options(self, url, **kwargs):\n476         \"\"\"Sends a OPTIONS request. Returns :class:`Response` object.\n477 \n478         :param url: URL for the new :class:`Request` object.\n479         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n480         \"\"\"\n481 \n482         kwargs.setdefault('allow_redirects', True)\n483         return self.request('OPTIONS', url, **kwargs)\n484 \n485     def head(self, url, **kwargs):\n486         \"\"\"Sends a HEAD request. Returns :class:`Response` object.\n487 \n488         :param url: URL for the new :class:`Request` object.\n489         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n490         \"\"\"\n491 \n492         kwargs.setdefault('allow_redirects', False)\n493         return self.request('HEAD', url, **kwargs)\n494 \n495     def post(self, url, data=None, **kwargs):\n496         \"\"\"Sends a POST request. Returns :class:`Response` object.\n497 \n498         :param url: URL for the new :class:`Request` object.\n499         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.\n500         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n501         \"\"\"\n502 \n503         return self.request('POST', url, data=data, **kwargs)\n504 \n505     def put(self, url, data=None, **kwargs):\n506         \"\"\"Sends a PUT request. Returns :class:`Response` object.\n507 \n508         :param url: URL for the new :class:`Request` object.\n509         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.\n510         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n511         \"\"\"\n512 \n513         return self.request('PUT', url, data=data, **kwargs)\n514 \n515     def patch(self, url, data=None, **kwargs):\n516         \"\"\"Sends a PATCH request. Returns :class:`Response` object.\n517 \n518         :param url: URL for the new :class:`Request` object.\n519         :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.\n520         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n521         \"\"\"\n522 \n523         return self.request('PATCH', url,  data=data, **kwargs)\n524 \n525     def delete(self, url, **kwargs):\n526         \"\"\"Sends a DELETE request. Returns :class:`Response` object.\n527 \n528         :param url: URL for the new :class:`Request` object.\n529         :param \\*\\*kwargs: Optional arguments that ``request`` takes.\n530         \"\"\"\n531 \n532         return self.request('DELETE', url, **kwargs)\n533 \n534     def send(self, request, **kwargs):\n535         \"\"\"Send a given PreparedRequest.\"\"\"\n536         # Set defaults that the hooks can utilize to ensure they always have\n537         # the correct parameters to reproduce the previous request.\n538         kwargs.setdefault('stream', self.stream)\n539         kwargs.setdefault('verify', self.verify)\n540         kwargs.setdefault('cert', self.cert)\n541         kwargs.setdefault('proxies', self.proxies)\n542 \n543         # It's possible that users might accidentally send a Request object.\n544         # Guard against that specific failure case.\n545         if not isinstance(request, PreparedRequest):\n546             raise ValueError('You can only send PreparedRequests.')\n547 \n548         while request.url in self.redirect_cache:\n549             request.url = self.redirect_cache.get(request.url)\n550 \n551         # Set up variables needed for resolve_redirects and dispatching of hooks\n552         allow_redirects = kwargs.pop('allow_redirects', True)\n553         stream = kwargs.get('stream')\n554         timeout = kwargs.get('timeout')\n555         verify = kwargs.get('verify')\n556         cert = kwargs.get('cert')\n557         proxies = kwargs.get('proxies')\n558         hooks = request.hooks\n559 \n560         # Get the appropriate adapter to use\n561         adapter = self.get_adapter(url=request.url)\n562 \n563         # Start time (approximately) of the request\n564         start = datetime.utcnow()\n565 \n566         # Send the request\n567         r = adapter.send(request, **kwargs)\n568 \n569         # Total elapsed time of the request (approximately)\n570         r.elapsed = datetime.utcnow() - start\n571 \n572         # Response manipulation hooks\n573         r = dispatch_hook('response', hooks, r, **kwargs)\n574 \n575         # Persist cookies\n576         if r.history:\n577 \n578             # If the hooks create history then we want those cookies too\n579             for resp in r.history:\n580                 extract_cookies_to_jar(self.cookies, resp.request, resp.raw)\n581 \n582         extract_cookies_to_jar(self.cookies, request, r.raw)\n583 \n584         # Redirect resolving generator.\n585         gen = self.resolve_redirects(r, request,\n586             stream=stream,\n587             timeout=timeout,\n588             verify=verify,\n589             cert=cert,\n590             proxies=proxies)\n591 \n592         # Resolve redirects if allowed.\n593         history = [resp for resp in gen] if allow_redirects else []\n594 \n595         # Shuffle things around if there's history.\n596         if history:\n597             # Insert the first (original) request at the start\n598             history.insert(0, r)\n599             # Get the last request made\n600             r = history.pop()\n601             r.history = history\n602 \n603         if not stream:\n604             r.content\n605 \n606         return r\n607 \n608     def get_adapter(self, url):\n609         \"\"\"Returns the appropriate connnection adapter for the given URL.\"\"\"\n610         for (prefix, adapter) in self.adapters.items():\n611 \n612             if url.lower().startswith(prefix):\n613                 return adapter\n614 \n615         # Nothing matches :-/\n616         raise InvalidSchema(\"No connection adapters were found for '%s'\" % url)\n617 \n618     def close(self):\n619         \"\"\"Closes all adapters and as such the session\"\"\"\n620         for v in self.adapters.values():\n621             v.close()\n622 \n623     def mount(self, prefix, adapter):\n624         \"\"\"Registers a connection adapter to a prefix.\n625 \n626         Adapters are sorted in descending order by key length.\"\"\"\n627 \n628         self.adapters[prefix] = adapter\n629         keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]\n630 \n631         for key in keys_to_move:\n632             self.adapters[key] = self.adapters.pop(key)\n633 \n634     def __getstate__(self):\n635         return dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)\n636 \n637     def __setstate__(self, state):\n638         for attr, value in state.items():\n639             setattr(self, attr, value)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]