2025-10-17 11:41:56.278 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-17 11:42:00.928 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=164, output_tokens=12, cost=0.002000
2025-10-17 11:42:00.929 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-17 11:42:00.933 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:42:05.797 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=472, output_tokens=177, cost=0.010030
2025-10-17 11:42:05.802 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:42:09.558 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=531, output_tokens=57, cost=0.007020
2025-10-17 11:42:09.559 | DEBUG    | Extracted a valid json.
2025-10-17 11:42:09.560 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"DatabaseOperations\")",
        "search_method_in_class(\"execute_sql_flush\", \"DatabaseOperations\")",
        "search_code(\"execute_sql_flush(connection.alias, sql_flush)\")"
    ],
    "bug_locations": []
}
2025-10-17 11:42:09.619 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-17 11:42:09.619 | DEBUG    | <Agent search> Analyzing search results.
2025-10-17 11:42:20.293 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=949, output_tokens=498, cost=0.024430
2025-10-17 11:42:20.298 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-17 11:42:30.543 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1663, output_tokens=469, cost=0.030700
2025-10-17 11:42:30.554 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-17 11:42:39.244 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=823, output_tokens=380, cost=0.019630
2025-10-17 11:42:39.245 | DEBUG    | Extracted a valid json.
2025-10-17 11:42:39.245 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/backends/sqlite3/operations.py",
            "class": "DatabaseOperations",
            "method": "execute_sql_flush",
            "intended_behavior": "The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally."
        },
        {
            "file": "django/db/backends/oracle/operations.py",
            "class": "DatabaseOperations",
            "method": "execute_sql_flush",
            "intended_behavior": "The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally."
        },
        {
            "file": "django/db/backends/postgresql/operations.py",
            "class": "DatabaseOperations",
            "method": "execute_sql_flush",
            "intended_behavior": "The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally."
        },
        {
            "file": "django/db/backends/mysql/operations.py",
            "class": "DatabaseOperations",
            "method": "execute_sql_flush",
            "intended_behavior": "The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally."
        },
        {
            "file": "django/db/backends/dummy/base.py",
            "class": "DatabaseOperations",
            "method": "execute_sql_flush",
            "intended_behavior": "The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally."
        }
    ]
}
2025-10-17 11:42:39.263 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/sqlite3/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
18 class DatabaseOperations(BaseDatabaseOperations):
19     cast_char_field_without_max_length = 'text'
20     cast_data_types = {
21         'DateField': 'TEXT',
22         'DateTimeField': 'TEXT',
23     }
24     explain_prefix = 'EXPLAIN QUERY PLAN'
25 
26     def bulk_batch_size(self, fields, objs):
27         """
28         SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of
29         999 variables per query.
30 
31         If there's only a single field to insert, the limit is 500
32         (SQLITE_MAX_COMPOUND_SELECT).
33         """
34         if len(fields) == 1:
35             return 500
36         elif len(fields) > 1:
37             return self.connection.features.max_query_params // len(fields)
38         else:
39             return len(objs)
40 
41     def check_expression_support(self, expression):
42         bad_fields = (models.DateField, models.DateTimeField, models.TimeField)
43         bad_aggregates = (models.Sum, models.Avg, models.Variance, models.StdDev)
44         if isinstance(expression, bad_aggregates):
45             for expr in expression.get_source_expressions():
46                 try:
47                     output_field = expr.output_field
48                 except (AttributeError, FieldError):
49                     # Not every subexpression has an output_field which is fine
50                     # to ignore.
51                     pass
52                 else:
53                     if isinstance(output_field, bad_fields):
54                         raise NotSupportedError(
55                             'You cannot use Sum, Avg, StdDev, and Variance '
56                             'aggregations on date/time fields in sqlite3 '
57                             'since date/time is saved as text.'
58                         )
59         if (
60             isinstance(expression, models.Aggregate) and
61             expression.distinct and
62             len(expression.source_expressions) > 1
63         ):
64             raise NotSupportedError(
65                 "SQLite doesn't support DISTINCT on aggregate functions "
66                 "accepting multiple arguments."
67             )
68 
69     def date_extract_sql(self, lookup_type, field_name):
70         """
71         Support EXTRACT with a user-defined function django_date_extract()
72         that's registered in connect(). Use single quotes because this is a
73         string and could otherwise cause a collision with a field name.
74         """
75         return "django_date_extract('%s', %s)" % (lookup_type.lower(), field_name)
76 
77     def date_interval_sql(self, timedelta):
78         return str(duration_microseconds(timedelta))
79 
80     def format_for_duration_arithmetic(self, sql):
81         """Do nothing since formatting is handled in the custom function."""
82         return sql
83 
84     def date_trunc_sql(self, lookup_type, field_name):
85         return "django_date_trunc('%s', %s)" % (lookup_type.lower(), field_name)
86 
87     def time_trunc_sql(self, lookup_type, field_name):
88         return "django_time_trunc('%s', %s)" % (lookup_type.lower(), field_name)
89 
90     def _convert_tznames_to_sql(self, tzname):
91         if settings.USE_TZ:
92             return "'%s'" % tzname, "'%s'" % self.connection.timezone_name
93         return 'NULL', 'NULL'
94 
95     def datetime_cast_date_sql(self, field_name, tzname):
96         return 'django_datetime_cast_date(%s, %s, %s)' % (
97             field_name, *self._convert_tznames_to_sql(tzname),
98         )
99 
100     def datetime_cast_time_sql(self, field_name, tzname):
101         return 'django_datetime_cast_time(%s, %s, %s)' % (
102             field_name, *self._convert_tznames_to_sql(tzname),
103         )
104 
105     def datetime_extract_sql(self, lookup_type, field_name, tzname):
106         return "django_datetime_extract('%s', %s, %s, %s)" % (
107             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
108         )
109 
110     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
111         return "django_datetime_trunc('%s', %s, %s, %s)" % (
112             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
113         )
114 
115     def time_extract_sql(self, lookup_type, field_name):
116         return "django_time_extract('%s', %s)" % (lookup_type.lower(), field_name)
117 
118     def pk_default_value(self):
119         return "NULL"
120 
121     def _quote_params_for_last_executed_query(self, params):
122         """
123         Only for last_executed_query! Don't use this to execute SQL queries!
124         """
125         # This function is limited both by SQLITE_LIMIT_VARIABLE_NUMBER (the
126         # number of parameters, default = 999) and SQLITE_MAX_COLUMN (the
127         # number of return values, default = 2000). Since Python's sqlite3
128         # module doesn't expose the get_limit() C API, assume the default
129         # limits are in effect and split the work in batches if needed.
130         BATCH_SIZE = 999
131         if len(params) > BATCH_SIZE:
132             results = ()
133             for index in range(0, len(params), BATCH_SIZE):
134                 chunk = params[index:index + BATCH_SIZE]
135                 results += self._quote_params_for_last_executed_query(chunk)
136             return results
137 
138         sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(params))
139         # Bypass Django's wrappers and use the underlying sqlite3 connection
140         # to avoid logging this query - it would trigger infinite recursion.
141         cursor = self.connection.connection.cursor()
142         # Native sqlite3 cursors cannot be used as context managers.
143         try:
144             return cursor.execute(sql, params).fetchone()
145         finally:
146             cursor.close()
147 
148     def last_executed_query(self, cursor, sql, params):
149         # Python substitutes parameters in Modules/_sqlite/cursor.c with:
150         # pysqlite_statement_bind_parameters(self->statement, parameters, allow_8bit_chars);
151         # Unfortunately there is no way to reach self->statement from Python,
152         # so we quote and substitute parameters manually.
153         if params:
154             if isinstance(params, (list, tuple)):
155                 params = self._quote_params_for_last_executed_query(params)
156             else:
157                 values = tuple(params.values())
158                 values = self._quote_params_for_last_executed_query(values)
159                 params = dict(zip(params, values))
160             return sql % params
161         # For consistency with SQLiteCursorWrapper.execute(), just return sql
162         # when there are no parameters. See #13648 and #17158.
163         else:
164             return sql
165 
166     def quote_name(self, name):
167         if name.startswith('"') and name.endswith('"'):
168             return name  # Quoting once is enough.
169         return '"%s"' % name
170 
171     def no_limit_value(self):
172         return -1
173 
174     def __references_graph(self, table_name):
175         query = """
176         WITH tables AS (
177             SELECT %s name
178             UNION
179             SELECT sqlite_master.name
180             FROM sqlite_master
181             JOIN tables ON (sql REGEXP %s || tables.name || %s)
182         ) SELECT name FROM tables;
183         """
184         params = (
185             table_name,
186             r'(?i)\s+references\s+("|\')?',
187             r'("|\')?\s*\(',
188         )
189         with self.connection.cursor() as cursor:
190             results = cursor.execute(query, params)
191             return [row[0] for row in results.fetchall()]
192 
193     @cached_property
194     def _references_graph(self):
195         # 512 is large enough to fit the ~330 tables (as of this writing) in
196         # Django's test suite.
197         return lru_cache(maxsize=512)(self.__references_graph)
198 
199     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
200         if tables and allow_cascade:
201             # Simulate TRUNCATE CASCADE by recursively collecting the tables
202             # referencing the tables to be flushed.
203             tables = set(chain.from_iterable(self._references_graph(table) for table in tables))
204         # Note: No requirement for reset of auto-incremented indices (cf. other
205         # sql_flush() implementations). Just return SQL at this point
206         return ['%s %s %s;' % (
207             style.SQL_KEYWORD('DELETE'),
208             style.SQL_KEYWORD('FROM'),
209             style.SQL_FIELD(self.quote_name(table))
210         ) for table in tables]
211 
212     def adapt_datetimefield_value(self, value):
213         if value is None:
214             return None
215 
216         # Expression values are adapted by the database.
217         if hasattr(value, 'resolve_expression'):
218             return value
219 
220         # SQLite doesn't support tz-aware datetimes
221         if timezone.is_aware(value):
222             if settings.USE_TZ:
223                 value = timezone.make_naive(value, self.connection.timezone)
224             else:
225                 raise ValueError("SQLite backend does not support timezone-aware datetimes when USE_TZ is False.")
226 
227         return str(value)
228 
229     def adapt_timefield_value(self, value):
230         if value is None:
231             return None
232 
233         # Expression values are adapted by the database.
234         if hasattr(value, 'resolve_expression'):
235             return value
236 
237         # SQLite doesn't support tz-aware datetimes
238         if timezone.is_aware(value):
239             raise ValueError("SQLite backend does not support timezone-aware times.")
240 
241         return str(value)
242 
243     def get_db_converters(self, expression):
244         converters = super().get_db_converters(expression)
245         internal_type = expression.output_field.get_internal_type()
246         if internal_type == 'DateTimeField':
247             converters.append(self.convert_datetimefield_value)
248         elif internal_type == 'DateField':
249             converters.append(self.convert_datefield_value)
250         elif internal_type == 'TimeField':
251             converters.append(self.convert_timefield_value)
252         elif internal_type == 'DecimalField':
253             converters.append(self.get_decimalfield_converter(expression))
254         elif internal_type == 'UUIDField':
255             converters.append(self.convert_uuidfield_value)
256         elif internal_type in ('NullBooleanField', 'BooleanField'):
257             converters.append(self.convert_booleanfield_value)
258         return converters
259 
260     def convert_datetimefield_value(self, value, expression, connection):
261         if value is not None:
262             if not isinstance(value, datetime.datetime):
263                 value = parse_datetime(value)
264             if settings.USE_TZ and not timezone.is_aware(value):
265                 value = timezone.make_aware(value, self.connection.timezone)
266         return value
267 
268     def convert_datefield_value(self, value, expression, connection):
269         if value is not None:
270             if not isinstance(value, datetime.date):
271                 value = parse_date(value)
272         return value
273 
274     def convert_timefield_value(self, value, expression, connection):
275         if value is not None:
276             if not isinstance(value, datetime.time):
277                 value = parse_time(value)
278         return value
279 
280     def get_decimalfield_converter(self, expression):
281         # SQLite stores only 15 significant digits. Digits coming from
282         # float inaccuracy must be removed.
283         create_decimal = decimal.Context(prec=15).create_decimal_from_float
284         if isinstance(expression, Col):
285             quantize_value = decimal.Decimal(1).scaleb(-expression.output_field.decimal_places)
286 
287             def converter(value, expression, connection):
288                 if value is not None:
289                     return create_decimal(value).quantize(quantize_value, context=expression.output_field.context)
290         else:
291             def converter(value, expression, connection):
292                 if value is not None:
293                     return create_decimal(value)
294         return converter
295 
296     def convert_uuidfield_value(self, value, expression, connection):
297         if value is not None:
298             value = uuid.UUID(value)
299         return value
300 
301     def convert_booleanfield_value(self, value, expression, connection):
302         return bool(value) if value in (1, 0) else value
303 
304     def bulk_insert_sql(self, fields, placeholder_rows):
305         return " UNION ALL ".join(
306             "SELECT %s" % ", ".join(row)
307             for row in placeholder_rows
308         )
309 
310     def combine_expression(self, connector, sub_expressions):
311         # SQLite doesn't have a ^ operator, so use the user-defined POWER
312         # function that's registered in connect().
313         if connector == '^':
314             return 'POWER(%s)' % ','.join(sub_expressions)
315         elif connector == '#':
316             return 'BITXOR(%s)' % ','.join(sub_expressions)
317         return super().combine_expression(connector, sub_expressions)
318 
319     def combine_duration_expression(self, connector, sub_expressions):
320         if connector not in ['+', '-']:
321             raise DatabaseError('Invalid connector for timedelta: %s.' % connector)
322         fn_params = ["'%s'" % connector] + sub_expressions
323         if len(fn_params) > 3:
324             raise ValueError('Too many params for timedelta operations.')
325         return "django_format_dtdelta(%s)" % ', '.join(fn_params)
326 
327     def integer_field_range(self, internal_type):
328         # SQLite doesn't enforce any integer constraints
329         return (None, None)
330 
331     def subtract_temporals(self, internal_type, lhs, rhs):
332         lhs_sql, lhs_params = lhs
333         rhs_sql, rhs_params = rhs
334         params = (*lhs_params, *rhs_params)
335         if internal_type == 'TimeField':
336             return 'django_time_diff(%s, %s)' % (lhs_sql, rhs_sql), params
337         return 'django_timestamp_diff(%s, %s)' % (lhs_sql, rhs_sql), params
338 
339     def insert_statement(self, ignore_conflicts=False):
340         return 'INSERT OR IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
21 class DatabaseOperations(BaseDatabaseOperations):
22     # Oracle uses NUMBER(5), NUMBER(11), and NUMBER(19) for integer fields.
23     # SmallIntegerField uses NUMBER(11) instead of NUMBER(5), which is used by
24     # SmallAutoField, to preserve backward compatibility.
25     integer_field_ranges = {
26         'SmallIntegerField': (-99999999999, 99999999999),
27         'IntegerField': (-99999999999, 99999999999),
28         'BigIntegerField': (-9999999999999999999, 9999999999999999999),
29         'PositiveBigIntegerField': (0, 9999999999999999999),
30         'PositiveSmallIntegerField': (0, 99999999999),
31         'PositiveIntegerField': (0, 99999999999),
32         'SmallAutoField': (-99999, 99999),
33         'AutoField': (-99999999999, 99999999999),
34         'BigAutoField': (-9999999999999999999, 9999999999999999999),
35     }
36     set_operators = {**BaseDatabaseOperations.set_operators, 'difference': 'MINUS'}
37 
38     # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.
39     _sequence_reset_sql = """
40 DECLARE
41     table_value integer;
42     seq_value integer;
43     seq_name user_tab_identity_cols.sequence_name%%TYPE;
44 BEGIN
45     BEGIN
46         SELECT sequence_name INTO seq_name FROM user_tab_identity_cols
47         WHERE  table_name = '%(table_name)s' AND
48                column_name = '%(column_name)s';
49         EXCEPTION WHEN NO_DATA_FOUND THEN
50             seq_name := '%(no_autofield_sequence_name)s';
51     END;
52 
53     SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;
54     SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences
55            WHERE sequence_name = seq_name;
56     WHILE table_value > seq_value LOOP
57         EXECUTE IMMEDIATE 'SELECT "'||seq_name||'".nextval FROM DUAL'
58         INTO seq_value;
59     END LOOP;
60 END;
61 /"""
62 
63     # Oracle doesn't support string without precision; use the max string size.
64     cast_char_field_without_max_length = 'NVARCHAR2(2000)'
65     cast_data_types = {
66         'AutoField': 'NUMBER(11)',
67         'BigAutoField': 'NUMBER(19)',
68         'SmallAutoField': 'NUMBER(5)',
69         'TextField': cast_char_field_without_max_length,
70     }
71 
72     def cache_key_culling_sql(self):
73         return 'SELECT cache_key FROM %s ORDER BY cache_key OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'
74 
75     def date_extract_sql(self, lookup_type, field_name):
76         if lookup_type == 'week_day':
77             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.
78             return "TO_CHAR(%s, 'D')" % field_name
79         elif lookup_type == 'iso_week_day':
80             return "TO_CHAR(%s - 1, 'D')" % field_name
81         elif lookup_type == 'week':
82             # IW = ISO week number
83             return "TO_CHAR(%s, 'IW')" % field_name
84         elif lookup_type == 'quarter':
85             return "TO_CHAR(%s, 'Q')" % field_name
86         elif lookup_type == 'iso_year':
87             return "TO_CHAR(%s, 'IYYY')" % field_name
88         else:
89             # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/EXTRACT-datetime.html
90             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
91 
92     def date_trunc_sql(self, lookup_type, field_name):
93         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
94         if lookup_type in ('year', 'month'):
95             return "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
96         elif lookup_type == 'quarter':
97             return "TRUNC(%s, 'Q')" % field_name
98         elif lookup_type == 'week':
99             return "TRUNC(%s, 'IW')" % field_name
100         else:
101             return "TRUNC(%s)" % field_name
102 
103     # Oracle crashes with "ORA-03113: end-of-file on communication channel"
104     # if the time zone name is passed in parameter. Use interpolation instead.
105     # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ
106     # This regexp matches all time zone names from the zoneinfo database.
107     _tzname_re = _lazy_re_compile(r'^[\w/:+-]+$')
108 
109     def _prepare_tzname_delta(self, tzname):
110         if '+' in tzname:
111             return tzname[tzname.find('+'):]
112         elif '-' in tzname:
113             return tzname[tzname.find('-'):]
114         return tzname
115 
116     def _convert_field_to_tz(self, field_name, tzname):
117         if not settings.USE_TZ:
118             return field_name
119         if not self._tzname_re.match(tzname):
120             raise ValueError("Invalid time zone name: %s" % tzname)
121         # Convert from connection timezone to the local time, returning
122         # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the
123         # TIME ZONE details.
124         if self.connection.timezone_name != tzname:
125             return "CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)" % (
126                 field_name,
127                 self.connection.timezone_name,
128                 self._prepare_tzname_delta(tzname),
129             )
130         return field_name
131 
132     def datetime_cast_date_sql(self, field_name, tzname):
133         field_name = self._convert_field_to_tz(field_name, tzname)
134         return 'TRUNC(%s)' % field_name
135 
136     def datetime_cast_time_sql(self, field_name, tzname):
137         # Since `TimeField` values are stored as TIMESTAMP where only the date
138         # part is ignored, convert the field to the specified timezone.
139         return self._convert_field_to_tz(field_name, tzname)
140 
141     def datetime_extract_sql(self, lookup_type, field_name, tzname):
142         field_name = self._convert_field_to_tz(field_name, tzname)
143         return self.date_extract_sql(lookup_type, field_name)
144 
145     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
146         field_name = self._convert_field_to_tz(field_name, tzname)
147         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
148         if lookup_type in ('year', 'month'):
149             sql = "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
150         elif lookup_type == 'quarter':
151             sql = "TRUNC(%s, 'Q')" % field_name
152         elif lookup_type == 'week':
153             sql = "TRUNC(%s, 'IW')" % field_name
154         elif lookup_type == 'day':
155             sql = "TRUNC(%s)" % field_name
156         elif lookup_type == 'hour':
157             sql = "TRUNC(%s, 'HH24')" % field_name
158         elif lookup_type == 'minute':
159             sql = "TRUNC(%s, 'MI')" % field_name
160         else:
161             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
162         return sql
163 
164     def time_trunc_sql(self, lookup_type, field_name):
165         # The implementation is similar to `datetime_trunc_sql` as both
166         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where
167         # the date part of the later is ignored.
168         if lookup_type == 'hour':
169             sql = "TRUNC(%s, 'HH24')" % field_name
170         elif lookup_type == 'minute':
171             sql = "TRUNC(%s, 'MI')" % field_name
172         elif lookup_type == 'second':
173             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
174         return sql
175 
176     def get_db_converters(self, expression):
177         converters = super().get_db_converters(expression)
178         internal_type = expression.output_field.get_internal_type()
179         if internal_type == 'TextField':
180             converters.append(self.convert_textfield_value)
181         elif internal_type == 'BinaryField':
182             converters.append(self.convert_binaryfield_value)
183         elif internal_type in ['BooleanField', 'NullBooleanField']:
184             converters.append(self.convert_booleanfield_value)
185         elif internal_type == 'DateTimeField':
186             if settings.USE_TZ:
187                 converters.append(self.convert_datetimefield_value)
188         elif internal_type == 'DateField':
189             converters.append(self.convert_datefield_value)
190         elif internal_type == 'TimeField':
191             converters.append(self.convert_timefield_value)
192         elif internal_type == 'UUIDField':
193             converters.append(self.convert_uuidfield_value)
194         # Oracle stores empty strings as null. If the field accepts the empty
195         # string, undo this to adhere to the Django convention of using
196         # the empty string instead of null.
197         if expression.field.empty_strings_allowed:
198             converters.append(
199                 self.convert_empty_bytes
200                 if internal_type == 'BinaryField' else
201                 self.convert_empty_string
202             )
203         return converters
204 
205     def convert_textfield_value(self, value, expression, connection):
206         if isinstance(value, Database.LOB):
207             value = value.read()
208         return value
209 
210     def convert_binaryfield_value(self, value, expression, connection):
211         if isinstance(value, Database.LOB):
212             value = force_bytes(value.read())
213         return value
214 
215     def convert_booleanfield_value(self, value, expression, connection):
216         if value in (0, 1):
217             value = bool(value)
218         return value
219 
220     # cx_Oracle always returns datetime.datetime objects for
221     # DATE and TIMESTAMP columns, but Django wants to see a
222     # python datetime.date, .time, or .datetime.
223 
224     def convert_datetimefield_value(self, value, expression, connection):
225         if value is not None:
226             value = timezone.make_aware(value, self.connection.timezone)
227         return value
228 
229     def convert_datefield_value(self, value, expression, connection):
230         if isinstance(value, Database.Timestamp):
231             value = value.date()
232         return value
233 
234     def convert_timefield_value(self, value, expression, connection):
235         if isinstance(value, Database.Timestamp):
236             value = value.time()
237         return value
238 
239     def convert_uuidfield_value(self, value, expression, connection):
240         if value is not None:
241             value = uuid.UUID(value)
242         return value
243 
244     @staticmethod
245     def convert_empty_string(value, expression, connection):
246         return '' if value is None else value
247 
248     @staticmethod
249     def convert_empty_bytes(value, expression, connection):
250         return b'' if value is None else value
251 
252     def deferrable_sql(self):
253         return " DEFERRABLE INITIALLY DEFERRED"
254 
255     def fetch_returned_insert_columns(self, cursor, returning_params):
256         columns = []
257         for param in returning_params:
258             value = param.get_value()
259             if value is None or value == []:
260                 # cx_Oracle < 6.3 returns None, >= 6.3 returns empty list.
261                 raise DatabaseError(
262                     'The database did not return a new row id. Probably '
263                     '"ORA-1403: no data found" was raised internally but was '
264                     'hidden by the Oracle OCI library (see '
265                     'https://code.djangoproject.com/ticket/28859).'
266                 )
267             # cx_Oracle < 7 returns value, >= 7 returns list with single value.
268             columns.append(value[0] if isinstance(value, list) else value)
269         return tuple(columns)
270 
271     def field_cast_sql(self, db_type, internal_type):
272         if db_type and db_type.endswith('LOB'):
273             return "DBMS_LOB.SUBSTR(%s)"
274         else:
275             return "%s"
276 
277     def no_limit_value(self):
278         return None
279 
280     def limit_offset_sql(self, low_mark, high_mark):
281         fetch, offset = self._get_limit_offset_params(low_mark, high_mark)
282         return ' '.join(sql for sql in (
283             ('OFFSET %d ROWS' % offset) if offset else None,
284             ('FETCH FIRST %d ROWS ONLY' % fetch) if fetch else None,
285         ) if sql)
286 
287     def last_executed_query(self, cursor, sql, params):
288         # https://cx-oracle.readthedocs.io/en/latest/cursor.html#Cursor.statement
289         # The DB API definition does not define this attribute.
290         statement = cursor.statement
291         # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's
292         # `statement` doesn't contain the query parameters. Substitute
293         # parameters manually.
294         if isinstance(params, (tuple, list)):
295             for i, param in enumerate(params):
296                 statement = statement.replace(':arg%d' % i, force_str(param, errors='replace'))
297         elif isinstance(params, dict):
298             for key, param in params.items():
299                 statement = statement.replace(':%s' % key, force_str(param, errors='replace'))
300         return statement
301 
302     def last_insert_id(self, cursor, table_name, pk_name):
303         sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)
304         cursor.execute('"%s".currval' % sq_name)
305         return cursor.fetchone()[0]
306 
307     def lookup_cast(self, lookup_type, internal_type=None):
308         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
309             return "UPPER(%s)"
310         return "%s"
311 
312     def max_in_list_size(self):
313         return 1000
314 
315     def max_name_length(self):
316         return 30
317 
318     def pk_default_value(self):
319         return "NULL"
320 
321     def prep_for_iexact_query(self, x):
322         return x
323 
324     def process_clob(self, value):
325         if value is None:
326             return ''
327         return value.read()
328 
329     def quote_name(self, name):
330         # SQL92 requires delimited (quoted) names to be case-sensitive.  When
331         # not quoted, Oracle has case-insensitive behavior for identifiers, but
332         # always defaults to uppercase.
333         # We simplify things by making Oracle identifiers always uppercase.
334         if not name.startswith('"') and not name.endswith('"'):
335             name = '"%s"' % truncate_name(name.upper(), self.max_name_length())
336         # Oracle puts the query text into a (query % args) construct, so % signs
337         # in names need to be escaped. The '%%' will be collapsed back to '%' at
338         # that stage so we aren't really making the name longer here.
339         name = name.replace('%', '%%')
340         return name.upper()
341 
342     def random_function_sql(self):
343         return "DBMS_RANDOM.RANDOM"
344 
345     def regex_lookup(self, lookup_type):
346         if lookup_type == 'regex':
347             match_option = "'c'"
348         else:
349             match_option = "'i'"
350         return 'REGEXP_LIKE(%%s, %%s, %s)' % match_option
351 
352     def return_insert_columns(self, fields):
353         if not fields:
354             return '', ()
355         field_names = []
356         params = []
357         for field in fields:
358             field_names.append('%s.%s' % (
359                 self.quote_name(field.model._meta.db_table),
360                 self.quote_name(field.column),
361             ))
362             params.append(InsertVar(field))
363         return 'RETURNING %s INTO %s' % (
364             ', '.join(field_names),
365             ', '.join(['%s'] * len(params)),
366         ), tuple(params)
367 
368     def __foreign_key_constraints(self, table_name, recursive):
369         with self.connection.cursor() as cursor:
370             if recursive:
371                 cursor.execute("""
372                     SELECT
373                         user_tables.table_name, rcons.constraint_name
374                     FROM
375                         user_tables
376                     JOIN
377                         user_constraints cons
378                         ON (user_tables.table_name = cons.table_name AND cons.constraint_type = ANY('P', 'U'))
379                     LEFT JOIN
380                         user_constraints rcons
381                         ON (user_tables.table_name = rcons.table_name AND rcons.constraint_type = 'R')
382                     START WITH user_tables.table_name = UPPER(%s)
383                     CONNECT BY NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name
384                     GROUP BY
385                         user_tables.table_name, rcons.constraint_name
386                     HAVING user_tables.table_name != UPPER(%s)
387                     ORDER BY MAX(level) DESC
388                 """, (table_name, table_name))
389             else:
390                 cursor.execute("""
391                     SELECT
392                         cons.table_name, cons.constraint_name
393                     FROM
394                         user_constraints cons
395                     WHERE
396                         cons.constraint_type = 'R'
397                         AND cons.table_name = UPPER(%s)
398                 """, (table_name,))
399             return cursor.fetchall()
400 
401     @cached_property
402     def _foreign_key_constraints(self):
403         # 512 is large enough to fit the ~330 tables (as of this writing) in
404         # Django's test suite.
405         return lru_cache(maxsize=512)(self.__foreign_key_constraints)
406 
407     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
408         if not tables:
409             return []
410 
411         truncated_tables = {table.upper() for table in tables}
412         constraints = set()
413         # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE foreign
414         # keys which Django doesn't define. Emulate the PostgreSQL behavior
415         # which truncates all dependent tables by manually retrieving all
416         # foreign key constraints and resolving dependencies.
417         for table in tables:
418             for foreign_table, constraint in self._foreign_key_constraints(table, recursive=allow_cascade):
419                 if allow_cascade:
420                     truncated_tables.add(foreign_table)
421                 constraints.add((foreign_table, constraint))
422         sql = [
423             '%s %s %s %s %s %s %s %s;' % (
424                 style.SQL_KEYWORD('ALTER'),
425                 style.SQL_KEYWORD('TABLE'),
426                 style.SQL_FIELD(self.quote_name(table)),
427                 style.SQL_KEYWORD('DISABLE'),
428                 style.SQL_KEYWORD('CONSTRAINT'),
429                 style.SQL_FIELD(self.quote_name(constraint)),
430                 style.SQL_KEYWORD('KEEP'),
431                 style.SQL_KEYWORD('INDEX'),
432             ) for table, constraint in constraints
433         ] + [
434             '%s %s %s;' % (
435                 style.SQL_KEYWORD('TRUNCATE'),
436                 style.SQL_KEYWORD('TABLE'),
437                 style.SQL_FIELD(self.quote_name(table)),
438             ) for table in truncated_tables
439         ] + [
440             '%s %s %s %s %s %s;' % (
441                 style.SQL_KEYWORD('ALTER'),
442                 style.SQL_KEYWORD('TABLE'),
443                 style.SQL_FIELD(self.quote_name(table)),
444                 style.SQL_KEYWORD('ENABLE'),
445                 style.SQL_KEYWORD('CONSTRAINT'),
446                 style.SQL_FIELD(self.quote_name(constraint)),
447             ) for table, constraint in constraints
448         ]
449         if reset_sequences:
450             sequences = [
451                 sequence
452                 for sequence in self.connection.introspection.sequence_list()
453                 if sequence['table'].upper() in truncated_tables
454             ]
455             # Since we've just deleted all the rows, running our sequence ALTER
456             # code will reset the sequence to 0.
457             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
458         return sql
459 
460     def sequence_reset_by_name_sql(self, style, sequences):
461         sql = []
462         for sequence_info in sequences:
463             no_autofield_sequence_name = self._get_no_autofield_sequence_name(sequence_info['table'])
464             table = self.quote_name(sequence_info['table'])
465             column = self.quote_name(sequence_info['column'] or 'id')
466             query = self._sequence_reset_sql % {
467                 'no_autofield_sequence_name': no_autofield_sequence_name,
468                 'table': table,
469                 'column': column,
470                 'table_name': strip_quotes(table),
471                 'column_name': strip_quotes(column),
472             }
473             sql.append(query)
474         return sql
475 
476     def sequence_reset_sql(self, style, model_list):
477         output = []
478         query = self._sequence_reset_sql
479         for model in model_list:
480             for f in model._meta.local_fields:
481                 if isinstance(f, AutoField):
482                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(model._meta.db_table)
483                     table = self.quote_name(model._meta.db_table)
484                     column = self.quote_name(f.column)
485                     output.append(query % {
486                         'no_autofield_sequence_name': no_autofield_sequence_name,
487                         'table': table,
488                         'column': column,
489                         'table_name': strip_quotes(table),
490                         'column_name': strip_quotes(column),
491                     })
492                     # Only one AutoField is allowed per model, so don't
493                     # continue to loop
494                     break
495             for f in model._meta.many_to_many:
496                 if not f.remote_field.through:
497                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(f.m2m_db_table())
498                     table = self.quote_name(f.m2m_db_table())
499                     column = self.quote_name('id')
500                     output.append(query % {
501                         'no_autofield_sequence_name': no_autofield_sequence_name,
502                         'table': table,
503                         'column': column,
504                         'table_name': strip_quotes(table),
505                         'column_name': 'ID',
506                     })
507         return output
508 
509     def start_transaction_sql(self):
510         return ''
511 
512     def tablespace_sql(self, tablespace, inline=False):
513         if inline:
514             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
515         else:
516             return "TABLESPACE %s" % self.quote_name(tablespace)
517 
518     def adapt_datefield_value(self, value):
519         """
520         Transform a date value to an object compatible with what is expected
521         by the backend driver for date columns.
522         The default implementation transforms the date to text, but that is not
523         necessary for Oracle.
524         """
525         return value
526 
527     def adapt_datetimefield_value(self, value):
528         """
529         Transform a datetime value to an object compatible with what is expected
530         by the backend driver for datetime columns.
531 
532         If naive datetime is passed assumes that is in UTC. Normally Django
533         models.DateTimeField makes sure that if USE_TZ is True passed datetime
534         is timezone aware.
535         """
536 
537         if value is None:
538             return None
539 
540         # Expression values are adapted by the database.
541         if hasattr(value, 'resolve_expression'):
542             return value
543 
544         # cx_Oracle doesn't support tz-aware datetimes
545         if timezone.is_aware(value):
546             if settings.USE_TZ:
547                 value = timezone.make_naive(value, self.connection.timezone)
548             else:
549                 raise ValueError("Oracle backend does not support timezone-aware datetimes when USE_TZ is False.")
550 
551         return Oracle_datetime.from_datetime(value)
552 
553     def adapt_timefield_value(self, value):
554         if value is None:
555             return None
556 
557         # Expression values are adapted by the database.
558         if hasattr(value, 'resolve_expression'):
559             return value
560 
561         if isinstance(value, str):
562             return datetime.datetime.strptime(value, '%H:%M:%S')
563 
564         # Oracle doesn't support tz-aware times
565         if timezone.is_aware(value):
566             raise ValueError("Oracle backend does not support timezone-aware times.")
567 
568         return Oracle_datetime(1900, 1, 1, value.hour, value.minute,
569                                value.second, value.microsecond)
570 
571     def combine_expression(self, connector, sub_expressions):
572         lhs, rhs = sub_expressions
573         if connector == '%%':
574             return 'MOD(%s)' % ','.join(sub_expressions)
575         elif connector == '&':
576             return 'BITAND(%s)' % ','.join(sub_expressions)
577         elif connector == '|':
578             return 'BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s' % {'lhs': lhs, 'rhs': rhs}
579         elif connector == '<<':
580             return '(%(lhs)s * POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
581         elif connector == '>>':
582             return 'FLOOR(%(lhs)s / POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
583         elif connector == '^':
584             return 'POWER(%s)' % ','.join(sub_expressions)
585         elif connector == '#':
586             raise NotSupportedError('Bitwise XOR is not supported in Oracle.')
587         return super().combine_expression(connector, sub_expressions)
588 
589     def _get_no_autofield_sequence_name(self, table):
590         """
591         Manually created sequence name to keep backward compatibility for
592         AutoFields that aren't Oracle identity columns.
593         """
594         name_length = self.max_name_length() - 3
595         return '%s_SQ' % truncate_name(strip_quotes(table), name_length).upper()
596 
597     def _get_sequence_name(self, cursor, table, pk_name):
598         cursor.execute("""
599             SELECT sequence_name
600             FROM user_tab_identity_cols
601             WHERE table_name = UPPER(%s)
602             AND column_name = UPPER(%s)""", [table, pk_name])
603         row = cursor.fetchone()
604         return self._get_no_autofield_sequence_name(table) if row is None else row[0]
605 
606     def bulk_insert_sql(self, fields, placeholder_rows):
607         query = []
608         for row in placeholder_rows:
609             select = []
610             for i, placeholder in enumerate(row):
611                 # A model without any fields has fields=[None].
612                 if fields[i]:
613                     internal_type = getattr(fields[i], 'target_field', fields[i]).get_internal_type()
614                     placeholder = BulkInsertMapper.types.get(internal_type, '%s') % placeholder
615                 # Add columns aliases to the first select to avoid "ORA-00918:
616                 # column ambiguously defined" when two or more columns in the
617                 # first select have the same value.
618                 if not query:
619                     placeholder = '%s col_%s' % (placeholder, i)
620                 select.append(placeholder)
621             query.append('SELECT %s FROM DUAL' % ', '.join(select))
622         # Bulk insert to tables with Oracle identity columns causes Oracle to
623         # add sequence.nextval to it. Sequence.nextval cannot be used with the
624         # UNION operator. To prevent incorrect SQL, move UNION to a subquery.
625         return 'SELECT * FROM (%s)' % ' UNION ALL '.join(query)
626 
627     def subtract_temporals(self, internal_type, lhs, rhs):
628         if internal_type == 'DateField':
629             lhs_sql, lhs_params = lhs
630             rhs_sql, rhs_params = rhs
631             params = (*lhs_params, *rhs_params)
632             return "NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')" % (lhs_sql, rhs_sql), params
633         return super().subtract_temporals(internal_type, lhs, rhs)
634 
635     def bulk_batch_size(self, fields, objs):
636         """Oracle restricts the number of parameters in a query."""
637         if fields:
638             return self.connection.features.max_query_params // len(fields)
639         return len(objs)
640 
641     def conditional_expression_supported_in_where_clause(self, expression):
642         """
643         Oracle supports only EXISTS(...) or filters in the WHERE clause, others
644         must be compared with True.
645         """
646         if isinstance(expression, (Exists, WhereNode)):
647             return True
648         if isinstance(expression, ExpressionWrapper) and expression.conditional:
649             return self.conditional_expression_supported_in_where_clause(expression.expression)
650         if isinstance(expression, RawSQL) and expression.conditional:
651             return True
652         return False

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/postgresql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
7 class DatabaseOperations(BaseDatabaseOperations):
8     cast_char_field_without_max_length = 'varchar'
9     explain_prefix = 'EXPLAIN'
10     cast_data_types = {
11         'AutoField': 'integer',
12         'BigAutoField': 'bigint',
13         'SmallAutoField': 'smallint',
14     }
15 
16     def unification_cast_sql(self, output_field):
17         internal_type = output_field.get_internal_type()
18         if internal_type in ("GenericIPAddressField", "IPAddressField", "TimeField", "UUIDField"):
19             # PostgreSQL will resolve a union as type 'text' if input types are
20             # 'unknown'.
21             # https://www.postgresql.org/docs/current/typeconv-union-case.html
22             # These fields cannot be implicitly cast back in the default
23             # PostgreSQL configuration so we need to explicitly cast them.
24             # We must also remove components of the type within brackets:
25             # varchar(255) -> varchar.
26             return 'CAST(%%s AS %s)' % output_field.db_type(self.connection).split('(')[0]
27         return '%s'
28 
29     def date_extract_sql(self, lookup_type, field_name):
30         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
31         if lookup_type == 'week_day':
32             # For consistency across backends, we return Sunday=1, Saturday=7.
33             return "EXTRACT('dow' FROM %s) + 1" % field_name
34         elif lookup_type == 'iso_week_day':
35             return "EXTRACT('isodow' FROM %s)" % field_name
36         elif lookup_type == 'iso_year':
37             return "EXTRACT('isoyear' FROM %s)" % field_name
38         else:
39             return "EXTRACT('%s' FROM %s)" % (lookup_type, field_name)
40 
41     def date_trunc_sql(self, lookup_type, field_name):
42         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
43         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
44 
45     def _prepare_tzname_delta(self, tzname):
46         if '+' in tzname:
47             return tzname.replace('+', '-')
48         elif '-' in tzname:
49             return tzname.replace('-', '+')
50         return tzname
51 
52     def _convert_field_to_tz(self, field_name, tzname):
53         if settings.USE_TZ:
54             field_name = "%s AT TIME ZONE '%s'" % (field_name, self._prepare_tzname_delta(tzname))
55         return field_name
56 
57     def datetime_cast_date_sql(self, field_name, tzname):
58         field_name = self._convert_field_to_tz(field_name, tzname)
59         return '(%s)::date' % field_name
60 
61     def datetime_cast_time_sql(self, field_name, tzname):
62         field_name = self._convert_field_to_tz(field_name, tzname)
63         return '(%s)::time' % field_name
64 
65     def datetime_extract_sql(self, lookup_type, field_name, tzname):
66         field_name = self._convert_field_to_tz(field_name, tzname)
67         return self.date_extract_sql(lookup_type, field_name)
68 
69     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
70         field_name = self._convert_field_to_tz(field_name, tzname)
71         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
72         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
73 
74     def time_trunc_sql(self, lookup_type, field_name):
75         return "DATE_TRUNC('%s', %s)::time" % (lookup_type, field_name)
76 
77     def deferrable_sql(self):
78         return " DEFERRABLE INITIALLY DEFERRED"
79 
80     def fetch_returned_insert_rows(self, cursor):
81         """
82         Given a cursor object that has just performed an INSERT...RETURNING
83         statement into a table, return the tuple of returned data.
84         """
85         return cursor.fetchall()
86 
87     def lookup_cast(self, lookup_type, internal_type=None):
88         lookup = '%s'
89 
90         # Cast text lookups to text to allow things like filter(x__contains=4)
91         if lookup_type in ('iexact', 'contains', 'icontains', 'startswith',
92                            'istartswith', 'endswith', 'iendswith', 'regex', 'iregex'):
93             if internal_type in ('IPAddressField', 'GenericIPAddressField'):
94                 lookup = "HOST(%s)"
95             elif internal_type in ('CICharField', 'CIEmailField', 'CITextField'):
96                 lookup = '%s::citext'
97             else:
98                 lookup = "%s::text"
99 
100         # Use UPPER(x) for case-insensitive lookups; it's faster.
101         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
102             lookup = 'UPPER(%s)' % lookup
103 
104         return lookup
105 
106     def no_limit_value(self):
107         return None
108 
109     def prepare_sql_script(self, sql):
110         return [sql]
111 
112     def quote_name(self, name):
113         if name.startswith('"') and name.endswith('"'):
114             return name  # Quoting once is enough.
115         return '"%s"' % name
116 
117     def set_time_zone_sql(self):
118         return "SET TIME ZONE %s"
119 
120     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
121         if not tables:
122             return []
123 
124         # Perform a single SQL 'TRUNCATE x, y, z...;' statement. It allows us
125         # to truncate tables referenced by a foreign key in any other table.
126         sql_parts = [
127             style.SQL_KEYWORD('TRUNCATE'),
128             ', '.join(style.SQL_FIELD(self.quote_name(table)) for table in tables),
129         ]
130         if reset_sequences:
131             sql_parts.append(style.SQL_KEYWORD('RESTART IDENTITY'))
132         if allow_cascade:
133             sql_parts.append(style.SQL_KEYWORD('CASCADE'))
134         return ['%s;' % ' '.join(sql_parts)]
135 
136     def sequence_reset_by_name_sql(self, style, sequences):
137         # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements
138         # to reset sequence indices
139         sql = []
140         for sequence_info in sequences:
141             table_name = sequence_info['table']
142             # 'id' will be the case if it's an m2m using an autogenerated
143             # intermediate table (see BaseDatabaseIntrospection.sequence_list).
144             column_name = sequence_info['column'] or 'id'
145             sql.append("%s setval(pg_get_serial_sequence('%s','%s'), 1, false);" % (
146                 style.SQL_KEYWORD('SELECT'),
147                 style.SQL_TABLE(self.quote_name(table_name)),
148                 style.SQL_FIELD(column_name),
149             ))
150         return sql
151 
152     def tablespace_sql(self, tablespace, inline=False):
153         if inline:
154             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
155         else:
156             return "TABLESPACE %s" % self.quote_name(tablespace)
157 
158     def sequence_reset_sql(self, style, model_list):
159         from django.db import models
160         output = []
161         qn = self.quote_name
162         for model in model_list:
163             # Use `coalesce` to set the sequence for each model to the max pk value if there are records,
164             # or 1 if there are none. Set the `is_called` property (the third argument to `setval`) to true
165             # if there are records (as the max pk value is already in use), otherwise set it to false.
166             # Use pg_get_serial_sequence to get the underlying sequence name from the table name
167             # and column name (available since PostgreSQL 8)
168 
169             for f in model._meta.local_fields:
170                 if isinstance(f, models.AutoField):
171                     output.append(
172                         "%s setval(pg_get_serial_sequence('%s','%s'), "
173                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
174                             style.SQL_KEYWORD('SELECT'),
175                             style.SQL_TABLE(qn(model._meta.db_table)),
176                             style.SQL_FIELD(f.column),
177                             style.SQL_FIELD(qn(f.column)),
178                             style.SQL_FIELD(qn(f.column)),
179                             style.SQL_KEYWORD('IS NOT'),
180                             style.SQL_KEYWORD('FROM'),
181                             style.SQL_TABLE(qn(model._meta.db_table)),
182                         )
183                     )
184                     break  # Only one AutoField is allowed per model, so don't bother continuing.
185             for f in model._meta.many_to_many:
186                 if not f.remote_field.through:
187                     output.append(
188                         "%s setval(pg_get_serial_sequence('%s','%s'), "
189                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
190                             style.SQL_KEYWORD('SELECT'),
191                             style.SQL_TABLE(qn(f.m2m_db_table())),
192                             style.SQL_FIELD('id'),
193                             style.SQL_FIELD(qn('id')),
194                             style.SQL_FIELD(qn('id')),
195                             style.SQL_KEYWORD('IS NOT'),
196                             style.SQL_KEYWORD('FROM'),
197                             style.SQL_TABLE(qn(f.m2m_db_table()))
198                         )
199                     )
200         return output
201 
202     def prep_for_iexact_query(self, x):
203         return x
204 
205     def max_name_length(self):
206         """
207         Return the maximum length of an identifier.
208 
209         The maximum length of an identifier is 63 by default, but can be
210         changed by recompiling PostgreSQL after editing the NAMEDATALEN
211         macro in src/include/pg_config_manual.h.
212 
213         This implementation returns 63, but can be overridden by a custom
214         database backend that inherits most of its behavior from this one.
215         """
216         return 63
217 
218     def distinct_sql(self, fields, params):
219         if fields:
220             params = [param for param_list in params for param in param_list]
221             return (['DISTINCT ON (%s)' % ', '.join(fields)], params)
222         else:
223             return ['DISTINCT'], []
224 
225     def last_executed_query(self, cursor, sql, params):
226         # https://www.psycopg.org/docs/cursor.html#cursor.query
227         # The query attribute is a Psycopg extension to the DB API 2.0.
228         if cursor.query is not None:
229             return cursor.query.decode()
230         return None
231 
232     def return_insert_columns(self, fields):
233         if not fields:
234             return '', ()
235         columns = [
236             '%s.%s' % (
237                 self.quote_name(field.model._meta.db_table),
238                 self.quote_name(field.column),
239             ) for field in fields
240         ]
241         return 'RETURNING %s' % ', '.join(columns), ()
242 
243     def bulk_insert_sql(self, fields, placeholder_rows):
244         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
245         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
246         return "VALUES " + values_sql
247 
248     def adapt_datefield_value(self, value):
249         return value
250 
251     def adapt_datetimefield_value(self, value):
252         return value
253 
254     def adapt_timefield_value(self, value):
255         return value
256 
257     def adapt_ipaddressfield_value(self, value):
258         if value:
259             return Inet(value)
260         return None
261 
262     def subtract_temporals(self, internal_type, lhs, rhs):
263         if internal_type == 'DateField':
264             lhs_sql, lhs_params = lhs
265             rhs_sql, rhs_params = rhs
266             params = (*lhs_params, *rhs_params)
267             return "(interval '1 day' * (%s - %s))" % (lhs_sql, rhs_sql), params
268         return super().subtract_temporals(internal_type, lhs, rhs)
269 
270     def explain_query_prefix(self, format=None, **options):
271         prefix = super().explain_query_prefix(format)
272         extra = {}
273         if format:
274             extra['FORMAT'] = format
275         if options:
276             extra.update({
277                 name.upper(): 'true' if value else 'false'
278                 for name, value in options.items()
279             })
280         if extra:
281             prefix += ' (%s)' % ', '.join('%s %s' % i for i in extra.items())
282         return prefix
283 
284     def ignore_conflicts_suffix_sql(self, ignore_conflicts=None):
285         return 'ON CONFLICT DO NOTHING' if ignore_conflicts else super().ignore_conflicts_suffix_sql(ignore_conflicts)

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/mysql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
10 class DatabaseOperations(BaseDatabaseOperations):
11     compiler_module = "django.db.backends.mysql.compiler"
12 
13     # MySQL stores positive fields as UNSIGNED ints.
14     integer_field_ranges = {
15         **BaseDatabaseOperations.integer_field_ranges,
16         'PositiveSmallIntegerField': (0, 65535),
17         'PositiveIntegerField': (0, 4294967295),
18         'PositiveBigIntegerField': (0, 18446744073709551615),
19     }
20     cast_data_types = {
21         'AutoField': 'signed integer',
22         'BigAutoField': 'signed integer',
23         'SmallAutoField': 'signed integer',
24         'CharField': 'char(%(max_length)s)',
25         'DecimalField': 'decimal(%(max_digits)s, %(decimal_places)s)',
26         'TextField': 'char',
27         'IntegerField': 'signed integer',
28         'BigIntegerField': 'signed integer',
29         'SmallIntegerField': 'signed integer',
30         'PositiveBigIntegerField': 'unsigned integer',
31         'PositiveIntegerField': 'unsigned integer',
32         'PositiveSmallIntegerField': 'unsigned integer',
33     }
34     cast_char_field_without_max_length = 'char'
35     explain_prefix = 'EXPLAIN'
36 
37     def date_extract_sql(self, lookup_type, field_name):
38         # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html
39         if lookup_type == 'week_day':
40             # DAYOFWEEK() returns an integer, 1-7, Sunday=1.
41             return "DAYOFWEEK(%s)" % field_name
42         elif lookup_type == 'iso_week_day':
43             # WEEKDAY() returns an integer, 0-6, Monday=0.
44             return "WEEKDAY(%s) + 1" % field_name
45         elif lookup_type == 'week':
46             # Override the value of default_week_format for consistency with
47             # other database backends.
48             # Mode 3: Monday, 1-53, with 4 or more days this year.
49             return "WEEK(%s, 3)" % field_name
50         elif lookup_type == 'iso_year':
51             # Get the year part from the YEARWEEK function, which returns a
52             # number as year * 100 + week.
53             return "TRUNCATE(YEARWEEK(%s, 3), -2) / 100" % field_name
54         else:
55             # EXTRACT returns 1-53 based on ISO-8601 for the week number.
56             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
57 
58     def date_trunc_sql(self, lookup_type, field_name):
59         fields = {
60             'year': '%%Y-01-01',
61             'month': '%%Y-%%m-01',
62         }  # Use double percents to escape.
63         if lookup_type in fields:
64             format_str = fields[lookup_type]
65             return "CAST(DATE_FORMAT(%s, '%s') AS DATE)" % (field_name, format_str)
66         elif lookup_type == 'quarter':
67             return "MAKEDATE(YEAR(%s), 1) + INTERVAL QUARTER(%s) QUARTER - INTERVAL 1 QUARTER" % (
68                 field_name, field_name
69             )
70         elif lookup_type == 'week':
71             return "DATE_SUB(%s, INTERVAL WEEKDAY(%s) DAY)" % (
72                 field_name, field_name
73             )
74         else:
75             return "DATE(%s)" % (field_name)
76 
77     def _prepare_tzname_delta(self, tzname):
78         if '+' in tzname:
79             return tzname[tzname.find('+'):]
80         elif '-' in tzname:
81             return tzname[tzname.find('-'):]
82         return tzname
83 
84     def _convert_field_to_tz(self, field_name, tzname):
85         if settings.USE_TZ and self.connection.timezone_name != tzname:
86             field_name = "CONVERT_TZ(%s, '%s', '%s')" % (
87                 field_name,
88                 self.connection.timezone_name,
89                 self._prepare_tzname_delta(tzname),
90             )
91         return field_name
92 
93     def datetime_cast_date_sql(self, field_name, tzname):
94         field_name = self._convert_field_to_tz(field_name, tzname)
95         return "DATE(%s)" % field_name
96 
97     def datetime_cast_time_sql(self, field_name, tzname):
98         field_name = self._convert_field_to_tz(field_name, tzname)
99         return "TIME(%s)" % field_name
100 
101     def datetime_extract_sql(self, lookup_type, field_name, tzname):
102         field_name = self._convert_field_to_tz(field_name, tzname)
103         return self.date_extract_sql(lookup_type, field_name)
104 
105     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
106         field_name = self._convert_field_to_tz(field_name, tzname)
107         fields = ['year', 'month', 'day', 'hour', 'minute', 'second']
108         format = ('%%Y-', '%%m', '-%%d', ' %%H:', '%%i', ':%%s')  # Use double percents to escape.
109         format_def = ('0000-', '01', '-01', ' 00:', '00', ':00')
110         if lookup_type == 'quarter':
111             return (
112                 "CAST(DATE_FORMAT(MAKEDATE(YEAR({field_name}), 1) + "
113                 "INTERVAL QUARTER({field_name}) QUARTER - " +
114                 "INTERVAL 1 QUARTER, '%%Y-%%m-01 00:00:00') AS DATETIME)"
115             ).format(field_name=field_name)
116         if lookup_type == 'week':
117             return (
118                 "CAST(DATE_FORMAT(DATE_SUB({field_name}, "
119                 "INTERVAL WEEKDAY({field_name}) DAY), "
120                 "'%%Y-%%m-%%d 00:00:00') AS DATETIME)"
121             ).format(field_name=field_name)
122         try:
123             i = fields.index(lookup_type) + 1
124         except ValueError:
125             sql = field_name
126         else:
127             format_str = ''.join(format[:i] + format_def[i:])
128             sql = "CAST(DATE_FORMAT(%s, '%s') AS DATETIME)" % (field_name, format_str)
129         return sql
130 
131     def time_trunc_sql(self, lookup_type, field_name):
132         fields = {
133             'hour': '%%H:00:00',
134             'minute': '%%H:%%i:00',
135             'second': '%%H:%%i:%%s',
136         }  # Use double percents to escape.
137         if lookup_type in fields:
138             format_str = fields[lookup_type]
139             return "CAST(DATE_FORMAT(%s, '%s') AS TIME)" % (field_name, format_str)
140         else:
141             return "TIME(%s)" % (field_name)
142 
143     def date_interval_sql(self, timedelta):
144         return 'INTERVAL %s MICROSECOND' % duration_microseconds(timedelta)
145 
146     def fetch_returned_insert_rows(self, cursor):
147         """
148         Given a cursor object that has just performed an INSERT...RETURNING
149         statement into a table, return the tuple of returned data.
150         """
151         return cursor.fetchall()
152 
153     def format_for_duration_arithmetic(self, sql):
154         return 'INTERVAL %s MICROSECOND' % sql
155 
156     def force_no_ordering(self):
157         """
158         "ORDER BY NULL" prevents MySQL from implicitly ordering by grouped
159         columns. If no ordering would otherwise be applied, we don't want any
160         implicit sorting going on.
161         """
162         return [(None, ("NULL", [], False))]
163 
164     def last_executed_query(self, cursor, sql, params):
165         # With MySQLdb, cursor objects have an (undocumented) "_executed"
166         # attribute where the exact query sent to the database is saved.
167         # See MySQLdb/cursors.py in the source distribution.
168         # MySQLdb returns string, PyMySQL bytes.
169         return force_str(getattr(cursor, '_executed', None), errors='replace')
170 
171     def no_limit_value(self):
172         # 2**64 - 1, as recommended by the MySQL documentation
173         return 18446744073709551615
174 
175     def quote_name(self, name):
176         if name.startswith("`") and name.endswith("`"):
177             return name  # Quoting once is enough.
178         return "`%s`" % name
179 
180     def random_function_sql(self):
181         return 'RAND()'
182 
183     def return_insert_columns(self, fields):
184         # MySQL and MariaDB < 10.5.0 don't support an INSERT...RETURNING
185         # statement.
186         if not fields:
187             return '', ()
188         columns = [
189             '%s.%s' % (
190                 self.quote_name(field.model._meta.db_table),
191                 self.quote_name(field.column),
192             ) for field in fields
193         ]
194         return 'RETURNING %s' % ', '.join(columns), ()
195 
196     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
197         if not tables:
198             return []
199 
200         sql = ['SET FOREIGN_KEY_CHECKS = 0;']
201         if reset_sequences:
202             # It's faster to TRUNCATE tables that require a sequence reset
203             # since ALTER TABLE AUTO_INCREMENT is slower than TRUNCATE.
204             sql.extend(
205                 '%s %s;' % (
206                     style.SQL_KEYWORD('TRUNCATE'),
207                     style.SQL_FIELD(self.quote_name(table_name)),
208                 ) for table_name in tables
209             )
210         else:
211             # Otherwise issue a simple DELETE since it's faster than TRUNCATE
212             # and preserves sequences.
213             sql.extend(
214                 '%s %s %s;' % (
215                     style.SQL_KEYWORD('DELETE'),
216                     style.SQL_KEYWORD('FROM'),
217                     style.SQL_FIELD(self.quote_name(table_name)),
218                 ) for table_name in tables
219             )
220         sql.append('SET FOREIGN_KEY_CHECKS = 1;')
221         return sql
222 
223     def sequence_reset_by_name_sql(self, style, sequences):
224         return [
225             '%s %s %s %s = 1;' % (
226                 style.SQL_KEYWORD('ALTER'),
227                 style.SQL_KEYWORD('TABLE'),
228                 style.SQL_FIELD(self.quote_name(sequence_info['table'])),
229                 style.SQL_FIELD('AUTO_INCREMENT'),
230             ) for sequence_info in sequences
231         ]
232 
233     def validate_autopk_value(self, value):
234         # MySQLism: zero in AUTO_INCREMENT field does not work. Refs #17653.
235         if value == 0:
236             raise ValueError('The database backend does not accept 0 as a '
237                              'value for AutoField.')
238         return value
239 
240     def adapt_datetimefield_value(self, value):
241         if value is None:
242             return None
243 
244         # Expression values are adapted by the database.
245         if hasattr(value, 'resolve_expression'):
246             return value
247 
248         # MySQL doesn't support tz-aware datetimes
249         if timezone.is_aware(value):
250             if settings.USE_TZ:
251                 value = timezone.make_naive(value, self.connection.timezone)
252             else:
253                 raise ValueError("MySQL backend does not support timezone-aware datetimes when USE_TZ is False.")
254         return str(value)
255 
256     def adapt_timefield_value(self, value):
257         if value is None:
258             return None
259 
260         # Expression values are adapted by the database.
261         if hasattr(value, 'resolve_expression'):
262             return value
263 
264         # MySQL doesn't support tz-aware times
265         if timezone.is_aware(value):
266             raise ValueError("MySQL backend does not support timezone-aware times.")
267 
268         return str(value)
269 
270     def max_name_length(self):
271         return 64
272 
273     def bulk_insert_sql(self, fields, placeholder_rows):
274         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
275         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
276         return "VALUES " + values_sql
277 
278     def combine_expression(self, connector, sub_expressions):
279         if connector == '^':
280             return 'POW(%s)' % ','.join(sub_expressions)
281         # Convert the result to a signed integer since MySQL's binary operators
282         # return an unsigned integer.
283         elif connector in ('&', '|', '<<', '#'):
284             connector = '^' if connector == '#' else connector
285             return 'CONVERT(%s, SIGNED)' % connector.join(sub_expressions)
286         elif connector == '>>':
287             lhs, rhs = sub_expressions
288             return 'FLOOR(%(lhs)s / POW(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
289         return super().combine_expression(connector, sub_expressions)
290 
291     def get_db_converters(self, expression):
292         converters = super().get_db_converters(expression)
293         internal_type = expression.output_field.get_internal_type()
294         if internal_type in ['BooleanField', 'NullBooleanField']:
295             converters.append(self.convert_booleanfield_value)
296         elif internal_type == 'DateTimeField':
297             if settings.USE_TZ:
298                 converters.append(self.convert_datetimefield_value)
299         elif internal_type == 'UUIDField':
300             converters.append(self.convert_uuidfield_value)
301         return converters
302 
303     def convert_booleanfield_value(self, value, expression, connection):
304         if value in (0, 1):
305             value = bool(value)
306         return value
307 
308     def convert_datetimefield_value(self, value, expression, connection):
309         if value is not None:
310             value = timezone.make_aware(value, self.connection.timezone)
311         return value
312 
313     def convert_uuidfield_value(self, value, expression, connection):
314         if value is not None:
315             value = uuid.UUID(value)
316         return value
317 
318     def binary_placeholder_sql(self, value):
319         return '_binary %s' if value is not None and not hasattr(value, 'as_sql') else '%s'
320 
321     def subtract_temporals(self, internal_type, lhs, rhs):
322         lhs_sql, lhs_params = lhs
323         rhs_sql, rhs_params = rhs
324         if internal_type == 'TimeField':
325             if self.connection.mysql_is_mariadb:
326                 # MariaDB includes the microsecond component in TIME_TO_SEC as
327                 # a decimal. MySQL returns an integer without microseconds.
328                 return 'CAST((TIME_TO_SEC(%(lhs)s) - TIME_TO_SEC(%(rhs)s)) * 1000000 AS SIGNED)' % {
329                     'lhs': lhs_sql, 'rhs': rhs_sql
330                 }, (*lhs_params, *rhs_params)
331             return (
332                 "((TIME_TO_SEC(%(lhs)s) * 1000000 + MICROSECOND(%(lhs)s)) -"
333                 " (TIME_TO_SEC(%(rhs)s) * 1000000 + MICROSECOND(%(rhs)s)))"
334             ) % {'lhs': lhs_sql, 'rhs': rhs_sql}, tuple(lhs_params) * 2 + tuple(rhs_params) * 2
335         params = (*rhs_params, *lhs_params)
336         return "TIMESTAMPDIFF(MICROSECOND, %s, %s)" % (rhs_sql, lhs_sql), params
337 
338     def explain_query_prefix(self, format=None, **options):
339         # Alias MySQL's TRADITIONAL to TEXT for consistency with other backends.
340         if format and format.upper() == 'TEXT':
341             format = 'TRADITIONAL'
342         elif not format and 'TREE' in self.connection.features.supported_explain_formats:
343             # Use TREE by default (if supported) as it's more informative.
344             format = 'TREE'
345         analyze = options.pop('analyze', False)
346         prefix = super().explain_query_prefix(format, **options)
347         if analyze and self.connection.features.supports_explain_analyze:
348             # MariaDB uses ANALYZE instead of EXPLAIN ANALYZE.
349             prefix = 'ANALYZE' if self.connection.mysql_is_mariadb else prefix + ' ANALYZE'
350         if format and not (analyze and not self.connection.mysql_is_mariadb):
351             # Only MariaDB supports the analyze option with formats.
352             prefix += ' FORMAT=%s' % format
353         if self.connection.features.needs_explain_extended and not analyze and format is None:
354             # ANALYZE, EXTENDED, and FORMAT are mutually exclusive options.
355             prefix += ' EXTENDED'
356         return prefix
357 
358     def regex_lookup(self, lookup_type):
359         # REGEXP BINARY doesn't work correctly in MySQL 8+ and REGEXP_LIKE
360         # doesn't exist in MySQL 5.6 or in MariaDB.
361         if self.connection.mysql_version < (8, 0, 0) or self.connection.mysql_is_mariadb:
362             if lookup_type == 'regex':
363                 return '%s REGEXP BINARY %s'
364             return '%s REGEXP %s'
365 
366         match_option = 'c' if lookup_type == 'regex' else 'i'
367         return "REGEXP_LIKE(%%s, %%s, '%s')" % match_option
368 
369     def insert_statement(self, ignore_conflicts=False):
370         return 'INSERT IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/dummy/base.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
29 class DatabaseOperations(BaseDatabaseOperations):
30     quote_name = complain

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>]
2025-10-17 11:42:39.263 | INFO     | Search completed. Bug locations: [<file>django/db/backends/sqlite3/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
18 class DatabaseOperations(BaseDatabaseOperations):
19     cast_char_field_without_max_length = 'text'
20     cast_data_types = {
21         'DateField': 'TEXT',
22         'DateTimeField': 'TEXT',
23     }
24     explain_prefix = 'EXPLAIN QUERY PLAN'
25 
26     def bulk_batch_size(self, fields, objs):
27         """
28         SQLite has a compile-time default (SQLITE_LIMIT_VARIABLE_NUMBER) of
29         999 variables per query.
30 
31         If there's only a single field to insert, the limit is 500
32         (SQLITE_MAX_COMPOUND_SELECT).
33         """
34         if len(fields) == 1:
35             return 500
36         elif len(fields) > 1:
37             return self.connection.features.max_query_params // len(fields)
38         else:
39             return len(objs)
40 
41     def check_expression_support(self, expression):
42         bad_fields = (models.DateField, models.DateTimeField, models.TimeField)
43         bad_aggregates = (models.Sum, models.Avg, models.Variance, models.StdDev)
44         if isinstance(expression, bad_aggregates):
45             for expr in expression.get_source_expressions():
46                 try:
47                     output_field = expr.output_field
48                 except (AttributeError, FieldError):
49                     # Not every subexpression has an output_field which is fine
50                     # to ignore.
51                     pass
52                 else:
53                     if isinstance(output_field, bad_fields):
54                         raise NotSupportedError(
55                             'You cannot use Sum, Avg, StdDev, and Variance '
56                             'aggregations on date/time fields in sqlite3 '
57                             'since date/time is saved as text.'
58                         )
59         if (
60             isinstance(expression, models.Aggregate) and
61             expression.distinct and
62             len(expression.source_expressions) > 1
63         ):
64             raise NotSupportedError(
65                 "SQLite doesn't support DISTINCT on aggregate functions "
66                 "accepting multiple arguments."
67             )
68 
69     def date_extract_sql(self, lookup_type, field_name):
70         """
71         Support EXTRACT with a user-defined function django_date_extract()
72         that's registered in connect(). Use single quotes because this is a
73         string and could otherwise cause a collision with a field name.
74         """
75         return "django_date_extract('%s', %s)" % (lookup_type.lower(), field_name)
76 
77     def date_interval_sql(self, timedelta):
78         return str(duration_microseconds(timedelta))
79 
80     def format_for_duration_arithmetic(self, sql):
81         """Do nothing since formatting is handled in the custom function."""
82         return sql
83 
84     def date_trunc_sql(self, lookup_type, field_name):
85         return "django_date_trunc('%s', %s)" % (lookup_type.lower(), field_name)
86 
87     def time_trunc_sql(self, lookup_type, field_name):
88         return "django_time_trunc('%s', %s)" % (lookup_type.lower(), field_name)
89 
90     def _convert_tznames_to_sql(self, tzname):
91         if settings.USE_TZ:
92             return "'%s'" % tzname, "'%s'" % self.connection.timezone_name
93         return 'NULL', 'NULL'
94 
95     def datetime_cast_date_sql(self, field_name, tzname):
96         return 'django_datetime_cast_date(%s, %s, %s)' % (
97             field_name, *self._convert_tznames_to_sql(tzname),
98         )
99 
100     def datetime_cast_time_sql(self, field_name, tzname):
101         return 'django_datetime_cast_time(%s, %s, %s)' % (
102             field_name, *self._convert_tznames_to_sql(tzname),
103         )
104 
105     def datetime_extract_sql(self, lookup_type, field_name, tzname):
106         return "django_datetime_extract('%s', %s, %s, %s)" % (
107             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
108         )
109 
110     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
111         return "django_datetime_trunc('%s', %s, %s, %s)" % (
112             lookup_type.lower(), field_name, *self._convert_tznames_to_sql(tzname),
113         )
114 
115     def time_extract_sql(self, lookup_type, field_name):
116         return "django_time_extract('%s', %s)" % (lookup_type.lower(), field_name)
117 
118     def pk_default_value(self):
119         return "NULL"
120 
121     def _quote_params_for_last_executed_query(self, params):
122         """
123         Only for last_executed_query! Don't use this to execute SQL queries!
124         """
125         # This function is limited both by SQLITE_LIMIT_VARIABLE_NUMBER (the
126         # number of parameters, default = 999) and SQLITE_MAX_COLUMN (the
127         # number of return values, default = 2000). Since Python's sqlite3
128         # module doesn't expose the get_limit() C API, assume the default
129         # limits are in effect and split the work in batches if needed.
130         BATCH_SIZE = 999
131         if len(params) > BATCH_SIZE:
132             results = ()
133             for index in range(0, len(params), BATCH_SIZE):
134                 chunk = params[index:index + BATCH_SIZE]
135                 results += self._quote_params_for_last_executed_query(chunk)
136             return results
137 
138         sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(params))
139         # Bypass Django's wrappers and use the underlying sqlite3 connection
140         # to avoid logging this query - it would trigger infinite recursion.
141         cursor = self.connection.connection.cursor()
142         # Native sqlite3 cursors cannot be used as context managers.
143         try:
144             return cursor.execute(sql, params).fetchone()
145         finally:
146             cursor.close()
147 
148     def last_executed_query(self, cursor, sql, params):
149         # Python substitutes parameters in Modules/_sqlite/cursor.c with:
150         # pysqlite_statement_bind_parameters(self->statement, parameters, allow_8bit_chars);
151         # Unfortunately there is no way to reach self->statement from Python,
152         # so we quote and substitute parameters manually.
153         if params:
154             if isinstance(params, (list, tuple)):
155                 params = self._quote_params_for_last_executed_query(params)
156             else:
157                 values = tuple(params.values())
158                 values = self._quote_params_for_last_executed_query(values)
159                 params = dict(zip(params, values))
160             return sql % params
161         # For consistency with SQLiteCursorWrapper.execute(), just return sql
162         # when there are no parameters. See #13648 and #17158.
163         else:
164             return sql
165 
166     def quote_name(self, name):
167         if name.startswith('"') and name.endswith('"'):
168             return name  # Quoting once is enough.
169         return '"%s"' % name
170 
171     def no_limit_value(self):
172         return -1
173 
174     def __references_graph(self, table_name):
175         query = """
176         WITH tables AS (
177             SELECT %s name
178             UNION
179             SELECT sqlite_master.name
180             FROM sqlite_master
181             JOIN tables ON (sql REGEXP %s || tables.name || %s)
182         ) SELECT name FROM tables;
183         """
184         params = (
185             table_name,
186             r'(?i)\s+references\s+("|\')?',
187             r'("|\')?\s*\(',
188         )
189         with self.connection.cursor() as cursor:
190             results = cursor.execute(query, params)
191             return [row[0] for row in results.fetchall()]
192 
193     @cached_property
194     def _references_graph(self):
195         # 512 is large enough to fit the ~330 tables (as of this writing) in
196         # Django's test suite.
197         return lru_cache(maxsize=512)(self.__references_graph)
198 
199     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
200         if tables and allow_cascade:
201             # Simulate TRUNCATE CASCADE by recursively collecting the tables
202             # referencing the tables to be flushed.
203             tables = set(chain.from_iterable(self._references_graph(table) for table in tables))
204         # Note: No requirement for reset of auto-incremented indices (cf. other
205         # sql_flush() implementations). Just return SQL at this point
206         return ['%s %s %s;' % (
207             style.SQL_KEYWORD('DELETE'),
208             style.SQL_KEYWORD('FROM'),
209             style.SQL_FIELD(self.quote_name(table))
210         ) for table in tables]
211 
212     def adapt_datetimefield_value(self, value):
213         if value is None:
214             return None
215 
216         # Expression values are adapted by the database.
217         if hasattr(value, 'resolve_expression'):
218             return value
219 
220         # SQLite doesn't support tz-aware datetimes
221         if timezone.is_aware(value):
222             if settings.USE_TZ:
223                 value = timezone.make_naive(value, self.connection.timezone)
224             else:
225                 raise ValueError("SQLite backend does not support timezone-aware datetimes when USE_TZ is False.")
226 
227         return str(value)
228 
229     def adapt_timefield_value(self, value):
230         if value is None:
231             return None
232 
233         # Expression values are adapted by the database.
234         if hasattr(value, 'resolve_expression'):
235             return value
236 
237         # SQLite doesn't support tz-aware datetimes
238         if timezone.is_aware(value):
239             raise ValueError("SQLite backend does not support timezone-aware times.")
240 
241         return str(value)
242 
243     def get_db_converters(self, expression):
244         converters = super().get_db_converters(expression)
245         internal_type = expression.output_field.get_internal_type()
246         if internal_type == 'DateTimeField':
247             converters.append(self.convert_datetimefield_value)
248         elif internal_type == 'DateField':
249             converters.append(self.convert_datefield_value)
250         elif internal_type == 'TimeField':
251             converters.append(self.convert_timefield_value)
252         elif internal_type == 'DecimalField':
253             converters.append(self.get_decimalfield_converter(expression))
254         elif internal_type == 'UUIDField':
255             converters.append(self.convert_uuidfield_value)
256         elif internal_type in ('NullBooleanField', 'BooleanField'):
257             converters.append(self.convert_booleanfield_value)
258         return converters
259 
260     def convert_datetimefield_value(self, value, expression, connection):
261         if value is not None:
262             if not isinstance(value, datetime.datetime):
263                 value = parse_datetime(value)
264             if settings.USE_TZ and not timezone.is_aware(value):
265                 value = timezone.make_aware(value, self.connection.timezone)
266         return value
267 
268     def convert_datefield_value(self, value, expression, connection):
269         if value is not None:
270             if not isinstance(value, datetime.date):
271                 value = parse_date(value)
272         return value
273 
274     def convert_timefield_value(self, value, expression, connection):
275         if value is not None:
276             if not isinstance(value, datetime.time):
277                 value = parse_time(value)
278         return value
279 
280     def get_decimalfield_converter(self, expression):
281         # SQLite stores only 15 significant digits. Digits coming from
282         # float inaccuracy must be removed.
283         create_decimal = decimal.Context(prec=15).create_decimal_from_float
284         if isinstance(expression, Col):
285             quantize_value = decimal.Decimal(1).scaleb(-expression.output_field.decimal_places)
286 
287             def converter(value, expression, connection):
288                 if value is not None:
289                     return create_decimal(value).quantize(quantize_value, context=expression.output_field.context)
290         else:
291             def converter(value, expression, connection):
292                 if value is not None:
293                     return create_decimal(value)
294         return converter
295 
296     def convert_uuidfield_value(self, value, expression, connection):
297         if value is not None:
298             value = uuid.UUID(value)
299         return value
300 
301     def convert_booleanfield_value(self, value, expression, connection):
302         return bool(value) if value in (1, 0) else value
303 
304     def bulk_insert_sql(self, fields, placeholder_rows):
305         return " UNION ALL ".join(
306             "SELECT %s" % ", ".join(row)
307             for row in placeholder_rows
308         )
309 
310     def combine_expression(self, connector, sub_expressions):
311         # SQLite doesn't have a ^ operator, so use the user-defined POWER
312         # function that's registered in connect().
313         if connector == '^':
314             return 'POWER(%s)' % ','.join(sub_expressions)
315         elif connector == '#':
316             return 'BITXOR(%s)' % ','.join(sub_expressions)
317         return super().combine_expression(connector, sub_expressions)
318 
319     def combine_duration_expression(self, connector, sub_expressions):
320         if connector not in ['+', '-']:
321             raise DatabaseError('Invalid connector for timedelta: %s.' % connector)
322         fn_params = ["'%s'" % connector] + sub_expressions
323         if len(fn_params) > 3:
324             raise ValueError('Too many params for timedelta operations.')
325         return "django_format_dtdelta(%s)" % ', '.join(fn_params)
326 
327     def integer_field_range(self, internal_type):
328         # SQLite doesn't enforce any integer constraints
329         return (None, None)
330 
331     def subtract_temporals(self, internal_type, lhs, rhs):
332         lhs_sql, lhs_params = lhs
333         rhs_sql, rhs_params = rhs
334         params = (*lhs_params, *rhs_params)
335         if internal_type == 'TimeField':
336             return 'django_time_diff(%s, %s)' % (lhs_sql, rhs_sql), params
337         return 'django_timestamp_diff(%s, %s)' % (lhs_sql, rhs_sql), params
338 
339     def insert_statement(self, ignore_conflicts=False):
340         return 'INSERT OR IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
21 class DatabaseOperations(BaseDatabaseOperations):
22     # Oracle uses NUMBER(5), NUMBER(11), and NUMBER(19) for integer fields.
23     # SmallIntegerField uses NUMBER(11) instead of NUMBER(5), which is used by
24     # SmallAutoField, to preserve backward compatibility.
25     integer_field_ranges = {
26         'SmallIntegerField': (-99999999999, 99999999999),
27         'IntegerField': (-99999999999, 99999999999),
28         'BigIntegerField': (-9999999999999999999, 9999999999999999999),
29         'PositiveBigIntegerField': (0, 9999999999999999999),
30         'PositiveSmallIntegerField': (0, 99999999999),
31         'PositiveIntegerField': (0, 99999999999),
32         'SmallAutoField': (-99999, 99999),
33         'AutoField': (-99999999999, 99999999999),
34         'BigAutoField': (-9999999999999999999, 9999999999999999999),
35     }
36     set_operators = {**BaseDatabaseOperations.set_operators, 'difference': 'MINUS'}
37 
38     # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.
39     _sequence_reset_sql = """
40 DECLARE
41     table_value integer;
42     seq_value integer;
43     seq_name user_tab_identity_cols.sequence_name%%TYPE;
44 BEGIN
45     BEGIN
46         SELECT sequence_name INTO seq_name FROM user_tab_identity_cols
47         WHERE  table_name = '%(table_name)s' AND
48                column_name = '%(column_name)s';
49         EXCEPTION WHEN NO_DATA_FOUND THEN
50             seq_name := '%(no_autofield_sequence_name)s';
51     END;
52 
53     SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;
54     SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences
55            WHERE sequence_name = seq_name;
56     WHILE table_value > seq_value LOOP
57         EXECUTE IMMEDIATE 'SELECT "'||seq_name||'".nextval FROM DUAL'
58         INTO seq_value;
59     END LOOP;
60 END;
61 /"""
62 
63     # Oracle doesn't support string without precision; use the max string size.
64     cast_char_field_without_max_length = 'NVARCHAR2(2000)'
65     cast_data_types = {
66         'AutoField': 'NUMBER(11)',
67         'BigAutoField': 'NUMBER(19)',
68         'SmallAutoField': 'NUMBER(5)',
69         'TextField': cast_char_field_without_max_length,
70     }
71 
72     def cache_key_culling_sql(self):
73         return 'SELECT cache_key FROM %s ORDER BY cache_key OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'
74 
75     def date_extract_sql(self, lookup_type, field_name):
76         if lookup_type == 'week_day':
77             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.
78             return "TO_CHAR(%s, 'D')" % field_name
79         elif lookup_type == 'iso_week_day':
80             return "TO_CHAR(%s - 1, 'D')" % field_name
81         elif lookup_type == 'week':
82             # IW = ISO week number
83             return "TO_CHAR(%s, 'IW')" % field_name
84         elif lookup_type == 'quarter':
85             return "TO_CHAR(%s, 'Q')" % field_name
86         elif lookup_type == 'iso_year':
87             return "TO_CHAR(%s, 'IYYY')" % field_name
88         else:
89             # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/EXTRACT-datetime.html
90             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
91 
92     def date_trunc_sql(self, lookup_type, field_name):
93         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
94         if lookup_type in ('year', 'month'):
95             return "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
96         elif lookup_type == 'quarter':
97             return "TRUNC(%s, 'Q')" % field_name
98         elif lookup_type == 'week':
99             return "TRUNC(%s, 'IW')" % field_name
100         else:
101             return "TRUNC(%s)" % field_name
102 
103     # Oracle crashes with "ORA-03113: end-of-file on communication channel"
104     # if the time zone name is passed in parameter. Use interpolation instead.
105     # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ
106     # This regexp matches all time zone names from the zoneinfo database.
107     _tzname_re = _lazy_re_compile(r'^[\w/:+-]+$')
108 
109     def _prepare_tzname_delta(self, tzname):
110         if '+' in tzname:
111             return tzname[tzname.find('+'):]
112         elif '-' in tzname:
113             return tzname[tzname.find('-'):]
114         return tzname
115 
116     def _convert_field_to_tz(self, field_name, tzname):
117         if not settings.USE_TZ:
118             return field_name
119         if not self._tzname_re.match(tzname):
120             raise ValueError("Invalid time zone name: %s" % tzname)
121         # Convert from connection timezone to the local time, returning
122         # TIMESTAMP WITH TIME ZONE and cast it back to TIMESTAMP to strip the
123         # TIME ZONE details.
124         if self.connection.timezone_name != tzname:
125             return "CAST((FROM_TZ(%s, '%s') AT TIME ZONE '%s') AS TIMESTAMP)" % (
126                 field_name,
127                 self.connection.timezone_name,
128                 self._prepare_tzname_delta(tzname),
129             )
130         return field_name
131 
132     def datetime_cast_date_sql(self, field_name, tzname):
133         field_name = self._convert_field_to_tz(field_name, tzname)
134         return 'TRUNC(%s)' % field_name
135 
136     def datetime_cast_time_sql(self, field_name, tzname):
137         # Since `TimeField` values are stored as TIMESTAMP where only the date
138         # part is ignored, convert the field to the specified timezone.
139         return self._convert_field_to_tz(field_name, tzname)
140 
141     def datetime_extract_sql(self, lookup_type, field_name, tzname):
142         field_name = self._convert_field_to_tz(field_name, tzname)
143         return self.date_extract_sql(lookup_type, field_name)
144 
145     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
146         field_name = self._convert_field_to_tz(field_name, tzname)
147         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
148         if lookup_type in ('year', 'month'):
149             sql = "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
150         elif lookup_type == 'quarter':
151             sql = "TRUNC(%s, 'Q')" % field_name
152         elif lookup_type == 'week':
153             sql = "TRUNC(%s, 'IW')" % field_name
154         elif lookup_type == 'day':
155             sql = "TRUNC(%s)" % field_name
156         elif lookup_type == 'hour':
157             sql = "TRUNC(%s, 'HH24')" % field_name
158         elif lookup_type == 'minute':
159             sql = "TRUNC(%s, 'MI')" % field_name
160         else:
161             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
162         return sql
163 
164     def time_trunc_sql(self, lookup_type, field_name):
165         # The implementation is similar to `datetime_trunc_sql` as both
166         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where
167         # the date part of the later is ignored.
168         if lookup_type == 'hour':
169             sql = "TRUNC(%s, 'HH24')" % field_name
170         elif lookup_type == 'minute':
171             sql = "TRUNC(%s, 'MI')" % field_name
172         elif lookup_type == 'second':
173             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
174         return sql
175 
176     def get_db_converters(self, expression):
177         converters = super().get_db_converters(expression)
178         internal_type = expression.output_field.get_internal_type()
179         if internal_type == 'TextField':
180             converters.append(self.convert_textfield_value)
181         elif internal_type == 'BinaryField':
182             converters.append(self.convert_binaryfield_value)
183         elif internal_type in ['BooleanField', 'NullBooleanField']:
184             converters.append(self.convert_booleanfield_value)
185         elif internal_type == 'DateTimeField':
186             if settings.USE_TZ:
187                 converters.append(self.convert_datetimefield_value)
188         elif internal_type == 'DateField':
189             converters.append(self.convert_datefield_value)
190         elif internal_type == 'TimeField':
191             converters.append(self.convert_timefield_value)
192         elif internal_type == 'UUIDField':
193             converters.append(self.convert_uuidfield_value)
194         # Oracle stores empty strings as null. If the field accepts the empty
195         # string, undo this to adhere to the Django convention of using
196         # the empty string instead of null.
197         if expression.field.empty_strings_allowed:
198             converters.append(
199                 self.convert_empty_bytes
200                 if internal_type == 'BinaryField' else
201                 self.convert_empty_string
202             )
203         return converters
204 
205     def convert_textfield_value(self, value, expression, connection):
206         if isinstance(value, Database.LOB):
207             value = value.read()
208         return value
209 
210     def convert_binaryfield_value(self, value, expression, connection):
211         if isinstance(value, Database.LOB):
212             value = force_bytes(value.read())
213         return value
214 
215     def convert_booleanfield_value(self, value, expression, connection):
216         if value in (0, 1):
217             value = bool(value)
218         return value
219 
220     # cx_Oracle always returns datetime.datetime objects for
221     # DATE and TIMESTAMP columns, but Django wants to see a
222     # python datetime.date, .time, or .datetime.
223 
224     def convert_datetimefield_value(self, value, expression, connection):
225         if value is not None:
226             value = timezone.make_aware(value, self.connection.timezone)
227         return value
228 
229     def convert_datefield_value(self, value, expression, connection):
230         if isinstance(value, Database.Timestamp):
231             value = value.date()
232         return value
233 
234     def convert_timefield_value(self, value, expression, connection):
235         if isinstance(value, Database.Timestamp):
236             value = value.time()
237         return value
238 
239     def convert_uuidfield_value(self, value, expression, connection):
240         if value is not None:
241             value = uuid.UUID(value)
242         return value
243 
244     @staticmethod
245     def convert_empty_string(value, expression, connection):
246         return '' if value is None else value
247 
248     @staticmethod
249     def convert_empty_bytes(value, expression, connection):
250         return b'' if value is None else value
251 
252     def deferrable_sql(self):
253         return " DEFERRABLE INITIALLY DEFERRED"
254 
255     def fetch_returned_insert_columns(self, cursor, returning_params):
256         columns = []
257         for param in returning_params:
258             value = param.get_value()
259             if value is None or value == []:
260                 # cx_Oracle < 6.3 returns None, >= 6.3 returns empty list.
261                 raise DatabaseError(
262                     'The database did not return a new row id. Probably '
263                     '"ORA-1403: no data found" was raised internally but was '
264                     'hidden by the Oracle OCI library (see '
265                     'https://code.djangoproject.com/ticket/28859).'
266                 )
267             # cx_Oracle < 7 returns value, >= 7 returns list with single value.
268             columns.append(value[0] if isinstance(value, list) else value)
269         return tuple(columns)
270 
271     def field_cast_sql(self, db_type, internal_type):
272         if db_type and db_type.endswith('LOB'):
273             return "DBMS_LOB.SUBSTR(%s)"
274         else:
275             return "%s"
276 
277     def no_limit_value(self):
278         return None
279 
280     def limit_offset_sql(self, low_mark, high_mark):
281         fetch, offset = self._get_limit_offset_params(low_mark, high_mark)
282         return ' '.join(sql for sql in (
283             ('OFFSET %d ROWS' % offset) if offset else None,
284             ('FETCH FIRST %d ROWS ONLY' % fetch) if fetch else None,
285         ) if sql)
286 
287     def last_executed_query(self, cursor, sql, params):
288         # https://cx-oracle.readthedocs.io/en/latest/cursor.html#Cursor.statement
289         # The DB API definition does not define this attribute.
290         statement = cursor.statement
291         # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's
292         # `statement` doesn't contain the query parameters. Substitute
293         # parameters manually.
294         if isinstance(params, (tuple, list)):
295             for i, param in enumerate(params):
296                 statement = statement.replace(':arg%d' % i, force_str(param, errors='replace'))
297         elif isinstance(params, dict):
298             for key, param in params.items():
299                 statement = statement.replace(':%s' % key, force_str(param, errors='replace'))
300         return statement
301 
302     def last_insert_id(self, cursor, table_name, pk_name):
303         sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)
304         cursor.execute('"%s".currval' % sq_name)
305         return cursor.fetchone()[0]
306 
307     def lookup_cast(self, lookup_type, internal_type=None):
308         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
309             return "UPPER(%s)"
310         return "%s"
311 
312     def max_in_list_size(self):
313         return 1000
314 
315     def max_name_length(self):
316         return 30
317 
318     def pk_default_value(self):
319         return "NULL"
320 
321     def prep_for_iexact_query(self, x):
322         return x
323 
324     def process_clob(self, value):
325         if value is None:
326             return ''
327         return value.read()
328 
329     def quote_name(self, name):
330         # SQL92 requires delimited (quoted) names to be case-sensitive.  When
331         # not quoted, Oracle has case-insensitive behavior for identifiers, but
332         # always defaults to uppercase.
333         # We simplify things by making Oracle identifiers always uppercase.
334         if not name.startswith('"') and not name.endswith('"'):
335             name = '"%s"' % truncate_name(name.upper(), self.max_name_length())
336         # Oracle puts the query text into a (query % args) construct, so % signs
337         # in names need to be escaped. The '%%' will be collapsed back to '%' at
338         # that stage so we aren't really making the name longer here.
339         name = name.replace('%', '%%')
340         return name.upper()
341 
342     def random_function_sql(self):
343         return "DBMS_RANDOM.RANDOM"
344 
345     def regex_lookup(self, lookup_type):
346         if lookup_type == 'regex':
347             match_option = "'c'"
348         else:
349             match_option = "'i'"
350         return 'REGEXP_LIKE(%%s, %%s, %s)' % match_option
351 
352     def return_insert_columns(self, fields):
353         if not fields:
354             return '', ()
355         field_names = []
356         params = []
357         for field in fields:
358             field_names.append('%s.%s' % (
359                 self.quote_name(field.model._meta.db_table),
360                 self.quote_name(field.column),
361             ))
362             params.append(InsertVar(field))
363         return 'RETURNING %s INTO %s' % (
364             ', '.join(field_names),
365             ', '.join(['%s'] * len(params)),
366         ), tuple(params)
367 
368     def __foreign_key_constraints(self, table_name, recursive):
369         with self.connection.cursor() as cursor:
370             if recursive:
371                 cursor.execute("""
372                     SELECT
373                         user_tables.table_name, rcons.constraint_name
374                     FROM
375                         user_tables
376                     JOIN
377                         user_constraints cons
378                         ON (user_tables.table_name = cons.table_name AND cons.constraint_type = ANY('P', 'U'))
379                     LEFT JOIN
380                         user_constraints rcons
381                         ON (user_tables.table_name = rcons.table_name AND rcons.constraint_type = 'R')
382                     START WITH user_tables.table_name = UPPER(%s)
383                     CONNECT BY NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name
384                     GROUP BY
385                         user_tables.table_name, rcons.constraint_name
386                     HAVING user_tables.table_name != UPPER(%s)
387                     ORDER BY MAX(level) DESC
388                 """, (table_name, table_name))
389             else:
390                 cursor.execute("""
391                     SELECT
392                         cons.table_name, cons.constraint_name
393                     FROM
394                         user_constraints cons
395                     WHERE
396                         cons.constraint_type = 'R'
397                         AND cons.table_name = UPPER(%s)
398                 """, (table_name,))
399             return cursor.fetchall()
400 
401     @cached_property
402     def _foreign_key_constraints(self):
403         # 512 is large enough to fit the ~330 tables (as of this writing) in
404         # Django's test suite.
405         return lru_cache(maxsize=512)(self.__foreign_key_constraints)
406 
407     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
408         if not tables:
409             return []
410 
411         truncated_tables = {table.upper() for table in tables}
412         constraints = set()
413         # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE foreign
414         # keys which Django doesn't define. Emulate the PostgreSQL behavior
415         # which truncates all dependent tables by manually retrieving all
416         # foreign key constraints and resolving dependencies.
417         for table in tables:
418             for foreign_table, constraint in self._foreign_key_constraints(table, recursive=allow_cascade):
419                 if allow_cascade:
420                     truncated_tables.add(foreign_table)
421                 constraints.add((foreign_table, constraint))
422         sql = [
423             '%s %s %s %s %s %s %s %s;' % (
424                 style.SQL_KEYWORD('ALTER'),
425                 style.SQL_KEYWORD('TABLE'),
426                 style.SQL_FIELD(self.quote_name(table)),
427                 style.SQL_KEYWORD('DISABLE'),
428                 style.SQL_KEYWORD('CONSTRAINT'),
429                 style.SQL_FIELD(self.quote_name(constraint)),
430                 style.SQL_KEYWORD('KEEP'),
431                 style.SQL_KEYWORD('INDEX'),
432             ) for table, constraint in constraints
433         ] + [
434             '%s %s %s;' % (
435                 style.SQL_KEYWORD('TRUNCATE'),
436                 style.SQL_KEYWORD('TABLE'),
437                 style.SQL_FIELD(self.quote_name(table)),
438             ) for table in truncated_tables
439         ] + [
440             '%s %s %s %s %s %s;' % (
441                 style.SQL_KEYWORD('ALTER'),
442                 style.SQL_KEYWORD('TABLE'),
443                 style.SQL_FIELD(self.quote_name(table)),
444                 style.SQL_KEYWORD('ENABLE'),
445                 style.SQL_KEYWORD('CONSTRAINT'),
446                 style.SQL_FIELD(self.quote_name(constraint)),
447             ) for table, constraint in constraints
448         ]
449         if reset_sequences:
450             sequences = [
451                 sequence
452                 for sequence in self.connection.introspection.sequence_list()
453                 if sequence['table'].upper() in truncated_tables
454             ]
455             # Since we've just deleted all the rows, running our sequence ALTER
456             # code will reset the sequence to 0.
457             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
458         return sql
459 
460     def sequence_reset_by_name_sql(self, style, sequences):
461         sql = []
462         for sequence_info in sequences:
463             no_autofield_sequence_name = self._get_no_autofield_sequence_name(sequence_info['table'])
464             table = self.quote_name(sequence_info['table'])
465             column = self.quote_name(sequence_info['column'] or 'id')
466             query = self._sequence_reset_sql % {
467                 'no_autofield_sequence_name': no_autofield_sequence_name,
468                 'table': table,
469                 'column': column,
470                 'table_name': strip_quotes(table),
471                 'column_name': strip_quotes(column),
472             }
473             sql.append(query)
474         return sql
475 
476     def sequence_reset_sql(self, style, model_list):
477         output = []
478         query = self._sequence_reset_sql
479         for model in model_list:
480             for f in model._meta.local_fields:
481                 if isinstance(f, AutoField):
482                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(model._meta.db_table)
483                     table = self.quote_name(model._meta.db_table)
484                     column = self.quote_name(f.column)
485                     output.append(query % {
486                         'no_autofield_sequence_name': no_autofield_sequence_name,
487                         'table': table,
488                         'column': column,
489                         'table_name': strip_quotes(table),
490                         'column_name': strip_quotes(column),
491                     })
492                     # Only one AutoField is allowed per model, so don't
493                     # continue to loop
494                     break
495             for f in model._meta.many_to_many:
496                 if not f.remote_field.through:
497                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(f.m2m_db_table())
498                     table = self.quote_name(f.m2m_db_table())
499                     column = self.quote_name('id')
500                     output.append(query % {
501                         'no_autofield_sequence_name': no_autofield_sequence_name,
502                         'table': table,
503                         'column': column,
504                         'table_name': strip_quotes(table),
505                         'column_name': 'ID',
506                     })
507         return output
508 
509     def start_transaction_sql(self):
510         return ''
511 
512     def tablespace_sql(self, tablespace, inline=False):
513         if inline:
514             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
515         else:
516             return "TABLESPACE %s" % self.quote_name(tablespace)
517 
518     def adapt_datefield_value(self, value):
519         """
520         Transform a date value to an object compatible with what is expected
521         by the backend driver for date columns.
522         The default implementation transforms the date to text, but that is not
523         necessary for Oracle.
524         """
525         return value
526 
527     def adapt_datetimefield_value(self, value):
528         """
529         Transform a datetime value to an object compatible with what is expected
530         by the backend driver for datetime columns.
531 
532         If naive datetime is passed assumes that is in UTC. Normally Django
533         models.DateTimeField makes sure that if USE_TZ is True passed datetime
534         is timezone aware.
535         """
536 
537         if value is None:
538             return None
539 
540         # Expression values are adapted by the database.
541         if hasattr(value, 'resolve_expression'):
542             return value
543 
544         # cx_Oracle doesn't support tz-aware datetimes
545         if timezone.is_aware(value):
546             if settings.USE_TZ:
547                 value = timezone.make_naive(value, self.connection.timezone)
548             else:
549                 raise ValueError("Oracle backend does not support timezone-aware datetimes when USE_TZ is False.")
550 
551         return Oracle_datetime.from_datetime(value)
552 
553     def adapt_timefield_value(self, value):
554         if value is None:
555             return None
556 
557         # Expression values are adapted by the database.
558         if hasattr(value, 'resolve_expression'):
559             return value
560 
561         if isinstance(value, str):
562             return datetime.datetime.strptime(value, '%H:%M:%S')
563 
564         # Oracle doesn't support tz-aware times
565         if timezone.is_aware(value):
566             raise ValueError("Oracle backend does not support timezone-aware times.")
567 
568         return Oracle_datetime(1900, 1, 1, value.hour, value.minute,
569                                value.second, value.microsecond)
570 
571     def combine_expression(self, connector, sub_expressions):
572         lhs, rhs = sub_expressions
573         if connector == '%%':
574             return 'MOD(%s)' % ','.join(sub_expressions)
575         elif connector == '&':
576             return 'BITAND(%s)' % ','.join(sub_expressions)
577         elif connector == '|':
578             return 'BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s' % {'lhs': lhs, 'rhs': rhs}
579         elif connector == '<<':
580             return '(%(lhs)s * POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
581         elif connector == '>>':
582             return 'FLOOR(%(lhs)s / POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
583         elif connector == '^':
584             return 'POWER(%s)' % ','.join(sub_expressions)
585         elif connector == '#':
586             raise NotSupportedError('Bitwise XOR is not supported in Oracle.')
587         return super().combine_expression(connector, sub_expressions)
588 
589     def _get_no_autofield_sequence_name(self, table):
590         """
591         Manually created sequence name to keep backward compatibility for
592         AutoFields that aren't Oracle identity columns.
593         """
594         name_length = self.max_name_length() - 3
595         return '%s_SQ' % truncate_name(strip_quotes(table), name_length).upper()
596 
597     def _get_sequence_name(self, cursor, table, pk_name):
598         cursor.execute("""
599             SELECT sequence_name
600             FROM user_tab_identity_cols
601             WHERE table_name = UPPER(%s)
602             AND column_name = UPPER(%s)""", [table, pk_name])
603         row = cursor.fetchone()
604         return self._get_no_autofield_sequence_name(table) if row is None else row[0]
605 
606     def bulk_insert_sql(self, fields, placeholder_rows):
607         query = []
608         for row in placeholder_rows:
609             select = []
610             for i, placeholder in enumerate(row):
611                 # A model without any fields has fields=[None].
612                 if fields[i]:
613                     internal_type = getattr(fields[i], 'target_field', fields[i]).get_internal_type()
614                     placeholder = BulkInsertMapper.types.get(internal_type, '%s') % placeholder
615                 # Add columns aliases to the first select to avoid "ORA-00918:
616                 # column ambiguously defined" when two or more columns in the
617                 # first select have the same value.
618                 if not query:
619                     placeholder = '%s col_%s' % (placeholder, i)
620                 select.append(placeholder)
621             query.append('SELECT %s FROM DUAL' % ', '.join(select))
622         # Bulk insert to tables with Oracle identity columns causes Oracle to
623         # add sequence.nextval to it. Sequence.nextval cannot be used with the
624         # UNION operator. To prevent incorrect SQL, move UNION to a subquery.
625         return 'SELECT * FROM (%s)' % ' UNION ALL '.join(query)
626 
627     def subtract_temporals(self, internal_type, lhs, rhs):
628         if internal_type == 'DateField':
629             lhs_sql, lhs_params = lhs
630             rhs_sql, rhs_params = rhs
631             params = (*lhs_params, *rhs_params)
632             return "NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')" % (lhs_sql, rhs_sql), params
633         return super().subtract_temporals(internal_type, lhs, rhs)
634 
635     def bulk_batch_size(self, fields, objs):
636         """Oracle restricts the number of parameters in a query."""
637         if fields:
638             return self.connection.features.max_query_params // len(fields)
639         return len(objs)
640 
641     def conditional_expression_supported_in_where_clause(self, expression):
642         """
643         Oracle supports only EXISTS(...) or filters in the WHERE clause, others
644         must be compared with True.
645         """
646         if isinstance(expression, (Exists, WhereNode)):
647             return True
648         if isinstance(expression, ExpressionWrapper) and expression.conditional:
649             return self.conditional_expression_supported_in_where_clause(expression.expression)
650         if isinstance(expression, RawSQL) and expression.conditional:
651             return True
652         return False

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/postgresql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
7 class DatabaseOperations(BaseDatabaseOperations):
8     cast_char_field_without_max_length = 'varchar'
9     explain_prefix = 'EXPLAIN'
10     cast_data_types = {
11         'AutoField': 'integer',
12         'BigAutoField': 'bigint',
13         'SmallAutoField': 'smallint',
14     }
15 
16     def unification_cast_sql(self, output_field):
17         internal_type = output_field.get_internal_type()
18         if internal_type in ("GenericIPAddressField", "IPAddressField", "TimeField", "UUIDField"):
19             # PostgreSQL will resolve a union as type 'text' if input types are
20             # 'unknown'.
21             # https://www.postgresql.org/docs/current/typeconv-union-case.html
22             # These fields cannot be implicitly cast back in the default
23             # PostgreSQL configuration so we need to explicitly cast them.
24             # We must also remove components of the type within brackets:
25             # varchar(255) -> varchar.
26             return 'CAST(%%s AS %s)' % output_field.db_type(self.connection).split('(')[0]
27         return '%s'
28 
29     def date_extract_sql(self, lookup_type, field_name):
30         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
31         if lookup_type == 'week_day':
32             # For consistency across backends, we return Sunday=1, Saturday=7.
33             return "EXTRACT('dow' FROM %s) + 1" % field_name
34         elif lookup_type == 'iso_week_day':
35             return "EXTRACT('isodow' FROM %s)" % field_name
36         elif lookup_type == 'iso_year':
37             return "EXTRACT('isoyear' FROM %s)" % field_name
38         else:
39             return "EXTRACT('%s' FROM %s)" % (lookup_type, field_name)
40 
41     def date_trunc_sql(self, lookup_type, field_name):
42         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
43         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
44 
45     def _prepare_tzname_delta(self, tzname):
46         if '+' in tzname:
47             return tzname.replace('+', '-')
48         elif '-' in tzname:
49             return tzname.replace('-', '+')
50         return tzname
51 
52     def _convert_field_to_tz(self, field_name, tzname):
53         if settings.USE_TZ:
54             field_name = "%s AT TIME ZONE '%s'" % (field_name, self._prepare_tzname_delta(tzname))
55         return field_name
56 
57     def datetime_cast_date_sql(self, field_name, tzname):
58         field_name = self._convert_field_to_tz(field_name, tzname)
59         return '(%s)::date' % field_name
60 
61     def datetime_cast_time_sql(self, field_name, tzname):
62         field_name = self._convert_field_to_tz(field_name, tzname)
63         return '(%s)::time' % field_name
64 
65     def datetime_extract_sql(self, lookup_type, field_name, tzname):
66         field_name = self._convert_field_to_tz(field_name, tzname)
67         return self.date_extract_sql(lookup_type, field_name)
68 
69     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
70         field_name = self._convert_field_to_tz(field_name, tzname)
71         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
72         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
73 
74     def time_trunc_sql(self, lookup_type, field_name):
75         return "DATE_TRUNC('%s', %s)::time" % (lookup_type, field_name)
76 
77     def deferrable_sql(self):
78         return " DEFERRABLE INITIALLY DEFERRED"
79 
80     def fetch_returned_insert_rows(self, cursor):
81         """
82         Given a cursor object that has just performed an INSERT...RETURNING
83         statement into a table, return the tuple of returned data.
84         """
85         return cursor.fetchall()
86 
87     def lookup_cast(self, lookup_type, internal_type=None):
88         lookup = '%s'
89 
90         # Cast text lookups to text to allow things like filter(x__contains=4)
91         if lookup_type in ('iexact', 'contains', 'icontains', 'startswith',
92                            'istartswith', 'endswith', 'iendswith', 'regex', 'iregex'):
93             if internal_type in ('IPAddressField', 'GenericIPAddressField'):
94                 lookup = "HOST(%s)"
95             elif internal_type in ('CICharField', 'CIEmailField', 'CITextField'):
96                 lookup = '%s::citext'
97             else:
98                 lookup = "%s::text"
99 
100         # Use UPPER(x) for case-insensitive lookups; it's faster.
101         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
102             lookup = 'UPPER(%s)' % lookup
103 
104         return lookup
105 
106     def no_limit_value(self):
107         return None
108 
109     def prepare_sql_script(self, sql):
110         return [sql]
111 
112     def quote_name(self, name):
113         if name.startswith('"') and name.endswith('"'):
114             return name  # Quoting once is enough.
115         return '"%s"' % name
116 
117     def set_time_zone_sql(self):
118         return "SET TIME ZONE %s"
119 
120     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
121         if not tables:
122             return []
123 
124         # Perform a single SQL 'TRUNCATE x, y, z...;' statement. It allows us
125         # to truncate tables referenced by a foreign key in any other table.
126         sql_parts = [
127             style.SQL_KEYWORD('TRUNCATE'),
128             ', '.join(style.SQL_FIELD(self.quote_name(table)) for table in tables),
129         ]
130         if reset_sequences:
131             sql_parts.append(style.SQL_KEYWORD('RESTART IDENTITY'))
132         if allow_cascade:
133             sql_parts.append(style.SQL_KEYWORD('CASCADE'))
134         return ['%s;' % ' '.join(sql_parts)]
135 
136     def sequence_reset_by_name_sql(self, style, sequences):
137         # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements
138         # to reset sequence indices
139         sql = []
140         for sequence_info in sequences:
141             table_name = sequence_info['table']
142             # 'id' will be the case if it's an m2m using an autogenerated
143             # intermediate table (see BaseDatabaseIntrospection.sequence_list).
144             column_name = sequence_info['column'] or 'id'
145             sql.append("%s setval(pg_get_serial_sequence('%s','%s'), 1, false);" % (
146                 style.SQL_KEYWORD('SELECT'),
147                 style.SQL_TABLE(self.quote_name(table_name)),
148                 style.SQL_FIELD(column_name),
149             ))
150         return sql
151 
152     def tablespace_sql(self, tablespace, inline=False):
153         if inline:
154             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
155         else:
156             return "TABLESPACE %s" % self.quote_name(tablespace)
157 
158     def sequence_reset_sql(self, style, model_list):
159         from django.db import models
160         output = []
161         qn = self.quote_name
162         for model in model_list:
163             # Use `coalesce` to set the sequence for each model to the max pk value if there are records,
164             # or 1 if there are none. Set the `is_called` property (the third argument to `setval`) to true
165             # if there are records (as the max pk value is already in use), otherwise set it to false.
166             # Use pg_get_serial_sequence to get the underlying sequence name from the table name
167             # and column name (available since PostgreSQL 8)
168 
169             for f in model._meta.local_fields:
170                 if isinstance(f, models.AutoField):
171                     output.append(
172                         "%s setval(pg_get_serial_sequence('%s','%s'), "
173                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
174                             style.SQL_KEYWORD('SELECT'),
175                             style.SQL_TABLE(qn(model._meta.db_table)),
176                             style.SQL_FIELD(f.column),
177                             style.SQL_FIELD(qn(f.column)),
178                             style.SQL_FIELD(qn(f.column)),
179                             style.SQL_KEYWORD('IS NOT'),
180                             style.SQL_KEYWORD('FROM'),
181                             style.SQL_TABLE(qn(model._meta.db_table)),
182                         )
183                     )
184                     break  # Only one AutoField is allowed per model, so don't bother continuing.
185             for f in model._meta.many_to_many:
186                 if not f.remote_field.through:
187                     output.append(
188                         "%s setval(pg_get_serial_sequence('%s','%s'), "
189                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
190                             style.SQL_KEYWORD('SELECT'),
191                             style.SQL_TABLE(qn(f.m2m_db_table())),
192                             style.SQL_FIELD('id'),
193                             style.SQL_FIELD(qn('id')),
194                             style.SQL_FIELD(qn('id')),
195                             style.SQL_KEYWORD('IS NOT'),
196                             style.SQL_KEYWORD('FROM'),
197                             style.SQL_TABLE(qn(f.m2m_db_table()))
198                         )
199                     )
200         return output
201 
202     def prep_for_iexact_query(self, x):
203         return x
204 
205     def max_name_length(self):
206         """
207         Return the maximum length of an identifier.
208 
209         The maximum length of an identifier is 63 by default, but can be
210         changed by recompiling PostgreSQL after editing the NAMEDATALEN
211         macro in src/include/pg_config_manual.h.
212 
213         This implementation returns 63, but can be overridden by a custom
214         database backend that inherits most of its behavior from this one.
215         """
216         return 63
217 
218     def distinct_sql(self, fields, params):
219         if fields:
220             params = [param for param_list in params for param in param_list]
221             return (['DISTINCT ON (%s)' % ', '.join(fields)], params)
222         else:
223             return ['DISTINCT'], []
224 
225     def last_executed_query(self, cursor, sql, params):
226         # https://www.psycopg.org/docs/cursor.html#cursor.query
227         # The query attribute is a Psycopg extension to the DB API 2.0.
228         if cursor.query is not None:
229             return cursor.query.decode()
230         return None
231 
232     def return_insert_columns(self, fields):
233         if not fields:
234             return '', ()
235         columns = [
236             '%s.%s' % (
237                 self.quote_name(field.model._meta.db_table),
238                 self.quote_name(field.column),
239             ) for field in fields
240         ]
241         return 'RETURNING %s' % ', '.join(columns), ()
242 
243     def bulk_insert_sql(self, fields, placeholder_rows):
244         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
245         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
246         return "VALUES " + values_sql
247 
248     def adapt_datefield_value(self, value):
249         return value
250 
251     def adapt_datetimefield_value(self, value):
252         return value
253 
254     def adapt_timefield_value(self, value):
255         return value
256 
257     def adapt_ipaddressfield_value(self, value):
258         if value:
259             return Inet(value)
260         return None
261 
262     def subtract_temporals(self, internal_type, lhs, rhs):
263         if internal_type == 'DateField':
264             lhs_sql, lhs_params = lhs
265             rhs_sql, rhs_params = rhs
266             params = (*lhs_params, *rhs_params)
267             return "(interval '1 day' * (%s - %s))" % (lhs_sql, rhs_sql), params
268         return super().subtract_temporals(internal_type, lhs, rhs)
269 
270     def explain_query_prefix(self, format=None, **options):
271         prefix = super().explain_query_prefix(format)
272         extra = {}
273         if format:
274             extra['FORMAT'] = format
275         if options:
276             extra.update({
277                 name.upper(): 'true' if value else 'false'
278                 for name, value in options.items()
279             })
280         if extra:
281             prefix += ' (%s)' % ', '.join('%s %s' % i for i in extra.items())
282         return prefix
283 
284     def ignore_conflicts_suffix_sql(self, ignore_conflicts=None):
285         return 'ON CONFLICT DO NOTHING' if ignore_conflicts else super().ignore_conflicts_suffix_sql(ignore_conflicts)

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/mysql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
10 class DatabaseOperations(BaseDatabaseOperations):
11     compiler_module = "django.db.backends.mysql.compiler"
12 
13     # MySQL stores positive fields as UNSIGNED ints.
14     integer_field_ranges = {
15         **BaseDatabaseOperations.integer_field_ranges,
16         'PositiveSmallIntegerField': (0, 65535),
17         'PositiveIntegerField': (0, 4294967295),
18         'PositiveBigIntegerField': (0, 18446744073709551615),
19     }
20     cast_data_types = {
21         'AutoField': 'signed integer',
22         'BigAutoField': 'signed integer',
23         'SmallAutoField': 'signed integer',
24         'CharField': 'char(%(max_length)s)',
25         'DecimalField': 'decimal(%(max_digits)s, %(decimal_places)s)',
26         'TextField': 'char',
27         'IntegerField': 'signed integer',
28         'BigIntegerField': 'signed integer',
29         'SmallIntegerField': 'signed integer',
30         'PositiveBigIntegerField': 'unsigned integer',
31         'PositiveIntegerField': 'unsigned integer',
32         'PositiveSmallIntegerField': 'unsigned integer',
33     }
34     cast_char_field_without_max_length = 'char'
35     explain_prefix = 'EXPLAIN'
36 
37     def date_extract_sql(self, lookup_type, field_name):
38         # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html
39         if lookup_type == 'week_day':
40             # DAYOFWEEK() returns an integer, 1-7, Sunday=1.
41             return "DAYOFWEEK(%s)" % field_name
42         elif lookup_type == 'iso_week_day':
43             # WEEKDAY() returns an integer, 0-6, Monday=0.
44             return "WEEKDAY(%s) + 1" % field_name
45         elif lookup_type == 'week':
46             # Override the value of default_week_format for consistency with
47             # other database backends.
48             # Mode 3: Monday, 1-53, with 4 or more days this year.
49             return "WEEK(%s, 3)" % field_name
50         elif lookup_type == 'iso_year':
51             # Get the year part from the YEARWEEK function, which returns a
52             # number as year * 100 + week.
53             return "TRUNCATE(YEARWEEK(%s, 3), -2) / 100" % field_name
54         else:
55             # EXTRACT returns 1-53 based on ISO-8601 for the week number.
56             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
57 
58     def date_trunc_sql(self, lookup_type, field_name):
59         fields = {
60             'year': '%%Y-01-01',
61             'month': '%%Y-%%m-01',
62         }  # Use double percents to escape.
63         if lookup_type in fields:
64             format_str = fields[lookup_type]
65             return "CAST(DATE_FORMAT(%s, '%s') AS DATE)" % (field_name, format_str)
66         elif lookup_type == 'quarter':
67             return "MAKEDATE(YEAR(%s), 1) + INTERVAL QUARTER(%s) QUARTER - INTERVAL 1 QUARTER" % (
68                 field_name, field_name
69             )
70         elif lookup_type == 'week':
71             return "DATE_SUB(%s, INTERVAL WEEKDAY(%s) DAY)" % (
72                 field_name, field_name
73             )
74         else:
75             return "DATE(%s)" % (field_name)
76 
77     def _prepare_tzname_delta(self, tzname):
78         if '+' in tzname:
79             return tzname[tzname.find('+'):]
80         elif '-' in tzname:
81             return tzname[tzname.find('-'):]
82         return tzname
83 
84     def _convert_field_to_tz(self, field_name, tzname):
85         if settings.USE_TZ and self.connection.timezone_name != tzname:
86             field_name = "CONVERT_TZ(%s, '%s', '%s')" % (
87                 field_name,
88                 self.connection.timezone_name,
89                 self._prepare_tzname_delta(tzname),
90             )
91         return field_name
92 
93     def datetime_cast_date_sql(self, field_name, tzname):
94         field_name = self._convert_field_to_tz(field_name, tzname)
95         return "DATE(%s)" % field_name
96 
97     def datetime_cast_time_sql(self, field_name, tzname):
98         field_name = self._convert_field_to_tz(field_name, tzname)
99         return "TIME(%s)" % field_name
100 
101     def datetime_extract_sql(self, lookup_type, field_name, tzname):
102         field_name = self._convert_field_to_tz(field_name, tzname)
103         return self.date_extract_sql(lookup_type, field_name)
104 
105     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
106         field_name = self._convert_field_to_tz(field_name, tzname)
107         fields = ['year', 'month', 'day', 'hour', 'minute', 'second']
108         format = ('%%Y-', '%%m', '-%%d', ' %%H:', '%%i', ':%%s')  # Use double percents to escape.
109         format_def = ('0000-', '01', '-01', ' 00:', '00', ':00')
110         if lookup_type == 'quarter':
111             return (
112                 "CAST(DATE_FORMAT(MAKEDATE(YEAR({field_name}), 1) + "
113                 "INTERVAL QUARTER({field_name}) QUARTER - " +
114                 "INTERVAL 1 QUARTER, '%%Y-%%m-01 00:00:00') AS DATETIME)"
115             ).format(field_name=field_name)
116         if lookup_type == 'week':
117             return (
118                 "CAST(DATE_FORMAT(DATE_SUB({field_name}, "
119                 "INTERVAL WEEKDAY({field_name}) DAY), "
120                 "'%%Y-%%m-%%d 00:00:00') AS DATETIME)"
121             ).format(field_name=field_name)
122         try:
123             i = fields.index(lookup_type) + 1
124         except ValueError:
125             sql = field_name
126         else:
127             format_str = ''.join(format[:i] + format_def[i:])
128             sql = "CAST(DATE_FORMAT(%s, '%s') AS DATETIME)" % (field_name, format_str)
129         return sql
130 
131     def time_trunc_sql(self, lookup_type, field_name):
132         fields = {
133             'hour': '%%H:00:00',
134             'minute': '%%H:%%i:00',
135             'second': '%%H:%%i:%%s',
136         }  # Use double percents to escape.
137         if lookup_type in fields:
138             format_str = fields[lookup_type]
139             return "CAST(DATE_FORMAT(%s, '%s') AS TIME)" % (field_name, format_str)
140         else:
141             return "TIME(%s)" % (field_name)
142 
143     def date_interval_sql(self, timedelta):
144         return 'INTERVAL %s MICROSECOND' % duration_microseconds(timedelta)
145 
146     def fetch_returned_insert_rows(self, cursor):
147         """
148         Given a cursor object that has just performed an INSERT...RETURNING
149         statement into a table, return the tuple of returned data.
150         """
151         return cursor.fetchall()
152 
153     def format_for_duration_arithmetic(self, sql):
154         return 'INTERVAL %s MICROSECOND' % sql
155 
156     def force_no_ordering(self):
157         """
158         "ORDER BY NULL" prevents MySQL from implicitly ordering by grouped
159         columns. If no ordering would otherwise be applied, we don't want any
160         implicit sorting going on.
161         """
162         return [(None, ("NULL", [], False))]
163 
164     def last_executed_query(self, cursor, sql, params):
165         # With MySQLdb, cursor objects have an (undocumented) "_executed"
166         # attribute where the exact query sent to the database is saved.
167         # See MySQLdb/cursors.py in the source distribution.
168         # MySQLdb returns string, PyMySQL bytes.
169         return force_str(getattr(cursor, '_executed', None), errors='replace')
170 
171     def no_limit_value(self):
172         # 2**64 - 1, as recommended by the MySQL documentation
173         return 18446744073709551615
174 
175     def quote_name(self, name):
176         if name.startswith("`") and name.endswith("`"):
177             return name  # Quoting once is enough.
178         return "`%s`" % name
179 
180     def random_function_sql(self):
181         return 'RAND()'
182 
183     def return_insert_columns(self, fields):
184         # MySQL and MariaDB < 10.5.0 don't support an INSERT...RETURNING
185         # statement.
186         if not fields:
187             return '', ()
188         columns = [
189             '%s.%s' % (
190                 self.quote_name(field.model._meta.db_table),
191                 self.quote_name(field.column),
192             ) for field in fields
193         ]
194         return 'RETURNING %s' % ', '.join(columns), ()
195 
196     def sql_flush(self, style, tables, *, reset_sequences=False, allow_cascade=False):
197         if not tables:
198             return []
199 
200         sql = ['SET FOREIGN_KEY_CHECKS = 0;']
201         if reset_sequences:
202             # It's faster to TRUNCATE tables that require a sequence reset
203             # since ALTER TABLE AUTO_INCREMENT is slower than TRUNCATE.
204             sql.extend(
205                 '%s %s;' % (
206                     style.SQL_KEYWORD('TRUNCATE'),
207                     style.SQL_FIELD(self.quote_name(table_name)),
208                 ) for table_name in tables
209             )
210         else:
211             # Otherwise issue a simple DELETE since it's faster than TRUNCATE
212             # and preserves sequences.
213             sql.extend(
214                 '%s %s %s;' % (
215                     style.SQL_KEYWORD('DELETE'),
216                     style.SQL_KEYWORD('FROM'),
217                     style.SQL_FIELD(self.quote_name(table_name)),
218                 ) for table_name in tables
219             )
220         sql.append('SET FOREIGN_KEY_CHECKS = 1;')
221         return sql
222 
223     def sequence_reset_by_name_sql(self, style, sequences):
224         return [
225             '%s %s %s %s = 1;' % (
226                 style.SQL_KEYWORD('ALTER'),
227                 style.SQL_KEYWORD('TABLE'),
228                 style.SQL_FIELD(self.quote_name(sequence_info['table'])),
229                 style.SQL_FIELD('AUTO_INCREMENT'),
230             ) for sequence_info in sequences
231         ]
232 
233     def validate_autopk_value(self, value):
234         # MySQLism: zero in AUTO_INCREMENT field does not work. Refs #17653.
235         if value == 0:
236             raise ValueError('The database backend does not accept 0 as a '
237                              'value for AutoField.')
238         return value
239 
240     def adapt_datetimefield_value(self, value):
241         if value is None:
242             return None
243 
244         # Expression values are adapted by the database.
245         if hasattr(value, 'resolve_expression'):
246             return value
247 
248         # MySQL doesn't support tz-aware datetimes
249         if timezone.is_aware(value):
250             if settings.USE_TZ:
251                 value = timezone.make_naive(value, self.connection.timezone)
252             else:
253                 raise ValueError("MySQL backend does not support timezone-aware datetimes when USE_TZ is False.")
254         return str(value)
255 
256     def adapt_timefield_value(self, value):
257         if value is None:
258             return None
259 
260         # Expression values are adapted by the database.
261         if hasattr(value, 'resolve_expression'):
262             return value
263 
264         # MySQL doesn't support tz-aware times
265         if timezone.is_aware(value):
266             raise ValueError("MySQL backend does not support timezone-aware times.")
267 
268         return str(value)
269 
270     def max_name_length(self):
271         return 64
272 
273     def bulk_insert_sql(self, fields, placeholder_rows):
274         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
275         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
276         return "VALUES " + values_sql
277 
278     def combine_expression(self, connector, sub_expressions):
279         if connector == '^':
280             return 'POW(%s)' % ','.join(sub_expressions)
281         # Convert the result to a signed integer since MySQL's binary operators
282         # return an unsigned integer.
283         elif connector in ('&', '|', '<<', '#'):
284             connector = '^' if connector == '#' else connector
285             return 'CONVERT(%s, SIGNED)' % connector.join(sub_expressions)
286         elif connector == '>>':
287             lhs, rhs = sub_expressions
288             return 'FLOOR(%(lhs)s / POW(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
289         return super().combine_expression(connector, sub_expressions)
290 
291     def get_db_converters(self, expression):
292         converters = super().get_db_converters(expression)
293         internal_type = expression.output_field.get_internal_type()
294         if internal_type in ['BooleanField', 'NullBooleanField']:
295             converters.append(self.convert_booleanfield_value)
296         elif internal_type == 'DateTimeField':
297             if settings.USE_TZ:
298                 converters.append(self.convert_datetimefield_value)
299         elif internal_type == 'UUIDField':
300             converters.append(self.convert_uuidfield_value)
301         return converters
302 
303     def convert_booleanfield_value(self, value, expression, connection):
304         if value in (0, 1):
305             value = bool(value)
306         return value
307 
308     def convert_datetimefield_value(self, value, expression, connection):
309         if value is not None:
310             value = timezone.make_aware(value, self.connection.timezone)
311         return value
312 
313     def convert_uuidfield_value(self, value, expression, connection):
314         if value is not None:
315             value = uuid.UUID(value)
316         return value
317 
318     def binary_placeholder_sql(self, value):
319         return '_binary %s' if value is not None and not hasattr(value, 'as_sql') else '%s'
320 
321     def subtract_temporals(self, internal_type, lhs, rhs):
322         lhs_sql, lhs_params = lhs
323         rhs_sql, rhs_params = rhs
324         if internal_type == 'TimeField':
325             if self.connection.mysql_is_mariadb:
326                 # MariaDB includes the microsecond component in TIME_TO_SEC as
327                 # a decimal. MySQL returns an integer without microseconds.
328                 return 'CAST((TIME_TO_SEC(%(lhs)s) - TIME_TO_SEC(%(rhs)s)) * 1000000 AS SIGNED)' % {
329                     'lhs': lhs_sql, 'rhs': rhs_sql
330                 }, (*lhs_params, *rhs_params)
331             return (
332                 "((TIME_TO_SEC(%(lhs)s) * 1000000 + MICROSECOND(%(lhs)s)) -"
333                 " (TIME_TO_SEC(%(rhs)s) * 1000000 + MICROSECOND(%(rhs)s)))"
334             ) % {'lhs': lhs_sql, 'rhs': rhs_sql}, tuple(lhs_params) * 2 + tuple(rhs_params) * 2
335         params = (*rhs_params, *lhs_params)
336         return "TIMESTAMPDIFF(MICROSECOND, %s, %s)" % (rhs_sql, lhs_sql), params
337 
338     def explain_query_prefix(self, format=None, **options):
339         # Alias MySQL's TRADITIONAL to TEXT for consistency with other backends.
340         if format and format.upper() == 'TEXT':
341             format = 'TRADITIONAL'
342         elif not format and 'TREE' in self.connection.features.supported_explain_formats:
343             # Use TREE by default (if supported) as it's more informative.
344             format = 'TREE'
345         analyze = options.pop('analyze', False)
346         prefix = super().explain_query_prefix(format, **options)
347         if analyze and self.connection.features.supports_explain_analyze:
348             # MariaDB uses ANALYZE instead of EXPLAIN ANALYZE.
349             prefix = 'ANALYZE' if self.connection.mysql_is_mariadb else prefix + ' ANALYZE'
350         if format and not (analyze and not self.connection.mysql_is_mariadb):
351             # Only MariaDB supports the analyze option with formats.
352             prefix += ' FORMAT=%s' % format
353         if self.connection.features.needs_explain_extended and not analyze and format is None:
354             # ANALYZE, EXTENDED, and FORMAT are mutually exclusive options.
355             prefix += ' EXTENDED'
356         return prefix
357 
358     def regex_lookup(self, lookup_type):
359         # REGEXP BINARY doesn't work correctly in MySQL 8+ and REGEXP_LIKE
360         # doesn't exist in MySQL 5.6 or in MariaDB.
361         if self.connection.mysql_version < (8, 0, 0) or self.connection.mysql_is_mariadb:
362             if lookup_type == 'regex':
363                 return '%s REGEXP BINARY %s'
364             return '%s REGEXP %s'
365 
366         match_option = 'c' if lookup_type == 'regex' else 'i'
367         return "REGEXP_LIKE(%%s, %%s, '%s')" % match_option
368 
369     def insert_statement(self, ignore_conflicts=False):
370         return 'INSERT IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>, <file>django/db/backends/dummy/base.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
29 class DatabaseOperations(BaseDatabaseOperations):
30     quote_name = complain

</code><intended_behavior>The `execute_sql_flush` method's signature should be modified to remove the `using` parameter. Instead, use `self.connection.alias` internally.</intended_behavior>]
2025-10-17 11:42:39.263 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-17 11:42:39.263 | INFO     | Search-only: skipping patch selection
2025-10-17 11:42:39.409 | INFO     | Task django__django-12741 completed successfully.
2025-10-17 11:42:39.410 | INFO     | No patch generated. You can try running ACR again.
