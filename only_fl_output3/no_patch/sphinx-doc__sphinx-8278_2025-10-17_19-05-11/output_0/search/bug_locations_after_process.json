[
    {
        "rel_file_path": "sphinx/util/docstrings.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.3/sphinx/util/docstrings.py",
        "start": 1,
        "end": 102,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.docstrings\n3     ~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Utilities for docstring processing.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import sys\n13 import warnings\n14 from typing import Dict, List\n15 \n16 from docutils.parsers.rst.states import Body\n17 \n18 from sphinx.deprecation import RemovedInSphinx50Warning\n19 \n20 \n21 field_list_item_re = re.compile(Body.patterns['field_marker'])\n22 \n23 \n24 def extract_metadata(s: str) -> Dict[str, str]:\n25     \"\"\"Extract metadata from docstring.\"\"\"\n26     in_other_element = False\n27     metadata = {}  # type: Dict[str, str]\n28 \n29     if not s:\n30         return metadata\n31 \n32     for line in prepare_docstring(s):\n33         if line.strip() == '':\n34             in_other_element = False\n35         else:\n36             matched = field_list_item_re.match(line)\n37             if matched and not in_other_element:\n38                 field_name = matched.group()[1:].split(':', 1)[0]\n39                 if field_name.startswith('meta '):\n40                     name = field_name[5:].strip()\n41                     metadata[name] = line[matched.end():].strip()\n42             else:\n43                 in_other_element = True\n44 \n45     return metadata\n46 \n47 \n48 def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]:\n49     \"\"\"Convert a docstring into lines of parseable reST.  Remove common leading\n50     indentation, where the indentation of a given number of lines (usually just\n51     one) is ignored.\n52 \n53     Return the docstring as a list of lines usable for inserting into a docutils\n54     ViewList (used as argument of nested_parse().)  An empty line is added to\n55     act as a separator between this docstring and following content.\n56     \"\"\"\n57     if ignore is None:\n58         ignore = 1\n59     else:\n60         warnings.warn(\"The 'ignore' argument to prepare_docstring() is deprecated.\",\n61                       RemovedInSphinx50Warning, stacklevel=2)\n62 \n63     lines = s.expandtabs(tabsize).splitlines()\n64     # Find minimum indentation of any non-blank lines after ignored lines.\n65     margin = sys.maxsize\n66     for line in lines[ignore:]:\n67         content = len(line.lstrip())\n68         if content:\n69             indent = len(line) - content\n70             margin = min(margin, indent)\n71     # Remove indentation from ignored lines.\n72     for i in range(ignore):\n73         if i < len(lines):\n74             lines[i] = lines[i].lstrip()\n75     if margin < sys.maxsize:\n76         for i in range(ignore, len(lines)):\n77             lines[i] = lines[i][margin:]\n78     # Remove any leading blank lines.\n79     while lines and not lines[0]:\n80         lines.pop(0)\n81     # make sure there is an empty line at the end\n82     if lines and lines[-1]:\n83         lines.append('')\n84     return lines\n85 \n86 \n87 def prepare_commentdoc(s: str) -> List[str]:\n88     \"\"\"Extract documentation comment lines (starting with #:) and return them\n89     as a list of lines.  Returns an empty list if there is no documentation.\n90     \"\"\"\n91     result = []\n92     lines = [line.strip() for line in s.expandtabs().splitlines()]\n93     for line in lines:\n94         if line.startswith('#:'):\n95             line = line[2:]\n96             # the first space after the comment is ignored\n97             if line and line[0] == ' ':\n98                 line = line[1:]\n99             result.append(line)\n100     if result and result[-1]:\n101         result.append('')\n102     return result\n",
        "intended_behavior": "The code within `docstrings.py` responsible for parsing default values from docstrings should be modified to preserve the numeral system (e.g., hexadecimal) as it is specified in the docstring. This means adding or refining a mechanism to detect when a default value is written in hexadecimal format (or potentially other formats) and ensuring this formatting is retained in the documentation output. Specifically, this could involve enhancing the parsing utility to tag numeric values with their detected format during the parsing phase and then using this format tag during the rendering phase to maintain format consistency in the generated documentation. This change aims not to alter the existing functionality that correctly processes and displays default values in the documentation, but to extend it to handle numeric formats more accurately. This extension should be made in a way that does not disrupt other parts of Sphinx that rely on `docstrings.py` for docstring handling, ensuring backward compatibility and preserving current functionalities outside of numeric value presentation."
    }
]